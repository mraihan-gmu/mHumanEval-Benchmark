[{"task_id":"HumanEval_0","nl":"kas_Deva","pl":"hs","prompt":"--рдг реН реН реН реН реН реН------- рдпреЗ рдЫреА рдПрд╡рдВ рд╡реБрдЪрдиреЗ рдХреА рдХрд╣реАрдВ рдЫреА рдХрд╣реАрдВ рдЬрд╝реЗ рдирдВрдмрд░ рдЖрд╕рд╛рди реЛрдиреЗ рд╕реЗрде--  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =","canonical_solution":"hasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold = any (\\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a \/= b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_1","nl":"kas_Deva","pl":"hs","prompt":"--рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдордВрдЬрд╝ рдХрд╣рдБ рддреЗ рд╕реНрдкреЗрд╕ рдЫреВ рдЗрдирдЧреЙрд░ рдХрд░рде.--рдЕрд▓рдЧ рдЕрд▓рдЧ рдЧреНрд░реБрдк рдЫрд┐ рдмреИрд▓реЗрдВрд╕реНрдб рдЖрд╕рд╛рди (рд╣рд░ рдЕрдЦ рдУрдкрдиреБрдХ рдмреНрд░реЗрд╕ рдЫреБ рдореБрдирд╛рд╕рд┐рдм рддреЛрд░ рдмрдВрдж рдЧрдЫрд╛рди) рдд рдЕрдЦ рдЕрдХрд┐рд╕ рдореНрдиреНрдЬрд╝ рдЫреБрди рдиреЗрд╕реНрдЯ рдХрд░рд╛рдиред--рдпреЗ рдЧреНрд░реБрдк рдЕрд▓рдЧ рдЕрд▓рдЧ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдордВрдЬрд╝ рддреНрд░рд╛рд╡реБрди рддреЗрдорди рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рд╡рд╛рдкрд╕ рдХрд░реЛрдВ.--рдпреБрд╕ рдпреЗ рдлрдВрдХреНрд╢рди рдЫреА рдпреЗ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдпрд╛рде рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ рд╡рд╛рд░рд┐рдпрд╛ рдЧреНрд░реБрдк рдиреЗрд╕реНрдЯреЗрдб рдХрдВрд╕рд┐рд╕реНрдЯреЗрдВрд╕--  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =","canonical_solution":"separateParenGroups :: String -> [String]\nseparateParenGroups paren_string = go paren_string 0 [] \"\" []\n  where\n    go [] _ _ current acc = if null current then acc else acc ++ [current]\n    go (x:xs) depth stack current acc\n      | x == ' ' = go xs depth stack current acc\n      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc\n      | x == ')' =\n          let newCurrent = current ++ [x]\n              newDepth = depth - 1\n          in if newDepth == 0\n             then go xs newDepth (tail stack) \"\" (acc ++ [newCurrent])\n             else go xs newDepth (tail stack) newCurrent acc\n      | otherwise = error \"Unexpected character\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_2","nl":"kas_Deva","pl":"hs","prompt":"--рдгрдгрдгрджрдж рдгрдж рдгрдж рдгрдж рдгрдж рдгрдж рдгрдж рдгрдж рдгрдж--(рдмрдЪреЗ рд╣реБрд╡реЗ рдкрд╛рд░реНрдЯ рд╣рдореЗрд╢рд╛ 1 рдЦреЛрдд рдХрдо).--рддреЗ рдЗрдВрдЯреЗрдЧрд░ рдкрд╛рд░реНрдЯ (рджрд╛рдУ рдирдВрдмрд░ рдЦреЛрдд рд▓рдХрд┐рдЯ рдЗрдиреНрдЯреЗрдЧрд░) рддреЗ рдбреЗрд╕реАрдорд▓--рдпреБрд╕ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдлреНрд▓реЛрдЯрд┐рдВрдЧ рдкреЙрдЗрдВрдЯ рдирдВрдмрд░ рдЫреА ,рдЗ рдЫреА рдПрд╡рдВ рдбрд┐рдХреЛрдореНрдкреЛрд╕реЗрдб рдХрд░рдиреЗ--  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =","canonical_solution":"truncateNumber :: Float -> Float\ntruncateNumber number = number - fromIntegral (floor number)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_3","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ рдЕрд╕ рдиреЗ рдЕрд╕ рд╕рд╣реА рддреЗрдо рд╡рд╛рддреЛ ,рддреЛрд▓ рдЕрд╕ рдЧрд▓рдд рддреЗрдо рд╡рд╛рддреЛ--рддреЛрдп рдЫреА рдпрд╣ рдбрд┐рдЯреЗрдХреНрдЯ рдХрд░рд╛ рдХреА рдХрд╣реАрдВ рдкреИрда рдЫреА рдмреИрд▓реЗрдВрд╕ рдСрдлрд╝ рдПрдХрд╛рдЙрдВрдЯреНрд╕ рдЧрд╛рд╕рди рдЬреАрд░реЛ рдЦреЛрдд рдиреАрдЪ ,рдмреЗ--рдЕрдЦрдГ рдмреИрдВрдХ рдЕрдХрд╛рдЙрдВрдЯрд╕ рдкреЗрда рдЬрдорд╛ рддреЗ рдирд┐рдХрд╛рд╕реА рд╣реБрдиреНрдж рд▓рд┐рд╕реНрдЯ рдпреБрд╕ рд╕реЗрдд рд╢реБрд░реВ рдЫреВ рдпреЗрд╡рд╛ рдХрд░рдиреЗ--  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =","canonical_solution":"belowZero :: [Int] -> Bool\nbelowZero operations = any (< 0) $ scanl (+) 0 operations","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_4","nl":"kas_Deva","pl":"hs","prompt":"--MAD = рдФрд╕рддред x - x_meanред --рдПрд▓рд┐рдореЗрдВрдЯ рддреЗ рд╕реЗрдиреНрдЯрд░рдкреЙрдЗрдВрдЯ (рдПрдордПрдПрди рдордВрдЬрд╝):--рдореАрдиреНрд╕ рдЕрдмреНрд╕реЛрд▓реБрдЯреЗ рдбрд┐рд╡рд┐рдПрд╢рди рдЫреА рдореАрдиреНрд╕ рдЕрдмреНрд╕реЛрд▓реБрдЯреЗ рдбрд┐рдлрд░реЗрдВрд╕ рджреБрдЗрди рдордВрдЬрд╝--рд╕реЙрд░реА рдбрд╛рдЯрд╛ рдЫреА рдИрд╡рд╛ рд░рдЬрд╝рд╛рди--реЗрдХ рджреЗрд╡рди рд▓рд┐рд╕рдЯ рдЗрдирдкреБрдЯ рдиреБрдореНрдмрд░рдВ рдЦрд╛рддрд░ , рдЫреА рдХрд▓рди рдореАрдиреНрд╕ рдЕрдмреНрд╕реЛрд▓реБрдЯреЗ рдбрд┐рд╡рд┐рдПрд╢рди--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =","canonical_solution":"meanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers = sum absoluteDifferences \/ fromIntegral (length numbers)\n  where\n    mean = sum numbers \/ fromIntegral (length numbers)\n    absoluteDifferences = map (\\x -> abs (x - mean)) numbers","tests":"\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_5","nl":"kas_Deva","pl":"hs","prompt":"--тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдирдВрдмрд░рд╕ ' тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдирдВрдмрд░рд╕ ' тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдирдВрдмрд░рд╕ ' тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдирдВрдмрд░рд╕ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ тИАрдЗрдирдкреБрдЯ--  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =","canonical_solution":"intersperse :: [Int] -> Int -> [Int]\nintersperse [] _ = []\nintersperse [x] _ = [x]\nintersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_6","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓реЗ, ()) рд╣реНрдирджрд┐рд╕ рдиреЗрд╕рдЯрд┐рдВрдЧ рд▓реЗрд╡рд▓рд╕ рдореНрдиреНрдЬрд╝ рдЫрд┐ рджреЛрди рд▓реЗрд╡рд▓ рдЖрд╕рд╛рди рдпреЗрд▓рд┐ рдЬрд╝рди ()) рд╣реНрдирджрд┐рд╕ рддреНрд░реЗрди рд▓реЗрд╡рд▓рд╕ рдореНрдиреНрдЬрд╝ рдЫреБред--рд╣рд░ рдЧреНрд░реБрдк рдЦрд╛рддрд┐рд░,рдХреБрдбрд╝рди рд╣рд┐рдВрдЬ рдиреЗрд╕реНрдЯрд┐рдВрдЧ рд╣рд┐рдВрдЬ рдбреАрдк рд▓реЗрд╡рд▓ рдЖрдЙрдЯрдкреБрдЯ рдХрд░рд╛.--рдпреБрд╕ рдпреЗ рдлрдВрдХреНрд╢рди рдЫреА рдпреЗ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдпреБрд╕ рд╣рд╡рди рдЫреА рдорд▓реНрдЯреАрдкрд▓ рдЧреНрд░реБрдкреНрд╕ рдиреЗрд╕реНрдЯреЗрдб рдХрдВрд╕рд┐рд╕реНрдЯреЗрдВрдЯреНрд╕ рдЦрд╛рддрд░ рдпреБрд╕ рдЕрд▓рдЧ рдЫреА рдХрд╛рд░рди рд╕реНрдкреЗрд╕ рд╕реЗрде--  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =","canonical_solution":"parseNestedParens :: String -> [Int]\nparseNestedParens paren_string = map maxDepth (words paren_string)\n  where\n    maxDepth :: String -> Int\n    maxDepth = go 0 0\n      where\n        go :: Int -> Int -> String -> Int\n        go currentDepth maxDepth [] = maxDepth\n        go currentDepth maxDepth (c:cs)\n          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs\n          | c == ')'  = go (currentDepth - 1) maxDepth cs\n          | otherwise = go currentDepth maxDepth cs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_7","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ рдЫреА рд╕реБ рдЫреА рдлрд┐рд▓реНрдЯрд░ рдХрд╛рд░рди рд╕рд┐рд░реНрдл рддреЗрдорди рдЦрд╛рддрд░ рдпрдо рдордВрдЬрд╝ рд╕рдмрд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА--  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =","canonical_solution":"filterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring = filter (substring `isInfixOf`) strings\n  where isInfixOf = isInfixOf","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_8","nl":"kas_Deva","pl":"hs","prompt":"--реЗрдореЛ рдХреБрд░ рдЕрд╕ рд╕реБрдореНрдо рдмрд░рд╛рдмрд░ 0 рдмреЗ рдпреБрд╕ реЗрдореЛ рдХреБрд░ рдЕрд╕ рд╕реБрдореНрдо рдмрд░рд╛рдмрд░ 1--рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рдЦрд╛рддрд┐рд░,рддреЗрдо рдЕрд╕ рдЯрдкрд▓ рддреЗ рддреЗрдо рд╕рдмрдХреБрдХ рдкреНрд░реЛрдбрдХреНрдЯ рдпреБрд╕ рд╕реВрдЪрд╕ рдордВрдЬрд╝ рдЫреВ.--  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =","canonical_solution":"sumProduct :: [Int] -> (Int, Int)\nsumProduct numbers = (sum numbers, product numbers)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_9","nl":"kas_Deva","pl":"hs","prompt":"--рдгрдг рдг рдг рдг рдг рдг рдг рдг рдг--рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝,рддреЗрдо рд╡рдХрд╝рдд рддрд╛рдо рд▓рдмрдиреА рдЕрдореГрдд рдПрд▓рд┐рдореЗрдВрдЯ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рддреИрдпрд╛рд░ рдХрд░рдиреЗ.--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =","canonical_solution":"rollingMax :: [Int] -> [Int]\nrollingMax = scanl1 max","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_10","nl":"kas_Deva","pl":"hs","prompt":"--- рд╕реНрдЯреНрд░рд┐рдВрдЧ рд░рд┐рд╡рд░реНрд╕ рдХрд┐рд╕ рдПрдиреНрдбрд╕ рдкреЗрда рдЕрдХрд┐рд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкреНрд░реАрдлрд┐рдХреНрд╕рд╕ рдЬреЛрдЫреБрди рдпреБрд╕ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдорд┐рдХ рд╕рдлрд┐рдХреНрд╕ рдмрд░реЛрд╣ рдЖрд╡ред--- рдлрд╛рдИрдВрдб рдереНрд░реВ рджреАрдб рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЗрдЬ рдП рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо--рдЕрд▓реНрдЧреЛрд░рд┐рдердо рдЖрдЗрдбрд┐рдпрд╛ рдЖрд╕рд╛рди:--ЁЯУМ рдХрдореЛрд╕реНрдЯ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо рдЦреЛрдЬреЗрдВ рдЬреЛ рд╢реБрд░реВ рд╣реЛ рдЬрд╛рдпреЗ ЁЯУМ рдХрдореЛрд╕реНрдЯ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо рдЦреЛрдЬреЗрдВ рдЬреЛ рд╢реБрд░реВ рд╣реЛ рдЬрд╛рдпреЗ ЁЯУМ рдХрдореЛрд╕реНрдЯ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо рдЦреЛрдЬреЗрдВ рдЬреЛ рд╢реБрд░реВ рд╣реЛ рдЬрд╛рдпреЗ ЁЯУМ рдХрдореЛрд╕реНрдЯ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо рдЦреЛрдЬреЗрдВ рдЬреЛ рд╢реБрд░реВ рд╣реЛ рдЬрд╛рдпреЗ ЁЯУМ--  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =","canonical_solution":"makePalindrome :: String -> String\nmakePalindrome string = string ++ reverse (take (length string - palindromeLength) string)\n  where\n    palindromeLength = longestPalindromicSuffix string\n\nlongestPalindromicSuffix :: String -> Int\nlongestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]\n\nisPalindrome :: String -> Bool\nisPalindrome s = s == reverse s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_11","nl":"kas_Deva","pl":"hs","prompt":"--рдЗрдирдкреБрдЯрд╕ рдкреЗрда рдмрд╛рдЗрдирд░реА XOR рдХрд░рд╛рди рддрд╣ рдирддреАрдЬрд╕ рддрд┐ string рдХрд┐рд╕ рд╕реВрд░рддрд╕ рдордВрдЬрд╝ рд╡рд╛рдкрд╕ рдХрд░рд╛рдиред-- рдЗрдирдкреБрдЯ рдЫреЗ рдЬрд╝реЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ a рдд b рдпрд┐рдо рд╕рд┐рд░рд┐рдлрд╝ 1 рдд 0 рдЫреЗ рдЖрд╕рд╛рдиред--  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =","canonical_solution":"stringXor :: String -> String -> String\nstringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_12","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ рдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ рдЫреВ рд░рд┐рдХреНрдд,рддреЗрд▓ рдЫреВ рдиреЛрде рддреЗ рд▓рд╡рди.-- list рдСрдлрд╝ strings, return the рд▓реЙрдиреНрдЧрд╕реНрдЯ рдУрдиреЗ.  return the рдлрд░реНрд╕реНрдЯ рдУрдиреЗ рдЗрди рдХреЗрд╕ рдСрдлрд╝ рдорд▓реНрдЯреАрдкреНрд▓ --  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =","canonical_solution":"longest :: [String] -> Maybe String\nlongest [] = Nothing\nlongest strings = Just $ foldl1 (\\acc x -> if length x > length acc then x else acc) strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_13","nl":"kas_Deva","pl":"hs","prompt":"--a рддреЗ b рддреЗрдордЬ рд╡рд░реАрдп рдХрдо рдХреЙрдорди рдбрд┐рд╡реАрдЬрд╝рд░--  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =","canonical_solution":"greatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b\n  | b == 0    = a\n  | otherwise = greatestCommonDivisor b (a `mod` b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_14","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рдпреЗ рд▓рдлрд╝рдЬрд╝ рдЫреА рдпреЗ рдЫреА рджреЗрд╡рди рд╕рд╛рд░рд┐ рд╕реВрд░рдд рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдордВрдЬрд╝--  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =","canonical_solution":"allPrefixes :: String -> [String]\nallPrefixes string = [take n string | n <- [1 .. length string]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_15","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рдЕрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЕрд╕ рджреЗрд╡рди рд╕реНрдкреЗрд╕ рдбрд┐рд▓реАрдорд┐рдЯреЗрдб рдиреБрдореНрдмрд░рдВ рд╕реЗрде--  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =","canonical_solution":"stringSequence :: Int -> String\nstringSequence n = unwords $ map show [0..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_16","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рдпреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА ,рдпрд┐рд▓ рдЕрд╕ рд╡реБрдЫреЛ рдХреА рддреЗрдо рдЫреА рд╡рд░реАрдп рдЕрд▓рдЧ рд╡рд░реНрдг (рдЕрд╕ рдиреЗ рдХрд╣реАрдВ рдХреЗрд╕)--  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =","canonical_solution":"import Data.Char (toLower)\nimport Data.Set (fromList, size)\n\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string = size . fromList $ map toLower string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_17","nl":"kas_Deva","pl":"hs","prompt":"--'.рдЫреЗрдХ' -рдХреНрд╡рд╛рд░реНрдЯрд░ рдиреЛрдЯ,рдЕрдЦ рдмреАрдЯ рддрдХрд╝рд░реАрдмрди.--'рдУрд░ рд╣реЕрдб' - рд╣рд╛рдл рдиреЛрдЯ, рджреЛ рдмреАрдЯреНрд╕ рддрдХ рд░рд╣рддрд╛ рд╣реИред--'рдУ' - рдкреБрд░ рдиреЛрдЯ, рдЫреВ рдлреЛрд░ рдмреАрдЯреНрд╕ рддрд╛рдо.--рдпреЗ рдЫреА рд▓реЗрдЬреЗрдВрдб:--рдЖрдЦрд░реА рдордВрдЬрд╝рд┐рд▓ рдирд╣реАрдВред--рддреЛрд╕рд┐ рд╣рдВрджрд┐рд╕ рдХрд╛рдорд╕ рдордВрдЬрд╝ рдЫреБ рдпрд┐ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд╛рд░реНрд╕ рдХрд░рд╛рди рдд рдпрд┐рдорди рдкреВрд░реНрдгрд╛рдВрдХрди рд╣реБрдиреНрдж рд▓рд┐рд╕реНрдЯ рд╡рд╛рдкрд╕ рдХрд░рд╛рди рдпрд┐рдо рдХреБрдирд┐ рддрд┐ рддрд╛рдо рдХреНрдпрд╣ рддрд╛рдо рдмреАрдЯреНрд╕ рдХрд░рд╛рди рдЫрд┐ред--рдЗрд╕ рдлрдВрдХреНрд╢рди рдЗрдирдкреБрдЯ рдЗрд╕ a рд╕реНрдЯреНрд░рд┐рдВрдЧ representing рдореНрдпреВрдЬрд┐рдХрд▓ рдиреЛрдЯреНрд╕ рдЗрди a рд╕реНрдкреЗрд╢рд▓ ASCII рдлреЙрд░реНрдореЗрдЯ. --  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =","canonical_solution":"parseMusic :: String -> [Int]\nparseMusic music_string = map beats (words music_string)\n  where\n    beats \"o\" = 4\n    beats \"o|\" = 2\n    beats \".|\" = 1\n    beats _ = 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_18","nl":"kas_Deva","pl":"hs","prompt":"-- рдЫреБ рдкрддрд╛ рд▓рдЧрд╛рд╡рди рдЬрд╝рд┐ рдЕрдХрд┐рд╕ рд╕рдмреНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдордВрдЬрд╝ рдЫрд┐ рдХрддреА рдЧреЙрд░ рдореЛрдЬрд╝реВ рдпрд┐рд╡рд╛рди рдХрдбрдирд╛рд╡рд╛рдиред--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =","canonical_solution":"howManyTimes :: String -> String -> Int\nhowManyTimes string substring\n  | null substring = 0\n  | otherwise = length . filter isPrefixOfSubstring $ tails string\n  where\n    isPrefixOfSubstring = isPrefixOf substring\n    isPrefixOf :: Eq a => [a] -> [a] -> Bool\n    isPrefixOf prefix str = prefix `isPrefixOf` str","tests":"\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_19","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рдирдВрдмрд░ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рд▓рдХреБрдЯ рдкреЗрда рд▓рд╛рд░реНрдЬ рддрд╛рдо--рд╡реИрд▓рд┐рдб рдЪреЙрдЗрд╕ рдЫрд┐ \"рдЬрд╝реЗрд░реЛ\", \"рд╡рди\", \"рдЯреВ\", \"рдереНрд░реА\", \"рдлреЛрд░\", \"рдлрд╛рдЗрд╡\", \"рд╕рд┐рдЪреНрд╕\", \"рд╕реЗрд╡реЗрди\", \"рдУрдЯ\" рдд \"рдирд╛рд╡реЗрди\"ред--рдЗрдирдкреБрдЯ рдЫреВ рд╕реНрдкреЗрд╕-рдбрд┐рд▓реАрдорд┐рдЯреЗрдб рд╕реНрдЯреНрд░рд┐рдВрдЧ рдиреБрдорд╛рд░рд┐рдХрд╛рд▓рд╕ рдкреЗрда 'рдЬрд╝реАрд░реЛ' рдкреЗрда 'рдиреМ'.--  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =","canonical_solution":"import Data.List (sort)\nimport Data.Maybe (fromJust)\nimport Data.Map (Map, fromList, lookup)\n\nsortNumbers :: String -> String\nsortNumbers numbers = unwords $ map snd $ sort $ map (\\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)\n  where\n    wordToNumber :: Map String Int\n    wordToNumber = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4),\n                             (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_20","nl":"kas_Deva","pl":"hs","prompt":"--реЗрдореЛ рдХреБрд░ рд░рд┐рдЯрд░реНрди реЗрдорди рдХреНрд░рдорд┐рдХ (рдХрдо рдирдВрдмрд░, рд╡рд░реАрдп рдирдВрдмрд░)--рдпреБрд╕ рдирдВрдмрд░ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рд╕реВрдЪрдиреЗ (рдХрдо рд╕реЗ рдХрдо рдЬрд╝реЗ) рд╕реЗрд▓реЗрдХреНрдЯ рдХрд░реЛ рдмреЗ рджреЗ рджреЛ рдпреБрд╕ рдирдЬрд╝рджреАрдХ рдЫреА рдЖрд╕рд╛рди--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =","canonical_solution":"findClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)\n  where\n    sortedNumbers = sort numbers\n    minByDiff (a1, b1) (a2, b2)\n      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)\n      | otherwise = (a2, b2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_21","nl":"kas_Deva","pl":"hs","prompt":"--рдпреЗ рдЫреА рдПрд╡рдВ рд╡рд░реАрдп рдХрдо рдирдВрдмрд░ рджрд┐рди 0 рдмреЗ рд╡рд░реАрдп рдмрдврд╝ 1--рдпреБрд╕ рдирдВрдмрд░ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ (рдХрдо рд╕реЗ рдХрдо рдЬрд╝реЗ рдПрд▓рд┐рдореЗрдВрдЯ),рдЕрде рдЫреА рдЕрд╕ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд╛рд░рди рд▓реАрдирд┐рдпрд░ рдЯреНрд░рд╛рдВрд╕рдлреЙрд░реНрдо--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =","canonical_solution":"rescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers = map (\\x -> (x - minVal) \/ range) numbers\n  where\n    minVal = minimum numbers\n    maxVal = maximum numbers\n    range = maxVal - minVal","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_23","nl":"kas_Deva","pl":"hs","prompt":"--рд╕реЙрд░реА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рд╣реБрдиреНрдж рд▓реЛрдВрдЧрде рд╡рд╛рдкрд╕ --  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =","canonical_solution":"strlen :: String -> Int\nstrlen string = length string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_24","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ рдЕрд╕ рджрд╛рд╣ рдЕрд╕ рдирдВрдмрд░ рдПрди рдЦрд╛рддрд░ ,рдЕрде рдЫреА рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рдирдВрдмрд░ рдпреБрд╕ рдПрди рдмрд░рд╛рдмрд░ рдбрд┐рд╡рд╛рдЗрдб рдЫреА рдХрд╛рд░рди ,рдЕрд╕ рдЫреА рд╡рд░реАрдп рд▓рдХрд┐рдЯ рдПрди рдЦреЛрдд--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =","canonical_solution":"largestDivisor :: Int -> Int\nlargestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_25","nl":"kas_Deva","pl":"hs","prompt":"--рдЗрдирдкреБрдЯ рдирдВрдмрд░ рд╣рдХреЛ рдЕрд╕ рдмрд░рд╛рдмрд░ рдкреНрд░реЛрдбрдХреНрдЯ рдСрдлрд╝ рд╕рд▓реАрдо рдлреИрдХреНрдЯрд░реНрд╕ --рд╣рд░ рдЖрдЦрдГ рдлреИрдХреНрдЯрд░ рдЧрд╕рдг рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рдПрдореН рдЫреА рдПрд╡рдВ рдлреИрдХреНрдЯрд░рд╛рдЗрдЬреЗрд╢рди рдордВрдЬрд╝-- рдЫреВ рдЬрд╝рдпрд╛рдж рдЖрд╕рд╛рди рддреЗрдо реБрдиреНрджрд╕ рд╕реЗрде рдпреБрд╕ рдЗрдиреНрдЯрд┐рдЬрд░ рдЫреВ рддреЗрдо рдЫреВ рдЬрд╝рдпрд╛рдж рдЖрд╕рд╛рди--  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =","canonical_solution":"factorize :: Int -> [Int]\nfactorize n = factorize' n 2\n  where\n    factorize' 1 _ = []\n    factorize' m f\n      | m `mod` f == 0 = f : factorize' (m `div` f) f\n      | otherwise      = factorize' m (f + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_26","nl":"kas_Deva","pl":"hs","prompt":"--рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣рд┐рдВрдЬ рдСрд░реНрдбрд░ рдЫреВ рдмрд╛рдпреЗ рд╢рд╛рдореЗ рдЗрдирдкреБрдЯ рдХрд┐ рддреИрд░ рдкрдЗрда.--рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝,рд╕реБ рдЫреА рд╕реБ рдЪреАрдЬрд╝ рджреВрд░ рдХрд╛рд░рди рдпреБрд╕ рдЬрд╝рдпрд╛рдж рдЫреА рдПрд╡рдВ--  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =","canonical_solution":"removeDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers = filter (\\x -> count x numbers == 1) numbers\n  where\n    count x = length . filter (== x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_27","nl":"kas_Deva","pl":"hs","prompt":"-- рдХреБрдирд┐ рджрд┐рд╢рд╛рдирд┐ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЦрд╛рддреНрд░рд┐, рд▓рдХреНрдЬрд╝рд░реА рд╡рд░реНрдг рдмрдбрд╝рд┐рдпрд╛рд╣рди рдд рдмрдбрд╝рд┐рдпрд╛рд╣рди рд▓рдХреНрдЬрд╝рд░реАрдпрди рдореНрдиреНрдЬрд╝ рддрдмрджреАрд▓ рдХрд░рд╛рдиред--  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =","canonical_solution":"flipCase :: String -> String\nflipCase = map flipChar\n  where\n    flipChar c\n      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)\n      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_28","nl":"kas_Deva","pl":"hs","prompt":"-- рдХреЙрдирдХреЗрдЯреЗрдиреЗрдЯ рд▓рд┐рд╕реНрдЯ рдСрдлрд╝ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЗрди рд╕рд┐рдВрдЧрд▓ рд╕реНрдЯреНрд░рд┐рдВрдЧ --  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =","canonical_solution":"concatenate :: [String] -> String\nconcatenate strings = concat strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_29","nl":"kas_Deva","pl":"hs","prompt":"-- рдлрд╝рд┐рд▓реНрдЯрд░ рдЗрдирдкреБрдЯ рд▓рд┐рд╕реНрдЯ рдСрдлрд╝ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдУрдирд▓реА рдлреЙрд░ рдУрдиреЗ рдард╛рдЯ рдмреЗ a given рдкреНрд░реАрдлрд┐рдХреНрд╕.--  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =","canonical_solution":"filterByPrefix strings prefix = filter (isPrefixOf prefix) strings\n  where\n    isPrefixOf pfx str = take (length pfx) str == pfx","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_30","nl":"kas_Deva","pl":"hs","prompt":"--реЗрдо рдХреНрд░ рд╕рд┐рд░реНрдл рдкреЙрдЬрд┐рдЯрд┐рд╡ рдирдВрдмрд░ рд╡рд╛рдкрд╕.--  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =","canonical_solution":"getPositive :: [Int] -> [Int]\ngetPositive l = filter (> 0) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_31","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ рдЕрд╕ рдирдВрдмрд░ рдЕрд╕ рдкреНрд░рд╛рдЗрдо ,рддрде рдЫреВ рдпреЗ рдЯреНрд░реВ ,рдмреЗ рдЕрд╕реВрд▓ реБрдиреНрдж рдЕрдЧрд░ рдЕрд╕ рдирдВрдмрд░ рдЕрд╕ рдкреНрд░рд╛рдЗрдо--  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =","canonical_solution":"isPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = not (any (\\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_33","nl":"kas_Deva","pl":"hs","prompt":"--рдгрдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг--l' рдЫреБ рддрд┐рдорди рдЗрдВрдбрд┐рд╕реЗрдпреНрди рдореНрдиреНрдЬрд╝ рдпрд┐рдо рддреНрд░реЗрди рд╣реНрдирджрд┐ рдмрд╛рдЧрдирдп рдпрд┐рд╡рд╛рди рдЫрд┐, рдпреЗрд▓рд┐ рдЬрд╝реНрди рддрд┐рдореНрди рдЗрдВрдбрд┐рд╕реЗрдпреНрди рдореНрдиреНрдЬрд╝ рдпрд┐рдо рддреНрд░реЗрди рд╣реНрдирджрд┐ рдмрд╛рдЧрдирдп рдЫрд┐ рддрд┐рдореНрди рд╣реНрдиреНрджрд┐ рд╡рд▓реНрдпреЛ рдмрд░рд╛рдмрд░ рдЫрд┐ред--рдпреБрд╕ рдпреЗ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рдЫреА рдЕрд╕ рд▓рд┐рд╕реНрдЯ рдХрд╛рд░рди рд╡рд╛рдкрд╕ рдХрд╛рд░рди--  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =","canonical_solution":"sortThird :: [Int] -> [Int]\nsortThird l = map selectElem indexed\n  where\n    indexed = zip [0..] l\n    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]\n    sortedThirdElems = sortedElems thirdIndicesElems\n    sortedElems = id -- or List.sort if imported\n    selectElem (i, x)\n      | i `mod` 3 == 0 = head sortedThirdElems\n      | otherwise = x\n    replaceSortedElem xs sorted = map selectElem indexed\n      where\n        replaceElem i (x:xs)\n          | i == 0 = x:xs\n          | otherwise = replaceElem (i - 1) xs\n        selectElem (i, x)\n          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)\n          | otherwise = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_34","nl":"kas_Deva","pl":"hs","prompt":"--рддрдорд┐ рд╡рд┐рдЬрд╝рд┐ рдЫреБ рдпрд┐ рд▓рд┐рд╕рдЯрд╕ рдореНрдиреНрдЬрд╝ рдлрд╝рд░рд╣рдо рдХрд░рди рд╡реЙрд▓ рдЕрдирдиреНрдп рдПрд▓рд┐рдореЗрдирдЯ рд░рджрд┐рдлрд╝рдд рдХрд░рд╛рдиред--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =","canonical_solution":"unique :: [Int] -> [Int]\nunique l = sort $ nub l\n  where\n    -- | Remove duplicate elements from a list.\n    nub :: (Eq a) => [a] -> [a]\n    nub [] = []\n    nub (x:xs) = x : nub (filter (\/= x) xs)\n\n    -- | Sort a list of elements (using QuickSort algorithm).\n    sort :: (Ord a) => [a] -> [a]\n    sort [] = []\n    sort (x:xs) =\n      let smallerSorted = sort [a | a <- xs, a <= x]\n          biggerSorted = sort [a | a <- xs, a > x]\n      in  smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_35","nl":"kas_Deva","pl":"hs","prompt":"--тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ--  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =","canonical_solution":"maxElement :: [Int] -> Int\nmaxElement [] = error \"List cannot be empty\"\nmaxElement (x:xs) = maxElementHelper xs x\n  where\n    maxElementHelper [] currentMax = currentMax\n    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_36","nl":"kas_Deva","pl":"hs","prompt":"--ЁЯУМ рдпреЗ рдЫреВ рдЗрдВрдЯреЗрдЧрд░рд╕ рдордВрдЬрд╝ рдирдВрдмрд░ 7 рд╣рд┐рдВрдЬ рдбрд┐рд╡рд┐рдЬрд╝рдирд▓ рдирдВрдмрд░--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =","canonical_solution":"fizzBuzz :: Int -> Int\nfizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_37","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рдпреЗ рд╡реИрд▓реНрдпреВ рдЫреА рдЗ рдЫреА рдПрд╡рдВ рд╡реБрдЪрдиреЗ рдпреБрд╕ рдЫреА рдПрд╡рдВ реЗрдорди рд╣рдВрджреНрд╡рд░ ,рд▓рдХрд┐рди рдЫреА рдПрд╡рдВ рд╕реЙрд░реНрдЯ рдХрд░рдиреЗ--l' рдЫреБ l рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди рд╣рд┐рд╡реЗрди--рдпреБрд╕ рдпреЗ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рдЫреА рдЕрд╕ рд▓рд┐рд╕реНрдЯ рдХрд╛рд░рди рд╡рд╛рдкрд╕--  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =","canonical_solution":"sortEven :: [Int] -> [Int]\nsortEven l = merge odds sortedEvens\n  where\n    (odds, evens) = partitionList l\n    sortedEvens = sort evens\n\n    partitionList :: [Int] -> ([Int], [Int])\n    partitionList [] = ([], [])\n    partitionList [x] = ([x], [])\n    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)\n      where\n        (xsOdds, xsEvens) = partitionList xs\n\n    merge :: [Int] -> [Int] -> [Int]\n    merge [] ys = ys\n    merge (x:xs) [] = x:xs\n    merge (x:xs) (y:ys) = x:y:merge xs ys","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_39","nl":"kas_Deva","pl":"hs","prompt":"--prime_fib рдЫреА рдЕрд╕ рджреЗрд╡рди n -рде рдиреБрдореНрдмрд░рдВ рдпреБрд╕ рдлрд┐рдмреЛрдиреИрдХреА рдиреБрдореНрдмрд░рдВ рдЫреА рдмреЗ рдЫреА рдпреЗ рдкреНрд░рд╛рдЗрдо--  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =","canonical_solution":"primeFib :: Int -> Int\nprimeFib n = primeFibs !! (n - 1)\n  where\n    primeFibs = filter isPrime fibs\n    fibs = map fst $ iterate (\\(a, b) -> (b, a + b)) (0, 1)\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2 = False\n  | k == 2 = True\n  | even k = False\n  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]\n  where\n    upperLimit = floor . sqrt $ fromIntegral k","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_40","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрд╕реБрдо рдЫреВ рдЬреАрд░реЛ,рддреЗ рдЧрд▓рдд рдЫреВ.--рдЕрдЧрд░ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рддреНрд░реЗ рдЕрд▓рдЧ рдЕрд▓рдЧ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ --рдЯреНрд░рд┐рдкрд▓рд╕_рд╕реБрдо_рдЯреЛ_рдЬрд╝реЗрд░реЛ рдЫреА рдЗрдиреНрдкреБрдЯ рдХрд╛рд░рди рдЗрдВрддреЗрдЬрд░рд╕--  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =","canonical_solution":"triplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]\n  where\n    tails [] = []\n    tails xs@(_:xs') = xs : tails xs'","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_41","nl":"kas_Deva","pl":"hs","prompt":"--рдпреЗ рдлрдВрдХреНрд╢рди рдЫреВ рдПрдПрдо рдЯрдХрд░рд╛рд╡рди рд╣рд┐рдиреНрдж рддреИрд░ рдкрдЗрда рдирдВрдмрд░ рдЖрдЙрдЯрдкреБрдЯ рдХрд░рд╛.--рдпреЗ рдЫреВ рдПрдПрдорд╡ рд╕рд┐рдВрдЬ рдЯреНрд░реЗрдЬреЗрдХреНрдЯрд░реА рдордВрдЬрд╝ рдРрд╕реЗ рд▓рдмрдиреА рдпреЗрд╡рд╛ рдпреЗрде рдкрдЗрда рдЕрдЧрд░ рддреЗрдо рдЖрдкрд╕ рдордВрдЬрд╝ рдЯрдХрд░рд╛рд╡ рдиреЗ рдХрд╛рд░рди.--рддрд╛рд╣рдо, рдХрд╛рд░ рдЫрд┐ рдЗрдирдлрд┐рдирд┐рдЯреА рдордЬрд╝рдмреВрдд рдд рдордЬрд╝рдмреВрдд; рдирддреАрдЬрддрди, рддрд┐рдо рдЫрд┐ рд▓рдЧрд╛рддрд╛рд░ рдЪрд▓рд╛рдиред--рдпреЗрд▓рд┐ рдЕрдЦ рдХрд╛рд░ рдпреБрд╕ рдмрд╛рдпреЗ рджрд╛рд╡реБрди рд░рдЯрди рдЖрд╕рд┐ рдЕрдЦ рдХрд╛рд░ рдпреБрд╕ рджрд╛рд╡реБрди рд░рдЯрди рдЖрд╕рд┐ред--рдЕрдЦ рдЕрдХрд┐рд╕ рд╕реЗрдд. рддрдорд╛рдо рдХрд╛рд░ рдЫреВ рдЕрдХрд┐рд╕ рд╕реНрдкреАрдб рд╕реЗрдд рд░рдЯрди. рджреВрдБ рдХрд╛рд░реЗрдВ рдЫреВ рдЯрдХрд░рд╛рд╡рди.--рджреЛрдпреЛ рдореБрдХрд╝рд╛рдо рдХрд╛рд░реЛ рд╢реБрд░реВ рдЫреВ рд╡рд░рд┐рдпреЗ рджреВрд░ рд╛рдХрд┐рд╕ рдореБрдХрд╝рд╛рдо рд╕реЗрдд.--n рдХрд╛рд░реНрд╕ рдЫрд┐ рдмрд╛рдо рдкреЗрда рджрд╛рд╡реБрди рдЪрд▓рд╛рд╡рди рдпрд┐рд╡рд╛рди; рдЕрдХрд┐рд╕ рд╡рдЦрддрд╕ рдкреЗрда, n рдХрд╛рд░реНрд╕ рд╣реБрдиреНрдж рдЕрдЦ рдореБрдЦрддрд▓рд┐рдл рд╕реЗрдЯред--тЭЦ рддрдЬрд╡реАрдЬрд╝ рдХрд░реЛ рдХрд┐ рдЕрдЦ рд░реЛрдб рдЕрдЦ рдореБрдХрдорд▓ рд╕реАрдзреА рд▓рд╛рдВрдмреА рд╣рд┐рдиреНрджреЗрди рд▓рд╛рдЗрдирди рд╣рд┐рдВрдЬ.carRaceCollision :: Int -> Int\ncarRaceCollision n =","canonical_solution":"carRaceCollision :: Int -> Int\ncarRaceCollision n = n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_42","nl":"kas_Deva","pl":"hs","prompt":"--тЮбя╕П1 рд╕реЗ рдмрдврд╝рдХрд░ рдЖрд╕рд╛рди рдЪреАрдЬрд╝реЗрдВ тЮбя╕П--  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =","canonical_solution":"incrList :: [Int] -> [Int]\nincrList l = map (+1) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_43","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрд╕реБрдо рдЫреВ рдЬреАрд░реЛ,рддреЗ рдЧрд▓рдд рдЫреВ.--рдЕрдЧрд░ реЗрдореБрдХ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЬрд╝реЗ рдЕрд▓рдЧ рдЕрд▓рдЧ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рдЖрд╕рд╛рди рддреЗрдо рдЫреВ рдЯреНрд░реВ рд░рд┐рдЯрд░реНрди рдХрд░рд╛--pairs_sum_to_zero рдЫреА рдЗрдиреНрдкреБрдЯ рдХрд╛рд░рди рдЗрдВрддреЗрдЬрд░рд╕--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =","canonical_solution":"pairsSumToZero :: [Int] -> Bool\npairsSumToZero l = any (\\x -> -x `elem` l) l && (length l > 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_44","nl":"kas_Deva","pl":"hs","prompt":"--рдмреЗрд╕ рдирдВрдмрд░ рдЫреА рд▓реЗрд╕реНрд╕ 10 --рддрдм, рддрдм, рддрдм, рддрдм, рддрдм, рддрдм--реЗрдо рдХреНрд░ рдЗрдирдкреБрдЯ рдирдВрдмрд░ X рд╣рд┐рдВрдЬ рдиреБрдорд╛рд░рд┐рдХрд╛рд▓ рдмреЗрд╕ рддреЗ рдмреЗрд╕ рдордВрдЬрд╝ рддрдмреНрджреАрд▓.--  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =","canonical_solution":"changeBase :: Int -> Int -> String\nchangeBase x base\n  | x < base  = show x\n  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_45","nl":"kas_Deva","pl":"hs","prompt":"------- рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ рддреНрд░рд┐рдХреЛрдгрдХ рд▓рдВрдмрди рдЫреВ--  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =","canonical_solution":"triangleArea :: Int -> Int -> Float\ntriangleArea a h = 0.5 * fromIntegral a * fromIntegral h","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_46","nl":"kas_Deva","pl":"hs","prompt":"--рдкреНрд▓реАрдЬрд╝ рд▓реЗрдЦреБрдЦ рдЕрдЦ рдлрдВрдХреНрд╢рди рддрд╛рдХрд┐ рдЕрд╕ рд╣рдХреЛ рдЕрд╕ рд╡реБрдЫрд┐рде n-рде рдПрд▓рд┐рдореЗрдВрдЯ fib4 рдиреБрдорд╛рд░рд┐рдХ рд╕реАрдХреНрд╡реЗрдВрд╕реБрдХ. --fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --рдпреБрд╕ Fib4 рдиреБрдореНрдмрд░рдВ рд╕реАрдХреНрд╡реЗрдВрд╕ рдЫреА рд╕реБ рдЫреА рд╕рд┐рдорд┐рд▓рд░ рдлрд┐рдмреЛрдиреИрдХреА рд╕реАрдХреНрд╡реЗрдВрд╕ рдпреБрд╕ рдбрд┐рдлрд╛рдЗрди рдЫреА рдПрд╡рдВ рдХрд░рдиреЗ--  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =","canonical_solution":"fib4 :: Int -> Int\nfib4 n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 2\n  | n == 3 = 0\n  | otherwise = iter 0 0 2 0 n\n  where\n    iter a b c d 4 = a + b + c + d\n    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_47","nl":"kas_Deva","pl":"hs","prompt":"--l рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣рд┐рдВрдЬ рдореАрдбрд┐рдпрди рдЫреВ рд╡рд╛рдкрд┐рд╕ рдПрд╡рдВ.--  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =","canonical_solution":"median :: [Int] -> Float\nmedian l \n  | odd n     = fromIntegral $ sorted !! mid\n  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) \/ 2\n  where\n    sorted = sort l\n    n = length l\n    mid = n `div` 2\n    sort = sortBy compare","tests":"\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_48","nl":"kas_Deva","pl":"hs","prompt":"--реЗрдо рдЫреА рдХрд╛рд░рди рдЪреЗрдХ рдХреА рдпреБрд╕ рджреЗрд╡рди рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рд╕реБ рдЫреА рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =","canonical_solution":"isPalindrome :: String -> Bool\nisPalindrome text = text == reverse text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_49","nl":"kas_Deva","pl":"hs","prompt":"--реЗрдХрд╢рди рдЫреВ 2^n рдореЙрдбреБрд▓реЛ p (рдирдВрдмрд░рд┐рдХрд╕ рдЫреВ рд╡рд╛рдирди).--  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =","canonical_solution":"modp :: Int -> Int -> Int\nmodp n p = powMod 2 n p\n\npowMod :: Int -> Int -> Int -> Int\npowMod base exp modulus\n  | modulus == 1 = 0\n  | exp == 0     = 1\n  | exp == 1     = base `mod` modulus\n  | otherwise    = if odd exp\n                   then (base * halfExp * halfExp) `mod` modulus\n                   else (halfExp * halfExp) `mod` modulus\n  where\n    halfExp = powMod base (exp `div` 2) modulus","tests":"\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_51","nl":"kas_Deva","pl":"hs","prompt":"--remove_vowels рдЫреБ рдЕрдЦ рдлрдВрдХреНрд╢рди рдпреБрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧ рд▓рд┐рдЫ рдд рд╕реБ рдЫреБ рд╡рд╛рдкрд╕ рдХрд░рд╛рди рд╕реНрдЯреНрд░рд┐рдВрдЧ рдмрдЧреИрд░ рд╡реЛрд▓реНрд╡рдиред--  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =","canonical_solution":"removeVowels :: String -> String\nremoveVowels text = filter (`notElem` \"aeiouAEIOU\") text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_52","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рд╕рд╣реА рдЫреВ рд╕реБ рдЫреВ рд╡рд╛рдкрд┐рд╕ рдХрд╛рд░рди рдЕрдЧрд░ рд╕рд▓реАрдо рдирдВрдмрд░ рдЫреА рд╕реВрдж рдереНрд░реЗрд╕рд╣реЛрд▓реНрдб t рдкреЗрда--  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =","canonical_solution":"belowThreshold l t = all (< t) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_53","nl":"kas_Deva","pl":"hs","prompt":"--X рддреЗ Y рддреЗрдордЬ рджреБрдирд╡рдИ рдирдВрдмрд░ рдЬрдорд╛ рдХрд░рдиреЗ--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =","canonical_solution":"add :: Int -> Int -> Int\nadd x y = x + y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_54","nl":"kas_Deva","pl":"hs","prompt":"--тЮбя╕ПрдЪреЗрдХ рдХрд░реЛ рдЕрдЧрд░ рджреЛрдиреЛ рд▓рдлреНрдЬреЛ рдореЗ рдПрдХрд╕рдорд╛рди рдЕрдХреНрд╖рд░ рд╣реЛ.--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =","canonical_solution":"import Data.List (nub, sort)\n\nsameChars :: String -> String -> Bool\nsameChars s0 s1 = sort (nub s0) == sort (nub s1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_55","nl":"kas_Deva","pl":"hs","prompt":"--тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П тЮбя╕П--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =","canonical_solution":"fib :: Int -> Int\nfib n = fibHelper 0 1 n\n  where\n    fibHelper a _ 0 = a\n    fibHelper a b n = fibHelper b (a + b) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_56","nl":"kas_Deva","pl":"hs","prompt":"--return рдЯреНрд░реВ рдЕрдЧрд░ рд╣рд░ рдУрдкрдирд┐рдВрдЧ рдмреНрд░реИрдХреЗрдЯ рдордВрдЬрд╝ рдЫреА рдд рдмреИ рдХрд░реЙрд╕реНрдкреЙрдиреНрдбреЗрдВрдЯ рдХреНрд▓реЛрдЬрд┐рдВрдЧ рдмреНрд░реИрдХреЗрдЯ--рдмреНрд░реИрдХреЗрдЯреНрд╕ рдЫреВ рд╕реНрдЯреНрд░рд┐рдВрдЧ \"<\" рддреЗ \">\".--  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBrackets brackets 0 == 0\n\ncheckBrackets :: String -> Int -> Int\ncheckBrackets [] n = n\ncheckBrackets (x:xs) n\n  | n < 0 = -1\n  | x == '<' = checkBrackets xs (n + 1)\n  | x == '>' = checkBrackets xs (n - 1)\n  | otherwise = checkBrackets xs n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_57","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рд░рд┐рдЯрд░реНрди рдЫреВ рдЯреНрд░реВ рдЫреВ рд╕реБ рдЫреВ рдПрд╡рдВ рдореЛрдиреЛрдЯреЛрдирд┐рдХрд▓реА рдПрд▓рд┐рдореЗрдВрдЯ рдмрдврд╝рд╛рд╡ рдпрд╛ рдХрдо рдХрд░реВрдБ--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =","canonical_solution":"monotonic :: [Int] -> Bool\nmonotonic l = increasing l || decreasing l\n  where\n    increasing xs = all (uncurry (<=)) (zip xs (tail xs))\n    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_58","nl":"kas_Deva","pl":"hs","prompt":"--реЗрдХ рдСрдмреНрдЬреЗрдХреНрдЯ рдЫреВ рджреБрдирд╡рдИ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣рд┐рдВрдЬ рдордХрд╕рдж рдХрд╛рд░рди.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =","canonical_solution":"common :: [Int] -> [Int] -> [Int]\ncommon l1 l2 = uniqueSortedCommon\n  where\n    commonElements = filter (`elem` l2) l1\n    uniqueCommon = removeDuplicates commonElements\n    uniqueSortedCommon = sort uniqueCommon\n\n    removeDuplicates :: [Int] -> [Int]\n    removeDuplicates = foldr (\\x seen -> if x `elem` seen then seen else x : seen) []\n\n    sort :: [Int] -> [Int]\n    sort [] = []\n    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)\n      where\n        lesser  = filter (< p) xs\n        greater = filter (>= p) xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_59","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рд╕рд░рд┐рдпреЛ рдЦреЛрдд рдмреБрдб рдкреНрд░рд╛рдЗрдо рдлреИрдХреНрдЯрд░ рдЫреВ рд╕реБ рдЫреВ рдПрд╡рдВ рд╡рд╛рдкрд╕ рдХрд╛рд░рди--  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =","canonical_solution":"largestPrimeFactor :: Int -> Int\nlargestPrimeFactor n = helper n 2\n  where\n    helper n factor\n      | factor * factor > n = n\n      | n `mod` factor == 0 = helper (n `div` factor) factor\n      | otherwise = helper n (factor + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_60","nl":"kas_Deva","pl":"hs","prompt":"--sum_to_n рдЫреВ рдЖрдБрдЦ рдлрдВрдХреНрд╢рди рдпреБрд╕ рдирдВрдмрд░ рдЫреА рд╕реБрдореНрдо рдХрд╛рд░рди 1 рдкреЗрда n рддрд╛рдо--  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =","canonical_solution":"sumToN :: Int -> Int\nsumToN n = sum [1..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_61","nl":"kas_Deva","pl":"hs","prompt":"--return рдЯреНрд░реВ рдЕрдЧрд░ рд╣рд░ рдУрдкрдирд┐рдВрдЧ рдмреНрд░реИрдХреЗрдЯ рдордВрдЬрд╝ рдЫреА рдд рдмреИ рдХрд░реЙрд╕реНрдкреЙрдиреНрдбреЗрдВрдЯ рдХреНрд▓реЛрдЬрд┐рдВрдЧ рдмреНрд░реИрдХреЗрдЯ--рдпреБрд╕ рдмреНрд░реИрдХреЗрдЯ рдЫреА рд╕реБ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧ \" (_) \" рдмреЗ \"_) \"--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBalance brackets 0\n  where\n    checkBalance [] 0 = True\n    checkBalance [] _ = False\n    checkBalance (x:xs) n\n      | x == '('  = checkBalance xs (n + 1)\n      | x == ')' && n > 0 = checkBalance xs (n - 1)\n      | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_62","nl":"kas_Deva","pl":"hs","prompt":"--рдпреЗ рдЫреА рдПрд╡рдВ рдкреЛрд▓реАрдиреЛрдорд┐рдЕрд▓ рдбреЗрд░реАрд╡реЗрдЯрд┐рд╡реНрд╕ рдордВрдЬрд╝ рддреЗрдорди рдлреЙрд░реНрдореЗрдВ рдордВрдЬрд╝--xs[0] + xs[1] * x + xs[2] * x^2 + .... --Xs рдЫреВ рдХреБрдб рдкреЛрд▓реАрдиреЛрдорд┐рдЕрд▓ рд╣реБрдиреНрдж рдХреЛрдПрдлрд╝рд┐рд╢рд┐рдПрдВрдЯ.--  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =","canonical_solution":"derivative :: [Int] -> [Int]\nderivative xs = zipWith (*) (tail xs) [1..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_63","nl":"kas_Deva","pl":"hs","prompt":"--рдкреНрд▓реАрдЬрд╝ рд▓реЗрдЦреБрдЦ рдЕрдЦ рдлрдВрдХреНрд╢рди рддрд╛рдХрд┐ рдЕрд╕ рд╣рдХреЛ рдХрд╛рдордпрде рдПрди-рде рдПрд▓рд┐рдореЗрдВрдЯ рдСрдлрд╝ рдлрд┐рдмрдлрд┐рдм рдирдВрдмрд░ рд╕реАрдХреНрд╡реЗрдВрд╕--fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). --fib fib ((2) == 1 --fib fib ((1) == 0 --fib fibf ((0) == 0 --рдпреБрд╕ рдлрд┐рдмрдлрд┐рдм рдирдВрдмрд░ рд╕реАрдХреНрд╡реЗрдВрд╕ рдЫреА рд╕реБ рдЫреА рд╕рд┐рдорд┐рд▓рд░ рдлрд┐рдмреЛрдиреИрдХреА рд╕реАрдХреНрд╡реЗрдВрд╕ рдпреБрд╕ рдбрд┐рдлрд╛рдЗрди рдЫреА рдПрд╡рдВ рдХрд░рдиреЗ--  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =","canonical_solution":"fibfib :: Int -> Int\nfibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibs !! n\n  where\n    fibs = 0 : 0 : 1 : zipWith3 (\\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_64","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рд╡реЛрдХрд▓ ,рд▓рдХрд┐рди рдпреЗ рдЫреВ рдПрд╡рдВ рд╕рд┐рд░реНрдл рдпрд┐рд▓ рдпреЗ рд▓рдлрд╝рдЬрд╝реЗ рд╣рд┐рдиреНрдж рдЖрдЦрд┐рд░рд╕ рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ--рдЕрдорд┐ рдорд╛рдорд▓рд╛рд╕ рдордВрдЬрд╝ рдЫрд┐ рд╕реНрд╡рд░ 'рдЕ', 'рдИ', 'рдЖрдИ', 'рдУ', 'рдпреВ' рдпрд┐рдереНрдХреЗрде 'рдп' рддрд┐ рдЫреБ рдЕред--рдгрдгрдг рдгрдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг--рдЕрдЦ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЗ рдпреБрд╕ --  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =","canonical_solution":"vowelsCount :: String -> Int\nvowelsCount s = length $ filter isVowel $ zip s [1..]\n  where\n    isVowel (c, pos) =\n      let lowercaseC = toLower c\n          isRegularVowel = lowercaseC `elem` \"aeiou\"\n          isLastCharY = lowercaseC == 'y' && pos == length s\n      in isRegularVowel || isLastCharY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_65","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ рд╢рд┐рдлреНрдЯ > рдбрд┐рдЬрд┐рдЯрд╕ рд╣реБрдиреНрдж рдирдВрдмрд░, рд░рд┐рдЯрд░реНрди рдбрд┐рдЬрд┐рдЯрд╕ рдЗрдирд╡рд░реНрд╕рдб.--рдгреВрдЗрдХ рдХреНрд╕рд┐рдУрдирдбрд╕ рдЕрд╕-- Circular shift the digits of the integer x, shift the digits right by shift  рд╕рд░реНрдХреБрд▓рд░ рд╢рд┐рдлреНрдЯ рдЗрдВрдЯрд┐рдЬрд░ рдПрдХреНрд╕, рдбрд┐рдЬрд┐рдЯ рд░рд╛рдЗрдЯ рдмрд╛рдп рд╢рд┐рдлреНрдЯ --  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =","canonical_solution":"circularShift :: Int -> Int -> String\ncircularShift x shift =\n  let digits = show x\n      len = length digits\n      effectiveShift = shift `mod` len\n  in if shift > len\n     then reverse digits\n     else let (begin, end) = splitAt (len - effectiveShift) digits\n          in end ++ begin","tests":"\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_66","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --ASCII рдХреЛрдбреНрд╕.--рд▓рд┐рдЦреЗрдВ рдлрдВрдХреНрд╢рди рдпреБрд╕ рдЕрд╕ рдХрд╛рд░рди рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдордВрдЬрд╝ рдмреЗ рдЫреА рд╕реБ рд╡рд╛рдкрд┐рд╕ рдХрд╛рд░рди рд╕рд┐рд░реНрдл рд╕реБрдореНрдо рдСрдлрд╝ рдЯреЙрдк рдХреИрд░реЗрдХреНрдЯрд░реНрд╕ \"--рдЯрд╛рд╕реНрдХ.--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =","canonical_solution":"digitsum :: String -> Int\ndigitsum s = sum $ map fromEnum $ filter isUpper s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_67","nl":"kas_Deva","pl":"hs","prompt":"--рдПрдХреНрд╕реИрдВрдмрд▓ рдЦрд╛рддрд┐рд░: --рдмрд╛рд╕реНрдХреЗрдЯ рдордВрдЬрд╝ рдЫреА рдореИрдВрдЧреЛ рдлрд▓реЛрдВ рд╣реБрдиреНрдж рдирдВрдмрд░--рдирд╛рд░рдВрдЧреА рддреЗ рд╕реЗрдм рддреЗ рдЕрдЦ рдЗрдиреНрдЯрд┐рдЬрд░ рдпреБрд╕ рдХреБрд▓ рдлрд░реВрдХ рдиреБрдореНрдмрд░рдВ рдЫреВ рд╣рд╡рди--,, рдд рдЖрдо рдлрд▓рди рд╣реНрдиреНрдЬрд╝рд┐ рдХреНрдо рддрд╛рджрд╛рджред--рдпреЗ рдЫреВ рдлрд▓рди рд╣рд┐рдВрдЬ рдЕрдЦ рдмрд╛рд╕реНрдХреЗрдЯ рдордВрдЬрд╝ рдмрдВрдЯрд╛рди рдпреЗ рдЫреВ рдЕрде рдмрд╛рд╕реНрдХреЗрдЯрд╕ рдордВрдЬрд╝ рд╢рд╛рдорд┐рд▓.-- рдЗрд╕ рдЯрд╛рд╕реНрдХ рдорд╛ рддреБрдорд░реМ рдмрд╛рди рдПрдХреЛ рд╕реНрдЯреНрд░рд┐рдВрдЧ рджреА рдЬрд╛рдпрдЧреА рдЬреЛ рдХреА рдПрдкреНрдкрд▓ рдЕрд░ рдСрд░реЗрдВрдЬ рдХреА рд╕рдВрдЦреНрдпрд╛ рдорд╛ рдмрдгрд╛рдпреЗ рдЧреЗред--  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =","canonical_solution":"import Text.Read (readMaybe)\n\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n = n - totalApplesOranges\n  where\n    totalApplesOranges = sum $ map (readNumber . words) [\"apples\", \"oranges\"]\n    readNumber keyword = case dropWhile (not . (==\" \") . dropWhile (\/=' ')) $ words s of\n      [] -> 0\n      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_68","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ 1: --рдЕрдЧрд░ рдЕрд╕ рдиреЗ рдХрд╣реАрдВ рддреЗ рд╡реИрд▓реНрдпреВрдЬ рдпрд╛ рдпреБрд╕ рд▓рд┐рд╕реНрдЯ рдЫреА рд╕реБ рдЫреА рдЦрд▓реА ,рддрде рдЫреА рд░рд┐рдЯрд░реНрди рдХрд╛рд░рди []--рдкрд┐рдХреНрдб рдиреЛрдб рдЖрд╡ рд░рдЯрд░реНрдиреНрдб рдХрд╛рд░рдг рдЖрдХрд┐рд╕ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝,[smalest_value,рдЗрдорд┐рд╕ рд╣рд┐рдиреНрдж рдЗрдВрдбреЗрдХреНрд╕],--рдЕрдЧрд░ рдЬрд╝рдпрд╛рдж рдиреЛрдбреНрд╕ рдЫреВ рд▓рдХреБрдЯ,рддреЗрд▓ рдЫреВ рдпреЗ рдиреЛрдбрд╕ рд▓рдХреБрдЯ рддреЗ рдХрдо.--рдпреБрд╕ рдиреЛрди рдЫреВ рд╕реБ рдЧреЙрд╡ рд╕рд░рд┐рдпреЛ рдЦреЛрдд рд▓рдХреБрдЯ--рддреЛрд░реЗ рдХрд╛рдо рдЫреЗ рдПрдиреЛ рдиреЛрдбрд╕ рд╣реВрд░ рдХрд░ рддреЗ рд╡рд╛рдкрд╕ рдХрд░.--рдпреБрд╕ рд▓рд┐рд╕реНрдЯ рдЫреА рдЗ рдЫреА рд╣рд╡рди рдмреНрд░рд╛рдВрдЪ рдСрдлрд╝ рдПрдЯреНрд░реА рдпреБрд╕ рдиреЙрди -рдиреЗрдЧреЗрдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдиреЛрдбреНрд╕ рдЫреА рдерд╡рди--  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =","canonical_solution":"pluck :: [Int] -> [Int]\npluck arr = case filter (\\(x, _) -> even x) (zip arr [0..]) of\n    [] -> []\n    evens -> let (value, index) = minimum evens in [value, index]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_69","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЕрдЧрд░ рдЕрд╕ рдиреЗ рдЕрд╕ рд╡рд░реАрдп рдЕрд╕рд▓ рд╡реИрд▓реНрдпреВ рдПрдХреНрд╕рд┐рд╕реНрдЯ рдХрд╛рд░рди ,рддреЗрдо рдЫреА рд░рд┐рдЯрд░реНрди рдХрд╛рд░рди -рез--рдпреБрд╕ рдЗрдиреНрдЯрд┐рдЬрд░ рдЫреВ рд╕реБ рдЫреВ рдлреНрд░реАрдХреНрд╡реЗрдВрд╕реА рдпреБрд╕ рдирдВрдмрд░ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝--рдпреЗ рдЫреА рдЕрд╕ рд╡рди рдЗрдиреНрдЯрд┐рдЬрд░ ,рдмреЗ рдЫреА рдпреЗ рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рдпрд╛ рдмрд░рд╛рдмрд░ рдЗрдиреНрдЯрд┐рдЬрд░ рд╕реЗрде--реЗрдХ рдиреЙрди-рдПрдореНрдкрд▓реАрдлрд┐рдХреЗрд╢рди рдСрдлрд╝ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЧрд░. реБрдорди рдЫреВ рд╕рд░рд┐рдпреЛ рдЦреЛрдд рдмреБрдб рдЗрдВрдЯреЗрдЧрд░ рд▓рдмрдиреА рдпреЗрдо рдЬрд╝рдпрд╛рдж рдЫреВ реЗрдорди рд╣рд┐рдиреНрдж рд╕реЗрдд--  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nsearch :: [Int] -> Int\nsearch lst = \n    let frequencies = map (\\g -> (head g, length g)) . group . sort $ lst\n        candidates = filter (\\(val, freq) -> freq >= val) frequencies\n    in case candidates of\n         [] -> -1\n         _  -> fst . maximum $ candidates","tests":"\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_70","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --реЗрдореЛ рдХреБрд░ рдПрдореНрдо рд╕реЗрде рдореИрдХреНрд╕рд┐рдордо рдЗрдВрдЯреЗрдЬрд░ ,рдкрд╛рдд рдПрдордУ рдХреБрд░ рдорд┐рдирд┐рдордо ,рдмреЗ рддреЗрдо рдкрд╛рдд--рд╕реНрдЯреНрд░реЗрдиреНрдЬ рд╕реЙрд░реНрдЯрд┐рдВрдЧ, рдЗрд╕ рдпреЗрд▓ рдЕрд╕ рдпреВ рдмрд┐рдлреЛрд░ рдереЗ рдорд┐рдирд┐рдордо рд╡реИрд▓реНрдпреВ, --рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди,рддреЗрдо рдХреНрд░ рд▓рд┐рд╕реНрдЯ рдЕрдХрд┐рд╕ рдЕрдирдЬрд╛рди рдСрд░реНрдбрд░ рдордВрдЬрд╝ рд╡рд╛рдкрд┐рд╕.--  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =","canonical_solution":"strangeSortList :: [Int] -> [Int]\nstrangeSortList [] = []\nstrangeSortList lst = go (sort lst) True\n  where\n    go [] _ = []\n    go xs toggle\n      | toggle    = head xs : go (tail xs) False\n      | otherwise = last xs : go (init xs) True","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_71","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рддреАрд╕рд░реА рддрд░рдл рд╕реЗред--рддреНрд░рд┐рдХреЛрдг рдЫреА рдЖрд╕рд╛рди рддреНрд░рд┐рдХреЛрдг рдЕрдЧрд░ рдХрд╣рдБ рддреЗ рджреБрдирд╡рдИ рддрд░рдлрд╛ рдЕрд╕ рдЬрд╝рдпрд╛рдж--рдЕрдЧрд░ рдиреЗ рдЕрд╕ рд╕рд╣реА рддреЗрдо рдЫреА рд╡рд╛рдкрд╕ рдХрд╛рд░рди -1 --рддреНрд░рд┐рдХреЛрдг рдЫреВ 2 рдбреЗрд╕рд┐рдорд▓ рдкреЙрдЗрдВрдЯреНрд╕ рддрд╛рдо рд░рд╛рдЙрдВрдб рдЕрд╕рд╛ рдЕрдЧрд░ рддреНрд░реЗрди рд╕рд╛рдЗрдб рдЫреВ рд╡реИрд▓рд┐рдб рддреНрд░рд┐рдХреЛрдг рдмрдирд╛рд╡рди.--рддреНрд░рд┐рдХреЛрдгрдо рддреНрд░рд┐рдХреЛрдгрдо рддреНрд░рд┐рдХреЛрдгрдо рддреНрд░рд┐рдХреЛрдгрдо рддреНрд░рд┐рдХреЛрдгрдо рддреНрд░рд┐рдХреЛрдгрдо--  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =","canonical_solution":"import Text.Printf (printf)\n\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c\n    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))\n    | otherwise = -1\n  where\n    s = (fromIntegral (a + b + c)) \/ 2\n    isValidTriangle x y z = x + y > z && x + z > y && y + z > x\n    roundToTwoDecimals x = read (printf \"%.2f\" x) :: Float","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_72","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдСрдмреНрдЬреЗрдХреНрдЯ q рдЕрдЧрд░ рдпреЗ рдмрд╛рд▓реНрд▓реЗрдВрд╕рдб (рдпреЗ рдЫреВ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдорд┐рдХ рд▓рд┐рд╕реНрдЯ) рддреЗ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣реБрдиреНрдж рдЕрдорд╛рдЙрдВрдЯ рдЫреВ рдХрдо рдпрд╛ рдмрд░рд╛рдмрд░ рдореИрдХреНрд╕рд┐рдордо рдореБрдордХрд┐рди рд╡рдЬрд╝рди w.--рдпреБрд╕ рдЕрд╕ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рдЫреА рдЕрд╕ рд╕рд╣реА рдХрд╛рд░рди рдЕрдЧрд░ рдСрдмреНрдЬреЗрдХреНрдЯ q рдлреНрд▓рд╛рдИ ,рдмреЗ рдЧрд▓рдд рдЕрдЧрд░ рдЕрд╕ рдиреЗ рдЕрд╕--  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =","canonical_solution":"willItFly :: [Int] -> Int -> Bool\nwillItFly q w = isPalindrome q && sum q <= w\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome xs = xs == reverse xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_73","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --реЗрдХ рдмрджрд▓рд╛рд╡ рдордВрдЬрд╝ , рддреБрд╣ рд╣реЗрдХреАрдЦ рдЕрдХрд┐рд╕ рдПрд▓рд┐рдореЗрдВрдЯрд╕ рдХреБрди рддрдмреНрджреАрд▓ рдХрд░рд┐рде рдмреЗрдХрд╕ рдПрд▓рд┐рдореЗрдВрдЯрд╕ рдордВрдЬрд╝--рдпреБрд╕ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдорд┐рдХ рд▓рд┐рд╕реНрдЯ рдЫреА рд╕реБ рдЫреА рд╕реБ рд▓рд┐рд╕реНрдЯ рдпреБрд╕--рдпреБрд╕ рдпреЗ рд▓рд┐рд╕реНрдЯ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рдЗрдиреНрдЯрд┐рдЬрд░рд╕ ,рдкрд╛рдд рдЫреА рдПрд╡рдВ рд╡рд░реАрдп рдХрдо рдПрд▓рд┐рдореЗрдВрдЯ--  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =","canonical_solution":"smallestChange :: [Int] -> Int\nsmallestChange arr = sum $ zipWith (\\x y -> if x \/= y then 1 else 0) arr (reverse arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_74","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --рдЕрдЧрд░ рдЬрд╝рди рджреЛрди рд╕реВрд░рддрди рдордВрдЬрд╝ рдЕрдХрд┐рдЪ рдирдВрдмрд░ рдЪрд┐рд╣реНрди рдЖрд╕рд┐, рддрдорд┐ рдмрд╛рдкрде рдЧреЛрдбрдирд┐рдХрд┐ рд╕реВрд░рддрд╕ рд╡рд╛рдкрд╕ рдХрдбрд┐рдеред--рдХреБрд▓ рдЪрд╛рд░реНрд╕ рдирдВрдмрд░ рдЗрди рдЖрд▓ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдСрдлрд╝ рдереЗ рд▓рд┐рд╕реНрдЯ рдХрдо рдЗрди рдереЗ рдЗрддрд░ рд▓рд┐рд╕реНрдЯ.--рдпреБрд╕ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рд╣рдХрд╝ рдЕрд╕рд┐рде рдпреБрд╕ рдЬрд╝реЗ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЫреА рдПрд╡рдВ рдорд╛рдирд╛--  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =","canonical_solution":"totalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2\n  | totalChars lst1 < totalChars lst2 = lst1\n  | totalChars lst1 > totalChars lst2 = lst2\n  | otherwise = lst1\n  where\n    totalChars = sum . map length","tests":"\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_75","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЕрдЧрд░ рдЕрд╕ рд╡реБрдЫрд┐рд╡ рдХреА (a) рдЫреА рдХрдо 100 рдкреЗрда--рдмреЗ рдЧрд▓рдд рдмрдХрд┐рдпрд╛рдБ рддрд░рд┐рдХрд╛рд╕ рдордВрдЬрд╝--рдпреБрд╕ рдЕрд╕ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рдЫреА рдЕрд╕ рд╡рди рдЯреНрд░реВ рдЕрдЧрд░ рдЕрд╕ рджреАрд╡рд╛рди рдиреБрдореНрдмрд░рдВ рдЫреА рдЬрд╝рд░рд┐рдпреЗ рддреНрд░ рдкреНрд░рд╛рдЗрдо рдиреБрдореНрдмрд░рдВ--  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =","canonical_solution":"isMultiplyPrime :: Int -> Bool\nisMultiplyPrime a = any isTriplePrimeProduct primeTriples\n  where\n    primes = filter isPrime [2..99]\n    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]\n    isTriplePrimeProduct (x, y, z) = x * y * z == a\n\nisPrime :: Int -> Bool\nisPrime n \n  | n < 2     = False\n  | otherwise = not (any (\\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_76","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --x рдЫреБ n рдкреЙрд╡рд░ рдЖрд╕рд╛рди рдЕрдЧрд░ n**int=x --рдпреБрд╕ рддрд╛рдХрдд рдЫреА n рдмреЗ рдЧрд▓рдд рдмрдХрд┐рдпрд╛рдБ рд┐рд╕рдорд╛рди рдХреЗрд╕ рдордВрдЬрд╝--рдпреБрд╕ рдЕрд╕ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рдЫреА рдЕрд╕ рд╡рди рдЯреНрд░реВ рдЕрдЧрд░ рдЕрд╕ рдЖрдБрдЦ рдирдВрдмрд░ рд╡рди рдЫреА рдПрдХреНрд╕--  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =","canonical_solution":"isSimplePower :: Int -> Int -> Bool\nisSimplePower x n\n  | x < 1 || n < 1 = False\n  | n == 1 = x == 1\n  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_77","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдиреЛрдЯ: рддреБрд╣реНрдпрд╝ рд╣реЗрдХрд┐рд╡ рдорд╛рдирдпрде рдЬрд╝рд┐ рдЗрдирдкреБрдЯ рдЫреЗ рд╣рдореЗрд╢рд┐ рд╕рд╣реАред--рдЕрдЧрд░ рдпреЗ рдЗрдиреНрдЧреЗрдЬрд░ рдЖрдБрдЦ рдХреНрдпреВрдм рдЫреА рдЗрдиреНрдЯрд┐рдЬрд░ рдирдВрдмрд░--рдЖрдБрдЦ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ рдпреБрд╕ рдЗрдиреНрдЯрд┐рдЬрд░ a рдЫреА рдХрд╛рд░рди рддреЗ рдЯреНрд░реВ рддреЗ рдЫреВ рджреЗрд╡рди--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =","canonical_solution":"iscube :: Int -> Bool\niscube a = let n = round (fromIntegral a ** (1\/3)) in n^3 == a","tests":"\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_78","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рддреЗрдо рд╕рд┐рдВрдмрд▓ рдП,рдмреА,рд╕реА,рдбреА,рдИ,рдПрдл рдЫреВ рд╣рдореЗрд╢рд╛ рдЕрдкрд░рдХреЗрд╕.--рдиреЛрдЯ: рддреБрд╣реНрдпрд╝ рд╣реЗрдХрд┐рд╡ рдорд╛рдирдп рдХрд┐ рдЗрдирдкреБрдЯ рдЫреЗ рд╣рдореЗрд╢рд╛ рд╕рд╣реА рдпрд╛ рдЦрд╛рд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ, --B (= рдбреЗрд╕реАрдорд▓ 11), D (= рдбреЗрд╕реАрдорд▓ 13) ред--рддреЛ рддреБрд╣реНрдпрд╝ рдЧрдЫрд┐ рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдбрд┐рдЬрд┐рдЯрд╣ рдкреЗрда рдЕрдЦ рдирдВрдмрд░рдГ 2, 3, 5, 7, --рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░ рдЫреА 2, 3, 5, 7, 11, 13, 17,...--рд╣реЗрдХреНрд╕рд╛рдбреЗрд╕рд┐рдорд▓ рдбрд┐рдЬрд┐рдЯ рдЫреВ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, рдП, рдмреА, рд╕реА, рдбреА, рдИ, рдПрдл.--рдпреЗ рдЫреА рдПрд╡рдВ рд╡рди рдХреА рдпреЗ рдЫреА рдЖрд╕рд╛рди рдЬрд╝реЗ рд▓реЗрдЯрд░ рдиреЗрдЪреБрд░рд▓ рдирдВрдмрд░)--рдпреЗ рдЫреА рдПрд╡рдВ рдиреБрдореНрдмрд░рдВ рдордВрдЬрд╝ ,рдЕрддрдГ рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░ ,рдпрд╛ рдкреНрд░рд╛рдЗрдо ,рдпреЗ рдЫреА рдиреЗрдЪреБрд░рд▓ рдирдВрдмрд░--рд╣реЗрдХреНрд╕рд╛рдбреЗрд╕рд┐рдорд▓ рдирдВрдмрд░ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдордВрдЬрд╝ рдПрд╡рдВ --реЗрдореЛ рдХреБрд░ рдЖрдЦрдГ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦрдиреЗ--  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =","canonical_solution":"hexKey :: String -> Int\nhexKey num = length . filter (`elem` primeHexDigits) $ num\n  where\n    primeHexDigits = \"2357BD\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_79","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдпреБрд╕ рдПрдХреНрд╕реНрдЯреНрд░рд╛ рдХреИрд░реЗрдХреНрдЯрд░ рдЫреА рд╕реБ рдЫреА рдорджрдд рдХрд╛рд░рди рдлреЙрд░реНрдореЗрдЯ рдмрдирд╛рд╡рдиреНрд╕ рдордВрдЬрд╝--рд╕реНрдЯреНрд░рд┐рдВрдЧ рдХрд┐рд╕ рд╢реБрд░реБрдЖрддрд╕ рдордВрдЬрд╝ рдд рдмреИ рдПрдиреНрдбрд╕ рдордВрдЬрд╝ рдЫреА рдИрд╡рд╛ рд╡рд╛рд░реНрдпрдГ рдЬрд╝рдпрд╛рдж рдХреИрд░реЗрдХреНрдЯрд░ \"db\"--рд╣рд░ рдЖрдХрд┐рд╕ рдЖрдХрд┐рд╕ рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ рд╛рдХрд┐рд╕ \" 0 \" рдпрд╛ \"1\"--рдпреБрд╕ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рдЫреА рджреЗрд╡рди рд╕реНрдЯреНрд░рд┐рдВрдЧ ,рдпрде рдордВрдЬрд╝ рд╣рд░ рдЖрдХрд┐рд╕ рд╣рд┐рд╕рд╕ рдЫреА рд╣рд╡рди рдмрд╛рдЗрдирд░реА --реЗрдо рдЫреА рджреЗрд╡рди рдиреБрдореНрдмрд░рдВ рдбреЗрд╕реАрдорд▓ рдлреЙрд░реНрдо рдордВрдЬрд╝ рдмреЗ рдЫреА рдПрд╡рдВ рдорди реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕ реЗрдореЛ рд╣рджреАрд╕--  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =","canonical_solution":"decimalToBinary :: Int -> String\ndecimalToBinary decimal = \"db\" ++ toBinary decimal ++ \"db\"\n  where\n    toBinary 0 = \"0\"\n    toBinary n = reverse (binaryHelper n)\n\n    binaryHelper 0 = \"\"\n    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_80","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдпреБрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА рд╕реБ рдЫреА рд╣рд╛рдл рдЕрдЧрд░ рд╕реБ рд╣рд┐рд╕рд╕ 3 рдд рдмреИ рд╣рд░ 3 рд╕рд┐рдЧрдиреЗрдЯрд┐рд╡реЗ рд▓реЗрдЯрд░ рдЕрд▓рдЧ рдЕрд▓рдЧ--рддреЗрд░реЗ рдЗрд╕ рддреЛ рдмреЗ рдЪреЗрдХ рдЕрдЧрд░ рдереЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЗрд╕ рд╣рд╛рдлреНрд╕ рдпрд╛ рдиреЛ.--          --  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =","canonical_solution":"isHappy :: String -> Bool\nisHappy s\n  | length s < 3 = False\n  | otherwise = all distinctTriples (windows 3 s)\n  where\n    distinctTriples [x, y, z] = x \/= y && y \/= z && x \/= z\n    distinctTriples _ = False\n    windows n xs\n      | length xs < n = []\n      | otherwise = take n xs : windows n (tail xs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_81","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --0.0 E --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 рдмреА + --> 3.3 A- --> 3.7 A --4.0 A+ --GPA. рд▓реЗрдЯрд░ рдЧреНрд░реЗрдб.--рдЕрдЦ рдлрдВрдХреНрд╢рди рдпреБрд╕ рд▓реЗрдЯрд░ рдЧреНрд░реЗрдб рд╣рд┐рдиреНрдЬрд╝ рд▓рд┐рд╕реНрдЯ рдпреА рддрд╛рд▓рд┐рдХрд╛рдГ рдордиреНрдЬрд╝ рдЗрдирдкреБрдЯ рдХрд░рд╛рди рдЫрд┐:--рд╕реБ рдЫреА рджреЗрд╡рди рддреБрдорд╣реИрдХ рд▓рд┐рд╕реНрдЯ GPAs рдХрд╣ рд╕реНрдЯреВрдбреЗрдВрдЯреНрд╕ рд╣реИрдЬрд╝ рдмреЗ рддреБрдорд╣ рдЫреА рдХрд╛рд░рди рд▓рд┐рдЦрдиреЗ--рдпреБрд╕ рд╕рд┐рд░реНрдл рдорд╕рд▓реЗ рдЫреВ ,рдЗрдо рдХреНрд░ рдХреЛрдб рдЧреБрдо рдпрд┐рдо рд╕реБ рдЧреНрд░реЗрдбрд┐рдВрдЧ рдЦрд╛рддрд┐рд░ рдЗрд╕реНрддрд┐рдорд╛рд▓ рдХреБрд░--рдЯреАрдЪрд░ рдЫреА рдмрдирд╡рд╛ рдкрдиреБрди рдЕрд▓реНрдЧреЛрд░рд┐рдердо рдЧреНрд░реЗрдбрд┐рдВрдЧ рдЦрд╛рддрд░--рд╕реЗрдореЗрд╕реНрдЯрд░ рдЫреВ рдЖрдЦрд░реА рд╣рдлреНрддрд╕ рдордВрдЬрд╝, рдЯреАрдЪрд░ рдЫреВ рдЧреНрд░реЗрдб рджреЗрд╡рди.--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =","canonical_solution":"numericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades = map gpaToLetterGrade grades\n  where\n    gpaToLetterGrade gpa\n      | gpa == 4.0 = \"A+\"\n      | gpa > 3.7  = \"A\"\n      | gpa > 3.3  = \"A-\"\n      | gpa > 3.0  = \"B+\"\n      | gpa > 2.7  = \"B\"\n      | gpa > 2.3  = \"B-\"\n      | gpa > 2.0  = \"C+\"\n      | gpa > 1.7  = \"C\"\n      | gpa > 1.3  = \"C-\"\n      | gpa > 1.0  = \"D+\"\n      | gpa > 0.7  = \"D\"\n      | gpa > 0.0  = \"D-\"\n      | otherwise  = \"E\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_82","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --length рдЫреВ рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░ рдпрд╛ рдЧрд▓рдд рдЕрдЧрд░ рдпреЗ рдиреЗ рдЕрд╕--рдпреБрд╕ рдлрдВрдХреНрд╢рди рдЫреА рд╕реБ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдордВрдЬрд╝ рддреЗрдо рдЫреА рдЯреНрд░реВ рд░рд┐рдЯрд░реНрди рдХрд╛рд░рди рдЕрдЧрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ --  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =","canonical_solution":"primeLength :: String -> Bool\nprimeLength string = isPrime (length string)\n\nisPrime :: Int -> Bool\nisPrime n\n  | n < 2     = False\n  | n == 2    = True\n  | even n    = False\n  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_83","nl":"kas_Deva","pl":"hs","prompt":"--рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдЫреА рд╢реБрд░реВ рдЧрд╕рд╛ рдпрд╛ рдЦрд╝рддрдо рдЧрд╕рд╛ 1 рд╕рд╛рде--рдпреБрд╕ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдЫреА ,рдпреЗ рдЫреА рдХрд╛рд░рди рдХрд╛рдЙрдВрдЯ рдСрдлрд╝ n -рдбрд┐рдЬрд┐рдЯ рдиреБрдореНрдмрд░рдВstartsOneEnds :: Int -> Int\nstartsOneEnds n =","canonical_solution":"startsOneEnds :: Int -> Int\nstartsOneEnds n\n  | n <= 0    = 0\n  | n == 1    = 1\n  | otherwise = 18 * 10^(n-2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_84","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ -- рдкреЛрдЬрд╝рд┐рдЯрд┐рд╡ рдЗрдиреНрдЯрд┐рдЬрд░ N рджреЗрд╡рди  рд╕рд┐рдЧрд░реЗрдЯ рд╣реБрдиреНрдж рдЯреЛрдЯрд▓ рд╕реЛрдВрдЯ рд╡рд╛рдкрд╕ рдмрд╛рдЗрдирд░реА рдордВрдЬрд╝--  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 тЙд N тЙд 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =","canonical_solution":"solve :: Int -> String\nsolve N = toBinary (sumOfDigits N)\n  where\n    sumOfDigits 0 = 0\n    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)\n\n    toBinary 0 = \"0\"\n    toBinary n = reverse (toBinary' n)\n      where\n        toBinary' 0 = \"\"\n        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_85","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рдиреЙрди-рдПрдХреНрд▓реЛ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рдиреЙрди-рдПрдХреНрд▓реЛ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рдиреЙрди-рдПрдХреНрд▓реЛ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рдиреЙрди-рдПрдХреНрд▓реЛ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рдиреЙрди-рдПрдХреНрд▓реЛ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рдиреЙрди-рдПрдХреНрд▓реЛ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди --  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =","canonical_solution":"add :: [Int] -> Int\nadd lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_86","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдиреЛрдЯ: рддреБрд╣реНрдпрд╝ рдЧрд╡ рдпрд┐ рд╡рд╛рдХреНрдпрд╕ рдордВрдЬрд╝ рд▓рдлреНрдЬрд╝рди рдд рд░рд┐рдХреНрдд рдЬрдЧрд╣рди рд╣реБрдиреНрдж рддрд░рддреАрдм рдерд╛рд╡реБрдиред--рд╕рдореА рдХрд╝реАрдорддрд╕ рдкреЗрда рдордмрдиреА рддрд░рддреАрдмреБрдХ рддрд░рддреАрдмред--реБрдорди рд╣рдВрджрд┐ рдЕрдХрд┐рд╕ рдирд╡рд┐ рд╢рдмреНрджрд╕ рдордВрдЬрд╝ рдпрд┐рдо рддрдорд╛рдо рдЦрдпрд╛рд▓рд╛рдд рдпрд┐рдо --рдСрд░реНрдбрд░реНрдб рд╡рд░реНрд╢рди рдСрдлрд╝ рд╕реНрдЯреНрд░рд┐рдВрдЧ, рдЗрд╕ a рд╕реНрдЯреНрд░рд┐рдВрдЧ рдпреЗрдд рдЖрд▓ рд╡рд░реНрдбреНрд╕ (рд╕реЗрдкрд░реЗрдЯреЗрдб рдмреА рд╕реНрдкреЗрд╕) --рдЕрдЦ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ рдпреБрд╕ рдЕрдЦ рд╕реНрдЯреНрд░рд┐рдВрдЧ рд▓реЗрде рддреЗ рд╕реБрдиреНрдж рдСрд░реНрдбрд░реНрдб рд╡рд░реНрд╢рди рд╡рд╛рдкрд╕ рдХрд░рде--  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =","canonical_solution":"import Data.List (sort)\nimport Data.Char (isAlpha)\n\nantiShuffle :: String -> String\nantiShuffle s = unwords $ map sortWord (wordsAndSpaces s)\n  where\n    sortWord word = if all isAlpha word then sort word else word\n    wordsAndSpaces [] = []\n    wordsAndSpaces xs = if head xs == ' ' \n                        then \" \" : wordsAndSpaces (dropWhile (== ' ') xs)\n                        else let (word, rest) = break (== ' ') xs\n                             in word : wordsAndSpaces rest","tests":"\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_87","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдмреЗ ,рдпрд┐рдо рдХреЛрдСрд░реНрдбрд┐рдирдЯрд╕ рдЫреА рддреЗрдо рдЫреА рд░реМрдХрд┐рдХ рд╕реЗрде рдХреЙрд▓рдо рд╕реЗрде--рдХреЛрдЖрд░реНрдбрд┐рдиреЗрдЯреНрд╕ рдЫреА рд╢реБрд░реВ рдЧрд╕рд╛ рд░реВрд▓ рдордВрдЬрд╝ рд╛рд╕реЗрдВрдбреАрдВрдЧ рд╛рдХрд┐рд╕ рд╛рдХрд┐рд╕ рдордВрдЬрд╝--рд╣рд░ рдЯрдкрд▓ рдЫреВ рдХреЛрдЖрд░реНрдбрд┐рдиреЗрдЯ - (row,columns),рдпреБрд╕ рд╢реБрд░реВ рдЫреВ рдЧрд╛рд╕рди 0.--рдд рдмреИ рд░рд┐рдЯрд░реНрди рд▓рд┐рд╕реНрдЯ рдСрдлрд╝ рдЯреНрдпреВрдкрд▓реНрд╕ , [(x1, y1), (x2, y2) ...]--lst, рддреЗ рдЗрдВрдЯреЗрдЬрд░ x рджреЗрди, рдЗрдВрдЯреЗрдЬрд░ x рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЦреЛрдЬ, --рд╣рд░ рдЖрдХрд┐рд╕ рд░рд╛рдЬрд╝рд╕ рдордВрдЬрд╝ рд╣реЗрдХрд╡ рдореБрдЦреНрддрд▓рд┐рдл рдирдВрдмрд░ рдХрд▓рдо рдЖрд╕рд┐рдеред--рдпреБрд╕ рдореИрдЯреНрд░рд┐рдХреНрд╕ рд╕реЗрде рдЫреА рд╣реБрд╡рд╛ ,рддреЛрддреА ,рдореИрдЯреНрд░рд┐рдХреНрд╕ рдЕрд▓рдЧ ,--реЗрдореЛ рджреЗрд╡рди 2рдбреА рдбрд╛рдЯрд╛ ,рдиреЗрд╕реНрдЯреЗрдб рд▓рд┐рд╕реНрдЯреНрд╕ рдордВрдЬрд╝ ,--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =","canonical_solution":"getRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x = concatMap processRow (zip [0..] lst)\n  where\n    processRow (rowIndex, row) = \n      let colIndices = reverse $ findIndices (== x) row\n      in [(rowIndex, colIndex) | colIndex <- colIndices]\n\nfindIndices :: (a -> Bool) -> [a] -> [Int]\nfindIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_88","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --* рджрд┐рддреЗрди рд▓рд┐рд╕реНрдЯ рдордд рдЪреЗрдВрдЬ рдХрд░реЛред--рдиреЛрдЯрдГ --рдпрд╛ рдЕрдЧрд░ рд╕реБрдореНрд▓ (рдкрд╣рд▓рд╛ рдЗрдВрдбреЗрдХреНрд╕ рд╡реИрд▓реНрдпреВ, рд▓рд╛рд╕реНрдЯ рдЗрдВрдбреЗрдХреНрд╕ рд╡реИрд▓реНрдпреВ) рдЫреА рдЬреЛрдбрд╝реА ,рддреЗрдо рдЫреА рдпреЗ рд╕реЛрд░реНрдбреЗрдб рдХрд╛рд░рди--рддреБрдо рдЫреА рд╕реЙрд░реНрдЯ рдХрд░рд╛ рдпрд╣ рд▓рд┐рд╕реНрдЯ рдЕрдЧрд░ рд╕реБрдореНрдо рдЫреА рдкрд╣рд▓рд╛ рдЗрдВрдбреЗрдХреНрд╕ рд╡реИрд▓реНрдпреВ , рд▓рд╛рд╕реНрдЯ рдЗрдВрдбреЗрдХреНрд╕ рд╡реИрд▓реНрдпреВ) рдЫреА рдЗрдкреЙрдб ,--                              --  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =","canonical_solution":"sortArray :: [Int] -> [Int]\nsortArray array\n  | null array = array\n  | otherwise =\n    let first = head array\n        last = last array\n        sumFirstLast = first + last\n    in if odd sumFirstLast\n       then sort array\n       else reverse (sort array)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_89","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --реЗрдореЛ рдХреБрд░ рджреБрдирд╡рдИ рд╕реЗрде рдЬрд╝рдпрд╛рдж рддреЗ рджреБрдирд╡рдИ рдЬрд╛рдЗ рдкреЗрда--рдЕрд▓реНрдлрд╛рдмреЗрдЯ рдЫреА рдПрд╡рдВ рдРрд╕реЗ рдмрджрд▓рдиреЗ рддрд╛рдХрд┐ --рдгреВрдЗрдВрдХреНрд░рд┐рдкреНрдЯреЗрдб рд╕реНрдЯреНрд░рд┐рдВрдЧ рд░рд┐рдЯрд░реНрди рдЕрд╕ рдЕрд▓реНрдлрд╛рдмреЗрдЯ рдЫреА рд░реЛрдЯрд┐рдЯреЗрдб-- рдЕрдЦ рдлрдВрдХреНрд╢рди рдмрдирд╛рд╡реБрди рдпреБрд╕ рдЕрдЦ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЕрд╕рд┐рде --  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =","canonical_solution":"encrypt :: String -> String\nencrypt s = map shiftChar s\n  where\n    shiftChar c\n      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')\n      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_90","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ рдЕрд╕ рдПрд▓рд┐рдореЗрдВрдЯ рди рдЕрд╕рд┐рде ,рддрде рд╣рдХрд╝ рдиреЗ рдХрд╣рдБ рддреЗ рд▓рдмрдиреА--рд▓рд┐рдЦреЛ рдлрдВрдХреНрд╢рди next_smallest () рдпреБрд╕ рджреБрдИрдд 2nd рд╕рд░рд┐рдпреЛ рдЦреЛрдд рд▓рдХрд┐рдЯ рдПрд▓рд┐рдореЗрдВрдЯ--реЗрдореЛ рд╡реБрди рдЗрдВрдЯреЗрдЬрд░рд╕ рдЫреА рдЖрд╕рд╛рди--  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =","canonical_solution":"nextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =\n  let uniqueSorted = removeDuplicates $ quicksort lst\n  in if length uniqueSorted < 2\n     then Nothing\n     else Just (uniqueSorted !! 1)\n\nremoveDuplicates :: (Ord a) => [a] -> [a]\nremoveDuplicates = foldr (\\x acc -> if x `elem` acc then acc else x : acc) []\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_91","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --\" \" 'рд╕рдиреНрдзрд┐ \" ' рдЫреБ рдЕрдЦ рдЕрдХрд┐рд╕ рд╣рдВрджрд┐рд╕ рджреЛрд░рд╛рди, рдпреЗрд▓рд┐ рдЬрд╝рди '!--рдмреЛрд░рд┐рдпрдд рдЫреЗ рдЕрдХрд┐ рд╡рдЬрд╝рд╛рд╣реНрдд рдпреБрд╕ \"I\" рд▓рдлреНрдЬрд╝рд╕ рд╕реАрде рд╢рд░реВ рдЧрдЫрд╛рди рдЫреБред--реЗрдореЛ рджреЗрдУ рдЖрдЦрдГ рд╕реНрдЯреНрд░рд┐рдВрдЧ ,рдмреЗ рдЫреА рддреБрдо рдХрд╛рдо рдирдВрдмрд░ рд╡рд╛рдирди--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =","canonical_solution":"isBored :: String -> Int\nisBored s = length $ filter (startsWithI . words) $ splitSentences s\n  where\n    splitSentences :: String -> [String]\n    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters \".?!\"\n    \n    splitOnDelimiters :: String -> String -> [String]\n    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of\n      \"\" -> []\n      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''\n    \n    startsWithI :: [String] -> Bool\n    startsWithI [] = False\n    startsWithI (x:_) = map toLower x == \"i\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_92","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --реЗрдореЛ рдХреБрд░ рд░рд┐рдЯрд░реНрди рдЧрд▓рдд рдмрдХрд┐рдпрд╛рдБ реЗрдХрд╕ рдХреЗрд╕ рдордВрдЬрд╝--рдЕрдЧрд░ рдЕрд╕ рдЖрдБрдЦ рдирдВрдмрд░ рдЕрд╕ рдмрд░рд╛рдмрд░ рдмрдХрд┐рдпрд╛рдБ рдЬрд╝рдирд╛рди рд╣реБрдиреНрдж ,рддреЗрд▓ рдЫреА рдЕрд╕ рдЗрдиреНрдЯрд┐рдЬрд░--реЗрдХ рдлрдВрдХреНрд╢рди рдмрдирд╛рдпрд┐рде рдпреБрд╕ 3 рдиреБрдореНрдмрд░рдВ рдЕрд╕--  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =","canonical_solution":"anyInt :: Float -> Float -> Float -> Bool\nanyInt x y z\n  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =\n      x == y + z || y == x + z || z == x + y\n  | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_93","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --реЗрдореЛ рдХреБрд░ рд╕рд┐рд░реНрдл рд▓реЗрдЯрд░ рд╣рд╛рд╡рдиреБрдХ рдЗрдЬрд╛рдЬрд╝рдд--рдпреБрд╕ рдпреЗ рд╡реЙрд╡реЗрд▓ рдЫреА рдЕрде рдЫреА рдПрд╡рдВ рдЗрдВрдЧреНрд▓рд┐рд╢ рдЕрд▓реНрдлрд╛рдмреЗрдЯреНрд╕ рдордВрдЬрд╝--рдпреБрд╕ рдореЗрд╕реЗрдЬ рдЫреА рд▓реЗрдЯрд░ рд╕рд╛рде рдпреБрд╕ рд╣рд╡рди рдЫреА 2 рдкреНрд▓реЗрд╕ рдмрд░реЛрд╣--рдпреЗ рдЫреА рдПрд╡рдВ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдиреЗ рддрд╛рдХрд┐ рдпреЗ рд╣рдХрд╝ рдмрджрд▓рд┐рдд рдХреЗрд╕ рдСрдлрд╝ рд╕рд▓реАрдо рд▓реЗрдЯрд░ ,рдЗ рдЫреА рд╕рдмрд╡реЗ рдХрд╛рд░рди рд╡реЛрдХреЗрд▓реНрд╕ --рдЕрдЦ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ рдпреБрд╕ рдореЗрд╕реЗрдЬ рд▓реЗрде ,рддреЗ рдЕрде рдордВрдЬрд╝ --  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =","canonical_solution":"encode :: String -> String\nencode = map transformChar\n  where\n    transformChar :: Char -> Char\n    transformChar c\n      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c\n      | otherwise      = swapCase c c\n      where\n        lowerC = toLower c\n\n    isVowel :: Char -> Bool\n    isVowel c = c `elem` \"aeiou\"\n\n    swapCase :: Char -> Char -> Char\n    swapCase origC c\n      | isUpper origC = toLower c\n      | otherwise     = toUpper c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_94","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рддреБрдореЛ рдХрд░ рдкрдиреБрди рдмреЗрд╕реНрдЯ рдкреНрд░рд╛рдЗрдо рд╡реИрд▓реНрдпреВ рдкрддрд╛ рддреЗрдо рд╕реВрдВрдб рдбрд┐рдЬреАрдЯ рд╣реБрдиреНрдж рд╕реБрдореНрдо рдХрд░реЛ--реЗрдореЛ рд╡реБрди рдЗрдВрдЯреЗрдЬрд░рд╕ рдЫреА рдЖрд╕рд╛рди--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =","canonical_solution":"skjkasdkd :: [Int] -> Int\nskjkasdkd lst = sumDigits (largestPrime lst)\n\n-- Function to check if a number is prime\nisPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]\n\n-- Integer square root using binary search, O(log n)\nisqrt :: Int -> Int\nisqrt n = floor . sqrt $ fromIntegral n\n\n-- Function to find the largest prime in the list\nlargestPrime :: [Int] -> Int\nlargestPrime = foldr (\\x acc -> if isPrime x && x > acc then x else acc) 0\n\n-- Function to calculate the sum of the digits of a number\nsumDigits :: Int -> Int\nsumDigits 0 = 0\nsumDigits n = n `mod` 10 + sumDigits (n `div` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_95","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдлрдВрдХреНрд╢рди рдЫреВ рдЧрд▓рдд рд░рд┐рдЯрд░реНрди рдХрд╛рд░рди рдЕрдЧрд░ рджреЗрд╡рди рдПрд╕реЛрд╕рд┐рдПрд╢рди рд▓рд┐рд╕реНрдЯ рдЫреВ рдЦрд▓реА рдЕрд╕рд╛.--рдХреЗрд╕ рдпрд╛ рд╕рд▓реАрдо рдХреАрдЬ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЕрдкрд░ рдХреЗрд╕ рдордВрдЬрд╝ ,рдЕрд▓реНрдЧ рдЫреВ рдлреЙрд▓рд╕ рд░рд┐рдЯрд░реНрди рдХрд╛рд░рди-------рдПрд╢рд┐рдпрд╛ рд▓рд┐рд╕реНрдЯ рджреАрдж, рдЕрдЧрд░ рддрдорд╛рдо рдХреБрдВрдЬреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЗрди рд▓реЛрдЕрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб рдЕрдВрдбрд░ рдОрдВрдб--  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =","canonical_solution":"import Data.Char (isUpper, isLower)\n\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase [] = False\ncheckDictCase dict = all isLower allKeys || all isUpper allKeys\n  where\n    allKeys = concatMap fst dict","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_96","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдЗрдВрддреЗрдЬрд░рд╕ рдпрдо рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░ рдЫреА рдмреЗ рдЫреА рдХрдо рдПрди рдирд┐рд╖реН--рдпреБрд╕ рдлрдВрдХреНрд╢рди рдЫреА рдпреЗ рдЫреА рдиреЗ рдиреЗрдЧреЗрдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдХрд╛рд░рди рд░рд┐рдЯрд░реНрди--  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =","canonical_solution":"countUpTo :: Int -> [Int]\ncountUpTo n = filter isPrime [2..n-1]\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_97","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдорд╛рдиреЛ рдЗрдирдкреБрдЯ рд╣рдореЗрд╢рд╛ рд╡реИрд▓рд┐рдб рд╣реЛред--рдгрдгрдг рдгрдгрдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг--реЗрдореБрдХ рдлрдВрдХреНрд╢рди рдЫреА рдЕрд╕ рдХрд╛рд░рди реЗрдХрд╕ рдЗрдиреНрдЯрд┐рдЬрд░ рдмреЗ рджреБрдИрдд реЗрдореБрдХ--  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =","canonical_solution":"multiply :: Int -> Int -> Int\nmultiply a b = (abs a `mod` 10) * (abs b `mod` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_98","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: -- рд╕рд┐рдЯреНрд░рд┐рдЩ s рджреЗрд╡рди рд╕, рдЕрдкрд░рдХреЗрд╕ рд╡реЛрд▓реНрд╡рди рд╣реБрдиреНрдж рддрд╛рджрд╛рдж рдкреЗрд░ рдЗрдиреНрдбреЗрдХреНрд╕ рдордВрдЬрд╝ рдд рдЧрдЫреБрди --  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =","canonical_solution":"countUpper :: String -> Int\ncountUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` \"AEIOU\"]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_99","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --реЗрдХрд╕ рдкреЗрда рджреВрдБ рдЗрдиреНрдЯрд┐рдЬрд░рди рдкреЗрда ,рдЕрде рдЫреА рдЕрд╕ рд░рд╛рдЙрдВрдб рдХрд╛рд░рди рдЬреАрд░реЛ рдирд┐рд╖реН рджреВрд░--рдЕрдЧрд░ рдпреЗ рдирдВрдмрд░ рдмрд░рд╛рдмрд░ рджреБрд░ рдЕрд╕рд┐рде--рдпреБрд╕ рдлрдВрдХреНрд╢рди рдЫреА рдЗ рдЫреА рдХрд╛рд░рди рдирдВрдмрд░ (рд╕реНрдЯреНрд░рд┐рдВрдЧ)--  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =","canonical_solution":"closestInteger :: String -> Int\nclosestInteger value = \n  let n = read value :: Double\n  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_100","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --i рдЫреВ рд▓реЗрд╡рд▓ (i+1) рдордВрдЬрд╝ рд╕реНрдЯреЛрдиреНрд╕ рд╣рд┐рдВрдЬ рддрд╛рджрд╛рдж рд╣рд╡рди.--                        --- рдпреЗ рдЫреА рдиреЗрдХреНрд╕реНрдЯ рдЬреЛрдбрд╝реА рдирдВрдмрд░ рдЕрдЧрд░ n рдЫреА рдЬреЛрдбрд╝реА--- рдиреЗрдХреНрд╕реНрдЯ рдУрдб рдирдВрдмрд░ рдЕрдЧрд░ n рдУрдб рдЫреВ--рдиреЗрдХреНрд╕реНрдЯ рд▓реЗрд╡рд▓ рдордВрдЬрд╝ рдЫреА рдирдВрдмрд░ рд╕реНрдЯреЛрдиреНрд╕:--рдЧреЛрдбреНрдиреБрдХ рд▓реЗрд╡рд▓ рдЫреА рдПрди рд╕реНрдЯреЛрдиреНрд╕ рд╕рд╛рде-- рдЕрдЧрд░ рдЕрд╕ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ n рджреЗрд╡рди ,рддреЛрд▓ рдЧрд╕рдг рдЕрд╕ рдкрд╛рде рдкрдерд░реА рдмрдирд╛рди--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =","canonical_solution":"makeAPile :: Int -> [Int]\nmakeAPile n = take n [n, n + 2 ..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_101","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдпреБрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рдЕрд▓рдЧ рдХрд░рдиреЗ рд▓рдлрд╝реНрдЬрд╝рди рдордВрдЬрд╝ рдмреЗ рдЫреА рдПрд╡рдВ рд╡рд╛рдкрд╕ рд╡рдЪрди рд▓рдлрд╝реНрдЬрд╝рди рд╣реБрдиреНрдж--реН рдЬрд╝рдмрд╛рдирд┐ рд╣реБрдиреНрдж рдЕрдЦ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреВ рджреЗрд╡рди,рдпреБрд╕ рдХреЙрдорд╛ рдпрд╛ рд╕реНрдкреЗрд╕ рд╕реЗрдд рдЕрд▓рдЧ рдЫреВ рдЕрд╕рд╛.--  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =","canonical_solution":"wordsString :: String -> [String]\nwordsString s = words $ map (\\c -> if c == ',' then ' ' else c) s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_102","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдЕрдЧрд░ рдЕрд╕ рдиреЗ рдЕрд╕ рдПрд╡рдВ ,рддрд┐рд▓ рдЧрд╕ рдЕрд╕ рдлрдВрдХреНрд╢рди -рез рд╡рд╛рдкрд╕ рдХрд╛рд░рди--рдЕрдЧрд░ рдЕрд╕ рд╡реБрдЫреЛ рдХреА рдЕрд╕ рдЫреА рд╡рд░реАрдп рдЕрд╕рд▓ рдЗрдиреНрдЯрд┐рдЬрд░ рдПрдХреНрд╕ ,рд╡рд╛рдИ рдордВрдЬрд╝--рдпреЗ рдлрдВрдХреНрд╢рди рдЫреВ рдЬрд╝реЗ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдирдВрдмрд░ рдПрдХреНрд╕ рддреЗ рд╡рд╛рдИ рддреЗ рдЫреВ рдбрд╝рд┐рд╕рд░реНрдЯрди --  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =","canonical_solution":"chooseNum :: Int -> Int -> Int\nchooseNum x y\n    | x > y = -1\n    | even upperBound = upperBound\n    | even (upperBound - 1) = upperBound - 1\n    | otherwise = -1\n  where\n    upperBound = max x y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_104","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдиреЛрдЯ: рд░рд┐рдЯрд░реНрдирдб рд▓рд┐рд╕реНрдЯ рдЖрд╡ рд╕реЙрд░реНрдЯ рдХрд╛рд░рдг рдЕрдХрд┐рд╕ рдСрд░реНрдбрд░реНрд╕ рдордВрдЬрд╝--реЗрд▓реЗрдореЗрдВрдЯреНрд╕ рдпрдо рдиреЗ рдХрд╣рдБ рддреЗ рд╕рдо рдбрд┐рдЬрд┐рдЯ рдЫреА рдЖрд╕рд╛рди-- рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЧрд░ x рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди --  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =","canonical_solution":"uniqueDigits :: [Int] -> [Int]\nuniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_105","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --\"рд╡рди\", \"рдЯреВ\", \"рдереНрд░реА\", \"рдлреЛрд░\", \"рдлрд╛рдЗрд╡\", \"рд╕рд┐рдХреНрд╕\", \"рд╕реЗрд╡рди\", \"рдЖрда\", \"рдирд╛рдЗрдиреЗ\".--рдпреБрд╕ рдпреЗ рд▓рд┐рд╕реНрдЯ рдЫреА рдЕрде рдЫреА рдЕрд╕ рдХрд╛рд░рди рд░рд┐рд╡рд░реНрд╕ ,рдмреЗ рдЫреА рдПрдореН рдкрд╛рдд рдХрд╛рд░рди рд╣рд░ рдбрд┐рдЬрд┐рдЯ рдмрджрд▓--рдЗрдВрдЯреЗрдЧрд░рди рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди,рддреЗрдо рдЗрдВрдЯреЗрдЧрд░ рдХреНрд░ рд╕реЙрд░реНрдЯ рдпреЗрдо 1 рддреЗ 9 рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ,--  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the list is empty, return an empty list:\n--  >>> byLength []\n--  []\n--  If the list has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =","canonical_solution":"byLength :: [Int] -> [String]\nbyLength arr = map digitName . reverse . sort . filter isValid $ arr\n  where\n    isValid x = x >= 1 && x <= 9\n    digitName x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"\n      _ -> error \"Unexpected number\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_106","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдпреБрд╕ рдлреИрдХреНрдЯреЛрд░рд┐рдпрд▓ рдЫреА I рдпреЗ рдЫреА рдорд▓реНрдЯреАрдкреНрд▓рд┐рдХреЗрд╢рди рдирдВрдмрд░реНрд╕ рдкреЗрда 1 рдкреЗрда I рддрд╛рдо (1 * 2 * ... * I)--i рдЫреА рд╢реБрд░реВ рдЧрд╛рд╕рди 1 рдкреЗрда--рдпрд╛ рдЕрд╕реБрдо рдирдВрдмрд░ 1 рдкреЗрда i рддрд╛рдо--рддреЗрдо рдЫреВ рд╕рд╛рдЗрдЬ n рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рддреЗ рджреЗрд╡рди,рдпреЗрде рдкреЗрда рдЗрдВрдбреЗрдХреНрд╕ i рдкреЗрда рдПрд▓рд┐рдореЗрдВрдЯ рд╣реБрдиреНрдж рд╡реИрд▓реНрдпреВ рдЫреВ рдлреИрдХреНрдЯреЛрд░рд┐рдпрд▓ рдСрдлрд╝ i рдпреЗрд▓ i рдЬреЛрдбрд╝реЗ рдЫреВ.--f рдлрдВрдХреНрд╢рди рдЫреВ рдЕрдорд▓реА рдмрдирд╛рд╡рди рдпреБрд╕ n рдЫреВ рдкреИрд░рд╛рдореАрдЯрд░,--  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =","canonical_solution":"f :: Int -> [Int]\nf n = map g [1..n]\n  where\n    g i\n      | even i    = factorial i\n      | otherwise = sum [1..i]\n    \n    factorial 0 = 1\n    factorial m = product [1..m]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_107","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ 1: --рдЗрдВрдЯреЗрдЧрд░ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдореНрд╕ рдпреБрд╕ рд░реЗрдВрдЬ рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ--рдпреБрд╕ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдЫреА ,рдпреЗ рдЫреА рдХрд╛рд░рди рдЯрдкрд▓ рдпреБрд╕ рдЕрд╕ рдПрд╡рдВ рдЫреА рдирдВрдмрд░ рдСрдлрд╝ рдЬреЛрд░ рддреЗ рдУрдб--  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =","canonical_solution":"evenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n = (length evens, length odds)\n  where\n    isPalindrome x = show x == reverse (show x)\n    palindromes = filter isPalindrome [1..n]\n    evens = filter even palindromes\n    odds  = filter odd palindromes","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_108","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреИрд░ рдкреЗрда -123 рдЫреА рд╕рд╛рдЗрди рдбрд┐рдЬрд┐рдЯ -1, 2 ,рдмреЗ 3--рдЕрдЧрд░ рдЖрдБрдЦ рдирдВрдмрд░ рдЫреА рдиреЗрдЧреЗрдЯрд┐рд╡ ,рддрд┐рд▓ рдЫреА рдЧреЛрдбреНрдиреБрдЦ рд╕рд╛рдЗрдиреЗрдб рдбрд┐рдЬрд┐рдЯ рдиреЗрдЧреЗрдЯрд┐рд╡--рдпреБрд╕ рдирдВрдмрд░ рдЫреА рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣реБрдиреНрдж рд╕реБ рдЫреА рдЕрд╕ рдбрд┐рдЬреАрдЯрд╕ > 0--реЗрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ count_nums рдпреБрд╕ рдЗрдВрддреЗрдЬрд░рд╕ рд╣реБрдиреНрдж рд▓рд┐рд╕реНрдЯ рдЫреА рд▓реЗрд╡рд╛ рдд рдмреИ рд╡рд╛рдкрд╕ рдХрд╛рд░рди--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =","canonical_solution":"countNums :: [Int] -> Int\ncountNums arr = length $ filter ((> 0) . sumDigits) arr\n  where\n    sumDigits 0 = 0\n    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)\n                  in sum digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_109","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдиреЛрдЯрдГ рджреЗрди рдЧреЗрдиреЗрдЯреЗрдб рд▓рд┐рд╕реНрдЯ рдЫреЗ рдпреВрдирд┐рдХ рдПрд▓рд┐рдореЗрдВрдЯрд╕ рдЖрд╕рд╛рдиред--рдЕрдЧрд░ рджреЗрд╡рди рд▓рд┐рд╕рдЯ рдЫреВ рдЦрд▓реА рддреЗрдо рдкрд╛рдд рдЫреВ рдЯреНрд░реВ рд╡рд╛рдкрд┐рд╕.--рдЕрдЧрд░ рдЕрд╕ рд╕рд╣реА рдЫреА ,рддрде рдЫреА рдЕрд╕ рдЧрд▓рдд рддреЗ рд░рд┐рдЯрд░реНрди--рдЕрдЧрд░ рдпреЗ рдореБрдордХрд┐рди рдЖрд╕ рдХреА рдЕрд╕ рдХрд░реЛ рд╕реЙрд░реНрдЯ рд▓рд┐рд╕реНрдЯ рдпрд┐рд▓ рдЕрд╕ рд╡рд░реАрдп рдСрдкрд░реЗрд╢рди рдХрд░реЛ--рдпреБрд╕ рд╢реБрд░реВрдЖрддреА рдкреЛрдЬреАрд╢рди рдЫреА рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдпрд╛рдиреЗ 0th рдЗрдВрдбреЗрдХреНрд╕--рдЖрдЦрд░реА рдПрд▓рд┐рдореЗрдВрдЯ рдЫреА --рдЕрдЦ рджрд╛рд╣реНрдиреА рд╢рд┐рдлреНрдЯ рдСрдкрд░реЗрд╢рди рдорддрд▓рдм рдЫреБ рдЬрд╝рд┐ рд╕рд╛рд░рд┐рд╡рдп рдПрд▓рд┐рдореЗрдВрдЯ рдЫреБ рдЕрдХрд┐рд╕ рд╣рд┐рд╡рд┐ рд╕реЙрддрд┐ рд╢рд┐рдлреНрдЯ рдЧрдЫрд╛рдиред--рддреБрд╣реНрдпрд╝ рд╣реЗрдХрд┐рд╡ рдпрд┐рдо рд╡рд╛рд░рд┐рдпрд╛рд╣ рд╡рдЦрддрд╣ рджрд╛рд╣ рд╢рдлрд╝реНрдЯ рдХрд░рд╛рдиред--рдпреБрд╕ рдСрдкрд░реЗрд╢рди рдЫреА рдПрдореН рдЫреА рдПрд╡рдВ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝:--рдпреЗ рдЫреА рдореБрдордХрд┐рди рдХреА рдЕрд╕ рд╣рдХреЛ рд▓рд┐рд╕реНрдЯ рдХреНрд░реЙрд░реНрдЯреАрдлрд╝рд┐рдП рдХрд░рде рдиреЙрди-рдбрд┐рдХреНрд░реЗрд╡рд┐рдВрдЧ рдСрд░реНрдбрд░ рдордВрдЬрд╝ --рдпреБрд╕ рдирдВрдмрд░ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рд░реИрдВрдбрдорд▓реА рдСрд░реНрдбрд░рд┐рдВрдЧ рдХрд╛рд░рдг--                                                                                    --  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given list.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  list by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =","canonical_solution":"moveOneBall :: [Int] -> Bool\nmoveOneBall [] = True\nmoveOneBall arr = canBeSorted (arr ++ arr)\n  where\n    n = length arr\n    canBeSorted xs = any isSorted (take n <$> tails xs)\n    isSorted ys = and $ zipWith (<=) ys (tail ys)\n    tails [] = []\n    tails l@(_:xs) = l : tails xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_110","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдЕрдЧрд░ рдиреЗ рдЕрд╕рд┐рде ,рддреЗрд▓ рдХрд░реЛ \"рдирд╛\" рд╡рд╛рдкрд╕--lst1 рд╣рд┐рдиреНрдЬрд╝ рддрдорд╛рдо рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рдЕрд╕рд┐рде, рд╡рд╛рдкрд╕ \"YES\".--рдЕрдЧрд░ рдпреЗ рдореБрдордХрд┐рди рд╣реИрдХ рдЕрд╕рд┐рде рдХреА рдЕрд╕ рд╣рдХреЛ рдмрджрд▓рд┐рдд рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ lst1 рдмреЗ lst2 рджрд░рдорд┐рдпрд╛рди рддрд╛рдХрд┐ --lst1 рддреЗ lst2 рджрд░рдорд┐рдпрд╛рди рдПрдХреНрд╕рдЪреЗрдВрдЬ рдПрд▓рд┐рдореЗрдВрдЯрди рд╣рд┐рдВрдЬ рдирдВрдмрд░ рдкреЗрда рдЫреБрдВ рдХрд╣реЗрдВ рд▓рд┐рдорд┐рдЯ.--реЗрдореЛ рдХреБрд░ рдЖрдЦрдГ рд▓рд┐рд╕реНрдЯ рд╕рд┐рд░реНрдл рдкрд░ рдирдВрдмрд░реЛрдВ рд╕реЗрде--рдд рдмреИ рдпрд╣ рдЫреА рдбреЗрдЯрд░реНрдорд┐рдиреЗ рдХрд░рд╛ рдХреА рдХреНрдпрд╛ рдпрд╣ рд╣реИрдХ рдЖрдореБрдд рдПрдХреНрд╕рдЪреЗрдВрдЬ рдХрд░рд┐рде--реЗрдо рдЕрд╕ рдлрдВрдХреНрд╢рди рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд╛рд░рди рдпреБрд╕ рдЬрд╝реЗ рдирдВрдмрд░ рдЫреА рд░рд▓рди--  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =","canonical_solution":"exchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | all even lst1 = \"YES\"\n  | null oddLst1 || null evenLst2 = \"NO\"\n  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)\n                in if possibility then \"YES\" else \"NO\"\n  where\n    oddLst1 = filter odd lst1\n    evenLst2 = filter even lst2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_111","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЕрдЧрд░ рдХрд╣рдБ рддреЗ рд▓реЗрдЯрд░ рдЫреА рдПрд╡рдВ рдПрдХрд┐рд╕ рдЬрд╛рдЗ рдкреЗрда ,рддрд╣ рдЫреА рдЕрде рд╕рд▓реАрдо рд╡рд╛рдкрд╕ рдХрд╛рд░рди--рдпреБрд╕ рд▓реЗрдЯрд░ рдЫреА рд╕реБ рдЫреА рд╡рд╛рд░рд┐рдпрд╛ рд░рд┐рдкреАрдЯ рдХрд╛рд░рди рдмреЗ рдЫреА рдЕрде рд╣рд┐рд╕рд╛рдм рдХрд╛рд░рди------- рд▓реБрдХрд▓рд╕реЗрд░реНрд╕ рд╕реЗрдкрд░реЗрдЯреЗрдб рд╕реНрдкреЗрд╕рд╕ рд░рд┐рдкреНрд░реЗрдЬреЗрдВрдЯ рдХрд░рдВрдЯреНрд╕, рд░рд┐рдЯрд░реНрди рдПрд╕реЛрд╕рд┐рдПрд╢рди рд▓рд┐рд╕реНрдЯ--  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nhistogram :: String -> [(String, Int)]\nhistogram input =\n  let wordsList = words input\n      grouped = group $ sort wordsList\n      countList = map (\\ws -> (head ws, length ws)) grouped\n      maxCount = if null countList then 0 else maximum $ map snd countList\n  in filter ((== maxCount) . snd) countList","tests":"\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_112","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --рддреБрд╣реНрдпрд╝ рдЧрд╡ рд░реЕрд▓рд┐рде рдЯреНрдпреБрдкрд▓ рдпрде рдореНрдиреНрдЬрд╝ рд░реЕрд▓рд┐рде рд╕рдЯреНрд░реЗрдиреНрдЧ рдд рдЯреНрд░реВ\/ рдлрд╝реЛрд▓реНрдЬрд╝ рдЫрд┐ред--рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреВ рдкреИрд▓рд┐рдВрдбреНрд░реЛрдо рд╡рд╛рдирд╛рди рдЕрдЧрд░ рдпреЗ рдмреИрдХрд╡рд░реНрдб рддреЗ рдлреЙрд░рд╡рд░реНрдб рдордВрдЬрд╝ рд╢рд╛рдореЗ рдкрд╛рда рдЫреВ рдХрд░рд╛.--рддрдорд┐ рдкрддрдГ рд╡реБрдЫреЛ рдЬрд╝рд┐ рд░рд┐рдЬрд╝рд▓реНрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреБ рдкрд╛рд▓рд┐рдиреНрдбреНрд░реЛрдоред--S рддреЗ C рддреЗрдо рд╕рд┐рдВрдж рд╕рд╛рд░реЛ рд╡рд░реНрдгреЛ рд╣рдЯрд╛рдУ--рдЯрд╛рд╕реНрдХ.--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =","canonical_solution":"import Data.List (filter)\n\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =\n  let result = filter (`notElem` c) s\n  in (result, result == reverse result)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_113","nl":"kas_Deva","pl":"hs","prompt":"--рдгрдгрдгрдо рдгрдо рдгрдо рдгрдо рдгрдо рдгрдо рдгрдо рдгрдо рдгрдо рдгрдо рдгрдо--рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ i. \"рдпреЗрддрд╕ рдордВрдЬрд╝ рд╕рд▓реАрдо рдЖрдИрдПрд╕ рд╣рдХреЛ рдЕрд╕ рдирдВрдмрд░ рд╕реЗрде рдмрджрд▓рд┐рдд--рд╣рд░ рдЖрд▓рд┐рдореЗрдВрдЯ рдЖрдп рдСрдлрд╝ рдЖрдЙрдЯрдкреБрдЯ рдЧрд╕рдг \"рдирдВрдмрд░ рдСрдлрд╝ рдУрдб рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рдЗрди -- рдЕрдЧрд░ рдЕрд╕ рд╡реБрдЫреЛ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рд╣реБрдиреНрдж рд▓рд┐рд╕реНрдЯ ,рдпрд┐рдд рд╕рд▓реАрдо рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА рдЖрд╕рд╛рди рд╕рд┐рд░реНрдл рдбрд┐рдЬрд┐рдЯ ,рддреЛрд▓ рдЕрд╕ рд▓рд┐рд╕реНрдЯ рдХрд╛рд░рди--  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =","canonical_solution":"oddCount :: [String] -> [String]\noddCount lst = map formatString lst\n  where\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"\n\n    countOdds :: String -> Int\n    countOdds str = length $ filter isOddDigit str\n\n    formatString :: String -> String\n    formatString str =\n      let oddCount = countOdds str in\n      \"the number of odd elements \" ++ show oddCount ++ \n      \"n the str\" ++ show oddCount ++ \"ng \" ++ show oddCount ++\n      \" of the \" ++ show oddCount ++ \"nput.\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_114","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --рдгрдгрдо рдгрдо рдгрдо рдгрдо--рдЕрдЧрд░ рдЕрд╕ рд╡реБрдЫреЛ рдЗрдиреНрдЯрд┐рдЬрд░рд╕ рд╣реБрдиреНрдж рд▓рд┐рд╕реНрдЯ ,рддреЗрд▓ рдЕрд╕ рд╡рд░реАрдп рдХрдо рдиреЛрди -рдПрдореНрдкреНрд▓реАрдореЗрдВрдЯреНрд╕ рд╣реБрдиреНрдж рд╕реБрдм-рд▓рд┐рд╕реНрдЯ--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =","canonical_solution":"minsubarraysum :: [Int] -> Int\nminsubarraysum nums = minimum $ scanl1 (\\acc x -> min x (acc + x)) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_115","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ 1: --рдмрдХреЗрдЯ рдиреАрдЪреЗрдВ рдХрд░рдиреЗ рдЦрд╛рддрд┐рд░ рдЫреВ рдЬрд╝рд░реВрд░рдд рдирдВрдмрд░ рдЖрдЙрдЯрдкреБрдЯ.--рддреБрд╣рдВрдЬреА рдХрд╛рдо рдЫреЗ рдХреБрдВрдЖрдВ рдЦрд╛рд▓реА рдХрд░рдг рдЦрд╛рддрд░ рдмрдХреЗрдЯ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдирд╛.--рддреТ рд╕рд╛рд░реЖрдп рдмрдХреЗрдЯреТ рдЫреЗ рдмрд░рд╛рдмрд░ рдХрд╛рдкрд╛рд╕рд┐рдЯреА рд╡рд╛рд▓реНрдпреН.--рд╣рд░ рдХреБрдВрдЖрд╕ рдордВрдЬрд╝ рдЫреА рдЖрдЦрдГ рдмрдХреЗрдЯ рдпреБрд╕ рдЗрд╕реНрддреЗрдорд╛рд▓ рдЫреА рдХрд╛рд░рди рдкрд╛рдиреА рд╣рдбрд╝рдиреЗ рдЦрд╛рддрд░--рдмреЗ рд╣рд░ 1 рдЫреА рдПрд╡рдВ рд░реЗрддрди рдкрд╛рдиреА рдпреВрдирд┐рдЯ рд╣рд┐рд╕рд╛рдм--реЗрдореЛ рджреАрд╡ рддреБрдорди рд░рд┐рдЯреЗрдВрдЧреБрд▓рд░ рдЧреНрд░рд┐рдб рдпреБрд╕ рд╡реЗрд▓ рдЫреА ,рд╣рд░ рд╛рдЦ рд░реМрд╕ рдЫреА рд╣рд╡рди рд╕рд┐рдВрдЧрд▓ рд╡реЗрд▓--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =","canonical_solution":"maxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity = ceiling (fromIntegral totalWater \/ fromIntegral capacity)\n  where\n    totalWater = sum (map sum grid)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_116","nl":"kas_Deva","pl":"hs","prompt":"--рдпрд┐ рдЫреБ рдпрд┐рде рдХрдирд┐ рдЕрдорд▓ рдХрд░рдирд┐ рдпрд┐рд╡рд╛рди:--рдЕрдЧрд░ рдЕрд╕ рддреЗрдо рдЕрд╕ рд╡рд░реАрдп ,рддреЗрдо рдЕрд╕ рдбреЗрд╕реАрдорд▓ рд╡реИрд▓реНрдпреВ рдкреЗрда рдЖрдзрд╛рд░рд┐рдд--реЗрдореЛ рдХреБрд░ рдПрдкреНрд▓реАрдХреЗрд╢рди рдирдВрдмрд░ рд╡рди реЗрдорди рд╣рд┐рдиреНрдж рдмрд╛рдЗрдирд░реА рд░рд┐рдкреНрд░реЗрдЬреЗрдВрдЯреЗрд╢рди рдордВрдЬрд╝--рдпреБрд╕ рдпреЗ рдХрд╛рдЯрд╛ рдЫреА ,рдЕрд╕ рдЫреА рдХрд╛рд░рди рд╕реЙрд░реНрдЯ рд▓рд┐рд╕реНрдЯ рдиреЙрди -рдиреЗрдЧреЗрдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░рд╕ рд╣рд┐рд╕рд╛рдм--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =","canonical_solution":"import Data.Bits (popCount)\nimport Data.List (sortBy)\n\nsortArray :: [Int] -> [Int]\nsortArray arr = sortBy compareOnesAndValues arr\n  where\n    compareOnesAndValues x y =\n      let onesX = popCount x\n          onesY = popCount y\n      in if onesX == onesY\n         then compare x y\n         else compare onesX onesY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_117","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдиреЛрдЯ: рддреБрд╣реНрдпрд╝ рд╣реЗрдХрд┐рд╡ рдорд╛рдирдпрде рдЬрд╝рд┐ рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдореНрдиреНрдЬрд╝ рдЫрд┐ рд╕рд┐рд░рд┐рдлрд╝ рд▓рдлрд╝рдЬрд╝ рдд рд╕реНрдкреЗрд╕ рдЖрд╕рд╛рдиред--рдЕрдЧрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ s рдЫреВ рд░рд┐рдХреНрдд рддреЗрдо рд╡рдХрд╝рдд рдлрдВрдХреНрд╢рди рдЫреВ рд░рд┐рдХреНрдд рд▓рд┐рд╕реНрдЯ рд▓рдмрдиреАрдЪ.--n рдХрдВрд╕реЛрдиреЗрдВрдЯреНрд╕, рддрд╛рдХрд┐ рдпреЗ рд▓рдлрд╝рдЬрд╝ рдпреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдордВрдЬрд╝ рд▓рдмрдиреА рдпреЗрд╡рд╛.--рдЕрдЦ рдлрдВрдХреНрд╢рди рдпреБрд╕ рд▓рдлрд╝реНрдЬрд╝рди рд╣рд┐рдиреНрдЬрд╝ рд▓рд┐рд╕реНрдЯ рд▓рдмрдирд╣ рдЫреБ рдпреБрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдордВрдЬрд╝ рдЫреБ рдпрде рдордВрдЬрд╝ --рдпреБрд╕ рдЕрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА s рддреЗ рдиреЗрдЪреБрд░рд▓ рдирдВрдмрд░ n ,рдЕрд╕ рдХрд░реЛ рддреБрдо рддреИрд░рд╛рдХреА--  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =","canonical_solution":"selectWords :: String -> Int -> [String]\nselectWords s n = filter (\\word -> countConsonants word == n) (words s)\n  where\n    countConsonants = length . filter (`elem` consonants)\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_118","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рддреБрд╣реНрдпрд╝ рд╣реЗрдХрд┐рд╡ рдорд╛рдирдпрде рдЬрд╝рд┐ рджрд┐рддрд┐рди рд╕рдЯреНрд░реЗрдиреНрдбреНрд╕ рдореНрдиреНрдЬрд╝ рдЫреБ рд╕рд┐рд░рд┐рдлрд╝ рдЕрдВрдЧреНрд░реЗрдЬреА рд▓рдлреНрдЬрд╝ред--рдХреБрдВрддреЗ рд╕реНрд╡рд░ рд╡реБрдЫреЛ рдпреЗрдо рдкреЗрда рдХрдВрдбреАрд╢рди рдЫреВ рдореБрд╡рд╛рдлрд╝рд┐рдХрд╝.--рдЕрдЧрд░ рддреБрд╣реНрд╕реАрдВ рди рдХрд░реЛрдВ рдд рддреБрд╣реНрд╕реАрдВ рд░рд┐рдХреНрдд рддрд╛рд░реВ рд╡рд╛рдкрд╕ рдХрд░реЛ--рд▓рдлрд╝рдЬрд╝рд╕ рдордВрдЬрд╝ рдЫреБ рджреЛрди рдХреЛрдиреНрд╕реЛрдирд╛рдЯрд╕ рд▓рдлреНрдЬрд╝рд╕ рджрд░реЗрдорд┐рд╕ рддрд░рдлрд╕ рдкреЗрда (рдорд╢рд╣реВрд░ рдХреЗрд╕ рд╕реЗрд╕рд┐рдЯрд┐рд╡) ред--.рдЕрд╕ рддреБрд╣реНрдпрд╝ рдЕрдХрд┐ рд▓рдлреНрдЬрд╝ рджрд┐рд╡рд╛рди рдЫреБред рдЕрдорд┐рдЪрд╝ рдХрд╛рдо рдЫреЗ рддрдорд┐ рдирдЬрд╝рджреАрдХреА рд╕реНрд╡рд░ рдпрд┐рдо рдЕрдХрд┐ рд▓рдлреНрдЬрд╝рд╕ рджрд░рдорд┐рдпрд╛рди рдЫрд┐ред--  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =","canonical_solution":"getClosestVowel :: String -> String\ngetClosestVowel word = go (reverse word) False\n  where\n    vowels = \"aeiouAEIOU\"\n    go [] _ = \"\"\n    go (x:xs) lastWasConsonant\n      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False\n      | x `notElem` vowels = go xs True\n      | otherwise = go xs False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_119","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЕрдЧрд░ рдЕрд╕ рдиреЗ рдХрд╣рдБ рддреЗ рдЕрд╕рд▓ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдмрдирд╛рдпрд┐рде ,рддреЗрдо рдкрд╛рдд рдЕрд╕ рдиреЗ рдХрд╣рдБ рддреЗ--\" ((()) \" рдЫреБрдВ.--рдпрд┐рдердкрд╛рдиреНрдардГ рд╕реНрдЯреНрд░рд┐рдВрдЧ '(((() ' рдЫреБ рдЕрд╕рд▓, рдпреЗрд▓рд┐ рдЬрд╝рди рд╕реНрдЯреНрд░рд┐рдВрдЧ --рдЕрдЦ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдПрд╕ рдЫреВ рдЧреБрдб рдорд╛рдирд╛рди рдЕрдЧрд░ рддреЗрдо рддреЗ рд╕рд┐рд░реНрдл рдЕрдЧрд░ рдПрд╕ рдордВрдЬрд╝ рд╕рд░реЗ рдХреБрдПрдВ рддреЗрдо --рдХрд╣рдБ рддреЗ рдСрд░реНрдбрд░ ,рдпреБрд╕ рдирддреАрдЬ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА рдЕрд╕рд▓--рддреБрд╣рд┐рдВрдж рдХрд╛рдо рдЫреВ рдпреЗ рдЪреЗрдХ рдХрд░рдиреБрдХ рдХрд┐ рдХреНрдпрд╛ рдпреЗ рдореБрдордХрд┐рди рдЫреВ рдХрд┐ рдЬрд╝реЗ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЗрдирдХрдЪреЗрдиреЗрдб рдХрд░рдиреЗ.--рд╕рд┐рд░реНрдл рдмреНрд░реИрдВрдЯреЗрдХреНрд╕ \" ((\" рдпрд╛ рдмрдВрдж рдмреНрд░реИрдВрдЯреЗрдХреНрд╕ \")) \"---- рддреБрдо рдЫреА рджреЗрд╡рди рдЖрдЦ рд▓рд┐рд╕реНрдЯ рдЬрд╝реЗ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ ,рдЬрд╝реЗ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЫреА рдЖрд╕рд╛рди рдУрдкреЗрди--  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =","canonical_solution":"matchParens :: [String] -> String\nmatchParens [a, b] =\n    if isValid (a ++ b) || isValid (b ++ a) then \"Yes\" else \"No\"\n  where\n    isValid :: String -> Bool\n    isValid = go 0\n      where\n        go 0 [] = True\n        go _ [] = False\n        go n (x:xs)\n            | x == '('  = go (n + 1) xs\n            | x == ')'  = n > 0 && go (n - 1) xs\n    isValid _ = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_120","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ 1: --рдпреБрд╕ рд▓реЛрдВрдЧрде k рдЫреА рдЕрде рдордВрдЬрд╝ рдЫреА рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж k рдиреБрдореНрдмрд░рдВ arr рдордВрдЬрд╝--рдпреБрд╕ рд▓рд┐рд╕реНрдЯ рдЫреА рд╕реБ рдЫреА arr рдЗрдВрдЯреЗрдЬрд░рд╕ рдмреА k рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ ,рд╕реБ рдЫреА рд╕реБ рд╡рд╛рдкрд┐рд╕ рдХрд╛рд░рди рд╕реЙрд░реНрдЯ--  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the list will be in the range of [1, 1000].\n--  2. The elements in the list will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =","canonical_solution":"maximum :: [Int] -> Int -> [Int]\nmaximum arr k = take k $ reverse $ sort arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_121","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --рдЗрдВрдЯрд░рдЬреЗрд░реНрд╕ рд╣рд┐рдВрдЬ рдЕрдЦ рдиреЙрди-рдПрдорд┐рдХрд▓ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди,рддреЗрдо реБрдорди рд╣рд┐рдиреНрджрд╕ рдСрд▓ рдЕрдирдб рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣рд┐рдВрдЬ рдЕрджреНрджрд┐рддреА рджреЗрд╡рди рдпреЗрдо рдЬрд╝реЗ рдкреЙрдЬрд┐рд╢рди рдордВрдЬрд╝ рдЕрд╕.--  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =","canonical_solution":"solution :: [Int] -> Int\nsolution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_122","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдпреБрд╕ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣реБрдиреНрдж рд╕реБрдореНрдо рдЫреА рдЕрде рдордВрдЬрд╝ рдЫреА рдЬрд╝реЗ рдбрд┐рдЬрд┐рдЯ рдЧреЛрджрдиреАрдЪ k рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рдкреЗрда arr--рдЕрдЧрд░ рдЕрд╕ рд╡реБрдЫреЛ рдЗрдиреНрдЯрд┐рдЬрд░ arr рддреЗ k ,рддреЗрдо рдЫреА рдЕрд╕ рд╡рд╛рдкрд┐рд╕ рдХрд╛рд░рди--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =","canonical_solution":"addElements :: [Int] -> Int -> Int\naddElements arr k = sum $ filter (\\x -> x >= -99 && x <= 99) $ take k arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_123","nl":"kas_Deva","pl":"hs","prompt":"--get_odd_collatz(5) рд░рд┐рдЯрд░реНрдирд╕ [1, 5] # рдХреЛрд▓рд╛рдЯреНрдЬрд╝ рд╕реАрдХреНрд╡реЗрдВрд╕ рдлреЙрд░ 5 рдЗрд╕ [5, 16, 8, 4, 2, 1], рд╕реЛ рдереЗрдкреЗрд░ рдирдВрдмрд░реНрд╕ рдЕрд░реЗ рдУрдирд▓реА 1, рдПрдВрдб 5. --рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --2. рдЖрд╡рд░реНрддрд┐рдд рд╕реВрдЪреА рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо рдХреНрд░рдо--1. рдХреЛрд▓рд╛рдЯреНрдЬрд╝ (рез) рдЫреБ [1]ред--рдиреЛрдЯрдГ --рдпреБрд╕ рдХрдЬреЗрдХреНрдЯреБрд░рд╕ рдЫреА рд╕реБ рдЫреА рдХреА рди рдХреА рдХреА рд╡рд░реАрдпрддрд╛ n ,рд╕реБ рдЫреА рд╣рдореЗрд╢рд╛ 1 рд░рдЯрди--рдЕрдЧрд░ рдЧреЛрдбрдирд┐рдХрд┐ рд▓рдлреНрдЬрд╝ рдЫреБ рдЕрдирдб, рддреЛ рдмреЗрдпрд┐ рд▓рдлреНрдЬрд╝ рдЫреБ 3 рдЧреЙрд░ рдмреНрд░реЛрдиреНрд╣ рдХреБрдиред--рдЕрдЧрд░ рдкреНрд░реЗрдЧреНрдиреЗрдВрдЯ рдЫреА ,рддрдореБрдХ рдиреЗрдХреНрд╕реНрдЯ рдЯрд░реНрдо рдЫреА рд╣рд╛рдл --рдпреЗ рдЫреА рдЕрд╕ рд╢реБрд░реВ рдХрд╛рд░рди рдХреБрдПрдВ рддреЗ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рд╕реЗрде .--рдХреЛрд▓рд╛рдЯреНрдЬрд╝ рдХрдВрдЬреЗрдХреНрдЯреБрд░реЗ рдЫреА рдореИрдердореИрдЯрд┐рдХреНрд╕ рдордВрдЬрд╝ рдпреБрд╕ рдЫреА рдПрд╡рдВ рд╕реАрдХреНрд╡реЗрдВрд╕ рдбрд┐рдлрд╛рдЗрди рдХрд░рдиреЗ--рдпреБрд╕ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдЫреА рд╕реБ рдЫреА рд╡рд╛рдкрд╕ рдХрд╛рд░рди рд╕реВрд░реНрдЯ рдпреБрд╕ рдЕрд╕ рдиреЗ рдЕрд╕ рдПрд╡рдВ рдХреЛрд▓рд╛рдЯреНрдЬрд╝ рд╕реАрдХреНрд╡реЗрдВрд╕ рдордВрдЬрд╝--  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =","canonical_solution":"getOddCollatz :: Int -> [Int]\ngetOddCollatz n = sort . filter odd $ collatzSequence n\n  where\n    collatzSequence 1 = [1]\n    collatzSequence x\n      | even x    = x : collatzSequence (x `div` 2)\n      | otherwise = x : collatzSequence (3 * x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_124","nl":"kas_Deva","pl":"hs","prompt":"--4. рддрд╛рд░реАрдЦ рдлреЙрд░реНрдореЗрдЯ рдореЗ рд╣реЛрдиреА рдЪрд╛рд╣рд┐рдпреЗ: mm-dd-yyyy --3. рдпреЗ рд╣рдХреЛ рди 1 рдордВрдереНрд╕ рдирд┐рд╖реН рдХрдо рдпрд╛ 12 рдордВрдереНрд╕ рдЦреЛрдд рдЬрд╝рдпрд╛рдж рдЕрд╕рд┐рде--2. рджрд┐рдирди рд╣рд┐рдиреНрдЬрд╝ рддрд╛рджрд╛рдж рдЫреЗ 1,3,5,7,8,10,12 рдордВрдерди рдЦрд╛рддреНрд░рд┐ 1 рдХрдо рдпрд╛ 31 рджрд┐рдирди рдЦреЛрдд рдЬрд╝реНрдпрд╛рдж рдЖрд╕рд╛рдиред рдд рджрд┐рдирди рд╣рд┐рдиреНрдЬрд╝ рддрд╛рджрд╛рдж рдЫреЗ 4,6,9,11 рдордВрдерди рдЦрд╛рддреНрд░рд┐ 1 рдХрдо рдпрд╛ 30 рджрд┐рдирди рдЦреЛрдд рдЬрд╝реНрдпрд╛рдж рдЖрд╕рд╛рдиред рдд, рдорд╛рд╣ 2 рдЦрд╛рддреНрд░рд┐ рджрд┐рдирди рд╣рд┐рдиреНрдЬрд╝ рддрд╛рджрд╛рдж рдЫреЗ 1 рдХрдо рдпрд╛ 29 рджрд┐рдирди рдЦреЛрдд рдЬрд╝реНрдпрд╛рдж рдЖрд╕рд╛рдиред--1. рдбреЗрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреВ рди рдЦрд╛рд▓реА.--рдЕрдЧрд░ рдПрдПрдо рддрдорд╛рдо рд░реВрд▓рди рд╣рд┐рдВрдЬ рдкрд╛рд▓рдирд╛ рдЫреВ рдпреЗрд╡рд╛ рдХрд░рдиреЗ рддреЗрдо рддрд╛рд░реАрдЦ рдЫреВ рд╡реИрд▓рд┐рдб рдпреЗрд╡рд╛ рдХрд░рдиреЗ:--рдЕрдЧрд░ рдбреЗрдЯ рд╡реИрд▓рд┐рдб рдЫреВ рддреЗрдо рдЫреВ рдЯреНрд░реВ рд░рд┐рдЯрд░реНрди рдХрд░рд╛,рдЕрдЧрд░ рд╡реИрд▓рд┐рдб рдЫреБрдВ рддреЗрдо рдЫреВ рдЧрд▓рдд.--реЗрдо рдЫреА рдЕрд╕ рдкрдирд╕ рдордВрдЬрд╝ рд╡рди рдХреА рдЕрд╕ рдХреНрдпрд╛ рд╣рдХреЛ рдЕрд╕ рд╡реБрдЫрд┐рде--  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06\/04\/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =","canonical_solution":"import Text.Read (readMaybe)\nimport Data.List.Split (splitOn)\n\nvalidDate :: String -> Bool\nvalidDate date =\n    case splitOn \"-\" date of\n        [m, d, y] -> isValidMonthDayYear m d y\n        _         -> False\n\nisValidMonthDayYear :: String -> String -> String -> Bool\nisValidMonthDayYear m d y =\n    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of\n        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day\n        _ -> False\n\nisValidMonth :: Int -> Bool\nisValidMonth month = month >= 1 && month <= 12\n\nisValidDay :: Int -> Int -> Bool\nisValidDay month day\n    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31\n    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30\n    | month == 2                           = day >= 1 && day <= 29\n    | otherwise                            = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_126","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --рдирдВрдмрд░, рд░рд┐рдЯрд░реНрди False. рдиреЛ рдиреЗрдЧреЗрдЯрд┐рд╡ рдирдВрдмрд░реНрд╕ рддреЗ рд╕рд┐рдВрдЧрд▓ рдЗрдВрдЯреЗрдЬрд░рд╕.--рдЕрдЧрд░ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЕрдХрд┐рд╕ рдЦреЛрдд рдЬрд╝рдпрд╛рдж рдбреБрдкреНрд▓рд┐рдХреЗрдЯ рдЖрд╕ --реЗрдХ рдирдВрдмрд░ рд▓рд┐рд╕реНрдЯ рджреЗрд╡рди реЗрд╡рд╛,рддреЗрдо рдЕрд╕ реБрд░реНрддреЗрдб рдпрд╛ рди--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =","canonical_solution":"isSorted :: [Int] -> Bool\nisSorted lst = go lst Nothing\n  where\n    go [] _ = True\n    go [x] _ = True\n    go (x:y:xs) prev\n      | x > y = False\n      | x == y && prev == Just x = False\n      | otherwise = go (y:xs) (Just x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_127","nl":"kas_Deva","pl":"hs","prompt":"--[рдЗрдирдкреБрдЯ\/рдЖрдЙрдЯрдкреБрдЯ] рд╕реИрдВрдкрд▓рдГ --рдЕрдЧрд░ рдЬрд╝реЗ рдЗрдВрдЯрд░рд╡рд▓ рдЫрд╛рди рдЗрдВрдЯрд░рд╕реЗрдХреНрдЯ рдХрд╛рд░рди ,рддреЗрдо рдЫреА рд░рд┐рдЯрд░реНрди рдХрд╛рд░рди \"NO\"--рдЕрдЧрд░ рдиреЗ рдЕрд╕рд┐рде ,рддреЗрд▓ рдХрд░реЛ \"NO\"--рдЕрдЧрд░ рдЗрдВрдЯрд░рд╕реЗрдХреНрд╢рдирди рд╣рд┐рдВрдЬ рд▓реЗрдВрде рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░ рдЫреВ,рддреЗрд▓ рдЫреВ рдпреЗ \"YES\" рд▓рдмрдиреА.--рдпреБрд╕ рд▓реЛрдВрдЧреА рдЫреА рд╕реБ рдЫреА 1 ,рд╕реБ рдЫреА рдиреЗ рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░ рдкреЗрда ,рдпреБрд╕ рдЗрдВрдЯрд░рд╕реЗрдХреНрд╢рди рдЫреВ рдЗрдВрдЯрд░рд╡реЗрд▓реНрд╕ рд╣реБрдиреНрдж (1, 3), (2, 4) рдЫреВ (2, 3)--реЗрдореЛ рдХреБрд░ рдЕрд╕ рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░--рддреЛрдп рдЫреА рдИрд╡рд╛ рд╡рд╛рдирди рдХреА рдХреНрдпрд╛ рдЫреА рдЗрдВрдЯрд░рд╕реЗрдХреНрд╢рди рджреБрдирд┐рдпреЛрдХ--рд╣рд░ рдЖрдЦрдГ рд╡рдЦрддреБрдХ рдЦрд╛рддрд┐рд░ ,рдпреЗ рдЫреА рдПрд╡рдВ рдорд╛рдирд╛ рдХреА рдПрдореВрдХ рд╢реБрд░реВ рдЫреВ рдХрдо рдпрд╛ рдмрд░рд╛рдмрд░ рдПрдореВрдХ рдЦрддрдо--рдЕрде рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ рд╢реБрд░реВ рддреЗ рдЦрд╝рддрдо рджреВрди--рджреЗрдЕрд░ рдЗрдВрдЯрд░рд╡рд▓реНрд╕ рдЕрд░реЗ рдХреНрд▓реЛрдЬреНрдб рд╡реНрд╣рд┐рдЪ рдореАрдиреНрд╕ рдереЗ рдЗрдВрдЯрд░рд╡рд▓реНрд╕ (рд╕реНрдЯрд╛рд░реНрдЯ, рдПрдВрдб)--рдпрд┐рдд рдЫреА рд╣рд░ рдЗрдВрдЯреЗрд░рд┐рдЕрд▓ рдЖрдБрдЦ рдЗрдВрдЯреЗрдЬрд░ рдЬреЛрдбрд╝реА ,рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░ ,рдЗрдВрдЯрд░рд╡рд▓ = (рд╢реБрд░реВ ,рдЕрдВрдд) = (1,2)--тЮбя╕ПрддреБрдорди рдЫреА рджреЗрд╡рди рдЬрд╝реЗ рдЗрдВрдЯрд░рд╡рд▓ ,--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =","canonical_solution":"intersection :: (Int, Int) -> (Int, Int) -> String\nintersection (start1, end1) (start2, end2) = \n    if intersectionLength > 0 && isPrime intersectionLength\n    then \"YES\"\n    else \"NO\"\n  where\n    intersectionStart = max start1 start2\n    intersectionEnd = min end1 end2\n    intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    isPrime :: Int -> Bool\n    isPrime n\n      | n <= 1 = False\n      | n == 2 = True\n      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_128","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдиреЛрдЯ: рд░рд┐рдХреНрдд рдЖрд░рд░ рдЦрд╛рддрд░ рдЫреБрдВ рдХрд╣рдБ рддреЗ рд▓рд╡рди--рдпреБрд╕ рдпреЗ рдирдВрдмрд░ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рд╣рд╡рди 1 , - 1 рдпрд╛ 0--реЗрдиреНрдЯрд┐рдЬрд░рд╕ рд╣реБрдиреНрдж рдореИрдЧреНрдирд┐рдЯреНрдпреВрдб рдпреБрд╕ рдЬрд╝рд░рд╛рдм рдЫреВ рдкреНрд░реЛрдбрдХреНрдЯ рдСрдлрд╝ рд╕рд▓реАрдо рдирд┐рд╢рд╛рдирди рд╣реБрдиреНрдж--рд╕рд▓реАрдо рд╢реБрдорд╛рд░рди рд╣рд┐рдиреНрдЬрд╝ рд▓рд┐рд╕реНрдЯ рдЫреЗ рдпрд┐рд╡рд╛рди рдХрд░рдиреНрд╣ рдд рддреБрд╣реНрдпрд╝ рдЧрдЫреБрди рд╡рд╛рдкрд╕ --  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =","canonical_solution":"prodSigns :: [Int] -> Maybe Int\nprodSigns [] = Nothing\nprodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_129","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдгреВрдЗрдХ рдСрд░реНрдбрд░реНрдб рд▓рд┐рд╕реНрдЯ рдСрдлрд╝ рд╡реИрд▓реНрдпреВрдЬ рдУрди рдереЗ рд╕реЗрд▓реНрд╕ рдард╛рдЯ рдереЗ рдорд┐рдирд┐рдордо рдкрд╛рде рдЧреЗрдЯреНрд╕ рдереНрд░реВ.--рдпреЗ рдЫреА рдЧрд╛рд░рдиреНрдЯреА рдХрд╛рд░рдг рдХреА рдЬрд╡рд╛рдм рдЫреА рдпреВрдирд┐рдХ--lst_A[j] = lst_B[j]ред--рдпрд┐рде рдХрдирд┐ рдЬрд╝реНрди lst_A[i] < lst_B[i] рдд рдХреБрдирд┐ j (1 <= j < i) рдмрд╛рдкрде рдЫрд┐ --lst_B рдЦреЛрдд,рдмрд╛рдХрд┐ рд▓рдлрд╝реНрдЬрд╝реЗрдВ рдордВрдЬрд╝,рдЕрде рдордВрдЬрд╝ рдЫреВ рдЗрдиреНрдЯрд┐рдЬрд░ рдЗрдВрдбреЗрдХреНрд╕ рдореМрдЬреВрдж (1 <= i <= k)--рд╕реЕрд╣реН рдЫреБ рд▓рдХреНрд╕рд┐рдХреЛрдЧреНрд░рд╛рдлрд╝рд┐рдпреЙрд░реА рддреЛрд░ рдХрдоред--рдпрд┐рд▓ рдЕрд╕ рдПрд╡рдВ рдСрд░реНрдбрд░рд┐рдВрдЧ рд▓рд┐рд╕реНрдЯ рдмрдирд╛рд╡рдиреЗ рд╕реЗрд▓ рдкреЗрда рдпрдо A рдмреЗ B реЗрдорди рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ--рдпреБрд╕ рдкрде A (рд▓рдореНрдмрд╛рдИ k) рдЫреА рдпреЗ рдЫреА рдПрд╡рдВ рдорд╛рдирд╛ рд▓рдХреБрдЯ рдкрде B (рд▓рдореНрдмрд╛рдИ k) рдЦреЛрдд рдЕрдЧрд░ --рддреБрд╣ рд╣рдХреЛрд╡ рдиреЗ рдЧреНрд░рд┐рдбрд╕ рдирд┐рд╢ рдЧрд╕рд┐рде--рдЬрд╝рд░реВрд░реА рддреЛрд░ рдореБрдЦреНрддрд▓рд┐рдл) ред--рдХреГрдкрдпрд╛ рдиреЛрдЯ рдХрд░рд┐рд╡ рдЬрд╝рд┐ рдЕрдЦ рд▓рдиреНрдЧ k рдкрдереБрдХ рдорддрд▓рдм рдЫреБ рдХрд┐ рдпрд┐ рдЫреБ рдмрд┐рд▓рдХреБрд▓ k рд╕реЗрд▓ (рди рдХрд┐ --рдг рдг рдг рдг рдг рдг--реЗрдорди рд╣рдВрджрд┐ рдирд╡рд┐рд╢рди рд╣рд┐рдпрд┐рдВрджрд┐ рдирд╡рд┐рд╢рди рд╣рд┐рдпрд┐рдВрджрд┐ рдирд╡рд┐рд╢рди рд╣рд┐рдпрд┐рдВрджрд┐ рдирд╡рд┐рд╢рди рд╣рд┐рдпрд┐рдВрджрд┐ рдирд╡рд┐рд╢рди рд╣рд┐рдпрд┐рдВрджрд┐ рдирд╡рд┐рд╢рди рд╣рд┐рдпрд┐рдВрджрд┐ рдирд╡рд┐рд╢рди--рдХреБрдВрддреЗ рд╕реЗрд▓ рдкреЗрда ,рдмреЗ рдХреБрдВрддреЗ рд╕реНрдЯреЗрдк рдкреЗрда рддреБрд╣ рд╣рдХрд╝ рдХреБрди рддреЗ рдиреЗрдмрд░ рд╕реЗрд▓ рдкреЗрда рд░рдЯрди ,--рддреБрдореЛ рдХрд░реЛрдЦ рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░ рдкрде рдкрде k--рдЗ рдЫреА рдПрд╡рдВ рдПрд╡рдВ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдиреЗ рдЧреНрд░рд┐рдб рдкреЗрда--рд╣рд░ рд╕реЗрд▓ рдЫреА рдЖрд╕рд╛рди рд╡реЗрд▓реНрдпреВрдЬ ,рдЗрдВрдЯрд░рдЬрд░ рдЫреА рд░реЗрдВрдЬ рдордВрдЬрд╝ [1, N * N]--рдпреБрд╕ рдпреЗ рдЧреНрд░рд┐рдб рдЫреА рдЕрде рдордВрдЬрд╝ рдЫреА N рд░реВрд▓ рдмреЗ N рдХреЙрд▓рдо (N >= 2) рдмреЗ рдЫреА рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ k ,--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =","canonical_solution":"import Data.List (sort, sortBy)\nimport Data.Ord (comparing)\nimport Control.Monad (guard)\n\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k = head $ sort paths\n  where\n    n = length grid\n    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]\n    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n      where\n        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n\n    value (r, c) = grid !! r !! c\n    paths = do\n      start <- cells\n      findPaths k [start]\n    findPaths 1 path = return $ map value path\n    findPaths l path@(current:_) = do\n      next <- neighbors current\n      findPaths (l-1) (next : path)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_130","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЧреЛрдбреНрдиреБрдЦ n + 1 рдирдВрдмрд░ рдЯреНрд░рд╛рдЗрдмреЛрдирд╛рдЪреА рд╕реАрдХреНрд╡реЗрдВрд╕реБрдХ--рдЕрдЧрд░ рдЕрд╕ рдиреЗрдЧреЗрдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдирдВрдмрд░ рджреЗрд╡рди ,рддреЛрд▓ рдЧрд╕рдг рдЕрд╕ рд▓рд┐рд╕реНрдЯ рд▓рдлрд╝реНрдЬрд╝ --= 2 + 3 + 3 = 8 --рддреНрд░рд┐рдХреБрдгреНрдб (3) = рддреНрд░рд┐рдХреБрдгреНрдб (2) + рддреНрд░рд┐рдХреБрдгреНрдб (1) + рддреНрд░рд┐рдХреБрдгреНрдб (4)--tri(4) = 3 --рддреНрд░рд┐рдХреБрдгреНрдбрд┐рдХреБрдгреНрдб = рез + (реи \/ реи) = реи --рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), рдЕрдЧрд░ n рдЕрдкрд░ рдЫреВ.--рдЕрдЧрд░ n рдЫреВ рдЬрд╝реЗрдж рддреЗ ,рддрд╣ рдЫреА n = 1 + n \/ 2--tri(1) = 3 --рдЯреНрд░рд╛рдЗрдмреЛрдиреИрдХреА рд╕реАрдХреНрд╡реЗрдВрд╕ рдЫреБ рдпрд┐рдореНрди рд░рд┐рд╕реАрд╡рд░рдиреНрд╕ рд╕реЙрддрд┐ рдбрд┐рдлрд╛рдЗрди рд╕рдкрджрд╛рди:--рддрд╛рд╣рдо,рдпреЗрде рд▓реБрдХрди рдЫрд╛рди рдЬрд╝рд╛рдирд╛рди рдЯреНрд░рд┐рдмреЛрдиреИрдХреА рддрд░рддреАрдм рдЫреВ.--рдлрд┐рдмреЛрдиреИрдХреА рд╕реАрдХреНрд╡реЗрдВрд╕ рдЫреА рдПрд╡рдВ рд╣рд░ рдЖрдХрд┐рд╕ рдордВрдЬрд╝ рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдиреЗ--  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =","canonical_solution":"tri :: Int -> [Int]\ntri n = map tribonacci [0..n]\n  where\n    -- Define the recursive function to calculate the tribonacci value for a given n\n    tribonacci :: Int -> Int\n    tribonacci 0 = 1\n    tribonacci 1 = 3\n    tribonacci x\n      | even x    = 1 + x `div` 2\n      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_131","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдЕрдЧрд░ рд╕рд▓реАрдо рдбрд┐рдЬрд┐рдЯ рдЫреА рдЬреЛрдбрд╝реЗ ,рддрде рдЫреА рдпреЗ 0 рд╡рд╛рдкрд╕ рдХрд╛рд░рди-- рдЕрдЧрд░ рдЕрд╕ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдиреНрдЯрд┐рдЬрд░ n рджреАрдд ,рддрд╣ рдЫреА рдЕрд╕ рдкреНрд░реЛрдбрдХреНрдЯ рдХрд╛рд░рди реБрдиреНрдб рдбрд┐рдЬрд┐рдЯ--  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =","canonical_solution":"digits :: Int -> Int\ndigits n\n  | null oddDigits = 0\n  | otherwise      = product oddDigits\n  where\n    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_132","nl":"kas_Deva","pl":"hs","prompt":"--рдпрд┐рдд рдЫреА рдЖрдЦрдГ рдмреНрд░реИрдХреЗрдЯ рд╕рдмреНрд╕рдХреНрд╡реЗрдиреНрд╕реА рдордВрдЬрд╝ рдЫреА рдиреЗрд╕реНрдЯреЗрдб--рдлрдВрдХреНрд╢рди рдЫреВ рдЯреНрд░реВ рд░рд┐рдЯрд░реНрди рдХрд░рд╛рди рдЕрдЧрд░ рддреЗрдо рддреЗ рд╕рд┐рд░реНрдл рдЕрдЧрд░ рдмреНрд░реИрдХреЗрдЯрд╕ рдордВрдЬрд╝ рдЕрдЦ рд╡реИрд▓рд┐рдб рд╕рдмреНрд╕рдХрдХреНрд╡реЗрдВрд╕реА --рдЕрдЦ рдлрдВрдХреНрд╢рди рдмрдирд╛рд╡реБрди рдпреБрд╕ рдЗрдирдкреБрдЯ рдЫреВ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдпреБрд╕ рд╕рд┐рд░реНрдл рд╕реНрдХреНрд╡рд╛рдпрд░ рдмреНрд░реИрдХреЗрдЯ рдЫреВ--  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =","canonical_solution":"isNested :: String -> Bool\nisNested string = go string 0 False\n  where\n    go [] _ nested = nested\n    go (x:xs) depth nested\n      | x == '['  = go xs (depth + 1) (nested || depth >= 1)\n      | x == ']' && depth > 0 = go xs (depth - 1) nested\n      | otherwise = go xs depth nested","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_133","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдХреБрдВрддреЗ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣рд┐рдиреНрдж рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЫреВ рдЧреБрдбрдирд┐рдХрд┐рд╕ рдЗрдВрдЯрд╕ рддрд╛рдо рд░рд╛рдЙрдВрдб рдХрд░рд╛.--рддреБрд╣реНрдпрд╝ рдЧрдЫрд╝рд╛рди рджрд┐рддреЗрди рд╕реВрд░рддрди рдордВрдЬрд╝ рд╢реБрдж рд╢реБрдж рд╕реНрдХреНрд╡рд╛рдпрд░, --тЮбя╕ПрддреБрдорди рдЫреА рджреЗрд╡рди рдЖрдЦ рд▓рд┐рд╕реНрдЯ тЮбя╕П--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =","canonical_solution":"import Data.List (foldl')\nimport Prelude hiding (sum)\n\nsumSquares :: [Float] -> Int\nsumSquares lst = foldl' (\\acc x -> acc + ceiling x ^ 2) 0 lst","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_134","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдиреЛрдЯ: \"рд╡рд░реНрдб\" рдЫреВ рд╕реНрдкреЗрд╕ рд╕реЗрдд рдЕрд▓рдЧ рдХрд░рди рд╡рд╛рд▓реЗрди рдХрд░реИрдХреНрдЯрд░рди рд╣реБрдиреНрдж рдЧреНрд░реБрдк.--реЗрдХ рд▓рдлреНрдЬрд╝реБрдХ рд╣рд┐рд╕рд╕ ,рдмреЗ рдЧрд▓рдд рдмрдХрд┐рдпрд╛рдБ рддрд░рд┐рдХрд╛рд╕ рдордВрдЬрд╝-- рдЫреА рдПрд╡рдВ рд╡рд░реНрдгрдорд╛рд▓рд╛ рдордВрдЬрд╝ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдиреЗ--рдпреБрд╕ рдЖрдЦрд░реА рдХреИрд░реЗрдХреНрдЯрд░ рдЫреВ рд╕реБ рдЫреВ рдЯреНрд░реВ рд▓рд╡рди--  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =","canonical_solution":"checkIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt = \n    let trimmed = reverse . dropWhile (== ' ') $ reverse txt\n    in case trimmed of\n        [] -> False\n        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_135","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдбреБрдкреНрд▓рд┐рдХреЗрдЯ рд╡реИрд▓реНрдпреВрдЬ--рдЕрдЧрд░ рдЕрд╕ рдПрде рдПрд▓рд┐рдореЗрдВрдЯ рдиреЗ рдЕрд╕ рдиреЗ рдХрд╣рдБ рддреЗ ,рддрд┐рд▓ рдЫреА рдпреЗ рд░рд┐рдЯрд░реНрди рдХрд╛рд░рди -1.--рдЕрдЧрд░                --рдЕрдЦ рдлрд╝рдВрдХреНрд╢рди рдмрдирд╛рд╡ рдпрде рдордВрдЬрд╝ рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣рд┐рдиреНрдж рдореЛрд╕реНрдЯ рдмрд╛рд░реНрд╕ рдЗрдВрдбреЗрдХреНрд╕ рд░реЗрдЯрд░реНрди рдЫреВ--  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =","canonical_solution":"canArrange :: [Int] -> Int\ncanArrange arr = go arr (-1) 0\n  where\n    go [] maxIdx _ = maxIdx\n    go [_] maxIdx _ = maxIdx\n    go (x:y:xs) maxIdx idx\n      | x >= y    = go (y:xs) idx (idx + 1)\n      | otherwise = go (y:xs) maxIdx (idx + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_136","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЕрдЧрд░ рдиреЗрдЧреЗрдЯрд┐рд╡ рдпрд╛ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдЕрд╕рд┐рде ,рддреЗрдо рдЕрд╕ рдПрд╡рдВ рдирдерд┐рдВрдЧ рдкреЗрда рд╡рд╛рдкрд╕ рдХрд░рдиреЗ--рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░рд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝.--рдпреЗ рдЫреА рд╡рд░реАрдп рдмрдврд╝ рдиреЗрдЧреЗрдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ ,рдмреА рдЫреА рд╡рд░реАрдп рд▓рдХреБрдЯ--рдЕрдЦ рдлрдВрдХреНрд╢рди рдмрдирд╛рд╡реБрди рдпреБрд╕ рдЯрдкрд▓ (a, b) рд╡рд╛рдкрд╕ рдХрд╛рд░рди, рдпрд┐рдд 'a' рдЫреВ --  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =","canonical_solution":"largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst = (largestNegative, smallestPositive)\n  where\n    negatives = filter (< 0) lst\n    positives = filter (> 0) lst\n    largestNegative = if null negatives then Nothing else Just (maximum negatives)\n    smallestPositive = if null positives then Nothing else Just (minimum positives)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_138","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --реЗрдореБрдХ рдЖрдХрд▓рди рдХрд╛рд░рди рдХреА рдХреНрдпрд╛ рдЫреВ рдПрд╡рдВ рдирдВрдмрд░ n рд▓рд┐рдЦреЛ реЗрдореБрдХ рдорддрд▓рдм рдЫреВ рд╕рд▓реАрдо 4 рдкреЙрдЬрд┐рдЯрд┐рд╡ рдирдВрдмрд░--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =","canonical_solution":"isEqualToSumEven :: Int -> Bool\nisEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_139","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдпрд┐рдд рдПрди > 0 --brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! --рдпреБрд╕ рдмреНрд░рд╛рдЬрд╝реАрд▓рд┐рдпрди рдлреЕрдХреНрдЯреЛрд░рд┐рдпрд▓ рдЫреА рдпреЗ рдЫреА рдПрд╡рдВ рд╡рди--  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =","canonical_solution":"specialFactorial :: Int -> Int\nspecialFactorial n = product [factorial x | x <- [1..n]]\n  where\n    factorial 0 = 1\n    factorial k = k * factorial (k - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_140","nl":"kas_Deva","pl":"hs","prompt":"--рддреЗрдо рдкрд╛рдд рдЫреА рдПрд╡рдВ рд╕рд▓реАрдо рд╕реНрдкреЗрд╕реЗрд╕ рдмрджрд▓рд╡рдиреА - --рдЕрдЧрд░ рдЕрдЦ рд╕реНрдЯреНрд░рд┐рдВрдЧ 2 рдЦреЛрдд рдЬрд╝рдпрд╛рдж рдХреЙрдиреНрд╕рдХреНрдЯрд┐рд╡реЗ рд╕реНрдкреЗрд╕рд╕ рдЫреВ,--                       --  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =","canonical_solution":"fixSpaces :: String -> String\nfixSpaces text = concatMap replaceSpaces (groupSpaces text)\n  where\n    groupSpaces :: String -> [String]\n    groupSpaces [] = []\n    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest\n\n    replaceSpaces :: String -> String\n    replaceSpaces spaces@(x:_)\n      | x == ' ' && length spaces > 2 = \"-\"\n      | x == ' ' = replicate (length spaces) '_'\n      | otherwise = spaces","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_141","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --- рдпреБрд╕ рд╕рдмрд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА рдбреЙрдЯ рдкрд╛рдд рдпреЗ рд╣рдХрд╝ рдЕрд╕рд┐рде: ['txt', 'exe', 'dll']--рд▓реИрдЯрд┐рди рдЕрд▓реНрдлрд╛рдмреЗрдЯ ('a'-'z' and 'A'-Z').--- рд╕рдмрд╕реНрдЯреНрд░рд┐рдВрдЧ рдпреБрд╕ рдбреЙрдЯ рдмрд░реЛрд╣ рдЫреА рд╕реБ рдЫрд╛рди рд╣рдХреЛ рдЖрд╕рд┐рде рдЦрд▓реА ,рдмреЗ рдпреЗ рдЫреА рд╢реБрд░реВ рдЧрд╛рд╕рди рд▓рдлрд╝реНрдЬ рд╕реЗрде--- рдлрд╝рд╛рдЗрд▓реБрдХ рдирд╛рд╡ рдЫреБ рдЕрдЦ рдбреЙрдЯ '.'ред--- рдлрд╝рд╛рдЗрд▓ рдирд╛рд╡рд╕ рдордВрдЬрд╝ рдЫреБрди рдЬрд╝реНрдпрд╛рдж рддреНрд░реЗрди рдбрд┐рдЬрд┐рдЯреНрди (0 - 9) рд╣реНрдиреНрдЬрд╝ рдЧрдЫрд╛рдиред--рдпреЗ рдЫреВ рдПрдПрдо рд╕реЗрдд рдорд┐рд▓рд╛рди:--рдЕрдЦ рдлрд╝рд╛рдЗрд▓ рдирд╛рд╡ рдЫреБ рд╡реИрд▓рд┐рдб рдорд╛рдирд╛рди рдЕрдЧрд░ рддреЖ рддрд┐рдо рддрдорд╛рдо рд╢рд░реВрдд рдкреВрд░рдГ рдЖрд╕рд┐ред--рдЕрдЧрд░ рдлрд╝рд╛рдЗрд▓ рд╣реБрдиреНрдж рдирд╛рд╡ рд╕рд╣реА рдЖрд╕рд┐, рдд 'рд╣рд╛рдБ', рдЕрдЧрд░ рдиреЗ рд╕рд╣реА рдЖрд╕рд┐, рдд 'рдирд╣'ред--реЗрдХ рдлрд╝рдВрдХреНрд╢рди рдмрдирд╛рд╡ рдпрде рдордВрдЬрд╝ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЫреА рдПрд╡рдВ рдлрд╛рдЗрд▓ рдирд╛рд╡реБрдХ ,рддреЗ рд╕реБ рдЫреА рджреЗрд╡рди --  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =","canonical_solution":"import Data.Char (isDigit, isLetter)\n\nfileNameCheck :: String -> String\nfileNameCheck file_name \n  | countDots \/= 1 = \"No\"\n  | length digits > 3 = \"No\"\n  | null beforeDot || not (isLetter (head beforeDot)) = \"No\"\n  | afterDot `notElem` validExtensions = \"No\"\n  | otherwise = \"Yes\"\n  where \n    (beforeDot, afterDot) = span (\/= '.') file_name\n    countDots = length $ filter (== '.') file_name\n    digits = filter isDigit file_name\n    validExtensions = [\"txt\", \"exe\", \"dll\"]\n    afterDot = if null dotAndAfter then \"\" else tail dotAndAfter\n    dotAndAfter = dropWhile (\/= '.') file_name","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"\/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_142","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдпреБрд╕ рдпреЗ рдлрдВрдХреНрд╢рди рдЫреВ рд╕реБ рдЫреА рдПрд╡рдВ рдмрджрд▓рдиреА рдПрдВрдЯреНрд░реАрдЬ рдордВрдЬрд╝ рдпрдорди рд╣рд┐рдиреНрдж рдЗрдВрдбреЗрдХреНрд╕ рдЫрд╛рди рдЬрд╝рдпрд╛рдж рдЖрд╕рд╛рди 3 рдпрд╛ 4--рдпреБрд╕ рдЗрдиреНрдЯрд┐рдЬрд░ рдЫреА рд╕реБ рд╣рдХрд╝ рдЕрд╕рд┐рде рд╡рд╛рд░рд┐рдпрд╛ рддреЗрд░ рдкреЗрда ,рдЕрдЧрд░ рд╕реБ рдЗрдиреНрдбрд┐рд╕реЗ рдЕрд╕ рд╡рд╛рд░рд┐рдпрд╛ рддреЗрд░ рдкреЗрда ,рдлреЙрд░рдЧреЗрдЯ рдЫрд╛рди рдЖрд╕рд╛рди--рдпреЗ рдлрдВрдХреНрд╢рди рдЫреА рдЗрдиреНрдЯрд┐рдЬрд░рд╕ рд╣реБрдиреНрдж рд▓рд┐рд╕реНрдЯ рдХрд╛рд░рди ,рд▓рдХрд┐рди рдЕрдЧрд░ рдпреЗ рдЗрдиреНрдЯрд┐рдЬрд░ --\" --  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =","canonical_solution":"sumSquares :: [Int] -> Int\nsumSquares lst = sum $ zipWith transform [0..] lst\n  where\n    transform idx x\n      | idx `mod` 3 == 0 = x * x\n      | idx `mod` 4 == 0 = x * x * x\n      | otherwise        = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_143","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ 1: --рдпреБрд╕ рдСрд░реНрдбрд░ рдЫреА рд▓рдлрд╝рдЬрд╝ рд╣реИрдЬрд╝ рдЕрде рдордВрдЬрд╝ рдирдИ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдордВрдЬрд╝ рдпреЗ рдЧрд╕рдг рдУрд░рд┐рдЬрд┐рдирд▓ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд╛рда--рдпреЗрдорди рд╣рд┐рдВрдЬ рд▓реЗрдВрде рдЫреВ рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░,--рдд рддреБрд╣реНрдпрд╝ рдЧрдЫрд╝рд╛рди рдЕрдЦ рд╕реНрдЯреНрд░рд┐рдВрдЧ рд╡рд╛рдкрд╕ рдпрде рдордВрдЬрд╝ рд▓рдлреНрдЬрд╝ рдЫрд┐ рдпрд┐рдо рдЧреЛрдбрдирд┐рдХрд┐рд╕ рд╡рд╛рдХреНрдпрд╕ рдордВрдЬрд╝ рдЫрд┐, --рдпреБрд╕ рдпреЗ рд╕реЗрдиреНрдЯреЗрдиреНрд╕ рдЫреА рдЕрде рдордВрдЬрд╝ рдЫреА рдХреЗрд╣ рд▓рдлрд╝рдЬрд╝ рдпреБрд╕ рд╕реНрдкреЗрд╕ рд╕реЗрде рдЫреА рдЕрд▓рдЧ рдХрд╛рд░рди ,--рдЕрд╕ рддреБрд╣реНрдпрд╝ рдЕрдХрд┐ рд╡рд╛рдХреНрдпрд╕ рд░рд┐рдкреНрд░реЗрдЬрд╝реНрдирдЯ рдХрд░рд╛рди,--  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =","canonical_solution":"import Data.List (intercalate)\n\nwordsInSentence :: String -> String\nwordsInSentence sentence = intercalate \" \" $ filter (isPrime . length) (words sentence)\n\nisPrime :: Int -> Bool\nisPrime n | n < 2     = False\n          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_144","nl":"kas_Deva","pl":"hs","prompt":"--рддреБрдо рд╣рдХреЛ рдЖрд╕реБрдордкреНрдЯ рдХрд░рд┐рде рдХреА x, рддреЗ n рдЫреВ рд╡реИрд▓рд┐рдб рдлреНрд░реИрдХреНрд╢рди, рддреЗ рдЫрд╛рди рдЖрд╕рд╛рди рдЬреАрд░реЛ рдбреЗрдорд┐рдиреЛрдиреЗрдЯрд░ рдкреЗрда--<numerator>\/<denominator> рдпреЗрде рдордВрдЬрд╝ рдиреБрдореЗрд░реЗрдЯрд░ рддреЗ рдбреЗрдиреЛрдорд┐рдирдЯрд░ рджреБрдирд╡рдИ рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░ рдирдВрдмрд░ рдЖрд╕рд╛рди.--рдЕрдЧрд░ рдЕрд╕ рд╡реБрдЫреЛ x рддреЗ n ,рдпреЗ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рд░рд┐рдкреНрд░реЗрдЬреЗрдВрдЯреЗрд╢рди рдлреНрд░реИрдХреНрд╢рдирдХ ,рдмреЗ рдЫреА рдЕрде рдлреЙрд░реНрдореЗрдЯ ,--x * n. рдлрдВрдХреНрд╢рди рдЫреВ рдЯреНрд░реВ рд░рд┐рдЯрд░реНрди рдХрд░рд╛ рдЕрдЧрд░ x * n рдЫреВ рдЗрдВрддреЗрдЬрд░ рддреЗ рдлреЙрд▓реНрдЯ --рдЕрд╕ рддреБрд╣рд░реЗ рдХрд╛рдо рдЫреА рдЗрдореНрдкреНрд▓реЙрдИ рдХрд░реЛрдВ рдлрдВрдХреНрд╢рди рдпреБрд╕ рдПрдХреНрд╕рдкреНрд░реЗрд╢рди рдЖрд╕рд╛рди рдмрдирд╛рдУ--  >>> simplify \"1\/5\" \"5\/1\"\n--  True\n--  >>> simplify \"1\/6\" \"2\/1\"\n--  False\n--  >>> simplify \"7\/10\" \"10\/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =","canonical_solution":"import Data.Ratio (denominator, numerator, (%))\n\nsimplify :: String -> String -> Bool\nsimplify x n =\n  let (xNum, xDen) = toFraction x\n      (nNum, nDen) = toFraction n\n      result = (xNum * nNum) % (xDen * nDen)\n  in denominator result == 1\n\ntoFraction :: String -> (Integer, Integer)\ntoFraction s =\n  let (numStr, _:denStr) = break (=='\/') s\n  in (read numStr, read denStr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/6\" \"2\/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/1\" \"3\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/10\" \"10\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/10\" \"50\/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/2\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11\/6\" \"6\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/3\" \"5\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/2\" \"3\/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"8\/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"1\/5\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_145","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --реЗрдореЛ рдХреБрд░ реЗрдорди рдЕрд░реНрдбрд░ рдПрдордПрдЪ рдЗрдВрдбреЗрдХреНрд╕ рдкреЗрда рдУрд░рд┐рдЬрд┐рдирд▓ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝--рдиреЛрдЯ: рдЕрдЧрд░ рдХрд╣рдБ рддреЗ рдЖрдЗрдЯрдо рдЖрд╕рд╛рди рддреЗрдорди рд╣рд┐рдиреНрдж рдбрд┐рдЬрд┐рдЯ рд╣реБрдиреНрдж рдмрд░рд╛рдмрд░ рд╕реЛрдВрде ,--рдгрдгрдг рдгрдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг рдг--рдЕрдЦ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ рдпреБрд╕ рдЗрдВрдЯреЗрдЬрд░рд╕ рджрд╛рддреЗ рдЕрд╕--  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =","canonical_solution":"import Data.List (sortBy)\nimport Data.Function (on)\n\norderByPoints :: [Int] -> [Int]\norderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums\n  where\n    sumOfDigits :: Int -> Int\n    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)\n    \n    indexedNums :: [(Int, Int)]\n    indexedNums = zip (map sumOfDigits nums) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_146","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдпреБрд╕ рдЧреЛрдбреНрдиреБрдЗрдХ рддреЗ рдЖрдЦрд░реА рдбрд┐рдЬрд┐рдЯ рдЫреА рдирдВрдмрд░ рдЫреА реБрдВрджрд░ (1, 3, 5, 7, 9)--рдпреБрд╕ рдирдВрдмрд░ рдЫреА рдПрд▓рд┐рдореЗрдВрдЯреНрд╕ рд╣реБрдиреНрдж рд╕реБ рдЫреА рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж 10 рдмреЗ рджреБрдирд╡рдИ --реЗрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ рдпреБрд╕ рдирдВрдмрд░ рдЫреА рдЗрдирдкреБрдЯ рддреЗ рд░рд┐рдЯрд░реНрди реЗрд╡рд╛--  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =","canonical_solution":"specialfilter :: [Int] -> Int\nspecialfilter nums = length $ filter isSpecial nums\n  where\n    isSpecial n = n > 10 && isOddFirstAndLast (abs n)\n\n    isOddFirstAndLast :: Int -> Bool\n    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit\n      where\n        xStr = show x\n        firstDigit = head xStr\n        lastDigit = last xStr\n\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_147","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓:--a[i] + a[j] + a[k] рдЫреВ рдорд▓реНрдЯреАрдкреНрд▓ рдСрдлрд╝ 3--a рд╣рд┐рдЪ рдЯреНрд░рд┐рдкрд▓ рдирдВрдмрд░ рд╡рд╛рдкрд╕ рдХрд░реЛ (a[i], a[j], a[k]) рдпрд┐рдд i < j < k, --рд╣рд░ i (1 тЙд i тЙд n) рдЦрд╛рддрд░ ,рдпреБрд╕ рд╡реИрд▓реНрдпреВ рдЫреА a[i] = i * i - i + 1--                     --  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =","canonical_solution":"getMaxTriples :: Int -> Int\ngetMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]\n  where\n    a = [i * i - i + 1 | i <- [1..n]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_149","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рддреБрдо рд╣рдХреЛ рдЖрд╕реБрдордкреНрдЯреАрд╡реЗ рдХрд░рд┐рде рдХреА рд╕рд▓реАрдо рд▓рдлрд╝рдЬрд╝ рдЫреА рдмрд░рд╛рдмрд░ рд▓реЛрдВрдЧ--рдлрдВрдХреНрд╢рди рдЫреВ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рдЕрд╕рд╛,рдпреЗрдо рд╕реЙрд░реНрдЯ рдХрд░рдиреЗ рдЦрд╛рддрд┐рд░ рдСрд░реНрдбрд░ рдЫреВ рдЕрд╕рд╛.--рдЕрдЧрд░ рджреЛрди рд▓рдлрд╝реНрдЬрд╝рди рд╣рд┐рдиреНрдЬрд╝ рд▓реНрдиреНрдЧрдпрд┐ рдЕрдЦ рдЕрдХрд┐рд╕ рд╕реАрдд рдЫреЗ, рддреНрд░рд╛рд╡рд┐рд╡ рдЕрд▓реНрдлрд╛рдмреЗрдЯрд┐рдХ рддреЛрд░ред--рдпрд┐рдорди рд░реВрд▓рди рд╣реНрдиреНрдЬрд╝рд┐ рд╕реЙрд░реНрдЯрд┐рдлрд╝рд╛рдпрд░ рдЫреБ рдпрд┐рд╡рд╛рди рдХрд░рдиреНрд╣ред--рдпреБрд╕ рдЖрд░реНрдбрд░ рдЫреА рд▓рд┐рд╕реНрдЯ рд╣реБрдиреНрдж рдЗ рдЧрд╕рдг рдЕрд╕реЗрдВрдмрд▓реА рдордВрдЬрд╝ рд╣рд░ рд▓рдлрд╝рдЬрд╝ рд╣реБрдиреНрдж рд▓реЗрдВрде рд╣рд┐рд╕рд╛рдм ,рдмреЗ рддреБрд╣ --рдпреЗ рд╣рдХрд╝ рдбреБрдкреНрд▓рд┐рдХреЗрдЯ рддреЗ рдЕрд╕рд┐рде--рдпреБрд╕ рд▓рд┐рд╕реНрдЯ рдЫреА рд╕реБ рдЫреА рд╣рдореЗрд╢рд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рд╣реБрдиреНрдж рд▓рд┐рд╕реНрдЯ рдмреЗ рдЫрд╛рди рдЬрд╝рдпрд╛рдж рдирдВрдмрд░ рдЖрд╕рд╛рди--                 --рдЫреБрдВ рдЫреБрдВ рд▓рдБрдкреБрдЗ рдЫреБрдВ рд▓рдБрдкреБрдЗ рдЫреБрдВ рд▓рдБрдкреБрдЗ рдЫреБрдВ рд▓рдБрдкреБрдЗ рдЫреБрдВ рд▓рдБрдкреБрдЗ рдЫреБрдВ--реЗрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ рдпреБрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рдЕрд╕ рдкреИрд░рд╛рдореАрдЯрд░ рдХреА рддреИрд░ рдкрдЗрда рдПрдХреНрд╕реЗрдкреНрдЯ рдХрд░рд╛,--  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =","canonical_solution":"sortedListSum :: [String] -> [String]\nsortedListSum lst = sortBy compareStrings (filter evenLength lst)\n  where\n    evenLength s = even (length s)\n    compareStrings s1 s2\n      | length s1 == length s2 = compare s1 s2\n      | otherwise = compare (length s1) (length s2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_150","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдпреЗ рдЫреА рдПрд╡рдВ рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдиреЗ--рдпреБрд╕ рдЖрд╕рд╛рди рдкреНрд░реЛрдЧреНрд░рд╛рдо рдЫреА рд╕реБ рдЫреА рджреЗрд╡рди рд╡реИрд▓реНрдпреВ x рдпрд┐рд▓ n рдЫреА --  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =","canonical_solution":"xOrY :: Int -> Int -> Int -> Int\nxOrY n x y = if isPrime n then x else y\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_151","nl":"kas_Deva","pl":"hs","prompt":"--рдпреБрд╕ рдирдВрдмрд░ рдЫреА рд╕реБ рдЫреА рдПрд╡рдВ рд┐рдирдЧрд░ рдХрд░рдиреЗ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =","canonical_solution":"doubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst = \n    sum [x * x | x <- map round lst, x > 0, odd x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_152","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЕрдЧрд░ рдпреЗ 0 рдУрд╕ ,рддрдореБрдХ рд╡реИрд▓реНрдпреВ рдЕрд╕ рдЕрдмреНрд╕реЛрд▓реБрдЯреЗ рдбрд┐рдлрд░реЗрдВрд╕ рдЧреЗрдЯреНрд╕ рддреЗ рд╕реНрдХреЛрд░ рдордВрдЬрд╝--рдЕрдЧрд░ рддреЗрдо рд╕рд╣реА рд╕реЗрдд рдЕрдВрджрд╛рдЬрд╝ рд▓рдЧрд╛рд╡ рддреЗ,--рддреЛрдп рдЫреА рджреЗрд╡рди рдЬрд╝реЗ рд▓рд┐рд╕реНрдЯ рд╕реНрдХреЛрд░ рдд рдмреИ рдЧреЗрд╕реНрдЯреНрд╕ рдмрд░рд╛рдмрд░ рд▓реЗрдВрде рд╕рд╛рде , рдпрде рдордВрдЬрд╝ рд╣рд░ рдЗрдВрдбреЗрдХреНрд╕ рдЫреА рд╣рд╡рди рдореИрдЪ--рддреЛрд░реЗ рдХрд╛рдо рдЫреЗ рдИ рдкрддрд╛ рд▓рдЧрд╛рдирд╛ рдХрд┐ рдЕрдЧрд░ рдЕрдХрд┐рд╕ рд╢рдЦреНрд╕рд╕ рд╕рд╣реА рдЕрдВрджрд╛рдЬрд╝рд╕ рдордВрдЬрд╝ рдореБрдХрд╝рд╛рдмрд▓рд╛ рдЫреВ рдЕрдореГрдд рдХрд░рдиреЗ.--рдпреЗ рдЫреА рдЬрд╝рд░реВрд░реА рдХреА рдЕрд╕ рд╣рдХреЛ рдЕрде рд╡реБрдЫрд┐рде рдмреЗ рддреБрд▓рд╕реАрде--рдпреБрд╕ рдпреЗ рдЗрд╡реЗрдВрдЯ рдЫреА рдпреЗ рдЫреА рдПрд╡рдВ рд╡реВрдЪрди--рд╣рдо рд╕реЛрдВрдЪреВрдВ рдЫреА рдХреА рдЕрд╕ рд╕рдВрдЬрди рдЫреА рдпрд┐рд▓ рдЕрд╕ рдирддреАрдЬ рдЫреА рд╡рд░реАрдп рдЬрд╝рдпрд╛рдж рд╡реЗрди рддреЗ--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =","canonical_solution":"compare :: [Int] -> [Int] -> [Int]\ncompare game guess = zipWith (\\g s -> abs (g - s)) game guess","tests":"\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_153","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --(рдЗрдорд┐рд╕рдВрдж рддрд╛рдХрдд рдЫреВ -1).--return 'Slices.SErviNGSliCes' as 'SErviNGSliCes' is the strongest extension --рдПрдХреНрд╕рдЯреЗрдВрд╢рди: ['рд╕реЗрд░реНрд╡рд┐рдВрдЧреНрд╕','рдЪреАрдЬрд╝', 'рд╕реНрдЯреВрдлрд╝реЗрдб'] рддреЛ рдЖрдк --рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░ ,рдЕрдЧрд░ рдЕрд╕ \"рд╕реНрд▓рд╛рдЗрд╕ \" рдХреНрд▓рд╛рд╕реЗрд╕ рддреЗ рд▓рд┐рд╕реНрдЯ --рдпреБрд╕ рдпреЗ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЧреЛрджрдиреАрдЪ рдЖрд╡ рдЗ рдЪреБрди рдЪреБрди--рдЕрдЧрд░ рдЕрдпреЗ рджреВрдБ рдпрд╛ рдЬрд╝рдпрд╛рдж рдПрдХреНрд╕рдЯреЗрдВрд╢рди рдЕрде рддрд╛рдХрд╝рдд рд╕реЗрдд,рдЕрде рдЫреВ рдирдЬрд╝рд░реБрд░рдд.--format: ClassName.StrongestExtensionName. --рддреБрд╣реНрдпрд╝ рдЧрдЫрд╝рд╛рди рд╕рд╛рд░рд┐рд╡рдп рдЦреБрдд рдЬрд╝реНрдпрд╛рджрд╣ рддрд╡рд╛рдиреЙрдпреА рдд рддреБрд╣реНрдпрд╝ рдЧрдЫрд╝рд╛рди рдпрд┐рдорд╕ рдордВрдЬрд╝ рдЕрдЦ рд╕реНрдЯреНрд░рд┐рдВрдЧ рд╡рд╛рдкрд╕ ред--рдПрдХреНрд╕рдЯреЗрдВрд╢рди рдирд╛рд╡ рдордВрдЬрд╝, рддрд╛рдХрдд рдЫреА рдПрд╡рдВ рдлреНрд░реИрдХреНрд╢рди CAP - SM рд╕реЗрде--рдПрдХреНрд╕рдЯреЗрдВрд╢рди рдирд╛рд╡ рдордВрдЬрд╝ рд▓рдмрд░реЗрди,рддреЗ SM рд▓рдХреБрдЯ рд▓рдмрд░реЗрди рд╣реБрдиреНрдж рдирдВрдмрд░ --рдпреБрд╕ рддрд╛рдХрдд рдЫреА рдПрдХреНрд╕рдЯреЗрдВрд╢рди рдЫреА рдИрда рдкрд╛рда:рдпреЗ рдЫреА CAP рдпреБрд╕ рдирдВрдмрд░ рдЫреА рдЕрдкрд░рдХреЗрд╕ --рдПрдХреНрд╕рдЯреЗрдВрд╢рди рдЫреА рдПрд╡рдВ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдиреЗ рддрд╛рдХрд┐ рдПрдореН рдХрд╛рд░рди рд▓реЛрдб рдПрдХреНрд╕реНрдЯреНрд░рд╛ рдХреНрд▓рд╛рд╕--рдЕрд╕ рддреБрд╣реНрдпрд╝ рджреАрд╡рд╛рди рд╡рд░реНрдЧрдЪрд┐ рдирд╛рд╡ (a string) рдд рдПрдХреНрд╕рдЯреЗрдВрд╢рдирди рд╣реНрдиреНрдЬрд╝ рд╕реВрд░рддред--  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =","canonical_solution":"strongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions = class_name ++ \".\" ++ strongestExt\n  where\n    calculateStrength :: String -> Int\n    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)\n    \n    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)\n    \n    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)\n    maxStrength ext1 ext2\n      | snd ext1 > snd ext2 = ext1\n      | otherwise           = ext2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_154","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ рддреБрд╣реАрдо рджреБрдпреНрдпрдо рд▓рдлреНрдЬрд╝ рдпрд╛ рдХреБрдВрддреЗ рддреЗрдорд╕реБрдиреНрдж рд░реЛрдЯреЗрд╢рди рдЫреВ рдЧреБрдбрдирд┐рдХрд┐рд╕ рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рд╕рдмрд╕реНрдЯреНрд░рд┐рдВрдЧ,рддреЗрдо рдЫреВ рдЯреНрд░реВ рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рд╕рд╣реА рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕рд╕рд╕ рдордВрдЬрд╝ рдЧрд▓рдд рд▓рдлреНрдЬрд╝рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕рд╕--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =","canonical_solution":"cycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b = any (`isInfixOf` a) rotations\n  where\n    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_155","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░. рдЗрдВрдЯрд░рдЬреЗрд░.--  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =","canonical_solution":"evenOddCount :: Int -> (Int, Int)\nevenOddCount num = (length evens, length odds)\n  where\n    digits = map (read . (:[])) . show . abs $ num\n    evens = filter even digits\n    odds  = filter odd digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_156","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рд░рд┐рд╕реНрдЯреНрд░рд┐рдХреНрдЯреНрд╕: 1 <= рдиреБрдо <= 1000 --рдд рддреБрдорд┐ рд▓реЛрд░рд┐рдХрд▓рд┐ рд╡рд╛рдкрд╕ рдХрд░рд┐ред-- рдкреЙрдЬрд┐рдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░,  рд░реЛрдорди рдиреБрдорд╛рд░рд┐рдХрд╛рд▓ рд╕рдорд╛рди рд╕реНрдЯреНрд░рд┐рдВрдЧ,--  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =","canonical_solution":"intToMiniRoman :: Int -> String\nintToMiniRoman number = concatMap (replicateSymbol number) romanNumerals\n  where\n    romanNumerals = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n                     (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n                     (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    \n    replicateSymbol :: Int -> (Int, String) -> String\n    replicateSymbol n (value, symbol)\n      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)\n      | otherwise = \"\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_157","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --90 рдбрд┐рдЧреНрд░реА. --рдпреБрд╕ рд░реЗрдХреНрдЯреИрдВрдЧрд▓ рдЯреНрд░рд╛рдИрдПрдВрдЧрд▓ рдЫреВ рд╕реБ рдЫреВ рдЯреНрд░рд╛рдИрдПрдВрдЧрд▓ рдпрд╛рде рдордВрдЬрд╝ рдЖрдБрдЦ рдПрдВрдЧрд▓ рдЫреВ рд░реЗрдХреНрдЯреИрдВрдЧрд▓ рдпрд╛ --рдЕрдЧрд░ рдЕрд╕ рдиреЗ рдЕрд╕ рд╕рд╣реА ,рддрд┐рд▓ рдЕрд╕ рдЧрд▓рдд--рдЕрдЧрд░ рддреНрд░рд┐рдХреЛрдгрдХ рддреНрд░реИрдорд╛рд╕рд┐рдХ рд▓рдореНрдм рдЫреВ рд╕рд╣реА,рддреЗрд▓ рдЫреВ рддреЗрдо рд▓рдВрдм рдЫреВ рд╕рд╣реА.--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =","canonical_solution":"rightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c = \n    let [x, y, z] = sort [a, b, c]\n    in x^2 + y^2 == z^2\n    where sort = Data.List.sort","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_158","nl":"kas_Deva","pl":"hs","prompt":"--рд▓рдлреНрдЬрд╝-рдП-рдЬрд╝рдмрд╛рдиреА рдордВрдЬрд╝,рдЕрде рд▓рдлреНрдЬрд╝рд╕ рдХреБрди рд╡рд╛рдкрд╕ рдХрд░рде рдпрд┐рдо рд▓рдлреНрдЬрд╝-рдП-рдЬрд╝рдмрд╛рдиреА рдордВрдЬрд╝ рдЧреБрдбрдирд┐рдХрд┐рд╕ рддрд░рдлрд╝рд╕ рдЖрд╕рди.--рдЕрдЧрд░ рдорд▓реНрдЯреАрдкреНрд▓ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдордВрдЬрд╝ рдЕрд╕реЗ рдореЗрдХрдЬрд╝рд┐рдо рдирдВрдмрд░ рдпреВрдирд┐рдХ --рдпреБрд╕ рд▓рд┐рд╕реНрдЯ рдЫреА рдЕрде рдордВрдЬрд╝ рдЫреА рдПрд╡рдВ рдЕрд▓рдЧ рд▓рдлрд╝рдЬрд╝--рдЕрдЦ рдлрдВрдХреНрд╢рди рд▓рд┐рдЦреЛ рдпреБрд╕ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рд╣рд┐рдВрдЬ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЫреВ рдПрд╡рд╛.--  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =","canonical_solution":"import Data.List (nub, sort)\n\nfindMax :: [String] -> String\nfindMax words = \n    head . sort . map snd . filter (\\(n, _) -> n == maxUnique) $ wordUniquePairs\n  where\n    wordUniquePairs = [(length . nub $ word, word) | word <- words]\n    maxUnique = maximum $ map fst wordUniquePairs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_159","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓: --рдЕрдЧрд░ рдЖрд╕ рд╡рд░рд┐рдпреЗ рдХрдо рдХрд╛рд░реЛрдЯ ,рддреЛ рддреБрд╣реНрд╣реБрдХ рд╣рдХрд╝ рддреБрд▓ рдХрд╛рд░реЛрдЯ рдЦрд╛рде ,рд▓рдХрд┐рди рддреБрд╣реНрд╣реБрдХ рд╣рдХрд╝ рд╡реЗрди рд╡реБрдирдЦ--рдпреБрд╕ рдирдВрдмрд░ рдЫреА рдЧрд╛рдЬрд░ рдпреБрд╕ рд░реЛрдЬрд╝рди рдЫреА рдореАрд▓реНрд╕ рдкрд╛рдд ] --рддреБрд╣реНрдпрд╝ рдЧрд╡ рдпрд┐ рд▓рд┐рд╕реНрдЯ рд╡рд╛рдкрд╕ [ рдХреБрд▓ рдЪреЙрд░ рдЦрд╛рдореНрдд рдХрд╛рд░реНрдЯреНрд╕ рдпрд┐рдо рддреБрд╣реНрдпрд╝ рдЦреЙрд░ рдЦрд╛рдореНрдд рдХрд░рдирдГ рдЖрдореБрдд рдЫрд┐, ]--рд▓реЗрдХрд┐рди рдЕрдм рддреБрд╣ рдкрдиреБрди рджрд┐рдирдЪ рдЦрд╛рд╡рдирд┐ рдЦрд╛рддреАрд░ рдЬрд╝реНрдпрд╛рдж рдХрд╛рд░реЛрдЯ рдЦрд╛ред--тЮбя╕ПрддреБрдо рднреВрдЦреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдЧрд╛рдЬрд░ рдЦрд╛ рдЪреБрдХреЗ рд╣реЛ, тЮбя╕ПрддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рдЦрд░рдЧреЛрд╢ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рд╣реЛ, рддреБрдо рдХреБрдЫ рдореЛрдЯреЗ рд╣реЛ,--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =","canonical_solution":"eat :: Int -> Int -> Int -> [Int]\neat number need remaining\n  | remaining >= need = [number + need, remaining - need]\n  | otherwise = [number + remaining, 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_160","nl":"kas_Deva","pl":"hs","prompt":"--рдСрдкрд░реЗрдЯрд░ рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЫреВ рдХрдо рд╕реЗ рдХрдо рдЕрдХрд┐рд╕ рдСрдкрд░реЗрдЯрд░рд╕ рдЕрд╕рд╛,рддреЗ рдСрдкрд░реЗрдиреНрдб рд▓рд┐рд╕реНрдЯ рдордВрдЬрд╝ рдЫреВ рдХрдо рд╕реЗ рдХрдо рджреВрдБ рдСрдкрд░реЗрдиреНрдбрд╕ рдЕрд╕рд╛.--рдУрдкрд░рдВрдб рдЫреВ рдЖрдБрдЦ рд▓рд┐рд╕реНрдЯ рдиреЙрди-рдиреЗрдЧреЗрдЯрд┐рд╡ рдЗрдВрдЯреЗрдЬрд░рд╕ рд╣рд┐рдВрдЬ.--рдпреБрд╕ рд▓реЛрдВрдЧ рдЫреА рдСрдкрд░реЗрдЯрд░ рд▓рд┐рд╕реНрдЯ рд╕реБ рдЫреА рдмрд░рд╛рдмрд░ рд▓реЛрдВрдЧ рдСрдлрд╝ рдУрдкреЗрд░рд╛рдВрдбреНрд╕ рд▓рд┐рд╕реНрдЯ -рез--рдиреЛрдЯрдГ --=> рд░рд┐рдЬрд▓реНрдЯ = 9 --рдирддреАрдЬ = 2 + 3 * 4 - 5 --list = [2, 3, 4, 5] --рдСрдкрд░реЗрдЯрд░['+', '*', '-'] --рдорд┐рд╕рд╛рд▓: --рдПрдХреНрд╕рдкреЛрдиреЗрдВрдЯрд┐рдЕрд╢рди (**)--рдлреНрд▓реЛрд░ рдбрд┐рд╡реАрдЬрд╝рди ( \/\/) --рдорд▓реНрдЯреАрдкреНрд▓рд┐рдХреЗрд╢рди (*) --рд╕рдмреНрдЯреНрд░реИрдХреНрд╢рди ( - ) --рдЕрджреНрджрд┐рддреАрдУрдВ (+) --рдпреБрд╕ рдмреБрдирд┐рдпрд╛рджреА рдЕрд▓рдЬреЗрдмреНрд░рд╛ рдСрдкрд░реЗрд╢рди рдЫреА:--рдПрдХреНрд╕рдкреНрд░реЗрд╢рди рддреЗ реЗрд╡рд▓реНрдпреВрдПрд╢рди рдСрдлрд╝ рдПрдХреНрд╕рдкреНрд░реЗрд╢рди--рдпреБрд╕ рджреБрдИрдо рд▓рд┐рд╕реНрдЯ рдЫреА рд╕реБ рдЫреА рдЗрдВрдЯреЗрдЬрд░рд╕ рд╣реБрдиреНрдж рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд╛рд░рди --реЗрдореЛ рдХреБрд░ рджреБрдирд╡рдИ рд▓рд┐рд╕реНрдЯ рдСрдкрд░реЗрдЯрд░ ,рдмреЗ рдСрдкрд░реЗрдиреНрдб ,рдпреБрд╕ рдЧреЛрдбреНрдиреБрдЗрдХ рд▓рд┐рд╕реНрдЯ рдЫреА рдмреЗрд╕рд┐рдХ рдЕрд▓рдЬреЗрдмреНрд░рд╛ рдСрдкрд░реЗрд╢рди ,рдмреЗ реЗрдорди рд╣реБрдиреНрджdoAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =","canonical_solution":"doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand = evaluate operand operator\n  where\n    evaluate [x] [] = x\n    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops\n      where\n        result = applyOperation op x y\n\n    applyOperation \"+\" a b = a + b\n    applyOperation \"-\" a b = a - b\n    applyOperation \"*\" a b = a * b\n    applyOperation \"\/\/\" a b = a `div` b\n    applyOperation \"**\" a b = a ^ b\n    applyOperation _ _ _ = error \"Unsupported operation\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"\/\/\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_161","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ --рдлрдВрдХреНрд╢рди рдЫреВ рд░рд┐рдЬрд▓реНрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ рджреЗрд╡рди.--рдЕрдЧрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдордВрдЬрд╝ рдХрд╣рдБ рддреЗ рд▓рдлрд╝рдЬрд╝ рдЫрд╛рди ,рддрд╡реЗ рдЫреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЙрд▓рдЯрд╛ рдХрд╛рд░рди--рдЕрдЧрд░ рдиреЗ рдпреЗ рд╣рдХрд╝ рдЕрд╕рд┐рде рдд рдпреЗ рд╣рдХрд╝ рдЕрд╕рд┐рде рддреЗрде рдкрд╛рда--рдЕрдЧрд░ s[i] рдЕрдЦ рд▓рдлрд╝рдЬрд╝ рдЫреЗ, рддрдорд┐ рд╕реБрдиреНрдж рдХреЗрд╕ рд▓реЛрдЕрд░ рдкреЗрда рдЙрдкреНрдкреЗрд░ рддрд╛рдо рдпрд╛ рд╡рд┐рд╕реЗрд░рд╡реЗрд╕ рддрд╛рдо,--          --  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =","canonical_solution":"solve :: String -> String\nsolve s\n  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s\n  | otherwise = reverse s\n  where\n    toggleCase c\n      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char\n      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_162","nl":"kas_Deva","pl":"hs","prompt":"--рдЕрдЧрд░ 'рдЯреЗрдХреНрд╕реНрдЯ' рдЫреВ рдЦрд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ,рддреЗрд▓ рдЫреВ рдиреЙрдЯ рд░рд┐рдЯрд░реНрди рдпреЗрд╡рд╛ рдХрд░рдиреЗ.-- 'рдЯреЗрдХреНрд╕реНрдЯ' рджреЗрдИ рдЧреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ, рд░рд┐рдЯрд░реНрди рдЗрдЯреНрд╕ рдПрдордбреА5 рд╣реИрд╢ рдПрдХреНрд╡рд┐рд╡реИрд▓реЗрдиреНрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ. --  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =","canonical_solution":"import qualified Data.ByteString.Char8 as C\nimport qualified Data.Digest.Pure.MD5 as MD5\n\nstringToMd5 :: String -> Maybe String\nstringToMd5 text\n  | null text = Nothing\n  | otherwise = Just $ show $ MD5.md5 $ C.pack text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_163","nl":"kas_Deva","pl":"hs","prompt":"--рдорд┐рд╕рд╛рд▓ рдХреА рддреЛрд░: --рдмреА ,рдПрдореН рдЫреА рд╛рд╕рд┐рдд рд╛рд╕рд┐рдд--Given two positive integers a and b, return the even digits between a  рдмреА рддреЗ рдП рдмреА рдмреА рдмреА рдмреА рдмреА рдмреА рдмреА рдмреА рдмреА--  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =","canonical_solution":"generateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b = filter even [min a b .. max a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()"}]