task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,kas_Deva,hs,"--‡§£ ‡•ç ‡•ç ‡•ç ‡•ç ‡•ç ‡•ç------- ‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡•Å‡§ö‡§®‡•á ‡§ï‡•Ä ‡§ï‡§π‡•Ä‡§Ç ‡§õ‡•Ä ‡§ï‡§π‡•Ä‡§Ç ‡§ú‡§º‡•á ‡§®‡§Ç‡§¨‡§∞ ‡§Ü‡§∏‡§æ‡§® ‡•ã‡§®‡•á ‡§∏‡•á‡§•--  >>> hasCloseElements [1.0,2.0,3.0] 0.5
--  False
--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3
--  True
hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold =","hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold = any (\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a /= b]","
main :: IO ()
main = do
  let candidate = hasCloseElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_1,kas_Deva,hs,"--‡§á‡§®‡§™‡•Å‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Æ‡§Ç‡§ú‡§º ‡§ï‡§π‡§Å ‡§§‡•á ‡§∏‡•ç‡§™‡•á‡§∏ ‡§õ‡•Ç ‡§á‡§®‡§ó‡•â‡§∞ ‡§ï‡§∞‡§•.--‡§Ö‡§≤‡§ó ‡§Ö‡§≤‡§ó ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§õ‡§ø ‡§¨‡•à‡§≤‡•á‡§Ç‡§∏‡•ç‡§° ‡§Ü‡§∏‡§æ‡§® (‡§π‡§∞ ‡§Ö‡§ñ ‡§ì‡§™‡§®‡•Å‡§ï ‡§¨‡•ç‡§∞‡•á‡§∏ ‡§õ‡•Å ‡§Æ‡•Å‡§®‡§æ‡§∏‡§ø‡§¨ ‡§§‡•ã‡§∞ ‡§¨‡§Ç‡§¶ ‡§ó‡§õ‡§æ‡§®) ‡§§ ‡§Ö‡§ñ ‡§Ö‡§ï‡§ø‡§∏ ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§õ‡•Å‡§® ‡§®‡•á‡§∏‡•ç‡§ü ‡§ï‡§∞‡§æ‡§®‡•§--‡§Ø‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Ö‡§≤‡§ó ‡§Ö‡§≤‡§ó ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§§‡•ç‡§∞‡§æ‡§µ‡•Å‡§® ‡§§‡•á‡§Æ‡§® ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡•ã‡§Ç.--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Ø‡§æ‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§æ‡§∞‡§ø‡§Ø‡§æ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§®‡•á‡§∏‡•ç‡§ü‡•á‡§° ‡§ï‡§Ç‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§∏--  >>> separateParenGroups ""( ) (( )) (( )( ))""
--  [""()"",""(())"",""(()())""]
separateParenGroups :: String -> [String]
separateParenGroups paren_string =","separateParenGroups :: String -> [String]
separateParenGroups paren_string = go paren_string 0 [] """" []
  where
    go [] _ _ current acc = if null current then acc else acc ++ [current]
    go (x:xs) depth stack current acc
      | x == ' ' = go xs depth stack current acc
      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc
      | x == ')' =
          let newCurrent = current ++ [x]
              newDepth = depth - 1
          in if newDepth == 0
             then go xs newDepth (tail stack) """" (acc ++ [newCurrent])
             else go xs newDepth (tail stack) newCurrent acc
      | otherwise = error ""Unexpected character""","
main :: IO ()
main = do
  let candidate = separateParenGroups
  if candidate ""(()()) ((())) () ((())()())"" == [""(()())"",""((()))"",""()"",""((())()())""] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [""()"",""(())"",""((()))"",""(((())))""] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [""(()(())((())))""] then pure () else error ""assertion failed""
  if candidate ""( ) (( )) (( )( ))"" == [""()"",""(())"",""(()())""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_2,kas_Deva,hs,"--‡§£‡§£‡§£‡§¶‡§¶ ‡§£‡§¶ ‡§£‡§¶ ‡§£‡§¶ ‡§£‡§¶ ‡§£‡§¶ ‡§£‡§¶ ‡§£‡§¶ ‡§£‡§¶--(‡§¨‡§ö‡•á ‡§π‡•Å‡§µ‡•á ‡§™‡§æ‡§∞‡•ç‡§ü ‡§π‡§Æ‡•á‡§∂‡§æ 1 ‡§ñ‡•ã‡§§ ‡§ï‡§Æ).--‡§§‡•á ‡§á‡§Ç‡§ü‡•á‡§ó‡§∞ ‡§™‡§æ‡§∞‡•ç‡§ü (‡§¶‡§æ‡§ì ‡§®‡§Ç‡§¨‡§∞ ‡§ñ‡•ã‡§§ ‡§≤‡§ï‡§ø‡§ü ‡§á‡§®‡•ç‡§ü‡•á‡§ó‡§∞) ‡§§‡•á ‡§°‡•á‡§∏‡•Ä‡§Æ‡§≤--‡§Ø‡•Å‡§∏ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§´‡•ç‡§≤‡•ã‡§ü‡§ø‡§Ç‡§ó ‡§™‡•â‡§á‡§Ç‡§ü ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ,‡§á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§°‡§ø‡§ï‡•ã‡§Æ‡•ç‡§™‡•ã‡§∏‡•á‡§° ‡§ï‡§∞‡§®‡•á--  >>> truncateNumber 3.5
--  0.5
truncateNumber :: Float -> Float
truncateNumber number =","truncateNumber :: Float -> Float
truncateNumber number = number - fromIntegral (floor number)","
main :: IO ()
main = do
  let candidate = truncateNumber
  if candidate 3.5 == 0.5 then pure () else error ""assertion failed""
  if candidate 1.25 == 0.25 then pure () else error ""assertion failed""
  if candidate 123.0 == 0.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_3,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á ‡§Ö‡§∏ ‡§∏‡§π‡•Ä ‡§§‡•á‡§Æ ‡§µ‡§æ‡§§‡•ã ,‡§§‡•ã‡§≤ ‡§Ö‡§∏ ‡§ó‡§≤‡§§ ‡§§‡•á‡§Æ ‡§µ‡§æ‡§§‡•ã--‡§§‡•ã‡§Ø ‡§õ‡•Ä ‡§Ø‡§π ‡§°‡§ø‡§ü‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡§æ ‡§ï‡•Ä ‡§ï‡§π‡•Ä‡§Ç ‡§™‡•à‡§† ‡§õ‡•Ä ‡§¨‡•à‡§≤‡•á‡§Ç‡§∏ ‡§ë‡§´‡§º ‡§è‡§ï‡§æ‡§â‡§Ç‡§ü‡•ç‡§∏ ‡§ó‡§æ‡§∏‡§® ‡§ú‡•Ä‡§∞‡•ã ‡§ñ‡•ã‡§§ ‡§®‡•Ä‡§ö ,‡§¨‡•á--‡§Ö‡§ñ‡§É ‡§¨‡•à‡§Ç‡§ï ‡§Ö‡§ï‡§æ‡§â‡§Ç‡§ü‡§∏ ‡§™‡•á‡§† ‡§ú‡§Æ‡§æ ‡§§‡•á ‡§®‡§ø‡§ï‡§æ‡§∏‡•Ä ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ø‡•Å‡§∏ ‡§∏‡•á‡§§ ‡§∂‡•Å‡§∞‡•Ç ‡§õ‡•Ç ‡§Ø‡•á‡§µ‡§æ ‡§ï‡§∞‡§®‡•á--  >>> belowZero [1,2,3]
--  False
--  >>> belowZero [1,2,(-4),5]
--  True
belowZero :: [Int] -> Bool
belowZero operations =","belowZero :: [Int] -> Bool
belowZero operations = any (< 0) $ scanl (+) 0 operations","
main :: IO ()
main = do
  let candidate = belowZero
  if candidate [] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-4),5,6] == True then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error ""assertion failed""
  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_4,kas_Deva,hs,"--MAD = ‡§î‡§∏‡§§‡•§ x - x_mean‡•§ --‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§§‡•á ‡§∏‡•á‡§®‡•ç‡§ü‡§∞‡§™‡•â‡§á‡§Ç‡§ü (‡§è‡§Æ‡§è‡§è‡§® ‡§Æ‡§Ç‡§ú‡§º):--‡§Æ‡•Ä‡§®‡•ç‡§∏ ‡§Ö‡§¨‡•ç‡§∏‡•ã‡§≤‡•Å‡§ü‡•á ‡§°‡§ø‡§µ‡§ø‡§è‡§∂‡§® ‡§õ‡•Ä ‡§Æ‡•Ä‡§®‡•ç‡§∏ ‡§Ö‡§¨‡•ç‡§∏‡•ã‡§≤‡•Å‡§ü‡•á ‡§°‡§ø‡§´‡§∞‡•á‡§Ç‡§∏ ‡§¶‡•Å‡§á‡§® ‡§Æ‡§Ç‡§ú‡§º--‡§∏‡•â‡§∞‡•Ä ‡§°‡§æ‡§ü‡§æ ‡§õ‡•Ä ‡§à‡§µ‡§æ ‡§∞‡§ú‡§º‡§æ‡§®--‡•á‡§ï ‡§¶‡•á‡§µ‡§® ‡§≤‡§ø‡§∏‡§ü ‡§á‡§®‡§™‡•Å‡§ü ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§ñ‡§æ‡§§‡§∞ , ‡§õ‡•Ä ‡§ï‡§≤‡§® ‡§Æ‡•Ä‡§®‡•ç‡§∏ ‡§Ö‡§¨‡•ç‡§∏‡•ã‡§≤‡•Å‡§ü‡•á ‡§°‡§ø‡§µ‡§ø‡§è‡§∂‡§®--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]
--  1.0
meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers =","meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers = sum absoluteDifferences / fromIntegral (length numbers)
  where
    mean = sum numbers / fromIntegral (length numbers)
    absoluteDifferences = map (\x -> abs (x - mean)) numbers","
main :: IO ()
main = do
  let candidate = meanAbsoluteDeviation
  if candidate [1.0,2.0] == 0.5 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_5,kas_Deva,hs,"--‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§®‡§Ç‡§¨‡§∞‡§∏ ' ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§®‡§Ç‡§¨‡§∞‡§∏ ' ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§®‡§Ç‡§¨‡§∞‡§∏ ' ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§®‡§Ç‡§¨‡§∞‡§∏ ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‚àÄ‡§á‡§®‡§™‡•Å‡§ü--  >>> intersperse [] 4
--  []
--  >>> intersperse [1,2,3] 4
--  [1,4,2,4,3]
intersperse :: [Int] -> Int -> [Int]
intersperse numbers delimeter =","intersperse :: [Int] -> Int -> [Int]
intersperse [] _ = []
intersperse [x] _ = [x]
intersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","
main :: IO ()
main = do
  let candidate = intersperse
  if candidate [] 7 == [] then pure () else error ""assertion failed""
  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error ""assertion failed""
  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_6,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤‡•á, ()) ‡§π‡•ç‡§®‡§¶‡§ø‡§∏ ‡§®‡•á‡§∏‡§ü‡§ø‡§Ç‡§ó ‡§≤‡•á‡§µ‡§≤‡§∏ ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§õ‡§ø ‡§¶‡•ã‡§® ‡§≤‡•á‡§µ‡§≤ ‡§Ü‡§∏‡§æ‡§® ‡§Ø‡•á‡§≤‡§ø ‡§ú‡§º‡§® ()) ‡§π‡•ç‡§®‡§¶‡§ø‡§∏ ‡§§‡•ç‡§∞‡•á‡§® ‡§≤‡•á‡§µ‡§≤‡§∏ ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§õ‡•Å‡•§--‡§π‡§∞ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ñ‡§æ‡§§‡§ø‡§∞,‡§ï‡•Å‡§°‡§º‡§® ‡§π‡§ø‡§Ç‡§ú ‡§®‡•á‡§∏‡•ç‡§ü‡§ø‡§Ç‡§ó ‡§π‡§ø‡§Ç‡§ú ‡§°‡•Ä‡§™ ‡§≤‡•á‡§µ‡§≤ ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§ï‡§∞‡§æ.--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Ø‡•Å‡§∏ ‡§π‡§µ‡§® ‡§õ‡•Ä ‡§Æ‡§≤‡•ç‡§ü‡•Ä‡§™‡§≤ ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§®‡•á‡§∏‡•ç‡§ü‡•á‡§° ‡§ï‡§Ç‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§ñ‡§æ‡§§‡§∞ ‡§Ø‡•Å‡§∏ ‡§Ö‡§≤‡§ó ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§∏‡•ç‡§™‡•á‡§∏ ‡§∏‡•á‡§•--  >>> parseNestedParens ""(()()) ((())) () ((())()())""
--  [2,3,1,3]
parseNestedParens :: String -> [Int]
parseNestedParens paren_string =","parseNestedParens :: String -> [Int]
parseNestedParens paren_string = map maxDepth (words paren_string)
  where
    maxDepth :: String -> Int
    maxDepth = go 0 0
      where
        go :: Int -> Int -> String -> Int
        go currentDepth maxDepth [] = maxDepth
        go currentDepth maxDepth (c:cs)
          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs
          | c == ')'  = go (currentDepth - 1) maxDepth cs
          | otherwise = go currentDepth maxDepth cs","
main :: IO ()
main = do
  let candidate = parseNestedParens
  if candidate ""(()()) ((())) () ((())()())"" == [2,3,1,3] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [4] then pure () else error ""assertion failed""
  pure ()"
HumanEval_7,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§´‡§ø‡§≤‡•ç‡§ü‡§∞ ‡§ï‡§æ‡§∞‡§® ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§§‡•á‡§Æ‡§® ‡§ñ‡§æ‡§§‡§∞ ‡§Ø‡§Æ ‡§Æ‡§Ç‡§ú‡§º ‡§∏‡§¨‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä--  >>> filterBySubstring [] ""a""
--  []
--  >>> filterBySubstring [""abc"",""bacd"",""cde"",""array""] ""a""
--  [""abc"",""bacd"",""array""]
filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring =","filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring = filter (substring `isInfixOf`) strings
  where isInfixOf = isInfixOf","
main :: IO ()
main = do
  let candidate = filterBySubstring
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""aaaxxy"",""john doe"",""xxxAAA"",""xxx""] ""xx"" == [""xxx"",""aaaxxy"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""grunt"",""trumpet"",""prune"",""gruesome""] ""run"" == [""grunt"",""prune""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_8,kas_Deva,hs,"--‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§Ö‡§∏ ‡§∏‡•Å‡§Æ‡•ç‡§Æ ‡§¨‡§∞‡§æ‡§¨‡§∞ 0 ‡§¨‡•á ‡§Ø‡•Å‡§∏ ‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§Ö‡§∏ ‡§∏‡•Å‡§Æ‡•ç‡§Æ ‡§¨‡§∞‡§æ‡§¨‡§∞ 1--‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ñ‡§æ‡§§‡§ø‡§∞,‡§§‡•á‡§Æ ‡§Ö‡§∏ ‡§ü‡§™‡§≤ ‡§§‡•á ‡§§‡•á‡§Æ ‡§∏‡§¨‡§ï‡•Å‡§ï ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§Ø‡•Å‡§∏ ‡§∏‡•Ç‡§ö‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ç.--  >>> sumProduct []
--  (0, 1)
--  >>> sumProduct [1,2,3,4]
--  (10, 24)
sumProduct :: [Int] -> (Int, Int)
sumProduct numbers =","sumProduct :: [Int] -> (Int, Int)
sumProduct numbers = (sum numbers, product numbers)","
main :: IO ()
main = do
  let candidate = sumProduct
  if candidate [] == (0, 1) then pure () else error ""assertion failed""
  if candidate [1,1,1] == (3, 1) then pure () else error ""assertion failed""
  if candidate [100,0] == (100, 0) then pure () else error ""assertion failed""
  if candidate [3,5,7] == (15, 105) then pure () else error ""assertion failed""
  if candidate [10] == (10, 10) then pure () else error ""assertion failed""
  pure ()"
HumanEval_9,kas_Deva,hs,"--‡§£‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£--‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º,‡§§‡•á‡§Æ ‡§µ‡§ï‡§º‡§§ ‡§§‡§æ‡§Æ ‡§≤‡§¨‡§®‡•Ä ‡§Ö‡§Æ‡•É‡§§ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡§®‡•á.--  >>> rollingMax [1,2,3,2,3,4,2]
--  [1,2,3,3,3,4,4]
rollingMax :: [Int] -> [Int]
rollingMax numbers =","rollingMax :: [Int] -> [Int]
rollingMax = scanl1 max","
main :: IO ()
main = do
  let candidate = rollingMax
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error ""assertion failed""
  pure ()"
HumanEval_10,kas_Deva,hs,"--- ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§∞‡§ø‡§µ‡§∞‡•ç‡§∏ ‡§ï‡§ø‡§∏ ‡§è‡§®‡•ç‡§°‡§∏ ‡§™‡•á‡§† ‡§Ö‡§ï‡§ø‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§™‡•ç‡§∞‡•Ä‡§´‡§ø‡§ï‡•ç‡§∏‡§∏ ‡§ú‡•ã‡§õ‡•Å‡§® ‡§Ø‡•Å‡§∏ ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ‡§ø‡§ï ‡§∏‡§´‡§ø‡§ï‡•ç‡§∏ ‡§¨‡§∞‡•ã‡§π ‡§Ü‡§µ‡•§--- ‡§´‡§æ‡§à‡§Ç‡§° ‡§•‡•ç‡§∞‡•Ç ‡§¶‡•Ä‡§° ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§á‡§ú ‡§è ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ--‡§Ö‡§≤‡•ç‡§ó‡•ã‡§∞‡§ø‡§•‡§Æ ‡§Ü‡§á‡§°‡§ø‡§Ø‡§æ ‡§Ü‡§∏‡§æ‡§®:--üìå ‡§ï‡§Æ‡•ã‡§∏‡•ç‡§ü ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ ‡§ñ‡•ã‡§ú‡•á‡§Ç ‡§ú‡•ã ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§ú‡§æ‡§Ø‡•á üìå ‡§ï‡§Æ‡•ã‡§∏‡•ç‡§ü ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ ‡§ñ‡•ã‡§ú‡•á‡§Ç ‡§ú‡•ã ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§ú‡§æ‡§Ø‡•á üìå ‡§ï‡§Æ‡•ã‡§∏‡•ç‡§ü ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ ‡§ñ‡•ã‡§ú‡•á‡§Ç ‡§ú‡•ã ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§ú‡§æ‡§Ø‡•á üìå ‡§ï‡§Æ‡•ã‡§∏‡•ç‡§ü ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ ‡§ñ‡•ã‡§ú‡•á‡§Ç ‡§ú‡•ã ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§ú‡§æ‡§Ø‡•á üìå--  >>> makePalindrome """"
--  """"
--  >>> makePalindrome ""cat""
--  ""catac""
--  >>> makePalindrome ""cata""
--  ""catac""
makePalindrome :: String -> String
makePalindrome string =","makePalindrome :: String -> String
makePalindrome string = string ++ reverse (take (length string - palindromeLength) string)
  where
    palindromeLength = longestPalindromicSuffix string

longestPalindromicSuffix :: String -> Int
longestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]

isPalindrome :: String -> Bool
isPalindrome s = s == reverse s","
main :: IO ()
main = do
  let candidate = makePalindrome
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""x"" == ""x"" then pure () else error ""assertion failed""
  if candidate ""xyz"" == ""xyzyx"" then pure () else error ""assertion failed""
  if candidate ""xyx"" == ""xyx"" then pure () else error ""assertion failed""
  if candidate ""jerry"" == ""jerryrrej"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_11,kas_Deva,hs,"--‡§á‡§®‡§™‡•Å‡§ü‡§∏ ‡§™‡•á‡§† ‡§¨‡§æ‡§á‡§®‡§∞‡•Ä XOR ‡§ï‡§∞‡§æ‡§® ‡§§‡§π ‡§®‡§§‡•Ä‡§ú‡§∏ ‡§§‡§ø string ‡§ï‡§ø‡§∏ ‡§∏‡•Ç‡§∞‡§§‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§æ‡§®‡•§-- ‡§á‡§®‡§™‡•Å‡§ü ‡§õ‡•á ‡§ú‡§º‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó a ‡§§ b ‡§Ø‡§ø‡§Æ ‡§∏‡§ø‡§∞‡§ø‡§´‡§º 1 ‡§§ 0 ‡§õ‡•á ‡§Ü‡§∏‡§æ‡§®‡•§--  >>> stringXor ""010"" ""110""
--  ""100""
stringXor :: String -> String -> String
stringXor a b =","stringXor :: String -> String -> String
stringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","
main :: IO ()
main = do
  let candidate = stringXor
  if candidate ""111000"" ""101010"" == ""010010"" then pure () else error ""assertion failed""
  if candidate ""1"" ""1"" == ""0"" then pure () else error ""assertion failed""
  if candidate ""0101"" ""0000"" == ""0101"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_12,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ç ‡§∞‡§ø‡§ï‡•ç‡§§,‡§§‡•á‡§≤ ‡§õ‡•Ç ‡§®‡•ã‡§• ‡§§‡•á ‡§≤‡§µ‡§®.-- list ‡§ë‡§´‡§º strings, return the ‡§≤‡•â‡§®‡•ç‡§ó‡§∏‡•ç‡§ü ‡§ì‡§®‡•á.  return the ‡§´‡§∞‡•ç‡§∏‡•ç‡§ü ‡§ì‡§®‡•á ‡§á‡§® ‡§ï‡•á‡§∏ ‡§ë‡§´‡§º ‡§Æ‡§≤‡•ç‡§ü‡•Ä‡§™‡•ç‡§≤ --  >>> longest []
--  Just (Nothing)
--  >>> longest [""a"",""b"",""c""]
--  Just (""a"")
--  >>> longest [""a"",""bb"",""ccc""]
--  Just (""ccc"")
longest :: [String] -> Maybe String
longest strings =","longest :: [String] -> Maybe String
longest [] = Nothing
longest strings = Just $ foldl1 (\acc x -> if length x > length acc then x else acc) strings","
main :: IO ()
main = do
  let candidate = longest
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == Just (""x"") then pure () else error ""assertion failed""
  if candidate [""x"",""yyy"",""zzzz"",""www"",""kkkk"",""abc""] == Just (""zzzz"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_13,kas_Deva,hs,"--a ‡§§‡•á b ‡§§‡•á‡§Æ‡§ú ‡§µ‡§∞‡•Ä‡§Ø ‡§ï‡§Æ ‡§ï‡•â‡§Æ‡§® ‡§°‡§ø‡§µ‡•Ä‡§ú‡§º‡§∞--  >>> greatestCommonDivisor 3 5
--  1
--  >>> greatestCommonDivisor 25 15
--  5
greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b =","greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b
  | b == 0    = a
  | otherwise = greatestCommonDivisor b (a `mod` b)","
main :: IO ()
main = do
  let candidate = greatestCommonDivisor
  if candidate 3 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 15 == 5 then pure () else error ""assertion failed""
  if candidate 49 14 == 7 then pure () else error ""assertion failed""
  if candidate 144 60 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_14,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§≤‡§´‡§º‡§ú‡§º ‡§õ‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§∏‡§æ‡§∞‡§ø ‡§∏‡•Ç‡§∞‡§§ ‡§á‡§®‡§™‡•Å‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Æ‡§Ç‡§ú‡§º--  >>> allPrefixes ""abc""
--  [""a"",""ab"",""abc""]
allPrefixes :: String -> [String]
allPrefixes string =","allPrefixes :: String -> [String]
allPrefixes string = [take n string | n <- [1 .. length string]]","
main :: IO ()
main = do
  let candidate = allPrefixes
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""asdfgh"" == [""a"",""as"",""asd"",""asdf"",""asdfg"",""asdfgh""] then pure () else error ""assertion failed""
  if candidate ""WWW"" == [""W"",""WW"",""WWW""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_15,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Ö‡§∏ ‡§¶‡•á‡§µ‡§® ‡§∏‡•ç‡§™‡•á‡§∏ ‡§°‡§ø‡§≤‡•Ä‡§Æ‡§ø‡§ü‡•á‡§° ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§∏‡•á‡§•--  >>> stringSequence 0
--  ""0""
--  >>> stringSequence 5
--  ""0 1 2 3 4 5""
stringSequence :: Int -> String
stringSequence n =","stringSequence :: Int -> String
stringSequence n = unwords $ map show [0..n]","
main :: IO ()
main = do
  let candidate = stringSequence
  if candidate 0 == ""0"" then pure () else error ""assertion failed""
  if candidate 3 == ""0 1 2 3"" then pure () else error ""assertion failed""
  if candidate 10 == ""0 1 2 3 4 5 6 7 8 9 10"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_16,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä ,‡§Ø‡§ø‡§≤ ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡•ã ‡§ï‡•Ä ‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§Ö‡§≤‡§ó ‡§µ‡§∞‡•ç‡§£ (‡§Ö‡§∏ ‡§®‡•á ‡§ï‡§π‡•Ä‡§Ç ‡§ï‡•á‡§∏)--  >>> countDistinctCharacters ""xyzXYZ""
--  3
--  >>> countDistinctCharacters ""Jerry""
--  4
countDistinctCharacters :: String -> Int
countDistinctCharacters string =","import Data.Char (toLower)
import Data.Set (fromList, size)

countDistinctCharacters :: String -> Int
countDistinctCharacters string = size . fromList $ map toLower string","
main :: IO ()
main = do
  let candidate = countDistinctCharacters
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abcde"" == 5 then pure () else error ""assertion failed""
  if candidate ""abcdecadeCADE"" == 5 then pure () else error ""assertion failed""
  if candidate ""aaaaAAAAaaaa"" == 1 then pure () else error ""assertion failed""
  if candidate ""Jerry jERRY JeRRRY"" == 5 then pure () else error ""assertion failed""
  pure ()"
HumanEval_17,kas_Deva,hs,"--'.‡§õ‡•á‡§ï' -‡§ï‡•ç‡§µ‡§æ‡§∞‡•ç‡§ü‡§∞ ‡§®‡•ã‡§ü,‡§Ö‡§ñ ‡§¨‡•Ä‡§ü ‡§§‡§ï‡§º‡§∞‡•Ä‡§¨‡§®.--'‡§ì‡§∞ ‡§π‡•Ö‡§°' - ‡§π‡§æ‡§´ ‡§®‡•ã‡§ü, ‡§¶‡•ã ‡§¨‡•Ä‡§ü‡•ç‡§∏ ‡§§‡§ï ‡§∞‡§π‡§§‡§æ ‡§π‡•à‡•§--'‡§ì' - ‡§™‡•Å‡§∞ ‡§®‡•ã‡§ü, ‡§õ‡•Ç ‡§´‡•ã‡§∞ ‡§¨‡•Ä‡§ü‡•ç‡§∏ ‡§§‡§æ‡§Æ.--‡§Ø‡•á ‡§õ‡•Ä ‡§≤‡•á‡§ú‡•á‡§Ç‡§°:--‡§Ü‡§ñ‡§∞‡•Ä ‡§Æ‡§Ç‡§ú‡§º‡§ø‡§≤ ‡§®‡§π‡•Ä‡§Ç‡•§--‡§§‡•ã‡§∏‡§ø ‡§π‡§Ç‡§¶‡§ø‡§∏ ‡§ï‡§æ‡§Æ‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Å ‡§Ø‡§ø ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§™‡§æ‡§∞‡•ç‡§∏ ‡§ï‡§∞‡§æ‡§® ‡§§ ‡§Ø‡§ø‡§Æ‡§® ‡§™‡•Ç‡§∞‡•ç‡§£‡§æ‡§Ç‡§ï‡§® ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§æ‡§® ‡§Ø‡§ø‡§Æ ‡§ï‡•Å‡§®‡§ø ‡§§‡§ø ‡§§‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§π ‡§§‡§æ‡§Æ ‡§¨‡•Ä‡§ü‡•ç‡§∏ ‡§ï‡§∞‡§æ‡§® ‡§õ‡§ø‡•§--‡§á‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§á‡§®‡§™‡•Å‡§ü ‡§á‡§∏ a ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó representing ‡§Æ‡•ç‡§Ø‡•Ç‡§ú‡§ø‡§ï‡§≤ ‡§®‡•ã‡§ü‡•ç‡§∏ ‡§á‡§® a ‡§∏‡•ç‡§™‡•á‡§∂‡§≤ ASCII ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü. --  >>> parseMusic ""o o| .| o| o| .| .| .| .| o o""
--  [4,2,1,2,2,1,1,1,1,4,4]
parseMusic :: String -> [Int]
parseMusic music_string =","parseMusic :: String -> [Int]
parseMusic music_string = map beats (words music_string)
  where
    beats ""o"" = 4
    beats ""o|"" = 2
    beats "".|"" = 1
    beats _ = 0","
main :: IO ()
main = do
  let candidate = parseMusic
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""o o o o"" == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate "".| .| .| .|"" == [1,1,1,1] then pure () else error ""assertion failed""
  if candidate ""o| o| .| .| o o o o"" == [2,2,1,1,4,4,4,4] then pure () else error ""assertion failed""
  if candidate ""o| .| o| .| o o| o o|"" == [2,1,2,1,4,2,4,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_18,kas_Deva,hs,"-- ‡§õ‡•Å ‡§™‡§§‡§æ ‡§≤‡§ó‡§æ‡§µ‡§® ‡§ú‡§º‡§ø ‡§Ö‡§ï‡§ø‡§∏ ‡§∏‡§¨‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡§ø ‡§ï‡§§‡•Ä ‡§ó‡•â‡§∞ ‡§Æ‡•ã‡§ú‡§º‡•Ç ‡§Ø‡§ø‡§µ‡§æ‡§® ‡§ï‡§°‡§®‡§æ‡§µ‡§æ‡§®‡•§--  >>> howManyTimes """" ""a""
--  0
--  >>> howManyTimes ""aaa"" ""a""
--  3
--  >>> howManyTimes ""aaaa"" ""aa""
--  3
howManyTimes :: String -> String -> Int
howManyTimes string substring =","howManyTimes :: String -> String -> Int
howManyTimes string substring
  | null substring = 0
  | otherwise = length . filter isPrefixOfSubstring $ tails string
  where
    isPrefixOfSubstring = isPrefixOf substring
    isPrefixOf :: Eq a => [a] -> [a] -> Bool
    isPrefixOf prefix str = prefix `isPrefixOf` str","
main :: IO ()
main = do
  let candidate = howManyTimes
  if candidate """" ""x"" == 0 then pure () else error ""assertion failed""
  if candidate ""xyxyxyx"" ""x"" == 4 then pure () else error ""assertion failed""
  if candidate ""cacacacac"" ""cac"" == 4 then pure () else error ""assertion failed""
  if candidate ""john doe"" ""john"" == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_19,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§≤‡§ï‡•Å‡§ü ‡§™‡•á‡§† ‡§≤‡§æ‡§∞‡•ç‡§ú ‡§§‡§æ‡§Æ--‡§µ‡•à‡§≤‡§ø‡§° ‡§ö‡•â‡§á‡§∏ ‡§õ‡§ø ""‡§ú‡§º‡•á‡§∞‡•ã"", ""‡§µ‡§®"", ""‡§ü‡•Ç"", ""‡§•‡•ç‡§∞‡•Ä"", ""‡§´‡•ã‡§∞"", ""‡§´‡§æ‡§á‡§µ"", ""‡§∏‡§ø‡§ö‡•ç‡§∏"", ""‡§∏‡•á‡§µ‡•á‡§®"", ""‡§ì‡§ü"" ‡§§ ""‡§®‡§æ‡§µ‡•á‡§®""‡•§--‡§á‡§®‡§™‡•Å‡§ü ‡§õ‡•Ç ‡§∏‡•ç‡§™‡•á‡§∏-‡§°‡§ø‡§≤‡•Ä‡§Æ‡§ø‡§ü‡•á‡§° ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§®‡•Å‡§Æ‡§æ‡§∞‡§ø‡§ï‡§æ‡§≤‡§∏ ‡§™‡•á‡§† '‡§ú‡§º‡•Ä‡§∞‡•ã' ‡§™‡•á‡§† '‡§®‡•å'.--  >>> sortNumbers ""three one five""
--  ""one three five""
sortNumbers :: String -> String
sortNumbers numbers =","import Data.List (sort)
import Data.Maybe (fromJust)
import Data.Map (Map, fromList, lookup)

sortNumbers :: String -> String
sortNumbers numbers = unwords $ map snd $ sort $ map (\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)
  where
    wordToNumber :: Map String Int
    wordToNumber = fromList [(""zero"", 0), (""one"", 1), (""two"", 2), (""three"", 3), (""four"", 4),
                             (""five"", 5), (""six"", 6), (""seven"", 7), (""eight"", 8), (""nine"", 9)]","
main :: IO ()
main = do
  let candidate = sortNumbers
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""three"" == ""three"" then pure () else error ""assertion failed""
  if candidate ""three five nine"" == ""three five nine"" then pure () else error ""assertion failed""
  if candidate ""five zero four seven nine eight"" == ""zero four five seven eight nine"" then pure () else error ""assertion failed""
  if candidate ""six five four three two one zero"" == ""zero one two three four five six"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_20,kas_Deva,hs,"--‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡•á‡§Æ‡§® ‡§ï‡•ç‡§∞‡§Æ‡§ø‡§ï (‡§ï‡§Æ ‡§®‡§Ç‡§¨‡§∞, ‡§µ‡§∞‡•Ä‡§Ø ‡§®‡§Ç‡§¨‡§∞)--‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§∏‡•Ç‡§ö‡§®‡•á (‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§ú‡§º‡•á) ‡§∏‡•á‡§≤‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡•ã ‡§¨‡•á ‡§¶‡•á ‡§¶‡•ã ‡§Ø‡•Å‡§∏ ‡§®‡§ú‡§º‡§¶‡•Ä‡§ï ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§®--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]
--  (2.0, 2.2)
--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]
--  (2.0, 2.0)
findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers =","findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)
  where
    sortedNumbers = sort numbers
    minByDiff (a1, b1) (a2, b2)
      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)
      | otherwise = (a2, b2)","
main :: IO ()
main = do
  let candidate = findClosestElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_21,kas_Deva,hs,"--‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§∞‡•Ä‡§Ø ‡§ï‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡§ø‡§® 0 ‡§¨‡•á ‡§µ‡§∞‡•Ä‡§Ø ‡§¨‡§¢‡§º 1--‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç (‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§ú‡§º‡•á ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü),‡§Ö‡§• ‡§õ‡•Ä ‡§Ö‡§∏ ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§æ‡§∞‡§® ‡§≤‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ü‡•ç‡§∞‡§æ‡§Ç‡§∏‡§´‡•â‡§∞‡•ç‡§Æ--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]
--  [0.0,0.25,0.5,0.75,1.0]
rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers =","rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers = map (\x -> (x - minVal) / range) numbers
  where
    minVal = minimum numbers
    maxVal = maximum numbers
    range = maxVal - minVal","
main :: IO ()
main = do
  let candidate = rescaleToUnit
  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error ""assertion failed""
  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error ""assertion failed""
  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  pure ()"
HumanEval_23,kas_Deva,hs,"--‡§∏‡•â‡§∞‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡•ã‡§Ç‡§ó‡§• ‡§µ‡§æ‡§™‡§∏ --  >>> strlen """"
--  0
--  >>> strlen ""abc""
--  3
strlen :: String -> Int
strlen string =","strlen :: String -> Int
strlen string = length string","
main :: IO ()
main = do
  let candidate = strlen
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""x"" == 1 then pure () else error ""assertion failed""
  if candidate ""asdasnakj"" == 9 then pure () else error ""assertion failed""
  pure ()"
HumanEval_24,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§¶‡§æ‡§π ‡§Ö‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§è‡§® ‡§ñ‡§æ‡§§‡§∞ ,‡§Ö‡§• ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§®‡§Ç‡§¨‡§∞ ‡§Ø‡•Å‡§∏ ‡§è‡§® ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§°‡§ø‡§µ‡§æ‡§á‡§° ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ,‡§Ö‡§∏ ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§≤‡§ï‡§ø‡§ü ‡§è‡§® ‡§ñ‡•ã‡§§--  >>> largestDivisor 15
--  5
largestDivisor :: Int -> Int
largestDivisor n =","largestDivisor :: Int -> Int
largestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = largestDivisor
  if candidate 3 == 1 then pure () else error ""assertion failed""
  if candidate 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 == 5 then pure () else error ""assertion failed""
  if candidate 100 == 50 then pure () else error ""assertion failed""
  if candidate 49 == 7 then pure () else error ""assertion failed""
  pure ()"
HumanEval_25,kas_Deva,hs,"--‡§á‡§®‡§™‡•Å‡§ü ‡§®‡§Ç‡§¨‡§∞ ‡§π‡§ï‡•ã ‡§Ö‡§∏ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§ë‡§´‡§º ‡§∏‡§≤‡•Ä‡§Æ ‡§´‡•à‡§ï‡•ç‡§ü‡§∞‡•ç‡§∏ --‡§π‡§∞ ‡§Ü‡§ñ‡§É ‡§´‡•à‡§ï‡•ç‡§ü‡§∞ ‡§ó‡§∏‡§£ ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§è‡§Æ‡•ç ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§´‡•à‡§ï‡•ç‡§ü‡§∞‡§æ‡§á‡§ú‡•á‡§∂‡§® ‡§Æ‡§Ç‡§ú‡§º-- ‡§õ‡•Ç ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§Ü‡§∏‡§æ‡§® ‡§§‡•á‡§Æ ‡•Å‡§®‡•ç‡§¶‡§∏ ‡§∏‡•á‡§• ‡§Ø‡•Å‡§∏ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§õ‡•Ç ‡§§‡•á‡§Æ ‡§õ‡•Ç ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§Ü‡§∏‡§æ‡§®--  >>> factorize 8
--  [2,2,2]
--  >>> factorize 25
--  [5,5]
--  >>> factorize 70
--  [2,5,7]
factorize :: Int -> [Int]
factorize n =","factorize :: Int -> [Int]
factorize n = factorize' n 2
  where
    factorize' 1 _ = []
    factorize' m f
      | m `mod` f == 0 = f : factorize' (m `div` f) f
      | otherwise      = factorize' m (f + 1)","
main :: IO ()
main = do
  let candidate = factorize
  if candidate 2 == [2] then pure () else error ""assertion failed""
  if candidate 4 == [2,2] then pure () else error ""assertion failed""
  if candidate 8 == [2,2,2] then pure () else error ""assertion failed""
  if candidate 57 == [3,19] then pure () else error ""assertion failed""
  if candidate 3249 == [3,3,19,19] then pure () else error ""assertion failed""
  if candidate 185193 == [3,3,3,19,19,19] then pure () else error ""assertion failed""
  if candidate 20577 == [3,19,19,19] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_26,kas_Deva,hs,"--‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§õ‡•Ç ‡§¨‡§æ‡§Ø‡•á ‡§∂‡§æ‡§Æ‡•á ‡§á‡§®‡§™‡•Å‡§ü ‡§ï‡§ø ‡§§‡•à‡§∞ ‡§™‡§á‡§†.--‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º,‡§∏‡•Å ‡§õ‡•Ä ‡§∏‡•Å ‡§ö‡•Ä‡§ú‡§º ‡§¶‡•Ç‡§∞ ‡§ï‡§æ‡§∞‡§® ‡§Ø‡•Å‡§∏ ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§õ‡•Ä ‡§è‡§µ‡§Ç--  >>> removeDuplicates [1,2,3,2,4]
--  [1,3,4]
removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers =","removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers = filter (\x -> count x numbers == 1) numbers
  where
    count x = length . filter (== x)","
main :: IO ()
main = do
  let candidate = removeDuplicates
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error ""assertion failed""
  pure ()"
HumanEval_27,kas_Deva,hs,"-- ‡§ï‡•Å‡§®‡§ø ‡§¶‡§ø‡§∂‡§æ‡§®‡§ø ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§ñ‡§æ‡§§‡•ç‡§∞‡§ø, ‡§≤‡§ï‡•ç‡§ú‡§º‡§∞‡•Ä ‡§µ‡§∞‡•ç‡§£ ‡§¨‡§°‡§º‡§ø‡§Ø‡§æ‡§π‡§® ‡§§ ‡§¨‡§°‡§º‡§ø‡§Ø‡§æ‡§π‡§® ‡§≤‡§ï‡•ç‡§ú‡§º‡§∞‡•Ä‡§Ø‡§® ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§§‡§¨‡§¶‡•Ä‡§≤ ‡§ï‡§∞‡§æ‡§®‡•§--  >>> flipCase ""Hello""
--  ""hELLO""
flipCase :: String -> String
flipCase string =","flipCase :: String -> String
flipCase = map flipChar
  where
    flipChar c
      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)
      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)
      | otherwise = c","
main :: IO ()
main = do
  let candidate = flipCase
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hello!"" == ""hELLO!"" then pure () else error ""assertion failed""
  if candidate ""These violent delights have violent ends"" == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_28,kas_Deva,hs,"-- ‡§ï‡•â‡§®‡§ï‡•á‡§ü‡•á‡§®‡•á‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ë‡§´‡§º ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§á‡§® ‡§∏‡§ø‡§Ç‡§ó‡§≤ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó --  >>> concatenate []
--  """"
--  >>> concatenate [""a"",""b"",""c""]
--  ""abc""
concatenate :: [String] -> String
concatenate strings =","concatenate :: [String] -> String
concatenate strings = concat strings","
main :: IO ()
main = do
  let candidate = concatenate
  if candidate [] == """" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == ""xyz"" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z"",""w"",""k""] == ""xyzwk"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_29,kas_Deva,hs,"-- ‡§´‡§º‡§ø‡§≤‡•ç‡§ü‡§∞ ‡§á‡§®‡§™‡•Å‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ë‡§´‡§º ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§ì‡§®‡§≤‡•Ä ‡§´‡•â‡§∞ ‡§ì‡§®‡•á ‡§†‡§æ‡§ü ‡§¨‡•á a given ‡§™‡•ç‡§∞‡•Ä‡§´‡§ø‡§ï‡•ç‡§∏.--  >>> filterByPrefix [] ""a""
--  []
--  >>> filterByPrefix [""abc"",""bcd"",""cde"",""array""] ""a""
--  [""abc"",""array""]
filterByPrefix :: [String] -> String -> [String]
filterByPrefix strings prefix =","filterByPrefix strings prefix = filter (isPrefixOf prefix) strings
  where
    isPrefixOf pfx str = take (length pfx) str == pfx","
main :: IO ()
main = do
  let candidate = filterByPrefix
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_30,kas_Deva,hs,"--‡•á‡§Æ ‡§ï‡•ç‡§∞ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§®‡§Ç‡§¨‡§∞ ‡§µ‡§æ‡§™‡§∏.--  >>> getPositive [(-1),2,(-4),5,6]
--  [2,5,6]
--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  [5,3,2,3,9,123,1]
getPositive :: [Int] -> [Int]
getPositive l =","getPositive :: [Int] -> [Int]
getPositive l = filter (> 0) l","
main :: IO ()
main = do
  let candidate = getPositive
  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error ""assertion failed""
  if candidate [(-1),(-2)] == [] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_31,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§Ö‡§∏ ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ,‡§§‡§• ‡§õ‡•Ç ‡§Ø‡•á ‡§ü‡•ç‡§∞‡•Ç ,‡§¨‡•á ‡§Ö‡§∏‡•Ç‡§≤ ‡•Å‡§®‡•ç‡§¶ ‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§Ö‡§∏ ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ--  >>> isPrime 6
--  False
--  >>> isPrime 101
--  True
--  >>> isPrime 11
--  True
--  >>> isPrime 13441
--  True
--  >>> isPrime 61
--  True
--  >>> isPrime 4
--  False
--  >>> isPrime 1
--  False
isPrime :: Int -> Bool
isPrime n =","isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = not (any (\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","
main :: IO ()
main = do
  let candidate = isPrime
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 101 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 13441 == True then pure () else error ""assertion failed""
  if candidate 61 == True then pure () else error ""assertion failed""
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 1 == False then pure () else error ""assertion failed""
  if candidate 5 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 17 == True then pure () else error ""assertion failed""
  if candidate 85 == False then pure () else error ""assertion failed""
  if candidate 77 == False then pure () else error ""assertion failed""
  if candidate 255379 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_33,kas_Deva,hs,"--‡§£‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£--l' ‡§õ‡•Å ‡§§‡§ø‡§Æ‡§® ‡§á‡§Ç‡§°‡§ø‡§∏‡•á‡§Ø‡•ç‡§® ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§Ø‡§ø‡§Æ ‡§§‡•ç‡§∞‡•á‡§® ‡§π‡•ç‡§®‡§¶‡§ø ‡§¨‡§æ‡§ó‡§®‡§Ø ‡§Ø‡§ø‡§µ‡§æ‡§® ‡§õ‡§ø, ‡§Ø‡•á‡§≤‡§ø ‡§ú‡§º‡•ç‡§® ‡§§‡§ø‡§Æ‡•ç‡§® ‡§á‡§Ç‡§°‡§ø‡§∏‡•á‡§Ø‡•ç‡§® ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§Ø‡§ø‡§Æ ‡§§‡•ç‡§∞‡•á‡§® ‡§π‡•ç‡§®‡§¶‡§ø ‡§¨‡§æ‡§ó‡§®‡§Ø ‡§õ‡§ø ‡§§‡§ø‡§Æ‡•ç‡§® ‡§π‡•ç‡§®‡•ç‡§¶‡§ø ‡§µ‡§≤‡•ç‡§Ø‡•ã ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§õ‡§ø‡•§--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§Ö‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡§æ‡§∞‡§® ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§®--  >>> sortThird [1,2,3]
--  [1,2,3]
--  >>> sortThird [5,6,3,4,8,9,2]
--  [2,6,3,4,8,9,5]
sortThird :: [Int] -> [Int]
sortThird l =","sortThird :: [Int] -> [Int]
sortThird l = map selectElem indexed
  where
    indexed = zip [0..] l
    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]
    sortedThirdElems = sortedElems thirdIndicesElems
    sortedElems = id -- or List.sort if imported
    selectElem (i, x)
      | i `mod` 3 == 0 = head sortedThirdElems
      | otherwise = x
    replaceSortedElem xs sorted = map selectElem indexed
      where
        replaceElem i (x:xs)
          | i == 0 = x:xs
          | otherwise = replaceElem (i - 1) xs
        selectElem (i, x)
          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)
          | otherwise = x","
main :: IO ()
main = do
  let candidate = sortThird
  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error ""assertion failed""
  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error ""assertion failed""
  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error ""assertion failed""
  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_34,kas_Deva,hs,"--‡§§‡§Æ‡§ø ‡§µ‡§ø‡§ú‡§º‡§ø ‡§õ‡•Å ‡§Ø‡§ø ‡§≤‡§ø‡§∏‡§ü‡§∏ ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§´‡§º‡§∞‡§π‡§Æ ‡§ï‡§∞‡§® ‡§µ‡•â‡§≤ ‡§Ö‡§®‡§®‡•ç‡§Ø ‡§è‡§≤‡§ø‡§Æ‡•á‡§®‡§ü ‡§∞‡§¶‡§ø‡§´‡§º‡§§ ‡§ï‡§∞‡§æ‡§®‡•§--  >>> unique [5,3,5,2,3,3,9,0,123]
--  [0,2,3,5,9,123]
unique :: [Int] -> [Int]
unique l =","unique :: [Int] -> [Int]
unique l = sort $ nub l
  where
    -- | Remove duplicate elements from a list.
    nub :: (Eq a) => [a] -> [a]
    nub [] = []
    nub (x:xs) = x : nub (filter (/= x) xs)

    -- | Sort a list of elements (using QuickSort algorithm).
    sort :: (Ord a) => [a] -> [a]
    sort [] = []
    sort (x:xs) =
      let smallerSorted = sort [a | a <- xs, a <= x]
          biggerSorted = sort [a | a <- xs, a > x]
      in  smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = unique
  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error ""assertion failed""
  pure ()"
HumanEval_35,kas_Deva,hs,"--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà--  >>> maxElement [1,2,3]
--  3
--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  123
maxElement :: [Int] -> Int
maxElement l =","maxElement :: [Int] -> Int
maxElement [] = error ""List cannot be empty""
maxElement (x:xs) = maxElementHelper xs x
  where
    maxElementHelper [] currentMax = currentMax
    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","
main :: IO ()
main = do
  let candidate = maxElement
  if candidate [1,2,3] == 3 then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error ""assertion failed""
  pure ()"
HumanEval_36,kas_Deva,hs,"--üìå ‡§Ø‡•á ‡§õ‡•Ç ‡§á‡§Ç‡§ü‡•á‡§ó‡§∞‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§®‡§Ç‡§¨‡§∞ 7 ‡§π‡§ø‡§Ç‡§ú ‡§°‡§ø‡§µ‡§ø‡§ú‡§º‡§®‡§≤ ‡§®‡§Ç‡§¨‡§∞--  >>> fizzBuzz 50
--  0
--  >>> fizzBuzz 78
--  2
--  >>> fizzBuzz 79
--  3
fizzBuzz :: Int -> Int
fizzBuzz n =","fizzBuzz :: Int -> Int
fizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","
main :: IO ()
main = do
  let candidate = fizzBuzz
  if candidate 50 == 0 then pure () else error ""assertion failed""
  if candidate 78 == 2 then pure () else error ""assertion failed""
  if candidate 79 == 3 then pure () else error ""assertion failed""
  if candidate 100 == 3 then pure () else error ""assertion failed""
  if candidate 200 == 6 then pure () else error ""assertion failed""
  if candidate 4000 == 192 then pure () else error ""assertion failed""
  if candidate 10000 == 639 then pure () else error ""assertion failed""
  if candidate 100000 == 8026 then pure () else error ""assertion failed""
  pure ()"
HumanEval_37,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç ‡§õ‡•Ä ‡§á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡•Å‡§ö‡§®‡•á ‡§Ø‡•Å‡§∏ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡•á‡§Æ‡§® ‡§π‡§Ç‡§¶‡•ç‡§µ‡§∞ ,‡§≤‡§ï‡§ø‡§® ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§∏‡•â‡§∞‡•ç‡§ü ‡§ï‡§∞‡§®‡•á--l' ‡§õ‡•Å l ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§® ‡§π‡§ø‡§µ‡•á‡§®--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§Ö‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡§æ‡§∞‡§® ‡§µ‡§æ‡§™‡§∏--  >>> sortEven [1,2,3]
--  [1,2,3]
--  >>> sortEven [5,6,3,4]
--  [3,6,5,4]
sortEven :: [Int] -> [Int]
sortEven l =","sortEven :: [Int] -> [Int]
sortEven l = merge odds sortedEvens
  where
    (odds, evens) = partitionList l
    sortedEvens = sort evens

    partitionList :: [Int] -> ([Int], [Int])
    partitionList [] = ([], [])
    partitionList [x] = ([x], [])
    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)
      where
        (xsOdds, xsEvens) = partitionList xs

    merge :: [Int] -> [Int] -> [Int]
    merge [] ys = ys
    merge (x:xs) [] = x:xs
    merge (x:xs) (y:ys) = x:y:merge xs ys","
main :: IO ()
main = do
  let candidate = sortEven
  if candidate [1,2,3] == [1,2,3] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error ""assertion failed""
  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_39,kas_Deva,hs,"--prime_fib ‡§õ‡•Ä ‡§Ö‡§∏ ‡§¶‡•á‡§µ‡§® n -‡§• ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§Ø‡•Å‡§∏ ‡§´‡§ø‡§¨‡•ã‡§®‡•à‡§ï‡•Ä ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§õ‡•Ä ‡§¨‡•á ‡§õ‡•Ä ‡§Ø‡•á ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ--  >>> primeFib 1
--  2
--  >>> primeFib 2
--  3
--  >>> primeFib 3
--  5
--  >>> primeFib 4
--  13
--  >>> primeFib 5
--  89
primeFib :: Int -> Int
primeFib n =","primeFib :: Int -> Int
primeFib n = primeFibs !! (n - 1)
  where
    primeFibs = filter isPrime fibs
    fibs = map fst $ iterate (\(a, b) -> (b, a + b)) (0, 1)

isPrime :: Int -> Bool
isPrime k
  | k < 2 = False
  | k == 2 = True
  | even k = False
  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]
  where
    upperLimit = floor . sqrt $ fromIntegral k","
main :: IO ()
main = do
  let candidate = primeFib
  if candidate 1 == 2 then pure () else error ""assertion failed""
  if candidate 2 == 3 then pure () else error ""assertion failed""
  if candidate 3 == 5 then pure () else error ""assertion failed""
  if candidate 4 == 13 then pure () else error ""assertion failed""
  if candidate 5 == 89 then pure () else error ""assertion failed""
  if candidate 6 == 233 then pure () else error ""assertion failed""
  if candidate 7 == 1597 then pure () else error ""assertion failed""
  if candidate 8 == 28657 then pure () else error ""assertion failed""
  if candidate 9 == 514229 then pure () else error ""assertion failed""
  if candidate 10 == 433494437 then pure () else error ""assertion failed""
  pure ()"
HumanEval_40,kas_Deva,hs,"--‡§Ö‡§∏‡•Å‡§Æ ‡§õ‡•Ç ‡§ú‡•Ä‡§∞‡•ã,‡§§‡•á ‡§ó‡§≤‡§§ ‡§õ‡•Ç.--‡§Ö‡§ó‡§∞ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§§‡•ç‡§∞‡•á ‡§Ö‡§≤‡§ó ‡§Ö‡§≤‡§ó ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ --‡§ü‡•ç‡§∞‡§ø‡§™‡§≤‡§∏_‡§∏‡•Å‡§Æ_‡§ü‡•ã_‡§ú‡§º‡•á‡§∞‡•ã ‡§õ‡•Ä ‡§á‡§®‡•ç‡§™‡•Å‡§ü ‡§ï‡§æ‡§∞‡§® ‡§á‡§Ç‡§§‡•á‡§ú‡§∞‡§∏--  >>> triplesSumToZero [1,3,5,0]
--  False
--  >>> triplesSumToZero [1,3,(-2),1]
--  True
--  >>> triplesSumToZero [1,2,3,7]
--  False
--  >>> triplesSumToZero [2,4,(-5),3,9,7]
--  True
--  >>> triplesSumToZero [1]
--  False
triplesSumToZero :: [Int] -> Bool
triplesSumToZero l =","triplesSumToZero :: [Int] -> Bool
triplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]
  where
    tails [] = []
    tails xs@(_:xs') = xs : tails xs'","
main :: IO ()
main = do
  let candidate = triplesSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-1)] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [1,2,5,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,9,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-100)] == False then pure () else error ""assertion failed""
  if candidate [100,3,5,(-100)] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_41,kas_Deva,hs,"--‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§è‡§è‡§Æ ‡§ü‡§ï‡§∞‡§æ‡§µ‡§® ‡§π‡§ø‡§®‡•ç‡§¶ ‡§§‡•à‡§∞ ‡§™‡§á‡§† ‡§®‡§Ç‡§¨‡§∞ ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§ï‡§∞‡§æ.--‡§Ø‡•á ‡§õ‡•Ç ‡§è‡§è‡§Æ‡§µ ‡§∏‡§ø‡§Ç‡§ú ‡§ü‡•ç‡§∞‡•á‡§ú‡•á‡§ï‡•ç‡§ü‡§∞‡•Ä ‡§Æ‡§Ç‡§ú‡§º ‡§ê‡§∏‡•á ‡§≤‡§¨‡§®‡•Ä ‡§Ø‡•á‡§µ‡§æ ‡§Ø‡•á‡§• ‡§™‡§á‡§† ‡§Ö‡§ó‡§∞ ‡§§‡•á‡§Æ ‡§Ü‡§™‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ü‡§ï‡§∞‡§æ‡§µ ‡§®‡•á ‡§ï‡§æ‡§∞‡§®.--‡§§‡§æ‡§π‡§Æ, ‡§ï‡§æ‡§∞ ‡§õ‡§ø ‡§á‡§®‡§´‡§ø‡§®‡§ø‡§ü‡•Ä ‡§Æ‡§ú‡§º‡§¨‡•Ç‡§§ ‡§§ ‡§Æ‡§ú‡§º‡§¨‡•Ç‡§§; ‡§®‡§§‡•Ä‡§ú‡§§‡§®, ‡§§‡§ø‡§Æ ‡§õ‡§ø ‡§≤‡§ó‡§æ‡§§‡§æ‡§∞ ‡§ö‡§≤‡§æ‡§®‡•§--‡§Ø‡•á‡§≤‡§ø ‡§Ö‡§ñ ‡§ï‡§æ‡§∞ ‡§Ø‡•Å‡§∏ ‡§¨‡§æ‡§Ø‡•á ‡§¶‡§æ‡§µ‡•Å‡§® ‡§∞‡§ü‡§® ‡§Ü‡§∏‡§ø ‡§Ö‡§ñ ‡§ï‡§æ‡§∞ ‡§Ø‡•Å‡§∏ ‡§¶‡§æ‡§µ‡•Å‡§® ‡§∞‡§ü‡§® ‡§Ü‡§∏‡§ø‡•§--‡§Ö‡§ñ ‡§Ö‡§ï‡§ø‡§∏ ‡§∏‡•á‡§§. ‡§§‡§Æ‡§æ‡§Æ ‡§ï‡§æ‡§∞ ‡§õ‡•Ç ‡§Ö‡§ï‡§ø‡§∏ ‡§∏‡•ç‡§™‡•Ä‡§° ‡§∏‡•á‡§§ ‡§∞‡§ü‡§®. ‡§¶‡•Ç‡§Å ‡§ï‡§æ‡§∞‡•á‡§Ç ‡§õ‡•Ç ‡§ü‡§ï‡§∞‡§æ‡§µ‡§®.--‡§¶‡•ã‡§Ø‡•ã ‡§Æ‡•Å‡§ï‡§º‡§æ‡§Æ ‡§ï‡§æ‡§∞‡•ã ‡§∂‡•Å‡§∞‡•Ç ‡§õ‡•Ç ‡§µ‡§∞‡§ø‡§Ø‡•á ‡§¶‡•Ç‡§∞ ‡§æ‡§ï‡§ø‡§∏ ‡§Æ‡•Å‡§ï‡§º‡§æ‡§Æ ‡§∏‡•á‡§§.--n ‡§ï‡§æ‡§∞‡•ç‡§∏ ‡§õ‡§ø ‡§¨‡§æ‡§Æ ‡§™‡•á‡§† ‡§¶‡§æ‡§µ‡•Å‡§® ‡§ö‡§≤‡§æ‡§µ‡§® ‡§Ø‡§ø‡§µ‡§æ‡§®; ‡§Ö‡§ï‡§ø‡§∏ ‡§µ‡§ñ‡§§‡§∏ ‡§™‡•á‡§†, n ‡§ï‡§æ‡§∞‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§Ö‡§ñ ‡§Æ‡•Å‡§ñ‡§§‡§≤‡§ø‡§´ ‡§∏‡•á‡§ü‡•§--‚ùñ ‡§§‡§ú‡§µ‡•Ä‡§ú‡§º ‡§ï‡§∞‡•ã ‡§ï‡§ø ‡§Ö‡§ñ ‡§∞‡•ã‡§° ‡§Ö‡§ñ ‡§Æ‡•Å‡§ï‡§Æ‡§≤ ‡§∏‡•Ä‡§ß‡•Ä ‡§≤‡§æ‡§Ç‡§¨‡•Ä ‡§π‡§ø‡§®‡•ç‡§¶‡•á‡§® ‡§≤‡§æ‡§á‡§®‡§® ‡§π‡§ø‡§Ç‡§ú.carRaceCollision :: Int -> Int
carRaceCollision n =","carRaceCollision :: Int -> Int
carRaceCollision n = n","
main :: IO ()
main = do
  let candidate = carRaceCollision
  if candidate 2 == 4 then pure () else error ""assertion failed""
  if candidate 3 == 9 then pure () else error ""assertion failed""
  if candidate 4 == 16 then pure () else error ""assertion failed""
  if candidate 8 == 64 then pure () else error ""assertion failed""
  if candidate 10 == 100 then pure () else error ""assertion failed""
  pure ()"
HumanEval_42,kas_Deva,hs,"--‚û°Ô∏è1 ‡§∏‡•á ‡§¨‡§¢‡§º‡§ï‡§∞ ‡§Ü‡§∏‡§æ‡§® ‡§ö‡•Ä‡§ú‡§º‡•á‡§Ç ‚û°Ô∏è--  >>> incrList [1,2,3]
--  [2,3,4]
--  >>> incrList [5,3,5,2,3,3,9,0,123]
--  [6,4,6,3,4,4,10,1,124]
incrList :: [Int] -> [Int]
incrList l =","incrList :: [Int] -> [Int]
incrList l = map (+1) l","
main :: IO ()
main = do
  let candidate = incrList
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [4,3,2] then pure () else error ""assertion failed""
  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error ""assertion failed""
  pure ()"
HumanEval_43,kas_Deva,hs,"--‡§Ö‡§∏‡•Å‡§Æ ‡§õ‡•Ç ‡§ú‡•Ä‡§∞‡•ã,‡§§‡•á ‡§ó‡§≤‡§§ ‡§õ‡•Ç.--‡§Ö‡§ó‡§∞ ‡•á‡§Æ‡•Å‡§ï ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§ú‡§º‡•á ‡§Ö‡§≤‡§ó ‡§Ö‡§≤‡§ó ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§Ü‡§∏‡§æ‡§® ‡§§‡•á‡§Æ ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§∞‡§æ--pairs_sum_to_zero ‡§õ‡•Ä ‡§á‡§®‡•ç‡§™‡•Å‡§ü ‡§ï‡§æ‡§∞‡§® ‡§á‡§Ç‡§§‡•á‡§ú‡§∞‡§∏--  >>> pairsSumToZero [1,3,5,0]
--  False
--  >>> pairsSumToZero [1,3,(-2),1]
--  False
--  >>> pairsSumToZero [1,2,3,7]
--  False
--  >>> pairsSumToZero [2,4,(-5),3,5,7]
--  True
--  >>> pairsSumToZero [1]
--  False
pairsSumToZero :: [Int] -> Bool
pairsSumToZero l =","pairsSumToZero :: [Int] -> Bool
pairsSumToZero l = any (\x -> -x `elem` l) l && (length l > 1)","
main :: IO ()
main = do
  let candidate = pairsSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,5,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_44,kas_Deva,hs,"--‡§¨‡•á‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§≤‡•á‡§∏‡•ç‡§∏ 10 --‡§§‡§¨, ‡§§‡§¨, ‡§§‡§¨, ‡§§‡§¨, ‡§§‡§¨, ‡§§‡§¨--‡•á‡§Æ ‡§ï‡•ç‡§∞ ‡§á‡§®‡§™‡•Å‡§ü ‡§®‡§Ç‡§¨‡§∞ X ‡§π‡§ø‡§Ç‡§ú ‡§®‡•Å‡§Æ‡§æ‡§∞‡§ø‡§ï‡§æ‡§≤ ‡§¨‡•á‡§∏ ‡§§‡•á ‡§¨‡•á‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§§‡§¨‡•ç‡§¶‡•Ä‡§≤.--  >>> changeBase 8 3
--  ""22""
--  >>> changeBase 8 2
--  ""1000""
--  >>> changeBase 7 2
--  ""111""
changeBase :: Int -> Int -> String
changeBase x base =","changeBase :: Int -> Int -> String
changeBase x base
  | x < base  = show x
  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","
main :: IO ()
main = do
  let candidate = changeBase
  if candidate 8 3 == ""22"" then pure () else error ""assertion failed""
  if candidate 9 3 == ""100"" then pure () else error ""assertion failed""
  if candidate 234 2 == ""11101010"" then pure () else error ""assertion failed""
  if candidate 16 2 == ""10000"" then pure () else error ""assertion failed""
  if candidate 8 2 == ""1000"" then pure () else error ""assertion failed""
  if candidate 7 2 == ""111"" then pure () else error ""assertion failed""
  if candidate 2 3 == ""2"" then pure () else error ""assertion failed""
  if candidate 3 4 == ""3"" then pure () else error ""assertion failed""
  if candidate 4 5 == ""4"" then pure () else error ""assertion failed""
  if candidate 5 6 == ""5"" then pure () else error ""assertion failed""
  if candidate 6 7 == ""6"" then pure () else error ""assertion failed""
  if candidate 7 8 == ""7"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_45,kas_Deva,hs,"------- ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§≤‡§Ç‡§¨‡§® ‡§õ‡•Ç--  >>> triangleArea 5 3
--  7.5
triangleArea :: Int -> Int -> Float
triangleArea a h =","triangleArea :: Int -> Int -> Float
triangleArea a h = 0.5 * fromIntegral a * fromIntegral h","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 5 3 == 7.5 then pure () else error ""assertion failed""
  if candidate 2 2 == 2.0 then pure () else error ""assertion failed""
  if candidate 10 8 == 40.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_46,kas_Deva,hs,"--‡§™‡•ç‡§≤‡•Ä‡§ú‡§º ‡§≤‡•á‡§ñ‡•Å‡§ñ ‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§§‡§æ‡§ï‡§ø ‡§Ö‡§∏ ‡§π‡§ï‡•ã ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡§ø‡§• n-‡§• ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü fib4 ‡§®‡•Å‡§Æ‡§æ‡§∞‡§ø‡§ï ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏‡•Å‡§ï. --fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --‡§Ø‡•Å‡§∏ Fib4 ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§∏‡§ø‡§Æ‡§ø‡§≤‡§∞ ‡§´‡§ø‡§¨‡•ã‡§®‡•à‡§ï‡•Ä ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§Ø‡•Å‡§∏ ‡§°‡§ø‡§´‡§æ‡§á‡§® ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§ï‡§∞‡§®‡•á--  >>> fib4 5
--  4
--  >>> fib4 6
--  8
--  >>> fib4 7
--  14
fib4 :: Int -> Int
fib4 n =","fib4 :: Int -> Int
fib4 n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 2
  | n == 3 = 0
  | otherwise = iter 0 0 2 0 n
  where
    iter a b c d 4 = a + b + c + d
    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","
main :: IO ()
main = do
  let candidate = fib4
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 28 then pure () else error ""assertion failed""
  if candidate 10 == 104 then pure () else error ""assertion failed""
  if candidate 12 == 386 then pure () else error ""assertion failed""
  pure ()"
HumanEval_47,kas_Deva,hs,"--l ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§® ‡§õ‡•Ç ‡§µ‡§æ‡§™‡§ø‡§∏ ‡§è‡§µ‡§Ç.--  >>> median [3,1,2,4,5]
--  3.0
--  >>> median [(-10),4,6,1000,10,20]
--  15.0
median :: [Int] -> Float
median l =","median :: [Int] -> Float
median l 
  | odd n     = fromIntegral $ sorted !! mid
  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) / 2
  where
    sorted = sort l
    n = length l
    mid = n `div` 2
    sort = sortBy compare","
main :: IO ()
main = do
  let candidate = median
  if candidate [3,1,2,4,5] == 3.0 then pure () else error ""assertion failed""
  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error ""assertion failed""
  if candidate [5] == 5.0 then pure () else error ""assertion failed""
  if candidate [6,5] == 5.5 then pure () else error ""assertion failed""
  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_48,kas_Deva,hs,"--‡•á‡§Æ ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§ö‡•á‡§ï ‡§ï‡•Ä ‡§Ø‡•Å‡§∏ ‡§¶‡•á‡§µ‡§® ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§∏‡•Å ‡§õ‡•Ä ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ--  >>> isPalindrome """"
--  True
--  >>> isPalindrome ""aba""
--  True
--  >>> isPalindrome ""aaaaa""
--  True
--  >>> isPalindrome ""zbcd""
--  False
isPalindrome :: String -> Bool
isPalindrome text =","isPalindrome :: String -> Bool
isPalindrome text = text == reverse text","
main :: IO ()
main = do
  let candidate = isPalindrome
  if candidate """" == True then pure () else error ""assertion failed""
  if candidate ""aba"" == True then pure () else error ""assertion failed""
  if candidate ""aaaaa"" == True then pure () else error ""assertion failed""
  if candidate ""zbcd"" == False then pure () else error ""assertion failed""
  if candidate ""xywyx"" == True then pure () else error ""assertion failed""
  if candidate ""xywyz"" == False then pure () else error ""assertion failed""
  if candidate ""xywzx"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_49,kas_Deva,hs,"--‡•á‡§ï‡§∂‡§® ‡§õ‡•Ç 2^n ‡§Æ‡•â‡§°‡•Å‡§≤‡•ã p (‡§®‡§Ç‡§¨‡§∞‡§ø‡§ï‡§∏ ‡§õ‡•Ç ‡§µ‡§æ‡§®‡§®).--  >>> modp 3 5
--  3
--  >>> modp 1101 101
--  2
--  >>> modp 0 101
--  1
--  >>> modp 3 11
--  8
--  >>> modp 100 101
--  1
modp :: Int -> Int -> Int
modp n p =","modp :: Int -> Int -> Int
modp n p = powMod 2 n p

powMod :: Int -> Int -> Int -> Int
powMod base exp modulus
  | modulus == 1 = 0
  | exp == 0     = 1
  | exp == 1     = base `mod` modulus
  | otherwise    = if odd exp
                   then (base * halfExp * halfExp) `mod` modulus
                   else (halfExp * halfExp) `mod` modulus
  where
    halfExp = powMod base (exp `div` 2) modulus","
main :: IO ()
main = do
  let candidate = modp
  if candidate 3 5 == 3 then pure () else error ""assertion failed""
  if candidate 1101 101 == 2 then pure () else error ""assertion failed""
  if candidate 0 101 == 1 then pure () else error ""assertion failed""
  if candidate 3 11 == 8 then pure () else error ""assertion failed""
  if candidate 100 101 == 1 then pure () else error ""assertion failed""
  if candidate 30 5 == 4 then pure () else error ""assertion failed""
  if candidate 31 5 == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_51,kas_Deva,hs,"--remove_vowels ‡§õ‡•Å ‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§Ø‡•Å‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§≤‡§ø‡§õ ‡§§ ‡§∏‡•Å ‡§õ‡•Å ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§æ‡§® ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§¨‡§ó‡•à‡§∞ ‡§µ‡•ã‡§≤‡•ç‡§µ‡§®‡•§--  >>> removeVowels """"
--  """"
--  >>> removeVowels ""abcdef""
--  ""bcdf""
--  >>> removeVowels ""aaaaa""
--  """"
--  >>> removeVowels ""aaBAA""
--  ""B""
--  >>> removeVowels ""zbcd""
--  ""zbcd""
removeVowels :: String -> String
removeVowels text =","removeVowels :: String -> String
removeVowels text = filter (`notElem` ""aeiouAEIOU"") text","
main :: IO ()
main = do
  let candidate = removeVowels
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""abcdef
ghijklm"" == ""bcdf
ghjklm"" then pure () else error ""assertion failed""
  if candidate ""fedcba"" == ""fdcb"" then pure () else error ""assertion failed""
  if candidate ""eeeee"" == """" then pure () else error ""assertion failed""
  if candidate ""acBAA"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""EcBOO"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""ybcd"" == ""ybcd"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_52,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§∏‡§π‡•Ä ‡§õ‡•Ç ‡§∏‡•Å ‡§õ‡•Ç ‡§µ‡§æ‡§™‡§ø‡§∏ ‡§ï‡§æ‡§∞‡§® ‡§Ö‡§ó‡§∞ ‡§∏‡§≤‡•Ä‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Ç‡§¶ ‡§•‡•ç‡§∞‡•á‡§∏‡§π‡•ã‡§≤‡•ç‡§° t ‡§™‡•á‡§†--  >>> belowThreshold [1,2,4,10] 100
--  True
--  >>> belowThreshold [1,20,4,10] 5
--  False
belowThreshold :: [Int] -> Int -> Bool
belowThreshold l t =",belowThreshold l t = all (< t) l,"
main :: IO ()
main = do
  let candidate = belowThreshold
  if candidate [1,2,4,10] 100 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 5 == False then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 21 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 22 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 11 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_53,kas_Deva,hs,"--X ‡§§‡•á Y ‡§§‡•á‡§Æ‡§ú ‡§¶‡•Å‡§®‡§µ‡§à ‡§®‡§Ç‡§¨‡§∞ ‡§ú‡§Æ‡§æ ‡§ï‡§∞‡§®‡•á--  >>> add 2 3
--  5
--  >>> add 5 7
--  12
add :: Int -> Int -> Int
add x y =","add :: Int -> Int -> Int
add x y = x + y","
main :: IO ()
main = do
  let candidate = add
  if candidate 0 1 == 1 then pure () else error ""assertion failed""
  if candidate 1 0 == 1 then pure () else error ""assertion failed""
  if candidate 2 3 == 5 then pure () else error ""assertion failed""
  if candidate 5 7 == 12 then pure () else error ""assertion failed""
  if candidate 7 5 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_54,kas_Deva,hs,"--‚û°Ô∏è‡§ö‡•á‡§ï ‡§ï‡§∞‡•ã ‡§Ö‡§ó‡§∞ ‡§¶‡•ã‡§®‡•ã ‡§≤‡§´‡•ç‡§ú‡•ã ‡§Æ‡•á ‡§è‡§ï‡§∏‡§Æ‡§æ‡§® ‡§Ö‡§ï‡•ç‡§∑‡§∞ ‡§π‡•ã.--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc""
--  True
--  >>> sameChars ""abcd"" ""dddddddabc""
--  True
--  >>> sameChars ""dddddddabc"" ""abcd""
--  True
--  >>> sameChars ""eabcd"" ""dddddddabc""
--  False
--  >>> sameChars ""abcd"" ""dddddddabce""
--  False
--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc""
--  False
sameChars :: String -> String -> Bool
sameChars s0 s1 =","import Data.List (nub, sort)

sameChars :: String -> String -> Bool
sameChars s0 s1 = sort (nub s0) == sort (nub s1)","
main :: IO ()
main = do
  let candidate = sameChars
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddeddabc"" == True then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabc"" == True then pure () else error ""assertion failed""
  if candidate ""dddddddabc"" ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""eabcd"" ""dddddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabcf"" == False then pure () else error ""assertion failed""
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""aabb"" ""aaccc"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_55,kas_Deva,hs,"--‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è ‚û°Ô∏è--  >>> fib 10
--  55
--  >>> fib 1
--  1
--  >>> fib 8
--  21
fib :: Int -> Int
fib n =","fib :: Int -> Int
fib n = fibHelper 0 1 n
  where
    fibHelper a _ 0 = a
    fibHelper a b n = fibHelper b (a + b) (n - 1)","
main :: IO ()
main = do
  let candidate = fib
  if candidate 10 == 55 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 8 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 89 then pure () else error ""assertion failed""
  if candidate 12 == 144 then pure () else error ""assertion failed""
  pure ()"
HumanEval_56,kas_Deva,hs,"--return ‡§ü‡•ç‡§∞‡•Ç ‡§Ö‡§ó‡§∞ ‡§π‡§∞ ‡§ì‡§™‡§®‡§ø‡§Ç‡§ó ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§§ ‡§¨‡•à ‡§ï‡§∞‡•â‡§∏‡•ç‡§™‡•â‡§®‡•ç‡§°‡•á‡§Ç‡§ü ‡§ï‡•ç‡§≤‡•ã‡§ú‡§ø‡§Ç‡§ó ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü--‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü‡•ç‡§∏ ‡§õ‡•Ç ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ""<"" ‡§§‡•á "">"".--  >>> correctBracketing ""<""
--  False
--  >>> correctBracketing ""<>""
--  True
--  >>> correctBracketing ""<<><>>""
--  True
--  >>> correctBracketing ""><<>""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBrackets brackets 0 == 0

checkBrackets :: String -> Int -> Int
checkBrackets [] n = n
checkBrackets (x:xs) n
  | n < 0 = -1
  | x == '<' = checkBrackets xs (n + 1)
  | x == '>' = checkBrackets xs (n - 1)
  | otherwise = checkBrackets xs n","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""<>"" == True then pure () else error ""assertion failed""
  if candidate ""<<><>>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<<><><>><>><<><><<>>>"" == True then pure () else error ""assertion failed""
  if candidate ""<<<><>>>>"" == False then pure () else error ""assertion failed""
  if candidate ""><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<"" == False then pure () else error ""assertion failed""
  if candidate ""<<<<"" == False then pure () else error ""assertion failed""
  if candidate "">"" == False then pure () else error ""assertion failed""
  if candidate ""<<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>>><>"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_57,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§õ‡•Ç ‡§∏‡•Å ‡§õ‡•Ç ‡§è‡§µ‡§Ç ‡§Æ‡•ã‡§®‡•ã‡§ü‡•ã‡§®‡§ø‡§ï‡§≤‡•Ä ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§¨‡§¢‡§º‡§æ‡§µ ‡§Ø‡§æ ‡§ï‡§Æ ‡§ï‡§∞‡•Ç‡§Å--  >>> monotonic [1,2,4,20]
--  True
--  >>> monotonic [1,20,4,10]
--  False
--  >>> monotonic [4,1,0,(-10)]
--  True
monotonic :: [Int] -> Bool
monotonic l =","monotonic :: [Int] -> Bool
monotonic l = increasing l || decreasing l
  where
    increasing xs = all (uncurry (<=)) (zip xs (tail xs))
    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","
main :: IO ()
main = do
  let candidate = monotonic
  if candidate [1,2,4,10] == True then pure () else error ""assertion failed""
  if candidate [1,2,4,20] == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] == False then pure () else error ""assertion failed""
  if candidate [4,1,0,(-10)] == True then pure () else error ""assertion failed""
  if candidate [4,1,1,0] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,2,5,60] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,60] == True then pure () else error ""assertion failed""
  if candidate [9,9,9,9] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_58,kas_Deva,hs,"--‡•á‡§ï ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§õ‡•Ç ‡§¶‡•Å‡§®‡§µ‡§à ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§Æ‡§ï‡§∏‡§¶ ‡§ï‡§æ‡§∞‡§®.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]
--  [1,5,653]
--  >>> common [5,3,2,8] [3,2]
--  [2,3]
common :: [Int] -> [Int] -> [Int]
common l1 l2 =","common :: [Int] -> [Int] -> [Int]
common l1 l2 = uniqueSortedCommon
  where
    commonElements = filter (`elem` l2) l1
    uniqueCommon = removeDuplicates commonElements
    uniqueSortedCommon = sort uniqueCommon

    removeDuplicates :: [Int] -> [Int]
    removeDuplicates = foldr (\x seen -> if x `elem` seen then seen else x : seen) []

    sort :: [Int] -> [Int]
    sort [] = []
    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)
      where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs","
main :: IO ()
main = do
  let candidate = common
  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error ""assertion failed""
  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_59,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§∏‡§∞‡§ø‡§Ø‡•ã ‡§ñ‡•ã‡§§ ‡§¨‡•Å‡§° ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§´‡•à‡§ï‡•ç‡§ü‡§∞ ‡§õ‡•Ç ‡§∏‡•Å ‡§õ‡•Ç ‡§è‡§µ‡§Ç ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§®--  >>> largestPrimeFactor 13195
--  29
--  >>> largestPrimeFactor 2048
--  2
largestPrimeFactor :: Int -> Int
largestPrimeFactor n =","largestPrimeFactor :: Int -> Int
largestPrimeFactor n = helper n 2
  where
    helper n factor
      | factor * factor > n = n
      | n `mod` factor == 0 = helper (n `div` factor) factor
      | otherwise = helper n (factor + 1)","
main :: IO ()
main = do
  let candidate = largestPrimeFactor
  if candidate 15 == 5 then pure () else error ""assertion failed""
  if candidate 27 == 3 then pure () else error ""assertion failed""
  if candidate 63 == 7 then pure () else error ""assertion failed""
  if candidate 330 == 11 then pure () else error ""assertion failed""
  if candidate 13195 == 29 then pure () else error ""assertion failed""
  pure ()"
HumanEval_60,kas_Deva,hs,"--sum_to_n ‡§õ‡•Ç ‡§Ü‡§Å‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å‡§Æ‡•ç‡§Æ ‡§ï‡§æ‡§∞‡§® 1 ‡§™‡•á‡§† n ‡§§‡§æ‡§Æ--  >>> sumToN 30
--  465
--  >>> sumToN 100
--  5050
--  >>> sumToN 5
--  15
--  >>> sumToN 10
--  55
--  >>> sumToN 1
--  1
sumToN :: Int -> Int
sumToN n =","sumToN :: Int -> Int
sumToN n = sum [1..n]","
main :: IO ()
main = do
  let candidate = sumToN
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 66 then pure () else error ""assertion failed""
  if candidate 30 == 465 then pure () else error ""assertion failed""
  if candidate 100 == 5050 then pure () else error ""assertion failed""
  pure ()"
HumanEval_61,kas_Deva,hs,"--return ‡§ü‡•ç‡§∞‡•Ç ‡§Ö‡§ó‡§∞ ‡§π‡§∞ ‡§ì‡§™‡§®‡§ø‡§Ç‡§ó ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§§ ‡§¨‡•à ‡§ï‡§∞‡•â‡§∏‡•ç‡§™‡•â‡§®‡•ç‡§°‡•á‡§Ç‡§ü ‡§ï‡•ç‡§≤‡•ã‡§ú‡§ø‡§Ç‡§ó ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü--‡§Ø‡•Å‡§∏ ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó "" (_) "" ‡§¨‡•á ""_) ""--  >>> correctBracketing ""(""
--  False
--  >>> correctBracketing ""()""
--  True
--  >>> correctBracketing ""(()())""
--  True
--  >>> correctBracketing "")(()""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBalance brackets 0
  where
    checkBalance [] 0 = True
    checkBalance [] _ = False
    checkBalance (x:xs) n
      | x == '('  = checkBalance xs (n + 1)
      | x == ')' && n > 0 = checkBalance xs (n - 1)
      | otherwise = False","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""()"" == True then pure () else error ""assertion failed""
  if candidate ""(()())"" == True then pure () else error ""assertion failed""
  if candidate ""()()(()())()"" == True then pure () else error ""assertion failed""
  if candidate ""()()((()()())())(()()(()))"" == True then pure () else error ""assertion failed""
  if candidate ""((()())))"" == False then pure () else error ""assertion failed""
  if candidate "")(()"" == False then pure () else error ""assertion failed""
  if candidate ""("" == False then pure () else error ""assertion failed""
  if candidate ""(((("" == False then pure () else error ""assertion failed""
  if candidate "")"" == False then pure () else error ""assertion failed""
  if candidate ""(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())())(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())()))()"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_62,kas_Deva,hs,"--‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§™‡•ã‡§≤‡•Ä‡§®‡•ã‡§Æ‡§ø‡§Ö‡§≤ ‡§°‡•á‡§∞‡•Ä‡§µ‡•á‡§ü‡§ø‡§µ‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§§‡•á‡§Æ‡§® ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§Ç ‡§Æ‡§Ç‡§ú‡§º--xs[0] + xs[1] * x + xs[2] * x^2 + .... --Xs ‡§õ‡•Ç ‡§ï‡•Å‡§° ‡§™‡•ã‡§≤‡•Ä‡§®‡•ã‡§Æ‡§ø‡§Ö‡§≤ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§ï‡•ã‡§è‡§´‡§º‡§ø‡§∂‡§ø‡§è‡§Ç‡§ü.--  >>> derivative [3,1,2,4,5]
--  [1,4,12,20]
--  >>> derivative [1,2,3]
--  [2,6]
derivative :: [Int] -> [Int]
derivative xs =","derivative :: [Int] -> [Int]
derivative xs = zipWith (*) (tail xs) [1..]","
main :: IO ()
main = do
  let candidate = derivative
  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,6] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [2,2] then pure () else error ""assertion failed""
  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error ""assertion failed""
  if candidate [1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_63,kas_Deva,hs,"--‡§™‡•ç‡§≤‡•Ä‡§ú‡§º ‡§≤‡•á‡§ñ‡•Å‡§ñ ‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§§‡§æ‡§ï‡§ø ‡§Ö‡§∏ ‡§π‡§ï‡•ã ‡§ï‡§æ‡§Æ‡§Ø‡§• ‡§è‡§®-‡§• ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§ë‡§´‡§º ‡§´‡§ø‡§¨‡§´‡§ø‡§¨ ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏--fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). --fib fib ((2) == 1 --fib fib ((1) == 0 --fib fibf ((0) == 0 --‡§Ø‡•Å‡§∏ ‡§´‡§ø‡§¨‡§´‡§ø‡§¨ ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§∏‡§ø‡§Æ‡§ø‡§≤‡§∞ ‡§´‡§ø‡§¨‡•ã‡§®‡•à‡§ï‡•Ä ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§Ø‡•Å‡§∏ ‡§°‡§ø‡§´‡§æ‡§á‡§® ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§ï‡§∞‡§®‡•á--  >>> fibfib 1
--  0
--  >>> fibfib 5
--  4
--  >>> fibfib 8
--  24
fibfib :: Int -> Int
fibfib n =","fibfib :: Int -> Int
fibfib n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 1
  | otherwise = fibs !! n
  where
    fibs = 0 : 0 : 1 : zipWith3 (\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","
main :: IO ()
main = do
  let candidate = fibfib
  if candidate 2 == 1 then pure () else error ""assertion failed""
  if candidate 1 == 0 then pure () else error ""assertion failed""
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 24 then pure () else error ""assertion failed""
  if candidate 10 == 81 then pure () else error ""assertion failed""
  if candidate 12 == 274 then pure () else error ""assertion failed""
  if candidate 14 == 927 then pure () else error ""assertion failed""
  pure ()"
HumanEval_64,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§µ‡•ã‡§ï‡§≤ ,‡§≤‡§ï‡§ø‡§® ‡§Ø‡•á ‡§õ‡•Ç ‡§è‡§µ‡§Ç ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§Ø‡§ø‡§≤ ‡§Ø‡•á ‡§≤‡§´‡§º‡§ú‡§º‡•á ‡§π‡§ø‡§®‡•ç‡§¶ ‡§Ü‡§ñ‡§ø‡§∞‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç--‡§Ö‡§Æ‡§ø ‡§Æ‡§æ‡§Æ‡§≤‡§æ‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡§ø ‡§∏‡•ç‡§µ‡§∞ '‡§Ö', '‡§à', '‡§Ü‡§à', '‡§ì', '‡§Ø‡•Ç' ‡§Ø‡§ø‡§•‡•ç‡§ï‡•á‡§• '‡§Ø' ‡§§‡§ø ‡§õ‡•Å ‡§Ö‡•§--‡§£‡§£‡§£ ‡§£‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£--‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•á ‡§Ø‡•Å‡§∏ --  >>> vowelsCount ""abcde""
--  2
--  >>> vowelsCount ""ACEDY""
--  3
vowelsCount :: String -> Int
vowelsCount s =","vowelsCount :: String -> Int
vowelsCount s = length $ filter isVowel $ zip s [1..]
  where
    isVowel (c, pos) =
      let lowercaseC = toLower c
          isRegularVowel = lowercaseC `elem` ""aeiou""
          isLastCharY = lowercaseC == 'y' && pos == length s
      in isRegularVowel || isLastCharY","
main :: IO ()
main = do
  let candidate = vowelsCount
  if candidate ""abcde"" == 2 then pure () else error ""assertion failed""
  if candidate ""Alone"" == 3 then pure () else error ""assertion failed""
  if candidate ""key"" == 2 then pure () else error ""assertion failed""
  if candidate ""bye"" == 1 then pure () else error ""assertion failed""
  if candidate ""keY"" == 2 then pure () else error ""assertion failed""
  if candidate ""bYe"" == 1 then pure () else error ""assertion failed""
  if candidate ""ACEDY"" == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_65,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ ‡§∂‡§ø‡§´‡•ç‡§ü > ‡§°‡§ø‡§ú‡§ø‡§ü‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§®‡§Ç‡§¨‡§∞, ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§°‡§ø‡§ú‡§ø‡§ü‡§∏ ‡§á‡§®‡§µ‡§∞‡•ç‡§∏‡§°.--‡§£‡•Ç‡§á‡§ï ‡§ï‡•ç‡§∏‡§ø‡§ì‡§®‡§°‡§∏ ‡§Ö‡§∏-- Circular shift the digits of the integer x, shift the digits right by shift  ‡§∏‡§∞‡•ç‡§ï‡•Å‡§≤‡§∞ ‡§∂‡§ø‡§´‡•ç‡§ü ‡§á‡§Ç‡§ü‡§ø‡§ú‡§∞ ‡§è‡§ï‡•ç‡§∏, ‡§°‡§ø‡§ú‡§ø‡§ü ‡§∞‡§æ‡§á‡§ü ‡§¨‡§æ‡§Ø ‡§∂‡§ø‡§´‡•ç‡§ü --  >>> circularShift 12 1
--  ""21""
--  >>> circularShift 12 2
--  ""12""
circularShift :: Int -> Int -> String
circularShift x shift =","circularShift :: Int -> Int -> String
circularShift x shift =
  let digits = show x
      len = length digits
      effectiveShift = shift `mod` len
  in if shift > len
     then reverse digits
     else let (begin, end) = splitAt (len - effectiveShift) digits
          in end ++ begin","
main :: IO ()
main = do
  let candidate = circularShift
  if candidate 100 2 == ""001"" then pure () else error ""assertion failed""
  if candidate 12 2 == ""12"" then pure () else error ""assertion failed""
  if candidate 97 8 == ""79"" then pure () else error ""assertion failed""
  if candidate 12 1 == ""21"" then pure () else error ""assertion failed""
  if candidate 11 101 == ""11"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_66,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --ASCII ‡§ï‡•ã‡§°‡•ç‡§∏.--‡§≤‡§ø‡§ñ‡•á‡§Ç ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§ï‡§æ‡§∞‡§® ‡§á‡§®‡§™‡•Å‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§¨‡•á ‡§õ‡•Ä ‡§∏‡•Å ‡§µ‡§æ‡§™‡§ø‡§∏ ‡§ï‡§æ‡§∞‡§® ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§∏‡•Å‡§Æ‡•ç‡§Æ ‡§ë‡§´‡§º ‡§ü‡•â‡§™ ‡§ï‡•à‡§∞‡•á‡§ï‡•ç‡§ü‡§∞‡•ç‡§∏ ""--‡§ü‡§æ‡§∏‡•ç‡§ï.--  >>> digitsum """"
--  0
--  >>> digitsum ""abAB""
--  131
--  >>> digitsum ""abcCd""
--  67
--  >>> digitsum ""helloE""
--  69
--  >>> digitsum ""woArBld""
--  131
--  >>> digitsum ""aAaaaXa""
--  153
digitsum :: String -> Int
digitsum s =","digitsum :: String -> Int
digitsum s = sum $ map fromEnum $ filter isUpper s","
main :: IO ()
main = do
  let candidate = digitsum
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abAB"" == 131 then pure () else error ""assertion failed""
  if candidate ""abcCd"" == 67 then pure () else error ""assertion failed""
  if candidate ""helloE"" == 69 then pure () else error ""assertion failed""
  if candidate ""woArBld"" == 131 then pure () else error ""assertion failed""
  if candidate ""aAaaaXa"" == 153 then pure () else error ""assertion failed""
  if candidate "" How are yOu?"" == 151 then pure () else error ""assertion failed""
  if candidate ""You arE Very Smart"" == 327 then pure () else error ""assertion failed""
  pure ()"
HumanEval_67,kas_Deva,hs,"--‡§è‡§ï‡•ç‡§∏‡•à‡§Ç‡§¨‡§≤ ‡§ñ‡§æ‡§§‡§ø‡§∞: --‡§¨‡§æ‡§∏‡•ç‡§ï‡•á‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§Æ‡•à‡§Ç‡§ó‡•ã ‡§´‡§≤‡•ã‡§Ç ‡§π‡•Å‡§®‡•ç‡§¶ ‡§®‡§Ç‡§¨‡§∞--‡§®‡§æ‡§∞‡§Ç‡§ó‡•Ä ‡§§‡•á ‡§∏‡•á‡§¨ ‡§§‡•á ‡§Ö‡§ñ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§Ø‡•Å‡§∏ ‡§ï‡•Å‡§≤ ‡§´‡§∞‡•Ç‡§ï ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§õ‡•Ç ‡§π‡§µ‡§®--,, ‡§§ ‡§Ü‡§Æ ‡§´‡§≤‡§® ‡§π‡•ç‡§®‡•ç‡§ú‡§º‡§ø ‡§ï‡•ç‡§Æ ‡§§‡§æ‡§¶‡§æ‡§¶‡•§--‡§Ø‡•á ‡§õ‡•Ç ‡§´‡§≤‡§® ‡§π‡§ø‡§Ç‡§ú ‡§Ö‡§ñ ‡§¨‡§æ‡§∏‡•ç‡§ï‡•á‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§¨‡§Ç‡§ü‡§æ‡§® ‡§Ø‡•á ‡§õ‡•Ç ‡§Ö‡§• ‡§¨‡§æ‡§∏‡•ç‡§ï‡•á‡§ü‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§∂‡§æ‡§Æ‡§ø‡§≤.-- ‡§á‡§∏ ‡§ü‡§æ‡§∏‡•ç‡§ï ‡§Æ‡§æ ‡§§‡•Å‡§Æ‡§∞‡•å ‡§¨‡§æ‡§® ‡§è‡§ï‡•ã ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§¶‡•Ä ‡§ú‡§æ‡§Ø‡§ó‡•Ä ‡§ú‡•ã ‡§ï‡•Ä ‡§è‡§™‡•ç‡§™‡§≤ ‡§Ö‡§∞ ‡§ë‡§∞‡•á‡§Ç‡§ú ‡§ï‡•Ä ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§Æ‡§æ ‡§¨‡§£‡§æ‡§Ø‡•á ‡§ó‡•á‡•§--  >>> fruitDistribution ""5 apples and 6 oranges"" 19
--  8
--  >>> fruitDistribution ""0 apples and 1 oranges"" 3
--  2
--  >>> fruitDistribution ""2 apples and 3 oranges"" 100
--  95
--  >>> fruitDistribution ""100 apples and 1 oranges"" 120
--  19
fruitDistribution :: String -> Int -> Int
fruitDistribution s n =","import Text.Read (readMaybe)

fruitDistribution :: String -> Int -> Int
fruitDistribution s n = n - totalApplesOranges
  where
    totalApplesOranges = sum $ map (readNumber . words) [""apples"", ""oranges""]
    readNumber keyword = case dropWhile (not . (=="" "") . dropWhile (/=' ')) $ words s of
      [] -> 0
      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","
main :: IO ()
main = do
  let candidate = fruitDistribution
  if candidate ""5 apples and 6 oranges"" 19 == 8 then pure () else error ""assertion failed""
  if candidate ""5 apples and 6 oranges"" 21 == 10 then pure () else error ""assertion failed""
  if candidate ""0 apples and 1 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""1 apples and 0 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 100 == 95 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 5 == 0 then pure () else error ""assertion failed""
  if candidate ""1 apples and 100 oranges"" 120 == 19 then pure () else error ""assertion failed""
  pure ()"
HumanEval_68,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ 1: --‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á ‡§ï‡§π‡•Ä‡§Ç ‡§§‡•á ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç‡§ú ‡§Ø‡§æ ‡§Ø‡•Å‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§ñ‡§≤‡•Ä ,‡§§‡§• ‡§õ‡•Ä ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§æ‡§∞‡§® []--‡§™‡§ø‡§ï‡•ç‡§° ‡§®‡•ã‡§° ‡§Ü‡§µ ‡§∞‡§ü‡§∞‡•ç‡§®‡•ç‡§° ‡§ï‡§æ‡§∞‡§£ ‡§Ü‡§ï‡§ø‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º,[smalest_value,‡§á‡§Æ‡§ø‡§∏ ‡§π‡§ø‡§®‡•ç‡§¶ ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏],--‡§Ö‡§ó‡§∞ ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§®‡•ã‡§°‡•ç‡§∏ ‡§õ‡•Ç ‡§≤‡§ï‡•Å‡§ü,‡§§‡•á‡§≤ ‡§õ‡•Ç ‡§Ø‡•á ‡§®‡•ã‡§°‡§∏ ‡§≤‡§ï‡•Å‡§ü ‡§§‡•á ‡§ï‡§Æ.--‡§Ø‡•Å‡§∏ ‡§®‡•ã‡§® ‡§õ‡•Ç ‡§∏‡•Å ‡§ó‡•â‡§µ ‡§∏‡§∞‡§ø‡§Ø‡•ã ‡§ñ‡•ã‡§§ ‡§≤‡§ï‡•Å‡§ü--‡§§‡•ã‡§∞‡•á ‡§ï‡§æ‡§Æ ‡§õ‡•á ‡§è‡§®‡•ã ‡§®‡•ã‡§°‡§∏ ‡§π‡•Ç‡§∞ ‡§ï‡§∞ ‡§§‡•á ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞.--‡§Ø‡•Å‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§á ‡§õ‡•Ä ‡§π‡§µ‡§® ‡§¨‡•ç‡§∞‡§æ‡§Ç‡§ö ‡§ë‡§´‡§º ‡§è‡§ü‡•ç‡§∞‡•Ä ‡§Ø‡•Å‡§∏ ‡§®‡•â‡§® -‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§®‡•ã‡§°‡•ç‡§∏ ‡§õ‡•Ä ‡§•‡§µ‡§®--  >>> pluck [4,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 2:
--  >>> pluck [1,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 3:
--  >>> pluck []
--  []
--  Example 4:
--  >>> pluck [5,0,3,0,4,2]
--  [0,1]
--  Explanation: 0 is the smallest value, but  there are two zeros,
--  so we will choose the first zero, which has the smallest index.
--  Constraints:
--  * 1 <= nodes.length <= 10000
--  * 0 <= node.value
pluck :: [Int] -> [Int]
pluck arr =","pluck :: [Int] -> [Int]
pluck arr = case filter (\(x, _) -> even x) (zip arr [0..]) of
    [] -> []
    evens -> let (value, index) = minimum evens in [value, index]","
main :: IO ()
main = do
  let candidate = pluck
  if candidate [4,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error ""assertion failed""
  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error ""assertion failed""
  if candidate [5,4,8,4,8] == [4,1] then pure () else error ""assertion failed""
  if candidate [7,6,7,1] == [6,1] then pure () else error ""assertion failed""
  if candidate [7,9,7,1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_69,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á ‡§Ö‡§∏ ‡§µ‡§∞‡•Ä‡§Ø ‡§Ö‡§∏‡§≤ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç ‡§è‡§ï‡•ç‡§∏‡§ø‡§∏‡•ç‡§ü ‡§ï‡§æ‡§∞‡§® ,‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§æ‡§∞‡§® -‡•ß--‡§Ø‡•Å‡§∏ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§õ‡•Ç ‡§∏‡•Å ‡§õ‡•Ç ‡§´‡•ç‡§∞‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏‡•Ä ‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•á ‡§õ‡•Ä ‡§Ö‡§∏ ‡§µ‡§® ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ,‡§¨‡•á ‡§õ‡•Ä ‡§Ø‡•á ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§Ø‡§æ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§∏‡•á‡§•--‡•á‡§ï ‡§®‡•â‡§®-‡§è‡§Æ‡•ç‡§™‡§≤‡•Ä‡§´‡§ø‡§ï‡•á‡§∂‡§® ‡§ë‡§´‡§º ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ó‡§∞. ‡•Å‡§Æ‡§® ‡§õ‡•Ç ‡§∏‡§∞‡§ø‡§Ø‡•ã ‡§ñ‡•ã‡§§ ‡§¨‡•Å‡§° ‡§á‡§Ç‡§ü‡•á‡§ó‡§∞ ‡§≤‡§¨‡§®‡•Ä ‡§Ø‡•á‡§Æ ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§õ‡•Ç ‡•á‡§Æ‡§® ‡§π‡§ø‡§®‡•ç‡§¶ ‡§∏‡•á‡§§--  >>> search [4,1,2,2,3,1]
--  2
--  >>> search [1,2,2,3,3,3,4,4,4]
--  3
--  >>> search [5,5,4,4,4]
--  (-1)
search :: [Int] -> Int
search lst =","import Data.List (group, sort)
import Data.Ord (comparing)

search :: [Int] -> Int
search lst = 
    let frequencies = map (\g -> (head g, length g)) . group . sort $ lst
        candidates = filter (\(val, freq) -> freq >= val) frequencies
    in case candidates of
         [] -> -1
         _  -> fst . maximum $ candidates","
main :: IO ()
main = do
  let candidate = search
  if candidate [5,5,5,5,1] == 1 then pure () else error ""assertion failed""
  if candidate [4,1,4,1,4,4] == 4 then pure () else error ""assertion failed""
  if candidate [3,3] == (-1) then pure () else error ""assertion failed""
  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error ""assertion failed""
  if candidate [2,3,3,2,2] == 2 then pure () else error ""assertion failed""
  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error ""assertion failed""
  if candidate [3,2,8,2] == 2 then pure () else error ""assertion failed""
  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error ""assertion failed""
  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error ""assertion failed""
  if candidate [1,9,10,1,3] == 1 then pure () else error ""assertion failed""
  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error ""assertion failed""
  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error ""assertion failed""
  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error ""assertion failed""
  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error ""assertion failed""
  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error ""assertion failed""
  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error ""assertion failed""
  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error ""assertion failed""
  if candidate [10] == (-1) then pure () else error ""assertion failed""
  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error ""assertion failed""
  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error ""assertion failed""
  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error ""assertion failed""
  if candidate [3,10,10,9,2] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_70,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§è‡§Æ‡•ç‡§Æ ‡§∏‡•á‡§• ‡§Æ‡•à‡§ï‡•ç‡§∏‡§ø‡§Æ‡§Æ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ,‡§™‡§æ‡§§ ‡§è‡§Æ‡§ì ‡§ï‡•Å‡§∞ ‡§Æ‡§ø‡§®‡§ø‡§Æ‡§Æ ,‡§¨‡•á ‡§§‡•á‡§Æ ‡§™‡§æ‡§§--‡§∏‡•ç‡§ü‡•ç‡§∞‡•á‡§®‡•ç‡§ú ‡§∏‡•â‡§∞‡•ç‡§ü‡§ø‡§Ç‡§ó, ‡§á‡§∏ ‡§Ø‡•á‡§≤ ‡§Ö‡§∏ ‡§Ø‡•Ç ‡§¨‡§ø‡§´‡•ã‡§∞ ‡§•‡•á ‡§Æ‡§ø‡§®‡§ø‡§Æ‡§Æ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç, --‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§®,‡§§‡•á‡§Æ ‡§ï‡•ç‡§∞ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ö‡§ï‡§ø‡§∏ ‡§Ö‡§®‡§ú‡§æ‡§® ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§Æ‡§Ç‡§ú‡§º ‡§µ‡§æ‡§™‡§ø‡§∏.--  >>> strangeSortList [1,2,3,4]
--  [1,4,2,3]
--  >>> strangeSortList [5,5,5,5]
--  [5,5,5,5]
--  >>> strangeSortList []
--  []
strangeSortList :: [Int] -> [Int]
strangeSortList lst =","strangeSortList :: [Int] -> [Int]
strangeSortList [] = []
strangeSortList lst = go (sort lst) True
  where
    go [] _ = []
    go xs toggle
      | toggle    = head xs : go (tail xs) False
      | otherwise = last xs : go (init xs) True","
main :: IO ()
main = do
  let candidate = strangeSortList
  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error ""assertion failed""
  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error ""assertion failed""
  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error ""assertion failed""
  if candidate [111111] == [111111] then pure () else error ""assertion failed""
  pure ()"
HumanEval_71,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§§‡•Ä‡§∏‡§∞‡•Ä ‡§§‡§∞‡§´ ‡§∏‡•á‡•§--‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£ ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§® ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£ ‡§Ö‡§ó‡§∞ ‡§ï‡§π‡§Å ‡§§‡•á ‡§¶‡•Å‡§®‡§µ‡§à ‡§§‡§∞‡§´‡§æ ‡§Ö‡§∏ ‡§ú‡§º‡§Ø‡§æ‡§¶--‡§Ö‡§ó‡§∞ ‡§®‡•á ‡§Ö‡§∏ ‡§∏‡§π‡•Ä ‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§® -1 --‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£ ‡§õ‡•Ç 2 ‡§°‡•á‡§∏‡§ø‡§Æ‡§≤ ‡§™‡•â‡§á‡§Ç‡§ü‡•ç‡§∏ ‡§§‡§æ‡§Æ ‡§∞‡§æ‡§â‡§Ç‡§° ‡§Ö‡§∏‡§æ ‡§Ö‡§ó‡§∞ ‡§§‡•ç‡§∞‡•á‡§® ‡§∏‡§æ‡§á‡§° ‡§õ‡•Ç ‡§µ‡•à‡§≤‡§ø‡§° ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£ ‡§¨‡§®‡§æ‡§µ‡§®.--‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§Æ ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§Æ ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§Æ ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§Æ ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§Æ ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§Æ--  >>> triangleArea 3 4 5
--  6.0
--  >>> triangleArea 1 2 10
--  (-1).0
triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c =","import Text.Printf (printf)

triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c
    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))
    | otherwise = -1
  where
    s = (fromIntegral (a + b + c)) / 2
    isValidTriangle x y z = x + y > z && x + z > y && y + z > x
    roundToTwoDecimals x = read (printf ""%.2f"" x) :: Float","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 3 4 5 == 6.0 then pure () else error ""assertion failed""
  if candidate 1 2 10 == (-1).0 then pure () else error ""assertion failed""
  if candidate 4 8 5 == 8.18 then pure () else error ""assertion failed""
  if candidate 2 2 2 == 1.73 then pure () else error ""assertion failed""
  if candidate 1 2 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 10 5 7 == 16.25 then pure () else error ""assertion failed""
  if candidate 2 6 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 1 1 1 == 0.43 then pure () else error ""assertion failed""
  if candidate 2 2 10 == (-1).0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_72,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü q ‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§¨‡§æ‡§≤‡•ç‡§≤‡•á‡§Ç‡§∏‡§° (‡§Ø‡•á ‡§õ‡•Ç ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ‡§ø‡§ï ‡§≤‡§ø‡§∏‡•ç‡§ü) ‡§§‡•á ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§Ö‡§Æ‡§æ‡§â‡§Ç‡§ü ‡§õ‡•Ç ‡§ï‡§Æ ‡§Ø‡§æ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§Æ‡•à‡§ï‡•ç‡§∏‡§ø‡§Æ‡§Æ ‡§Æ‡•Å‡§Æ‡§ï‡§ø‡§® ‡§µ‡§ú‡§º‡§® w.--‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§Ö‡§∏ ‡§∏‡§π‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§Ö‡§ó‡§∞ ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü q ‡§´‡•ç‡§≤‡§æ‡§à ,‡§¨‡•á ‡§ó‡§≤‡§§ ‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á ‡§Ö‡§∏--  >>> willItFly [1,2] 5
--  False
--  # 1+2 is less than the maximum possible weight, but it's unbalanced.
--  >>> willItFly [3,2,3] 1
--  False
--  # it's balanced, but 3+2+3 is more than the maximum possible weight.
--  >>> willItFly [3,2,3] 9
--  True
--  # 3+2+3 is less than the maximum possible weight, and it's balanced.
--  >>> willItFly [3] 5
--  True
--  # 3 is less than the maximum possible weight, and it's balanced.
willItFly :: [Int] -> Int -> Bool
willItFly q w =","willItFly :: [Int] -> Int -> Bool
willItFly q w = isPalindrome q && sum q <= w

isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs","
main :: IO ()
main = do
  let candidate = willItFly
  if candidate [3,2,3] 9 == True then pure () else error ""assertion failed""
  if candidate [1,2] 5 == False then pure () else error ""assertion failed""
  if candidate [3] 5 == True then pure () else error ""assertion failed""
  if candidate [3,2,3] 1 == False then pure () else error ""assertion failed""
  if candidate [1,2,3] 6 == False then pure () else error ""assertion failed""
  if candidate [5] 5 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_73,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡•á‡§ï ‡§¨‡§¶‡§≤‡§æ‡§µ ‡§Æ‡§Ç‡§ú‡§º , ‡§§‡•Å‡§π ‡§π‡•á‡§ï‡•Ä‡§ñ ‡§Ö‡§ï‡§ø‡§∏ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡§∏ ‡§ï‡•Å‡§® ‡§§‡§¨‡•ç‡§¶‡•Ä‡§≤ ‡§ï‡§∞‡§ø‡§• ‡§¨‡•á‡§ï‡§∏ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•Å‡§∏ ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ‡§ø‡§ï ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§∏‡•Å ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ø‡•Å‡§∏--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞‡§∏ ,‡§™‡§æ‡§§ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§∞‡•Ä‡§Ø ‡§ï‡§Æ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü--  >>> smallestChange [1,2,3,5,4,7,9,6]
--  4
--  >>> smallestChange [1,2,3,4,3,2,2]
--  1
--  >>> smallestChange [1,2,3,2,1]
--  0
smallestChange :: [Int] -> Int
smallestChange arr =","smallestChange :: [Int] -> Int
smallestChange arr = sum $ zipWith (\x y -> if x /= y then 1 else 0) arr (reverse arr)","
main :: IO ()
main = do
  let candidate = smallestChange
  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error ""assertion failed""
  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,2,3,2,1] == 0 then pure () else error ""assertion failed""
  if candidate [3,1,1,3] == 0 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_74,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡§Ö‡§ó‡§∞ ‡§ú‡§º‡§® ‡§¶‡•ã‡§® ‡§∏‡•Ç‡§∞‡§§‡§® ‡§Æ‡§Ç‡§ú‡§º ‡§Ö‡§ï‡§ø‡§ö ‡§®‡§Ç‡§¨‡§∞ ‡§ö‡§ø‡§π‡•ç‡§® ‡§Ü‡§∏‡§ø, ‡§§‡§Æ‡§ø ‡§¨‡§æ‡§™‡§• ‡§ó‡•ã‡§°‡§®‡§ø‡§ï‡§ø ‡§∏‡•Ç‡§∞‡§§‡§∏ ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§°‡§ø‡§•‡•§--‡§ï‡•Å‡§≤ ‡§ö‡§æ‡§∞‡•ç‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§á‡§® ‡§Ü‡§≤ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§ë‡§´‡§º ‡§•‡•á ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡§Æ ‡§á‡§® ‡§•‡•á ‡§á‡§§‡§∞ ‡§≤‡§ø‡§∏‡•ç‡§ü.--‡§Ø‡•Å‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§π‡§ï‡§º ‡§Ö‡§∏‡§ø‡§• ‡§Ø‡•Å‡§∏ ‡§ú‡§º‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§Æ‡§æ‡§®‡§æ--  >>> totalMatch [] []
--  []
--  >>> totalMatch [""hi"",""admin""] [""hI"",""Hi""]
--  [""hI"",""Hi""]
--  >>> totalMatch [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""]
--  [""hi"",""admin""]
--  >>> totalMatch [""hi"",""admin""] [""hI"",""hi"",""hi""]
--  [""hI"",""hi"",""hi""]
--  >>> totalMatch [""4""] [""1"",""2"",""3"",""4"",""5""]
--  [""4""]
totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2 =","totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2
  | totalChars lst1 < totalChars lst2 = lst1
  | totalChars lst1 > totalChars lst2 = lst2
  | otherwise = lst1
  where
    totalChars = sum . map length","
main :: IO ()
main = do
  let candidate = totalMatch
  if candidate [] [] == [] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi""] == [""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [""4""] [""1"",""2"",""3"",""4"",""5""] == [""4""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""Hi""] == [""hI"",""Hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hi""] == [""hI"",""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hii""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [] [""this""] == [] then pure () else error ""assertion failed""
  if candidate [""this""] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_75,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡§ø‡§µ ‡§ï‡•Ä (a) ‡§õ‡•Ä ‡§ï‡§Æ 100 ‡§™‡•á‡§†--‡§¨‡•á ‡§ó‡§≤‡§§ ‡§¨‡§ï‡§ø‡§Ø‡§æ‡§Å ‡§§‡§∞‡§ø‡§ï‡§æ‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§Ö‡§∏ ‡§µ‡§® ‡§ü‡•ç‡§∞‡•Ç ‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§¶‡•Ä‡§µ‡§æ‡§® ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§õ‡•Ä ‡§ú‡§º‡§∞‡§ø‡§Ø‡•á ‡§§‡•ç‡§∞ ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç--  >>> isMultiplyPrime 30
--  True
--  30 = 2 * 3 * 5
isMultiplyPrime :: Int -> Bool
isMultiplyPrime a =","isMultiplyPrime :: Int -> Bool
isMultiplyPrime a = any isTriplePrimeProduct primeTriples
  where
    primes = filter isPrime [2..99]
    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]
    isTriplePrimeProduct (x, y, z) = x * y * z == a

isPrime :: Int -> Bool
isPrime n 
  | n < 2     = False
  | otherwise = not (any (\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","
main :: IO ()
main = do
  let candidate = isMultiplyPrime
  if candidate 5 == False then pure () else error ""assertion failed""
  if candidate 30 == True then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == False then pure () else error ""assertion failed""
  if candidate 125 == True then pure () else error ""assertion failed""
  if candidate 105 == True then pure () else error ""assertion failed""
  if candidate 126 == False then pure () else error ""assertion failed""
  if candidate 729 == False then pure () else error ""assertion failed""
  if candidate 891 == False then pure () else error ""assertion failed""
  if candidate 1001 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_76,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --x ‡§õ‡•Å n ‡§™‡•â‡§µ‡§∞ ‡§Ü‡§∏‡§æ‡§® ‡§Ö‡§ó‡§∞ n**int=x --‡§Ø‡•Å‡§∏ ‡§§‡§æ‡§ï‡§§ ‡§õ‡•Ä n ‡§¨‡•á ‡§ó‡§≤‡§§ ‡§¨‡§ï‡§ø‡§Ø‡§æ‡§Å ‡§ø‡§∏‡§Æ‡§æ‡§® ‡§ï‡•á‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§Ö‡§∏ ‡§µ‡§® ‡§ü‡•ç‡§∞‡•Ç ‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§Ü‡§Å‡§ñ ‡§®‡§Ç‡§¨‡§∞ ‡§µ‡§® ‡§õ‡•Ä ‡§è‡§ï‡•ç‡§∏--  >>> isSimplePower 1 4
--  True
--  >>> isSimplePower 2 2
--  True
--  >>> isSimplePower 8 2
--  True
--  >>> isSimplePower 3 2
--  False
--  >>> isSimplePower 3 1
--  False
--  >>> isSimplePower 5 3
--  False
isSimplePower :: Int -> Int -> Bool
isSimplePower x n =","isSimplePower :: Int -> Int -> Bool
isSimplePower x n
  | x < 1 || n < 1 = False
  | n == 1 = x == 1
  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","
main :: IO ()
main = do
  let candidate = isSimplePower
  if candidate 16 2 == True then pure () else error ""assertion failed""
  if candidate 143214 16 == False then pure () else error ""assertion failed""
  if candidate 4 2 == True then pure () else error ""assertion failed""
  if candidate 9 3 == True then pure () else error ""assertion failed""
  if candidate 16 4 == True then pure () else error ""assertion failed""
  if candidate 24 2 == False then pure () else error ""assertion failed""
  if candidate 128 4 == False then pure () else error ""assertion failed""
  if candidate 12 6 == False then pure () else error ""assertion failed""
  if candidate 1 1 == True then pure () else error ""assertion failed""
  if candidate 1 12 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_77,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§®‡•ã‡§ü: ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§π‡•á‡§ï‡§ø‡§µ ‡§Æ‡§æ‡§®‡§Ø‡§• ‡§ú‡§º‡§ø ‡§á‡§®‡§™‡•Å‡§ü ‡§õ‡•á ‡§π‡§Æ‡•á‡§∂‡§ø ‡§∏‡§π‡•Ä‡•§--‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§á‡§®‡•ç‡§ó‡•á‡§ú‡§∞ ‡§Ü‡§Å‡§ñ ‡§ï‡•ç‡§Ø‡•Ç‡§¨ ‡§õ‡•Ä ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§®‡§Ç‡§¨‡§∞--‡§Ü‡§Å‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã ‡§Ø‡•Å‡§∏ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ a ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§§‡•á ‡§ü‡•ç‡§∞‡•Ç ‡§§‡•á ‡§õ‡•Ç ‡§¶‡•á‡§µ‡§®--  >>> iscube 1
--  True
--  >>> iscube 2
--  False
--  >>> iscube (-1)
--  True
--  >>> iscube 64
--  True
--  >>> iscube 0
--  True
--  >>> iscube 180
--  False
iscube :: Int -> Bool
iscube a =","iscube :: Int -> Bool
iscube a = let n = round (fromIntegral a ** (1/3)) in n^3 == a","
main :: IO ()
main = do
  let candidate = iscube
  if candidate 1 == True then pure () else error ""assertion failed""
  if candidate 2 == False then pure () else error ""assertion failed""
  if candidate (-1) == True then pure () else error ""assertion failed""
  if candidate 64 == True then pure () else error ""assertion failed""
  if candidate 180 == False then pure () else error ""assertion failed""
  if candidate 1000 == True then pure () else error ""assertion failed""
  if candidate 0 == True then pure () else error ""assertion failed""
  if candidate 1729 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_78,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§§‡•á‡§Æ ‡§∏‡§ø‡§Ç‡§¨‡§≤ ‡§è,‡§¨‡•Ä,‡§∏‡•Ä,‡§°‡•Ä,‡§à,‡§è‡§´ ‡§õ‡•Ç ‡§π‡§Æ‡•á‡§∂‡§æ ‡§Ö‡§™‡§∞‡§ï‡•á‡§∏.--‡§®‡•ã‡§ü: ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§π‡•á‡§ï‡§ø‡§µ ‡§Æ‡§æ‡§®‡§Ø ‡§ï‡§ø ‡§á‡§®‡§™‡•Å‡§ü ‡§õ‡•á ‡§π‡§Æ‡•á‡§∂‡§æ ‡§∏‡§π‡•Ä ‡§Ø‡§æ ‡§ñ‡§æ‡§≤‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó, --B (= ‡§°‡•á‡§∏‡•Ä‡§Æ‡§≤ 11), D (= ‡§°‡•á‡§∏‡•Ä‡§Æ‡§≤ 13) ‡•§--‡§§‡•ã ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§õ‡§ø ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§°‡§ø‡§ú‡§ø‡§ü‡§π ‡§™‡•á‡§† ‡§Ö‡§ñ ‡§®‡§Ç‡§¨‡§∞‡§É 2, 3, 5, 7, --‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä 2, 3, 5, 7, 11, 13, 17,...--‡§π‡•á‡§ï‡•ç‡§∏‡§æ‡§°‡•á‡§∏‡§ø‡§Æ‡§≤ ‡§°‡§ø‡§ú‡§ø‡§ü ‡§õ‡•Ç 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ‡§è, ‡§¨‡•Ä, ‡§∏‡•Ä, ‡§°‡•Ä, ‡§à, ‡§è‡§´.--‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§® ‡§ï‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§® ‡§ú‡§º‡•á ‡§≤‡•á‡§ü‡§∞ ‡§®‡•á‡§ö‡•Å‡§∞‡§≤ ‡§®‡§Ç‡§¨‡§∞)--‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§Æ‡§Ç‡§ú‡§º ,‡§Ö‡§§‡§É ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞ ,‡§Ø‡§æ ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ,‡§Ø‡•á ‡§õ‡•Ä ‡§®‡•á‡§ö‡•Å‡§∞‡§≤ ‡§®‡§Ç‡§¨‡§∞--‡§π‡•á‡§ï‡•ç‡§∏‡§æ‡§°‡•á‡§∏‡§ø‡§Æ‡§≤ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§è‡§µ‡§Ç --‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§Ü‡§ñ‡§É ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡§®‡•á--  >>> hexKey ""AB""
--  1
--  >>> hexKey ""1077E""
--  2
--  >>> hexKey ""ABED1A33""
--  4
--  >>> hexKey ""123456789ABCDEF0""
--  6
--  >>> hexKey ""2020""
--  2
hexKey :: String -> Int
hexKey num =","hexKey :: String -> Int
hexKey num = length . filter (`elem` primeHexDigits) $ num
  where
    primeHexDigits = ""2357BD""","
main :: IO ()
main = do
  let candidate = hexKey
  if candidate ""AB"" == 1 then pure () else error ""assertion failed""
  if candidate ""1077E"" == 2 then pure () else error ""assertion failed""
  if candidate ""ABED1A33"" == 4 then pure () else error ""assertion failed""
  if candidate ""2020"" == 2 then pure () else error ""assertion failed""
  if candidate ""123456789ABCDEF0"" == 6 then pure () else error ""assertion failed""
  if candidate ""112233445566778899AABBCCDDEEFF00"" == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_79,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ø‡•Å‡§∏ ‡§è‡§ï‡•ç‡§∏‡•ç‡§ü‡•ç‡§∞‡§æ ‡§ï‡•à‡§∞‡•á‡§ï‡•ç‡§ü‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§æ‡§∞‡§® ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü ‡§¨‡§®‡§æ‡§µ‡§®‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§ï‡§ø‡§∏ ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§§ ‡§¨‡•à ‡§è‡§®‡•ç‡§°‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§à‡§µ‡§æ ‡§µ‡§æ‡§∞‡•ç‡§Ø‡§É ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§ï‡•à‡§∞‡•á‡§ï‡•ç‡§ü‡§∞ ""db""--‡§π‡§∞ ‡§Ü‡§ï‡§ø‡§∏ ‡§Ü‡§ï‡§ø‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§æ‡§ï‡§ø‡§∏ "" 0 "" ‡§Ø‡§æ ""1""--‡§Ø‡•Å‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ,‡§Ø‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§π‡§∞ ‡§Ü‡§ï‡§ø‡§∏ ‡§π‡§ø‡§∏‡§∏ ‡§õ‡•Ä ‡§π‡§µ‡§® ‡§¨‡§æ‡§á‡§®‡§∞‡•Ä --‡•á‡§Æ ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§°‡•á‡§∏‡•Ä‡§Æ‡§≤ ‡§´‡•â‡§∞‡•ç‡§Æ ‡§Æ‡§Ç‡§ú‡§º ‡§¨‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§Æ‡§® ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏ ‡•á‡§Æ‡•ã ‡§π‡§¶‡•Ä‡§∏--  >>> decimalToBinary 15
--  ""db1111db""
--  >>> decimalToBinary 32
--  ""db100000db""
decimalToBinary :: Int -> String
decimalToBinary decimal =","decimalToBinary :: Int -> String
decimalToBinary decimal = ""db"" ++ toBinary decimal ++ ""db""
  where
    toBinary 0 = ""0""
    toBinary n = reverse (binaryHelper n)

    binaryHelper 0 = """"
    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","
main :: IO ()
main = do
  let candidate = decimalToBinary
  if candidate 0 == ""db0db"" then pure () else error ""assertion failed""
  if candidate 32 == ""db100000db"" then pure () else error ""assertion failed""
  if candidate 103 == ""db1100111db"" then pure () else error ""assertion failed""
  if candidate 15 == ""db1111db"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_80,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§Ø‡•Å‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§π‡§æ‡§´ ‡§Ö‡§ó‡§∞ ‡§∏‡•Å ‡§π‡§ø‡§∏‡§∏ 3 ‡§§ ‡§¨‡•à ‡§π‡§∞ 3 ‡§∏‡§ø‡§ó‡§®‡•á‡§ü‡§ø‡§µ‡•á ‡§≤‡•á‡§ü‡§∞ ‡§Ö‡§≤‡§ó ‡§Ö‡§≤‡§ó--‡§§‡•á‡§∞‡•á ‡§á‡§∏ ‡§§‡•ã ‡§¨‡•á ‡§ö‡•á‡§ï ‡§Ö‡§ó‡§∞ ‡§•‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§á‡§∏ ‡§π‡§æ‡§´‡•ç‡§∏ ‡§Ø‡§æ ‡§®‡•ã.--          --  >>> isHappy ""a""
--  False
--  >>> isHappy ""aa""
--  False
--  >>> isHappy ""abcd""
--  True
--  >>> isHappy ""aabb""
--  False
--  >>> isHappy ""adb""
--  True
--  >>> isHappy ""xyy""
--  False
isHappy :: String -> Bool
isHappy s =","isHappy :: String -> Bool
isHappy s
  | length s < 3 = False
  | otherwise = all distinctTriples (windows 3 s)
  where
    distinctTriples [x, y, z] = x /= y && y /= z && x /= z
    distinctTriples _ = False
    windows n xs
      | length xs < n = []
      | otherwise = take n xs : windows n (tail xs)","
main :: IO ()
main = do
  let candidate = isHappy
  if candidate ""a"" == False then pure () else error ""assertion failed""
  if candidate ""aa"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""adb"" == True then pure () else error ""assertion failed""
  if candidate ""xyy"" == False then pure () else error ""assertion failed""
  if candidate ""iopaxpoi"" == True then pure () else error ""assertion failed""
  if candidate ""iopaxioi"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_81,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --0.0 E --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 ‡§¨‡•Ä + --> 3.3 A- --> 3.7 A --4.0 A+ --GPA. ‡§≤‡•á‡§ü‡§∞ ‡§ó‡•ç‡§∞‡•á‡§°.--‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§Ø‡•Å‡§∏ ‡§≤‡•á‡§ü‡§∞ ‡§ó‡•ç‡§∞‡•á‡§° ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ø‡•Ä ‡§§‡§æ‡§≤‡§ø‡§ï‡§æ‡§É ‡§Æ‡§®‡•ç‡§ú‡§º ‡§á‡§®‡§™‡•Å‡§ü ‡§ï‡§∞‡§æ‡§® ‡§õ‡§ø:--‡§∏‡•Å ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§§‡•Å‡§Æ‡§π‡•à‡§ï ‡§≤‡§ø‡§∏‡•ç‡§ü GPAs ‡§ï‡§π ‡§∏‡•ç‡§ü‡•Ç‡§°‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡•à‡§ú‡§º ‡§¨‡•á ‡§§‡•Å‡§Æ‡§π ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§≤‡§ø‡§ñ‡§®‡•á--‡§Ø‡•Å‡§∏ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§Æ‡§∏‡§≤‡•á ‡§õ‡•Ç ,‡§á‡§Æ ‡§ï‡•ç‡§∞ ‡§ï‡•ã‡§° ‡§ó‡•Å‡§Æ ‡§Ø‡§ø‡§Æ ‡§∏‡•Å ‡§ó‡•ç‡§∞‡•á‡§°‡§ø‡§Ç‡§ó ‡§ñ‡§æ‡§§‡§ø‡§∞ ‡§á‡§∏‡•ç‡§§‡§ø‡§Æ‡§æ‡§≤ ‡§ï‡•Å‡§∞--‡§ü‡•Ä‡§ö‡§∞ ‡§õ‡•Ä ‡§¨‡§®‡§µ‡§æ ‡§™‡§®‡•Å‡§® ‡§Ö‡§≤‡•ç‡§ó‡•ã‡§∞‡§ø‡§•‡§Æ ‡§ó‡•ç‡§∞‡•á‡§°‡§ø‡§Ç‡§ó ‡§ñ‡§æ‡§§‡§∞--‡§∏‡•á‡§Æ‡•á‡§∏‡•ç‡§ü‡§∞ ‡§õ‡•Ç ‡§Ü‡§ñ‡§∞‡•Ä ‡§π‡§´‡•ç‡§§‡§∏ ‡§Æ‡§Ç‡§ú‡§º, ‡§ü‡•Ä‡§ö‡§∞ ‡§õ‡•Ç ‡§ó‡•ç‡§∞‡•á‡§° ‡§¶‡•á‡§µ‡§®.--  >>> gradeEquation [4.0,3,1.7,2,3.5]
--  [""A+"",""B"",""C-"",""C"",""A-""]
numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades =","numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades = map gpaToLetterGrade grades
  where
    gpaToLetterGrade gpa
      | gpa == 4.0 = ""A+""
      | gpa > 3.7  = ""A""
      | gpa > 3.3  = ""A-""
      | gpa > 3.0  = ""B+""
      | gpa > 2.7  = ""B""
      | gpa > 2.3  = ""B-""
      | gpa > 2.0  = ""C+""
      | gpa > 1.7  = ""C""
      | gpa > 1.3  = ""C-""
      | gpa > 1.0  = ""D+""
      | gpa > 0.7  = ""D""
      | gpa > 0.0  = ""D-""
      | otherwise  = ""E""","
main :: IO ()
main = do
  let candidate = numericalLetterGrade
  if candidate [4.0,3,1.7,2,3.5] == [""A+"",""B"",""C-"",""C"",""A-""] then pure () else error ""assertion failed""
  if candidate [1.2] == [""D+""] then pure () else error ""assertion failed""
  if candidate [0.5] == [""D-""] then pure () else error ""assertion failed""
  if candidate [0.0] == [""E""] then pure () else error ""assertion failed""
  if candidate [1.0,0.3,1.5,2.8,3.3] == [""D"",""D-"",""C-"",""B"",""B+""] then pure () else error ""assertion failed""
  if candidate [0.0,0.7] == [""E"",""D-""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_82,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --length ‡§õ‡•Ç ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§Ø‡§æ ‡§ó‡§≤‡§§ ‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§®‡•á ‡§Ö‡§∏--‡§Ø‡•Å‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§ü‡•ç‡§∞‡•Ç ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§æ‡§∞‡§® ‡§Ö‡§ó‡§∞ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó --  >>> primeLength ""Hello""
--  True
--  >>> primeLength ""abcdcba""
--  True
--  >>> primeLength ""kittens""
--  True
--  >>> primeLength ""orange""
--  False
primeLength :: String -> Bool
primeLength string =","primeLength :: String -> Bool
primeLength string = isPrime (length string)

isPrime :: Int -> Bool
isPrime n
  | n < 2     = False
  | n == 2    = True
  | even n    = False
  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = primeLength
  if candidate ""Hello"" == True then pure () else error ""assertion failed""
  if candidate ""abcdcba"" == True then pure () else error ""assertion failed""
  if candidate ""kittens"" == True then pure () else error ""assertion failed""
  if candidate ""orange"" == False then pure () else error ""assertion failed""
  if candidate ""wow"" == True then pure () else error ""assertion failed""
  if candidate ""world"" == True then pure () else error ""assertion failed""
  if candidate ""MadaM"" == True then pure () else error ""assertion failed""
  if candidate ""Wow"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""HI"" == True then pure () else error ""assertion failed""
  if candidate ""go"" == True then pure () else error ""assertion failed""
  if candidate ""gogo"" == False then pure () else error ""assertion failed""
  if candidate ""aaaaaaaaaaaaaaa"" == False then pure () else error ""assertion failed""
  if candidate ""Madam"" == True then pure () else error ""assertion failed""
  if candidate ""M"" == False then pure () else error ""assertion failed""
  if candidate ""0"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_83,kas_Deva,hs,"--‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§õ‡•Ä ‡§∂‡•Å‡§∞‡•Ç ‡§ó‡§∏‡§æ ‡§Ø‡§æ ‡§ñ‡§º‡§§‡§Æ ‡§ó‡§∏‡§æ 1 ‡§∏‡§æ‡§•--‡§Ø‡•Å‡§∏ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§õ‡•Ä ,‡§Ø‡•á ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§ï‡§æ‡§â‡§Ç‡§ü ‡§ë‡§´‡§º n -‡§°‡§ø‡§ú‡§ø‡§ü ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§ÇstartsOneEnds :: Int -> Int
startsOneEnds n =","startsOneEnds :: Int -> Int
startsOneEnds n
  | n <= 0    = 0
  | n == 1    = 1
  | otherwise = 18 * 10^(n-2)","
main :: IO ()
main = do
  let candidate = startsOneEnds
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 2 == 18 then pure () else error ""assertion failed""
  if candidate 3 == 180 then pure () else error ""assertion failed""
  if candidate 4 == 1800 then pure () else error ""assertion failed""
  if candidate 5 == 18000 then pure () else error ""assertion failed""
  pure ()"
HumanEval_84,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ -- ‡§™‡•ã‡§ú‡§º‡§ø‡§ü‡§ø‡§µ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ N ‡§¶‡•á‡§µ‡§®  ‡§∏‡§ø‡§ó‡§∞‡•á‡§ü ‡§π‡•Å‡§®‡•ç‡§¶ ‡§ü‡•ã‡§ü‡§≤ ‡§∏‡•ã‡§Ç‡§ü ‡§µ‡§æ‡§™‡§∏ ‡§¨‡§æ‡§á‡§®‡§∞‡•Ä ‡§Æ‡§Ç‡§ú‡§º--  >>> solve 1000
--  ""1""
--  >>> solve 150
--  ""110""
--  >>> solve 147
--  ""1100""
--  Variables:
--  @N integer
--  Constraints: 0 ‚â§ N ‚â§ 10000.
--  Output:
--  a string of binary number
solve :: Int -> String
solve N =","solve :: Int -> String
solve N = toBinary (sumOfDigits N)
  where
    sumOfDigits 0 = 0
    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)

    toBinary 0 = ""0""
    toBinary n = reverse (toBinary' n)
      where
        toBinary' 0 = """"
        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","
main :: IO ()
main = do
  let candidate = solve
  if candidate 1000 == ""1"" then pure () else error ""assertion failed""
  if candidate 150 == ""110"" then pure () else error ""assertion failed""
  if candidate 147 == ""1100"" then pure () else error ""assertion failed""
  if candidate 333 == ""1001"" then pure () else error ""assertion failed""
  if candidate 963 == ""10010"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_85,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§®‡•â‡§®-‡§è‡§ï‡•ç‡§≤‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§®‡•â‡§®-‡§è‡§ï‡•ç‡§≤‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§®‡•â‡§®-‡§è‡§ï‡•ç‡§≤‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§®‡•â‡§®-‡§è‡§ï‡•ç‡§≤‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§®‡•â‡§®-‡§è‡§ï‡•ç‡§≤‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§®‡•â‡§®-‡§è‡§ï‡•ç‡§≤‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® --  >>> add [4,2,6,7]
--  2
add :: [Int] -> Int
add lst =","add :: [Int] -> Int
add lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","
main :: IO ()
main = do
  let candidate = add
  if candidate [4,88] == 88 then pure () else error ""assertion failed""
  if candidate [4,5,6,7,2,122] == 122 then pure () else error ""assertion failed""
  if candidate [4,0,6,7] == 0 then pure () else error ""assertion failed""
  if candidate [4,4,6,8] == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_86,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§®‡•ã‡§ü: ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§µ ‡§Ø‡§ø ‡§µ‡§æ‡§ï‡•ç‡§Ø‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§≤‡§´‡•ç‡§ú‡§º‡§® ‡§§ ‡§∞‡§ø‡§ï‡•ç‡§§ ‡§ú‡§ó‡§π‡§® ‡§π‡•Å‡§®‡•ç‡§¶ ‡§§‡§∞‡§§‡•Ä‡§¨ ‡§•‡§æ‡§µ‡•Å‡§®‡•§--‡§∏‡§Æ‡•Ä ‡§ï‡§º‡•Ä‡§Æ‡§§‡§∏ ‡§™‡•á‡§† ‡§Æ‡§¨‡§®‡•Ä ‡§§‡§∞‡§§‡•Ä‡§¨‡•Å‡§ï ‡§§‡§∞‡§§‡•Ä‡§¨‡•§--‡•Å‡§Æ‡§® ‡§π‡§Ç‡§¶‡§ø ‡§Ö‡§ï‡§ø‡§∏ ‡§®‡§µ‡§ø ‡§∂‡§¨‡•ç‡§¶‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§Ø‡§ø‡§Æ ‡§§‡§Æ‡§æ‡§Æ ‡§ñ‡§Ø‡§æ‡§≤‡§æ‡§§ ‡§Ø‡§ø‡§Æ --‡§ë‡§∞‡•ç‡§°‡§∞‡•ç‡§° ‡§µ‡§∞‡•ç‡§∂‡§® ‡§ë‡§´‡§º ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó, ‡§á‡§∏ a ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Ø‡•á‡§§ ‡§Ü‡§≤ ‡§µ‡§∞‡•ç‡§°‡•ç‡§∏ (‡§∏‡•á‡§™‡§∞‡•á‡§ü‡•á‡§° ‡§¨‡•Ä ‡§∏‡•ç‡§™‡•á‡§∏) --‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã ‡§Ø‡•Å‡§∏ ‡§Ö‡§ñ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§≤‡•á‡§• ‡§§‡•á ‡§∏‡•Å‡§®‡•ç‡§¶ ‡§ë‡§∞‡•ç‡§°‡§∞‡•ç‡§° ‡§µ‡§∞‡•ç‡§∂‡§® ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§•--  >>> antiShuffle ""Hi""
--  ""Hi""
--  >>> antiShuffle ""hello""
--  ""ehllo""
--  >>> antiShuffle ""Hello World!!!""
--  ""Hello !!!Wdlor""
antiShuffle :: String -> String
antiShuffle s =","import Data.List (sort)
import Data.Char (isAlpha)

antiShuffle :: String -> String
antiShuffle s = unwords $ map sortWord (wordsAndSpaces s)
  where
    sortWord word = if all isAlpha word then sort word else word
    wordsAndSpaces [] = []
    wordsAndSpaces xs = if head xs == ' ' 
                        then "" "" : wordsAndSpaces (dropWhile (== ' ') xs)
                        else let (word, rest) = break (== ' ') xs
                             in word : wordsAndSpaces rest","
main :: IO ()
main = do
  let candidate = antiShuffle
  if candidate ""Hi"" == ""Hi"" then pure () else error ""assertion failed""
  if candidate ""hello"" == ""ehllo"" then pure () else error ""assertion failed""
  if candidate ""number"" == ""bemnru"" then pure () else error ""assertion failed""
  if candidate ""abcd"" == ""abcd"" then pure () else error ""assertion failed""
  if candidate ""Hello World!!!"" == ""Hello !!!Wdlor"" then pure () else error ""assertion failed""
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hi. My name is Mister Robot. How are you?"" == "".Hi My aemn is Meirst .Rboot How aer ?ouy"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_87,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§¨‡•á ,‡§Ø‡§ø‡§Æ ‡§ï‡•ã‡§ë‡§∞‡•ç‡§°‡§ø‡§®‡§ü‡§∏ ‡§õ‡•Ä ‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§∞‡•å‡§ï‡§ø‡§ï ‡§∏‡•á‡§• ‡§ï‡•â‡§≤‡§Æ ‡§∏‡•á‡§•--‡§ï‡•ã‡§Ü‡§∞‡•ç‡§°‡§ø‡§®‡•á‡§ü‡•ç‡§∏ ‡§õ‡•Ä ‡§∂‡•Å‡§∞‡•Ç ‡§ó‡§∏‡§æ ‡§∞‡•Ç‡§≤ ‡§Æ‡§Ç‡§ú‡§º ‡§æ‡§∏‡•á‡§Ç‡§°‡•Ä‡§Ç‡§ó ‡§æ‡§ï‡§ø‡§∏ ‡§æ‡§ï‡§ø‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡§π‡§∞ ‡§ü‡§™‡§≤ ‡§õ‡•Ç ‡§ï‡•ã‡§Ü‡§∞‡•ç‡§°‡§ø‡§®‡•á‡§ü - (row,columns),‡§Ø‡•Å‡§∏ ‡§∂‡•Å‡§∞‡•Ç ‡§õ‡•Ç ‡§ó‡§æ‡§∏‡§® 0.--‡§§ ‡§¨‡•à ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ë‡§´‡§º ‡§ü‡•ç‡§Ø‡•Ç‡§™‡§≤‡•ç‡§∏ , [(x1, y1), (x2, y2) ...]--lst, ‡§§‡•á ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ x ‡§¶‡•á‡§®, ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ x ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§ñ‡•ã‡§ú, --‡§π‡§∞ ‡§Ü‡§ï‡§ø‡§∏ ‡§∞‡§æ‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§π‡•á‡§ï‡§µ ‡§Æ‡•Å‡§ñ‡•ç‡§§‡§≤‡§ø‡§´ ‡§®‡§Ç‡§¨‡§∞ ‡§ï‡§≤‡§Æ ‡§Ü‡§∏‡§ø‡§•‡•§--‡§Ø‡•Å‡§∏ ‡§Æ‡•à‡§ü‡•ç‡§∞‡§ø‡§ï‡•ç‡§∏ ‡§∏‡•á‡§• ‡§õ‡•Ä ‡§π‡•Å‡§µ‡§æ ,‡§§‡•ã‡§§‡•Ä ,‡§Æ‡•à‡§ü‡•ç‡§∞‡§ø‡§ï‡•ç‡§∏ ‡§Ö‡§≤‡§ó ,--‡•á‡§Æ‡•ã ‡§¶‡•á‡§µ‡§® 2‡§°‡•Ä ‡§°‡§æ‡§ü‡§æ ,‡§®‡•á‡§∏‡•ç‡§ü‡•á‡§° ‡§≤‡§ø‡§∏‡•ç‡§ü‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ,--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1
--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]
--  >>> getRow [] 1
--  []
--  >>> getRow [[],[1],[1,2,3]] 3
--  [(2, 2)]
getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x =","getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x = concatMap processRow (zip [0..] lst)
  where
    processRow (rowIndex, row) = 
      let colIndices = reverse $ findIndices (== x) row
      in [(rowIndex, colIndex) | colIndex <- colIndices]

findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","
main :: IO ()
main = do
  let candidate = getRow
  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error ""assertion failed""
  if candidate [] 1 == [] then pure () else error ""assertion failed""
  if candidate [[1]] 2 == [] then pure () else error ""assertion failed""
  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_88,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --* ‡§¶‡§ø‡§§‡•á‡§® ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§§ ‡§ö‡•á‡§Ç‡§ú ‡§ï‡§∞‡•ã‡•§--‡§®‡•ã‡§ü‡§É --‡§Ø‡§æ ‡§Ö‡§ó‡§∞ ‡§∏‡•Å‡§Æ‡•ç‡§≤ (‡§™‡§π‡§≤‡§æ ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç, ‡§≤‡§æ‡§∏‡•ç‡§ü ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç) ‡§õ‡•Ä ‡§ú‡•ã‡§°‡§º‡•Ä ,‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§Ø‡•á ‡§∏‡•ã‡§∞‡•ç‡§°‡•á‡§° ‡§ï‡§æ‡§∞‡§®--‡§§‡•Å‡§Æ ‡§õ‡•Ä ‡§∏‡•â‡§∞‡•ç‡§ü ‡§ï‡§∞‡§æ ‡§Ø‡§π ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ö‡§ó‡§∞ ‡§∏‡•Å‡§Æ‡•ç‡§Æ ‡§õ‡•Ä ‡§™‡§π‡§≤‡§æ ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç , ‡§≤‡§æ‡§∏‡•ç‡§ü ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç) ‡§õ‡•Ä ‡§á‡§™‡•â‡§° ,--                              --  >>> sortArray []
--  []
--  >>> sortArray [5]
--  [5]
--  >>> sortArray [2,4,3,0,1,5]
--  [0,1,2,3,4,5]
--  >>> sortArray [2,4,3,0,1,5,6]
--  [6,5,4,3,2,1,0]
sortArray :: [Int] -> [Int]
sortArray array =","sortArray :: [Int] -> [Int]
sortArray array
  | null array = array
  | otherwise =
    let first = head array
        last = last array
        sumFirstLast = first + last
    in if odd sumFirstLast
       then sort array
       else reverse (sort array)","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5] == [5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error ""assertion failed""
  if candidate [2,1] == [1,2] then pure () else error ""assertion failed""
  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error ""assertion failed""
  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error ""assertion failed""
  pure ()"
HumanEval_89,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§¶‡•Å‡§®‡§µ‡§à ‡§∏‡•á‡§• ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§§‡•á ‡§¶‡•Å‡§®‡§µ‡§à ‡§ú‡§æ‡§á ‡§™‡•á‡§†--‡§Ö‡§≤‡•ç‡§´‡§æ‡§¨‡•á‡§ü ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§ê‡§∏‡•á ‡§¨‡§¶‡§≤‡§®‡•á ‡§§‡§æ‡§ï‡§ø --‡§£‡•Ç‡§á‡§Ç‡§ï‡•ç‡§∞‡§ø‡§™‡•ç‡§ü‡•á‡§° ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§Ö‡§∏ ‡§Ö‡§≤‡•ç‡§´‡§æ‡§¨‡•á‡§ü ‡§õ‡•Ä ‡§∞‡•ã‡§ü‡§ø‡§ü‡•á‡§°-- ‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§¨‡§®‡§æ‡§µ‡•Å‡§® ‡§Ø‡•Å‡§∏ ‡§Ö‡§ñ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Ö‡§∏‡§ø‡§• --  >>> encrypt ""hi""
--  ""lm""
--  >>> encrypt ""asdfghjkl""
--  ""ewhjklnop""
--  >>> encrypt ""gf""
--  ""kj""
--  >>> encrypt ""et""
--  ""ix""
encrypt :: String -> String
encrypt s =","encrypt :: String -> String
encrypt s = map shiftChar s
  where
    shiftChar c
      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')
      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')
      | otherwise = c","
main :: IO ()
main = do
  let candidate = encrypt
  if candidate ""hi"" == ""lm"" then pure () else error ""assertion failed""
  if candidate ""asdfghjkl"" == ""ewhjklnop"" then pure () else error ""assertion failed""
  if candidate ""gf"" == ""kj"" then pure () else error ""assertion failed""
  if candidate ""et"" == ""ix"" then pure () else error ""assertion failed""
  if candidate ""faewfawefaewg"" == ""jeiajeaijeiak"" then pure () else error ""assertion failed""
  if candidate ""hellomyfriend"" == ""lippsqcjvmirh"" then pure () else error ""assertion failed""
  if candidate ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"" == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" then pure () else error ""assertion failed""
  if candidate ""a"" == ""e"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_90,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§® ‡§Ö‡§∏‡§ø‡§• ,‡§§‡§• ‡§π‡§ï‡§º ‡§®‡•á ‡§ï‡§π‡§Å ‡§§‡•á ‡§≤‡§¨‡§®‡•Ä--‡§≤‡§ø‡§ñ‡•ã ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® next_smallest () ‡§Ø‡•Å‡§∏ ‡§¶‡•Å‡§à‡§§ 2nd ‡§∏‡§∞‡§ø‡§Ø‡•ã ‡§ñ‡•ã‡§§ ‡§≤‡§ï‡§ø‡§ü ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü--‡•á‡§Æ‡•ã ‡§µ‡•Å‡§® ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§®--  >>> nextSmallest [1,2,3,4,5]
--  Just (2)
--  >>> nextSmallest [5,1,4,3,2]
--  Just (2)
--  >>> nextSmallest []
--  Just (Nothing)
--  >>> nextSmallest [1,1]
--  Just (Nothing)
nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =","nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =
  let uniqueSorted = removeDuplicates $ quicksort lst
  in if length uniqueSorted < 2
     then Nothing
     else Just (uniqueSorted !! 1)

removeDuplicates :: (Ord a) => [a] -> [a]
removeDuplicates = foldr (\x acc -> if x `elem` acc then acc else x : acc) []

quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = nextSmallest
  if candidate [1,2,3,4,5] == Just (2) then pure () else error ""assertion failed""
  if candidate [5,1,4,3,2] == Just (2) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1,1,1,0] == Just (1) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error ""assertion failed""
  pure ()"
HumanEval_91,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --"" "" '‡§∏‡§®‡•ç‡§ß‡§ø "" ' ‡§õ‡•Å ‡§Ö‡§ñ ‡§Ö‡§ï‡§ø‡§∏ ‡§π‡§Ç‡§¶‡§ø‡§∏ ‡§¶‡•ã‡§∞‡§æ‡§®, ‡§Ø‡•á‡§≤‡§ø ‡§ú‡§º‡§® '!--‡§¨‡•ã‡§∞‡§ø‡§Ø‡§§ ‡§õ‡•á ‡§Ö‡§ï‡§ø ‡§µ‡§ú‡§º‡§æ‡§π‡•ç‡§§ ‡§Ø‡•Å‡§∏ ""I"" ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§∏‡•Ä‡§• ‡§∂‡§∞‡•Ç ‡§ó‡§õ‡§æ‡§® ‡§õ‡•Å‡•§--‡•á‡§Æ‡•ã ‡§¶‡•á‡§ì ‡§Ü‡§ñ‡§É ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ,‡§¨‡•á ‡§õ‡•Ä ‡§§‡•Å‡§Æ ‡§ï‡§æ‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§µ‡§æ‡§®‡§®--  >>> isBored ""Hello world""
--  0
--  >>> isBored ""The sky is blue. The sun is shining. I love this weather""
--  1
isBored :: String -> Int
isBored S =","isBored :: String -> Int
isBored s = length $ filter (startsWithI . words) $ splitSentences s
  where
    splitSentences :: String -> [String]
    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters "".?!""
    
    splitOnDelimiters :: String -> String -> [String]
    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of
      """" -> []
      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''
    
    startsWithI :: [String] -> Bool
    startsWithI [] = False
    startsWithI (x:_) = map toLower x == ""i""","
main :: IO ()
main = do
  let candidate = isBored
  if candidate ""Hello world"" == 0 then pure () else error ""assertion failed""
  if candidate ""Is the sky blue?"" == 0 then pure () else error ""assertion failed""
  if candidate ""I love It !"" == 1 then pure () else error ""assertion failed""
  if candidate ""bIt"" == 0 then pure () else error ""assertion failed""
  if candidate ""I feel good today. I will be productive. will kill It"" == 2 then pure () else error ""assertion failed""
  if candidate ""You and I are going for a walk"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_92,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ó‡§≤‡§§ ‡§¨‡§ï‡§ø‡§Ø‡§æ‡§Å ‡•á‡§ï‡§∏ ‡§ï‡•á‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§Ü‡§Å‡§ñ ‡§®‡§Ç‡§¨‡§∞ ‡§Ö‡§∏ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§¨‡§ï‡§ø‡§Ø‡§æ‡§Å ‡§ú‡§º‡§®‡§æ‡§® ‡§π‡•Å‡§®‡•ç‡§¶ ,‡§§‡•á‡§≤ ‡§õ‡•Ä ‡§Ö‡§∏ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞--‡•á‡§ï ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§¨‡§®‡§æ‡§Ø‡§ø‡§• ‡§Ø‡•Å‡§∏ 3 ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç ‡§Ö‡§∏--  >>> anyInt 5 2 7
--  True
--  >>> anyInt 3 2 2
--  False
--  >>> anyInt 3 (-2) 1
--  True
--  >>> anyInt 3.6 -2.2 2
--  False
anyInt :: Float -> Float -> Float -> Bool
anyInt x y z =","anyInt :: Float -> Float -> Float -> Bool
anyInt x y z
  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =
      x == y + z || y == x + z || z == x + y
  | otherwise = False","
main :: IO ()
main = do
  let candidate = anyInt
  if candidate 2.0 3.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 2.5 2.0 3.0 == False then pure () else error ""assertion failed""
  if candidate 1.5 5.0 3.5 == False then pure () else error ""assertion failed""
  if candidate 2.0 6.0 2.0 == False then pure () else error ""assertion failed""
  if candidate 4.0 2.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.2 2.2 2.2 == False then pure () else error ""assertion failed""
  if candidate (-4).0 6.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.0 1.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_93,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§≤‡•á‡§ü‡§∞ ‡§π‡§æ‡§µ‡§®‡•Å‡§ï ‡§á‡§ú‡§æ‡§ú‡§º‡§§--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§µ‡•â‡§µ‡•á‡§≤ ‡§õ‡•Ä ‡§Ö‡§• ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§á‡§Ç‡§ó‡•ç‡§≤‡§ø‡§∂ ‡§Ö‡§≤‡•ç‡§´‡§æ‡§¨‡•á‡§ü‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•Å‡§∏ ‡§Æ‡•á‡§∏‡•á‡§ú ‡§õ‡•Ä ‡§≤‡•á‡§ü‡§∞ ‡§∏‡§æ‡§• ‡§Ø‡•Å‡§∏ ‡§π‡§µ‡§® ‡§õ‡•Ä 2 ‡§™‡•ç‡§≤‡•á‡§∏ ‡§¨‡§∞‡•ã‡§π--‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡§®‡•á ‡§§‡§æ‡§ï‡§ø ‡§Ø‡•á ‡§π‡§ï‡§º ‡§¨‡§¶‡§≤‡§ø‡§§ ‡§ï‡•á‡§∏ ‡§ë‡§´‡§º ‡§∏‡§≤‡•Ä‡§Æ ‡§≤‡•á‡§ü‡§∞ ,‡§á ‡§õ‡•Ä ‡§∏‡§¨‡§µ‡•á ‡§ï‡§æ‡§∞‡§® ‡§µ‡•ã‡§ï‡•á‡§≤‡•ç‡§∏ --‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã ‡§Ø‡•Å‡§∏ ‡§Æ‡•á‡§∏‡•á‡§ú ‡§≤‡•á‡§• ,‡§§‡•á ‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º --  >>> encode ""test""
--  ""TGST""
--  >>> encode ""This is a message""
--  ""tHKS KS C MGSSCGG""
encode :: String -> String
encode message =","encode :: String -> String
encode = map transformChar
  where
    transformChar :: Char -> Char
    transformChar c
      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c
      | otherwise      = swapCase c c
      where
        lowerC = toLower c

    isVowel :: Char -> Bool
    isVowel c = c `elem` ""aeiou""

    swapCase :: Char -> Char -> Char
    swapCase origC c
      | isUpper origC = toLower c
      | otherwise     = toUpper c","
main :: IO ()
main = do
  let candidate = encode
  if candidate ""TEST"" == ""tgst"" then pure () else error ""assertion failed""
  if candidate ""Mudasir"" == ""mWDCSKR"" then pure () else error ""assertion failed""
  if candidate ""YES"" == ""ygs"" then pure () else error ""assertion failed""
  if candidate ""This is a message"" == ""tHKS KS C MGSSCGG"" then pure () else error ""assertion failed""
  if candidate ""I DoNt KnOw WhAt tO WrItE"" == ""k dQnT kNqW wHcT Tq wRkTg"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_94,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§§‡•Å‡§Æ‡•ã ‡§ï‡§∞ ‡§™‡§®‡•Å‡§® ‡§¨‡•á‡§∏‡•ç‡§ü ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç ‡§™‡§§‡§æ ‡§§‡•á‡§Æ ‡§∏‡•Ç‡§Ç‡§° ‡§°‡§ø‡§ú‡•Ä‡§ü ‡§π‡•Å‡§®‡•ç‡§¶ ‡§∏‡•Å‡§Æ‡•ç‡§Æ ‡§ï‡§∞‡•ã--‡•á‡§Æ‡•ã ‡§µ‡•Å‡§® ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§®--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]
--  10
--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]
--  25
--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]
--  13
--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]
--  11
--  >>> skjkasdkd [0,81,12,3,1,21]
--  3
--  >>> skjkasdkd [0,8,1,2,1,7]
--  7
skjkasdkd :: [Int] -> Int
skjkasdkd lst =","skjkasdkd :: [Int] -> Int
skjkasdkd lst = sumDigits (largestPrime lst)

-- Function to check if a number is prime
isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]

-- Integer square root using binary search, O(log n)
isqrt :: Int -> Int
isqrt n = floor . sqrt $ fromIntegral n

-- Function to find the largest prime in the list
largestPrime :: [Int] -> Int
largestPrime = foldr (\x acc -> if isPrime x && x > acc then x else acc) 0

-- Function to calculate the sum of the digits of a number
sumDigits :: Int -> Int
sumDigits 0 = 0
sumDigits n = n `mod` 10 + sumDigits (n `div` 10)","
main :: IO ()
main = do
  let candidate = skjkasdkd
  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error ""assertion failed""
  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error ""assertion failed""
  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error ""assertion failed""
  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error ""assertion failed""
  if candidate [0,81,12,3,1,21] == 3 then pure () else error ""assertion failed""
  if candidate [0,8,1,2,1,7] == 7 then pure () else error ""assertion failed""
  if candidate [8191] == 19 then pure () else error ""assertion failed""
  if candidate [8191,123456,127,7] == 19 then pure () else error ""assertion failed""
  if candidate [127,97,8192] == 10 then pure () else error ""assertion failed""
  pure ()"
HumanEval_95,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§ó‡§≤‡§§ ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§æ‡§∞‡§® ‡§Ö‡§ó‡§∞ ‡§¶‡•á‡§µ‡§® ‡§è‡§∏‡•ã‡§∏‡§ø‡§è‡§∂‡§® ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ç ‡§ñ‡§≤‡•Ä ‡§Ö‡§∏‡§æ.--‡§ï‡•á‡§∏ ‡§Ø‡§æ ‡§∏‡§≤‡•Ä‡§Æ ‡§ï‡•Ä‡§ú ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Ö‡§™‡§∞ ‡§ï‡•á‡§∏ ‡§Æ‡§Ç‡§ú‡§º ,‡§Ö‡§≤‡•ç‡§ó ‡§õ‡•Ç ‡§´‡•â‡§≤‡§∏ ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§æ‡§∞‡§®-------‡§è‡§∂‡§ø‡§Ø‡§æ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•Ä‡§¶, ‡§Ö‡§ó‡§∞ ‡§§‡§Æ‡§æ‡§Æ ‡§ï‡•Å‡§Ç‡§ú‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§á‡§® ‡§≤‡•ã‡§Ö‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§° ‡§Ö‡§Ç‡§°‡§∞ ‡§é‡§Ç‡§°--  >>> checkDictCase [(""a"", ""apple""), (""b"", ""banana"")]
--  True
--  >>> checkDictCase [(""a"", ""apple""), (""A"", ""banana""), (""B"", ""banana"")]
--  False
--  >>> checkDictCase [(""a"", ""apple""), (8, ""banana""), (""a"", ""apple"")]
--  False
--  >>> checkDictCase [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")]
--  False
--  >>> checkDictCase [(""STATE"", ""NC""), (""ZIP"", ""12345"")]
--  True
checkDictCase :: [(String, String)] -> Bool
checkDictCase dict =","import Data.Char (isUpper, isLower)

checkDictCase :: [(String, String)] -> Bool
checkDictCase [] = False
checkDictCase dict = all isLower allKeys || all isUpper allKeys
  where
    allKeys = concatMap fst dict","
main :: IO ()
main = do
  let candidate = checkDictCase
  if candidate [(""p"", ""pineapple""), (""b"", ""banana"")] == True then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""A"", ""banana""), (""B"", ""banana"")] == False then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""5"", ""banana""), (""a"", ""apple"")] == False then pure () else error ""assertion failed""
  if candidate [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")] == False then pure () else error ""assertion failed""
  if candidate [(""STATE"", ""NC""), (""ZIP"", ""12345"")] == True then pure () else error ""assertion failed""
  if candidate [(""fruit"", ""Orange""), (""taste"", ""Sweet"")] == True then pure () else error ""assertion failed""
  if candidate [] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_96,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§á‡§Ç‡§§‡•á‡§ú‡§∞‡§∏ ‡§Ø‡§Æ ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§¨‡•á ‡§õ‡•Ä ‡§ï‡§Æ ‡§è‡§® ‡§®‡§ø‡§∑‡•ç--‡§Ø‡•Å‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§®‡•á ‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§ï‡§æ‡§∞‡§® ‡§∞‡§ø‡§ü‡§∞‡•ç‡§®--  >>> countUpTo 5
--  [2,3]
--  >>> countUpTo 11
--  [2,3,5,7]
--  >>> countUpTo 0
--  []
--  >>> countUpTo 20
--  [2,3,5,7,11,13,17,19]
--  >>> countUpTo 1
--  []
--  >>> countUpTo 18
--  [2,3,5,7,11,13,17]
countUpTo :: Int -> [Int]
countUpTo n =","countUpTo :: Int -> [Int]
countUpTo n = filter isPrime [2..n-1]

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = countUpTo
  if candidate 5 == [2,3] then pure () else error ""assertion failed""
  if candidate 6 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 7 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 10 == [2,3,5,7] then pure () else error ""assertion failed""
  if candidate 0 == [] then pure () else error ""assertion failed""
  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error ""assertion failed""
  if candidate 1 == [] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error ""assertion failed""
  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error ""assertion failed""
  pure ()"
HumanEval_97,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Æ‡§æ‡§®‡•ã ‡§á‡§®‡§™‡•Å‡§ü ‡§π‡§Æ‡•á‡§∂‡§æ ‡§µ‡•à‡§≤‡§ø‡§° ‡§π‡•ã‡•§--‡§£‡§£‡§£ ‡§£‡§£‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£--‡•á‡§Æ‡•Å‡§ï ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§Ö‡§∏ ‡§ï‡§æ‡§∞‡§® ‡•á‡§ï‡§∏ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§¨‡•á ‡§¶‡•Å‡§à‡§§ ‡•á‡§Æ‡•Å‡§ï--  >>> multiply 148 412
--  16
--  >>> multiply 19 28
--  72
--  >>> multiply 2020 1851
--  0
--  >>> multiply 14 (-15)
--  20
multiply :: Int -> Int -> Int
multiply a b =","multiply :: Int -> Int -> Int
multiply a b = (abs a `mod` 10) * (abs b `mod` 10)","
main :: IO ()
main = do
  let candidate = multiply
  if candidate 148 412 == 16 then pure () else error ""assertion failed""
  if candidate 19 28 == 72 then pure () else error ""assertion failed""
  if candidate 2020 1851 == 0 then pure () else error ""assertion failed""
  if candidate 14 (-15) == 20 then pure () else error ""assertion failed""
  if candidate 76 67 == 42 then pure () else error ""assertion failed""
  if candidate 17 27 == 49 then pure () else error ""assertion failed""
  if candidate 0 1 == 0 then pure () else error ""assertion failed""
  if candidate 0 0 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_98,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: -- ‡§∏‡§ø‡§ü‡•ç‡§∞‡§ø‡§ô s ‡§¶‡•á‡§µ‡§® ‡§∏, ‡§Ö‡§™‡§∞‡§ï‡•á‡§∏ ‡§µ‡•ã‡§≤‡•ç‡§µ‡§® ‡§π‡•Å‡§®‡•ç‡§¶ ‡§§‡§æ‡§¶‡§æ‡§¶ ‡§™‡•á‡§∞ ‡§á‡§®‡•ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§§ ‡§ó‡§õ‡•Å‡§® --  >>> countUpper ""aBCdEf""
--  1
--  >>> countUpper ""abcdefg""
--  0
--  >>> countUpper ""dBBE""
--  0
countUpper :: String -> Int
countUpper s =","countUpper :: String -> Int
countUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` ""AEIOU""]","
main :: IO ()
main = do
  let candidate = countUpper
  if candidate ""aBCdEf"" == 1 then pure () else error ""assertion failed""
  if candidate ""abcdefg"" == 0 then pure () else error ""assertion failed""
  if candidate ""dBBE"" == 0 then pure () else error ""assertion failed""
  if candidate ""B"" == 0 then pure () else error ""assertion failed""
  if candidate ""U"" == 1 then pure () else error ""assertion failed""
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""EEEE"" == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_99,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡•á‡§ï‡§∏ ‡§™‡•á‡§† ‡§¶‡•Ç‡§Å ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞‡§® ‡§™‡•á‡§† ,‡§Ö‡§• ‡§õ‡•Ä ‡§Ö‡§∏ ‡§∞‡§æ‡§â‡§Ç‡§° ‡§ï‡§æ‡§∞‡§® ‡§ú‡•Ä‡§∞‡•ã ‡§®‡§ø‡§∑‡•ç ‡§¶‡•Ç‡§∞--‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§¶‡•Å‡§∞ ‡§Ö‡§∏‡§ø‡§•--‡§Ø‡•Å‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§á ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§®‡§Ç‡§¨‡§∞ (‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó)--  >>> closestInteger ""10""
--  10
--  >>> closestInteger ""15.3""
--  15
--  Note:
--  Rounding away from zero means that if the given number is equidistant
--  from two integers, the one you should return is the one that is the
--  farthest from zero. For example closest_integer(""14.5"") should
--  return 15 and closest_integer(""-14.5"") should return -15.
closestInteger :: String -> Int
closestInteger value =","closestInteger :: String -> Int
closestInteger value = 
  let n = read value :: Double
  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","
main :: IO ()
main = do
  let candidate = closestInteger
  if candidate ""10"" == 10 then pure () else error ""assertion failed""
  if candidate ""14.5"" == 15 then pure () else error ""assertion failed""
  if candidate ""-15.5"" == (-16) then pure () else error ""assertion failed""
  if candidate ""15.3"" == 15 then pure () else error ""assertion failed""
  if candidate ""0"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_100,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --i ‡§õ‡•Ç ‡§≤‡•á‡§µ‡§≤ (i+1) ‡§Æ‡§Ç‡§ú‡§º ‡§∏‡•ç‡§ü‡•ã‡§®‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§§‡§æ‡§¶‡§æ‡§¶ ‡§π‡§µ‡§®.--                        --- ‡§Ø‡•á ‡§õ‡•Ä ‡§®‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ú‡•ã‡§°‡§º‡•Ä ‡§®‡§Ç‡§¨‡§∞ ‡§Ö‡§ó‡§∞ n ‡§õ‡•Ä ‡§ú‡•ã‡§°‡§º‡•Ä--- ‡§®‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ì‡§° ‡§®‡§Ç‡§¨‡§∞ ‡§Ö‡§ó‡§∞ n ‡§ì‡§° ‡§õ‡•Ç--‡§®‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≤‡•á‡§µ‡§≤ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡•ç‡§ü‡•ã‡§®‡•ç‡§∏:--‡§ó‡•ã‡§°‡•ç‡§®‡•Å‡§ï ‡§≤‡•á‡§µ‡§≤ ‡§õ‡•Ä ‡§è‡§® ‡§∏‡•ç‡§ü‡•ã‡§®‡•ç‡§∏ ‡§∏‡§æ‡§•-- ‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ n ‡§¶‡•á‡§µ‡§® ,‡§§‡•ã‡§≤ ‡§ó‡§∏‡§£ ‡§Ö‡§∏ ‡§™‡§æ‡§• ‡§™‡§•‡§∞‡•Ä ‡§¨‡§®‡§æ‡§®--  >>> makeAPile 3
--  [3,5,7]
makeAPile :: Int -> [Int]
makeAPile n =","makeAPile :: Int -> [Int]
makeAPile n = take n [n, n + 2 ..]","
main :: IO ()
main = do
  let candidate = makeAPile
  if candidate 3 == [3,5,7] then pure () else error ""assertion failed""
  if candidate 4 == [4,6,8,10] then pure () else error ""assertion failed""
  if candidate 5 == [5,7,9,11,13] then pure () else error ""assertion failed""
  if candidate 6 == [6,8,10,12,14,16] then pure () else error ""assertion failed""
  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error ""assertion failed""
  pure ()"
HumanEval_101,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§Ø‡•Å‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§Ö‡§≤‡§ó ‡§ï‡§∞‡§®‡•á ‡§≤‡§´‡§º‡•ç‡§ú‡§º‡§® ‡§Æ‡§Ç‡§ú‡§º ‡§¨‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§æ‡§™‡§∏ ‡§µ‡§ö‡§® ‡§≤‡§´‡§º‡•ç‡§ú‡§º‡§® ‡§π‡•Å‡§®‡•ç‡§¶--‡•ç ‡§ú‡§º‡§¨‡§æ‡§®‡§ø ‡§π‡•Å‡§®‡•ç‡§¶ ‡§Ö‡§ñ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ç ‡§¶‡•á‡§µ‡§®,‡§Ø‡•Å‡§∏ ‡§ï‡•â‡§Æ‡§æ ‡§Ø‡§æ ‡§∏‡•ç‡§™‡•á‡§∏ ‡§∏‡•á‡§§ ‡§Ö‡§≤‡§ó ‡§õ‡•Ç ‡§Ö‡§∏‡§æ.--  >>> wordsString ""Hi, my name is John""
--  [""Hi"",""my"",""name"",""is"",""John""]
--  >>> wordsString ""One, two, three, four, five, six""
--  [""One"",""two"",""three"",""four"",""five"",""six""]
wordsString :: String -> [String]
wordsString s =","wordsString :: String -> [String]
wordsString s = words $ map (\c -> if c == ',' then ' ' else c) s","
main :: IO ()
main = do
  let candidate = wordsString
  if candidate ""Hi, my name is John"" == [""Hi"",""my"",""name"",""is"",""John""] then pure () else error ""assertion failed""
  if candidate ""One, two, three, four, five, six"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate ""Hi, my name"" == [""Hi"",""my"",""name""] then pure () else error ""assertion failed""
  if candidate ""One,, two, three, four, five, six,"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""ahmed     , gamal"" == [""ahmed"",""gamal""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_102,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á ‡§Ö‡§∏ ‡§è‡§µ‡§Ç ,‡§§‡§ø‡§≤ ‡§ó‡§∏ ‡§Ö‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® -‡•ß ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§®--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡•ã ‡§ï‡•Ä ‡§Ö‡§∏ ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§Ö‡§∏‡§≤ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§è‡§ï‡•ç‡§∏ ,‡§µ‡§æ‡§à ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§ú‡§º‡•á ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§®‡§Ç‡§¨‡§∞ ‡§è‡§ï‡•ç‡§∏ ‡§§‡•á ‡§µ‡§æ‡§à ‡§§‡•á ‡§õ‡•Ç ‡§°‡§º‡§ø‡§∏‡§∞‡•ç‡§ü‡§® --  >>> chooseNum 12 15
--  14
--  >>> chooseNum 13 12
--  (-1)
chooseNum :: Int -> Int -> Int
chooseNum x y =","chooseNum :: Int -> Int -> Int
chooseNum x y
    | x > y = -1
    | even upperBound = upperBound
    | even (upperBound - 1) = upperBound - 1
    | otherwise = -1
  where
    upperBound = max x y","
main :: IO ()
main = do
  let candidate = chooseNum
  if candidate 12 15 == 14 then pure () else error ""assertion failed""
  if candidate 13 12 == (-1) then pure () else error ""assertion failed""
  if candidate 33 12354 == 12354 then pure () else error ""assertion failed""
  if candidate 5234 5233 == (-1) then pure () else error ""assertion failed""
  if candidate 6 29 == 28 then pure () else error ""assertion failed""
  if candidate 27 10 == (-1) then pure () else error ""assertion failed""
  if candidate 7 7 == (-1) then pure () else error ""assertion failed""
  if candidate 546 546 == 546 then pure () else error ""assertion failed""
  pure ()"
HumanEval_104,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§®‡•ã‡§ü: ‡§∞‡§ø‡§ü‡§∞‡•ç‡§®‡§° ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ü‡§µ ‡§∏‡•â‡§∞‡•ç‡§ü ‡§ï‡§æ‡§∞‡§£ ‡§Ö‡§ï‡§ø‡§∏ ‡§ë‡§∞‡•ç‡§°‡§∞‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º--‡•á‡§≤‡•á‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§Ø‡§Æ ‡§®‡•á ‡§ï‡§π‡§Å ‡§§‡•á ‡§∏‡§Æ ‡§°‡§ø‡§ú‡§ø‡§ü ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§®-- ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ó‡§∞ x ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® --  >>> uniqueDigits [15,33,1422,1]
--  [1,15,33]
--  >>> uniqueDigits [152,323,1422,10]
--  []
uniqueDigits :: [Int] -> [Int]
uniqueDigits x =","uniqueDigits :: [Int] -> [Int]
uniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","
main :: IO ()
main = do
  let candidate = uniqueDigits
  if candidate [15,33,1422,1] == [1,15,33] then pure () else error ""assertion failed""
  if candidate [152,323,1422,10] == [] then pure () else error ""assertion failed""
  if candidate [12345,2033,111,151] == [111,151] then pure () else error ""assertion failed""
  if candidate [135,103,31] == [31,135] then pure () else error ""assertion failed""
  pure ()"
HumanEval_105,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --""‡§µ‡§®"", ""‡§ü‡•Ç"", ""‡§•‡•ç‡§∞‡•Ä"", ""‡§´‡•ã‡§∞"", ""‡§´‡§æ‡§á‡§µ"", ""‡§∏‡§ø‡§ï‡•ç‡§∏"", ""‡§∏‡•á‡§µ‡§®"", ""‡§Ü‡§†"", ""‡§®‡§æ‡§á‡§®‡•á"".--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§Ö‡§• ‡§õ‡•Ä ‡§Ö‡§∏ ‡§ï‡§æ‡§∞‡§® ‡§∞‡§ø‡§µ‡§∞‡•ç‡§∏ ,‡§¨‡•á ‡§õ‡•Ä ‡§è‡§Æ‡•ç ‡§™‡§æ‡§§ ‡§ï‡§æ‡§∞‡§® ‡§π‡§∞ ‡§°‡§ø‡§ú‡§ø‡§ü ‡§¨‡§¶‡§≤--‡§á‡§Ç‡§ü‡•á‡§ó‡§∞‡§® ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§®,‡§§‡•á‡§Æ ‡§á‡§Ç‡§ü‡•á‡§ó‡§∞ ‡§ï‡•ç‡§∞ ‡§∏‡•â‡§∞‡•ç‡§ü ‡§Ø‡•á‡§Æ 1 ‡§§‡•á 9 ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç,--  >>> byLength [2,1,1,4,5,8,2,3]
--  [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""]
--  If the list is empty, return an empty list:
--  >>> byLength []
--  []
--  If the list has any strange number ignore it:
--  >>> byLength [1,(-1),55]
--  [""One""]
byLength :: [Int] -> [String]
byLength arr =","byLength :: [Int] -> [String]
byLength arr = map digitName . reverse . sort . filter isValid $ arr
  where
    isValid x = x >= 1 && x <= 9
    digitName x = case x of
      1 -> ""One""
      2 -> ""Two""
      3 -> ""Three""
      4 -> ""Four""
      5 -> ""Five""
      6 -> ""Six""
      7 -> ""Seven""
      8 -> ""Eight""
      9 -> ""Nine""
      _ -> error ""Unexpected number""","
main :: IO ()
main = do
  let candidate = byLength
  if candidate [2,1,1,4,5,8,2,3] == [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-1),55] == [""One""] then pure () else error ""assertion failed""
  if candidate [1,(-1),3,2] == [""Three"",""Two"",""One""] then pure () else error ""assertion failed""
  if candidate [9,4,8] == [""Nine"",""Eight"",""Four""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_106,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ø‡•Å‡§∏ ‡§´‡•à‡§ï‡•ç‡§ü‡•ã‡§∞‡§ø‡§Ø‡§≤ ‡§õ‡•Ä I ‡§Ø‡•á ‡§õ‡•Ä ‡§Æ‡§≤‡•ç‡§ü‡•Ä‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§∂‡§® ‡§®‡§Ç‡§¨‡§∞‡•ç‡§∏ ‡§™‡•á‡§† 1 ‡§™‡•á‡§† I ‡§§‡§æ‡§Æ (1 * 2 * ... * I)--i ‡§õ‡•Ä ‡§∂‡•Å‡§∞‡•Ç ‡§ó‡§æ‡§∏‡§® 1 ‡§™‡•á‡§†--‡§Ø‡§æ ‡§Ö‡§∏‡•Å‡§Æ ‡§®‡§Ç‡§¨‡§∞ 1 ‡§™‡•á‡§† i ‡§§‡§æ‡§Æ--‡§§‡•á‡§Æ ‡§õ‡•Ç ‡§∏‡§æ‡§á‡§ú n ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§§‡•á ‡§¶‡•á‡§µ‡§®,‡§Ø‡•á‡§• ‡§™‡•á‡§† ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ i ‡§™‡•á‡§† ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§π‡•Å‡§®‡•ç‡§¶ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç ‡§õ‡•Ç ‡§´‡•à‡§ï‡•ç‡§ü‡•ã‡§∞‡§ø‡§Ø‡§≤ ‡§ë‡§´‡§º i ‡§Ø‡•á‡§≤ i ‡§ú‡•ã‡§°‡§º‡•á ‡§õ‡•Ç.--f ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§Ö‡§Æ‡§≤‡•Ä ‡§¨‡§®‡§æ‡§µ‡§® ‡§Ø‡•Å‡§∏ n ‡§õ‡•Ç ‡§™‡•à‡§∞‡§æ‡§Æ‡•Ä‡§ü‡§∞,--  >>> f 5
--  [1,2,6,24,15]
f :: Int -> [Int]
f n =","f :: Int -> [Int]
f n = map g [1..n]
  where
    g i
      | even i    = factorial i
      | otherwise = sum [1..i]
    
    factorial 0 = 1
    factorial m = product [1..m]","
main :: IO ()
main = do
  let candidate = f
  if candidate 5 == [1,2,6,24,15] then pure () else error ""assertion failed""
  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  if candidate 3 == [1,2,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_107,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ 1: --‡§á‡§Ç‡§ü‡•á‡§ó‡§∞ ‡§™‡§æ‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ‡•ç‡§∏ ‡§Ø‡•Å‡§∏ ‡§∞‡•á‡§Ç‡§ú ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç--‡§Ø‡•Å‡§∏ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§õ‡•Ä ,‡§Ø‡•á ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§ü‡§™‡§≤ ‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§è‡§µ‡§Ç ‡§õ‡•Ä ‡§®‡§Ç‡§¨‡§∞ ‡§ë‡§´‡§º ‡§ú‡•ã‡§∞ ‡§§‡•á ‡§ì‡§°--  >>> evenOddPalindrome 3
--  (1, 2)
--  Explanation:
--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
--  Example 2:
--  >>> evenOddPalindrome 12
--  (4, 6)
--  Explanation:
--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
--  Note:
--  1. 1 <= n <= 10^3
--  2. returned tuple has the number of even and odd integer palindromes respectively.
evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n =","evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n = (length evens, length odds)
  where
    isPalindrome x = show x == reverse (show x)
    palindromes = filter isPalindrome [1..n]
    evens = filter even palindromes
    odds  = filter odd palindromes","
main :: IO ()
main = do
  let candidate = evenOddPalindrome
  if candidate 123 == (8, 13) then pure () else error ""assertion failed""
  if candidate 12 == (4, 6) then pure () else error ""assertion failed""
  if candidate 3 == (1, 2) then pure () else error ""assertion failed""
  if candidate 63 == (6, 8) then pure () else error ""assertion failed""
  if candidate 25 == (5, 6) then pure () else error ""assertion failed""
  if candidate 19 == (4, 6) then pure () else error ""assertion failed""
  if candidate 9 == (4, 5) then pure () else error ""assertion failed""
  if candidate 1 == (0, 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_108,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•à‡§∞ ‡§™‡•á‡§† -123 ‡§õ‡•Ä ‡§∏‡§æ‡§á‡§® ‡§°‡§ø‡§ú‡§ø‡§ü -1, 2 ,‡§¨‡•á 3--‡§Ö‡§ó‡§∞ ‡§Ü‡§Å‡§ñ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ,‡§§‡§ø‡§≤ ‡§õ‡•Ä ‡§ó‡•ã‡§°‡•ç‡§®‡•Å‡§ñ ‡§∏‡§æ‡§á‡§®‡•á‡§° ‡§°‡§ø‡§ú‡§ø‡§ü ‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ--‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§∏‡•Å ‡§õ‡•Ä ‡§Ö‡§∏ ‡§°‡§ø‡§ú‡•Ä‡§ü‡§∏ > 0--‡•á‡§ï ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã count_nums ‡§Ø‡•Å‡§∏ ‡§á‡§Ç‡§§‡•á‡§ú‡§∞‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§≤‡•á‡§µ‡§æ ‡§§ ‡§¨‡•à ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§®--  >>> countNums []
--  0
--  >>> countNums [(-1),11,(-11)]
--  1
--  >>> countNums [1,1,2]
--  3
countNums :: [Int] -> Int
countNums arr =","countNums :: [Int] -> Int
countNums arr = length $ filter ((> 0) . sumDigits) arr
  where
    sumDigits 0 = 0
    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)
                  in sum digits","
main :: IO ()
main = do
  let candidate = countNums
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),0] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error ""assertion failed""
  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error ""assertion failed""
  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error ""assertion failed""
  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_109,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§®‡•ã‡§ü‡§É ‡§¶‡•á‡§® ‡§ó‡•á‡§®‡•á‡§ü‡•á‡§° ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•á ‡§Ø‡•Ç‡§®‡§ø‡§ï ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡§∏ ‡§Ü‡§∏‡§æ‡§®‡•§--‡§Ö‡§ó‡§∞ ‡§¶‡•á‡§µ‡§® ‡§≤‡§ø‡§∏‡§ü ‡§õ‡•Ç ‡§ñ‡§≤‡•Ä ‡§§‡•á‡§Æ ‡§™‡§æ‡§§ ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§µ‡§æ‡§™‡§ø‡§∏.--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§∏‡§π‡•Ä ‡§õ‡•Ä ,‡§§‡§• ‡§õ‡•Ä ‡§Ö‡§∏ ‡§ó‡§≤‡§§ ‡§§‡•á ‡§∞‡§ø‡§ü‡§∞‡•ç‡§®--‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§Æ‡•Å‡§Æ‡§ï‡§ø‡§® ‡§Ü‡§∏ ‡§ï‡•Ä ‡§Ö‡§∏ ‡§ï‡§∞‡•ã ‡§∏‡•â‡§∞‡•ç‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ø‡§ø‡§≤ ‡§Ö‡§∏ ‡§µ‡§∞‡•Ä‡§Ø ‡§ë‡§™‡§∞‡•á‡§∂‡§® ‡§ï‡§∞‡•ã--‡§Ø‡•Å‡§∏ ‡§∂‡•Å‡§∞‡•Ç‡§Ü‡§§‡•Ä ‡§™‡•ã‡§ú‡•Ä‡§∂‡§® ‡§õ‡•Ä ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§Ø‡§æ‡§®‡•á 0th ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏--‡§Ü‡§ñ‡§∞‡•Ä ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§õ‡•Ä --‡§Ö‡§ñ ‡§¶‡§æ‡§π‡•ç‡§®‡•Ä ‡§∂‡§ø‡§´‡•ç‡§ü ‡§ë‡§™‡§∞‡•á‡§∂‡§® ‡§Æ‡§§‡§≤‡§¨ ‡§õ‡•Å ‡§ú‡§º‡§ø ‡§∏‡§æ‡§∞‡§ø‡§µ‡§Ø ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§õ‡•Å ‡§Ö‡§ï‡§ø‡§∏ ‡§π‡§ø‡§µ‡§ø ‡§∏‡•â‡§§‡§ø ‡§∂‡§ø‡§´‡•ç‡§ü ‡§ó‡§õ‡§æ‡§®‡•§--‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§π‡•á‡§ï‡§ø‡§µ ‡§Ø‡§ø‡§Æ ‡§µ‡§æ‡§∞‡§ø‡§Ø‡§æ‡§π ‡§µ‡§ñ‡§§‡§π ‡§¶‡§æ‡§π ‡§∂‡§´‡§º‡•ç‡§ü ‡§ï‡§∞‡§æ‡§®‡•§--‡§Ø‡•Å‡§∏ ‡§ë‡§™‡§∞‡•á‡§∂‡§® ‡§õ‡•Ä ‡§è‡§Æ‡•ç ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º:--‡§Ø‡•á ‡§õ‡•Ä ‡§Æ‡•Å‡§Æ‡§ï‡§ø‡§® ‡§ï‡•Ä ‡§Ö‡§∏ ‡§π‡§ï‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡•ç‡§∞‡•â‡§∞‡•ç‡§ü‡•Ä‡§´‡§º‡§ø‡§è ‡§ï‡§∞‡§• ‡§®‡•â‡§®-‡§°‡§ø‡§ï‡•ç‡§∞‡•á‡§µ‡§ø‡§Ç‡§ó ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§Æ‡§Ç‡§ú‡§º --‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§∞‡•à‡§Ç‡§°‡§Æ‡§≤‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞‡§ø‡§Ç‡§ó ‡§ï‡§æ‡§∞‡§£--                                                                                    --  >>> moveOneBall [3,4,5,1,2]
--  True
--  Explanation: By performin 2 right shift operations, non-decreasing order can
--  be achieved for the given list.
--  >>> moveOneBall [3,5,4,1,2]
--  False
--  Explanation:It is not possible to get non-decreasing order for the given
--  list by performing any number of right shift operations.
moveOneBall :: [Int] -> Bool
moveOneBall arr =","moveOneBall :: [Int] -> Bool
moveOneBall [] = True
moveOneBall arr = canBeSorted (arr ++ arr)
  where
    n = length arr
    canBeSorted xs = any isSorted (take n <$> tails xs)
    isSorted ys = and $ zipWith (<=) ys (tail ys)
    tails [] = []
    tails l@(_:xs) = l : tails xs","
main :: IO ()
main = do
  let candidate = moveOneBall
  if candidate [3,4,5,1,2] == True then pure () else error ""assertion failed""
  if candidate [3,5,10,1,2] == True then pure () else error ""assertion failed""
  if candidate [4,3,1,2] == False then pure () else error ""assertion failed""
  if candidate [3,5,4,1,2] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_110,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§Ö‡§ó‡§∞ ‡§®‡•á ‡§Ö‡§∏‡§ø‡§• ,‡§§‡•á‡§≤ ‡§ï‡§∞‡•ã ""‡§®‡§æ"" ‡§µ‡§æ‡§™‡§∏--lst1 ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§§‡§Æ‡§æ‡§Æ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§Ö‡§∏‡§ø‡§•, ‡§µ‡§æ‡§™‡§∏ ""YES"".--‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§Æ‡•Å‡§Æ‡§ï‡§ø‡§® ‡§π‡•à‡§ï ‡§Ö‡§∏‡§ø‡§• ‡§ï‡•Ä ‡§Ö‡§∏ ‡§π‡§ï‡•ã ‡§¨‡§¶‡§≤‡§ø‡§§ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ lst1 ‡§¨‡•á lst2 ‡§¶‡§∞‡§Æ‡§ø‡§Ø‡§æ‡§® ‡§§‡§æ‡§ï‡§ø --lst1 ‡§§‡•á lst2 ‡§¶‡§∞‡§Æ‡§ø‡§Ø‡§æ‡§® ‡§è‡§ï‡•ç‡§∏‡§ö‡•á‡§Ç‡§ú ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡§® ‡§π‡§ø‡§Ç‡§ú ‡§®‡§Ç‡§¨‡§∞ ‡§™‡•á‡§† ‡§õ‡•Å‡§Ç ‡§ï‡§π‡•á‡§Ç ‡§≤‡§ø‡§Æ‡§ø‡§ü.--‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§Ü‡§ñ‡§É ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§™‡§∞ ‡§®‡§Ç‡§¨‡§∞‡•ã‡§Ç ‡§∏‡•á‡§•--‡§§ ‡§¨‡•à ‡§Ø‡§π ‡§õ‡•Ä ‡§°‡•á‡§ü‡§∞‡•ç‡§Æ‡§ø‡§®‡•á ‡§ï‡§∞‡§æ ‡§ï‡•Ä ‡§ï‡•ç‡§Ø‡§æ ‡§Ø‡§π ‡§π‡•à‡§ï ‡§Ü‡§Æ‡•Å‡§§ ‡§è‡§ï‡•ç‡§∏‡§ö‡•á‡§Ç‡§ú ‡§ï‡§∞‡§ø‡§•--‡•á‡§Æ ‡§Ö‡§∏ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§æ‡§∞‡§® ‡§Ø‡•Å‡§∏ ‡§ú‡§º‡•á ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∞‡§≤‡§®--  >>> exchange [1,2,3,4] [1,2,3,4]
--  ""YES""
--  >>> exchange [1,2,3,4] [1,5,3,4]
--  ""NO""
--  It is assumed that the input lists will be non-empty.
exchange :: [Int] -> [Int] -> String
exchange lst1 lst2 =","exchange :: [Int] -> [Int] -> String
exchange lst1 lst2
  | all even lst1 = ""YES""
  | null oddLst1 || null evenLst2 = ""NO""
  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)
                in if possibility then ""YES"" else ""NO""
  where
    oddLst1 = filter odd lst1
    evenLst2 = filter even lst2","
main :: IO ()
main = do
  let candidate = exchange
  if candidate [1,2,3,4] [1,2,3,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [1,5,3,4] == ""NO"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [2,1,4,3] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,3] == ""NO"" then pure () else error ""assertion failed""
  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == ""NO"" then pure () else error ""assertion failed""
  if candidate [100,200] [200,200] == ""YES"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_111,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ö‡§ó‡§∞ ‡§ï‡§π‡§Å ‡§§‡•á ‡§≤‡•á‡§ü‡§∞ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§è‡§ï‡§ø‡§∏ ‡§ú‡§æ‡§á ‡§™‡•á‡§† ,‡§§‡§π ‡§õ‡•Ä ‡§Ö‡§• ‡§∏‡§≤‡•Ä‡§Æ ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§®--‡§Ø‡•Å‡§∏ ‡§≤‡•á‡§ü‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§µ‡§æ‡§∞‡§ø‡§Ø‡§æ ‡§∞‡§ø‡§™‡•Ä‡§ü ‡§ï‡§æ‡§∞‡§® ‡§¨‡•á ‡§õ‡•Ä ‡§Ö‡§• ‡§π‡§ø‡§∏‡§æ‡§¨ ‡§ï‡§æ‡§∞‡§®------- ‡§≤‡•Å‡§ï‡§≤‡§∏‡•á‡§∞‡•ç‡§∏ ‡§∏‡•á‡§™‡§∞‡•á‡§ü‡•á‡§° ‡§∏‡•ç‡§™‡•á‡§∏‡§∏ ‡§∞‡§ø‡§™‡•ç‡§∞‡•á‡§ú‡•á‡§Ç‡§ü ‡§ï‡§∞‡§Ç‡§ü‡•ç‡§∏, ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§è‡§∏‡•ã‡§∏‡§ø‡§è‡§∂‡§® ‡§≤‡§ø‡§∏‡•ç‡§ü--  >>> histogram ""a b c""
--  [(""a"", 1), (""b"", 1), (""c"", 1)]
--  >>> histogram ""a b b a""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""a b c a b""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""b b b b a""
--  [(""b"", 4)]
--  >>> histogram """"
--  []
histogram :: String -> [(String, Int)]
histogram test =","import Data.List (group, sort)
import Data.Ord (comparing)

histogram :: String -> [(String, Int)]
histogram input =
  let wordsList = words input
      grouped = group $ sort wordsList
      countList = map (\ws -> (head ws, length ws)) grouped
      maxCount = if null countList then 0 else maximum $ map snd countList
  in filter ((== maxCount) . snd) countList","
main :: IO ()
main = do
  let candidate = histogram
  if candidate ""a b b a"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c a b"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c d g"" == [(""a"", 1), (""b"", 1), (""c"", 1), (""d"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""b b b b a"" == [(""b"", 4)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""a"" == [(""a"", 1)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_112,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§µ ‡§∞‡•Ö‡§≤‡§ø‡§• ‡§ü‡•ç‡§Ø‡•Å‡§™‡§≤ ‡§Ø‡§• ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§∞‡•Ö‡§≤‡§ø‡§• ‡§∏‡§ü‡•ç‡§∞‡•á‡§®‡•ç‡§ó ‡§§ ‡§ü‡•ç‡§∞‡•Ç/ ‡§´‡§º‡•ã‡§≤‡•ç‡§ú‡§º ‡§õ‡§ø‡•§--‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ç ‡§™‡•à‡§≤‡§ø‡§Ç‡§°‡•ç‡§∞‡•ã‡§Æ ‡§µ‡§æ‡§®‡§æ‡§® ‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§¨‡•à‡§ï‡§µ‡§∞‡•ç‡§° ‡§§‡•á ‡§´‡•â‡§∞‡§µ‡§∞‡•ç‡§° ‡§Æ‡§Ç‡§ú‡§º ‡§∂‡§æ‡§Æ‡•á ‡§™‡§æ‡§† ‡§õ‡•Ç ‡§ï‡§∞‡§æ.--‡§§‡§Æ‡§ø ‡§™‡§§‡§É ‡§µ‡•Å‡§õ‡•ã ‡§ú‡§º‡§ø ‡§∞‡§ø‡§ú‡§º‡§≤‡•ç‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Å ‡§™‡§æ‡§≤‡§ø‡§®‡•ç‡§°‡•ç‡§∞‡•ã‡§Æ‡•§--S ‡§§‡•á C ‡§§‡•á‡§Æ ‡§∏‡§ø‡§Ç‡§¶ ‡§∏‡§æ‡§∞‡•ã ‡§µ‡§∞‡•ç‡§£‡•ã ‡§π‡§ü‡§æ‡§ì--‡§ü‡§æ‡§∏‡•ç‡§ï.--  >>> reverseDelete ""abcde"" ""ae""
--  (""bcd"", False)
--  >>> reverseDelete ""abcdef"" ""b""
--  (""acdef"", False)
--  >>> reverseDelete ""abcdedcba"" ""ab""
--  (""cdedc"", True)
reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =","import Data.List (filter)

reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =
  let result = filter (`notElem` c) s
  in (result, result == reverse result)","
main :: IO ()
main = do
  let candidate = reverseDelete
  if candidate ""abcde"" ""ae"" == (""bcd"", False) then pure () else error ""assertion failed""
  if candidate ""abcdef"" ""b"" == (""acdef"", False) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""ab"" == (""cdedc"", True) then pure () else error ""assertion failed""
  if candidate ""dwik"" ""w"" == (""dik"", False) then pure () else error ""assertion failed""
  if candidate ""a"" ""a"" == ("""", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" """" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""v"" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""vabba"" ""v"" == (""abba"", True) then pure () else error ""assertion failed""
  if candidate ""mamma"" ""mia"" == ("""", True) then pure () else error ""assertion failed""
  pure ()"
HumanEval_113,kas_Deva,hs,"--‡§£‡§£‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ--‡§á‡§®‡§™‡•Å‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó i. ""‡§Ø‡•á‡§§‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§∏‡§≤‡•Ä‡§Æ ‡§Ü‡§à‡§è‡§∏ ‡§π‡§ï‡•ã ‡§Ö‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡•á‡§• ‡§¨‡§¶‡§≤‡§ø‡§§--‡§π‡§∞ ‡§Ü‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§Ü‡§Ø ‡§ë‡§´‡§º ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü ‡§ó‡§∏‡§£ ""‡§®‡§Ç‡§¨‡§∞ ‡§ë‡§´‡§º ‡§ì‡§° ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§á‡§® -- ‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡•ã ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ,‡§Ø‡§ø‡§§ ‡§∏‡§≤‡•Ä‡§Æ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§® ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§°‡§ø‡§ú‡§ø‡§ü ,‡§§‡•ã‡§≤ ‡§Ö‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡§æ‡§∞‡§®--  >>> oddCount [""1234567""]
--  [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
--  >>> oddCount [""3"",""11111111""]
--  [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""]
oddCount :: [String] -> [String]
oddCount lst =","oddCount :: [String] -> [String]
oddCount lst = map formatString lst
  where
    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""

    countOdds :: String -> Int
    countOdds str = length $ filter isOddDigit str

    formatString :: String -> String
    formatString str =
      let oddCount = countOdds str in
      ""the number of odd elements "" ++ show oddCount ++ 
      ""n the str"" ++ show oddCount ++ ""ng "" ++ show oddCount ++
      "" of the "" ++ show oddCount ++ ""nput.""","
main :: IO ()
main = do
  let candidate = oddCount
  if candidate [""1234567""] == [""the number of odd elements 4n the str4ng 4 of the 4nput.""] then pure () else error ""assertion failed""
  if candidate [""3"",""11111111""] == [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""] then pure () else error ""assertion failed""
  if candidate [""271"",""137"",""314""] == [""the number of odd elements 2n the str2ng 2 of the 2nput."",""the number of odd elements 3n the str3ng 3 of the 3nput."",""the number of odd elements 2n the str2ng 2 of the 2nput.""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_114,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡§£‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ ‡§£‡§Æ--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡•ã ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ,‡§§‡•á‡§≤ ‡§Ö‡§∏ ‡§µ‡§∞‡•Ä‡§Ø ‡§ï‡§Æ ‡§®‡•ã‡§® -‡§è‡§Æ‡•ç‡§™‡•ç‡§≤‡•Ä‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§∏‡•Å‡§¨-‡§≤‡§ø‡§∏‡•ç‡§ü--  >>> minsubarraysum [2,3,4,1,2,4]
--  1
--  >>> minsubarraysum [(-1),(-2),(-3)]
--  (-6)
minsubarraysum :: [Int] -> Int
minsubarraysum nums =","minsubarraysum :: [Int] -> Int
minsubarraysum nums = minimum $ scanl1 (\acc x -> min x (acc + x)) nums","
main :: IO ()
main = do
  let candidate = minsubarraysum
  if candidate [2,3,4,1,2,4] == 1 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error ""assertion failed""
  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error ""assertion failed""
  if candidate [0,10,20,1000000] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [10,11,13,8,3,4] == 3 then pure () else error ""assertion failed""
  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error ""assertion failed""
  if candidate [(-10)] == (-10) then pure () else error ""assertion failed""
  if candidate [7] == 7 then pure () else error ""assertion failed""
  if candidate [1,(-1)] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_115,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ 1: --‡§¨‡§ï‡•á‡§ü ‡§®‡•Ä‡§ö‡•á‡§Ç ‡§ï‡§∞‡§®‡•á ‡§ñ‡§æ‡§§‡§ø‡§∞ ‡§õ‡•Ç ‡§ú‡§º‡§∞‡•Ç‡§∞‡§§ ‡§®‡§Ç‡§¨‡§∞ ‡§Ü‡§â‡§ü‡§™‡•Å‡§ü.--‡§§‡•Å‡§π‡§Ç‡§ú‡•Ä ‡§ï‡§æ‡§Æ ‡§õ‡•á ‡§ï‡•Å‡§Ç‡§Ü‡§Ç ‡§ñ‡§æ‡§≤‡•Ä ‡§ï‡§∞‡§£ ‡§ñ‡§æ‡§§‡§∞ ‡§¨‡§ï‡•á‡§ü ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡§®‡§æ.--‡§§‡•í ‡§∏‡§æ‡§∞‡•Ü‡§Ø ‡§¨‡§ï‡•á‡§ü‡•í ‡§õ‡•á ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§ï‡§æ‡§™‡§æ‡§∏‡§ø‡§ü‡•Ä ‡§µ‡§æ‡§≤‡•ç‡§Ø‡•ç.--‡§π‡§∞ ‡§ï‡•Å‡§Ç‡§Ü‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§Ü‡§ñ‡§É ‡§¨‡§ï‡•á‡§ü ‡§Ø‡•Å‡§∏ ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§™‡§æ‡§®‡•Ä ‡§π‡§°‡§º‡§®‡•á ‡§ñ‡§æ‡§§‡§∞--‡§¨‡•á ‡§π‡§∞ 1 ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§∞‡•á‡§§‡§® ‡§™‡§æ‡§®‡•Ä ‡§Ø‡•Ç‡§®‡§ø‡§ü ‡§π‡§ø‡§∏‡§æ‡§¨--‡•á‡§Æ‡•ã ‡§¶‡•Ä‡§µ ‡§§‡•Å‡§Æ‡§® ‡§∞‡§ø‡§ü‡•á‡§Ç‡§ó‡•Å‡§≤‡§∞ ‡§ó‡•ç‡§∞‡§ø‡§° ‡§Ø‡•Å‡§∏ ‡§µ‡•á‡§≤ ‡§õ‡•Ä ,‡§π‡§∞ ‡§æ‡§ñ ‡§∞‡•å‡§∏ ‡§õ‡•Ä ‡§π‡§µ‡§® ‡§∏‡§ø‡§Ç‡§ó‡§≤ ‡§µ‡•á‡§≤--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1
--  6
--  Example 2:
--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2
--  5
--  Example 3:
--  >>> maxFill [[0,0,0],[0,0,0]] 5
--  0
--  Constraints:
--  * all wells have the same length
--  * 1 <= grid.length <= 10^2
--  * 1 <= grid[:,1].length <= 10^2
--  * grid[i][j] -> 0 | 1
--  * 1 <= capacity <= 10
maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity =","maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity = ceiling (fromIntegral totalWater / fromIntegral capacity)
  where
    totalWater = sum (map sum grid)","
main :: IO ()
main = do
  let candidate = maxFill
  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error ""assertion failed""
  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error ""assertion failed""
  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_116,kas_Deva,hs,"--‡§Ø‡§ø ‡§õ‡•Å ‡§Ø‡§ø‡§• ‡§ï‡§®‡§ø ‡§Ö‡§Æ‡§≤ ‡§ï‡§∞‡§®‡§ø ‡§Ø‡§ø‡§µ‡§æ‡§®:--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§§‡•á‡§Æ ‡§Ö‡§∏ ‡§µ‡§∞‡•Ä‡§Ø ,‡§§‡•á‡§Æ ‡§Ö‡§∏ ‡§°‡•á‡§∏‡•Ä‡§Æ‡§≤ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç ‡§™‡•á‡§† ‡§Ü‡§ß‡§æ‡§∞‡§ø‡§§--‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§è‡§™‡•ç‡§≤‡•Ä‡§ï‡•á‡§∂‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§µ‡§® ‡•á‡§Æ‡§® ‡§π‡§ø‡§®‡•ç‡§¶ ‡§¨‡§æ‡§á‡§®‡§∞‡•Ä ‡§∞‡§ø‡§™‡•ç‡§∞‡•á‡§ú‡•á‡§Ç‡§ü‡•á‡§∂‡§® ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§ï‡§æ‡§ü‡§æ ‡§õ‡•Ä ,‡§Ö‡§∏ ‡§õ‡•Ä ‡§ï‡§æ‡§∞‡§® ‡§∏‡•â‡§∞‡•ç‡§ü ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§®‡•â‡§® -‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§π‡§ø‡§∏‡§æ‡§¨--  >>> sortArray [1,5,2,3,4]
--  [1,2,3,4,5]
--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]
--  [(-6),(-5),(-4),(-3),(-2)]
--  >>> sortArray [1,0,2,3,4]
--  [0,1,2,3,4]
sortArray :: [Int] -> [Int]
sortArray arr =","import Data.Bits (popCount)
import Data.List (sortBy)

sortArray :: [Int] -> [Int]
sortArray arr = sortBy compareOnesAndValues arr
  where
    compareOnesAndValues x y =
      let onesX = popCount x
          onesY = popCount y
      in if onesX == onesY
         then compare x y
         else compare onesX onesY","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error ""assertion failed""
  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error ""assertion failed""
  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error ""assertion failed""
  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  pure ()"
HumanEval_117,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§®‡•ã‡§ü: ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§π‡•á‡§ï‡§ø‡§µ ‡§Æ‡§æ‡§®‡§Ø‡§• ‡§ú‡§º‡§ø ‡§á‡§®‡§™‡•Å‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§õ‡§ø ‡§∏‡§ø‡§∞‡§ø‡§´‡§º ‡§≤‡§´‡§º‡§ú‡§º ‡§§ ‡§∏‡•ç‡§™‡•á‡§∏ ‡§Ü‡§∏‡§æ‡§®‡•§--‡§Ö‡§ó‡§∞ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó s ‡§õ‡•Ç ‡§∞‡§ø‡§ï‡•ç‡§§ ‡§§‡•á‡§Æ ‡§µ‡§ï‡§º‡§§ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§∞‡§ø‡§ï‡•ç‡§§ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§≤‡§¨‡§®‡•Ä‡§ö.--n ‡§ï‡§Ç‡§∏‡•ã‡§®‡•á‡§Ç‡§ü‡•ç‡§∏, ‡§§‡§æ‡§ï‡§ø ‡§Ø‡•á ‡§≤‡§´‡§º‡§ú‡§º ‡§Ø‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Æ‡§Ç‡§ú‡§º ‡§≤‡§¨‡§®‡•Ä ‡§Ø‡•á‡§µ‡§æ.--‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§Ø‡•Å‡§∏ ‡§≤‡§´‡§º‡•ç‡§ú‡§º‡§® ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§≤‡§¨‡§®‡§π ‡§õ‡•Å ‡§Ø‡•Å‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Å ‡§Ø‡§• ‡§Æ‡§Ç‡§ú‡§º --‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä s ‡§§‡•á ‡§®‡•á‡§ö‡•Å‡§∞‡§≤ ‡§®‡§Ç‡§¨‡§∞ n ,‡§Ö‡§∏ ‡§ï‡§∞‡•ã ‡§§‡•Å‡§Æ ‡§§‡•à‡§∞‡§æ‡§ï‡•Ä--  >>> selectWords ""Mary had a little lamb"" 4
--  [""little""]
--  >>> selectWords ""Mary had a little lamb"" 3
--  [""Mary"",""lamb""]
--  >>> selectWords ""simple white space"" 2
--  []
--  >>> selectWords ""Hello world"" 4
--  [""world""]
--  >>> selectWords ""Uncle sam"" 3
--  [""Uncle""]
selectWords :: String -> Int -> [String]
selectWords s n =","selectWords :: String -> Int -> [String]
selectWords s n = filter (\word -> countConsonants word == n) (words s)
  where
    countConsonants = length . filter (`elem` consonants)
    consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ""","
main :: IO ()
main = do
  let candidate = selectWords
  if candidate ""Mary had a little lamb"" 4 == [""little""] then pure () else error ""assertion failed""
  if candidate ""Mary had a little lamb"" 3 == [""Mary"",""lamb""] then pure () else error ""assertion failed""
  if candidate ""simple white space"" 2 == [] then pure () else error ""assertion failed""
  if candidate ""Hello world"" 4 == [""world""] then pure () else error ""assertion failed""
  if candidate ""Uncle sam"" 3 == [""Uncle""] then pure () else error ""assertion failed""
  if candidate """" 4 == [] then pure () else error ""assertion failed""
  if candidate ""a b c d e f"" 1 == [""b"",""c"",""d"",""f""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_118,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§π‡•á‡§ï‡§ø‡§µ ‡§Æ‡§æ‡§®‡§Ø‡§• ‡§ú‡§º‡§ø ‡§¶‡§ø‡§§‡§ø‡§® ‡§∏‡§ü‡•ç‡§∞‡•á‡§®‡•ç‡§°‡•ç‡§∏ ‡§Æ‡•ç‡§®‡•ç‡§ú‡§º ‡§õ‡•Å ‡§∏‡§ø‡§∞‡§ø‡§´‡§º ‡§Ö‡§Ç‡§ó‡•ç‡§∞‡•á‡§ú‡•Ä ‡§≤‡§´‡•ç‡§ú‡§º‡•§--‡§ï‡•Å‡§Ç‡§§‡•á ‡§∏‡•ç‡§µ‡§∞ ‡§µ‡•Å‡§õ‡•ã ‡§Ø‡•á‡§Æ ‡§™‡•á‡§† ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§® ‡§õ‡•Ç ‡§Æ‡•Å‡§µ‡§æ‡§´‡§º‡§ø‡§ï‡§º.--‡§Ö‡§ó‡§∞ ‡§§‡•Å‡§π‡•ç‡§∏‡•Ä‡§Ç ‡§® ‡§ï‡§∞‡•ã‡§Ç ‡§§ ‡§§‡•Å‡§π‡•ç‡§∏‡•Ä‡§Ç ‡§∞‡§ø‡§ï‡•ç‡§§ ‡§§‡§æ‡§∞‡•Ç ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡•ã--‡§≤‡§´‡§º‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Å ‡§¶‡•ã‡§® ‡§ï‡•ã‡§®‡•ç‡§∏‡•ã‡§®‡§æ‡§ü‡§∏ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§¶‡§∞‡•á‡§Æ‡§ø‡§∏ ‡§§‡§∞‡§´‡§∏ ‡§™‡•á‡§† (‡§Æ‡§∂‡§π‡•Ç‡§∞ ‡§ï‡•á‡§∏ ‡§∏‡•á‡§∏‡§ø‡§ü‡§ø‡§µ) ‡•§--.‡§Ö‡§∏ ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§Ö‡§ï‡§ø ‡§≤‡§´‡•ç‡§ú‡§º ‡§¶‡§ø‡§µ‡§æ‡§® ‡§õ‡•Å‡•§ ‡§Ö‡§Æ‡§ø‡§ö‡§º ‡§ï‡§æ‡§Æ ‡§õ‡•á ‡§§‡§Æ‡§ø ‡§®‡§ú‡§º‡§¶‡•Ä‡§ï‡•Ä ‡§∏‡•ç‡§µ‡§∞ ‡§Ø‡§ø‡§Æ ‡§Ö‡§ï‡§ø ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§¶‡§∞‡§Æ‡§ø‡§Ø‡§æ‡§® ‡§õ‡§ø‡•§--  >>> getClosestVowel ""yogurt""
--  ""u""
--  >>> getClosestVowel ""FULL""
--  ""U""
--  >>> getClosestVowel ""quick""
--  """"
--  >>> getClosestVowel ""ab""
--  """"
getClosestVowel :: String -> String
getClosestVowel word =","getClosestVowel :: String -> String
getClosestVowel word = go (reverse word) False
  where
    vowels = ""aeiouAEIOU""
    go [] _ = """"
    go (x:xs) lastWasConsonant
      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False
      | x `notElem` vowels = go xs True
      | otherwise = go xs False","
main :: IO ()
main = do
  let candidate = getClosestVowel
  if candidate ""yogurt"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""full"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""easy"" == """" then pure () else error ""assertion failed""
  if candidate ""eAsy"" == """" then pure () else error ""assertion failed""
  if candidate ""ali"" == """" then pure () else error ""assertion failed""
  if candidate ""bad"" == ""a"" then pure () else error ""assertion failed""
  if candidate ""most"" == ""o"" then pure () else error ""assertion failed""
  if candidate ""ab"" == """" then pure () else error ""assertion failed""
  if candidate ""ba"" == """" then pure () else error ""assertion failed""
  if candidate ""quick"" == """" then pure () else error ""assertion failed""
  if candidate ""anime"" == ""i"" then pure () else error ""assertion failed""
  if candidate ""Asia"" == """" then pure () else error ""assertion failed""
  if candidate ""Above"" == ""o"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_119,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á ‡§ï‡§π‡§Å ‡§§‡•á ‡§Ö‡§∏‡§≤ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§¨‡§®‡§æ‡§Ø‡§ø‡§• ,‡§§‡•á‡§Æ ‡§™‡§æ‡§§ ‡§Ö‡§∏ ‡§®‡•á ‡§ï‡§π‡§Å ‡§§‡•á--"" ((()) "" ‡§õ‡•Å‡§Ç.--‡§Ø‡§ø‡§•‡§™‡§æ‡§®‡•ç‡§†‡§É ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó '(((() ' ‡§õ‡•Å ‡§Ö‡§∏‡§≤, ‡§Ø‡•á‡§≤‡§ø ‡§ú‡§º‡§® ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó --‡§Ö‡§ñ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§è‡§∏ ‡§õ‡•Ç ‡§ó‡•Å‡§° ‡§Æ‡§æ‡§®‡§æ‡§® ‡§Ö‡§ó‡§∞ ‡§§‡•á‡§Æ ‡§§‡•á ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§Ö‡§ó‡§∞ ‡§è‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§∏‡§∞‡•á ‡§ï‡•Å‡§è‡§Ç ‡§§‡•á‡§Æ --‡§ï‡§π‡§Å ‡§§‡•á ‡§ë‡§∞‡•ç‡§°‡§∞ ,‡§Ø‡•Å‡§∏ ‡§®‡§§‡•Ä‡§ú ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä ‡§Ö‡§∏‡§≤--‡§§‡•Å‡§π‡§ø‡§Ç‡§¶ ‡§ï‡§æ‡§Æ ‡§õ‡•Ç ‡§Ø‡•á ‡§ö‡•á‡§ï ‡§ï‡§∞‡§®‡•Å‡§ï ‡§ï‡§ø ‡§ï‡•ç‡§Ø‡§æ ‡§Ø‡•á ‡§Æ‡•Å‡§Æ‡§ï‡§ø‡§® ‡§õ‡•Ç ‡§ï‡§ø ‡§ú‡§º‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§á‡§®‡§ï‡§ö‡•á‡§®‡•á‡§° ‡§ï‡§∞‡§®‡•á.--‡§∏‡§ø‡§∞‡•ç‡§´ ‡§¨‡•ç‡§∞‡•à‡§Ç‡§ü‡•á‡§ï‡•ç‡§∏ "" (("" ‡§Ø‡§æ ‡§¨‡§Ç‡§¶ ‡§¨‡•ç‡§∞‡•à‡§Ç‡§ü‡•á‡§ï‡•ç‡§∏ "")) ""---- ‡§§‡•Å‡§Æ ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§Ü‡§ñ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ú‡§º‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ,‡§ú‡§º‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§® ‡§ì‡§™‡•á‡§®--  >>> matchParens [""()("","")""]
--  ""Yes""
--  >>> matchParens ["")"","")""]
--  ""No""
matchParens :: [String] -> String
matchParens lst =","matchParens :: [String] -> String
matchParens [a, b] =
    if isValid (a ++ b) || isValid (b ++ a) then ""Yes"" else ""No""
  where
    isValid :: String -> Bool
    isValid = go 0
      where
        go 0 [] = True
        go _ [] = False
        go n (x:xs)
            | x == '('  = go (n + 1) xs
            | x == ')'  = n > 0 && go (n - 1) xs
    isValid _ = False","
main :: IO ()
main = do
  let candidate = matchParens
  if candidate [""()("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"","")""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()(())"",""())())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")())"",""(()()(""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(())))"",""(()())((""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""()"",""())""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()("",""()))()""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(((("",""((())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")(()"",""(()(""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")("","")(""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"",""(""] == ""Yes"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_120,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ 1: --‡§Ø‡•Å‡§∏ ‡§≤‡•ã‡§Ç‡§ó‡§• k ‡§õ‡•Ä ‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ k ‡§®‡•Å‡§Æ‡•ç‡§¨‡§∞‡§Ç arr ‡§Æ‡§Ç‡§ú‡§º--‡§Ø‡•Å‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä arr ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§¨‡•Ä k ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ,‡§∏‡•Å ‡§õ‡•Ä ‡§∏‡•Å ‡§µ‡§æ‡§™‡§ø‡§∏ ‡§ï‡§æ‡§∞‡§® ‡§∏‡•â‡§∞‡•ç‡§ü--  >>> maximum [(-3),(-4),5] 3
--  [(-4),(-3),5]
--  Example 2:
--  >>> maximum [4,(-4),4] 2
--  [4,4]
--  Example 3:
--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1
--  [2]
--  Note:
--  1. The length of the list will be in the range of [1, 1000].
--  2. The elements in the list will be in the range of [-1000, 1000].
--  3. 0 <= k <= len(arr)
maximum :: [Int] -> Int -> [Int]
maximum arr k =","maximum :: [Int] -> Int -> [Int]
maximum arr k = take k $ reverse $ sort arr","
main :: IO ()
main = do
  let candidate = maximum
  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error ""assertion failed""
  if candidate [4,(-4),4] 2 == [4,4] then pure () else error ""assertion failed""
  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error ""assertion failed""
  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error ""assertion failed""
  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error ""assertion failed""
  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error ""assertion failed""
  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error ""assertion failed""
  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error ""assertion failed""
  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error ""assertion failed""
  if candidate [(-10),10] 2 == [(-10),10] then pure () else error ""assertion failed""
  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_121,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§Ö‡§ñ ‡§®‡•â‡§®-‡§è‡§Æ‡§ø‡§ï‡§≤ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§®,‡§§‡•á‡§Æ ‡•Å‡§Æ‡§® ‡§π‡§ø‡§®‡•ç‡§¶‡§∏ ‡§ë‡§≤ ‡§Ö‡§®‡§° ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§Ö‡§¶‡•ç‡§¶‡§ø‡§§‡•Ä ‡§¶‡•á‡§µ‡§® ‡§Ø‡•á‡§Æ ‡§ú‡§º‡•á ‡§™‡•â‡§ú‡§ø‡§∂‡§® ‡§Æ‡§Ç‡§ú‡§º ‡§Ö‡§∏.--  >>> solution [5,8,7,1]
--  12
--  >>> solution [3,3,3,3,3]
--  9
--  >>> solution [30,13,24,321]
--  0
solution :: [Int] -> Int
solution lst =","solution :: [Int] -> Int
solution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","
main :: IO ()
main = do
  let candidate = solution
  if candidate [5,8,7,1] == 12 then pure () else error ""assertion failed""
  if candidate [3,3,3,3,3] == 9 then pure () else error ""assertion failed""
  if candidate [30,13,24,321] == 0 then pure () else error ""assertion failed""
  if candidate [5,9] == 5 then pure () else error ""assertion failed""
  if candidate [2,4,8] == 0 then pure () else error ""assertion failed""
  if candidate [30,13,23,32] == 23 then pure () else error ""assertion failed""
  if candidate [3,13,2,9] == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_122,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ø‡•Å‡§∏ ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§∏‡•Å‡§Æ‡•ç‡§Æ ‡§õ‡•Ä ‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§ú‡§º‡•á ‡§°‡§ø‡§ú‡§ø‡§ü ‡§ó‡•ã‡§¶‡§®‡•Ä‡§ö k ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§™‡•á‡§† arr--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡•ã ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ arr ‡§§‡•á k ,‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§Ö‡§∏ ‡§µ‡§æ‡§™‡§ø‡§∏ ‡§ï‡§æ‡§∞‡§®--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4
--  24
--  Constraints:
--  1. 1 <= len(arr) <= 100
--  2. 1 <= k <= len(arr)
addElements :: [Int] -> Int -> Int
addElements arr k =","addElements :: [Int] -> Int -> Int
addElements arr k = sum $ filter (\x -> x >= -99 && x <= 99) $ take k arr","
main :: IO ()
main = do
  let candidate = addElements
  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error ""assertion failed""
  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error ""assertion failed""
  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error ""assertion failed""
  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error ""assertion failed""
  if candidate [1] 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_123,kas_Deva,hs,"--get_odd_collatz(5) ‡§∞‡§ø‡§ü‡§∞‡•ç‡§®‡§∏ [1, 5] # ‡§ï‡•ã‡§≤‡§æ‡§ü‡•ç‡§ú‡§º ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§´‡•â‡§∞ 5 ‡§á‡§∏ [5, 16, 8, 4, 2, 1], ‡§∏‡•ã ‡§•‡•á‡§™‡•á‡§∞ ‡§®‡§Ç‡§¨‡§∞‡•ç‡§∏ ‡§Ö‡§∞‡•á ‡§ì‡§®‡§≤‡•Ä 1, ‡§è‡§Ç‡§° 5. --‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --2. ‡§Ü‡§µ‡§∞‡•ç‡§§‡§ø‡§§ ‡§∏‡•Ç‡§ö‡•Ä ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ ‡§ï‡•ç‡§∞‡§Æ--1. ‡§ï‡•ã‡§≤‡§æ‡§ü‡•ç‡§ú‡§º (‡•ß) ‡§õ‡•Å [1]‡•§--‡§®‡•ã‡§ü‡§É --‡§Ø‡•Å‡§∏ ‡§ï‡§ú‡•á‡§ï‡•ç‡§ü‡•Å‡§∞‡§∏ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§ï‡•Ä ‡§® ‡§ï‡•Ä ‡§ï‡•Ä ‡§µ‡§∞‡•Ä‡§Ø‡§§‡§æ n ,‡§∏‡•Å ‡§õ‡•Ä ‡§π‡§Æ‡•á‡§∂‡§æ 1 ‡§∞‡§ü‡§®--‡§Ö‡§ó‡§∞ ‡§ó‡•ã‡§°‡§®‡§ø‡§ï‡§ø ‡§≤‡§´‡•ç‡§ú‡§º ‡§õ‡•Å ‡§Ö‡§®‡§°, ‡§§‡•ã ‡§¨‡•á‡§Ø‡§ø ‡§≤‡§´‡•ç‡§ú‡§º ‡§õ‡•Å 3 ‡§ó‡•â‡§∞ ‡§¨‡•ç‡§∞‡•ã‡§®‡•ç‡§π ‡§ï‡•Å‡§®‡•§--‡§Ö‡§ó‡§∞ ‡§™‡•ç‡§∞‡•á‡§ó‡•ç‡§®‡•á‡§Ç‡§ü ‡§õ‡•Ä ,‡§§‡§Æ‡•Å‡§ï ‡§®‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ü‡§∞‡•ç‡§Æ ‡§õ‡•Ä ‡§π‡§æ‡§´ --‡§Ø‡•á ‡§õ‡•Ä ‡§Ö‡§∏ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§æ‡§∞‡§® ‡§ï‡•Å‡§è‡§Ç ‡§§‡•á ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§∏‡•á‡§• .--‡§ï‡•ã‡§≤‡§æ‡§ü‡•ç‡§ú‡§º ‡§ï‡§Ç‡§ú‡•á‡§ï‡•ç‡§ü‡•Å‡§∞‡•á ‡§õ‡•Ä ‡§Æ‡•à‡§•‡§Æ‡•à‡§ü‡§ø‡§ï‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§Ø‡•Å‡§∏ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§°‡§ø‡§´‡§æ‡§á‡§® ‡§ï‡§∞‡§®‡•á--‡§Ø‡•Å‡§∏ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§® ‡§∏‡•Ç‡§∞‡•ç‡§ü ‡§Ø‡•Å‡§∏ ‡§Ö‡§∏ ‡§®‡•á ‡§Ö‡§∏ ‡§è‡§µ‡§Ç ‡§ï‡•ã‡§≤‡§æ‡§ü‡•ç‡§ú‡§º ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º--  >>> getOddCollatz 5
--  [1,5]
getOddCollatz :: Int -> [Int]
getOddCollatz n =","getOddCollatz :: Int -> [Int]
getOddCollatz n = sort . filter odd $ collatzSequence n
  where
    collatzSequence 1 = [1]
    collatzSequence x
      | even x    = x : collatzSequence (x `div` 2)
      | otherwise = x : collatzSequence (3 * x + 1)","
main :: IO ()
main = do
  let candidate = getOddCollatz
  if candidate 14 == [1,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 5 == [1,5] then pure () else error ""assertion failed""
  if candidate 12 == [1,3,5] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_124,kas_Deva,hs,"--4. ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü ‡§Æ‡•á ‡§π‡•ã‡§®‡•Ä ‡§ö‡§æ‡§π‡§ø‡§Ø‡•á: mm-dd-yyyy --3. ‡§Ø‡•á ‡§π‡§ï‡•ã ‡§® 1 ‡§Æ‡§Ç‡§•‡•ç‡§∏ ‡§®‡§ø‡§∑‡•ç ‡§ï‡§Æ ‡§Ø‡§æ 12 ‡§Æ‡§Ç‡§•‡•ç‡§∏ ‡§ñ‡•ã‡§§ ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§Ö‡§∏‡§ø‡§•--2. ‡§¶‡§ø‡§®‡§® ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§§‡§æ‡§¶‡§æ‡§¶ ‡§õ‡•á 1,3,5,7,8,10,12 ‡§Æ‡§Ç‡§•‡§® ‡§ñ‡§æ‡§§‡•ç‡§∞‡§ø 1 ‡§ï‡§Æ ‡§Ø‡§æ 31 ‡§¶‡§ø‡§®‡§® ‡§ñ‡•ã‡§§ ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶ ‡§Ü‡§∏‡§æ‡§®‡•§ ‡§§ ‡§¶‡§ø‡§®‡§® ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§§‡§æ‡§¶‡§æ‡§¶ ‡§õ‡•á 4,6,9,11 ‡§Æ‡§Ç‡§•‡§® ‡§ñ‡§æ‡§§‡•ç‡§∞‡§ø 1 ‡§ï‡§Æ ‡§Ø‡§æ 30 ‡§¶‡§ø‡§®‡§® ‡§ñ‡•ã‡§§ ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶ ‡§Ü‡§∏‡§æ‡§®‡•§ ‡§§, ‡§Æ‡§æ‡§π 2 ‡§ñ‡§æ‡§§‡•ç‡§∞‡§ø ‡§¶‡§ø‡§®‡§® ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§§‡§æ‡§¶‡§æ‡§¶ ‡§õ‡•á 1 ‡§ï‡§Æ ‡§Ø‡§æ 29 ‡§¶‡§ø‡§®‡§® ‡§ñ‡•ã‡§§ ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶ ‡§Ü‡§∏‡§æ‡§®‡•§--1. ‡§°‡•á‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ç ‡§® ‡§ñ‡§æ‡§≤‡•Ä.--‡§Ö‡§ó‡§∞ ‡§è‡§è‡§Æ ‡§§‡§Æ‡§æ‡§Æ ‡§∞‡•Ç‡§≤‡§® ‡§π‡§ø‡§Ç‡§ú ‡§™‡§æ‡§≤‡§®‡§æ ‡§õ‡•Ç ‡§Ø‡•á‡§µ‡§æ ‡§ï‡§∞‡§®‡•á ‡§§‡•á‡§Æ ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§õ‡•Ç ‡§µ‡•à‡§≤‡§ø‡§° ‡§Ø‡•á‡§µ‡§æ ‡§ï‡§∞‡§®‡•á:--‡§Ö‡§ó‡§∞ ‡§°‡•á‡§ü ‡§µ‡•à‡§≤‡§ø‡§° ‡§õ‡•Ç ‡§§‡•á‡§Æ ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§∞‡§æ,‡§Ö‡§ó‡§∞ ‡§µ‡•à‡§≤‡§ø‡§° ‡§õ‡•Å‡§Ç ‡§§‡•á‡§Æ ‡§õ‡•Ç ‡§ó‡§≤‡§§.--‡•á‡§Æ ‡§õ‡•Ä ‡§Ö‡§∏ ‡§™‡§®‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§µ‡§® ‡§ï‡•Ä ‡§Ö‡§∏ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡§ï‡•ã ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡§ø‡§•--  >>> validDate ""03-11-2000""
--  True
--  >>> validDate ""15-01-2012""
--  False
--  >>> validDate ""04-0-2040""
--  False
--  >>> validDate ""06-04-2020""
--  True
--  >>> validDate ""06/04/2020""
--  False
validDate :: String -> Bool
validDate date =","import Text.Read (readMaybe)
import Data.List.Split (splitOn)

validDate :: String -> Bool
validDate date =
    case splitOn ""-"" date of
        [m, d, y] -> isValidMonthDayYear m d y
        _         -> False

isValidMonthDayYear :: String -> String -> String -> Bool
isValidMonthDayYear m d y =
    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of
        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day
        _ -> False

isValidMonth :: Int -> Bool
isValidMonth month = month >= 1 && month <= 12

isValidDay :: Int -> Int -> Bool
isValidDay month day
    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31
    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30
    | month == 2                           = day >= 1 && day <= 29
    | otherwise                            = False","
main :: IO ()
main = do
  let candidate = validDate
  if candidate ""03-11-2000"" == True then pure () else error ""assertion failed""
  if candidate ""15-01-2012"" == False then pure () else error ""assertion failed""
  if candidate ""04-0-2040"" == False then pure () else error ""assertion failed""
  if candidate ""06-04-2020"" == True then pure () else error ""assertion failed""
  if candidate ""01-01-2007"" == True then pure () else error ""assertion failed""
  if candidate ""03-32-2011"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""04-31-3000"" == False then pure () else error ""assertion failed""
  if candidate ""06-06-2005"" == True then pure () else error ""assertion failed""
  if candidate ""21-31-2000"" == False then pure () else error ""assertion failed""
  if candidate ""04-12-2003"" == True then pure () else error ""assertion failed""
  if candidate ""04122003"" == False then pure () else error ""assertion failed""
  if candidate ""20030412"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04-12"" == False then pure () else error ""assertion failed""
  if candidate ""04-2003"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_126,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡§®‡§Ç‡§¨‡§∞, ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® False. ‡§®‡•ã ‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§®‡§Ç‡§¨‡§∞‡•ç‡§∏ ‡§§‡•á ‡§∏‡§ø‡§Ç‡§ó‡§≤ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏.--‡§Ö‡§ó‡§∞ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§Ö‡§ï‡§ø‡§∏ ‡§ñ‡•ã‡§§ ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§°‡•Å‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§ü ‡§Ü‡§∏ --‡•á‡§ï ‡§®‡§Ç‡§¨‡§∞ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¶‡•á‡§µ‡§® ‡•á‡§µ‡§æ,‡§§‡•á‡§Æ ‡§Ö‡§∏ ‡•Å‡§∞‡•ç‡§§‡•á‡§° ‡§Ø‡§æ ‡§®--  >>> isSorted [5]
--  True
--  >>> isSorted [1,2,3,4,5]
--  True
--  >>> isSorted [1,3,2,4,5]
--  False
--  >>> isSorted [1,2,3,4,5,6]
--  True
--  >>> isSorted [1,2,3,4,5,6,7]
--  True
--  >>> isSorted [1,3,2,4,5,6,7]
--  False
--  >>> isSorted [1,2,2,3,3,4]
--  True
--  >>> isSorted [1,2,2,2,3,4]
--  False
isSorted :: [Int] -> Bool
isSorted lst =","isSorted :: [Int] -> Bool
isSorted lst = go lst Nothing
  where
    go [] _ = True
    go [x] _ = True
    go (x:y:xs) prev
      | x > y = False
      | x == y && prev == Just x = False
      | otherwise = go (y:xs) (Just x)","
main :: IO ()
main = do
  let candidate = isSorted
  if candidate [5] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,7] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  if candidate [1] == True then pure () else error ""assertion failed""
  if candidate [3,2,1] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,2,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,3,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,3,3,4] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_127,kas_Deva,hs,"--[‡§á‡§®‡§™‡•Å‡§ü/‡§Ü‡§â‡§ü‡§™‡•Å‡§ü] ‡§∏‡•à‡§Ç‡§™‡§≤‡§É --‡§Ö‡§ó‡§∞ ‡§ú‡§º‡•á ‡§á‡§Ç‡§ü‡§∞‡§µ‡§≤ ‡§õ‡§æ‡§® ‡§á‡§Ç‡§ü‡§∞‡§∏‡•á‡§ï‡•ç‡§ü ‡§ï‡§æ‡§∞‡§® ,‡§§‡•á‡§Æ ‡§õ‡•Ä ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§æ‡§∞‡§® ""NO""--‡§Ö‡§ó‡§∞ ‡§®‡•á ‡§Ö‡§∏‡§ø‡§• ,‡§§‡•á‡§≤ ‡§ï‡§∞‡•ã ""NO""--‡§Ö‡§ó‡§∞ ‡§á‡§Ç‡§ü‡§∞‡§∏‡•á‡§ï‡•ç‡§∂‡§®‡§® ‡§π‡§ø‡§Ç‡§ú ‡§≤‡•á‡§Ç‡§• ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ç,‡§§‡•á‡§≤ ‡§õ‡•Ç ‡§Ø‡•á ""YES"" ‡§≤‡§¨‡§®‡•Ä.--‡§Ø‡•Å‡§∏ ‡§≤‡•ã‡§Ç‡§ó‡•Ä ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä 1 ,‡§∏‡•Å ‡§õ‡•Ä ‡§®‡•á ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞ ‡§™‡•á‡§† ,‡§Ø‡•Å‡§∏ ‡§á‡§Ç‡§ü‡§∞‡§∏‡•á‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§á‡§Ç‡§ü‡§∞‡§µ‡•á‡§≤‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ (1, 3), (2, 4) ‡§õ‡•Ç (2, 3)--‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§Ö‡§∏ ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞--‡§§‡•ã‡§Ø ‡§õ‡•Ä ‡§à‡§µ‡§æ ‡§µ‡§æ‡§®‡§® ‡§ï‡•Ä ‡§ï‡•ç‡§Ø‡§æ ‡§õ‡•Ä ‡§á‡§Ç‡§ü‡§∞‡§∏‡•á‡§ï‡•ç‡§∂‡§® ‡§¶‡•Å‡§®‡§ø‡§Ø‡•ã‡§ï--‡§π‡§∞ ‡§Ü‡§ñ‡§É ‡§µ‡§ñ‡§§‡•Å‡§ï ‡§ñ‡§æ‡§§‡§ø‡§∞ ,‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§Æ‡§æ‡§®‡§æ ‡§ï‡•Ä ‡§è‡§Æ‡•Ç‡§ï ‡§∂‡•Å‡§∞‡•Ç ‡§õ‡•Ç ‡§ï‡§Æ ‡§Ø‡§æ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§è‡§Æ‡•Ç‡§ï ‡§ñ‡§§‡§Æ--‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§∂‡•Å‡§∞‡•Ç ‡§§‡•á ‡§ñ‡§º‡§§‡§Æ ‡§¶‡•Ç‡§®--‡§¶‡•á‡§Ö‡§∞ ‡§á‡§Ç‡§ü‡§∞‡§µ‡§≤‡•ç‡§∏ ‡§Ö‡§∞‡•á ‡§ï‡•ç‡§≤‡•ã‡§ú‡•ç‡§° ‡§µ‡•ç‡§π‡§ø‡§ö ‡§Æ‡•Ä‡§®‡•ç‡§∏ ‡§•‡•á ‡§á‡§Ç‡§ü‡§∞‡§µ‡§≤‡•ç‡§∏ (‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü, ‡§è‡§Ç‡§°)--‡§Ø‡§ø‡§§ ‡§õ‡•Ä ‡§π‡§∞ ‡§á‡§Ç‡§ü‡•á‡§∞‡§ø‡§Ö‡§≤ ‡§Ü‡§Å‡§ñ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§ú‡•ã‡§°‡§º‡•Ä ,‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞ ,‡§á‡§Ç‡§ü‡§∞‡§µ‡§≤ = (‡§∂‡•Å‡§∞‡•Ç ,‡§Ö‡§Ç‡§§) = (1,2)--‚û°Ô∏è‡§§‡•Å‡§Æ‡§® ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§ú‡§º‡•á ‡§á‡§Ç‡§ü‡§∞‡§µ‡§≤ ,--  >>> intersection (1, 2) (2, 3)
--  ""NO""
--  >>> intersection ((-1), 1) (0, 4)
--  ""NO""
--  >>> intersection ((-3), (-1)) ((-5), 5)
--  ""YES""
intersection :: (Int, Int) -> (Int, Int) -> String
intersection interval1 interval2 =","intersection :: (Int, Int) -> (Int, Int) -> String
intersection (start1, end1) (start2, end2) = 
    if intersectionLength > 0 && isPrime intersectionLength
    then ""YES""
    else ""NO""
  where
    intersectionStart = max start1 start2
    intersectionEnd = min end1 end2
    intersectionLength = intersectionEnd - intersectionStart + 1
    
    isPrime :: Int -> Bool
    isPrime n
      | n <= 1 = False
      | n == 2 = True
      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","
main :: IO ()
main = do
  let candidate = intersection
  if candidate (1, 2) (2, 3) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-1), 1) (0, 4) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-3), (-1)) ((-5), 5) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-2), 2) ((-4), 0) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-11), 2) ((-1), (-1)) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (3, 5) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (1, 2) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-2), (-2)) ((-3), (-2)) == ""NO"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_128,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§®‡•ã‡§ü: ‡§∞‡§ø‡§ï‡•ç‡§§ ‡§Ü‡§∞‡§∞ ‡§ñ‡§æ‡§§‡§∞ ‡§õ‡•Å‡§Ç ‡§ï‡§π‡§Å ‡§§‡•á ‡§≤‡§µ‡§®--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§π‡§µ‡§® 1 , - 1 ‡§Ø‡§æ 0--‡•á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§Æ‡•à‡§ó‡•ç‡§®‡§ø‡§ü‡•ç‡§Ø‡•Ç‡§° ‡§Ø‡•Å‡§∏ ‡§ú‡§º‡§∞‡§æ‡§¨ ‡§õ‡•Ç ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§ë‡§´‡§º ‡§∏‡§≤‡•Ä‡§Æ ‡§®‡§ø‡§∂‡§æ‡§®‡§® ‡§π‡•Å‡§®‡•ç‡§¶--‡§∏‡§≤‡•Ä‡§Æ ‡§∂‡•Å‡§Æ‡§æ‡§∞‡§® ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•á ‡§Ø‡§ø‡§µ‡§æ‡§® ‡§ï‡§∞‡§®‡•ç‡§π ‡§§ ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§õ‡•Å‡§® ‡§µ‡§æ‡§™‡§∏ --  >>> prodSigns [1,2,2,(-4)]
--  Just (9)
--  >>> prodSigns [0,1]
--  Just (0)
--  >>> prodSigns []
--  Just (Nothing)
prodSigns :: [Int] -> Maybe Int
prodSigns arr =","prodSigns :: [Int] -> Maybe Int
prodSigns [] = Nothing
prodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","
main :: IO ()
main = do
  let candidate = prodSigns
  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error ""assertion failed""
  if candidate [0,1] == Just (0) then pure () else error ""assertion failed""
  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error ""assertion failed""
  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,0] == Just (0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_129,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§£‡•Ç‡§á‡§ï ‡§ë‡§∞‡•ç‡§°‡§∞‡•ç‡§° ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ë‡§´‡§º ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç‡§ú ‡§ì‡§® ‡§•‡•á ‡§∏‡•á‡§≤‡•ç‡§∏ ‡§†‡§æ‡§ü ‡§•‡•á ‡§Æ‡§ø‡§®‡§ø‡§Æ‡§Æ ‡§™‡§æ‡§• ‡§ó‡•á‡§ü‡•ç‡§∏ ‡§•‡•ç‡§∞‡•Ç.--‡§Ø‡•á ‡§õ‡•Ä ‡§ó‡§æ‡§∞‡§®‡•ç‡§ü‡•Ä ‡§ï‡§æ‡§∞‡§£ ‡§ï‡•Ä ‡§ú‡§µ‡§æ‡§¨ ‡§õ‡•Ä ‡§Ø‡•Ç‡§®‡§ø‡§ï--lst_A[j] = lst_B[j]‡•§--‡§Ø‡§ø‡§• ‡§ï‡§®‡§ø ‡§ú‡§º‡•ç‡§® lst_A[i] < lst_B[i] ‡§§ ‡§ï‡•Å‡§®‡§ø j (1 <= j < i) ‡§¨‡§æ‡§™‡§• ‡§õ‡§ø --lst_B ‡§ñ‡•ã‡§§,‡§¨‡§æ‡§ï‡§ø ‡§≤‡§´‡§º‡•ç‡§ú‡§º‡•á‡§Ç ‡§Æ‡§Ç‡§ú‡§º,‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ç ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§Æ‡•å‡§ú‡•Ç‡§¶ (1 <= i <= k)--‡§∏‡•Ö‡§π‡•ç ‡§õ‡•Å ‡§≤‡§ï‡•ç‡§∏‡§ø‡§ï‡•ã‡§ó‡•ç‡§∞‡§æ‡§´‡§º‡§ø‡§Ø‡•â‡§∞‡•Ä ‡§§‡•ã‡§∞ ‡§ï‡§Æ‡•§--‡§Ø‡§ø‡§≤ ‡§Ö‡§∏ ‡§è‡§µ‡§Ç ‡§ë‡§∞‡•ç‡§°‡§∞‡§ø‡§Ç‡§ó ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¨‡§®‡§æ‡§µ‡§®‡•á ‡§∏‡•á‡§≤ ‡§™‡•á‡§† ‡§Ø‡§Æ A ‡§¨‡•á B ‡•á‡§Æ‡§® ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç--‡§Ø‡•Å‡§∏ ‡§™‡§• A (‡§≤‡§Æ‡•ç‡§¨‡§æ‡§à k) ‡§õ‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§Æ‡§æ‡§®‡§æ ‡§≤‡§ï‡•Å‡§ü ‡§™‡§• B (‡§≤‡§Æ‡•ç‡§¨‡§æ‡§à k) ‡§ñ‡•ã‡§§ ‡§Ö‡§ó‡§∞ --‡§§‡•Å‡§π ‡§π‡§ï‡•ã‡§µ ‡§®‡•á ‡§ó‡•ç‡§∞‡§ø‡§°‡§∏ ‡§®‡§ø‡§∂ ‡§ó‡§∏‡§ø‡§•--‡§ú‡§º‡§∞‡•Ç‡§∞‡•Ä ‡§§‡•ã‡§∞ ‡§Æ‡•Å‡§ñ‡•ç‡§§‡§≤‡§ø‡§´) ‡•§--‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡•ã‡§ü ‡§ï‡§∞‡§ø‡§µ ‡§ú‡§º‡§ø ‡§Ö‡§ñ ‡§≤‡§®‡•ç‡§ó k ‡§™‡§•‡•Å‡§ï ‡§Æ‡§§‡§≤‡§¨ ‡§õ‡•Å ‡§ï‡§ø ‡§Ø‡§ø ‡§õ‡•Å ‡§¨‡§ø‡§≤‡§ï‡•Å‡§≤ k ‡§∏‡•á‡§≤ (‡§® ‡§ï‡§ø --‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£--‡•á‡§Æ‡§® ‡§π‡§Ç‡§¶‡§ø ‡§®‡§µ‡§ø‡§∂‡§® ‡§π‡§ø‡§Ø‡§ø‡§Ç‡§¶‡§ø ‡§®‡§µ‡§ø‡§∂‡§® ‡§π‡§ø‡§Ø‡§ø‡§Ç‡§¶‡§ø ‡§®‡§µ‡§ø‡§∂‡§® ‡§π‡§ø‡§Ø‡§ø‡§Ç‡§¶‡§ø ‡§®‡§µ‡§ø‡§∂‡§® ‡§π‡§ø‡§Ø‡§ø‡§Ç‡§¶‡§ø ‡§®‡§µ‡§ø‡§∂‡§® ‡§π‡§ø‡§Ø‡§ø‡§Ç‡§¶‡§ø ‡§®‡§µ‡§ø‡§∂‡§® ‡§π‡§ø‡§Ø‡§ø‡§Ç‡§¶‡§ø ‡§®‡§µ‡§ø‡§∂‡§®--‡§ï‡•Å‡§Ç‡§§‡•á ‡§∏‡•á‡§≤ ‡§™‡•á‡§† ,‡§¨‡•á ‡§ï‡•Å‡§Ç‡§§‡•á ‡§∏‡•ç‡§ü‡•á‡§™ ‡§™‡•á‡§† ‡§§‡•Å‡§π ‡§π‡§ï‡§º ‡§ï‡•Å‡§® ‡§§‡•á ‡§®‡•á‡§¨‡§∞ ‡§∏‡•á‡§≤ ‡§™‡•á‡§† ‡§∞‡§ü‡§® ,--‡§§‡•Å‡§Æ‡•ã ‡§ï‡§∞‡•ã‡§ñ ‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞ ‡§™‡§• ‡§™‡§• k--‡§á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§è‡§µ‡§Ç ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡§®‡•á ‡§ó‡•ç‡§∞‡§ø‡§° ‡§™‡•á‡§†--‡§π‡§∞ ‡§∏‡•á‡§≤ ‡§õ‡•Ä ‡§Ü‡§∏‡§æ‡§® ‡§µ‡•á‡§≤‡•ç‡§Ø‡•Ç‡§ú ,‡§á‡§Ç‡§ü‡§∞‡§ú‡§∞ ‡§õ‡•Ä ‡§∞‡•á‡§Ç‡§ú ‡§Æ‡§Ç‡§ú‡§º [1, N * N]--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§ó‡•ç‡§∞‡§ø‡§° ‡§õ‡•Ä ‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä N ‡§∞‡•Ç‡§≤ ‡§¨‡•á N ‡§ï‡•â‡§≤‡§Æ (N >= 2) ‡§¨‡•á ‡§õ‡•Ä ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ k ,--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3
--  [1,2,1]
--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1
--  [1]
minpath :: [[Int]] -> Int -> [Int]
minpath grid k =","import Data.List (sort, sortBy)
import Data.Ord (comparing)
import Control.Monad (guard)

minpath :: [[Int]] -> Int -> [Int]
minpath grid k = head $ sort paths
  where
    n = length grid
    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]
    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
      where
        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n
    value (r, c) = grid !! r !! c
    paths = do
      start <- cells
      findPaths k [start]
    findPaths 1 path = return $ map value path
    findPaths l path@(current:_) = do
      next <- neighbors current
      findPaths (l-1) (next : path)","
main :: IO ()
main = do
  let candidate = minpath
  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error ""assertion failed""
  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error ""assertion failed""
  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error ""assertion failed""
  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error ""assertion failed""
  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error ""assertion failed""
  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error ""assertion failed""
  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_130,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§ó‡•ã‡§°‡•ç‡§®‡•Å‡§ñ n + 1 ‡§®‡§Ç‡§¨‡§∞ ‡§ü‡•ç‡§∞‡§æ‡§á‡§¨‡•ã‡§®‡§æ‡§ö‡•Ä ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏‡•Å‡§ï--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡•á‡§µ‡§® ,‡§§‡•ã‡§≤ ‡§ó‡§∏‡§£ ‡§Ö‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§≤‡§´‡§º‡•ç‡§ú‡§º --= 2 + 3 + 3 = 8 --‡§§‡•ç‡§∞‡§ø‡§ï‡•Å‡§£‡•ç‡§° (3) = ‡§§‡•ç‡§∞‡§ø‡§ï‡•Å‡§£‡•ç‡§° (2) + ‡§§‡•ç‡§∞‡§ø‡§ï‡•Å‡§£‡•ç‡§° (1) + ‡§§‡•ç‡§∞‡§ø‡§ï‡•Å‡§£‡•ç‡§° (4)--tri(4) = 3 --‡§§‡•ç‡§∞‡§ø‡§ï‡•Å‡§£‡•ç‡§°‡§ø‡§ï‡•Å‡§£‡•ç‡§° = ‡•ß + (‡•® / ‡•®) = ‡•® --‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ‡§Ö‡§ó‡§∞ n ‡§Ö‡§™‡§∞ ‡§õ‡•Ç.--‡§Ö‡§ó‡§∞ n ‡§õ‡•Ç ‡§ú‡§º‡•á‡§¶ ‡§§‡•á ,‡§§‡§π ‡§õ‡•Ä n = 1 + n / 2--tri(1) = 3 --‡§ü‡•ç‡§∞‡§æ‡§á‡§¨‡•ã‡§®‡•à‡§ï‡•Ä ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§õ‡•Å ‡§Ø‡§ø‡§Æ‡•ç‡§® ‡§∞‡§ø‡§∏‡•Ä‡§µ‡§∞‡§®‡•ç‡§∏ ‡§∏‡•â‡§§‡§ø ‡§°‡§ø‡§´‡§æ‡§á‡§® ‡§∏‡§™‡§¶‡§æ‡§®:--‡§§‡§æ‡§π‡§Æ,‡§Ø‡•á‡§• ‡§≤‡•Å‡§ï‡§® ‡§õ‡§æ‡§® ‡§ú‡§º‡§æ‡§®‡§æ‡§® ‡§ü‡•ç‡§∞‡§ø‡§¨‡•ã‡§®‡•à‡§ï‡•Ä ‡§§‡§∞‡§§‡•Ä‡§¨ ‡§õ‡•Ç.--‡§´‡§ø‡§¨‡•ã‡§®‡•à‡§ï‡•Ä ‡§∏‡•Ä‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§π‡§∞ ‡§Ü‡§ï‡§ø‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡§®‡•á--  >>> tri 3
--  [1,3,2,8]
tri :: Int -> [Int]
tri n =","tri :: Int -> [Int]
tri n = map tribonacci [0..n]
  where
    -- Define the recursive function to calculate the tribonacci value for a given n
    tribonacci :: Int -> Int
    tribonacci 0 = 1
    tribonacci 1 = 3
    tribonacci x
      | even x    = 1 + x `div` 2
      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","
main :: IO ()
main = do
  let candidate = tri
  if candidate 3 == [1,3,2,8] then pure () else error ""assertion failed""
  if candidate 4 == [1,3,2,8,3] then pure () else error ""assertion failed""
  if candidate 5 == [1,3,2,8,3,15] then pure () else error ""assertion failed""
  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error ""assertion failed""
  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error ""assertion failed""
  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error ""assertion failed""
  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error ""assertion failed""
  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error ""assertion failed""
  if candidate 0 == [1] then pure () else error ""assertion failed""
  if candidate 1 == [1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_131,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§Ö‡§ó‡§∞ ‡§∏‡§≤‡•Ä‡§Æ ‡§°‡§ø‡§ú‡§ø‡§ü ‡§õ‡•Ä ‡§ú‡•ã‡§°‡§º‡•á ,‡§§‡§• ‡§õ‡•Ä ‡§Ø‡•á 0 ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§®-- ‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ n ‡§¶‡•Ä‡§§ ,‡§§‡§π ‡§õ‡•Ä ‡§Ö‡§∏ ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§ï‡§æ‡§∞‡§® ‡•Å‡§®‡•ç‡§° ‡§°‡§ø‡§ú‡§ø‡§ü--  >>> digits 1
--  1
--  >>> digits 4
--  0
--  >>> digits 235
--  15
digits :: Int -> Int
digits n =","digits :: Int -> Int
digits n
  | null oddDigits = 0
  | otherwise      = product oddDigits
  where
    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","
main :: IO ()
main = do
  let candidate = digits
  if candidate 5 == 5 then pure () else error ""assertion failed""
  if candidate 54 == 5 then pure () else error ""assertion failed""
  if candidate 120 == 1 then pure () else error ""assertion failed""
  if candidate 5014 == 5 then pure () else error ""assertion failed""
  if candidate 98765 == 315 then pure () else error ""assertion failed""
  if candidate 5576543 == 2625 then pure () else error ""assertion failed""
  if candidate 2468 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_132,kas_Deva,hs,"--‡§Ø‡§ø‡§§ ‡§õ‡•Ä ‡§Ü‡§ñ‡§É ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü ‡§∏‡§¨‡•ç‡§∏‡§ï‡•ç‡§µ‡•á‡§®‡•ç‡§∏‡•Ä ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§®‡•á‡§∏‡•ç‡§ü‡•á‡§°--‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§∞‡§æ‡§® ‡§Ö‡§ó‡§∞ ‡§§‡•á‡§Æ ‡§§‡•á ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§Ö‡§ó‡§∞ ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§Ö‡§ñ ‡§µ‡•à‡§≤‡§ø‡§° ‡§∏‡§¨‡•ç‡§∏‡§ï‡§ï‡•ç‡§µ‡•á‡§Ç‡§∏‡•Ä --‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§¨‡§®‡§æ‡§µ‡•Å‡§® ‡§Ø‡•Å‡§∏ ‡§á‡§®‡§™‡•Å‡§ü ‡§õ‡•Ç ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Ø‡•Å‡§∏ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§∏‡•ç‡§ï‡•ç‡§µ‡§æ‡§Ø‡§∞ ‡§¨‡•ç‡§∞‡•à‡§ï‡•á‡§ü ‡§õ‡•Ç--  >>> isNested ""[[]]""
--  True
--  >>> isNested ""[]]]]]]][[[[[]""
--  False
--  >>> isNested ""[][]""
--  False
--  >>> isNested ""[]""
--  False
--  >>> isNested ""[[][]]""
--  True
--  >>> isNested ""[[]][[""
--  True
isNested :: String -> Bool
isNested string =","isNested :: String -> Bool
isNested string = go string 0 False
  where
    go [] _ nested = nested
    go (x:xs) depth nested
      | x == '['  = go xs (depth + 1) (nested || depth >= 1)
      | x == ']' && depth > 0 = go xs (depth - 1) nested
      | otherwise = go xs depth nested","
main :: IO ()
main = do
  let candidate = isNested
  if candidate ""[[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]][[[[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[][]"" == False then pure () else error ""assertion failed""
  if candidate ""[]"" == False then pure () else error ""assertion failed""
  if candidate ""[[[[]]]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]]]]]"" == False then pure () else error ""assertion failed""
  if candidate ""[][][[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[]]"" == False then pure () else error ""assertion failed""
  if candidate ""[[]][["" == True then pure () else error ""assertion failed""
  if candidate ""[[][]]"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""[[[[[[[["" == False then pure () else error ""assertion failed""
  if candidate ""]]]]]]]]"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_133,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§ï‡•Å‡§Ç‡§§‡•á ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡§ø‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ç ‡§ó‡•Å‡§°‡§®‡§ø‡§ï‡§ø‡§∏ ‡§á‡§Ç‡§ü‡§∏ ‡§§‡§æ‡§Æ ‡§∞‡§æ‡§â‡§Ç‡§° ‡§ï‡§∞‡§æ.--‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§õ‡§º‡§æ‡§® ‡§¶‡§ø‡§§‡•á‡§® ‡§∏‡•Ç‡§∞‡§§‡§® ‡§Æ‡§Ç‡§ú‡§º ‡§∂‡•Å‡§¶ ‡§∂‡•Å‡§¶ ‡§∏‡•ç‡§ï‡•ç‡§µ‡§æ‡§Ø‡§∞, --‚û°Ô∏è‡§§‡•Å‡§Æ‡§® ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§Ü‡§ñ ‡§≤‡§ø‡§∏‡•ç‡§ü ‚û°Ô∏è--  >>> lst [1.0,2.0,3.0]
--  14
--  >>> lst [1.0,4.0,9.0]
--  98
--  >>> lst [1.0,3.0,5.0,7.0]
--  84
--  >>> lst [1.4,4.2,0.0]
--  29
--  >>> lst [-2.4,1.0,1.0]
--  6
sumSquares :: [Float] -> Int
sumSquares lst =","import Data.List (foldl')
import Prelude hiding (sum)

sumSquares :: [Float] -> Int
sumSquares lst = foldl' (\acc x -> acc + ceiling x ^ 2) 0 lst","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error ""assertion failed""
  if candidate [1.4,4.2,0.0] == 29 then pure () else error ""assertion failed""
  if candidate [-2.4,1.0,1.0] == 6 then pure () else error ""assertion failed""
  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error ""assertion failed""
  if candidate [10000.0,10000.0] == 200000000 then pure () else error ""assertion failed""
  if candidate [-1.4,4.6,6.3] == 75 then pure () else error ""assertion failed""
  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error ""assertion failed""
  if candidate [0.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0] == 1 then pure () else error ""assertion failed""
  if candidate [-1.0,1.0,0.0] == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_134,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§®‡•ã‡§ü: ""‡§µ‡§∞‡•ç‡§°"" ‡§õ‡•Ç ‡§∏‡•ç‡§™‡•á‡§∏ ‡§∏‡•á‡§§ ‡§Ö‡§≤‡§ó ‡§ï‡§∞‡§® ‡§µ‡§æ‡§≤‡•á‡§® ‡§ï‡§∞‡•à‡§ï‡•ç‡§ü‡§∞‡§® ‡§π‡•Å‡§®‡•ç‡§¶ ‡§ó‡•ç‡§∞‡•Å‡§™.--‡•á‡§ï ‡§≤‡§´‡•ç‡§ú‡§º‡•Å‡§ï ‡§π‡§ø‡§∏‡§∏ ,‡§¨‡•á ‡§ó‡§≤‡§§ ‡§¨‡§ï‡§ø‡§Ø‡§æ‡§Å ‡§§‡§∞‡§ø‡§ï‡§æ‡§∏ ‡§Æ‡§Ç‡§ú‡§º-- ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§∞‡•ç‡§£‡§Æ‡§æ‡§≤‡§æ ‡§Æ‡§Ç‡§ú‡§º ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡§®‡•á--‡§Ø‡•Å‡§∏ ‡§Ü‡§ñ‡§∞‡•Ä ‡§ï‡•à‡§∞‡•á‡§ï‡•ç‡§ü‡§∞ ‡§õ‡•Ç ‡§∏‡•Å ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§≤‡§µ‡§®--  >>> checkIfLastCharIsALetter ""apple pie""
--  False
--  >>> checkIfLastCharIsALetter ""apple pi e""
--  True
--  >>> checkIfLastCharIsALetter ""apple pi e ""
--  False
--  >>> checkIfLastCharIsALetter """"
--  False
checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt =","checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt = 
    let trimmed = reverse . dropWhile (== ' ') $ reverse txt
    in case trimmed of
        [] -> False
        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","
main :: IO ()
main = do
  let candidate = checkIfLastCharIsALetter
  if candidate ""apple"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e"" == True then pure () else error ""assertion failed""
  if candidate ""eeeee"" == False then pure () else error ""assertion failed""
  if candidate ""A"" == True then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie "" == False then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie 1"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""eeeee e "" == False then pure () else error ""assertion failed""
  if candidate ""apple pie"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e "" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_135,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§°‡•Å‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§ü ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç‡§ú--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§è‡§• ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü ‡§®‡•á ‡§Ö‡§∏ ‡§®‡•á ‡§ï‡§π‡§Å ‡§§‡•á ,‡§§‡§ø‡§≤ ‡§õ‡•Ä ‡§Ø‡•á ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§æ‡§∞‡§® -1.--‡§Ö‡§ó‡§∞                --‡§Ö‡§ñ ‡§´‡§º‡§Ç‡§ï‡•ç‡§∂‡§® ‡§¨‡§®‡§æ‡§µ ‡§Ø‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡§ø‡§®‡•ç‡§¶ ‡§Æ‡•ã‡§∏‡•ç‡§ü ‡§¨‡§æ‡§∞‡•ç‡§∏ ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§∞‡•á‡§ü‡§∞‡•ç‡§® ‡§õ‡•Ç--  >>> canArrange [1,2,4,3,5]
--  3
--  >>> canArrange [1,2,3]
--  (-1)
canArrange :: [Int] -> Int
canArrange arr =","canArrange :: [Int] -> Int
canArrange arr = go arr (-1) 0
  where
    go [] maxIdx _ = maxIdx
    go [_] maxIdx _ = maxIdx
    go (x:y:xs) maxIdx idx
      | x >= y    = go (y:xs) idx (idx + 1)
      | otherwise = go (y:xs) maxIdx (idx + 1)","
main :: IO ()
main = do
  let candidate = canArrange
  if candidate [1,2,4,3,5] == 3 then pure () else error ""assertion failed""
  if candidate [1,2,4,5] == (-1) then pure () else error ""assertion failed""
  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error ""assertion failed""
  if candidate [4,8,5,7,3] == 4 then pure () else error ""assertion failed""
  if candidate [] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_136,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ö‡§ó‡§∞ ‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§Ø‡§æ ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§Ö‡§∏‡§ø‡§• ,‡§§‡•á‡§Æ ‡§Ö‡§∏ ‡§è‡§µ‡§Ç ‡§®‡§•‡§ø‡§Ç‡§ó ‡§™‡•á‡§† ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§®‡•á--‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º.--‡§Ø‡•á ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§¨‡§¢‡§º ‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ,‡§¨‡•Ä ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§≤‡§ï‡•Å‡§ü--‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§¨‡§®‡§æ‡§µ‡•Å‡§® ‡§Ø‡•Å‡§∏ ‡§ü‡§™‡§≤ (a, b) ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§æ‡§∞‡§®, ‡§Ø‡§ø‡§§ 'a' ‡§õ‡•Ç --  >>> largestSmallestIntegers [2,4,1,3,5,7]
--  (Nothing, 1)
--  >>> largestSmallestIntegers []
--  (Nothing, Nothing)
--  >>> largestSmallestIntegers [0]
--  (Nothing, Nothing)
largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst =","largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst = (largestNegative, smallestPositive)
  where
    negatives = filter (< 0) lst
    positives = filter (> 0) lst
    largestNegative = if null negatives then Nothing else Just (maximum negatives)
    smallestPositive = if null positives then Nothing else Just (minimum positives)","
main :: IO ()
main = do
  let candidate = largestSmallestIntegers
  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error ""assertion failed""
  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error ""assertion failed""
  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error ""assertion failed""
  if candidate [] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [0] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_138,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡•á‡§Æ‡•Å‡§ï ‡§Ü‡§ï‡§≤‡§® ‡§ï‡§æ‡§∞‡§® ‡§ï‡•Ä ‡§ï‡•ç‡§Ø‡§æ ‡§õ‡•Ç ‡§è‡§µ‡§Ç ‡§®‡§Ç‡§¨‡§∞ n ‡§≤‡§ø‡§ñ‡•ã ‡•á‡§Æ‡•Å‡§ï ‡§Æ‡§§‡§≤‡§¨ ‡§õ‡•Ç ‡§∏‡§≤‡•Ä‡§Æ 4 ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§®‡§Ç‡§¨‡§∞--  >>> isEqualToSumEven 4
--  False
--  >>> isEqualToSumEven 6
--  False
--  >>> isEqualToSumEven 8
--  True
isEqualToSumEven :: Int -> Bool
isEqualToSumEven n =","isEqualToSumEven :: Int -> Bool
isEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","
main :: IO ()
main = do
  let candidate = isEqualToSumEven
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == True then pure () else error ""assertion failed""
  if candidate 11 == False then pure () else error ""assertion failed""
  if candidate 12 == True then pure () else error ""assertion failed""
  if candidate 13 == False then pure () else error ""assertion failed""
  if candidate 16 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_139,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§Ø‡§ø‡§§ ‡§è‡§® > 0 --brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! --‡§Ø‡•Å‡§∏ ‡§¨‡•ç‡§∞‡§æ‡§ú‡§º‡•Ä‡§≤‡§ø‡§Ø‡§® ‡§´‡•Ö‡§ï‡•ç‡§ü‡•ã‡§∞‡§ø‡§Ø‡§≤ ‡§õ‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§®--  >>> specialFactorial 4
--  288
--  The function will receive an integer as input and should return the special
--  factorial of this integer.
specialFactorial :: Int -> Int
specialFactorial n =","specialFactorial :: Int -> Int
specialFactorial n = product [factorial x | x <- [1..n]]
  where
    factorial 0 = 1
    factorial k = k * factorial (k - 1)","
main :: IO ()
main = do
  let candidate = specialFactorial
  if candidate 4 == 288 then pure () else error ""assertion failed""
  if candidate 5 == 34560 then pure () else error ""assertion failed""
  if candidate 7 == 125411328000 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_140,kas_Deva,hs,"--‡§§‡•á‡§Æ ‡§™‡§æ‡§§ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§∏‡§≤‡•Ä‡§Æ ‡§∏‡•ç‡§™‡•á‡§∏‡•á‡§∏ ‡§¨‡§¶‡§≤‡§µ‡§®‡•Ä - --‡§Ö‡§ó‡§∞ ‡§Ö‡§ñ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó 2 ‡§ñ‡•ã‡§§ ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§ï‡•â‡§®‡•ç‡§∏‡§ï‡•ç‡§ü‡§ø‡§µ‡•á ‡§∏‡•ç‡§™‡•á‡§∏‡§∏ ‡§õ‡•Ç,--                       --  >>> fixSpaces "" Example""
--  ""Example""
--  >>> fixSpaces "" Example 1""
--  ""Example_1""
--  >>> fixSpaces "" Example 2""
--  ""_Example_2""
--  >>> fixSpaces "" Example 3""
--  ""_Example-3""
fixSpaces :: String -> String
fixSpaces text =","fixSpaces :: String -> String
fixSpaces text = concatMap replaceSpaces (groupSpaces text)
  where
    groupSpaces :: String -> [String]
    groupSpaces [] = []
    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest

    replaceSpaces :: String -> String
    replaceSpaces spaces@(x:_)
      | x == ' ' && length spaces > 2 = ""-""
      | x == ' ' = replicate (length spaces) '_'
      | otherwise = spaces","
main :: IO ()
main = do
  let candidate = fixSpaces
  if candidate ""Example"" == ""Example"" then pure () else error ""assertion failed""
  if candidate ""Mudasir Hanif "" == ""Mudasir_Hanif_"" then pure () else error ""assertion failed""
  if candidate ""Yellow Yellow  Dirty  Fellow"" == ""Yellow_Yellow__Dirty__Fellow"" then pure () else error ""assertion failed""
  if candidate ""Exa   mple"" == ""Exa-mple"" then pure () else error ""assertion failed""
  if candidate ""   Exa 1 2 2 mple"" == ""-Exa_1_2_2_mple"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_141,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --- ‡§Ø‡•Å‡§∏ ‡§∏‡§¨‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä ‡§°‡•â‡§ü ‡§™‡§æ‡§§ ‡§Ø‡•á ‡§π‡§ï‡§º ‡§Ö‡§∏‡§ø‡§•: ['txt', 'exe', 'dll']--‡§≤‡•à‡§ü‡§ø‡§® ‡§Ö‡§≤‡•ç‡§´‡§æ‡§¨‡•á‡§ü ('a'-'z' and 'A'-Z').--- ‡§∏‡§¨‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Ø‡•Å‡§∏ ‡§°‡•â‡§ü ‡§¨‡§∞‡•ã‡§π ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡§æ‡§® ‡§π‡§ï‡•ã ‡§Ü‡§∏‡§ø‡§• ‡§ñ‡§≤‡•Ä ,‡§¨‡•á ‡§Ø‡•á ‡§õ‡•Ä ‡§∂‡•Å‡§∞‡•Ç ‡§ó‡§æ‡§∏‡§® ‡§≤‡§´‡§º‡•ç‡§ú ‡§∏‡•á‡§•--- ‡§´‡§º‡§æ‡§á‡§≤‡•Å‡§ï ‡§®‡§æ‡§µ ‡§õ‡•Å ‡§Ö‡§ñ ‡§°‡•â‡§ü '.'‡•§--- ‡§´‡§º‡§æ‡§á‡§≤ ‡§®‡§æ‡§µ‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Å‡§® ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶ ‡§§‡•ç‡§∞‡•á‡§® ‡§°‡§ø‡§ú‡§ø‡§ü‡•ç‡§® (0 - 9) ‡§π‡•ç‡§®‡•ç‡§ú‡§º ‡§ó‡§õ‡§æ‡§®‡•§--‡§Ø‡•á ‡§õ‡•Ç ‡§è‡§è‡§Æ ‡§∏‡•á‡§§ ‡§Æ‡§ø‡§≤‡§æ‡§®:--‡§Ö‡§ñ ‡§´‡§º‡§æ‡§á‡§≤ ‡§®‡§æ‡§µ ‡§õ‡•Å ‡§µ‡•à‡§≤‡§ø‡§° ‡§Æ‡§æ‡§®‡§æ‡§® ‡§Ö‡§ó‡§∞ ‡§§‡•Ü ‡§§‡§ø‡§Æ ‡§§‡§Æ‡§æ‡§Æ ‡§∂‡§∞‡•Ç‡§§ ‡§™‡•Ç‡§∞‡§É ‡§Ü‡§∏‡§ø‡•§--‡§Ö‡§ó‡§∞ ‡§´‡§º‡§æ‡§á‡§≤ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§®‡§æ‡§µ ‡§∏‡§π‡•Ä ‡§Ü‡§∏‡§ø, ‡§§ '‡§π‡§æ‡§Å', ‡§Ö‡§ó‡§∞ ‡§®‡•á ‡§∏‡§π‡•Ä ‡§Ü‡§∏‡§ø, ‡§§ '‡§®‡§π'‡•§--‡•á‡§ï ‡§´‡§º‡§Ç‡§ï‡•ç‡§∂‡§® ‡§¨‡§®‡§æ‡§µ ‡§Ø‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§´‡§æ‡§á‡§≤ ‡§®‡§æ‡§µ‡•Å‡§ï ,‡§§‡•á ‡§∏‡•Å ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® --  >>> fileNameCheck ""example.txt""
--  ""Yes""
--  >>> fileNameCheck ""1example.dll""
--  ""No""
fileNameCheck :: String -> String
fileNameCheck file_name =","import Data.Char (isDigit, isLetter)

fileNameCheck :: String -> String
fileNameCheck file_name 
  | countDots /= 1 = ""No""
  | length digits > 3 = ""No""
  | null beforeDot || not (isLetter (head beforeDot)) = ""No""
  | afterDot `notElem` validExtensions = ""No""
  | otherwise = ""Yes""
  where 
    (beforeDot, afterDot) = span (/= '.') file_name
    countDots = length $ filter (== '.') file_name
    digits = filter isDigit file_name
    validExtensions = [""txt"", ""exe"", ""dll""]
    afterDot = if null dotAndAfter then """" else tail dotAndAfter
    dotAndAfter = dropWhile (/= '.') file_name","
main :: IO ()
main = do
  let candidate = fileNameCheck
  if candidate ""example.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1example.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s1sdf3.asd"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""K.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""MY16FILE3.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""His12FILE94.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_Y.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""?aREYA.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""/this_is_valid.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.wow"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txtexe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""#this2_i4s_5valid.ten"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""@this1_is6_valid.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_12valid.6exe4.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""all.exe.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_No.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""Is3youfault.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""no_one#knows.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1I563_Yes3.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_Yes3.txtt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final..txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final132"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_f4indsartal132."" == ""No"" then pure () else error ""assertion failed""
  if candidate "".txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s."" == ""No"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_142,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§¨‡§¶‡§≤‡§®‡•Ä ‡§è‡§Ç‡§ü‡•ç‡§∞‡•Ä‡§ú ‡§Æ‡§Ç‡§ú‡§º ‡§Ø‡§Æ‡§® ‡§π‡§ø‡§®‡•ç‡§¶ ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§õ‡§æ‡§® ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§Ü‡§∏‡§æ‡§® 3 ‡§Ø‡§æ 4--‡§Ø‡•Å‡§∏ ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§π‡§ï‡§º ‡§Ö‡§∏‡§ø‡§• ‡§µ‡§æ‡§∞‡§ø‡§Ø‡§æ ‡§§‡•á‡§∞ ‡§™‡•á‡§† ,‡§Ö‡§ó‡§∞ ‡§∏‡•Å ‡§á‡§®‡•ç‡§°‡§ø‡§∏‡•á ‡§Ö‡§∏ ‡§µ‡§æ‡§∞‡§ø‡§Ø‡§æ ‡§§‡•á‡§∞ ‡§™‡•á‡§† ,‡§´‡•â‡§∞‡§ó‡•á‡§ü ‡§õ‡§æ‡§® ‡§Ü‡§∏‡§æ‡§®--‡§Ø‡•á ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ä ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡§æ‡§∞‡§® ,‡§≤‡§ï‡§ø‡§® ‡§Ö‡§ó‡§∞ ‡§Ø‡•á ‡§á‡§®‡•ç‡§ü‡§ø‡§ú‡§∞ --"" --  >>> lst
--  [1,2,3]
--  >>> lst
--  []
--  >>> lst
--  [(-1),(-5),2,(-1),(-5)]
sumSquares :: [Int] -> Int
sumSquares lst =","sumSquares :: [Int] -> Int
sumSquares lst = sum $ zipWith transform [0..] lst
  where
    transform idx x
      | idx `mod` 3 == 0 = x * x
      | idx `mod` 4 == 0 = x * x * x
      | otherwise        = x","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1,2,3] == 6 then pure () else error ""assertion failed""
  if candidate [1,4,9] == 14 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error ""assertion failed""
  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error ""assertion failed""
  if candidate [0] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error ""assertion failed""
  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error ""assertion failed""
  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error ""assertion failed""
  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error ""assertion failed""
  pure ()"
HumanEval_143,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ 1: --‡§Ø‡•Å‡§∏ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§õ‡•Ä ‡§≤‡§´‡§º‡§ú‡§º ‡§π‡•à‡§ú‡§º ‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§®‡§à ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Æ‡§Ç‡§ú‡§º ‡§Ø‡•á ‡§ó‡§∏‡§£ ‡§ì‡§∞‡§ø‡§ú‡§ø‡§®‡§≤ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§™‡§æ‡§†--‡§Ø‡•á‡§Æ‡§® ‡§π‡§ø‡§Ç‡§ú ‡§≤‡•á‡§Ç‡§• ‡§õ‡•Ç ‡§™‡•ç‡§∞‡§æ‡§á‡§Æ ‡§®‡§Ç‡§¨‡§∞,--‡§§ ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§õ‡§º‡§æ‡§® ‡§Ö‡§ñ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§µ‡§æ‡§™‡§∏ ‡§Ø‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§≤‡§´‡•ç‡§ú‡§º ‡§õ‡§ø ‡§Ø‡§ø‡§Æ ‡§ó‡•ã‡§°‡§®‡§ø‡§ï‡§ø‡§∏ ‡§µ‡§æ‡§ï‡•ç‡§Ø‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡§ø, --‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§∏‡•á‡§®‡•ç‡§ü‡•á‡§®‡•ç‡§∏ ‡§õ‡•Ä ‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§ï‡•á‡§π ‡§≤‡§´‡§º‡§ú‡§º ‡§Ø‡•Å‡§∏ ‡§∏‡•ç‡§™‡•á‡§∏ ‡§∏‡•á‡§• ‡§õ‡•Ä ‡§Ö‡§≤‡§ó ‡§ï‡§æ‡§∞‡§® ,--‡§Ö‡§∏ ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§Ö‡§ï‡§ø ‡§µ‡§æ‡§ï‡•ç‡§Ø‡§∏ ‡§∞‡§ø‡§™‡•ç‡§∞‡•á‡§ú‡§º‡•ç‡§®‡§ü ‡§ï‡§∞‡§æ‡§®,--  >>> wordsInSentence ""This is a test""
--  ""is""
--  Example 2:
--  >>> wordsInSentence ""lets go for swimming""
--  ""go for""
--  Constraints:
--  * 1 <= len(sentence) <= 100
--  * sentence contains only letters
wordsInSentence :: String -> String
wordsInSentence sentence =","import Data.List (intercalate)

wordsInSentence :: String -> String
wordsInSentence sentence = intercalate "" "" $ filter (isPrime . length) (words sentence)

isPrime :: Int -> Bool
isPrime n | n < 2     = False
          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = wordsInSentence
  if candidate ""This is a test"" == ""is"" then pure () else error ""assertion failed""
  if candidate ""lets go for swimming"" == ""go for"" then pure () else error ""assertion failed""
  if candidate ""there is no place available here"" == ""there is no place"" then pure () else error ""assertion failed""
  if candidate ""Hi I am Hussein"" == ""Hi am Hussein"" then pure () else error ""assertion failed""
  if candidate ""go for it"" == ""go for it"" then pure () else error ""assertion failed""
  if candidate ""here"" == """" then pure () else error ""assertion failed""
  if candidate ""here is"" == ""is"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_144,kas_Deva,hs,"--‡§§‡•Å‡§Æ ‡§π‡§ï‡•ã ‡§Ü‡§∏‡•Å‡§Æ‡§™‡•ç‡§ü ‡§ï‡§∞‡§ø‡§• ‡§ï‡•Ä x, ‡§§‡•á n ‡§õ‡•Ç ‡§µ‡•à‡§≤‡§ø‡§° ‡§´‡•ç‡§∞‡•à‡§ï‡•ç‡§∂‡§®, ‡§§‡•á ‡§õ‡§æ‡§® ‡§Ü‡§∏‡§æ‡§® ‡§ú‡•Ä‡§∞‡•ã ‡§°‡•á‡§Æ‡§ø‡§®‡•ã‡§®‡•á‡§ü‡§∞ ‡§™‡•á‡§†--<numerator>/<denominator> ‡§Ø‡•á‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§®‡•Å‡§Æ‡•á‡§∞‡•á‡§ü‡§∞ ‡§§‡•á ‡§°‡•á‡§®‡•ã‡§Æ‡§ø‡§®‡§ü‡§∞ ‡§¶‡•Å‡§®‡§µ‡§à ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞ ‡§®‡§Ç‡§¨‡§∞ ‡§Ü‡§∏‡§æ‡§®.--‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§µ‡•Å‡§õ‡•ã x ‡§§‡•á n ,‡§Ø‡•á ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§∞‡§ø‡§™‡•ç‡§∞‡•á‡§ú‡•á‡§Ç‡§ü‡•á‡§∂‡§® ‡§´‡•ç‡§∞‡•à‡§ï‡•ç‡§∂‡§®‡§ï ,‡§¨‡•á ‡§õ‡•Ä ‡§Ö‡§• ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü ,--x * n. ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§ï‡§∞‡§æ ‡§Ö‡§ó‡§∞ x * n ‡§õ‡•Ç ‡§á‡§Ç‡§§‡•á‡§ú‡§∞ ‡§§‡•á ‡§´‡•â‡§≤‡•ç‡§ü --‡§Ö‡§∏ ‡§§‡•Å‡§π‡§∞‡•á ‡§ï‡§æ‡§Æ ‡§õ‡•Ä ‡§á‡§Æ‡•ç‡§™‡•ç‡§≤‡•â‡§à ‡§ï‡§∞‡•ã‡§Ç ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§Ø‡•Å‡§∏ ‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§∞‡•á‡§∂‡§® ‡§Ü‡§∏‡§æ‡§® ‡§¨‡§®‡§æ‡§ì--  >>> simplify ""1/5"" ""5/1""
--  True
--  >>> simplify ""1/6"" ""2/1""
--  False
--  >>> simplify ""7/10"" ""10/2""
--  False
simplify :: String -> String -> Bool
simplify x n =","import Data.Ratio (denominator, numerator, (%))

simplify :: String -> String -> Bool
simplify x n =
  let (xNum, xDen) = toFraction x
      (nNum, nDen) = toFraction n
      result = (xNum * nNum) % (xDen * nDen)
  in denominator result == 1

toFraction :: String -> (Integer, Integer)
toFraction s =
  let (numStr, _:denStr) = break (=='/') s
  in (read numStr, read denStr)","
main :: IO ()
main = do
  let candidate = simplify
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/6"" ""2/1"" == False then pure () else error ""assertion failed""
  if candidate ""5/1"" ""3/1"" == True then pure () else error ""assertion failed""
  if candidate ""7/10"" ""10/2"" == False then pure () else error ""assertion failed""
  if candidate ""2/10"" ""50/10"" == True then pure () else error ""assertion failed""
  if candidate ""7/2"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""11/6"" ""6/1"" == True then pure () else error ""assertion failed""
  if candidate ""2/3"" ""5/2"" == False then pure () else error ""assertion failed""
  if candidate ""5/2"" ""3/5"" == False then pure () else error ""assertion failed""
  if candidate ""2/4"" ""8/4"" == True then pure () else error ""assertion failed""
  if candidate ""2/4"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""1/5"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_145,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡•á‡§Æ‡§® ‡§Ö‡§∞‡•ç‡§°‡§∞ ‡§è‡§Æ‡§è‡§ö ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§™‡•á‡§† ‡§ì‡§∞‡§ø‡§ú‡§ø‡§®‡§≤ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º--‡§®‡•ã‡§ü: ‡§Ö‡§ó‡§∞ ‡§ï‡§π‡§Å ‡§§‡•á ‡§Ü‡§á‡§ü‡§Æ ‡§Ü‡§∏‡§æ‡§® ‡§§‡•á‡§Æ‡§® ‡§π‡§ø‡§®‡•ç‡§¶ ‡§°‡§ø‡§ú‡§ø‡§ü ‡§π‡•Å‡§®‡•ç‡§¶ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§∏‡•ã‡§Ç‡§• ,--‡§£‡§£‡§£ ‡§£‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£ ‡§£--‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã ‡§Ø‡•Å‡§∏ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§¶‡§æ‡§§‡•á ‡§Ö‡§∏--  >>> orderByPoints [1,11,(-1),(-11),(-12)]
--  [(-1),(-11),1,(-12),11]
--  >>> orderByPoints []
--  []
orderByPoints :: [Int] -> [Int]
orderByPoints nums =","import Data.List (sortBy)
import Data.Function (on)

orderByPoints :: [Int] -> [Int]
orderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums
  where
    sumOfDigits :: Int -> Int
    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)
    
    indexedNums :: [(Int, Int)]
    indexedNums = zip (map sumOfDigits nums) nums","
main :: IO ()
main = do
  let candidate = orderByPoints
  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error ""assertion failed""
  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error ""assertion failed""
  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_146,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§Ø‡•Å‡§∏ ‡§ó‡•ã‡§°‡•ç‡§®‡•Å‡§á‡§ï ‡§§‡•á ‡§Ü‡§ñ‡§∞‡•Ä ‡§°‡§ø‡§ú‡§ø‡§ü ‡§õ‡•Ä ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡•Å‡§Ç‡§¶‡§∞ (1, 3, 5, 7, 9)--‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§è‡§≤‡§ø‡§Æ‡•á‡§Ç‡§ü‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§∏‡•Å ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ 10 ‡§¨‡•á ‡§¶‡•Å‡§®‡§µ‡§à --‡•á‡§ï ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã ‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§á‡§®‡§™‡•Å‡§ü ‡§§‡•á ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡•á‡§µ‡§æ--  >>> specialfilter [15,(-73),14,(-15)]
--  1
--  >>> specialfilter [33,(-2),(-3),45,21,109]
--  2
specialfilter :: [Int] -> Int
specialfilter nums =","specialfilter :: [Int] -> Int
specialfilter nums = length $ filter isSpecial nums
  where
    isSpecial n = n > 10 && isOddFirstAndLast (abs n)

    isOddFirstAndLast :: Int -> Bool
    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit
      where
        xStr = show x
        firstDigit = head xStr
        lastDigit = last xStr

    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""","
main :: IO ()
main = do
  let candidate = specialfilter
  if candidate [5,(-2),1,(-5)] == 0 then pure () else error ""assertion failed""
  if candidate [15,(-73),14,(-15)] == 1 then pure () else error ""assertion failed""
  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error ""assertion failed""
  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error ""assertion failed""
  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_147,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤:--a[i] + a[j] + a[k] ‡§õ‡•Ç ‡§Æ‡§≤‡•ç‡§ü‡•Ä‡§™‡•ç‡§≤ ‡§ë‡§´‡§º 3--a ‡§π‡§ø‡§ö ‡§ü‡•ç‡§∞‡§ø‡§™‡§≤ ‡§®‡§Ç‡§¨‡§∞ ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡•ã (a[i], a[j], a[k]) ‡§Ø‡§ø‡§§ i < j < k, --‡§π‡§∞ i (1 ‚â§ i ‚â§ n) ‡§ñ‡§æ‡§§‡§∞ ,‡§Ø‡•Å‡§∏ ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç ‡§õ‡•Ä a[i] = i * i - i + 1--                     --  >>> getMaxTriples 5
--  1
--  Explanation: 
--  a = [1, 3, 7, 13, 21]
--  The only valid triple is (1, 7, 13).
getMaxTriples :: Int -> Int
getMaxTriples n =","getMaxTriples :: Int -> Int
getMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]
  where
    a = [i * i - i + 1 | i <- [1..n]]","
main :: IO ()
main = do
  let candidate = getMaxTriples
  if candidate 5 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 4 then pure () else error ""assertion failed""
  if candidate 10 == 36 then pure () else error ""assertion failed""
  if candidate 100 == 53361 then pure () else error ""assertion failed""
  pure ()"
HumanEval_149,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§§‡•Å‡§Æ ‡§π‡§ï‡•ã ‡§Ü‡§∏‡•Å‡§Æ‡§™‡•ç‡§ü‡•Ä‡§µ‡•á ‡§ï‡§∞‡§ø‡§• ‡§ï‡•Ä ‡§∏‡§≤‡•Ä‡§Æ ‡§≤‡§´‡§º‡§ú‡§º ‡§õ‡•Ä ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§≤‡•ã‡§Ç‡§ó--‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ö‡§∏‡§æ,‡§Ø‡•á‡§Æ ‡§∏‡•â‡§∞‡•ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ñ‡§æ‡§§‡§ø‡§∞ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§õ‡•Ç ‡§Ö‡§∏‡§æ.--‡§Ö‡§ó‡§∞ ‡§¶‡•ã‡§® ‡§≤‡§´‡§º‡•ç‡§ú‡§º‡§® ‡§π‡§ø‡§®‡•ç‡§ú‡§º ‡§≤‡•ç‡§®‡•ç‡§ó‡§Ø‡§ø ‡§Ö‡§ñ ‡§Ö‡§ï‡§ø‡§∏ ‡§∏‡•Ä‡§§ ‡§õ‡•á, ‡§§‡•ç‡§∞‡§æ‡§µ‡§ø‡§µ ‡§Ö‡§≤‡•ç‡§´‡§æ‡§¨‡•á‡§ü‡§ø‡§ï ‡§§‡•ã‡§∞‡•§--‡§Ø‡§ø‡§Æ‡§® ‡§∞‡•Ç‡§≤‡§® ‡§π‡•ç‡§®‡•ç‡§ú‡§º‡§ø ‡§∏‡•â‡§∞‡•ç‡§ü‡§ø‡§´‡§º‡§æ‡§Ø‡§∞ ‡§õ‡•Å ‡§Ø‡§ø‡§µ‡§æ‡§® ‡§ï‡§∞‡§®‡•ç‡§π‡•§--‡§Ø‡•Å‡§∏ ‡§Ü‡§∞‡•ç‡§°‡§∞ ‡§õ‡•Ä ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§π‡•Å‡§®‡•ç‡§¶ ‡§á ‡§ó‡§∏‡§£ ‡§Ö‡§∏‡•á‡§Ç‡§¨‡§≤‡•Ä ‡§Æ‡§Ç‡§ú‡§º ‡§π‡§∞ ‡§≤‡§´‡§º‡§ú‡§º ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡•á‡§Ç‡§• ‡§π‡§ø‡§∏‡§æ‡§¨ ,‡§¨‡•á ‡§§‡•Å‡§π --‡§Ø‡•á ‡§π‡§ï‡§º ‡§°‡•Å‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§ü ‡§§‡•á ‡§Ö‡§∏‡§ø‡§•--‡§Ø‡•Å‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§π‡§Æ‡•á‡§∂‡§æ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§¨‡•á ‡§õ‡§æ‡§® ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§®‡§Ç‡§¨‡§∞ ‡§Ü‡§∏‡§æ‡§®--                 --‡§õ‡•Å‡§Ç ‡§õ‡•Å‡§Ç ‡§≤‡§Å‡§™‡•Å‡§á ‡§õ‡•Å‡§Ç ‡§≤‡§Å‡§™‡•Å‡§á ‡§õ‡•Å‡§Ç ‡§≤‡§Å‡§™‡•Å‡§á ‡§õ‡•Å‡§Ç ‡§≤‡§Å‡§™‡•Å‡§á ‡§õ‡•Å‡§Ç ‡§≤‡§Å‡§™‡•Å‡§á ‡§õ‡•Å‡§Ç--‡•á‡§ï ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã ‡§Ø‡•Å‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Ö‡§∏ ‡§™‡•à‡§∞‡§æ‡§Æ‡•Ä‡§ü‡§∞ ‡§ï‡•Ä ‡§§‡•à‡§∞ ‡§™‡§á‡§† ‡§è‡§ï‡•ç‡§∏‡•á‡§™‡•ç‡§ü ‡§ï‡§∞‡§æ,--  >>> listSort [""aa"",""a"",""aaa""]
--  [""aa""]
--  >>> listSort [""ab"",""a"",""aaa"",""cd""]
--  [""ab"",""cd""]
sortedListSum :: [String] -> [String]
sortedListSum lst =","sortedListSum :: [String] -> [String]
sortedListSum lst = sortBy compareStrings (filter evenLength lst)
  where
    evenLength s = even (length s)
    compareStrings s1 s2
      | length s1 == length s2 = compare s1 s2
      | otherwise = compare (length s1) (length s2)","
main :: IO ()
main = do
  let candidate = sortedListSum
  if candidate [""aa"",""a"",""aaa""] == [""aa""] then pure () else error ""assertion failed""
  if candidate [""school"",""AI"",""asdf"",""b""] == [""AI"",""asdf"",""school""] then pure () else error ""assertion failed""
  if candidate [""d"",""b"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""d"",""dcba"",""abcd"",""a""] == [""abcd"",""dcba""] then pure () else error ""assertion failed""
  if candidate [""AI"",""ai"",""au""] == [""AI"",""ai"",""au""] then pure () else error ""assertion failed""
  if candidate [""a"",""b"",""b"",""c"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""aaaa"",""bbbb"",""dd"",""cc""] == [""cc"",""dd"",""aaaa"",""bbbb""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_150,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡§®‡•á--‡§Ø‡•Å‡§∏ ‡§Ü‡§∏‡§æ‡§® ‡§™‡•ç‡§∞‡•ã‡§ó‡•ç‡§∞‡§æ‡§Æ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç x ‡§Ø‡§ø‡§≤ n ‡§õ‡•Ä --  >>> xOrY 7 34 12
--  34
--  >>> xOrY 15 8 5
--  5
xOrY :: Int -> Int -> Int -> Int
xOrY n x y =","xOrY :: Int -> Int -> Int -> Int
xOrY n x y = if isPrime n then x else y

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = xOrY
  if candidate 7 34 12 == 34 then pure () else error ""assertion failed""
  if candidate 15 8 5 == 5 then pure () else error ""assertion failed""
  if candidate 3 33 5212 == 33 then pure () else error ""assertion failed""
  if candidate 1259 3 52 == 3 then pure () else error ""assertion failed""
  if candidate 7919 (-1) 12 == (-1) then pure () else error ""assertion failed""
  if candidate 3609 1245 583 == 583 then pure () else error ""assertion failed""
  if candidate 91 56 129 == 129 then pure () else error ""assertion failed""
  if candidate 6 34 1234 == 1234 then pure () else error ""assertion failed""
  if candidate 1 2 0 == 0 then pure () else error ""assertion failed""
  if candidate 2 2 0 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_151,kas_Deva,hs,"--‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§ø‡§®‡§ó‡§∞ ‡§ï‡§∞‡§®‡•á---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  >>> doubleTheDifference [1,3,2,0]
--  10
--  >>> doubleTheDifference [(-1),(-2),0]
--  0
--  >>> doubleTheDifference [9,(-2)]
--  81
--  >>> doubleTheDifference [0]
--  0
--  If the input list is empty, return 0.
doubleTheDifference :: [Float] -> Int
doubleTheDifference lst =","doubleTheDifference :: [Float] -> Int
doubleTheDifference lst = 
    sum [x * x | x <- map round lst, x > 0, odd x]","
main :: IO ()
main = do
  let candidate = doubleTheDifference
  if candidate [.0] == 0 then pure () else error ""assertion failed""
  if candidate [5.0,4.0] == 25 then pure () else error ""assertion failed""
  if candidate [0.1,0.2,0.3] == 0 then pure () else error ""assertion failed""
  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error ""assertion failed""
  if candidate [0.2,3.0,5.0] == 34 then pure () else error ""assertion failed""
  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error ""assertion failed""
  pure ()"
HumanEval_152,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ö‡§ó‡§∞ ‡§Ø‡•á 0 ‡§ì‡§∏ ,‡§§‡§Æ‡•Å‡§ï ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç ‡§Ö‡§∏ ‡§Ö‡§¨‡•ç‡§∏‡•ã‡§≤‡•Å‡§ü‡•á ‡§°‡§ø‡§´‡§∞‡•á‡§Ç‡§∏ ‡§ó‡•á‡§ü‡•ç‡§∏ ‡§§‡•á ‡§∏‡•ç‡§ï‡•ã‡§∞ ‡§Æ‡§Ç‡§ú‡§º--‡§Ö‡§ó‡§∞ ‡§§‡•á‡§Æ ‡§∏‡§π‡•Ä ‡§∏‡•á‡§§ ‡§Ö‡§Ç‡§¶‡§æ‡§ú‡§º ‡§≤‡§ó‡§æ‡§µ ‡§§‡•á,--‡§§‡•ã‡§Ø ‡§õ‡•Ä ‡§¶‡•á‡§µ‡§® ‡§ú‡§º‡•á ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§∏‡•ç‡§ï‡•ã‡§∞ ‡§§ ‡§¨‡•à ‡§ó‡•á‡§∏‡•ç‡§ü‡•ç‡§∏ ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§≤‡•á‡§Ç‡§• ‡§∏‡§æ‡§• , ‡§Ø‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§π‡§∞ ‡§á‡§Ç‡§°‡•á‡§ï‡•ç‡§∏ ‡§õ‡•Ä ‡§π‡§µ‡§® ‡§Æ‡•à‡§ö--‡§§‡•ã‡§∞‡•á ‡§ï‡§æ‡§Æ ‡§õ‡•á ‡§à ‡§™‡§§‡§æ ‡§≤‡§ó‡§æ‡§®‡§æ ‡§ï‡§ø ‡§Ö‡§ó‡§∞ ‡§Ö‡§ï‡§ø‡§∏ ‡§∂‡§ñ‡•ç‡§∏‡§∏ ‡§∏‡§π‡•Ä ‡§Ö‡§Ç‡§¶‡§æ‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§Æ‡•Å‡§ï‡§º‡§æ‡§¨‡§≤‡§æ ‡§õ‡•Ç ‡§Ö‡§Æ‡•É‡§§ ‡§ï‡§∞‡§®‡•á.--‡§Ø‡•á ‡§õ‡•Ä ‡§ú‡§º‡§∞‡•Ç‡§∞‡•Ä ‡§ï‡•Ä ‡§Ö‡§∏ ‡§π‡§ï‡•ã ‡§Ö‡§• ‡§µ‡•Å‡§õ‡§ø‡§• ‡§¨‡•á ‡§§‡•Å‡§≤‡§∏‡•Ä‡§•--‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§á‡§µ‡•á‡§Ç‡§ü ‡§õ‡•Ä ‡§Ø‡•á ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§µ‡•Ç‡§ö‡§®--‡§π‡§Æ ‡§∏‡•ã‡§Ç‡§ö‡•Ç‡§Ç ‡§õ‡•Ä ‡§ï‡•Ä ‡§Ö‡§∏ ‡§∏‡§Ç‡§ú‡§® ‡§õ‡•Ä ‡§Ø‡§ø‡§≤ ‡§Ö‡§∏ ‡§®‡§§‡•Ä‡§ú ‡§õ‡•Ä ‡§µ‡§∞‡•Ä‡§Ø ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§µ‡•á‡§® ‡§§‡•á--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]
--  [0,0,0,0,3,3]
--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]
--  [4,4,1,0,0,6]
compare :: [Int] -> [Int] -> [Int]
compare game guess =","compare :: [Int] -> [Int] -> [Int]
compare game guess = zipWith (\g s -> abs (g - s)) game guess","
main :: IO ()
main = do
  let candidate = compare
  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error ""assertion failed""
  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error ""assertion failed""
  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error ""assertion failed""
  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_153,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --(‡§á‡§Æ‡§ø‡§∏‡§Ç‡§¶ ‡§§‡§æ‡§ï‡§§ ‡§õ‡•Ç -1).--return 'Slices.SErviNGSliCes' as 'SErviNGSliCes' is the strongest extension --‡§è‡§ï‡•ç‡§∏‡§ü‡•á‡§Ç‡§∂‡§®: ['‡§∏‡•á‡§∞‡•ç‡§µ‡§ø‡§Ç‡§ó‡•ç‡§∏','‡§ö‡•Ä‡§ú‡§º', '‡§∏‡•ç‡§ü‡•Ç‡§´‡§º‡•á‡§°'] ‡§§‡•ã ‡§Ü‡§™ --‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞ ,‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ""‡§∏‡•ç‡§≤‡§æ‡§á‡§∏ "" ‡§ï‡•ç‡§≤‡§æ‡§∏‡•á‡§∏ ‡§§‡•á ‡§≤‡§ø‡§∏‡•ç‡§ü --‡§Ø‡•Å‡§∏ ‡§Ø‡•á ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡•ã‡§¶‡§®‡•Ä‡§ö ‡§Ü‡§µ ‡§á ‡§ö‡•Å‡§® ‡§ö‡•Å‡§®--‡§Ö‡§ó‡§∞ ‡§Ö‡§Ø‡•á ‡§¶‡•Ç‡§Å ‡§Ø‡§æ ‡§ú‡§º‡§Ø‡§æ‡§¶ ‡§è‡§ï‡•ç‡§∏‡§ü‡•á‡§Ç‡§∂‡§® ‡§Ö‡§• ‡§§‡§æ‡§ï‡§º‡§§ ‡§∏‡•á‡§§,‡§Ö‡§• ‡§õ‡•Ç ‡§®‡§ú‡§º‡§∞‡•Å‡§∞‡§§.--format: ClassName.StrongestExtensionName. --‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§õ‡§º‡§æ‡§® ‡§∏‡§æ‡§∞‡§ø‡§µ‡§Ø ‡§ñ‡•Å‡§§ ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶‡§π ‡§§‡§µ‡§æ‡§®‡•â‡§Ø‡•Ä ‡§§ ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§õ‡§º‡§æ‡§® ‡§Ø‡§ø‡§Æ‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§Ö‡§ñ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§µ‡§æ‡§™‡§∏ ‡•§--‡§è‡§ï‡•ç‡§∏‡§ü‡•á‡§Ç‡§∂‡§® ‡§®‡§æ‡§µ ‡§Æ‡§Ç‡§ú‡§º, ‡§§‡§æ‡§ï‡§§ ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§´‡•ç‡§∞‡•à‡§ï‡•ç‡§∂‡§® CAP - SM ‡§∏‡•á‡§•--‡§è‡§ï‡•ç‡§∏‡§ü‡•á‡§Ç‡§∂‡§® ‡§®‡§æ‡§µ ‡§Æ‡§Ç‡§ú‡§º ‡§≤‡§¨‡§∞‡•á‡§®,‡§§‡•á SM ‡§≤‡§ï‡•Å‡§ü ‡§≤‡§¨‡§∞‡•á‡§® ‡§π‡•Å‡§®‡•ç‡§¶ ‡§®‡§Ç‡§¨‡§∞ --‡§Ø‡•Å‡§∏ ‡§§‡§æ‡§ï‡§§ ‡§õ‡•Ä ‡§è‡§ï‡•ç‡§∏‡§ü‡•á‡§Ç‡§∂‡§® ‡§õ‡•Ä ‡§à‡§† ‡§™‡§æ‡§†:‡§Ø‡•á ‡§õ‡•Ä CAP ‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§Ö‡§™‡§∞‡§ï‡•á‡§∏ --‡§è‡§ï‡•ç‡§∏‡§ü‡•á‡§Ç‡§∂‡§® ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§∞‡§®‡•á ‡§§‡§æ‡§ï‡§ø ‡§è‡§Æ‡•ç ‡§ï‡§æ‡§∞‡§® ‡§≤‡•ã‡§° ‡§è‡§ï‡•ç‡§∏‡•ç‡§ü‡•ç‡§∞‡§æ ‡§ï‡•ç‡§≤‡§æ‡§∏--‡§Ö‡§∏ ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§¶‡•Ä‡§µ‡§æ‡§® ‡§µ‡§∞‡•ç‡§ó‡§ö‡§ø ‡§®‡§æ‡§µ (a string) ‡§§ ‡§è‡§ï‡•ç‡§∏‡§ü‡•á‡§Ç‡§∂‡§®‡§® ‡§π‡•ç‡§®‡•ç‡§ú‡§º ‡§∏‡•Ç‡§∞‡§§‡•§--  >>> strongestExtension ""my_class"" [""AA"",""Be"",""CC""]
--  ""my_class.AA""
strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions =","strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions = class_name ++ ""."" ++ strongestExt
  where
    calculateStrength :: String -> Int
    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)
    
    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)
    
    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)
    maxStrength ext1 ext2
      | snd ext1 > snd ext2 = ext1
      | otherwise           = ext2","
main :: IO ()
main = do
  let candidate = strongestExtension
  if candidate ""Watashi"" [""tEN"",""niNE"",""eIGHt8OKe""] == ""Watashi.eIGHt8OKe"" then pure () else error ""assertion failed""
  if candidate ""Boku123"" [""nani"",""NazeDa"",""YEs.WeCaNe"",""32145tggg""] == ""Boku123.YEs.WeCaNe"" then pure () else error ""assertion failed""
  if candidate ""__YESIMHERE"" [""t"",""eMptY"",""nothing"",""zeR00"",""NuLl__"",""123NoooneB321""] == ""__YESIMHERE.NuLl__"" then pure () else error ""assertion failed""
  if candidate ""K"" [""Ta"",""TAR"",""t234An"",""cosSo""] == ""K.TAR"" then pure () else error ""assertion failed""
  if candidate ""__HAHA"" [""Tab"",""123"",""781345"",""-_-""] == ""__HAHA.123"" then pure () else error ""assertion failed""
  if candidate ""YameRore"" [""HhAas"",""okIWILL123"",""WorkOut"",""Fails"",""-_-""] == ""YameRore.okIWILL123"" then pure () else error ""assertion failed""
  if candidate ""finNNalLLly"" [""Die"",""NowW"",""Wow"",""WoW""] == ""finNNalLLly.WoW"" then pure () else error ""assertion failed""
  if candidate ""_"" [""Bb"",""91245""] == ""_.Bb"" then pure () else error ""assertion failed""
  if candidate ""Sp"" [""671235"",""Bb""] == ""Sp.671235"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_154,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ ‡§§‡•Å‡§π‡•Ä‡§Æ ‡§¶‡•Å‡§Ø‡•ç‡§Ø‡§Æ ‡§≤‡§´‡•ç‡§ú‡§º ‡§Ø‡§æ ‡§ï‡•Å‡§Ç‡§§‡•á ‡§§‡•á‡§Æ‡§∏‡•Å‡§®‡•ç‡§¶ ‡§∞‡•ã‡§ü‡•á‡§∂‡§® ‡§õ‡•Ç ‡§ó‡•Å‡§°‡§®‡§ø‡§ï‡§ø‡§∏ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§∏‡§¨‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó,‡§§‡•á‡§Æ ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡•Ç ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§∏‡§π‡•Ä ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏‡§∏‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡§≤‡§§ ‡§≤‡§´‡•ç‡§ú‡§º‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏‡§∏--  >>> cycpatternCheck ""abcd"" ""abd""
--  False
--  >>> cycpatternCheck ""hello"" ""ell""
--  True
--  >>> cycpatternCheck ""whassup"" ""psus""
--  False
--  >>> cycpatternCheck ""abab"" ""baa""
--  True
--  >>> cycpatternCheck ""efef"" ""eeff""
--  False
--  >>> cycpatternCheck ""himenss"" ""simen""
--  True
cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b =","cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b = any (`isInfixOf` a) rotations
  where
    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","
main :: IO ()
main = do
  let candidate = cycpatternCheck
  if candidate ""xyzw"" ""xyw"" == False then pure () else error ""assertion failed""
  if candidate ""yello"" ""ell"" == True then pure () else error ""assertion failed""
  if candidate ""whattup"" ""ptut"" == False then pure () else error ""assertion failed""
  if candidate ""efef"" ""fee"" == True then pure () else error ""assertion failed""
  if candidate ""abab"" ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""winemtt"" ""tinem"" == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_155,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞. ‡§á‡§Ç‡§ü‡§∞‡§ú‡•á‡§∞.--  >>> evenOddCount (-12)
--  (1, 1)
--  >>> evenOddCount 123
--  (1, 2)
evenOddCount :: Int -> (Int, Int)
evenOddCount num =","evenOddCount :: Int -> (Int, Int)
evenOddCount num = (length evens, length odds)
  where
    digits = map (read . (:[])) . show . abs $ num
    evens = filter even digits
    odds  = filter odd digits","
main :: IO ()
main = do
  let candidate = evenOddCount
  if candidate 7 == (0, 1) then pure () else error ""assertion failed""
  if candidate (-78) == (1, 1) then pure () else error ""assertion failed""
  if candidate 3452 == (2, 2) then pure () else error ""assertion failed""
  if candidate 346211 == (3, 3) then pure () else error ""assertion failed""
  if candidate (-345821) == (3, 3) then pure () else error ""assertion failed""
  if candidate (-2) == (1, 0) then pure () else error ""assertion failed""
  if candidate (-45347) == (2, 3) then pure () else error ""assertion failed""
  if candidate 0 == (1, 0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_156,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§∞‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§ï‡•ç‡§ü‡•ç‡§∏: 1 <= ‡§®‡•Å‡§Æ <= 1000 --‡§§ ‡§§‡•Å‡§Æ‡§ø ‡§≤‡•ã‡§∞‡§ø‡§ï‡§≤‡§ø ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§ø‡•§-- ‡§™‡•â‡§ú‡§ø‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞,  ‡§∞‡•ã‡§Æ‡§® ‡§®‡•Å‡§Æ‡§æ‡§∞‡§ø‡§ï‡§æ‡§≤ ‡§∏‡§Æ‡§æ‡§® ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó,--  >>> intToMiniRoman 19
--  ""xix""
--  >>> intToMiniRoman 152
--  ""clii""
--  >>> intToMiniRoman 426
--  ""cdxxvi""
intToMiniRoman :: Int -> String
intToMiniRoman number =","intToMiniRoman :: Int -> String
intToMiniRoman number = concatMap (replicateSymbol number) romanNumerals
  where
    romanNumerals = [(1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
                     (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
                     (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""), (1, ""i"")]
    
    replicateSymbol :: Int -> (Int, String) -> String
    replicateSymbol n (value, symbol)
      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)
      | otherwise = """"","
main :: IO ()
main = do
  let candidate = intToMiniRoman
  if candidate 19 == ""xix"" then pure () else error ""assertion failed""
  if candidate 152 == ""clii"" then pure () else error ""assertion failed""
  if candidate 251 == ""ccli"" then pure () else error ""assertion failed""
  if candidate 426 == ""cdxxvi"" then pure () else error ""assertion failed""
  if candidate 500 == ""d"" then pure () else error ""assertion failed""
  if candidate 1 == ""i"" then pure () else error ""assertion failed""
  if candidate 4 == ""iv"" then pure () else error ""assertion failed""
  if candidate 43 == ""xliii"" then pure () else error ""assertion failed""
  if candidate 90 == ""xc"" then pure () else error ""assertion failed""
  if candidate 94 == ""xciv"" then pure () else error ""assertion failed""
  if candidate 532 == ""dxxxii"" then pure () else error ""assertion failed""
  if candidate 900 == ""cm"" then pure () else error ""assertion failed""
  if candidate 994 == ""cmxciv"" then pure () else error ""assertion failed""
  if candidate 1000 == ""m"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_157,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --90 ‡§°‡§ø‡§ó‡•ç‡§∞‡•Ä. --‡§Ø‡•Å‡§∏ ‡§∞‡•á‡§ï‡•ç‡§ü‡•à‡§Ç‡§ó‡§≤ ‡§ü‡•ç‡§∞‡§æ‡§à‡§è‡§Ç‡§ó‡§≤ ‡§õ‡•Ç ‡§∏‡•Å ‡§õ‡•Ç ‡§ü‡•ç‡§∞‡§æ‡§à‡§è‡§Ç‡§ó‡§≤ ‡§Ø‡§æ‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§Ü‡§Å‡§ñ ‡§è‡§Ç‡§ó‡§≤ ‡§õ‡•Ç ‡§∞‡•á‡§ï‡•ç‡§ü‡•à‡§Ç‡§ó‡§≤ ‡§Ø‡§æ --‡§Ö‡§ó‡§∞ ‡§Ö‡§∏ ‡§®‡•á ‡§Ö‡§∏ ‡§∏‡§π‡•Ä ,‡§§‡§ø‡§≤ ‡§Ö‡§∏ ‡§ó‡§≤‡§§--‡§Ö‡§ó‡§∞ ‡§§‡•ç‡§∞‡§ø‡§ï‡•ã‡§£‡§ï ‡§§‡•ç‡§∞‡•à‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§≤‡§Æ‡•ç‡§¨ ‡§õ‡•Ç ‡§∏‡§π‡•Ä,‡§§‡•á‡§≤ ‡§õ‡•Ç ‡§§‡•á‡§Æ ‡§≤‡§Ç‡§¨ ‡§õ‡•Ç ‡§∏‡§π‡•Ä.--  >>> rightAngleTriangle 3 4 5
--  True
--  >>> rightAngleTriangle 1 2 3
--  False
rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c =","rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c = 
    let [x, y, z] = sort [a, b, c]
    in x^2 + y^2 == z^2
    where sort = Data.List.sort","
main :: IO ()
main = do
  let candidate = rightAngleTriangle
  if candidate 3 4 5 == True then pure () else error ""assertion failed""
  if candidate 1 2 3 == False then pure () else error ""assertion failed""
  if candidate 10 6 8 == True then pure () else error ""assertion failed""
  if candidate 2 2 2 == False then pure () else error ""assertion failed""
  if candidate 7 24 25 == True then pure () else error ""assertion failed""
  if candidate 10 5 7 == False then pure () else error ""assertion failed""
  if candidate 5 12 13 == True then pure () else error ""assertion failed""
  if candidate 15 8 17 == True then pure () else error ""assertion failed""
  if candidate 48 55 73 == True then pure () else error ""assertion failed""
  if candidate 1 1 1 == False then pure () else error ""assertion failed""
  if candidate 2 2 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_158,kas_Deva,hs,"--‡§≤‡§´‡•ç‡§ú‡§º-‡§è-‡§ú‡§º‡§¨‡§æ‡§®‡•Ä ‡§Æ‡§Ç‡§ú‡§º,‡§Ö‡§• ‡§≤‡§´‡•ç‡§ú‡§º‡§∏ ‡§ï‡•Å‡§® ‡§µ‡§æ‡§™‡§∏ ‡§ï‡§∞‡§• ‡§Ø‡§ø‡§Æ ‡§≤‡§´‡•ç‡§ú‡§º-‡§è-‡§ú‡§º‡§¨‡§æ‡§®‡•Ä ‡§Æ‡§Ç‡§ú‡§º ‡§ó‡•Å‡§°‡§®‡§ø‡§ï‡§ø‡§∏ ‡§§‡§∞‡§´‡§º‡§∏ ‡§Ü‡§∏‡§®.--‡§Ö‡§ó‡§∞ ‡§Æ‡§≤‡•ç‡§ü‡•Ä‡§™‡•ç‡§≤ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡§Ç‡§ú‡§º ‡§Ö‡§∏‡•á ‡§Æ‡•á‡§ï‡§ú‡§º‡§ø‡§Æ ‡§®‡§Ç‡§¨‡§∞ ‡§Ø‡•Ç‡§®‡§ø‡§ï --‡§Ø‡•Å‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§Ö‡§• ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ä ‡§è‡§µ‡§Ç ‡§Ö‡§≤‡§ó ‡§≤‡§´‡§º‡§ú‡§º--‡§Ö‡§ñ ‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§≤‡§ø‡§ñ‡•ã ‡§Ø‡•Å‡§∏ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§π‡§ø‡§Ç‡§ú ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ç ‡§è‡§µ‡§æ.--  >>> findMax [""name"",""of"",""string""]
--  ""string""
--  >>> findMax [""name"",""enam"",""game""]
--  ""enam""
--  >>> findMax [""aaaaaaa"",""bb"",""cc""]
--  ""aaaaaaa""
findMax :: [String] -> String
findMax words =","import Data.List (nub, sort)

findMax :: [String] -> String
findMax words = 
    head . sort . map snd . filter (\(n, _) -> n == maxUnique) $ wordUniquePairs
  where
    wordUniquePairs = [(length . nub $ word, word) | word <- words]
    maxUnique = maximum $ map fst wordUniquePairs","
main :: IO ()
main = do
  let candidate = findMax
  if candidate [""name"",""of"",""string""] == ""string"" then pure () else error ""assertion failed""
  if candidate [""name"",""enam"",""game""] == ""enam"" then pure () else error ""assertion failed""
  if candidate [""aaaaaaa"",""bb"",""cc""] == ""aaaaaaa"" then pure () else error ""assertion failed""
  if candidate [""abc"",""cba""] == ""abc"" then pure () else error ""assertion failed""
  if candidate [""play"",""this"",""game"",""of"",""footbott""] == ""footbott"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""gonna"",""rock""] == ""gonna"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""a"",""mad"",""nation""] == ""nation"" then pure () else error ""assertion failed""
  if candidate [""this"",""is"",""a"",""prrk""] == ""this"" then pure () else error ""assertion failed""
  if candidate [""b""] == ""b"" then pure () else error ""assertion failed""
  if candidate [""play"",""play"",""play""] == ""play"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_159,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§Ö‡§ó‡§∞ ‡§Ü‡§∏ ‡§µ‡§∞‡§ø‡§Ø‡•á ‡§ï‡§Æ ‡§ï‡§æ‡§∞‡•ã‡§ü ,‡§§‡•ã ‡§§‡•Å‡§π‡•ç‡§π‡•Å‡§ï ‡§π‡§ï‡§º ‡§§‡•Å‡§≤ ‡§ï‡§æ‡§∞‡•ã‡§ü ‡§ñ‡§æ‡§• ,‡§≤‡§ï‡§ø‡§® ‡§§‡•Å‡§π‡•ç‡§π‡•Å‡§ï ‡§π‡§ï‡§º ‡§µ‡•á‡§® ‡§µ‡•Å‡§®‡§ñ--‡§Ø‡•Å‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§õ‡•Ä ‡§ó‡§æ‡§ú‡§∞ ‡§Ø‡•Å‡§∏ ‡§∞‡•ã‡§ú‡§º‡§® ‡§õ‡•Ä ‡§Æ‡•Ä‡§≤‡•ç‡§∏ ‡§™‡§æ‡§§ ] --‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ó‡§µ ‡§Ø‡§ø ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§µ‡§æ‡§™‡§∏ [ ‡§ï‡•Å‡§≤ ‡§ö‡•â‡§∞ ‡§ñ‡§æ‡§Æ‡•ç‡§§ ‡§ï‡§æ‡§∞‡•ç‡§ü‡•ç‡§∏ ‡§Ø‡§ø‡§Æ ‡§§‡•Å‡§π‡•ç‡§Ø‡§º ‡§ñ‡•â‡§∞ ‡§ñ‡§æ‡§Æ‡•ç‡§§ ‡§ï‡§∞‡§®‡§É ‡§Ü‡§Æ‡•Å‡§§ ‡§õ‡§ø, ]--‡§≤‡•á‡§ï‡§ø‡§® ‡§Ö‡§¨ ‡§§‡•Å‡§π ‡§™‡§®‡•Å‡§® ‡§¶‡§ø‡§®‡§ö ‡§ñ‡§æ‡§µ‡§®‡§ø ‡§ñ‡§æ‡§§‡•Ä‡§∞ ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶ ‡§ï‡§æ‡§∞‡•ã‡§ü ‡§ñ‡§æ‡•§--‚û°Ô∏è‡§§‡•Å‡§Æ ‡§≠‡•Ç‡§ñ‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§ó‡§æ‡§ú‡§∞ ‡§ñ‡§æ ‡§ö‡•Å‡§ï‡•á ‡§π‡•ã, ‚û°Ô∏è‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§ñ‡§∞‡§ó‡•ã‡§∂ ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§π‡•ã, ‡§§‡•Å‡§Æ ‡§ï‡•Å‡§õ ‡§Æ‡•ã‡§ü‡•á ‡§π‡•ã,--  >>> eat 5 6 10
--  [11,4]
--  >>> eat 4 8 9
--  [12,1]
--  >>> eat 1 10 10
--  [11,0]
--  >>> eat 2 11 5
--  [7,0]
--  Variables:
--  @number : integer
--  the number of carrots that you have eaten.
--  @need : integer
--  the number of carrots that you need to eat.
--  @remaining : integer
--  the number of remaining carrots thet exist in stock
--  Constrain:
--  * 0 <= number <= 1000
--  * 0 <= need <= 1000
--  * 0 <= remaining <= 1000
--  Have fun :)
eat :: Int -> Int -> Int -> [Int]
eat number need remaining =","eat :: Int -> Int -> Int -> [Int]
eat number need remaining
  | remaining >= need = [number + need, remaining - need]
  | otherwise = [number + remaining, 0]","
main :: IO ()
main = do
  let candidate = eat
  if candidate 5 6 10 == [11,4] then pure () else error ""assertion failed""
  if candidate 4 8 9 == [12,1] then pure () else error ""assertion failed""
  if candidate 1 10 10 == [11,0] then pure () else error ""assertion failed""
  if candidate 2 11 5 == [7,0] then pure () else error ""assertion failed""
  if candidate 4 5 7 == [9,2] then pure () else error ""assertion failed""
  if candidate 4 5 1 == [5,0] then pure () else error ""assertion failed""
  pure ()"
HumanEval_160,kas_Deva,hs,"--‡§ë‡§™‡§∞‡•á‡§ü‡§∞ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ç ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§Ö‡§ï‡§ø‡§∏ ‡§ë‡§™‡§∞‡•á‡§ü‡§∞‡§∏ ‡§Ö‡§∏‡§æ,‡§§‡•á ‡§ë‡§™‡§∞‡•á‡§®‡•ç‡§° ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡§Ç‡§ú‡§º ‡§õ‡•Ç ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§¶‡•Ç‡§Å ‡§ë‡§™‡§∞‡•á‡§®‡•ç‡§°‡§∏ ‡§Ö‡§∏‡§æ.--‡§ì‡§™‡§∞‡§Ç‡§° ‡§õ‡•Ç ‡§Ü‡§Å‡§ñ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§®‡•â‡§®-‡§®‡•á‡§ó‡•á‡§ü‡§ø‡§µ ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§π‡§ø‡§Ç‡§ú.--‡§Ø‡•Å‡§∏ ‡§≤‡•ã‡§Ç‡§ó ‡§õ‡•Ä ‡§ë‡§™‡§∞‡•á‡§ü‡§∞ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§∏‡•Å ‡§õ‡•Ä ‡§¨‡§∞‡§æ‡§¨‡§∞ ‡§≤‡•ã‡§Ç‡§ó ‡§ë‡§´‡§º ‡§ì‡§™‡•á‡§∞‡§æ‡§Ç‡§°‡•ç‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü -‡•ß--‡§®‡•ã‡§ü‡§É --=> ‡§∞‡§ø‡§ú‡§≤‡•ç‡§ü = 9 --‡§®‡§§‡•Ä‡§ú = 2 + 3 * 4 - 5 --list = [2, 3, 4, 5] --‡§ë‡§™‡§∞‡•á‡§ü‡§∞['+', '*', '-'] --‡§Æ‡§ø‡§∏‡§æ‡§≤: --‡§è‡§ï‡•ç‡§∏‡§™‡•ã‡§®‡•á‡§Ç‡§ü‡§ø‡§Ö‡§∂‡§® (**)--‡§´‡•ç‡§≤‡•ã‡§∞ ‡§°‡§ø‡§µ‡•Ä‡§ú‡§º‡§® ( //) --‡§Æ‡§≤‡•ç‡§ü‡•Ä‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§∂‡§® (*) --‡§∏‡§¨‡•ç‡§ü‡•ç‡§∞‡•à‡§ï‡•ç‡§∂‡§® ( - ) --‡§Ö‡§¶‡•ç‡§¶‡§ø‡§§‡•Ä‡§ì‡§Ç (+) --‡§Ø‡•Å‡§∏ ‡§¨‡•Å‡§®‡§ø‡§Ø‡§æ‡§¶‡•Ä ‡§Ö‡§≤‡§ú‡•á‡§¨‡•ç‡§∞‡§æ ‡§ë‡§™‡§∞‡•á‡§∂‡§® ‡§õ‡•Ä:--‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§∞‡•á‡§∂‡§® ‡§§‡•á ‡•á‡§µ‡§≤‡•ç‡§Ø‡•Ç‡§è‡§∂‡§® ‡§ë‡§´‡§º ‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§∞‡•á‡§∂‡§®--‡§Ø‡•Å‡§∏ ‡§¶‡•Å‡§à‡§Æ ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§∏‡•Å ‡§õ‡•Ä ‡§á‡§Ç‡§ü‡•á‡§ú‡§∞‡§∏ ‡§π‡•Å‡§®‡•ç‡§¶ ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§ï‡§æ‡§∞‡§® --‡•á‡§Æ‡•ã ‡§ï‡•Å‡§∞ ‡§¶‡•Å‡§®‡§µ‡§à ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ë‡§™‡§∞‡•á‡§ü‡§∞ ,‡§¨‡•á ‡§ë‡§™‡§∞‡•á‡§®‡•ç‡§° ,‡§Ø‡•Å‡§∏ ‡§ó‡•ã‡§°‡•ç‡§®‡•Å‡§á‡§ï ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§õ‡•Ä ‡§¨‡•á‡§∏‡§ø‡§ï ‡§Ö‡§≤‡§ú‡•á‡§¨‡•ç‡§∞‡§æ ‡§ë‡§™‡§∞‡•á‡§∂‡§® ,‡§¨‡•á ‡•á‡§Æ‡§® ‡§π‡•Å‡§®‡•ç‡§¶doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand =","doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand = evaluate operand operator
  where
    evaluate [x] [] = x
    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops
      where
        result = applyOperation op x y

    applyOperation ""+"" a b = a + b
    applyOperation ""-"" a b = a - b
    applyOperation ""*"" a b = a * b
    applyOperation ""//"" a b = a `div` b
    applyOperation ""**"" a b = a ^ b
    applyOperation _ _ _ = error ""Unsupported operation""","
main :: IO ()
main = do
  let candidate = doAlgebra
  if candidate [""**"",""*"",""+""] [2,3,4,5] == 37 then pure () else error ""assertion failed""
  if candidate [""+"",""*"",""-""] [2,3,4,5] == 9 then pure () else error ""assertion failed""
  if candidate [""//"",""*""] [7,3,4] == 8 then pure () else error ""assertion failed""
  pure ()"
HumanEval_161,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ --‡§´‡§Ç‡§ï‡•ç‡§∂‡§® ‡§õ‡•Ç ‡§∞‡§ø‡§ú‡§≤‡•ç‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§¶‡•á‡§µ‡§®.--‡§Ö‡§ó‡§∞ ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§Æ‡§Ç‡§ú‡§º ‡§ï‡§π‡§Å ‡§§‡•á ‡§≤‡§´‡§º‡§ú‡§º ‡§õ‡§æ‡§® ,‡§§‡§µ‡•á ‡§õ‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó ‡§â‡§≤‡§ü‡§æ ‡§ï‡§æ‡§∞‡§®--‡§Ö‡§ó‡§∞ ‡§®‡•á ‡§Ø‡•á ‡§π‡§ï‡§º ‡§Ö‡§∏‡§ø‡§• ‡§§ ‡§Ø‡•á ‡§π‡§ï‡§º ‡§Ö‡§∏‡§ø‡§• ‡§§‡•á‡§• ‡§™‡§æ‡§†--‡§Ö‡§ó‡§∞ s[i] ‡§Ö‡§ñ ‡§≤‡§´‡§º‡§ú‡§º ‡§õ‡•á, ‡§§‡§Æ‡§ø ‡§∏‡•Å‡§®‡•ç‡§¶ ‡§ï‡•á‡§∏ ‡§≤‡•ã‡§Ö‡§∞ ‡§™‡•á‡§† ‡§â‡§™‡•ç‡§™‡•á‡§∞ ‡§§‡§æ‡§Æ ‡§Ø‡§æ ‡§µ‡§ø‡§∏‡•á‡§∞‡§µ‡•á‡§∏ ‡§§‡§æ‡§Æ,--          --  >>> solve ""1234""
--  ""4321""
--  >>> solve ""ab""
--  ""AB""
--  >>> solve ""#a@C""
--  ""#A@c""
solve :: String -> String
solve s =","solve :: String -> String
solve s
  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s
  | otherwise = reverse s
  where
    toggleCase c
      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char
      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char
      | otherwise = c","
main :: IO ()
main = do
  let candidate = solve
  if candidate ""AsDf"" == ""aSdF"" then pure () else error ""assertion failed""
  if candidate ""1234"" == ""4321"" then pure () else error ""assertion failed""
  if candidate ""ab"" == ""AB"" then pure () else error ""assertion failed""
  if candidate ""#a@C"" == ""#A@c"" then pure () else error ""assertion failed""
  if candidate ""#AsdfW^45"" == ""#aSDFw^45"" then pure () else error ""assertion failed""
  if candidate ""#6@2"" == ""2@6#"" then pure () else error ""assertion failed""
  if candidate ""#$a^D"" == ""#$A^d"" then pure () else error ""assertion failed""
  if candidate ""#ccc"" == ""#CCC"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_162,kas_Deva,hs,"--‡§Ö‡§ó‡§∞ '‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü' ‡§õ‡•Ç ‡§ñ‡§≤‡•Ä ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó,‡§§‡•á‡§≤ ‡§õ‡•Ç ‡§®‡•â‡§ü ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§Ø‡•á‡§µ‡§æ ‡§ï‡§∞‡§®‡•á.-- '‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü' ‡§¶‡•á‡§à ‡§ó‡•á ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó, ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§á‡§ü‡•ç‡§∏ ‡§è‡§Æ‡§°‡•Ä5 ‡§π‡•à‡§∂ ‡§è‡§ï‡•ç‡§µ‡§ø‡§µ‡•à‡§≤‡•á‡§®‡•ç‡§ü ‡§∏‡•ç‡§ü‡•ç‡§∞‡§ø‡§Ç‡§ó. --  >>> stringToMd5 ""Hello world""
--  Just (""3e25960a79dbc69b674cd4ec67a72c62"")
stringToMd5 :: String -> Maybe String
stringToMd5 text =","import qualified Data.ByteString.Char8 as C
import qualified Data.Digest.Pure.MD5 as MD5

stringToMd5 :: String -> Maybe String
stringToMd5 text
  | null text = Nothing
  | otherwise = Just $ show $ MD5.md5 $ C.pack text","
main :: IO ()
main = do
  let candidate = stringToMd5
  if candidate ""Hello world"" == Just (""3e25960a79dbc69b674cd4ec67a72c62"") then pure () else error ""assertion failed""
  if candidate """" == Just (Nothing) then pure () else error ""assertion failed""
  if candidate ""A B C"" == Just (""0ef78513b0cb8cef12743f5aeb35f888"") then pure () else error ""assertion failed""
  if candidate ""password"" == Just (""5f4dcc3b5aa765d61d8327deb882cf99"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_163,kas_Deva,hs,"--‡§Æ‡§ø‡§∏‡§æ‡§≤ ‡§ï‡•Ä ‡§§‡•ã‡§∞: --‡§¨‡•Ä ,‡§è‡§Æ‡•ç ‡§õ‡•Ä ‡§æ‡§∏‡§ø‡§§ ‡§æ‡§∏‡§ø‡§§--Given two positive integers a and b, return the even digits between a  ‡§¨‡•Ä ‡§§‡•á ‡§è ‡§¨‡•Ä ‡§¨‡•Ä ‡§¨‡•Ä ‡§¨‡•Ä ‡§¨‡•Ä ‡§¨‡•Ä ‡§¨‡•Ä ‡§¨‡•Ä ‡§¨‡•Ä--  >>> generateIntegers 2 8
--  [2,4,6,8]
--  >>> generateIntegers 8 2
--  [2,4,6,8]
--  >>> generateIntegers 10 14
--  []
generateIntegers :: Int -> Int -> [Int]
generateIntegers a b =","generateIntegers :: Int -> Int -> [Int]
generateIntegers a b = filter even [min a b .. max a b]","
main :: IO ()
main = do
  let candidate = generateIntegers
  if candidate 2 10 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 10 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 132 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 17 89 == [] then pure () else error ""assertion failed""
  pure ()"
