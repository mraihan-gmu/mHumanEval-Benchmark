task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,ewe_Latn,go_test.go,"package has_close_elements_test

import (
    ""testing""
    ""fmt""
)

//le nu si le ame si ŋu nya wogblɔ la nu.//Kpɔe ɖa be xexlẽdzesi eve siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi// >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)
// false
// >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)
// true
func has_close_elements(numbers []float64, threshold float64) bool {
","package has_close_elements_test

import (
	""math""
	""sort""
	""testing""
)

// Check if in given list of numbers, are any two numbers closer to each other than
// given threshold.
func has_close_elements(numbers []float64, threshold float64) bool {
	sort.Float64s(numbers)
	for i := 0; i < len(numbers)-1; i++ {
		if math.Abs(numbers[i+1]-numbers[i]) < threshold {
			return true
		}
	}
	return false
}

func TestHasCloseElements(t *testing.T) {
	testCases := []struct {
		numbers   []float64
		threshold float64
		expected  bool
	}{
		{[]float64{1.0, 2.0, 3.0}, 0.5, false},
		{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},
		{[]float64{1.5, 1.8, 2.2}, 0.3, true},
		{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},
	}

	for i, tc := range testCases {
		t.Run(fmt.Sprintf(""TestCase%d"", i+1), func(t *testing.T) {
			result := has_close_elements(tc.numbers, tc.threshold)
			if result != tc.expected {
				t.Errorf(""expected %v, got %v"", tc.expected, result)
			}
		})
	}
}","func TestHas_Close_Elements(t *testing.T) {
  candidate := has_close_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_1,ewe_Latn,go_test.go,"package separate_paren_groups_test

import (
    ""testing""
    ""fmt""
)

//Mègaŋlɔ nya siwo le nyagbeawo me la be o.//Ƒuƒoƒo vovovoawo nɔa te ɖe wo nɔewo ŋu (wo dometɔ ɖe sia ɖe ƒe kɔme si le ʋuʋu la kuna nyuie) eye wometsɔa wo nɔewo dea eme o.//ɖe wo me ɖe ƒuƒoƒo me eye nàtrɔ asi le wo ŋu wòade wo me.//Dɔwɔƒe sia ƒe nuƒle nye nyagbe si me nuƒleƒle siwo le ƒuƒoƒo vovovowo me le. Wò taɖodzinu enye be // >>> separate_paren_groups(""( ) (( )) (( )( ))"")
// []string{""()"", ""(())"", ""(()())""}
func separate_paren_groups(paren_string string) []string {
","package separate_paren_groups

func separate_paren_groups(paren_string string) []string {
	var result []string
	var currentGroup []rune
	openCount := 0

	for _, char := range paren_string {
		if char == '(' {
			openCount++
			currentGroup = append(currentGroup, char)
		} else if char == ')' {
			openCount--
			currentGroup = append(currentGroup, char)

			if openCount == 0 {
				result = append(result, string(currentGroup))
				currentGroup = nil
			}
		}
	}

	return result
}","func TestSeparate_Paren_Groups(t *testing.T) {
  candidate := separate_paren_groups
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""(()()) ((())) () ((())()())""), expected: []string{""(()())"", ""((()))"", ""()"", ""((())()())""} },
     { actual: candidate(""() (()) ((())) (((())))""), expected: []string{""()"", ""(())"", ""((()))"", ""(((())))""} },
     { actual: candidate(""(()(())((())))""), expected: []string{""(()(())((())))""} },
     { actual: candidate(""( ) (( )) (( )( ))""), expected: []string{""()"", ""(())"", ""(()())""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_2,ewe_Latn,go_test.go,"package truncate_number_test

import (
    ""testing""
    ""fmt""
)

//Gblɔ xexlẽdzesi si le xexlẽdzesi la ƒe teƒe ewolia. //(nu si susɔ la anɔ sue wu 1 ɣesiaɣi).//kple xexlẽdzesi blibo ƒe akpa (xexlẽdzesi blibo si lolo wu si le sue wu xexlẽdzesi si wona) kple xexlẽdzesi siwo wotsɔ dea teƒe ewo me //Ne míetsɔ xexlẽdzesi si nye floating point si nye dzidzedze la, míate ŋu atsɔe aɖɔli ɖe // >>> truncate_number(3.5)
// 0.5
func truncate_number(number float64) float64 {
","package truncate_number_test

import (
    ""testing""
    ""fmt""
)

// Given a positive floating point number, it can be decomposed into
// an integer part (largest integer smaller than given number) and decimals
// (leftover part always smaller than 1).
// Return the decimal part of the number.
// >>> truncate_number(3.5)
// 0.5
func truncate_number(number float64) float64 {
    integerPart := int(number)
    return number - float64(integerPart)
}

func TestTruncateNumber(t *testing.T) {
    testCases := []struct {
        input float64
        expected float64
    }{
        {3.5, 0.5},
        {0.0, 0.0},
        {7.25, 0.25},
        {4.99, 0.99},
        {2.0, 0.0},
    }

    for _, tc := range testCases {
        result := truncate_number(tc.input)
        if result != tc.expected {
            t.Errorf(""Expected %.2f, got %.2f"", tc.expected, result)
        }
    }
}

func main() {
    fmt.Println(truncate_number(3.5)) // Should print 0.5
    fmt.Println(truncate_number(7.25)) // Should print 0.25
}","func TestTruncate_Number(t *testing.T) {
  candidate := truncate_number
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3.5), expected: 0.5 },
     { actual: candidate(1.25), expected: 0.25 },
     { actual: candidate(123.0), expected: 0.0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_3,ewe_Latn,go_test.go,"package below_zero_test

import (
    ""testing""
    ""fmt""
)

//le ɣeyiɣi ma me la, ele be dɔwɔwɔa naɖo nyateƒe. Ne menye nenema o la, ele be wòaɖo aʋatso.//wò dɔe nye be nàkpɔ ne ga si le wò ga me la dzi ɖe kpɔtɔ le teƒe aɖe, eye //Wona agbalẽ si me woŋlɔ ga siwo nèda kple esiwo nèɖe le gadzraɖoƒe si dze egɔme kple // >>> below_zero([]int{1, 2, 3})
// false
// >>> below_zero([]int{1, 2, -4, 5})
// true
func below_zero(operations []int) bool {
","package below_zero_test

import (
    ""testing""
    ""fmt""
)

func below_zero(operations []int) bool {
    balance := 0
    for _, op := range operations {
        balance += op
        if balance < 0 {
            return true
        }
    }
    return false
}

func TestBelowZero(t *testing.T) {
    testCases := []struct {
        operations []int
        expected   bool
    }{
        {[]int{1, 2, 3}, false},
        {[]int{1, 2, -4, 5}, true},
        {[]int{0, -1, 1}, true},
        {[]int{}, false},
        {[]int{-1, 1, -1, 1}, true},
    }
    for _, tc := range testCases {
        result := below_zero(tc.operations)
        if result != tc.expected {
            t.Errorf(""below_zero(%v) = %v; want %v"", tc.operations, result, tc.expected)
        }
    }
}","func TestBelow_Zero(t *testing.T) {
  candidate := below_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: false },
     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },
     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },
     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },
     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },
     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_4,ewe_Latn,go_test.go,"package mean_absolute_deviation_test

import (
    ""testing""
    ""fmt""
)

//MAD = average. x - x_mean. //element kple titina (le go sia me la, enye nu si le edzi yim le titina): //Medzidzenu si le ame ɖekaɖekawo dome la ƒe mama le ame ɖekaɖekawo dome enye //le nyatakaka siawo ƒe domedome lɔƒo. //Ne ètsɔ xexlẽdzesi siwo wotsɔ de asi la ƒe xexlẽdzesi aɖe na wò la, bu Alesi Woƒe Numekukuwo To To To Godoo la ŋu // >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})
// 1.0
func mean_absolute_deviation(numbers []float64) float64 {
","package mean_absolute_deviation_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func mean_absolute_deviation(numbers []float64) float64 {
    var sum float64
    for _, num := range numbers {
        sum += num
    }
    mean := sum / float64(len(numbers))

    var madSum float64
    for _, num := range numbers {
        madSum += math.Abs(num - mean)
    }
    return madSum / float64(len(numbers))
}

func TestMeanAbsoluteDeviation(t *testing.T) {
    tests := []struct {
        input []float64
        want  float64
    }{
        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},
        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},
        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""mean_absolute_deviation(%v)"", test.input), func(t *testing.T) {
            got := mean_absolute_deviation(test.input)
            if got != test.want {
                t.Errorf(""mean_absolute_deviation(%v) = %v; want %v"", test.input, got, test.want)
            }
        })
    }
}","func TestMean_Absolute_Deviation(t *testing.T) {
  candidate := mean_absolute_deviation
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_5,ewe_Latn,go_test.go,"package intersperse_test

import (
    ""testing""
    ""fmt""
)

//De dzesi 'delimeter' le nu eve siwo le ɖoɖo nu la dome ∀numbers"" // >>> intersperse([]int{}, 4)
// []int{}
// >>> intersperse([]int{1, 2, 3}, 4)
// []int{1, 4, 2, 4, 3}
func intersperse(numbers []int, delimeter int) []int {
","package intersperse_test

import (
    ""testing""
    ""fmt""
)

func intersperse(numbers []int, delimiter int) []int {
    if len(numbers) == 0 {
        return []int{}
    }

    result := make([]int, 0, len(numbers)*2-1)
    for i, num := range numbers {
        if i > 0 {
            result = append(result, delimiter)
        }
        result = append(result, num)
    }
    return result
}

func TestIntersperse(t *testing.T) {
    testCases := []struct{
        input []int
        delimiter int
        expected []int
    }{
        {[]int{}, 4, []int{}},
        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},
        {[]int{1}, 4, []int{1}},
        {[]int{1, 2}, 4, []int{1, 4, 2}},
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf(""%v, %d"", tc.input, tc.delimiter), func(t *testing.T) {
            result := intersperse(tc.input, tc.delimiter)
            if !equal(result, tc.expected) {
                t.Errorf(""Expected %v, but got %v"", tc.expected, result)
            }
        })
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    
    return true
}","func TestIntersperse(t *testing.T) {
  candidate := intersperse
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}, 7), expected: []int{} },
     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },
     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_6,ewe_Latn,go_test.go,"package parse_nested_parens_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me, (() (()) ƒe akpa si woƒona le la ƒe akpa eve koe ate ŋu anɔ, eye ((())) ya ƒe akpa etɔ̃. //Na ƒuƒoƒo ɖesiaɖe naɖe nu siwo me wodzidze nu ɖo le la ƒe akpa si lolo wu la ɖe go. //Dɔwɔƒe sia ƒe nuƒle nye ƒuƒoƒo geɖe siwo wotsɔ nuƒleƒle siwo dome nɔlawoe ma me ƒe ƒuƒoƒowo.// >>> parse_nested_parens(""(()()) ((())) () ((())()())"")
// []int{2, 3, 1, 3}
func parse_nested_parens(paren_string string) []int {
","func parse_nested_parens(paren_string string) []int {
    groups := strings.Fields(paren_string)
    depths := make([]int, len(groups))

    for i, group := range groups {
        maxDepth, currentDepth := 0, 0
        for _, char := range group {
            if char == '(' {
                currentDepth++
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == ')' {
                currentDepth--
            }
        }
        depths[i] = maxDepth
    }

    return depths
}","func TestParse_Nested_Parens(t *testing.T) {
  candidate := parse_nested_parens
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""(()()) ((())) () ((())()())""), expected: []int{2, 3, 1, 3} },
     { actual: candidate(""() (()) ((())) (((())))""), expected: []int{1, 2, 3, 4} },
     { actual: candidate(""(()(())((())))""), expected: []int{4} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_7,ewe_Latn,go_test.go,"package filter_by_substring_test

import (
    ""testing""
    ""fmt""
)

//Filter input list of strings only for ones that contain given substring  Eʋe siwo le ŋɔŋlɔdzesi siwo wotsɔ ɖo ŋɔŋlɔdzesi me la ko// >>> filter_by_substring([]string{}, ""a"")
// []string{}
// >>> filter_by_substring([]string{""abc"", ""bacd"", ""cde"", ""array""}, ""a"")
// []string{""abc"", ""bacd"", ""array""}
func filter_by_substring(strings []string, substring string) []string {
","package filter_by_substring_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func filter_by_substring(strings []string, substring string) []string {
    var result []string
    for _, str := range strings {
        if strings.Contains(str, substring) {
            result = append(result, str)
        }
    }
    return result
}

func TestFilterBySubstring(t *testing.T) {
    tests := []struct {
        input    []string
        substring string
        expected []string
    }{
        {[]string{}, ""a"", []string{}},
        {[]string{""abc"", ""bacd"", ""cde"", ""array""}, ""a"", []string{""abc"", ""bacd"", ""array""}},
    }

    for _, test := range tests {
        result := filter_by_substring(test.input, test.substring)
        if fmt.Sprintf(""%q"", result) != fmt.Sprintf(""%q"", test.expected) {
            t.Errorf(""filter_by_substring(%q, %q) = %q; expected %q"", test.input, test.substring, result, test.expected)
        }
    }
}","func TestFilter_By_Substring(t *testing.T) {
  candidate := filter_by_substring
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, ""john""), expected: []string{} },
     { actual: candidate([]string{""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xxx""), expected: []string{""xxx"", ""xxxAAA"", ""xxx""} },
     { actual: candidate([]string{""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xx""), expected: []string{""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""} },
     { actual: candidate([]string{""grunt"", ""trumpet"", ""prune"", ""gruesome""}, ""run""), expected: []string{""grunt"", ""prune""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_8,ewe_Latn,go_test.go,"package sum_product_test

import (
    ""testing""
    ""fmt""
)

//Ele be nu si wotsɔ ƒo ƒui la nanye 0 eye nu si wotsɔ ƒo ƒui la nanye 1. //Ne ètsɔ xexlẽdzesi blibowo ƒe ŋkɔwo le eme la, trɔ asi le xexlẽdzesi siwo katã le eme ƒe xexlẽdzesi siwo nye xexlẽdzesi siwo katã le eme ƒe xexlẽdzesi siwo nye wo ƒe xexlẽdzesi siwo nye wo ƒe xexlẽdzesi siwo nye wo ƒe xexlẽdzesi siwo nye wo ƒe xexlẽdzesi siwo nye wo ƒe xexlẽdzesi siwo nye wo ƒe xexlẽdzesi siwo nye wo ƒe xexlẽdzesi siwo nye wo tɔ la ƒe xexlẽdzesi siwo nye wo tɔ.// >>> sum_product([]int{})
// []interface{}{0, 1}
// >>> sum_product([]int{1, 2, 3, 4})
// []interface{}{10, 24}
func sum_product(numbers []int) []interface{} {
","func sum_product(numbers []int) []interface{} {
    sum := 0
    product := 1
    for _, number := range numbers {
        sum += number
        product *= number
    }
    return []interface{}{sum, product}
}","func TestSum_Product(t *testing.T) {
  candidate := sum_product
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []interface{}{0, 1} },
     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },
     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },
     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },
     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_9,ewe_Latn,go_test.go,"package rolling_max_test

import (
    ""testing""
    ""fmt""
)

//le ɖoɖo nu.//Tso xexlẽdzesi blibowo ƒe ŋkɔ si wona la dzi la, wɔ xexlẽdzesi siwo dzi woate ŋu akpɔ le ɣeyiɣi si wonae la ƒe ŋkɔwo.// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})
// []int{1, 2, 3, 3, 3, 4, 4}
func rolling_max(numbers []int) []int {
","package rolling_max_test

import (
    ""testing""
    ""fmt""
)

// From a given list of integers, generate a list of rolling maximum element found until given moment
// in the sequence.
// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})
// []int{1, 2, 3, 3, 3, 4, 4}
func rolling_max(numbers []int) []int {
    if len(numbers) == 0 {
        return []int{}
    }
    result := make([]int, len(numbers))
    maxSoFar := numbers[0]
    for i, num := range numbers {
        if num > maxSoFar {
            maxSoFar = num
        }
        result[i] = maxSoFar
    }
    return result
}

func TestRollingMax(t *testing.T) {
    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) // should output []int{1, 2, 3, 3, 3, 4, 4}
}","func TestRolling_Max(t *testing.T) {
  candidate := rolling_max
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },
     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },
     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_10,ewe_Latn,go_test.go,"package make_palindrome_test

import (
    ""testing""
    ""fmt""
)

//- Tsɔ kpe ɖe kpeɖeŋutɔ si doa ŋgɔ na palindromic ƒe kpeɖeŋutɔ la ŋu le kpeɖeŋutɔ ƒe nuwuwu. //- Kpɔe ɖa be nu si wotsɔ ɖo kpe nya siwo wotsɔ ɖo kpe dzi la ƒe akpa si didi wu si nye palindrome la nye esi. //Nuŋɔŋlɔdzesi si ŋu wotrɔ asi le le bɔbɔe: //Kpɔ palindrome kpui si dze egɔme kple nyagbe si wotsɔ ɖo la. // >>> make_palindrome("""")
// """"
// >>> make_palindrome(""cat"")
// ""catac""
// >>> make_palindrome(""cata"")
// ""catac""
func make_palindrome(myString string) string {
","package make_palindrome_test

import (
    ""testing""
)

func make_palindrome(myString string) string {
    if len(myString) <= 1 {
        return myString
    }
    
    // Helper function to check if a string is a palindrome
    isPalindrome := func(s string) bool {
        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
            if s[i] != s[j] {
                return false
            }
        }
        return true
    }

    // Start from the whole string and reduce until we find a palindrome
    for i := len(myString); i > 0; i-- {
        if isPalindrome(myString[len(myString)-i:]) {
            prefix := myString[:len(myString)-i]
            // Reverse the prefix and append to original string
            reversedPrefix := reverse(prefix)
            return myString + reversedPrefix
        }
    }

    // If no palindromic suffix is found, return original string with reverse appended
    return myString + reverse(myString)
}

// Helper function to reverse a string
func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func TestMakePalindrome(t *testing.T) {
    tests := []struct {
        input    string
        expected string
    }{
        {"""", """"},
        {""cat"", ""catac""},
        {""cata"", ""catac""},
    }

    for _, test := range tests {
        result := make_palindrome(test.input)
        if result != test.expected {
            t.Errorf(""make_palindrome(%q) = %q; expected %q"", test.input, result, test.expected)
        }
    }
}","func TestMake_Palindrome(t *testing.T) {
  candidate := make_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""x""), expected: ""x"" },
     { actual: candidate(""xyz""), expected: ""xyzyx"" },
     { actual: candidate(""xyx""), expected: ""xyx"" },
     { actual: candidate(""jerry""), expected: ""jerryrrej"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_11,ewe_Latn,go_test.go,"package string_xor_test

import (
    ""testing""
    ""fmt""
)

//Wɔ XOR le nu siawo dzi eye nàtrɔ nu si ado tso eme la hã wòazu string. //Aƒomevi eve siwo nye a kple b siwo me 1 kple 0 koe le la koe nye nuƒogbalẽvi.// >>> string_xor(""010"", ""110"")
// ""100""
func string_xor(a string, b string) string {
","result := make([]byte, len(a))
	for i := 0; i < len(a); i++ {
		if a[i] == b[i] {
			result[i] = '0'
		} else {
			result[i] = '1'
		}
	}
	return string(result)
}","func TestString_Xor(t *testing.T) {
  candidate := string_xor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""111000"", ""101010""), expected: ""010010"" },
     { actual: candidate(""1"", ""1""), expected: ""0"" },
     { actual: candidate(""0101"", ""0000""), expected: ""0101"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_13,ewe_Latn,go_test.go,"package greatest_common_divisor_test

import (
    ""testing""
    ""fmt""
)

//Gbugbɔa ame eve siwo nye xexlẽdzesi blibo a kple b ƒe mama gãtɔ la ƒoa ƒui // >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
func greatest_common_divisor(a int, b int) int {
","package greatest_common_divisor_test

import (
    ""testing""
    ""fmt""
)

// Return a greatest common divisor of two integers a and b
// >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
func greatest_common_divisor(a int, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func TestGreatestCommonDivisor(t *testing.T) {
    tests := []struct {
        a, b   int
        expect int
    }{
        {3, 5, 1},
        {25, 15, 5},
        {54, 24, 6},
        {48, 18, 6},
        {101, 103, 1},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d,%d"", test.a, test.b), func(t *testing.T) {
            result := greatest_common_divisor(test.a, test.b)
            if result != test.expect {
                t.Errorf(""expected %d, got %d"", test.expect, result)
            }
        })
    }
}","func TestGreatest_Common_Divisor(t *testing.T) {
  candidate := greatest_common_divisor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 7), expected: 1 },
     { actual: candidate(10, 15), expected: 5 },
     { actual: candidate(49, 14), expected: 7 },
     { actual: candidate(144, 60), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_14,ewe_Latn,go_test.go,"package all_prefixes_test

import (
    ""testing""
    ""fmt""
)

//Etrɔna nya siwo katã wotsɔ ɖo kpe nyagbewo dzi tso nyagbe kpuiwo dzi va se ɖe nyagbe didiwo dzi la ƒe ŋkɔwo // >>> all_prefixes(""abc"")
// []string{""a"", ""ab"", ""abc""}
func all_prefixes(myString string) []string {
","package all_prefixes_test

import (
    ""testing""
    ""fmt""
)

// Return list of all prefixes from shortest to longest of the input string
// >>> all_prefixes(""abc"")
// []string{""a"", ""ab"", ""abc""}
func all_prefixes(myString string) []string {
    var prefixes []string
    for i := 1; i <= len(myString); i++ {
        prefixes = append(prefixes, myString[:i])
    }
    return prefixes
}

func TestAllPrefixes(t *testing.T) {
    result := all_prefixes(""abc"")
    expected := []string{""a"", ""ab"", ""abc""}
    for i, v := range result {
        if v != expected[i] {
            t.Errorf(""Test failed, expected %v, got %v"", expected[i], v)
        }
    }
    fmt.Println(""Test passed"")
}","func TestAll_Prefixes(t *testing.T) {
  candidate := all_prefixes
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: []string{} },
     { actual: candidate(""asdfgh""), expected: []string{""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""} },
     { actual: candidate(""WWW""), expected: []string{""W"", ""WW"", ""WWW""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_15,ewe_Latn,go_test.go,"package string_sequence_test

import (
    ""testing""
    ""fmt""
)

//Gbugbɔ string si me numelɔ siwo woɖo ɖi le teƒea le tso 0 va se ɖe n dzi. // >>> string_sequence(0)
// ""0""
// >>> string_sequence(5)
// ""0 1 2 3 4 5""
func string_sequence(n int) string {
","package string_sequence_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

// Return a string containing space-delimited numbers starting from 0 upto n inclusive.
func string_sequence(n int) string {
    var parts []string
    for i := 0; i <= n; i++ {
        parts = append(parts, fmt.Sprintf(""%d"", i))
    }
    return strings.Join(parts, "" "")
}

func TestStringSequence(t *testing.T) {
    result := string_sequence(0)
    expected := ""0""
    if result != expected {
        t.Errorf(""Expected %s, got %s"", expected, result)
    }
    
    result = string_sequence(5)
    expected = ""0 1 2 3 4 5""
    if result != expected {
        t.Errorf(""Expected %s, got %s"", expected, result)
    }
}","func TestString_Sequence(t *testing.T) {
  candidate := string_sequence
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0), expected: ""0"" },
     { actual: candidate(3), expected: ""0 1 2 3"" },
     { actual: candidate(10), expected: ""0 1 2 3 4 5 6 7 8 9 10"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_16,ewe_Latn,go_test.go,"package count_distinct_characters_test

import (
    ""testing""
    ""fmt""
)

//Ne wotsɔ nyagbe aɖe na wò la, ke kpɔ be ŋɔŋlɔdzesi vovovo nenie le eme (ɖikeke mele eme o be ŋɔŋlɔdzesi gãe loo alo suee wònye o) // >>> count_distinct_characters(""xyzXYZ"")
// 3
// >>> count_distinct_characters(""Jerry"")
// 4
func count_distinct_characters(myString string) int {
","package count_distinct_characters_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func count_distinct_characters(myString string) int {
    characterMap := make(map[rune]bool)
    for _, char := range strings.ToLower(myString) {
        characterMap[char] = true
    }
    return len(characterMap)
}

func TestCountDistinctCharacters(t *testing.T) {
    testCases := []struct{
        input string
        expected int
    }{
        {""xyzXYZ"", 3},
        {""Jerry"", 4},
        {"""", 0},
        {""Hello, World!"", 10},
    }

    for _, testCase := range testCases {
        result := count_distinct_characters(testCase.input)
        if result != testCase.expected {
            t.Errorf(""For input '%s', expected %d but got %d"", testCase.input, testCase.expected, result)
        } else {
            fmt.Printf(""Test passed for input '%s': got %d\n"", testCase.input, result)
        }
    }
}","func TestCount_Distinct_Characters(t *testing.T) {
  candidate := count_distinct_characters
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""abcde""), expected: 5 },
     { actual: candidate(""abcdecadeCADE""), expected: 5 },
     { actual: candidate(""aaaaAAAAaaaa""), expected: 1 },
     { actual: candidate(""Jerry jERRY JeRRRY""), expected: 5 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_17,ewe_Latn,go_test.go,"package parse_music_test

import (
    ""testing""
    ""fmt""
)

//'Hake' - enye to ene me nya si nɔa anyi ɣeyiɣi ɖeka.//'o sa - nu afã, eye wòxɔa zi eve.//'o' - enye toƒoƒo blibo, si nɔa anyi ɣeyiɣi ene //Ŋutinya aɖe gblɔ be://menye mamlɛtɔ o.//Wò dɔe nye be nàxlẽ ŋɔŋlɔdzesi sia eye nàna xexlẽdzesi siwo sɔ kple zi neni si wo dometɔ ɖe sia ɖe ƒoa ƒui la ƒe ŋkɔ nàkpɔ.//Dɔwɔƒe sia ƒe nuƒle nye haƒonu siwo le ASCII-ŋɔŋlɔdzesi tɔxɛ aɖe me.// >>> parse_music(""o o| .| o| o| .| .| .| .| o o"")
// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}
func parse_music(music_string string) []int {
","package parse_music_test

import (
    ""strings""
)

func parse_music(music_string string) []int {
    notes := strings.Fields(music_string)
    beats := make([]int, len(notes))
    for i, note := range notes {
        switch note {
        case ""o"":
            beats[i] = 4
        case ""o|"":
            beats[i] = 2
        case "".|"":
            beats[i] = 1
        }
    }
    return beats
}","func TestParse_Music(t *testing.T) {
  candidate := parse_music
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: []int{} },
     { actual: candidate(""o o o o""), expected: []int{4, 4, 4, 4} },
     { actual: candidate("".| .| .| .|""), expected: []int{1, 1, 1, 1} },
     { actual: candidate(""o| o| .| .| o o o o""), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },
     { actual: candidate(""o| .| o| .| o o| o o|""), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_18,ewe_Latn,go_test.go,"package how_many_times_test

import (
    ""testing""
    ""fmt""
)

//Kpɔ zi nenie woate ŋu akpɔ nyagbɔgblɔ aɖe le nyagbɔgblɔ gbãtɔa me. Xlẽ nya siwo do ƒome kplii. // >>> how_many_times("""", ""a"")
// 0
// >>> how_many_times(""aaa"", ""a"")
// 3
// >>> how_many_times(""aaaa"", ""aa"")
// 3
func how_many_times(myString string, substring string) int {
","func how_many_times(myString string, substring string) int {
    if len(substring) == 0 {
        return 0
    }

    count := 0
    for i := 0; i <= len(myString)-len(substring); i++ {
        if myString[i:i+len(substring)] == substring {
            count++
        }
    }
    return count
}

func TestHowManyTimes(t *testing.T) {
    tests := []struct {
        myString  string
        substring string
        expected  int
    }{
        {"""", ""a"", 0},
        {""aaa"", ""a"", 3},
        {""aaaa"", ""aa"", 3},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%s in %s"", test.substring, test.myString), func(t *testing.T) {
            result := how_many_times(test.myString, test.substring)
            if result != test.expected {
                t.Errorf(""Expected %d but got %d"", test.expected, result)
            }
        })
    }
}","func TestHow_Many_Times(t *testing.T) {
  candidate := how_many_times
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate("""", ""x""), expected: 0 },
     { actual: candidate(""xyxyxyx"", ""x""), expected: 4 },
     { actual: candidate(""cacacacac"", ""cac""), expected: 4 },
     { actual: candidate(""john doe"", ""john""), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_19,ewe_Latn,go_test.go,"package sort_numbers_test

import (
    ""testing""
    ""fmt""
)

//Gbugbɔa xɔname siwo me xexlẽdzesiwo le tso suetɔ yi gãtɔ dzi la ɖo //Tiatia siwo sɔ enye 'aʋaa', 'ɖeka', 'eve', 'etɔ̃', 'ene', 'atɔ̃', 'ade', 'adre', 'enyi' kple 'asieke'. //Numeral siwo tso 'zero' va ɖo 'nine' ƒe xexlẽdzesiwo ƒe xexlẽdzesi si wotsɔ teƒe ɖo la ye nye nu si wotsɔna dea eme.// >>> sort_numbers(""three one five"")
// ""one three five""
func sort_numbers(numbers string) string {
","package sort_numbers_test

import (
    ""strings""
    ""sort""
)

func sort_numbers(numbers string) string {
    wordsToNumbers := map[string]int{
        ""zero"":  0,
        ""one"":   1,
        ""two"":   2,
        ""three"": 3,
        ""four"":  4,
        ""five"":  5,
        ""six"":   6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"":  9,
    }
    
    numbersToWords := []string{""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine""}
    
    words := strings.Fields(numbers)
    numberInts := make([]int, len(words))
    
    for i, word := range words {
        numberInts[i] = wordsToNumbers[word]
    }
    
    sort.Ints(numberInts)
    
    sortedWords := make([]string, len(words))
    for i, num := range numberInts {
        sortedWords[i] = numbersToWords[num]
    }
    
    return strings.Join(sortedWords, "" "")
}","func TestSort_Numbers(t *testing.T) {
  candidate := sort_numbers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""three""), expected: ""three"" },
     { actual: candidate(""three five nine""), expected: ""three five nine"" },
     { actual: candidate(""five zero four seven nine eight""), expected: ""zero four five seven eight nine"" },
     { actual: candidate(""six five four three two one zero""), expected: ""zero one two three four five six"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_20,ewe_Latn,go_test.go,"package find_closest_elements_test

import (
    ""testing""
    ""fmt""
)

//Ne èdi be yeakpɔ nu bubu siwo le agbalẽa me la, nàŋlɔ wo ɖe ɖoɖo nu (ne xexlẽme si le sue la, xexlẽme si le gãe).//Tia xexlẽdzesi eve siwo te ɖe wo dometɔ ɖesiaɖe ŋu wu le xexlẽdzesi siwo wotsɔ vɛ (siwo ƒe didime nye eve ya teti) me eye nàtsɔ eve siwo te ɖe wo dometɔ ɖesiaɖe ŋu wu la aɖo egbɔ // >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})
// []interface{}{2.0, 2.2}
// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})
// []interface{}{2.0, 2.0}
func find_closest_elements(numbers []float64) []interface{} {
","package find_closest_elements_test

import (
    ""math""
    ""sort""
)

func find_closest_elements(numbers []float64) []interface{} {
    if len(numbers) < 2 {
        return nil
    }
    
    // Create a sorted copy of the numbers
    sortedNumbers := make([]float64, len(numbers))
    copy(sortedNumbers, numbers)
    sort.Float64s(sortedNumbers)
    
    // Initialize the minimum difference and result
    minDiff := math.MaxFloat64
    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}
    
    // Iterate over the sorted numbers to find the closest pair
    for i := 1; i < len(sortedNumbers); i++ {
        diff := sortedNumbers[i] - sortedNumbers[i-1]
        if diff < minDiff {
            minDiff = diff
            result[0] = sortedNumbers[i-1]
            result[1] = sortedNumbers[i]
        }
    }
    
    return result
}","func TestFind_Closest_Elements(t *testing.T) {
  candidate := find_closest_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },
     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },
     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_21,ewe_Latn,go_test.go,"package rescale_to_unit_test

import (
    ""testing""
    ""fmt""
)

//ale be xexlẽdzesi suetɔ nava zu 0 eye gãtɔ nava zu 1 //Ne èkpɔ xexlẽdzesiwo le xexlẽdzesi siwo le xexlẽdzesi eve ya teti me la, zãa linear transform le xexlẽdzesi siwo le xexlẽdzesi eve ya teti me ŋu.// >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})
// []float64{0.0, 0.25, 0.5, 0.75, 1.0}
func rescale_to_unit(numbers []float64) []float64 {
","package rescale_to_unit_test

import (
	""testing""
	""fmt""
)

func rescale_to_unit(numbers []float64) []float64 {
	if len(numbers) < 2 {
		return numbers
	}
	
	minVal := numbers[0]
	maxVal := numbers[0]
	for _, num := range numbers {
		if num < minVal {
			minVal = num
		} else if num > maxVal {
			maxVal = num
		}
	}

	scale := maxVal - minVal
	if scale == 0 {
		return make([]float64, len(numbers))
	}

	rescaled := make([]float64, len(numbers))
	for i, num := range numbers {
		rescaled[i] = (num - minVal) / scale
	}

	return rescaled
}

func TestRescaleToUnit(t *testing.T) {
	tests := []struct {
		input    []float64
		expected []float64
	}{
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},
		{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},
		{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},
		{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},
	}

	for _, test := range tests {
		result := rescale_to_unit(test.input)
		for i, v := range result {
			if v != test.expected[i] {
				t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
				break
			}
		}
	}
}","func TestRescale_To_Unit(t *testing.T) {
  candidate := rescale_to_unit
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },
     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },
     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },
     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },
     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_22,ewe_Latn,go_test.go,"package filter_integers_test

import (
    ""testing""
    ""fmt""
)

//Filter list given of any gothon values only for integers  (Nɔ xexlẽdzesi blibowo ko ŋu)// >>> filter_integers([]float64{""a"", 3.14, 5})
// []int{5}
// >>> filter_integers([]interface{}{1, 2, 3, ""abc"", map[interface{}]interface{}{}, []interface{}{}})
// []int{1, 2, 3}
func filter_integers(values []interface{}) []int {
","func filter_integers(values []interface{}) []int {
    var result []int
    for _, v := range values {
        if intValue, ok := v.(int); ok {
            result = append(result, intValue)
        }
    }
    return result
}

func TestFilterIntegers(t *testing.T) {
    cases := []struct {
        input    []interface{}
        expected []int
    }{
        {
            input:    []interface{}{1, 2, 3, ""abc"", map[interface{}]interface{}{}, []interface{}{}},
            expected: []int{1, 2, 3},
        },
        {
            input:    []interface{}{""a"", 3.14, 5},
            expected: []int{5},
        },
    }

    for _, c := range cases {
        result := filter_integers(c.input)
        if !equal(result, c.expected) {
            t.Errorf(""filter_integers(%v) == %v, expected %v"", c.input, result, c.expected)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }
    return true
}","func TestFilter_Integers(t *testing.T) {
  candidate := filter_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]interface{}{}), expected: []int{} },
     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, ""adasd""}), expected: []int{4, 9} },
     { actual: candidate([]interface{}{3, ""c"", 3, 3, ""a"", ""b""}), expected: []int{3, 3, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_23,ewe_Latn,go_test.go,"package strlen_test

import (
    ""testing""
    ""fmt""
)

//Gbedasi ƒe didime si wona // >>> strlen("""")
// 0
// >>> strlen(""abc"")
// 3
func strlen(myString string) int {
","return len(myString)
}","func TestStrlen(t *testing.T) {
  candidate := strlen
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""x""), expected: 1 },
     { actual: candidate(""asdasnakj""), expected: 9 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_24,ewe_Latn,go_test.go,"package largest_divisor_test

import (
    ""testing""
    ""fmt""
)

//Ne ètsɔ xexlẽdzesi n na mí la, ke kpɔ xexlẽdzesi si lolo wu si mamã n sɔsɔe, si le sue wu n la ɖa.// >>> largest_divisor(15)
// 5
func largest_divisor(n int) int {
","package largest_divisor_test

import (
    ""testing""
    ""fmt""
)

// For a given number n, find the largest number that divides n evenly, smaller than n
// >>> largest_divisor(15)
// 5
func largest_divisor(n int) int {
    for i := n/2; i > 0; i-- {
        if n%i == 0 {
            return i
        }
    }
    return 1
}

func TestLargestDivisor(t *testing.T) {
    cases := []struct {
        input    int
        expected int
    }{
        {15, 5},
        {100, 50},
        {49, 7},
        {81, 27},
        {1, 1},
    }

    for _, c := range cases {
        result := largest_divisor(c.input)
        if result != c.expected {
            t.Errorf(""largest_divisor(%d) == %d, expected %d"", c.input, result, c.expected)
        }
    }
}

func main() {
    fmt.Println(largest_divisor(15))
}","func TestLargest_Divisor(t *testing.T) {
  candidate := largest_divisor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: 1 },
     { actual: candidate(7), expected: 1 },
     { actual: candidate(10), expected: 5 },
     { actual: candidate(100), expected: 50 },
     { actual: candidate(49), expected: 7 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_25,ewe_Latn,go_test.go,"package factorize_test

import (
    ""testing""
    ""fmt""
)

//Ele be nu siwo katã wotsɔ wɔ numekuku la nasɔ kple nu siwo katã wotsɔ wɔ numekuku la ƒe agbɔsɔsɔ.//Ele be woaŋlɔ nu vevi ɖe sia ɖe ƒe xexlẽme si sɔ kple zi nenie wòdzɔna le nuŋɔŋlɔa me.//Enaa xexlẽdzesi blibo aɖe ƒe mamawo ƒe xexlẽdzesi gbãtɔwo le ɖoɖo nu tso suetɔ dzi va se ɖe gãtɔ dzi.// >>> factorize(8)
// []int{2, 2, 2}
// >>> factorize(25)
// []int{5, 5}
// >>> factorize(70)
// []int{2, 5, 7}
func factorize(n int) []int {
","package factorize

func factorize(n int) []int {
	var factors []int
	for i := 2; i*i <= n; i++ {
		for n%i == 0 {
			factors = append(factors, i)
			n /= i
		}
	}
	if n > 1 {
		factors = append(factors, n)
	}
	return factors
}","func TestFactorize(t *testing.T) {
  candidate := factorize
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: []int{2} },
     { actual: candidate(4), expected: []int{2, 2} },
     { actual: candidate(8), expected: []int{2, 2, 2} },
     { actual: candidate(57), expected: []int{3, 19} },
     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },
     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },
     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },
     { actual: candidate(18), expected: []int{2, 3, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_26,ewe_Latn,go_test.go,"package remove_duplicates_test

import (
    ""testing""
    ""fmt""
)

//Na nu siwo nèŋlɔ ɖi la nanɔ ɖoɖo ɖeka me.//Ðe nusiwo katã dzena zi gbɔ zi ɖeka la ɖa le xexlẽdzesi blibowo ƒe ŋkɔ me. // >>> remove_duplicates([]int{1, 2, 3, 2, 4})
// []int{1, 3, 4}
func remove_duplicates(numbers []int) []int {
","package remove_duplicates_test

import (
	""testing""
	""fmt""
)

func remove_duplicates(numbers []int) []int {
	counts := make(map[int]int)
	for _, num := range numbers {
		counts[num]++
	}

	result := []int{}
	for _, num := range numbers {
		if counts[num] == 1 {
			result = append(result, num)
		}
	}
	return result
}

func TestRemoveDuplicates(t *testing.T) {
	tests := []struct {
		input    []int
		expected []int
	}{
		{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},
		{[]int{1, 1, 1, 1}, []int{}},
		{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},
		{[]int{5, 5, 5, 6}, []int{6}},
		{[]int{9, 8, 9, 8, 7}, []int{7}},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""remove_duplicates(%v)"", test.input), func(t *testing.T) {
			result := remove_duplicates(test.input)
			if len(result) != len(test.expected) {
				t.Errorf(""Expected length %d, got %d"", len(test.expected), len(result))
			}
			for i, v := range result {
				if v != test.expected[i] {
					t.Errorf(""Expected %v, got %v"", test.expected, result)
					break
				}
			}
		})
	}
}","func TestRemove_Duplicates(t *testing.T) {
  candidate := remove_duplicates
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },
     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_27,ewe_Latn,go_test.go,"package flip_case_test

import (
    ""testing""
    ""fmt""
)

//Ne èle nyagbe aɖe si wotsɔ ŋɔŋlɔdzesi suewo ŋlɔm la, trɔ ŋɔŋlɔdzesi suewo na ŋɔŋlɔdzesi gãwo eye nàtrɔ ŋɔŋlɔdzesi gãwo na ŋɔŋlɔdzesi suewo. // >>> flip_case(""Hello"")
// ""hELLO""
func flip_case(myString string) string {
","func flip_case(myString string) string {
	var result []rune
	for _, char := range myString {
		if char >= 'a' && char <= 'z' {
			result = append(result, char-('a'-'A'))
		} else if char >= 'A' && char <= 'Z' {
			result = append(result, char+('a'-'A'))
		} else {
			result = append(result, char)
		}
	}
	return string(result)
}","func TestFlip_Case(t *testing.T) {
  candidate := flip_case
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""Hello!""), expected: ""hELLO!"" },
     { actual: candidate(""These violent delights have violent ends""), expected: ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_28,ewe_Latn,go_test.go,"package concatenate_test

import (
    ""testing""
    ""fmt""
)

//Ɖo mɔ̃wo ƒe ŋkɔwo ɖe mɔ̃ ɖeka me // >>> concatenate([]string{})
// """"
// >>> concatenate([]string{""a"", ""b"", ""c""})
// ""abc""
func concatenate(strings []string) string {
","result := """"
    for _, str := range strings {
        result += str
    }
    return result
}","func TestConcatenate(t *testing.T) {
  candidate := concatenate
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}), expected: """" },
     { actual: candidate([]string{""x"", ""y"", ""z""}), expected: ""xyz"" },
     { actual: candidate([]string{""x"", ""y"", ""z"", ""w"", ""k""}), expected: ""xyzwk"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_29,ewe_Latn,go_test.go,"package filter_by_prefix_test

import (
    ""testing""
    ""fmt""
)

//Dzidze nya siwo wotsɔ kpe kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya siwo wotsɔ kpe ɖe nya aɖe ŋu la ŋu la ŋu.// >>> filter_by_prefix([]string{}, ""a"")
// []string{}
// >>> filter_by_prefix([]string{""abc"", ""bcd"", ""cde"", ""array""}, ""a"")
// []string{""abc"", ""array""}
func filter_by_prefix(strings []string, prefix string) []string {
","package filter_by_prefix_test

import (
    ""testing""
)

// Filter an input list of strings only for ones that start with a given prefix.
func filter_by_prefix(strings []string, prefix string) []string {
    var result []string
    for _, str := range strings {
        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {
            result = append(result, str)
        }
    }
    return result
}

func TestFilterByPrefix(t *testing.T) {
    tests := []struct {
        input    []string
        prefix   string
        expected []string
    }{
        {[]string{}, ""a"", []string{}},
        {[]string{""abc"", ""bcd"", ""cde"", ""array""}, ""a"", []string{""abc"", ""array""}},
        {[]string{""hello"", ""helium"", ""world""}, ""he"", []string{""hello"", ""helium""}},
        {[]string{""banana"", ""band"", ""bandana""}, ""ban"", []string{""banana"", ""band"", ""bandana""}},
        {[]string{""apple"", ""ape"", ""apricot""}, ""ap"", []string{""apple"", ""ape"", ""apricot""}},
    }

    for _, test := range tests {
        result := filter_by_prefix(test.input, test.prefix)
        if !equal(result, test.expected) {
            t.Errorf(""filter_by_prefix(%v, %s) = %v; expected %v"", test.input, test.prefix, result, test.expected)
        }
    }
}

func equal(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestFilter_By_Prefix(t *testing.T) {
  candidate := filter_by_prefix
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, ""john""), expected: []string{} },
     { actual: candidate([]string{""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""}, ""xxx""), expected: []string{""xxx"", ""xxxAAA"", ""xxx""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_30,ewe_Latn,go_test.go,"package get_positive_test

import (
    ""testing""
    ""fmt""
)

//Xlẽ xexlẽdzesi siwo nye dzidzimegbalẽwo ko le nuŋlɔɖia me. // >>> get_positive([]int{-1, 2, -4, 5, 6})
// []int{2, 5, 6}
// >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// []int{5, 3, 2, 3, 9, 123, 1}
func get_positive(l []int) []int {
","package get_positive_test

import (
    ""testing""
    ""fmt""
)

// Return only positive numbers in the list.
func get_positive(l []int) []int {
    var positiveNumbers []int
    for _, num := range l {
        if num > 0 {
            positiveNumbers = append(positiveNumbers, num)
        }
    }
    return positiveNumbers
}

func TestGetPositive(t *testing.T) {
    tests := []struct {
        input  []int
        output []int
    }{
        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},
        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},
    }
    
    for _, test := range tests {
        result := get_positive(test.input)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", test.output) {
            t.Errorf(""Expected %v, got %v"", test.output, result)
        }
    }
}","func TestGet_Positive(t *testing.T) {
  candidate := get_positive
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },
     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },
     { actual: candidate([]int{-1, -2}), expected: []int{} },
     { actual: candidate([]int{}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_31,ewe_Latn,go_test.go,"package is_prime_test

import (
    ""testing""
    ""fmt""
)

//Ne xexlẽdzesi aɖe nye gbãtɔ la, egatrɔna va nye nyateƒe, eye ne menye nenema o la, egadzena aʋatso. // >>> is_prime(6)
// false
// >>> is_prime(101)
// true
// >>> is_prime(11)
// true
// >>> is_prime(13441)
// true
// >>> is_prime(61)
// true
// >>> is_prime(4)
// false
// >>> is_prime(1)
// false
func is_prime(n int) bool {
","package is_prime_test

import (
    ""testing""
    ""fmt""
)

func is_prime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func TestIsPrime(t *testing.T) {
    testCases := []struct {
        number   int
        expected bool
    }{
        {6, false},
        {101, true},
        {11, true},
        {13441, true},
        {61, true},
        {4, false},
        {1, false},
    }

    for _, testCase := range testCases {
        result := is_prime(testCase.number)
        if result != testCase.expected {
            t.Errorf(""is_prime(%d) = %v; want %v"", testCase.number, result, testCase.expected)
        } else {
            fmt.Printf(""Test Passed: is_prime(%d) = %v\n"", testCase.number, result)
        }
    }
}","func TestIs_Prime(t *testing.T) {
  candidate := is_prime
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(6), expected: false },
     { actual: candidate(101), expected: true },
     { actual: candidate(11), expected: true },
     { actual: candidate(13441), expected: true },
     { actual: candidate(61), expected: true },
     { actual: candidate(4), expected: false },
     { actual: candidate(1), expected: false },
     { actual: candidate(5), expected: true },
     { actual: candidate(11), expected: true },
     { actual: candidate(17), expected: true },
     { actual: candidate(85), expected: false },
     { actual: candidate(77), expected: false },
     { actual: candidate(255379), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_33,ewe_Latn,go_test.go,"package sort_third_test

import (
    ""testing""
    ""fmt""
)

//Wotsɔa wo dometɔ ɖesiaɖe sɔna kple l ƒe xexlẽdzesi siwo sɔ, gake woɖɔa wo ɖo.//l' sɔ kple l le nu siwo womate ŋu ama ɖe etɔ̃ o me, eye eƒe asixɔxɔwo le nu siwo womate ŋu ama ɖe etɔ̃ o me sɔ //Dɔwɔƒe sia xɔa ŋkɔwo ƒe ƒuƒoƒo l eye wòɖoa ŋkɔwo ƒe ƒuƒoƒo l' si nye be // >>> sort_third([]int{1, 2, 3})
// []int{1, 2, 3}
// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})
// []int{2, 6, 3, 4, 8, 9, 5}
func sort_third(l []int) []int {
","package sort_third_test

import (
    ""sort""
)

func sort_third(l []int) []int {
    type pair struct {
        index int
        value int
    }

    // Collect the pairs where indices are divisible by 3
    sortSection := []pair{}

    for i := 0; i < len(l); i++ {
        if i%3 == 0 {
            sortSection = append(sortSection, pair{index: i, value: l[i]})
        }
    }

    // Sort this section based on the values
    sort.Slice(sortSection, func(i, j int) bool {
        return sortSection[i].value < sortSection[j].value
    })

    // Generate result slice
    result := make([]int, len(l))
    copy(result, l)

    // Fill the sorted values back to the result
    for _, p := range sortSection {
        result[p.index] = p.value
    }

    return result
}","func TestSort_Third(t *testing.T) {
  candidate := sort_third
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },
     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },
     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },
     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_34,ewe_Latn,go_test.go,"package unique_test

import (
    ""testing""
    ""fmt""
)

//Etrɔna nu siwo wota ɖe ɖoɖo nu le list me la ƒe ɖeka // >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{0, 2, 3, 5, 9, 123}
func unique(l []int) []int {
","package unique_test

import (
    ""sort""
)

func unique(l []int) []int {
    uniqueMap := make(map[int]bool)
    for _, value := range l {
        uniqueMap[value] = true
    }

    uniqueSlice := make([]int, 0, len(uniqueMap))
    for key := range uniqueMap {
        uniqueSlice = append(uniqueSlice, key)
    }

    sort.Ints(uniqueSlice)
    return uniqueSlice
}","func TestUnique(t *testing.T) {
  candidate := unique
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_35,ewe_Latn,go_test.go,"package max_element_test

import (
    ""testing""
    ""fmt""
)

//Egbɔna nu vevi si le list la me wu. // >>> max_element([]int{1, 2, 3})
// 3
// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// 123
func max_element(l []int) int {
","package max_element_test

import (
    ""testing""
    ""fmt""
)

// Return maximum element in the list.
// >>> max_element([]int{1, 2, 3})
// 3
// >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})
// 123
func max_element(l []int) int {
    if len(l) == 0 {
        panic(""Empty list has no maximum value"")
    }
    max := l[0]
    for _, value := range l {
        if value > max {
            max = value
        }
    }
    return max
}

func TestMaxElement(t *testing.T) {
    testCases := []struct {
        input    []int
        expected int
    }{
        {[]int{1, 2, 3}, 3},
        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},
        {[]int{-1, -2, -3, -4}, -1},
        {[]int{9, 9, 9, 9}, 9},
    }

    for _, testCase := range testCases {
        result := max_element(testCase.input)
        if result != testCase.expected {
            t.Errorf(""For input %v, expected %d, got %d"", testCase.input, testCase.expected, result)
        }
    }
}","func TestMax_Element(t *testing.T) {
  candidate := max_element
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: 3 },
     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_36,ewe_Latn,go_test.go,"package fizz_buzz_test

import (
    ""testing""
    ""fmt""
)

//Xlẽ zi nenie xexlẽdzesi 7 dze le xexlẽdzesi siwo mede n o siwo woma ɖe 11 alo 13 me. // >>> fizz_buzz(50)
// 0
// >>> fizz_buzz(78)
// 2
// >>> fizz_buzz(79)
// 3
func fizz_buzz(n int) int {
","package fizz_buzz_test

import (
    ""testing""
    ""fmt""
    ""strconv""
)

func fizz_buzz(n int) int {
    count := 0
    for i := 0; i < n; i++ {
        if i % 11 == 0 || i % 13 == 0 {
            count += countSevens(i)
        }
    }
    return count
}

func countSevens(num int) int {
    strNum := strconv.Itoa(num)
    count := 0
    for _, c := range strNum {
        if c == '7' {
            count++
        }
    }
    return count
}

func TestFizzBuzz(t *testing.T) {
    tests := []struct {
        input int
        expected int
    }{
        {50, 0},
        {78, 2},
        {79, 3},
    }

    for _, test := range tests {
        result := fizz_buzz(test.input)
        if result != test.expected {
            t.Errorf(""fizz_buzz(%d) = %d; expected %d"", test.input, result, test.expected)
        }
    }
}

func main() {
    fmt.Println(fizz_buzz(50)) // 0
    fmt.Println(fizz_buzz(78)) // 2
    fmt.Println(fizz_buzz(79)) // 3
}","func TestFizz_Buzz(t *testing.T) {
  candidate := fizz_buzz
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(50), expected: 0 },
     { actual: candidate(78), expected: 2 },
     { actual: candidate(79), expected: 3 },
     { actual: candidate(100), expected: 3 },
     { actual: candidate(200), expected: 6 },
     { actual: candidate(4000), expected: 192 },
     { actual: candidate(10000), expected: 639 },
     { actual: candidate(100000), expected: 8026 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_37,ewe_Latn,go_test.go,"package sort_even_test

import (
    ""testing""
    ""fmt""
)

//Gake woɖɔ wo ɖo.//l' sɔ kple l le nuŋɔŋlɔ siwo nye ɖeka kple eve la me, gake eƒe asixɔxɔwo sɔ le nuŋɔŋlɔ siwo nye eve la me //Dɔwɔƒe sia xɔa ŋkɔwo ƒe ƒuƒoƒo l eye wòɖoa ŋkɔwo ƒe ƒuƒoƒo l' si nye be // >>> sort_even([]int{1, 2, 3})
// []int{1, 2, 3}
// >>> sort_even([]int{5, 6, 3, 4})
// []int{3, 6, 5, 4}
func sort_even(l []int) []int {
","package sort_even_test

import (
    ""sort""
)

func sort_even(l []int) []int {
    if len(l) < 2 {
        return l
    }
    
    // Extract even indices
    evens := []int{}
    for i := 0; i < len(l); i += 2 {
        evens = append(evens, l[i])
    }
    
    // Sort even-indexed elements
    sort.Ints(evens)
    
    // Merge sorted evens back into the original list
    j := 0
    for i := 0; i < len(l); i += 2 {
        l[i] = evens[j]
        j++
    }

    return l
}","func TestSort_Even(t *testing.T) {
  candidate := sort_even
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },
     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },
     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_39,ewe_Latn,go_test.go,"package prime_fib_test

import (
    ""testing""
    ""fmt""
)

//prime_fib ɖoa xexlẽdzesi si nye Fibonacci ƒe xexlẽdzesi si nye prime hã la teƒe.// >>> prime_fib(1)
// 2
// >>> prime_fib(2)
// 3
// >>> prime_fib(3)
// 5
// >>> prime_fib(4)
// 13
// >>> prime_fib(5)
// 89
func prime_fib(n int) int {
","package prime_fib_test

import (
    ""testing""
    ""fmt""
)

// isPrime checks if a number is prime
func isPrime(num int) bool {
    if num <= 1 {
        return false
    }
    if num <= 3 {
        return true
    }
    if num%2 == 0 || num%3 == 0 {
        return false
    }
    for i := 5; i*i <= num; i += 6 {
        if num%i == 0 || num%(i+2) == 0 {
            return false
        }
    }
    return true
}

// prime_fib returns n-th number that is a Fibonacci number and it's also prime.
func prime_fib(n int) int {
    if n <= 0 {
        return 0
    }
    a, b := 1, 1
    count := 0
    for count < n {
        a, b = b, a+b
        if isPrime(a) {
            count++
        }
    }
    return a
}

func TestPrimeFib(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {1, 2},
        {2, 3},
        {3, 5},
        {4, 13},
        {5, 89},
    }

    for _, test := range tests {
        result := prime_fib(test.input)
        if result != test.expected {
            t.Errorf(""prime_fib(%d) = %d; expected %d"", test.input, result, test.expected)
        } else {
            fmt.Printf(""prime_fib(%d) = %d\n"", test.input, result)
        }
    }
}","func TestPrime_Fib(t *testing.T) {
  candidate := prime_fib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 2 },
     { actual: candidate(2), expected: 3 },
     { actual: candidate(3), expected: 5 },
     { actual: candidate(4), expected: 13 },
     { actual: candidate(5), expected: 89 },
     { actual: candidate(6), expected: 233 },
     { actual: candidate(7), expected: 1597 },
     { actual: candidate(8), expected: 28657 },
     { actual: candidate(9), expected: 514229 },
     { actual: candidate(10), expected: 433494437 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_40,ewe_Latn,go_test.go,"package triples_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

//Ne woƒo wo katã nu ƒu la, woanye nu si mesɔ o.//ne nu etɔ̃ siwo to vovo le ŋkɔawo dome le ŋkɔawo dome la, woatrɔe be true//triple_sum_to_zero xɔa xexlẽdzesi blibowo ƒe ŋkɔwo abe nuŋɔŋlɔ ene.// >>> triples_sum_to_zero([]int{1, 3, 5, 0})
// false
// >>> triples_sum_to_zero([]int{1, 3, -2, 1})
// true
// >>> triples_sum_to_zero([]int{1, 2, 3, 7})
// false
// >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})
// true
// >>> triples_sum_to_zero([]int{1})
// false
func triples_sum_to_zero(l []int) bool {
","func triples_sum_to_zero(l []int) bool {
    n := len(l)
    if n < 3 {
        return false
    }
    
    for i := 0; i < n-2; i++ {
        for j := i + 1; j < n-1; j++ {
            for k := j + 1; k < n; k++ {
                if l[i]+l[j]+l[k] == 0 {
                    return true
                }
            }
        }
    }
    
    return false
}

func TestTriplesSumToZero(t *testing.T) {
    tests := []struct {
        input  []int
        output bool
    }{
        {[]int{1, 3, 5, 0}, false},
        {[]int{1, 3, -2, 1}, true},
        {[]int{1, 2, 3, 7}, false},
        {[]int{2, 4, -5, 3, 9, 7}, true},
        {[]int{1}, false},
    }

    for _, test := range tests {
        result := triples_sum_to_zero(test.input)
        if result != test.output {
            t.Errorf(""For input %v, expected %v, got %v"", test.input, test.output, result)
        }
    }
}

func main() {
    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    // false
    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   // true
    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    // false
    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) // true
    fmt.Println(triples_sum_to_zero([]int{1}))              // false
}","func TestTriples_Sum_To_Zero(t *testing.T) {
  candidate := triples_sum_to_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 3, 5, 0}), expected: false },
     { actual: candidate([]int{1, 3, 5, -1}), expected: false },
     { actual: candidate([]int{1, 3, -2, 1}), expected: true },
     { actual: candidate([]int{1, 2, 3, 7}), expected: false },
     { actual: candidate([]int{1, 2, 5, 7}), expected: false },
     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },
     { actual: candidate([]int{1}), expected: false },
     { actual: candidate([]int{1, 3, 5, -100}), expected: false },
     { actual: candidate([]int{100, 3, 5, -100}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_41,ewe_Latn,go_test.go,"package car_race_collision_test

import (
    ""testing""
    ""fmt""
)

//Dɔwɔƒe sia ɖoa afɔku siawo ƒe xexlẽme ɖe go. //Woƒe zɔzɔme le abe ɖe womegakpe wo nɔewo o ene.//Gake ʋu siawo sẽ ŋu eye wosesẽ ale gbegbe; esia wɔe be wole zɔzɔm.//ne ʋu aɖe si le zɔzɔm tso miame yi ɖusime la dze ʋu bubu si le zɔzɔm tso miame yi miame dzi.//Ne ʋu eve le du ƒum la, woƒoa ʋua wo nɔewo.//Ʋu eveawo dze mɔ tso adzɔge ʋĩ tso wo nɔewo gbɔ.//Ʋu n le ʋum tso miame yi ɖusime; le ɣeyiɣi ma ke me la, ʋuwo ƒe ƒuƒoƒo bubu aɖe si nye n le ʋum //Tsɔe be mɔ aɖe le dzɔdzɔe bliboe eye wòkeke ʋuu keke ta.func car_race_collision(n int) int {
","package car_race_collision_test

import (
    ""testing""
)

func car_race_collision(n int) int {
    return n
}

func TestCarRaceCollision(t *testing.T) {
    cases := []struct {
        n        int
        expected int
    }{
        {1, 1},
        {2, 2},
        {3, 3},
        {10, 10},
        {0, 0},
    }

    for _, c := range cases {
        result := car_race_collision(c.n)
        if result != c.expected {
            t.Errorf(""car_race_collision(%d) == %d, expected %d"", c.n, result, c.expected)
        }
    }
}","func TestCar_Race_Collision(t *testing.T) {
  candidate := car_race_collision
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: 4 },
     { actual: candidate(3), expected: 9 },
     { actual: candidate(4), expected: 16 },
     { actual: candidate(8), expected: 64 },
     { actual: candidate(10), expected: 100 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_42,ewe_Latn,go_test.go,"package incr_list_test

import (
    ""testing""
    ""fmt""
)

//Woatrɔa nu siwo wotsɔ 1 dzi ɖe edzi la ɖe wo ŋu.// >>> incr_list([]int{1, 2, 3})
// []int{2, 3, 4}
// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}
func incr_list(l []int) []int {
","package incr_list_test

import (
    ""testing""
    ""fmt""
)

// Return list with elements incremented by 1.
// >>> incr_list([]int{1, 2, 3})
// []int{2, 3, 4}
// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})
// []int{6, 4, 6, 3, 4, 4, 10, 1, 124}
func incr_list(l []int) []int {
    result := make([]int, len(l))
    for i, val := range l {
        result[i] = val + 1
    }
    return result
}

func TestIncrList(t *testing.T) {
    cases := []struct {
        input    []int
        expected []int
    }{
        {[]int{1, 2, 3}, []int{2, 3, 4}},
        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},
    }

    for _, c := range cases {
        result := incr_list(c.input)
        for i := range result {
            if result[i] != c.expected[i] {
                t.Errorf(""incr_list(%v) == %v, expected %v"", c.input, result, c.expected)
            }
        }
    }
}

func main() {
    fmt.Println(incr_list([]int{1, 2, 3}))          // should print [2, 3, 4]
    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) // should print [6, 4, 6, 3, 4, 4, 10, 1, 124]
}","func TestIncr_List(t *testing.T) {
  candidate := incr_list
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },
     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_43,ewe_Latn,go_test.go,"package pairs_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

//Ne woƒo wo katã nu ƒu la, woanye nu si mesɔ o.//ne nu eve siwo to vovo le ŋkɔa me siwo nye //pairs_sum_to_zero xɔa xexlẽdzesi blibowo ƒe ŋkɔwo abe nuŋɔŋlɔwo ene. // >>> pairs_sum_to_zero([]int{1, 3, 5, 0})
// false
// >>> pairs_sum_to_zero([]int{1, 3, -2, 1})
// false
// >>> pairs_sum_to_zero([]int{1, 2, 3, 7})
// false
// >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})
// true
// >>> pairs_sum_to_zero([]int{1})
// false
func pairs_sum_to_zero(l []int) bool {
","package pairs_sum_to_zero_test

import (
    ""testing""
    ""fmt""
)

func pairs_sum_to_zero(l []int) bool {
    numSet := make(map[int]struct{})
    for _, num := range l {
        if _, found := numSet[-num]; found {
            return true
        }
        numSet[num] = struct{}{}
    }
    return false
}

func TestPairsSumToZero(t *testing.T) {
    testCases := []struct {
        input    []int
        expected bool
    }{
        {[]int{1, 3, 5, 0}, false},
        {[]int{1, 3, -2, 1}, false},
        {[]int{1, 2, 3, 7}, false},
        {[]int{2, 4, -5, 3, 5, 7}, true},
        {[]int{1}, false},
    }

    for _, tc := range testCases {
        result := pairs_sum_to_zero(tc.input)
        if result != tc.expected {
            t.Errorf(""pairs_sum_to_zero(%v) = %v; expected %v"", tc.input, result, tc.expected)
        } else {
            fmt.Printf(""Test passed for input: %v, result: %v\n"", tc.input, result)
        }
    }
}","func TestPairs_Sum_To_Zero(t *testing.T) {
  candidate := pairs_sum_to_zero
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 3, 5, 0}), expected: false },
     { actual: candidate([]int{1, 3, -2, 1}), expected: false },
     { actual: candidate([]int{1, 2, 3, 7}), expected: false },
     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },
     { actual: candidate([]int{1}), expected: false },
     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },
     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },
     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },
     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_44,ewe_Latn,go_test.go,"package change_base_test

import (
    ""testing""
    ""fmt""
)

//xexlẽdzesi siwo le woƒe xɔnuvia ƒe kɔpi me la mede 10 o.//trɔna string ƒe nuŋɔŋlɔa le tɔtrɔ megbe.//Trɔ x si nye xexlẽdzesi si dzi wotrɔ asi le la wòava zu xexlẽdzesi si dzi wotrɔ asi le.// >>> change_base(8, 3)
// ""22""
// >>> change_base(8, 2)
// ""1000""
// >>> change_base(7, 2)
// ""111""
func change_base(x int, base int) string {
","package change_base_test

import (
    ""strconv""
    ""testing""
    ""fmt""
)

func change_base(x int, base int) string {
    if base < 2 || base > 9 {
        return """"
    }

    result := """"
    for x > 0 {
        remainder := x % base
        result = strconv.Itoa(remainder) + result
        x = x / base
    }
    
    if result == """" {
        return ""0""
    }
    return result
}

func TestChangeBase(t *testing.T) {
    tests := []struct {
        x      int
        base   int
        result string
    }{
        {8, 3, ""22""},
        {8, 2, ""1000""},
        {7, 2, ""111""},
        {0, 2, ""0""},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d to base %d"", test.x, test.base), func(t *testing.T) {
            res := change_base(test.x, test.base)
            if res != test.result {
                t.Errorf(""expected %s, got %s"", test.result, res)
            }
        })
    }
}","func TestChange_Base(t *testing.T) {
  candidate := change_base
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(8, 3), expected: ""22"" },
     { actual: candidate(9, 3), expected: ""100"" },
     { actual: candidate(234, 2), expected: ""11101010"" },
     { actual: candidate(16, 2), expected: ""10000"" },
     { actual: candidate(8, 2), expected: ""1000"" },
     { actual: candidate(7, 2), expected: ""111"" },
     { actual: candidate(2, 3), expected: ""2"" },
     { actual: candidate(3, 4), expected: ""3"" },
     { actual: candidate(4, 5), expected: ""4"" },
     { actual: candidate(5, 6), expected: ""5"" },
     { actual: candidate(6, 7), expected: ""6"" },
     { actual: candidate(7, 8), expected: ""7"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_45,ewe_Latn,go_test.go,"package triangle_area_test

import (
    ""testing""
    ""fmt""
)

//Ne wotsɔ axa ƒe didime kple teƒe si wotrɔna ɖo ƒe lolome na dzogoe etɔ̃ la,// >>> triangle_area(5, 3)
// 7.5
func triangle_area(a int, h int) float64 {
","package triangle_area_test

import (
    ""testing""
    ""fmt""
)

// Given length of a side and height return area for a triangle.
// >>> triangle_area(5, 3)
// 7.5
func triangle_area(a int, h int) float64 {
    return 0.5 * float64(a) * float64(h)
}

func TestTriangleArea(t *testing.T) {
    cases := []struct {
        a, h int
        expected float64
    }{
        {5, 3, 7.5},
        {6, 4, 12.0},
        {10, 2, 10.0},
        {8, 5, 20.0},
    }
    
    for _, c := range cases {
        result := triangle_area(c.a, c.h)
        if result != c.expected {
            t.Errorf(""triangle_area(%d, %d) == %f, expected %f"", c.a, c.h, result, c.expected)
        } else {
            fmt.Printf(""triangle_area(%d, %d) == %f\n"", c.a, c.h, result)
        }
    }
}","func TestTriangle_Area(t *testing.T) {
  candidate := triangle_area
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5, 3), expected: 7.5 },
     { actual: candidate(2, 2), expected: 2.0 },
     { actual: candidate(10, 8), expected: 40.0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_46,ewe_Latn,go_test.go,"package fib4_test

import (
    ""testing""
    ""fmt""
)

//Taflatse ŋlɔ dɔwɔƒe aɖe si ana nàbu fib4 xexlẽdzesiwo ƒe ɖoɖo ƒe akpa si nye n-tɔ ŋu nyuie. Mègazã gbugbɔgaɖɔɖo o. //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).//fib4(3) -> 0 //fib4(2) -> 2 //fib4(1) -> 0 //fib4(0) -> 0 //Fib4 xexlẽdzesiwo ƒe ɖoɖo nye ɖoɖo si sɔ kple Fibbonacci ƒe ɖoɖo si gɔme woɖe ale: // >>> fib4(5)
// 4
// >>> fib4(6)
// 8
// >>> fib4(7)
// 14
func fib4(n int) int {
","func fib4(n int) int {
    if n < 0 {
        return 0
    }
    
    seq := []int{0, 0, 2, 0}
    
    if n < 4 {
        return seq[n]
    }
    
    for i := 4; i <= n; i++ {
        next := seq[0] + seq[1] + seq[2] + seq[3]
        seq[0] = seq[1]
        seq[1] = seq[2]
        seq[2] = seq[3]
        seq[3] = next
    }
    
    return seq[3]
}","func TestFib4(t *testing.T) {
  candidate := fib4
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 4 },
     { actual: candidate(8), expected: 28 },
     { actual: candidate(10), expected: 104 },
     { actual: candidate(12), expected: 386 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_47,ewe_Latn,go_test.go,"package median_test

import (
    ""testing""
    ""fmt""
)

//Nu siwo le lɛta la me ƒe domedome ƒe akpa si woagbugbɔ aɖo ɖa l. // >>> median([]int{3, 1, 2, 4, 5})
// 3
// >>> median([]int{-10, 4, 6, 1000, 10, 20})
// 15.0
func median(l []int) float64 {
","package median_test

import (
    ""sort""
)

func median(l []int) float64 {
    sort.Ints(l)
    n := len(l)
    if n%2 == 1 {
        return float64(l[n/2])
    }
    mid1, mid2 := l[(n/2)-1], l[n/2]
    return float64(mid1+mid2) / 2.0
}","func TestMedian(t *testing.T) {
  candidate := median
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },
     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },
     { actual: candidate([]int{5}), expected: 5 },
     { actual: candidate([]int{6, 5}), expected: 5.5 },
     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_48,ewe_Latn,go_test.go,"package is_palindrome_test

import (
    ""testing""
    ""fmt""
)

//Dzroa be nyagbe si wona enye palindrome // >>> is_palindrome("""")
// true
// >>> is_palindrome(""aba"")
// true
// >>> is_palindrome(""aaaaa"")
// true
// >>> is_palindrome(""zbcd"")
// false
func is_palindrome(text string) bool {
","package is_palindrome_test

import (
    ""testing""
)

// Checks if given string is a palindrome
func is_palindrome(text string) bool {
    n := len(text)
    for i := 0; i < n/2; i++ {
        if text[i] != text[n-i-1] {
            return false
        }
    }
    return true
}

func TestIsPalindrome(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {"""", true},
        {""aba"", true},
        {""aaaaa"", true},
        {""zbcd"", false},
    }

    for _, test := range tests {
        result := is_palindrome(test.input)
        if result != test.expected {
            t.Errorf(""For input '%s', expected %v, but got %v"", test.input, test.expected, result)
        }
    }
}","func TestIs_Palindrome(t *testing.T) {
  candidate := is_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: true },
     { actual: candidate(""aba""), expected: true },
     { actual: candidate(""aaaaa""), expected: true },
     { actual: candidate(""zbcd""), expected: false },
     { actual: candidate(""xywyx""), expected: true },
     { actual: candidate(""xywyz""), expected: false },
     { actual: candidate(""xywzx""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_49,ewe_Latn,go_test.go,"package modp_test

import (
    ""testing""
    ""fmt""
)

//Gbugbɔ 2^n modulo p (nya xexlẽdzesiwo).// >>> modp(3, 5)
// 3
// >>> modp(1101, 101)
// 2
// >>> modp(0, 101)
// 1
// >>> modp(3, 11)
// 8
// >>> modp(100, 101)
// 1
func modp(n int, p int) int {
","package modp_test

import (
    ""testing""
    ""fmt""
)

// Return 2^n modulo p (be aware of numerics).
func modp(n int, p int) int {
    if n == 0 {
        return 1
    }
    result := 1
    base := 2
    for n > 0 {
        if n%2 == 1 {
            result = (result * base) % p
        }
        base = (base * base) % p
        n /= 2
    }
    return result
}

func TestModp(t *testing.T) {
    tests := []struct {
        n, p int
        expected int
    }{
        {3, 5, 3},
        {1101, 101, 2},
        {0, 101, 1},
        {3, 11, 8},
        {100, 101, 1},
    }

    for _, test := range tests {
        result := modp(test.n, test.p)
        if result != test.expected {
            t.Errorf(""modp(%d, %d) = %d; expected %d"", test.n, test.p, result, test.expected)
        } else {
            fmt.Printf(""modp(%d, %d) = %d; passed\n"", test.n, test.p, result)
        }
    }
}","func TestModp(t *testing.T) {
  candidate := modp
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 5), expected: 3 },
     { actual: candidate(1101, 101), expected: 2 },
     { actual: candidate(0, 101), expected: 1 },
     { actual: candidate(3, 11), expected: 8 },
     { actual: candidate(100, 101), expected: 1 },
     { actual: candidate(30, 5), expected: 4 },
     { actual: candidate(31, 5), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_51,ewe_Latn,go_test.go,"package remove_vowels_test

import (
    ""testing""
    ""fmt""
)

//remove_vowels nye dɔwɔna si xɔa nyagbewo eye wòɖoa nyagbewo siwo me nyagbewo mele o. // >>> remove_vowels("""")
// """"
// >>> remove_vowels(""abcdef"")
// ""bcdf""
// >>> remove_vowels(""aaaaa"")
// """"
// >>> remove_vowels(""aaBAA"")
// ""B""
// >>> remove_vowels(""zbcd"")
// ""zbcd""
func remove_vowels(text string) string {
","package remove_vowels_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func remove_vowels(text string) string {
    vowels := ""aeiouAEIOU""
    var result strings.Builder
    for _, char := range text {
        if !strings.ContainsRune(vowels, char) {
            result.WriteRune(char)
        }
    }
    return result.String()
}

func TestRemoveVowels(t *testing.T) {
    var tests = []struct {
        input    string
        expected string
    }{
        {"""", """"},
        {""abcdef"", ""bcdf""},
        {""aaaaa"", """"},
        {""aaBAA"", ""B""},
        {""zbcd"", ""zbcd""},
    }

    for _, test := range tests {
        if output := remove_vowels(test.input); output != test.expected {
            t.Errorf(""remove_vowels(%q) = %q; expected %q"", test.input, output, test.expected)
        }
    }
}

func main() {
    test := &testing.T{}
    TestRemoveVowels(test)
    if test.Failed() {
        fmt.Println(""Tests failed!"")
    } else {
        fmt.Println(""All tests passed!"")
    }
}","func TestRemove_Vowels(t *testing.T) {
  candidate := remove_vowels
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""abcdef\nghijklm""), expected: ""bcdf\nghjklm"" },
     { actual: candidate(""fedcba""), expected: ""fdcb"" },
     { actual: candidate(""eeeee""), expected: """" },
     { actual: candidate(""acBAA""), expected: ""cB"" },
     { actual: candidate(""EcBOO""), expected: ""cB"" },
     { actual: candidate(""ybcd""), expected: ""ybcd"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_52,ewe_Latn,go_test.go,"package below_threshold_test

import (
    ""testing""
    ""fmt""
)

//Ne xexlẽdzesi siwo katã le ŋkɔdzesi l me le teƒeteƒe t la, ke trɔna na true. // >>> below_threshold([]int{1, 2, 4, 10}, 100)
// true
// >>> below_threshold([]int{1, 20, 4, 10}, 5)
// false
func below_threshold(l []int, t int) bool {
","package below_threshold_test

import (
    ""testing""
    ""fmt""
)

// Return true if all numbers in the list l are below threshold t.
func below_threshold(l []int, t int) bool {
    for _, num := range l {
        if num >= t {
            return false
        }
    }
    return true
}

// Example test cases
func TestBelowThreshold(t *testing.T) {
    if !below_threshold([]int{1, 2, 4, 10}, 100) {
        t.Error(""Expected true, got false"")
    }
    if below_threshold([]int{1, 20, 4, 10}, 5) {
        t.Error(""Expected false, got true"")
    }
}

func main() {
    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) // true
    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  // false
}","func TestBelow_Threshold(t *testing.T) {
  candidate := below_threshold
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },
     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },
     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },
     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_53,ewe_Latn,go_test.go,"package add_test

import (
    ""testing""
    ""fmt""
)

//Tsɔ xexlẽdzesi eve x kple y kpe // >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
func add(x int, y int) int {
","package add_test

import (
    ""testing""
    ""fmt""
)

// Add two numbers x and y
// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
func add(x int, y int) int {
    return x + y
}

func TestAdd(t *testing.T) {
    testCases := []struct {
        x, y, expected int
    }{
        {2, 3, 5},
        {5, 7, 12},
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf(""add(%d,%d)"", tc.x, tc.y), func(t *testing.T) {
            result := add(tc.x, tc.y)
            if result != tc.expected {
                t.Errorf(""Expected %d, got %d"", tc.expected, result)
            }
        })
    }
}","func TestAdd(t *testing.T) {
  candidate := add
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0, 1), expected: 1 },
     { actual: candidate(1, 0), expected: 1 },
     { actual: candidate(2, 3), expected: 5 },
     { actual: candidate(5, 7), expected: 12 },
     { actual: candidate(7, 5), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_54,ewe_Latn,go_test.go,"package same_chars_test

import (
    ""testing""
    ""fmt""
)

//Kpɔe ɖa be ŋɔŋlɔdzesi ɖeka tɔgbi le nya eve aɖewo me hã. // >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
// true
// >>> same_chars(""abcd"", ""dddddddabc"")
// true
// >>> same_chars(""dddddddabc"", ""abcd"")
// true
// >>> same_chars(""eabcd"", ""dddddddabc"")
// false
// >>> same_chars(""abcd"", ""dddddddabce"")
// false
// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
// false
func same_chars(s0 string, s1 string) bool {
","package same_chars_test

import (
	""testing""
	""fmt""
)

func same_chars(s0 string, s1 string) bool {
	countChars := func(s string) map[rune]int {
		count := make(map[rune]int)
		for _, char := range s {
			count[char]++
		}
		return count
	}

	count0 := countChars(s0)
	count1 := countChars(s1)

	for char := range count0 {
		if count1[char] < count0[char] {
			return false
		}
	}

	for char := range count1 {
		if count0[char] < count1[char] {
			return false
		}
	}

	return true
}

func TestSameChars(t *testing.T) {
	tests := []struct {
		s0     string
		s1     string
		result bool
	}{
		{""eabcdzzzz"", ""dddzzzzzzzddeddabc"", true},
		{""abcd"", ""dddddddabc"", true},
		{""dddddddabc"", ""abcd"", true},
		{""eabcd"", ""dddddddabc"", false},
		{""abcd"", ""dddddddabce"", false},
		{""eabcdzzzz"", ""dddzzzzzzzddddabc"", false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%s vs %s"", test.s0, test.s1), func(t *testing.T) {
			if got := same_chars(test.s0, test.s1); got != test.result {
				t.Errorf(""same_chars(%q, %q) = %v; want %v"", test.s0, test.s1, got, test.result)
			}
		})
	}
}","func TestSame_Chars(t *testing.T) {
  candidate := same_chars
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""eabcdzzzz"", ""dddzzzzzzzddeddabc""), expected: true },
     { actual: candidate(""abcd"", ""dddddddabc""), expected: true },
     { actual: candidate(""dddddddabc"", ""abcd""), expected: true },
     { actual: candidate(""eabcd"", ""dddddddabc""), expected: false },
     { actual: candidate(""abcd"", ""dddddddabcf""), expected: false },
     { actual: candidate(""eabcdzzzz"", ""dddzzzzzzzddddabc""), expected: false },
     { actual: candidate(""aabb"", ""aaccc""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_55,ewe_Latn,go_test.go,"package fib_test

import (
    ""testing""
    ""fmt""
)

//Gblɔ Fibonacci xexlẽdzesi si nye n-tɔ. // >>> fib(10)
// 55
// >>> fib(1)
// 1
// >>> fib(8)
// 21
func fib(n int) int {
","if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}","func TestFib(t *testing.T) {
  candidate := fib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(10), expected: 55 },
     { actual: candidate(1), expected: 1 },
     { actual: candidate(8), expected: 21 },
     { actual: candidate(11), expected: 89 },
     { actual: candidate(12), expected: 144 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_56,ewe_Latn,go_test.go,"package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

//return true ne nuŋɔŋlɔ siwo le akpa si dzi woadze la dometɔ ɖe sia ɖe kple nuŋɔŋlɔ siwo le akpa si dzi woadze la. //brackets nye ""<"" kple "">"" ƒe kɔpi. // >>> correct_bracketing(""<"")
// false
// >>> correct_bracketing(""<>"")
// true
// >>> correct_bracketing(""<<><>>"")
// true
// >>> correct_bracketing(""><<>"")
// false
func correct_bracketing(brackets string) bool {
","package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

func correct_bracketing(brackets string) bool {
    balance := 0
    for _, char := range brackets {
        if char == '<' {
            balance++
        } else if char == '>' {
            balance--
            if balance < 0 {
                return false
            }
        }
    }
    return balance == 0
}

func TestCorrectBracketing(t *testing.T) {
    testCases := []struct {
        input    string
        expected bool
    }{
        {input: ""<"", expected: false},
        {input: ""<>"", expected: true},
        {input: ""<<><>>"", expected: true},
        {input: ""><<>"", expected: false},
        {input: ""<<>>"", expected: true},
        {input: ""><"", expected: false},
    }

    for _, tc := range testCases {
        result := correct_bracketing(tc.input)
        if result != tc.expected {
            t.Errorf(""correct_bracketing(%q) = %v; expected %v"", tc.input, result, tc.expected)
        } else {
            fmt.Printf(""Test passed for input: %q\n"", tc.input)
        }
    }
}","func TestCorrect_Bracketing(t *testing.T) {
  candidate := correct_bracketing
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""<>""), expected: true },
     { actual: candidate(""<<><>>""), expected: true },
     { actual: candidate(""<><><<><>><>""), expected: true },
     { actual: candidate(""<><><<<><><>><>><<><><<>>>""), expected: true },
     { actual: candidate(""<<<><>>>>""), expected: false },
     { actual: candidate(""><<>""), expected: false },
     { actual: candidate(""<""), expected: false },
     { actual: candidate(""<<<<""), expected: false },
     { actual: candidate("">""), expected: false },
     { actual: candidate(""<<>""), expected: false },
     { actual: candidate(""<><><<><>><>><<>""), expected: false },
     { actual: candidate(""<><><<><>><>>><>""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_57,ewe_Latn,go_test.go,"package monotonic_test

import (
    ""testing""
    ""fmt""
)

//Return true is list elements are monotonically increasing or decreasing.  Ðɔ true be ŋkɔawo le dzidzim ɖe edzi alo le to yim.// >>> monotonic([]int{1, 2, 4, 20})
// true
// >>> monotonic([]int{1, 20, 4, 10})
// false
// >>> monotonic([]int{4, 1, 0, -10})
// true
func monotonic(l []int) bool {
","package monotonic_test

import (
    ""testing""
    ""fmt""
)

// Return true if list elements are monotonically increasing or decreasing.
func monotonic(l []int) bool {
    if len(l) < 2 {
        return true
    }
    increasing := true
    decreasing := true

    for i := 1; i < len(l); i++ {
        if l[i] > l[i-1] {
            decreasing = false
        }
        if l[i] < l[i-1] {
            increasing = false
        }
    }

    return increasing || decreasing
}

func TestMonotonic(t *testing.T) {
    fmt.Println(monotonic([]int{1, 2, 4, 20})) // true
    fmt.Println(monotonic([]int{1, 20, 4, 10})) // false
    fmt.Println(monotonic([]int{4, 1, 0, -10})) // true
}","func TestMonotonic(t *testing.T) {
  candidate := monotonic
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 10}), expected: true },
     { actual: candidate([]int{1, 2, 4, 20}), expected: true },
     { actual: candidate([]int{1, 20, 4, 10}), expected: false },
     { actual: candidate([]int{4, 1, 0, -10}), expected: true },
     { actual: candidate([]int{4, 1, 1, 0}), expected: true },
     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },
     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },
     { actual: candidate([]int{9, 9, 9, 9}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_58,ewe_Latn,go_test.go,"package common_test

import (
    ""testing""
    ""fmt""
)

//Etrɔna ɖe nu siwo le abe nu ɖeka aɖe ene siwo le ɖoɖo nu la ŋu le nuŋlɔɖi eve me. // >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})
// []int{1, 5, 653}
// >>> common([]int{5, 3, 2, 8}, []int{3, 2})
// []int{2, 3}
func common(l1 []int, l2 []int) []int {
","package common_test

import (
    ""testing""
    ""fmt""
    ""sort""
)

func common(l1 []int, l2 []int) []int {
    set1 := make(map[int]struct{})
    set2 := make(map[int]struct{})
    commonSet := make(map[int]struct{})
    
    // Fill set1 with elements of l1
    for _, num := range l1 {
        set1[num] = struct{}{}
    }
    
    // Fill set2 with elements of l2
    for _, num := range l2 {
        if _, found := set1[num]; found {
            commonSet[num] = struct{}{}
        }
        set2[num] = struct{}{}
    }
    
    result := make([]int, 0, len(commonSet))
    
    // Collect common elements
    for num := range commonSet {
        result = append(result, num)
    }
    
    // Sort the result
    sort.Ints(result)
    
    return result
}

func TestCommon(t *testing.T) {
    cases := []struct {
        l1, l2 []int
        expected []int
    }{
        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},
        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},
    }
    
    for _, c := range cases {
        result := common(c.l1, c.l2)
        if !equal(result, c.expected) {
            t.Errorf(""common(%v, %v) == %v, expected %v"", c.l1, c.l2, result, c.expected)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestCommon(t *testing.T) {
  candidate := common
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },
     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },
     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },
     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_59,ewe_Latn,go_test.go,"package largest_prime_factor_test

import (
    ""testing""
    ""fmt""
)

//Gbugbɔ n ƒe akpa vevi gãtɔ vɛ. Tsɔe be n > 1 eye menye akpa vevi o. // >>> largest_prime_factor(13195)
// 29
// >>> largest_prime_factor(2048)
// 2
func largest_prime_factor(n int) int {
","package largest_prime_factor_test

import (
	""testing""
	""fmt""
)

func largest_prime_factor(n int) int {
	largestFactor := 1
	div := 2

	for n > 1 {
		if n%div == 0 {
			largestFactor = div
			n /= div
		} else {
			div++
		}
	}

	return largestFactor
}

func TestLargestPrimeFactor(t *testing.T) {
	tests := []struct{
		n int
		expected int
	} {
		{13195, 29},
		{2048, 2},
		{123456, 643},
		{100, 5},
		{999, 37},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""n=%d"", test.n), func(t *testing.T) {
			if result := largest_prime_factor(test.n); result != test.expected {
				t.Errorf(""largest_prime_factor(%d) = %d; expected %d"", test.n, result, test.expected)
			}
		})
	}
}","func TestLargest_Prime_Factor(t *testing.T) {
  candidate := largest_prime_factor
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(15), expected: 5 },
     { actual: candidate(27), expected: 3 },
     { actual: candidate(63), expected: 7 },
     { actual: candidate(330), expected: 11 },
     { actual: candidate(13195), expected: 29 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_60,ewe_Latn,go_test.go,"package sum_to_n_test

import (
    ""testing""
    ""fmt""
)

//sum_to_n nye dɔ si wotsɔna ƒoa xexlẽdzesi siwo tso 1 va se ɖe n nu ƒu. // >>> sum_to_n(30)
// 465
// >>> sum_to_n(100)
// 5050
// >>> sum_to_n(5)
// 15
// >>> sum_to_n(10)
// 55
// >>> sum_to_n(1)
// 1
func sum_to_n(n int) int {
","func sum_to_n(n int) int {
    return n * (n + 1) / 2
}

func TestSumToN(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {30, 465},
        {100, 5050},
        {5, 15},
        {10, 55},
        {1, 1},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""sum_to_n(%d)"", test.input), func(t *testing.T) {
            result := sum_to_n(test.input)
            if result != test.expected {
                t.Errorf(""Expected %d, got %d"", test.expected, result)
            }
        })
    }
}","func TestSum_To_N(t *testing.T) {
  candidate := sum_to_n
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 1 },
     { actual: candidate(6), expected: 21 },
     { actual: candidate(11), expected: 66 },
     { actual: candidate(30), expected: 465 },
     { actual: candidate(100), expected: 5050 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_61,ewe_Latn,go_test.go,"package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

//return true ne nuŋɔŋlɔ siwo le akpa si dzi woadze la dometɔ ɖe sia ɖe kple nuŋɔŋlɔ siwo le akpa si dzi woadze la. //brackets nye ""("" kple """") ƒe string.// >>> correct_bracketing(""("")
// false
// >>> correct_bracketing(""()"")
// true
// >>> correct_bracketing(""(()())"")
// true
// >>> correct_bracketing("")(()"")
// false
func correct_bracketing(brackets string) bool {
","package correct_bracketing_test

import (
    ""testing""
    ""fmt""
)

func correct_bracketing(brackets string) bool {
    balance := 0
    for _, char := range brackets {
        if char == '(' {
            balance++
        } else if char == ')' {
            balance--
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}

func TestCorrectBracketing(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {""("", false},
        {""()"", true},
        {""(()())"", true},
        {"")(()"", false},
        {"""", true},
        {""((()))"", true},
        {""(()"", false},
        {""())"", false},
    }

    for _, tt := range tests {
        result := correct_bracketing(tt.input)
        if result != tt.expected {
            t.Errorf(""correct_bracketing(%q) = %v; want %v"", tt.input, result, tt.expected)
        } else {
            fmt.Printf(""correct_bracketing(%q) = %v\n"", tt.input, result)
        }
    }
}","func TestCorrect_Bracketing(t *testing.T) {
  candidate := correct_bracketing
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""()""), expected: true },
     { actual: candidate(""(()())""), expected: true },
     { actual: candidate(""()()(()())()""), expected: true },
     { actual: candidate(""()()((()()())())(()()(()))""), expected: true },
     { actual: candidate(""((()())))""), expected: false },
     { actual: candidate("")(()""), expected: false },
     { actual: candidate(""(""), expected: false },
     { actual: candidate(""((((""), expected: false },
     { actual: candidate("")""), expected: false },
     { actual: candidate(""(()""), expected: false },
     { actual: candidate(""()()(()())())(()""), expected: false },
     { actual: candidate(""()()(()())()))()""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_62,ewe_Latn,go_test.go,"package derivative_test

import (
    ""testing""
    ""fmt""
)

//Gbugbɔ ŋkɔ sia ƒe derivative ɖo le mɔ ma ke nu.//xs[0] + xs[1] * x + xs[2] * x^2 + .... //xs nye polynomial ƒe koefiɖizɛ. // >>> derivative([]int{3, 1, 2, 4, 5})
// []int{1, 4, 12, 20}
// >>> derivative([]int{1, 2, 3})
// []int{2, 6}
func derivative(xs []int) []int {
","package derivative_test

import (
    ""testing""
    ""fmt""
)

// xs represent coefficients of a polynomial.
// xs[0] + xs[1] * x + xs[2] * x^2 + ....
// Return derivative of this polynomial in the same form.
func derivative(xs []int) []int {
    if len(xs) <= 1 {
        return []int{}
    }
    
    derived := make([]int, len(xs)-1)
    for i := 1; i < len(xs); i++ {
        derived[i-1] = xs[i] * i
    }
    return derived
}

func TestDerivative(t *testing.T) {
    testCases := []struct{
        input []int
        expected []int
    }{
        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},
        {[]int{1, 2, 3}, []int{2, 6}},
        {[]int{1}, []int{}},
        {[]int{}, []int{}},
    }

    for _, testCase := range testCases {
        result := derivative(testCase.input)
        if !equal(result, testCase.expected) {
            t.Errorf(""For input %v, expected %v, but got %v"", 
                     testCase.input, testCase.expected, result)
        }
    }
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestDerivative(t *testing.T) {
  candidate := derivative
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },
     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },
     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },
     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },
     { actual: candidate([]int{1}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_63,ewe_Latn,go_test.go,"package fibfib_test

import (
    ""testing""
    ""fmt""
)

//Taflatse ŋlɔ dɔ si ana nàbu fibfib xexlẽdzesiwo ƒe ɖoɖo si nye n-tɔ la ŋu nyuie. //fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). //fib fib ((2) == 1 //fibfib ((1) == 0 //fibfib ((0) == 0 //FibFib xexlẽdzesiwo ƒe ɖoɖo nye ɖoɖo si sɔ kple Fibbonacci ƒe ɖoɖo si gɔme woɖe ale: // >>> fibfib(1)
// 0
// >>> fibfib(5)
// 4
// >>> fibfib(8)
// 24
func fibfib(n int) int {
","func fibfib(n int) int {
    if n == 0 || n == 1 {
        return 0
    } else if n == 2 {
        return 1
    }

    a, b, c := 0, 0, 1
    for i := 3; i <= n; i++ {
        next := a + b + c
        a = b
        b = c
        c = next
    }
    return c
}","func TestFibfib(t *testing.T) {
  candidate := fibfib
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2), expected: 1 },
     { actual: candidate(1), expected: 0 },
     { actual: candidate(5), expected: 4 },
     { actual: candidate(8), expected: 24 },
     { actual: candidate(10), expected: 81 },
     { actual: candidate(12), expected: 274 },
     { actual: candidate(14), expected: 927 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_64,ewe_Latn,go_test.go,"package vowels_count_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //enyea gbeɖiɖi, gake ne ele nya aɖe ƒe nuwuwu ko hafi.//Gbeɖiɖi siwo le nya sia me nye 'a', 'e', 'i', 'o', 'u.' Le afisia la, 'y' hã nye a //enye nya si wotsɔ de eme eye wònana wonyaa vokal siwo le nyagbea me ƒe xexlẽme. //Ŋlɔ dɔdeasi si nye vowels_count si xɔa string si le tsitre ɖi na // >>> vowels_count(""abcde"")
// 2
// >>> vowels_count(""ACEDY"")
// 3
func vowels_count(s string) int {
","package vowels_count_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func vowels_count(s string) int {
    count := 0
    s = strings.ToLower(s)
    vowels := ""aeiou""
    for i, char := range s {
        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {
            count++
        }
    }
    return count
}

func TestVowelsCount(t *testing.T) {
    tests := []struct {
        input  string
        output int
    }{
        {""abcde"", 2},
        {""ACEDY"", 3},
        {""xyz"", 1},
        {""plenty"", 1},
        {""queue"", 3},
    }

    for _, test := range tests {
        result := vowels_count(test.input)
        if result != test.output {
            t.Errorf(""Expected %d, but got %d for input %s"", test.output, result, test.input)
        } else {
            fmt.Printf(""Success: got %d for input %s\n"", result, test.input)
        }
    }
}","func TestVowels_Count(t *testing.T) {
  candidate := vowels_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""abcde""), expected: 2 },
     { actual: candidate(""Alone""), expected: 3 },
     { actual: candidate(""key""), expected: 2 },
     { actual: candidate(""bye""), expected: 1 },
     { actual: candidate(""keY""), expected: 2 },
     { actual: candidate(""bYe""), expected: 1 },
     { actual: candidate(""ACEDY""), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_65,ewe_Latn,go_test.go,"package circular_shift_test

import (
    ""testing""
    ""fmt""
)

//Ne shift > digits ƒe xexlẽme la, trɔ digitswo.//eye wòana eƒe tagbɔ nasɔ abe nyagbe ene. //Zɔ x ƒe xexlẽdzesi siwo le x ƒe axawo dzi la ƒe xexlẽdzesiwo le nutoa me, eye nàtrɔ wo ƒe xexlẽdzesiwo ɖe ɖusime to wo tɔtrɔ me.// >>> circular_shift(12, 1)
// ""21""
// >>> circular_shift(12, 2)
// ""12""
func circular_shift(x int, shift int) string {
","package circular_shift_test

import (
    ""strconv""
)

func circular_shift(x int, shift int) string {
    strX := strconv.Itoa(x)
    numDigits := len(strX)

    if shift > numDigits {
        // Reverse the digits if shift is greater than the number of digits
        reversed := make([]byte, numDigits)
        for i := 0; i < numDigits; i++ {
            reversed[i] = strX[numDigits-i-1]
        }
        return string(reversed)
    } else {
        // Perform a circular shift
        shift = shift % numDigits
        return strX[numDigits-shift:] + strX[:numDigits-shift]
    }
}","func TestCircular_Shift(t *testing.T) {
  candidate := circular_shift
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(100, 2), expected: ""001"" },
     { actual: candidate(12, 2), expected: ""12"" },
     { actual: candidate(97, 8), expected: ""79"" },
     { actual: candidate(12, 1), expected: ""21"" },
     { actual: candidate(11, 101), expected: ""11"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_66,ewe_Latn,go_test.go,"package digitSum_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //ASCII ƒe dzesiwo.//Ŋlɔ dɔdeasi aɖe si xɔa nyagbe aɖe abe nu si woadee ene eye wòɖoa nya siwo le etame la ƒe xexlẽdzesi ko ɖe eme.'//Dɔdasi // >>> digitSum("""")
// 0
// >>> digitSum(""abAB"")
// 131
// >>> digitSum(""abcCd"")
// 67
// >>> digitSum(""helloE"")
// 69
// >>> digitSum(""woArBld"")
// 131
// >>> digitSum(""aAaaaXa"")
// 153
func digitSum(s string) int {
","func digitSum(s string) int {
    sum := 0
    for _, char := range s {
        if char >= 'A' && char <= 'Z' {
            sum += int(char)
        }
    }
    return sum
}","func TestDigitsum(t *testing.T) {
  candidate := digitSum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""abAB""), expected: 131 },
     { actual: candidate(""abcCd""), expected: 67 },
     { actual: candidate(""helloE""), expected: 69 },
     { actual: candidate(""woArBld""), expected: 131 },
     { actual: candidate(""aAaaaXa""), expected: 153 },
     { actual: candidate("" How are yOu?""), expected: 151 },
     { actual: candidate(""You arE Very Smart""), expected: 327 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_67,ewe_Latn,go_test.go,"package fruit_distribution_test

import (
    ""testing""
    ""fmt""
)

//le examble me: //le kusi me naxe mɔ̃ siwo le kusi me ƒe xexlẽme. //aŋuti kple atsu kpakple xexlẽdzesi blibo si fia atikutsetseawo katã ƒe xexlẽdzesi //Ne míetsɔ nu siwo le xlẽm la ƒe xexlẽme si nye //Woɖoa wo ɖe atikutsetsewo ƒe kusi aɖe me.//Le dɔdeasi sia me la, woana wò nyagbe si le tsitre ɖi na atsu kple aŋuti ƒe xexlẽme // >>> fruit_distribution(""5 apples and 6 oranges"", 19)
// 8
// >>> fruit_distribution(""0 apples and 1 oranges"", 3)
// 2
// >>> fruit_distribution(""2 apples and 3 oranges"", 100)
// 95
// >>> fruit_distribution(""100 apples and 1 oranges"", 120)
// 19
func fruit_distribution(s string, n int) int {
","package fruit_distribution_test

import (
    ""fmt""
    ""regexp""
    ""strconv""
    ""testing""
)

func fruit_distribution(s string, n int) int {
    re := regexp.MustCompile(`(\d+) apples and (\d+) oranges`)
    matches := re.FindStringSubmatch(s)
    
    if len(matches) != 3 {
        return -1 // Could return an error or a sentinel value if input format is incorrect
    }

    apples, _ := strconv.Atoi(matches[1])
    oranges, _ := strconv.Atoi(matches[2])

    mangoes := n - (apples + oranges)
    return mangoes
}

func TestFruitDistribution(t *testing.T) {
    var tests = []struct {
        description string
        inputString string
        totalFruits int
        expected    int
    }{
        {""Test case 1"", ""5 apples and 6 oranges"", 19, 8},
        {""Test case 2"", ""0 apples and 1 oranges"", 3, 2},
        {""Test case 3"", ""2 apples and 3 oranges"", 100, 95},
        {""Test case 4"", ""100 apples and 1 oranges"", 120, 19},
    }

    for _, tt := range tests {
        t.Run(tt.description, func(t *testing.T) {
            result := fruit_distribution(tt.inputString, tt.totalFruits)
            if result != tt.expected {
                t.Errorf(""got %d, want %d"", result, tt.expected)
            }
        })
    }
}

func main() {
    fmt.Println(fruit_distribution(""5 apples and 6 oranges"", 19)) // 8
    fmt.Println(fruit_distribution(""0 apples and 1 oranges"", 3))  // 2
    fmt.Println(fruit_distribution(""2 apples and 3 oranges"", 100)) // 95
    fmt.Println(fruit_distribution(""100 apples and 1 oranges"", 120)) // 19
}","func TestFruit_Distribution(t *testing.T) {
  candidate := fruit_distribution
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""5 apples and 6 oranges"", 19), expected: 8 },
     { actual: candidate(""5 apples and 6 oranges"", 21), expected: 10 },
     { actual: candidate(""0 apples and 1 oranges"", 3), expected: 2 },
     { actual: candidate(""1 apples and 0 oranges"", 3), expected: 2 },
     { actual: candidate(""2 apples and 3 oranges"", 100), expected: 95 },
     { actual: candidate(""2 apples and 3 oranges"", 5), expected: 0 },
     { actual: candidate(""1 apples and 100 oranges"", 120), expected: 19 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_68,ewe_Latn,go_test.go,"package pluck_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu 1: //Ne xexlẽdzesi eve aɖeke meli o alo xexlẽdzesi si wotsɔ ɖo la le ƒuƒlu la, trɔ [].//Ele be woaɖo nu si wohe la ɖe list me, [ smalest_value, eƒe index ], //Ne wokpɔ node geɖe siwo ƒe xexlẽdzesi le sue wu la, ke trɔna ɖo node si ƒe xexlẽdzesi le sue wu la. //Ele be nu si ƒe xexlẽdzesi le eve la nanye nu si ƒe xexlẽdzesi le eve la ƒe xexlẽdzesi suetɔ.//Wò dɔe nye be nàɖe eƒe akpa ɖeka le eme eye nàgatrɔe ayii.//""Ne míetsɔ ŋkɔ siwo le ati aɖe ƒe alɔwo me siwo me xexlẽdzesi siwo menye vɔ o le la, // >>> pluck([]int{4, 2, 3})
// []int{2, 1}
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 2:
// >>> pluck([]int{1, 2, 3})
// []int{2, 1}
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 3:
// >>> pluck([]int{})
// []int{}
// Example 4:
// >>> pluck([]int{5, 0, 3, 0, 4, 2})
// []int{0, 1}
// Explanation: 0 is the smallest value, but  there are two zeros,
// so we will choose the first zero, which has the smallest index.
// Constraints:
// * 1 <= nodes.length <= 10000
// * 0 <= node.value
func pluck(arr []int) []int {
","package pluck_test

import (
	""testing""
)

// pluck function that implements the solution as described in the problem
func pluck(arr []int) []int {
	if len(arr) == 0 {
		return []int{}
	}

	smallestEvenValue := -1
	index := -1

	for i, val := range arr {
		if val%2 == 0 {
			if smallestEvenValue == -1 || val < smallestEvenValue {
				smallestEvenValue = val
				index = i
			}
		}
	}

	if index == -1 {
		return []int{}
	}

	return []int{smallestEvenValue, index}
}

// Example unit tests can be implemented by using the testing package
func TestPluck(t *testing.T) {
	tests := []struct {
		input    []int
		expected []int
	}{
		{[]int{4, 2, 3}, []int{2, 1}},
		{[]int{1, 2, 3}, []int{2, 1}},
		{[]int{}, []int{}},
		{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},
	}

	for _, test := range tests {
		result := pluck(test.input)
		if len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {
			t.Errorf(""pluck(%v) = %v; expected %v"", test.input, result, test.expected)
		}
	}
}","func TestPluck(t *testing.T) {
  candidate := pluck
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },
     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },
     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },
     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },
     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },
     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_69,ewe_Latn,go_test.go,"package search_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ne asixɔxɔ ma meli o la, gbugbɔ ɖo -1.//Zi ale si xexlẽdzesi blibo aɖe dze le nuŋlɔɖia me la ƒe agbɔsɔsɔe nye zi ale si wòadze le nuŋlɔɖia me. //enyea nufitifiti, eye eƒe xexlẽdzesi sɔna kple xexlẽdzesi blibo la tɔ.//Wona xexlẽdzesi siwo nye positive integers siwo menye ƒuƒlu o. Gbugbɔ xexlẽdzesi si lolo wu  la ɖo.// >>> search([]int{4, 1, 2, 2, 3, 1})
// 2
// >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})
// 3
// >>> search([]int{5, 5, 4, 4, 4})
// -1
func search(lst []int) int {
","package search_test

import ""sort""

func search(lst []int) int {
	frequency := make(map[int]int)

	for _, num := range lst {
		frequency[num]++
	}

	candidates := []int{}
	for num, count := range frequency {
		if count >= num {
			candidates = append(candidates, num)
		}
	}

	if len(candidates) == 0 {
		return -1
	}

	sort.Ints(candidates)
	return candidates[len(candidates)-1]
}","func TestSearch(t *testing.T) {
  candidate := search
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },
     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },
     { actual: candidate([]int{3, 3}), expected: -1 },
     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },
     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },
     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },
     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },
     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },
     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },
     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },
     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },
     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },
     { actual: candidate([]int{1}), expected: 1 },
     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },
     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },
     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },
     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },
     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },
     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },
     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },
     { actual: candidate([]int{10}), expected: -1 },
     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },
     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },
     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },
     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_70,ewe_Latn,go_test.go,"package strange_sort_list_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Emegbe xexlẽdzesi siwo susɔ la ƒe agbɔsɔsɔme, emegbe esiwo susɔ la ƒe agbɔsɔsɔme, eye nenemae ko wòayi edzi anɔ.//Ne èdze egɔme kple nu si ƒe home le sue wu la, ekema nu si le sue wu la koe nàkpɔ.//Ne èna xexlẽdzesi blibowo ƒe ŋkɔ mí la, míana ŋkɔawo nanɔ ɖoɖo tɔxɛ aɖe nu.// >>> strange_sort_list([]int{1, 2, 3, 4})
// []int{1, 4, 2, 3}
// >>> strange_sort_list([]int{5, 5, 5, 5})
// []int{5, 5, 5, 5}
// >>> strange_sort_list([]int{})
// []int{}
func strange_sort_list(lst []int) []int {
","package strange_sort_list_test

import (
	""testing""
	""fmt""
	""sort""
)

func strange_sort_list(lst []int) []int {
	if len(lst) == 0 {
		return lst
	}
	
	sort.Ints(lst)
	res := make([]int, len(lst))
	left, right := 0, len(lst)-1
	i := 0

	for left <= right {
		if i%2 == 0 {
			res[i] = lst[left]
			left++
		} else {
			res[i] = lst[right]
			right--
		}
		i++
	}

	return res
}

func TestStrangeSortList(t *testing.T) {
	tests := []struct {
		input  []int
		output []int
	}{
		{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},
		{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},
		{[]int{}, []int{}},
		{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},
	}
	for _, test := range tests {
		if res := strange_sort_list(test.input); !equal(res, test.output) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.output, res)
		}
	}
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func main() {
	fmt.Println(strange_sort_list([]int{1, 2, 3, 4})) // Should print [1 4 2 3]
}","func TestStrange_Sort_List(t *testing.T) {
  candidate := strange_sort_list
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },
     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },
     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },
     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },
     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },
     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },
     { actual: candidate([]int{111111}), expected: []int{111111} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_71,ewe_Latn,go_test.go,"package triangle_area_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Ke menye akpa etɔ̃lia o.//Ne akpa eveawo ƒe xexlẽme sɔ gbɔ wu la, akpa etɔ̃a katã nyea dzogoe ɖeka.//Ne menye nenema o la, ekema gbugbɔ ɖo -1 //ne eƒe axa etɔ̃awo nyea dzogoe eve la, ekema enyea dzogoe eve.//Ne míetsɔ dzogoe etɔ̃ siwo le dzogoe etɔ̃ me ƒe didimewo na la, ekema míatsɔ teƒe si nye  la ƒe lolome aɖo teƒe si nye // >>> triangle_area(3, 4, 5)
// 6.0
// >>> triangle_area(1, 2, 10)
// -1
func triangle_area(a int, b int, c int) float64 {
","package triangle_area_test

import (
    ""math""
)

func triangle_area(a int, b int, c int) float64 {
    // Check for the validity of the triangle
    if a+b <= c || a+c <= b || b+c <= a {
        return -1
    }
    // Calculate the semi-perimeter
    s := float64(a+b+c) / 2
    // Calculate the area using Heron's formula
    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))
    // Round the result to 2 decimal places
    return math.Round(area*100) / 100.0
}","func TestTriangle_Area(t *testing.T) {
  candidate := triangle_area
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 4, 5), expected: 6.0 },
     { actual: candidate(1, 2, 10), expected: -1 },
     { actual: candidate(4, 8, 5), expected: 8.18 },
     { actual: candidate(2, 2, 2), expected: 1.73 },
     { actual: candidate(1, 2, 3), expected: -1 },
     { actual: candidate(10, 5, 7), expected: 16.25 },
     { actual: candidate(2, 6, 3), expected: -1 },
     { actual: candidate(1, 1, 1), expected: 0.43 },
     { actual: candidate(2, 2, 10), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_72,ewe_Latn,go_test.go,"package will_it_fly_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Nuvi q adzo ne eƒe nuwo sɔ (enye palindromic list) eye eƒe nuwo ƒe xexlẽme le sue wu alo sɔ kple eƒe kpekpeme si le w.//Ŋlɔ dɔ si ana nyateƒe ne nu si q la le dzodzom, eye aʋatso ne menye nenema o. // >>> will_it_fly([]int{1, 2}, 5)
// false
// # 1+2 is less than the maximum possible weight, but it's unbalanced.
// >>> will_it_fly([]int{3, 2, 3}, 1)
// false
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
// >>> will_it_fly([]int{3, 2, 3}, 9)
// true
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
// >>> will_it_fly([]int{3}, 5)
// true
// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q []int, w int) bool {
","func will_it_fly(q []int, w int) bool {
    sum := 0
    n := len(q)

    // Calculate the sum of the elements in q
    for _, value := range q {
        sum += value
    }

    // Check if sum is greater than the maximum possible weight
    if sum > w {
        return false
    }

    // Check if the list is a palindrome
    for i := 0; i < n/2; i++ {
        if q[i] != q[n-i-1] {
            return false
        }
    }

    // If the list is balanced and sum is less than or equal to w
    return true
}","func TestWill_It_Fly(t *testing.T) {
  candidate := will_it_fly
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 2, 3}, 9), expected: true },
     { actual: candidate([]int{1, 2}, 5), expected: false },
     { actual: candidate([]int{3}, 5), expected: true },
     { actual: candidate([]int{3, 2, 3}, 1), expected: false },
     { actual: candidate([]int{1, 2, 3}, 6), expected: false },
     { actual: candidate([]int{5}, 5), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_73,ewe_Latn,go_test.go,"package smallest_change_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Ne ètrɔ asi le nane ŋu la, àte ŋu atrɔ asi le eŋu wòava zu nu bubu.//ele be woatrɔ asi le wo ŋu be woana ŋkɔawo nanɔ abe palindromic ene.//Ne èkpɔ xexlẽdzesi blibowo ƒe xexlẽdzesi siwo nye arr la, ke kpɔ xexlẽdzesi siwo le wo me la ƒe xexlẽdzesi si le sue wu si // >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})
// 4
// >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})
// 1
// >>> smallest_change([]int{1, 2, 3, 2, 1})
// 0
func smallest_change(arr []int) int {
","package smallest_change_test

import (
    ""testing""
    ""fmt""
)

func smallest_change(arr []int) int {
    n := len(arr)
    changes := 0
    for i := 0; i < n/2; i++ {
        if arr[i] != arr[n-i-1] {
            changes++
        }
    }
    return changes
}

func TestSmallestChange(t *testing.T) {
    tests := []struct{
        input []int
        expected int
    }{
        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},
        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},
        {[]int{1, 2, 3, 2, 1}, 0},
    }

    for _, test := range tests {
        result := smallest_change(test.input)
        if result != test.expected {
            t.Errorf(""For input %v, expected %d but got %d"", test.input, test.expected, result)
        } else {
            fmt.Printf(""Test passed for input %v\n"", test.input)
        }
    }
}","func TestSmallest_Change(t *testing.T) {
  candidate := smallest_change
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },
     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },
     { actual: candidate([]int{1, 4, 2}), expected: 1 },
     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },
     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },
     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },
     { actual: candidate([]int{1}), expected: 0 },
     { actual: candidate([]int{0, 1}), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_74,ewe_Latn,go_test.go,"package total_match_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //ne xexlẽdzesi ɖeka koe le nuŋlɔɖi eveawo me la, ekema naŋlɔ gbãtɔ.//nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo katã le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi siwo le nuŋɔŋlɔdzesi me.//Ŋlɔ dɔdeasi si axɔ nyagbewo ƒe ƒuƒoƒo eve eye wòana ŋkɔ si le wo dome la ƒe ƒuƒoƒo ɖeka.// >>> total_match([]string{}, []string{})
// []string{}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hI"", ""Hi""})
// []string{""hI"", ""Hi""}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""})
// []string{""hi"", ""admin""}
// >>> total_match([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""})
// []string{""hI"", ""hi"", ""hi""}
// >>> total_match([]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""})
// []string{""4""}
func total_match(lst1 []string, lst2 []string) []string {
","package total_match_test

import (
    ""testing""
    ""fmt""
)

// total_match function returns the list with the smaller total character count.
// If both lists have the same character count, it returns the first list.
func total_match(lst1 []string, lst2 []string) []string {
    sumChars := func(lst []string) int {
        total := 0
        for _, str := range lst {
            total += len(str)
        }
        return total
    }
    
    sum1 := sumChars(lst1)
    sum2 := sumChars(lst2)

    if sum1 <= sum2 {
        return lst1
    } else {
        return lst2
    }
}

// Test functions can go below to verify the behavior of total_match.
func TestTotalMatch(t *testing.T) {
    cases := []struct {
        lst1      []string
        lst2      []string
        expected  []string
    }{
        {[]string{}, []string{}, []string{}},
        {[]string{""hi"", ""admin""}, []string{""hI"", ""Hi""}, []string{""hI"", ""Hi""}},
        {[]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""}, []string{""hi"", ""admin""}},
        {[]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""}, []string{""hI"", ""hi"", ""hi""}},
        {[]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""}, []string{""4""}},
    }

    for _, c := range cases {
        result := total_match(c.lst1, c.lst2)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", c.expected) {
            t.Errorf(""total_match(%v, %v) == %v, expected %v"", c.lst1, c.lst2, result, c.expected)
        }
    }
}","func TestTotal_Match(t *testing.T) {
  candidate := total_match
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{}, []string{}), expected: []string{} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hi"", ""hi""}), expected: []string{""hi"", ""hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hi"", ""hi"", ""admin"", ""project""}), expected: []string{""hi"", ""admin""} },
     { actual: candidate([]string{""4""}, []string{""1"", ""2"", ""3"", ""4"", ""5""}), expected: []string{""4""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""Hi""}), expected: []string{""hI"", ""Hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hi""}), expected: []string{""hI"", ""hi"", ""hi""} },
     { actual: candidate([]string{""hi"", ""admin""}, []string{""hI"", ""hi"", ""hii""}), expected: []string{""hi"", ""admin""} },
     { actual: candidate([]string{}, []string{""this""}), expected: []string{} },
     { actual: candidate([]string{""this""}, []string{}), expected: []string{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_75,ewe_Latn,go_test.go,"package is_multiply_prime_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Ne míenya be a mede 100 o la, ekema míade dzesi a kple a ƒe xexlẽdzesi.//eye menye nyateƒe o. //Ŋlɔ dɔdeasi aɖe si ana ame ƒe xexlẽdzesi nanye nyateƒe ne enye xexlẽdzesi gbãtɔ etɔ̃ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ ƒe xexlẽdzesi gbãtɔ.// >>> is_multiply_prime(30)
// true
// 30 = 2 * 3 * 5
func is_multiply_prime(a int) bool {
","func is_multiply_prime(a int) bool {
	if a < 2 {
		return false
	}

	primeNumbers := generatePrimesUpTo(100)
	
	for i := 0; i < len(primeNumbers); i++ {
		for j := i; j < len(primeNumbers); j++ {
			for k := j; k < len(primeNumbers); k++ {
				if primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {
					return true
				}
			}
		}
	}
	return false
}

func generatePrimesUpTo(max int) []int {
	isPrime := make([]bool, max+1)
	for i := 2; i <= max; i++ {
		isPrime[i] = true
	}
	for i := 2; i*i <= max; i++ {
		if isPrime[i] {
			for j := i * i; j <= max; j += i {
				isPrime[j] = false
			}
		}
	}
	var primes []int
	for i := 2; i <= max; i++ {
		if isPrime[i] {
			primes = append(primes, i)
		}
	}
	return primes
}","func TestIs_Multiply_Prime(t *testing.T) {
  candidate := is_multiply_prime
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: false },
     { actual: candidate(30), expected: true },
     { actual: candidate(8), expected: true },
     { actual: candidate(10), expected: false },
     { actual: candidate(125), expected: true },
     { actual: candidate(105), expected: true },
     { actual: candidate(126), expected: false },
     { actual: candidate(729), expected: false },
     { actual: candidate(891), expected: false },
     { actual: candidate(1001), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_76,ewe_Latn,go_test.go,"package is_simple_power_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //x nye n ƒe ŋusẽ si le bɔbɔe ne n**int=x //le n ƒe ŋusẽ me eye woagblẽ le go bubuwo me. //Wò dɔdeasi enye be nàŋlɔ dɔdeasi si ana nàkpɔe be enye nyateƒe ne xexlẽdzesi x nye ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ ƒ// >>> is_simple_power(1, 4)
// true
// >>> is_simple_power(2, 2)
// true
// >>> is_simple_power(8, 2)
// true
// >>> is_simple_power(3, 2)
// false
// >>> is_simple_power(3, 1)
// false
// >>> is_simple_power(5, 3)
// false
func is_simple_power(x int, n int) bool {
","package is_simple_power_test

import (
    ""testing""
    ""fmt""
)

func is_simple_power(x int, n int) bool {
    if n <= 1 {
        return x == 1
    }
    
    current := n
    for current <= x {
        if current == x {
            return true
        }
        current *= n
    }
    return false
}

func TestIsSimplePower(t *testing.T) {
    tests := []struct {
        x, n     int
        expected bool
    }{
        {1, 4, true},
        {2, 2, true},
        {8, 2, true},
        {3, 2, false},
        {3, 1, false},
        {5, 3, false},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%d,%d"", test.x, test.n), func(t *testing.T) {
            result := is_simple_power(test.x, test.n)
            if result != test.expected {
                t.Errorf(""Expected %v, but got %v"", test.expected, result)
            }
        })
    }
}","func TestIs_Simple_Power(t *testing.T) {
  candidate := is_simple_power
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(16, 2), expected: true },
     { actual: candidate(143214, 16), expected: false },
     { actual: candidate(4, 2), expected: true },
     { actual: candidate(9, 3), expected: true },
     { actual: candidate(16, 4), expected: true },
     { actual: candidate(24, 2), expected: false },
     { actual: candidate(128, 4), expected: false },
     { actual: candidate(12, 6), expected: false },
     { actual: candidate(1, 1), expected: true },
     { actual: candidate(1, 12), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_77,ewe_Latn,go_test.go,"package iscube_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //De dzesii: àte ŋu abui be nya si nèŋlɔ la nye nyateƒe ɣesiaɣi. //ne ameƒomevi sia nye xexlẽdzesi blibo aɖe ƒe dzidze.//Ŋlɔ dɔdeasi si xɔa xexlẽdzesi blibo a eye wòɖoa true // >>> iscube(1)
// true
// >>> iscube(2)
// false
// >>> iscube(-1)
// true
// >>> iscube(64)
// true
// >>> iscube(0)
// true
// >>> iscube(180)
// false
func iscube(a int) bool {
","package iscube_test

import (
	""testing""
	""math""
)

func iscube(a int) bool {
	if a < 0 {
		a = -a
	}
	cubeRoot := math.Cbrt(float64(a))
	return cubeRoot == float64(int(cubeRoot))
}

func TestIsCube(t *testing.T) {
	tests := []struct {
		input    int
		expected bool
	}{
		{1, true},
		{2, false},
		{-1, true},
		{64, true},
		{0, true},
		{180, false},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""iscube(%d)"", test.input), func(t *testing.T) {
			result := iscube(test.input)
			if result != test.expected {
				t.Errorf(""expected %v, got %v"", test.expected, result)
			}
		})
	}
}","func TestIscube(t *testing.T) {
  candidate := iscube
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: true },
     { actual: candidate(2), expected: false },
     { actual: candidate(-1), expected: true },
     { actual: candidate(64), expected: true },
     { actual: candidate(180), expected: false },
     { actual: candidate(1000), expected: true },
     { actual: candidate(0), expected: true },
     { actual: candidate(1729), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_78,ewe_Latn,go_test.go,"package hex_key_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Eye dzesideŋkɔ siwo nye A, B, C, D, E, F nyea ŋɔŋlɔdzesi gãwo ɣesiaɣi.//De dzesii: àte ŋu abu be nya si nèŋlɔ la nye nyateƒe ɣesiaɣi alo enye nya si ŋu wometsɔ ŋkɔ ɖo o, //B (= decimal 11), D (= decimal 13). //Eyata ele be nàkpɔ xexlẽdzesi siwo gbɔna la dometɔ ɖeka: 2, 3, 5, 7, //Xexlẽdzesi gbãtɔwoe nye 2, 3, 5, 7, 11, 13, 17,... //Xexadecimal xexlẽdzesiwoe nye 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. //enye 1 eye menye xexlẽdzesi sue eve ƒe xexlẽdzesi o).//enye xexlẽdzesi gbãtɔwo (numeral gbãtɔ, alo prime, nye xexlẽdzesi si li ŋutɔŋutɔ //hexadecimal xexlẽdzesi abe string ene eye wòxlẽa xexlẽdzesi siwo nye hexadecimal //Wode dɔ asi na wò be nàŋlɔ dɔ si xɔa // >>> hex_key(""AB"")
// 1
// >>> hex_key(""1077E"")
// 2
// >>> hex_key(""ABED1A33"")
// 4
// >>> hex_key(""123456789ABCDEF0"")
// 6
// >>> hex_key(""2020"")
// 2
func hex_key(num string) int {
","func hex_key(num string) int {
    primeDigits := map[rune]struct{}{
        '2': {},
        '3': {},
        '5': {},
        '7': {},
        'B': {},
        'D': {},
    }

    count := 0
    for _, digit := range num {
        if _, found := primeDigits[digit]; found {
            count++
        }
    }
    return count
}

func TestHexKey(t *testing.T) {
    tests := []struct {
        input    string
        expected int
    }{
        {""AB"", 1},
        {""1077E"", 2},
        {""ABED1A33"", 4},
        {""123456789ABCDEF0"", 6},
        {""2020"", 2},
        {"""", 0},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""hex_key(%s)"", test.input), func(t *testing.T) {
            result := hex_key(test.input)
            if result != test.expected {
                t.Errorf(""expected %d, got %d"", test.expected, result)
            }
        })
    }
}","func TestHex_Key(t *testing.T) {
  candidate := hex_key
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""AB""), expected: 1 },
     { actual: candidate(""1077E""), expected: 2 },
     { actual: candidate(""ABED1A33""), expected: 4 },
     { actual: candidate(""2020""), expected: 2 },
     { actual: candidate(""123456789ABCDEF0""), expected: 6 },
     { actual: candidate(""112233445566778899AABBCCDDEEFF00""), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_79,ewe_Latn,go_test.go,"package decimal_to_binary_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ŋkɔ siwo wotsɔ kpe ɖe eŋu la kpe ɖe eŋu le ale si woaŋlɔe me. //Ŋkɔ eve bubu siwo nye 'db' anɔ ŋɔŋlɔdzesi la ƒe gɔmedzedze kple nuwuwu.//Xexlẽdzesi ɖesiaɖe si le nyagbea me anye '0' alo '1'.//ele be dɔwɔwɔa nagbugbɔ string, kple ŋɔŋlɔdzesi ɖesiaɖe si le tsitre ɖi na binary //Woana xexlẽdzesi aɖe wò le xexlẽdzesi ewo me eye wò dɔe nye be nàtrɔe wòazu // >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
func decimal_to_binary(decimal int) string {
","package decimal_to_binary_test

import (
    ""testing""
    ""fmt""
    ""strconv""
)

// You will be given a number in decimal form and your task is to convert it to
// binary format. The function should return a string, with each character representing a binary
// number. Each character in the string will be '0' or '1'.
// There will be an extra couple of characters 'db' at the beginning and at the end of the string.
// The extra characters are there to help with the format.
// Examples:
// >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
func decimal_to_binary(decimal int) string {
    binary := strconv.FormatInt(int64(decimal), 2)
    return ""db"" + binary + ""db""
}

func TestDecimalToBinary(t *testing.T) {
    tests := []struct {
        input  int
        output string
    }{
        {15, ""db1111db""},
        {32, ""db100000db""},
        {0, ""db0db""},
        {1, ""db1db""},
        {255, ""db11111111db""},
    }

    for _, test := range tests {
        result := decimal_to_binary(test.input)
        if result != test.output {
            t.Errorf(""For input %d, expected %s, but got %s"", test.input, test.output, result)
        }
    }
}

func main() {
    fmt.Println(decimal_to_binary(15))  // Output: db1111db
    fmt.Println(decimal_to_binary(32))  // Output: db100000db
    fmt.Println(decimal_to_binary(255)) // Output: db11111111db
}","func TestDecimal_To_Binary(t *testing.T) {
  candidate := decimal_to_binary
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(0), expected: ""db0db"" },
     { actual: candidate(32), expected: ""db100000db"" },
     { actual: candidate(103), expected: ""db1100111db"" },
     { actual: candidate(15), expected: ""db1111db"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_80,ewe_Latn,go_test.go,"package is_happy_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Ne nyagbe aɖe ƒe didime nye 3 ya teti eye ne ŋɔŋlɔdzesi 3 siwo kplɔe ɖo dometɔ ɖesiaɖe to vovo la, ekema enye hapgo.//Wò dɔe nye be nàkpɔe ɖa be nyagbe la nye hapgo alo menye hapgo o.//Wona akalo si nye s. // >>> is_happy(""a"")
// false
// >>> is_happy(""aa"")
// false
// >>> is_happy(""abcd"")
// true
// >>> is_happy(""aabb"")
// false
// >>> is_happy(""adb"")
// true
// >>> is_happy(""xyy"")
// false
func is_happy(s string) bool {
","func is_happy(s string) bool {
    if len(s) < 3 {
        return false
    }
    for i := 0; i <= len(s)-3; i++ {
        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {
            return false
        }
    }
    return true
}","func TestIs_Happy(t *testing.T) {
  candidate := is_happy
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""a""), expected: false },
     { actual: candidate(""aa""), expected: false },
     { actual: candidate(""abcd""), expected: true },
     { actual: candidate(""aabb""), expected: false },
     { actual: candidate(""adb""), expected: true },
     { actual: candidate(""xyy""), expected: false },
     { actual: candidate(""iopaxpoi""), expected: true },
     { actual: candidate(""iopaxioi""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_81,ewe_Latn,go_test.go,"package numerical_letter_grade_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //0.0 E //> 0.0 D- //> 0.7 D //> 1.0 D+ //> 1.3 C- //> 1.7 C //> 2.0 C+ //> 2.3 B- //> 2.7 B //> 3.0 B+ //> 3.3 A- //> 3.7 A //4.0 A+ //GPA. Nuxexlẽ ƒe dzesi.//dɔwɔna si ate ŋu ana ŋɔŋlɔdzesi ƒe hatsotsowo ƒe ŋkɔwo nanɔ te le taɖodzinu si gbɔna la dzi: //Ena nufialawo ƒe sukudede ƒe dzesiwo wò eye ele be nàŋlɔe na wo.//Kuxi si li koe nye be, eƒe dzesi si wòzãna tsɔ dea dzesi nuwo la bu.//Nufiala la ŋutɔ to eƒe dzesiŋɔŋlɔmɔ̃ si dzi wòatsɔ aɖo dzesiwoe la vɛ.//Semesters ƒe kwasiɖa mamlɛtɔ mee nye sia eye nufiala la le dzesiwo nam.// >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})
// []string{""A+"", ""B"", ""C-"", ""C"", ""A-""}
func numerical_letter_grade(grades []float64) []string {
","func numerical_letter_grade(grades []float64) []string {
    letterGrades := []string{}
    for _, grade := range grades {
        if grade == 4.0 {
            letterGrades = append(letterGrades, ""A+"")
        } else if grade > 3.7 {
            letterGrades = append(letterGrades, ""A"")
        } else if grade > 3.3 {
            letterGrades = append(letterGrades, ""A-"")
        } else if grade > 3.0 {
            letterGrades = append(letterGrades, ""B+"")
        } else if grade > 2.7 {
            letterGrades = append(letterGrades, ""B"")
        } else if grade > 2.3 {
            letterGrades = append(letterGrades, ""B-"")
        } else if grade > 2.0 {
            letterGrades = append(letterGrades, ""C+"")
        } else if grade > 1.7 {
            letterGrades = append(letterGrades, ""C"")
        } else if grade > 1.3 {
            letterGrades = append(letterGrades, ""C-"")
        } else if grade > 1.0 {
            letterGrades = append(letterGrades, ""D+"")
        } else if grade > 0.7 {
            letterGrades = append(letterGrades, ""D"")
        } else if grade > 0.0 {
            letterGrades = append(letterGrades, ""D-"")
        } else {
            letterGrades = append(letterGrades, ""E"")
        }
    }
    return letterGrades
}","func TestNumerical_Letter_Grade(t *testing.T) {
  candidate := numerical_letter_grade
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{""A+"", ""B"", ""C-"", ""C"", ""A-""} },
     { actual: candidate([]float64{1.2}), expected: []string{""D+""} },
     { actual: candidate([]float64{0.5}), expected: []string{""D-""} },
     { actual: candidate([]float64{0.0}), expected: []string{""E""} },
     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{""D"", ""D-"", ""C-"", ""B"", ""B+""} },
     { actual: candidate([]float64{0.0, 0.7}), expected: []string{""E"", ""D-""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_82,ewe_Latn,go_test.go,"package prime_length_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //ne enye xexlẽdzesi gbãtɔ alo enye alakpa //Ŋlɔ dɔdeasi si xɔa string eye wòtrɔna true ne string la // >>> prime_length(""Hello"")
// true
// >>> prime_length(""abcdcba"")
// true
// >>> prime_length(""kittens"")
// true
// >>> prime_length(""orange"")
// false
func prime_length(myString string) bool {
","package prime_length_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func prime_length(myString string) bool {
    length := len(myString)
    return isPrime(length)
}

func TestPrimeLength(t *testing.T) {
    testCases := []struct{
        input string
        expected bool
    }{
        {""Hello"", true},
        {""abcdcba"", true},
        {""kittens"", true},
        {""orange"", false},
    }

    for _, testCase := range testCases {
        result := prime_length(testCase.input)
        if result != testCase.expected {
            t.Errorf(""prime_length(%v) returned %v, expected %v"", testCase.input, result, testCase.expected)
        }
    }
}

func main() {
    fmt.Println(prime_length(""Hello""))  // true
    fmt.Println(prime_length(""abcdcba""))  // true
    fmt.Println(prime_length(""kittens""))  // true
    fmt.Println(prime_length(""orange""))  // false
}","func TestPrime_Length(t *testing.T) {
  candidate := prime_length
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hello""), expected: true },
     { actual: candidate(""abcdcba""), expected: true },
     { actual: candidate(""kittens""), expected: true },
     { actual: candidate(""orange""), expected: false },
     { actual: candidate(""wow""), expected: true },
     { actual: candidate(""world""), expected: true },
     { actual: candidate(""MadaM""), expected: true },
     { actual: candidate(""Wow""), expected: true },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""HI""), expected: true },
     { actual: candidate(""go""), expected: true },
     { actual: candidate(""gogo""), expected: false },
     { actual: candidate(""aaaaaaaaaaaaaaa""), expected: false },
     { actual: candidate(""Madam""), expected: true },
     { actual: candidate(""M""), expected: false },
     { actual: candidate(""0""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_83,ewe_Latn,go_test.go,"package starts_one_ends_test

import (
    ""testing""
    ""fmt""
)

//Enyea xexlẽdzesi siwo ƒe xexlẽdzesi dze egɔme alo wua enu kple 1.//Ne wotsɔ xexlẽdzesi blibo nyui n na mí la, gbugbɔ xlẽ xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi n la ƒe xexlẽdzesi func starts_one_ends(n int) int {
","package starts_one_ends_test

import (
    ""testing""
    ""fmt""
)

// Given a positive integer n, return the count of the numbers of n-digit
// positive integers that start or end with 1.
func starts_one_ends(n int) int {
    if n == 1 {
        return 1
    }

    countStart1 := 1 * pow(10, n-1)
    countEnd1 := 9 * pow(10, n-2)
    
    return countStart1 + countEnd1
}

func pow(base, exp int) int {
    if exp == 0 {
        return 1
    }
    result := 1
    for i := 0; i < exp; i++ {
        result *= base
    }
    return result
}

func TestStartsOneEnds(t *testing.T) {
    tests := []struct {
        n        int
        expected int
    }{
        {1, 1},
        {2, 19},
        {3, 189},
        {4, 1899},
        {5, 18999},
    }

    for _, tt := range tests {
        testname := fmt.Sprintf(""n=%d"", tt.n)
        t.Run(testname, func(t *testing.T) {
            result := starts_one_ends(tt.n)
            if result != tt.expected {
                t.Errorf(""got %d, want %d"", result, tt.expected)
            }
        })
    }
}","func TestStarts_One_Ends(t *testing.T) {
  candidate := starts_one_ends
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1), expected: 1 },
     { actual: candidate(2), expected: 18 },
     { actual: candidate(3), expected: 180 },
     { actual: candidate(4), expected: 1800 },
     { actual: candidate(5), expected: 18000 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_84,ewe_Latn,go_test.go,"package solve_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu //Ne wotsɔ xexlẽdzesi blibo si nye N na la, trɔ eƒe xexlẽdzesi siwo nye binary ƒe xexlẽdzesi la katã ƒe xexlẽdzesi. // >>> solve(1000)
// ""1""
// >>> solve(150)
// ""110""
// >>> solve(147)
// ""1100""
// Variables:
// @N integer
// Constraints: 0 ≤ N ≤ 10000.
// Output:
// a string of binary number
func solve(N int) string {
","func solve(N int) string {
    sum := 0
    for N > 0 {
        sum += N % 10
        N /= 10
    }
    return fmt.Sprintf(""%b"", sum)
}","func TestSolve(t *testing.T) {
  candidate := solve
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(1000), expected: ""1"" },
     { actual: candidate(150), expected: ""110"" },
     { actual: candidate(147), expected: ""1100"" },
     { actual: candidate(333), expected: ""1001"" },
     { actual: candidate(963), expected: ""10010"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_85,ewe_Latn,go_test.go,"package add_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ne míetsɔ xexlẽdzesi siwo nye xexlẽdzesi siwo menye ƒuƒlu o la, míatsɔ xexlẽdzesi siwo nye xexlẽdzesi eve siwo le xexlẽdzesi eve dzi la akpee.// >>> add([]int{4, 2, 6, 7})
// 2
func add(lst []int) int {
","sum := 0
    for i := 1; i < len(lst); i += 2 {
        if lst[i]%2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","func TestAdd(t *testing.T) {
  candidate := add
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{4, 88}), expected: 88 },
     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },
     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },
     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_86,ewe_Latn,go_test.go,"package anti_shuffle_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //De dzesii: Ele be nàlé nya siwo nègblɔ kple teƒe siwo le nyagbea me la ɖe ɖoɖo nu.//le ɖoɖo si nu woɖua wo ɖokui dzi le le ascii-kɔdzia dzi. //wotsɔ nya yeye si me ŋɔŋlɔdzesi siwo katã le //Nyagbewo ƒe ɖoɖo si le ɖoɖo nu, enye nyagbe siwo katã le (siwo dome wometsɔ teƒe ɖo o) //Ŋlɔ dɔ si xɔa nyakui aɖe eye wòɖoa eƒe ɖoɖo aɖe ɖe enu.// >>> anti_shuffle(""Hi"")
// ""Hi""
// >>> anti_shuffle(""hello"")
// ""ehllo""
// >>> anti_shuffle(""Hello World!!!"")
// ""Hello !!!Wdlor""
func anti_shuffle(s string) string {
","package anti_shuffle_test

import (
    ""strings""
    ""sort""
)

func anti_shuffle(s string) string {
    // Split the input string into words based on spaces
    words := strings.Fields(s)

    // Iterate over each word
    for i, word := range words {
        // Convert the word to a slice of runes for sorting
        runes := []rune(word)
        // Sort the runes using custom comparison
        sort.Slice(runes, func(i, j int) bool {
            return runes[i] < runes[j]
        })
        // Reassign the sorted runes back to the word
        words[i] = string(runes)
    }

    // Rejoin the words into a single string, keeping original spaces
    result := """"
    inputIndex := 0

    for _, word := range words {
        // Add the spaces prior to the current word
        for inputIndex < len(s) && s[inputIndex] == ' ' {
            result += "" ""
            inputIndex++
        }
        // Add the current sorted word
        result += word
        inputIndex += len(word)
    }

    // Add trailing spaces, if any.
    for inputIndex < len(s) && s[inputIndex] == ' ' {
        result += "" ""
        inputIndex++
    }

    return result
}","func TestAnti_Shuffle(t *testing.T) {
  candidate := anti_shuffle
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hi""), expected: ""Hi"" },
     { actual: candidate(""hello""), expected: ""ehllo"" },
     { actual: candidate(""number""), expected: ""bemnru"" },
     { actual: candidate(""abcd""), expected: ""abcd"" },
     { actual: candidate(""Hello World!!!""), expected: ""Hello !!!Wdlor"" },
     { actual: candidate(""""), expected: """" },
     { actual: candidate(""Hi. My name is Mister Robot. How are you?""), expected: "".Hi My aemn is Meirst .Rboot How aer ?ouy"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_87,ewe_Latn,go_test.go,"package get_row_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Azɔ hã, tsɔ axawo ƒe xexlẽdzesiwo me nyawo ɖo ɖoɖo si dzi woadze le la nu.//Midzra kadodoawo ɖo ɖe ɖoɖo si nu woyina dzi ɖo la nu gbã.//axawo katã nyea xɔnuvɔ̃ - (dzinɔ, kɔli), eye wodzea egɔme kple 0. //eye wòana woaŋlɔ ŋkɔ siwo le ŋkɔawo me la [(x1, y1), (x2, y2) ...] ale be //Ne èna lst, kple x, la, ke kpɔ x ƒe xexlẽdzesi siwo le xexlẽdzesi la me, //axawo ƒe xexlẽme ate ŋu ato vovo le axa ɖe sia ɖe me.//si ɖi matrix, gake to vovo na matrixwo la,//Wona nu siwo le dzedzem le go eve me wòzu nu siwo le ƒuƒoƒo me, // >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)
// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}
// >>> get_row([][]int{}, 1)
// [][]interface{}{}
// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)
// [][]int{[]interface{}{2, 2}}
func get_row(lst [][]int, x int) [][]interface{} {
","package get_row_test

import (
	""sort""
)

func get_row(lst [][]int, x int) [][]interface{} {
	var result [][]interface{}

	for i, row := range lst {
		var temp []interface{}
		for j, value := range row {
			if value == x {
				temp = append(temp, []interface{}{i, j})
			}
		}
		// Sort columns in descending order for the current row
		sort.Slice(temp, func(a, b int) bool {
			return temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)
		})
		result = append(result, temp...)
	}

	// result is already sorted by rows since we've traversed `lst` row by row
	return result
}","func TestGet_Row(t *testing.T) {
  candidate := get_row
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },
     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },
     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },
     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_88,ewe_Latn,go_test.go,"package sort_array_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //* mègaɖɔ li nusiwo le eme la o. //De dzesii: //alo woadzidze wo le ɖoɖo si dzi woato anɔ ɖiɖim ɖe edzi me ne woƒo wo katã nu ƒu la ((ŋkɔdzesi gbãtɔ, ŋkɔdzesi mamlɛtɔ) sɔ. //miatsɔ ŋkɔ siwo le eme la ƒe xexlẽdzesiwo anɔ ɖoɖo si dzi woato anɔ dzi demi ne xexlẽdzesi siwo le eme la ƒe xexlẽdzesi siwo nye (( gbãtɔ ƒe xexlẽdzesi, mamlɛtɔ ƒe xexlẽdzesi) la nye ɖeka, //Ne wotsɔ xexlẽdzesi siwo menye ameŋkumenu o ƒe ŋkɔwo na mí la, míatrɔ ŋkɔa ƒe cogo le ɖoɖowɔwɔ vɔ megbe, // >>> sort_array([]int{})
// []int{}
// >>> sort_array([]int{5})
// []int{5}
// >>> sort_array([]int{2, 4, 3, 0, 1, 5})
// []int{0, 1, 2, 3, 4, 5}
// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})
// []int{6, 5, 4, 3, 2, 1, 0}
func sort_array(array []int) []int {
","package sort_array_test

import (
    ""sort""
)

func sort_array(array []int) []int {
    if len(array) <= 1 {
        return append([]int{}, array...)
    }

    result := append([]int{}, array...) // Copy the array to avoid mutating the input
    if (result[0]+result[len(result)-1])%2 == 0 {
        sort.Sort(sort.Reverse(sort.IntSlice(result))) // Sort in descending order
    } else {
        sort.Ints(result) // Sort in ascending order
    }

    return result
}","func TestSort_Array(t *testing.T) {
  candidate := sort_array
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{5}), expected: []int{5} },
     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },
     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },
     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },
     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },
     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_89,ewe_Latn,go_test.go,"package encrypt_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //tsɔe eve dzi ɖe edzi va ɖo teƒe eve.//Ele be woaɖɔli alfabeta la ale be ŋɔŋlɔdzesi siwo nye //trɔa asi le alifebiawo ŋu wòzuaa nyagbe si wotsɔ nyagbewo ɖo.//Wɔ dɔdeasi si xɔa nyagbewo abe nyagbewo ene eye // >>> encrypt(""hi"")
// ""lm""
// >>> encrypt(""asdfghjkl"")
// ""ewhjklnop""
// >>> encrypt(""gf"")
// ""kj""
// >>> encrypt(""et"")
// ""ix""
func encrypt(s string) string {
","func encrypt(s string) string {
    result := []rune(s)
    for i, char := range result {
        if char >= 'a' && char <= 'z' {
            result[i] = 'a' + (char-'a'+4)%26
        } else if char >= 'A' && char <= 'Z' {
            result[i] = 'A' + (char-'A'+4)%26
        }
    }
    return string(result)
}","func TestEncrypt(t *testing.T) {
  candidate := encrypt
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""hi""), expected: ""lm"" },
     { actual: candidate(""asdfghjkl""), expected: ""ewhjklnop"" },
     { actual: candidate(""gf""), expected: ""kj"" },
     { actual: candidate(""et""), expected: ""ix"" },
     { actual: candidate(""faewfawefaewg""), expected: ""jeiajeaijeiak"" },
     { actual: candidate(""hellomyfriend""), expected: ""lippsqcjvmirh"" },
     { actual: candidate(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""), expected: ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" },
     { actual: candidate(""a""), expected: ""e"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_91,ewe_Latn,go_test.go,"package is_bored_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Wozãa '.', '?' alo '!' tsɔ dea akpa aɖe nyagbɔgblɔwo dome. //Nuxaxa nye nyagbɔgblɔ si dzea egɔme kple ""m"".//Woana nya aɖewo wò, eye wò dɔe nye be nàxlẽ xexlẽdzesiawo.// >>> is_bored(""Hello world"")
// 0
// >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
// 1
func is_bored(S string) int {
","package is_bored_test

import (
    ""strings""
    ""testing""
    ""fmt""
)

func is_bored(S string) int {
    sentences := strings.FieldsFunc(S, func(r rune) bool {
        return r == '.' || r == '?' || r == '!'
    })
    count := 0
    for _, sentence := range sentences {
        trimmed := strings.TrimSpace(sentence)
        if strings.HasPrefix(trimmed, ""I "") {
            count++
        }
    }
    return count
}

func TestIsBored(t *testing.T) {
    tests := []struct {
        input string
        want  int
    }{
        {""Hello world"", 0},
        {""The sky is blue. The sun is shining. I love this weather"", 1},
        {""I am here. I am there. I am everywhere"", 3},
        {""What's up? Are you ok? Yes, I am!"", 1},
        {"""", 0},
        {""I."", 1},
        {""I! am excited. I? am curious"", 2},
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf(""is_bored(%q)"", tt.input), func(t *testing.T) {
            got := is_bored(tt.input)
            if got != tt.want {
                t.Errorf(""got %d, want %d"", got, tt.want)
            }
        })
    }
}","func TestIs_Bored(t *testing.T) {
  candidate := is_bored
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hello world""), expected: 0 },
     { actual: candidate(""Is the sky blue?""), expected: 0 },
     { actual: candidate(""I love It !""), expected: 1 },
     { actual: candidate(""bIt""), expected: 0 },
     { actual: candidate(""I feel good today. I will be productive. will kill It""), expected: 2 },
     { actual: candidate(""You and I are going for a walk""), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_92,ewe_Latn,go_test.go,"package any_int_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //Etrɔna va nye false le go bubuwo me. //Ne xexlẽdzesi eveawo ƒe ƒuƒoƒo sɔ kple wo dometɔ ɖeka eye xexlẽdzesiawo katã nye xexlẽdzesi blibowo la, ekema enye nyateƒe.//Wɔ dɔdeasi si axɔ xexlẽdzesi etɔ̃.// >>> any_int(5, 2, 7)
// true
// >>> any_int(3, 2, 2)
// false
// >>> any_int(3, -2, 1)
// true
// >>> any_int(3.6, -2.2, 2)
// false
func any_int(x float64, y float64, z float64) bool {
","package any_int_test

import (
    ""testing""
)

func any_int(x float64, y float64, z float64) bool {
    // Check if x, y, and z are integers
    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {
        return false
    }

    // Check if one of the numbers is the sum of the other two
    if x == y+z || y == x+z || z == x+y {
        return true
    }

    return false
}

func TestAnyInt(t *testing.T) {
    if !any_int(5, 2, 7) {
        t.Errorf(""Expected true for any_int(5, 2, 7)"")
    }
    if any_int(3, 2, 2) {
        t.Errorf(""Expected false for any_int(3, 2, 2)"")
    }
    if !any_int(3, -2, 1) {
        t.Errorf(""Expected true for any_int(3, -2, 1)"")
    }
    if any_int(3.6, -2.2, 2) {
        t.Errorf(""Expected false for any_int(3.6, -2.2, 2)"")
    }
}","func TestAny_Int(t *testing.T) {
  candidate := any_int
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2, 3, 1), expected: true },
     { actual: candidate(2.5, 2, 3), expected: false },
     { actual: candidate(1.5, 5, 3.5), expected: false },
     { actual: candidate(2, 6, 2), expected: false },
     { actual: candidate(4, 2, 2), expected: true },
     { actual: candidate(2.2, 2.2, 2.2), expected: false },
     { actual: candidate(-4, 6, 2), expected: true },
     { actual: candidate(2, 1, 1), expected: true },
     { actual: candidate(3, 4, 7), expected: true },
     { actual: candidate(3.0, 4, 7), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_93,ewe_Latn,go_test.go,"package encode_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ŋlɔ nya siwo le eme la ko.//Enye gbeɖiɖi le Eŋlisigbe me alfabeta me.//lɛta si dze le teƒe eve do ŋgɔ na ema la le gbedasia me //Etrɔa ŋɔŋlɔdzesiwo katã ƒe ŋɔŋlɔdzesiwo, eye wòɖɔa gbeɖiɖiwo katã le  me.//Ŋlɔ dɔdeasi aɖe si xɔa gbedasi aɖe, eye wòŋlɔa edzi be // >>> encode(""test"")
// ""TGST""
// >>> encode(""This is a message"")
// ""tHKS KS C MGSSCGG""
func encode(message string) string {
","package encode_test

import (
	""strings""
	""unicode""
)

func encode(message string) string {
	var encodedMessage strings.Builder

	// Mapping of vowels to the letter appearing 2 places ahead
	vowelReplacement := map[rune]rune{
		'a': 'c',
		'A': 'C',
		'e': 'g',
		'E': 'G',
		'i': 'k',
		'I': 'K',
		'o': 'q',
		'O': 'Q',
		'u': 'w',
		'U': 'W',
	}

	for _, char := range message {
		if unicode.IsLetter(char) {
			// Swap case of the character
			if unicode.IsUpper(char) {
				char = unicode.ToLower(char)
			} else {
				char = unicode.ToUpper(char)
			}

			// Replace vowel if the character is a vowel
			if replacement, isVowel := vowelReplacement[char]; isVowel {
				char = replacement
			}
		}

		encodedMessage.WriteRune(char)
	}

	return encodedMessage.String()
}","func TestEncode(t *testing.T) {
  candidate := encode
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""TEST""), expected: ""tgst"" },
     { actual: candidate(""Mudasir""), expected: ""mWDCSKR"" },
     { actual: candidate(""YES""), expected: ""ygs"" },
     { actual: candidate(""This is a message""), expected: ""tHKS KS C MGSSCGG"" },
     { actual: candidate(""I DoNt KnOw WhAt tO WrItE""), expected: ""k dQnT kNqW wHcT Tq wRkTg"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_94,ewe_Latn,go_test.go,"package skjkasdkd_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ele be nàkpɔ prime xexlẽdzesi gãtɔ si le eme eye nàtsɔ eƒe xexlẽdzesi siwo wotsɔ ƒo ƒui la ƒe xexlẽdzesi agbɔsɔsɔe.//Wona xexlẽdzesi blibowo ƒe xexlẽdzesi wò.// >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})
// 10
// >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})
// 25
// >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})
// 13
// >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})
// 11
// >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})
// 3
// >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})
// 7
func skjkasdkd(lst []int) int {
","package skjkasdkd_test

import (
	""testing""
)

// Helper function to check if a number is prime
func isPrime(n int) bool {
	if n < 2 {
		return false
	}
	for i := 2; i*i <= n; i++ {
		if n%i == 0 {
			return false
		}
	}
	return true
}

// Function to calculate the sum of digits of a number
func sumOfDigits(n int) int {
	sum := 0
	for n > 0 {
		sum += n % 10
		n /= 10
	}
	return sum
}

// Function to find the largest prime and return the sum of its digits
func skjkasdkd(lst []int) int {
	maxPrime := -1
	for _, num := range lst {
		if isPrime(num) && num > maxPrime {
			maxPrime = num
		}
	}
	if maxPrime == -1 {
		return 0
	}
	return sumOfDigits(maxPrime)
}

func TestSkjkasdkd(t *testing.T) {
	tests := []struct {
		input    []int
		expected int
	}{
		{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},
		{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},
		{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},
		{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},
		{[]int{0, 81, 12, 3, 1, 21}, 3},
		{[]int{0, 8, 1, 2, 1, 7}, 7},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
			result := skjkasdkd(test.input)
			if result != test.expected {
				t.Errorf(""got %v, want %v"", result, test.expected)
			}
		})
	}
}","func TestSkjkasdkd(t *testing.T) {
  candidate := skjkasdkd
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },
     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },
     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },
     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },
     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },
     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },
     { actual: candidate([]int{8191}), expected: 19 },
     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },
     { actual: candidate([]int{127, 97, 8192}), expected: 10 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_95,ewe_Latn,go_test.go,"package check_dict_case_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ele be dɔwɔwɔa nagbugbɔ false ne anyigbatata si wona la le ƒuƒlu. //case alo keys katã nye string siwo nye uppercase, ne menye nenema o la return false. //Ne wotsɔ anyigbatata aɖe na mí la, trɔna true ne safuiwo katã nye string siwo le sue wu // >>> check_dict_case(map[string]string{""a"": ""apple"", ""b"": ""banana""})
// true
// >>> check_dict_case(map[string]string{""a"": ""apple"", ""A"": ""banana"", ""B"": ""banana""})
// false
// >>> check_dict_case(map[interface{}]string{""a"": ""apple"", 8: ""banana"", ""a"": ""apple""})
// false
// >>> check_dict_case(map[string]string{""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""})
// false
// >>> check_dict_case(map[string]string{""STATE"": ""NC"", ""ZIP"": ""12345""})
// true
func check_dict_case(dict map[string]string) bool {
","func check_dict_case(dict map[string]string) bool {
    if len(dict) == 0 {
        return false
    }

    var allLowercase, allUppercase bool
    for k := range dict {
        if k != strings.ToLower(k) && k != strings.ToUpper(k) {
            return false
        }
        if k == strings.ToLower(k) {
            if allUppercase {
                return false
            }
            allLowercase = true
        }
        if k == strings.ToUpper(k) {
            if allLowercase {
                return false
            }
            allUppercase = true
        }
    }

    return allLowercase || allUppercase
}","func TestCheck_Dict_Case(t *testing.T) {
  candidate := check_dict_case
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""b"": ""banana""}), expected: true },
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""A"": ""banana"", ""B"": ""banana""}), expected: false },
     { actual: candidate(map[string]string{""p"": ""pineapple"", ""5"": ""banana"", ""a"": ""apple""}), expected: false },
     { actual: candidate(map[string]string{""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""}), expected: false },
     { actual: candidate(map[string]string{""STATE"": ""NC"", ""ZIP"": ""12345""}), expected: true },
     { actual: candidate(map[string]string{""fruit"": ""Orange"", ""taste"": ""Sweet""}), expected: true },
     { actual: candidate(map[string]string{}), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_96,ewe_Latn,go_test.go,"package count_up_to_test

import (
    ""testing""
    ""fmt""
)

//le kpɔɖeŋu me: //enye xexlẽdzesi siwo nye gbãtɔwo eye wonyo wu n. //Wɔ dɔdeasi aɖe si xɔa xexlẽdzesi blibo si menye vɔ o eye wònana xexlẽdzesi gbãtɔ n ƒe ŋkɔwo dzena.// >>> count_up_to(5)
// []int{2, 3}
// >>> count_up_to(11)
// []int{2, 3, 5, 7}
// >>> count_up_to(0)
// []int{}
// >>> count_up_to(20)
// []int{2, 3, 5, 7, 11, 13, 17, 19}
// >>> count_up_to(1)
// []int{}
// >>> count_up_to(18)
// []int{2, 3, 5, 7, 11, 13, 17}
func count_up_to(n int) []int {
","func count_up_to(n int) []int {
	primes := []int{}
	for num := 2; num < n; num++ {
		if isPrime(num) {
			primes = append(primes, num)
		}
	}
	return primes
}

func isPrime(num int) bool {
	if num <= 1 {
		return false
	}
	for i := 2; i*i <= num; i++ {
		if num%i == 0 {
			return false
		}
	}
	return true
}","func TestCount_Up_To(t *testing.T) {
  candidate := count_up_to
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: []int{2, 3} },
     { actual: candidate(6), expected: []int{2, 3, 5} },
     { actual: candidate(7), expected: []int{2, 3, 5} },
     { actual: candidate(10), expected: []int{2, 3, 5, 7} },
     { actual: candidate(0), expected: []int{} },
     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },
     { actual: candidate(1), expected: []int{} },
     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },
     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },
     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_97,ewe_Latn,go_test.go,"package multiply_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Tsɔe be nu si nèŋlɔ la nye nyateƒe ɣesiaɣi.//woƒe xexlẽdzesi ɖeka ƒe xexlẽdzesi ƒe xexlẽdzesi. //Xlẽ numekuku si me woxɔa xexlẽdzesi blibo eve le eye wògatrɔa // >>> multiply(148, 412)
// 16
// >>> multiply(19, 28)
// 72
// >>> multiply(2020, 1851)
// 0
// >>> multiply(14, -15)
// 20
func multiply(a int, b int) int {
","package multiply_test

import (
    ""testing""
    ""fmt""
)

// Complete the function that takes two integers and returns 
// the product of their unit digits.
// Assume the input is always valid.
func multiply(a int, b int) int {
    unitA := abs(a) % 10
    unitB := abs(b) % 10
    return unitA * unitB
}

func abs(n int) int {
    if n < 0 {
        return -n
    }
    return n
}

func TestMultiply(t *testing.T) {
    fmt.Println(multiply(148, 412)) // 16
    fmt.Println(multiply(19, 28))   // 72
    fmt.Println(multiply(2020, 1851)) // 0
    fmt.Println(multiply(14, -15))  // 20
}","func TestMultiply(t *testing.T) {
  candidate := multiply
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(148, 412), expected: 16 },
     { actual: candidate(19, 28), expected: 72 },
     { actual: candidate(2020, 1851), expected: 0 },
     { actual: candidate(14, -15), expected: 20 },
     { actual: candidate(76, 67), expected: 42 },
     { actual: candidate(17, 27), expected: 49 },
     { actual: candidate(0, 1), expected: 0 },
     { actual: candidate(0, 0), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_98,ewe_Latn,go_test.go,"package count_upper_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Ne wotsɔ nyagbe s na wò la, xlẽ gbeɖiɖi gã siwo le ŋɔŋlɔdzesi eve me la ƒe xexlẽme. // >>> count_upper(""aBCdEf"")
// 1
// >>> count_upper(""abcdefg"")
// 0
// >>> count_upper(""dBBE"")
// 0
func count_upper(s string) int {
","package count_upper_test

import (
    ""testing""
)

func count_upper(s string) int {
    uppercaseVowels := ""AEIOU""
    count := 0
    
    for i := 0; i < len(s); i += 2 {
        if contains(uppercaseVowels, s[i]) {
            count++
        }
    }
    
    return count
}

func contains(vowels string, ch byte) bool {
    for i := 0; i < len(vowels); i++ {
        if vowels[i] == ch {
            return true
        }
    }
    return false
}

func TestCountUpper(t *testing.T) {
    tests := []struct {
        input    string
        expected int
    }{
        {""aBCdEf"", 1},
        {""abcdefg"", 0},
        {""dBBE"", 0},
    }

    for _, test := range tests {
        result := count_upper(test.input)
        if result != test.expected {
            t.Errorf(""For input '%s', expected %d but got %d"", test.input, test.expected, result)
        }
    }
}","func TestCount_Upper(t *testing.T) {
  candidate := count_upper
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""aBCdEf""), expected: 1 },
     { actual: candidate(""abcdefg""), expected: 0 },
     { actual: candidate(""dBBE""), expected: 0 },
     { actual: candidate(""B""), expected: 0 },
     { actual: candidate(""U""), expected: 1 },
     { actual: candidate(""""), expected: 0 },
     { actual: candidate(""EEEE""), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_99,ewe_Latn,go_test.go,"package closest_integer_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //tso xexlẽdzesi blibo eve dzi, ƒo xlãe wòayi adzɔge tso nu me.//Ne xexlẽdzesi la le adzɔge tso wo nɔewo gbɔ la, ekema enyea xexlẽdzesi si gogo wo wu.//Wɔ dɔdeasi si xɔa xexlẽdzesi aɖe si nye xexlẽdzesi (dzesi) si le tsitre ɖi na xexlẽdzesi aɖe // >>> closest_integer(""10"")
// 10
// >>> closest_integer(""15.3"")
// 15
// Note:
// Rounding away from zero means that if the given number is equidistant
// from two integers, the one you should return is the one that is the
// farthest from zero. For example closest_integer(""14.5"") should
// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value string) int {
","package closest_integer_test

import (
	""strconv""
	""math""
)

func closest_integer(value string) int {
	num, err := strconv.ParseFloat(value, 64)
	if err != nil {
		return 0 // handle error appropriately in real scenarios
	}
	if num > 0 {
		return int(math.Ceil(num - 0.5))
	}
	return int(math.Floor(num + 0.5))
}","func TestClosest_Integer(t *testing.T) {
  candidate := closest_integer
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""10""), expected: 10 },
     { actual: candidate(""14.5""), expected: 15 },
     { actual: candidate(""-15.5""), expected: -16 },
     { actual: candidate(""15.3""), expected: 15 },
     { actual: candidate(""0""), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_100,ewe_Latn,go_test.go,"package make_a_pile_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //i nye kpe siwo le dziƒoxɔ (i+1) la ƒe xexlẽme.//Etsɔ kpe siwo le dzedzeme ɖesiaɖe me le nuŋlɔɖi aɖe me, afisi element le index //- Ne n nye xexlẽdzesi eve la, ekema enye xexlẽdzesi eve si kplɔe ɖo. //- Ne n nye xexlẽdzesi ɖeka la, ekema enye xexlẽdzesi eve siwo kplɔe ɖo. //Kpe siwo le dzisasrã si kplɔe ɖo me ƒe xexlẽme nye: //Kpe n ye le dzisasrã gbãtɔa dzi.//Ne èkpɔ xexlẽdzesi blibo si nye n la, ele be nàƒo kpewo nu ƒu le dzidze n me.// >>> make_a_pile(3)
// []int{3, 5, 7}
func make_a_pile(n int) []int {
","package make_a_pile_test

import (
    ""testing""
    ""fmt""
)

func make_a_pile(n int) []int {
    pile := make([]int, n)
    currentStones := n

    for i := 0; i < n; i++ {
        pile[i] = currentStones
        if n%2 == 0 {
            currentStones += 2
        } else {
            currentStones += 2
        }
    }

    return pile
}

func TestMakeAPile(t *testing.T) {
    cases := []struct {
        input    int
        expected []int
    }{
        {3, []int{3, 5, 7}},
        {4, []int{4, 6, 8, 10}},
        {1, []int{1}},
        {5, []int{5, 7, 9, 11, 13}},
    }

    for _, c := range cases {
        res := make_a_pile(c.input)
        if fmt.Sprintf(""%v"", res) != fmt.Sprintf(""%v"", c.expected) {
            t.Errorf(""make_a_pile(%d) == %v, expected %v"", c.input, res, c.expected)
        }
    }
}","func TestMake_A_Pile(t *testing.T) {
  candidate := make_a_pile
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: []int{3, 5, 7} },
     { actual: candidate(4), expected: []int{4, 6, 8, 10} },
     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },
     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },
     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_101,ewe_Latn,go_test.go,"package words_string_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //be wòama nyawo me eye wòana nyawo ƒe ŋkɔwo nanɔ eme.//Woana nyagbewo ƒe xexlẽdzesi siwo wotsɔ akpanyawo alo teƒewo ɖe vovo la wò. Wò dɔdeasi enye be // >>> words_string(""Hi, my name is John"")
// []string{""Hi"", ""my"", ""name"", ""is"", ""John""}
// >>> words_string(""One, two, three, four, five, six"")
// []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""}
func words_string(s string) []string {
","package words_string_test

import (
    ""testing""
    ""strings""
    ""fmt""
    ""regexp""
)

func words_string(s string) []string {
    re := regexp.MustCompile(`[,\s]+`)
    return re.Split(s, -1)
}

func TestWordsString(t *testing.T) {
    tests := []struct{
        input string
        expected []string
    }{
        {""Hi, my name is John"", []string{""Hi"", ""my"", ""name"", ""is"", ""John""}},
        {""One, two, three, four, five, six"", []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""}},
        {""a,b,c"", []string{""a"", ""b"", ""c""}},
        {""hello world"", []string{""hello"", ""world""}},
    }

    for _, test := range tests {
        result := words_string(test.input)
        if !equal(result, test.expected) {
            t.Errorf(""Expected %v, but got %v"", test.expected, result)
        }
    }
}

func equal(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestWords_String(t *testing.T) {
  candidate := words_string
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Hi, my name is John""), expected: []string{""Hi"", ""my"", ""name"", ""is"", ""John""} },
     { actual: candidate(""One, two, three, four, five, six""), expected: []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""} },
     { actual: candidate(""Hi, my name""), expected: []string{""Hi"", ""my"", ""name""} },
     { actual: candidate(""One,, two, three, four, five, six,""), expected: []string{""One"", ""two"", ""three"", ""four"", ""five"", ""six""} },
     { actual: candidate(""""), expected: []string{} },
     { actual: candidate(""ahmed     , gamal""), expected: []string{""ahmed"", ""gamal""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_102,ewe_Latn,go_test.go,"package choose_num_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Ne xexlẽdzesi ma meli o la, ekema ele be dɔwɔwɔa nagbugbɔ -1.//Ne enye xexlẽdzesi si le [x, y] dome la, ekema enye xexlẽdzesi si le [x, y] dome.//Dɔwɔƒe sia xɔa xexlẽdzesi nyui eve x kple y eye wòɖoa // >>> choose_num(12, 15)
// 14
// >>> choose_num(13, 12)
// -1
func choose_num(x int, y int) int {
","func choose_num(x int, y int) int {
	if x > y {
		return -1
	}
	// Start from y and move backwards looking for the largest even number
	for i := y; i >= x; i-- {
		if i%2 == 0 {
			return i
		}
	}
	return -1
}

func TestChooseNum(t *testing.T) {
	tests := []struct {
		x, y, expected int
	}{
		{12, 15, 14},
		{13, 12, -1},
		{4, 10, 10},
		{5, 5, -1},
		{6, 6, 6},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""x=%d_y=%d"", test.x, test.y), func(t *testing.T) {
			result := choose_num(test.x, test.y)
			if result != test.expected {
				t.Errorf(""For choose_num(%d, %d), expected %d, but got %d"", test.x, test.y, test.expected, result)
			}
		})
	}
}","func TestChoose_Num(t *testing.T) {
  candidate := choose_num
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(12, 15), expected: 14 },
     { actual: candidate(13, 12), expected: -1 },
     { actual: candidate(33, 12354), expected: 12354 },
     { actual: candidate(5234, 5233), expected: -1 },
     { actual: candidate(6, 29), expected: 28 },
     { actual: candidate(27, 10), expected: -1 },
     { actual: candidate(7, 7), expected: -1 },
     { actual: candidate(546, 546), expected: 546 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_104,ewe_Latn,go_test.go,"package unique_digits_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //De dzesii: Ele be woaɖo ŋkɔ siwo woagbugbɔ aɖo ɖe ame siwo woagbugbɔ aɖo ɖe wo la ƒe xexlẽdzesiwo ɖe ɖoɖo si nu wole dzidzim ɖe edzi le nu.//element siwo ƒe xexlẽdzesi menye eve o.//Ne wotsɔ xexlẽdzesi siwo nye x ƒe xexlẽdzesiwo na mí la, míana xexlẽdzesi siwo katã nye x ƒe xexlẽdzesiwo la ƒe xexlẽdzesi si me woɖɔ ɖo la.// >>> unique_digits([]int{15, 33, 1422, 1})
// []int{1, 15, 33}
// >>> unique_digits([]int{152, 323, 1422, 10})
// []int{}
func unique_digits(x []int) []int {
","package unique_digits_test

import (
    ""sort""
)

// unique_digits returns a sorted list of all elements that don't have any even digit.
func unique_digits(x []int) []int {
    result := []int{}
    for _, num := range x {
        if hasEvenDigit(num) == false {
            result = append(result, num)
        }
    }
    sort.Ints(result)
    return result
}

// hasEvenDigit checks if a given number contains any even digit.
func hasEvenDigit(num int) bool {
    for num > 0 {
        digit := num % 10
        if digit%2 == 0 {
            return true
        }
        num /= 10
    }
    return false
}","func TestUnique_Digits(t *testing.T) {
  candidate := unique_digits
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },
     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },
     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },
     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_105,ewe_Latn,go_test.go,"package by_length_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //""Ame ɖeka"", ""Ame eve"", ""Ame etɔ̃"", ""Ame ene"", ""Ame atɔ̃"", ""Ame ade"", ""Ame adre"", ""Ame enyi"", ""Ame asieke"". //trɔ asi le xexlẽdzesi si do tso eme la ŋu, eye nàtsɔ ŋkɔ si sɔ na xexlẽdzesi ɖesiaɖe si le  la aɖɔlii.//Ne èkpɔ xexlẽdzesi blibowo le axa aɖe la, wɔ xexlẽdzesi siwo le 1 va se ɖe 9 la ƒe hatsotsowo ŋu ɖoɖo, // >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})
// []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""}
// If the list is empty, return an empty list:
// >>> by_length([]int{})
// []string{}
// If the list has any strange number ignore it:
// >>> by_length([]int{1, -1, 55})
// []string{""One""}
func by_length(arr []int) []string {
","package by_length_test

import (
    ""testing""
    ""sort""
)

func by_length(arr []int) []string {
    // Filter numbers between 1 and 9
    filtered := []int{}
    for _, num := range arr {
        if num >= 1 && num <= 9 {
            filtered = append(filtered, num)
        }
    }

    // Sort in ascending order
    sort.Ints(filtered)

    // Reverse the sorted slice
    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {
        filtered[i], filtered[j] = filtered[j], filtered[i]
    }

    // Map numbers to their corresponding names
    numToString := map[int]string{
        1: ""One"", 2: ""Two"", 3: ""Three"",
        4: ""Four"", 5: ""Five"", 6: ""Six"",
        7: ""Seven"", 8: ""Eight"", 9: ""Nine"",
    }

    // Create the result slice with names
    result := []string{}
    for _, num := range filtered {
        result = append(result, numToString[num])
    }

    return result
}

func TestByLength(t *testing.T) {
    tests := []struct {
        input []int
        want  []string
    }{
        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""}},
        {[]int{}, []string{}},
        {[]int{1, -1, 55}, []string{""One""}},
    }

    for _, test := range tests {
        t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
            got := by_length(test.input)
            if !equals(got, test.want) {
                t.Errorf(""got = %v; want %v"", got, test.want)
            }
        })
    }
}

func equals(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}","func TestBy_Length(t *testing.T) {
  candidate := by_length
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""} },
     { actual: candidate([]int{}), expected: []string{} },
     { actual: candidate([]int{1, -1, 55}), expected: []string{""One""} },
     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{""Three"", ""Two"", ""One""} },
     { actual: candidate([]int{9, 4, 8}), expected: []string{""Nine"", ""Eight"", ""Four""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_106,ewe_Latn,go_test.go,"package f_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Xexlẽdzesi si nye 1 yi i ƒe xexlẽdzesi siwo nye (1 * 2 * ... * i) ƒe xexlẽdzesiwoe nye i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye (1 * 2 * ... * i) ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesi siwo nye 1 yi i ƒe xexlẽdzesiwo.//i dze egɔme tso 1. //alo xexlẽdzesi siwo tso 1 va se ɖe i ƒe xexlẽdzesi. //eye wòana n ƒe lolome ƒe xexlẽdzesi, ale be nu si le index i la ƒe asixɔxɔ nanye i ƒe nuƒleƒle ne i nye eve //Wɔ dɔdeasi si nye f si xɔa n abe parameter ene la ŋudɔ, // >>> f(5)
// []int{1, 2, 6, 24, 15}
func f(n int) []int {
","package f_test

import (
    ""testing""
    ""fmt""
)

func f(n int) []int {
    result := make([]int, n)
    for i := 1; i <= n; i++ {
        if i%2 == 0 {
            result[i-1] = factorial(i)
        } else {
            result[i-1] = sum(i)
        }
    }
    return result
}

func factorial(num int) int {
    if num <= 1 {
        return 1
    }
    return num * factorial(num-1)
}

func sum(num int) int {
    s := 0
    for i := 1; i <= num; i++ {
        s += i
    }
    return s
}

func TestF(t *testing.T) {
    expected := []int{1, 2, 6, 24, 15}
    result := f(5)
    if !equals(expected, result) {
        t.Errorf(""Expected %v, got %v"", expected, result)
    }
}

func equals(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}

func main() {
    fmt.Println(f(5)) // Output: []int{1, 2, 6, 24, 15}
}","func TestF(t *testing.T) {
  candidate := f
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },
     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },
     { actual: candidate(1), expected: []int{1} },
     { actual: candidate(3), expected: []int{1, 2, 6} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_107,ewe_Latn,go_test.go,"package even_odd_palindrome_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu 1: //Palindromes siwo nye xexlẽdzesi blibo siwo le ɖoɖo si nye ((1, n), kple wo nɔewo dome. //Ne wotsɔ xexlẽdzesi blibo si nye n na mí la, míana xexlẽdzesi siwo nye eve kple eve ƒe xexlẽdzesi nanɔ eme // >>> even_odd_palindrome(3)
// []interface{}{1, 2}
// Explanation:
// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
// Example 2:
// >>> even_odd_palindrome(12)
// []interface{}{4, 6}
// Explanation:
// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
// Note:
// 1. 1 <= n <= 10^3
// 2. returned list has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n int) []interface{} {
","func isPalindrome(num int) bool {
    original := num
    reversed := 0
    for num > 0 {
        reversed = reversed*10 + num%10
        num /= 10
    }
    return original == reversed
}

func even_odd_palindrome(n int) []interface{} {
    evenCount, oddCount := 0, 0
    for i := 1; i <= n; i++ {
        if isPalindrome(i) {
            if i%2 == 0 {
                evenCount++
            } else {
                oddCount++
            }
        }
    }
    return []interface{}{evenCount, oddCount}
}","func TestEven_Odd_Palindrome(t *testing.T) {
  candidate := even_odd_palindrome
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(123), expected: []interface{}{8, 13} },
     { actual: candidate(12), expected: []interface{}{4, 6} },
     { actual: candidate(3), expected: []interface{}{1, 2} },
     { actual: candidate(63), expected: []interface{}{6, 8} },
     { actual: candidate(25), expected: []interface{}{5, 6} },
     { actual: candidate(19), expected: []interface{}{4, 6} },
     { actual: candidate(9), expected: []interface{}{4, 5} },
     { actual: candidate(1), expected: []interface{}{0, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_108,ewe_Latn,go_test.go,"package count_nums_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me, -123 ƒe dzesi nye -1, 2, kple 3. //Ne xexlẽdzesi aɖe nye vɔ̃ la, ekema eƒe xexlẽdzesi gbãtɔ si dzi woŋlɔ eƒe ŋkɔ ɖo la anye vɔ̃: //element siwo ƒe xexlẽme ƒe xexlẽme ƒe xexlẽme le > 0. //Ŋlɔ dɔdeasi count_nums si xɔa xexlẽdzesi blibowo ƒe ŋkɔ eye wòtrɔna // >>> count_nums([]int{})
// 0
// >>> count_nums([]int{-1, 11, -11})
// 1
// >>> count_nums([]int{1, 1, 2})
// 3
func count_nums(arr []int) int {
","package count_nums_test

import (
    ""testing""
    ""fmt""
)

func count_nums(arr []int) int {
    count := 0
    for _, num := range arr {
        digits := num
        sum := 0

        if digits < 0 {
            sum = digits % 10
            digits = -digits / 10
        }

        for digits > 0 {
            sum += digits % 10
            digits /= 10
        }

        if sum > 0 {
            count++
        }
    }
    return count
}

func TestCountNums(t *testing.T) {
    testCases := []struct {
        input    []int
        expected int
    }{
        {[]int{}, 0},
        {[]int{-1, 11, -11}, 1},
        {[]int{1, 1, 2}, 3},
    }

    for _, tc := range testCases {
        result := count_nums(tc.input)
        if result != tc.expected {
            t.Errorf(""Expected %v, got %v"", tc.expected, result)
        }
    }
}

func main() {
    fmt.Println(count_nums([]int{-1, 11, -11})) // Output: 1
    fmt.Println(count_nums([]int{1, 1, 2}))    // Output: 3
}","func TestCount_Nums(t *testing.T) {
  candidate := count_nums
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{}), expected: 0 },
     { actual: candidate([]int{-1, -2, 0}), expected: 0 },
     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },
     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },
     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },
     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },
     { actual: candidate([]int{0, 1}), expected: 1 },
     { actual: candidate([]int{1}), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_109,ewe_Latn,go_test.go,"package move_one_ball_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //De dzesii: Woka ɖe edzi be nu siwo le ŋkɔ siwo woyɔ me la nye etɔxɛ.//Ne ŋkɔa megale nuŋɔŋlɔa me o la, ekema trɔna yia true. //ekema trɔ true alo trɔ false. //Ne anya wɔ be woaŋlɔ ŋkɔ siwo woɖɔ ɖo la ɖe ɖoɖo si dzi míedzro la nu //enye 0-ŋkɔ si dze le nuŋlɔɖia me.//Woatrɔ ŋkɔ mamlɛtɔ si le nuŋlɔɖia me la ayi //Ne míetsɔ nu ɖeka yi ɖusime la, efia be míatsɔ nu ɖeka yi ɖusime.//Woɖe mɔ na wò be nàwɔ ɖusimeyiyi ƒe dɔwɔwɔ zi alesi nèdi.//dɔ si gbɔna le ŋkɔ siwo le eme la me: //woate ŋu awɔ ɖoɖo ɖe nu siwo mele tsɔtsɔm o ŋu to //Woadzra xexlẽdzesi siwo le nyatakakadzraɖoƒea la ɖo le ɖoɖo nu.//Míekpɔ 'arr' ƒe xexlẽdzesi siwo nye N siwo nye arr[1], arr[2], ..., arr[N].// >>> move_one_ball([]int{3, 4, 5, 1, 2})
// true
// Explanation: By performin 2 right shift operations, non-decreasing order can
// be achieved for the given list.
// >>> move_one_ball([]int{3, 5, 4, 1, 2})
// false
// Explanation:It is not possible to get non-decreasing order for the given
// list by performing any number of right shift operations.
func move_one_ball(arr []int) bool {
","func move_one_ball(arr []int) bool {
    n := len(arr)
    if n == 0 {
        return true
    }

    // Detect the point where the order breaks
    countBreaks := 0
    index := -1

    for i := 0; i < n; i++ {
        if arr[i] > arr[(i+1)%n] {
            countBreaks++
            index = i
        }
    }

    // If there is at most one point where the order breaks
    if countBreaks <= 1 {
        return true
    }

    return false
}","func TestMove_One_Ball(t *testing.T) {
  candidate := move_one_ball
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },
     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },
     { actual: candidate([]int{4, 3, 1, 2}), expected: false },
     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },
     { actual: candidate([]int{}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_110,ewe_Latn,go_test.go,"package exchange_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Ne menye nenema o la, ɖo ""AO"". //Ne lst1 ƒe nuŋɔŋlɔawo katã nye eve la, ɖo ""YES"" ŋu.//Ne woate ŋu atrɔ asi le nu siwo le lst1 kple lst2 dome ŋu la,//Mome ɖe nu siwo woate ŋu atsɔ aɖo teƒea le lst1 kple lst2 dome la dzi o. //Wowɔe be xexlẽdzesi eve koe le lst1 me.//Eye wòdzroa eme be woate ŋu awɔ nuŋɔŋlɔawo ƒe tɔtrɔ //Le kuxi sia me la, àwɔ dɔ si xɔa xexlẽdzesi eve, // >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})
// ""YES""
// >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})
// ""NO""
// It is assumed that the input lists will be non-empty.
func exchange(lst1 []int, lst2 []int) string {
","func exchange(lst1 []int, lst2 []int) string {
    hasEvenInLst2 := false
    
    for _, num := range lst2 {
        if num%2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasEvenInLst2 {
        return ""NO""
    }
    
    for _, num := range lst1 {
        if num%2 != 0 {
            return ""YES""
        }
    }

    return ""YES""
}","func TestExchange(t *testing.T) {
  candidate := exchange
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: ""YES"" },
     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: ""NO"" },
     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: ""YES"" },
     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: ""YES"" },
     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: ""NO"" },
     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: ""NO"" },
     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: ""YES"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_111,ewe_Latn,go_test.go,"package histogram_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Ne ŋɔŋlɔdzesi geɖe dze le teƒe ɖeka la, gbugbɔ wo katã ɖo.//Eŋɔŋlɔdzesi si gbugbɔgagblɔ sɔ gbɔ wu eye wòyɔ xexlẽme si sɔ kplii. //Ne wotsɔ nyagbe aɖe si nye nya siwo wotsɔ nuŋɔŋlɔdzesi suewo ɖe vovo fia la, trɔ asi le anyigbatata ŋu // >>> histogram(""a b c"")
// map[string]int{""a"": 1, ""b"": 1, ""c"": 1}
// >>> histogram(""a b b a"")
// map[string]int{""a"": 2, ""b"": 2}
// >>> histogram(""a b c a b"")
// map[string]int{""a"": 2, ""b"": 2}
// >>> histogram(""b b b b a"")
// map[string]int{""b"": 4}
// >>> histogram("""")
// map[string]int{}
func histogram(test string) map[string]int {
","package histogram_test

import (
    ""strings""
)

func histogram(test string) map[string]int {
    if test == """" {
        return map[string]int{}
    }

    counts := make(map[string]int)
    words := strings.Fields(test)
    
    var maxCount int
    for _, word := range words {
        counts[word]++
        if counts[word] > maxCount {
            maxCount = counts[word]
        }
    }

    result := make(map[string]int)
    for key, count := range counts {
        if count == maxCount {
            result[key] = count
        }
    }

    return result
}","func TestHistogram(t *testing.T) {
  candidate := histogram
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""a b b a""), expected: map[string]int{""a"": 2, ""b"": 2} },
     { actual: candidate(""a b c a b""), expected: map[string]int{""a"": 2, ""b"": 2} },
     { actual: candidate(""a b c d g""), expected: map[string]int{""a"": 1, ""b"": 1, ""c"": 1, ""d"": 1, ""g"": 1} },
     { actual: candidate(""r t g""), expected: map[string]int{""r"": 1, ""t"": 1, ""g"": 1} },
     { actual: candidate(""b b b b a""), expected: map[string]int{""b"": 4} },
     { actual: candidate(""r t g""), expected: map[string]int{""r"": 1, ""t"": 1, ""g"": 1} },
     { actual: candidate(""""), expected: map[string]int{} },
     { actual: candidate(""a""), expected: map[string]int{""a"": 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_112,ewe_Latn,go_test.go,"package reverse_delete_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu //Ele be nàɖo nyatakaka siwo me nu siwo nàkpɔ la ƒe xexlẽdzesi kple true/false le la ɖa.//Ne woxlẽa nya siwo le ŋgɔ kple esiwo le megbe la le ɖeka la, woyɔnɛ be palindrome. //ekema kpɔ be nu si do tso eme nye palindrome hã. //Míexɔ nyagbe eve siwo nye s kple c, ele be míaɖe ŋɔŋlɔdzesi siwo katã le s me siwo sɔ kple ŋɔŋlɔdzesi siwo le c me la ɖa.//Dɔdasi // >>> reverse_delete(""abcde"", ""ae"")
// []interface{}{""bcd"", false}
// >>> reverse_delete(""abcdef"", ""b"")
// []interface{}{""acdef"", false}
// >>> reverse_delete(""abcdedcba"", ""ab"")
// []interface{}{""cdedc"", true}
func reverse_delete(s string, c string) []interface{} {
","func reverse_delete(s string, c string) []interface{} {
    // Create a map to store the characters to be deleted
    deleteMap := make(map[rune]bool)
    for _, ch := range c {
        deleteMap[ch] = true
    }
    
    // Filter the string s by removing characters present in deleteMap
    var filteredString []rune
    for _, ch := range s {
        if !deleteMap[ch] {
            filteredString = append(filteredString, ch)
        }
    }
    
    // Check if the filtered string is a palindrome
    n := len(filteredString)
    isPalindrome := true
    for i := 0; i < n/2; i++ {
        if filteredString[i] != filteredString[n-1-i] {
            isPalindrome = false
            break
        }
    }
    
    // Convert filteredString to a string and prepare result
    resultString := string(filteredString)
    return []interface{}{resultString, isPalindrome}
}","func TestReverse_Delete(t *testing.T) {
  candidate := reverse_delete
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""abcde"", ""ae""), expected: []interface{}{""bcd"", false} },
     { actual: candidate(""abcdef"", ""b""), expected: []interface{}{""acdef"", false} },
     { actual: candidate(""abcdedcba"", ""ab""), expected: []interface{}{""cdedc"", true} },
     { actual: candidate(""dwik"", ""w""), expected: []interface{}{""dik"", false} },
     { actual: candidate(""a"", ""a""), expected: []interface{}{"""", true} },
     { actual: candidate(""abcdedcba"", """"), expected: []interface{}{""abcdedcba"", true} },
     { actual: candidate(""abcdedcba"", ""v""), expected: []interface{}{""abcdedcba"", true} },
     { actual: candidate(""vabba"", ""v""), expected: []interface{}{""abba"", true} },
     { actual: candidate(""mamma"", ""mia""), expected: []interface{}{"""", true} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_113,ewe_Latn,go_test.go,"package odd_count_test

import (
    ""testing""
    ""fmt""
)

//Le numegbe si nye i'th me la, xexlẽdzesi siwo nye ɖeka kple eve ƒe xexlẽdzesi siwo nye ɖeka kple eve la le nu si wotsɔ de eme la me.//"" afi si woatsɔe xexlẽdzesi si nye  aɖo i ɖesiaɖe teƒee.//Ele be nu si me wodzɔ le la ƒe akpa si nye i nanye ""nu siwo me womedzɔ le o ƒe xexlẽme le akpa si nye //Ne èna wo xlẽa xexlẽdzesi siwo me xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi siwo nye xexlẽdzesi.// >>> odd_count([]string{""1234567""})
// []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""}
// >>> odd_count([]string{""3"", ""11111111""})
// []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""}
func odd_count(lst []string) []string {
","package odd_count_test

import (
	""fmt""
	""testing""
)

func odd_count(lst []string) []string {
	result := []string{}
	for _, str := range lst {
		oddCount := 0
		for _, char := range str {
			if char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {
				oddCount++
			}
		}
		output := fmt.Sprintf(""the number of odd elements %dn the str%1ng %d of the %dnput."", oddCount, oddCount, oddCount)
		result = append(result, output)
	}
	return result
}

func TestOddCount(t *testing.T) {
	tests := []struct {
		input    []string
		expected []string
	}{
		{[]string{""1234567""}, []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""}},
		{[]string{""3"", ""11111111""}, []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""}},
	}

	for _, test := range tests {
		if result := odd_count(test.input); !equals(result, test.expected) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
		}
	}
}

func equals(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestOdd_Count(t *testing.T) {
  candidate := odd_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""1234567""}), expected: []string{""the number of odd elements 4n the str4ng 4 of the 4nput.""} },
     { actual: candidate([]string{""3"", ""11111111""}), expected: []string{""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""} },
     { actual: candidate([]string{""271"", ""137"", ""314""}), expected: []string{""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_114,ewe_Latn,go_test.go,"package minSubArraySum_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu //le numegbe me.//Ne èkpɔ xexlẽdzesi blibowo ƒe xexlẽdzesi la, ke kpɔ xexlẽdzesi siwo mele ƒuƒlu o ƒe xexlẽdzesi suetɔ kekeake ƒe xexlẽdzesi // >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})
// 1
// >>> minSubArraySum([]int{-1, -2, -3})
// -6
func minSubArraySum(nums []int) int {
","if len(nums) == 0 {
        return 0
    }
    
    minEndingHere := nums[0]
    minSoFar := nums[0]

    for _, num := range nums[1:] {
        if minEndingHere > 0 {
            minEndingHere = num
        } else {
            minEndingHere += num
        }
        
        if minEndingHere < minSoFar {
            minSoFar = minEndingHere
        }
    }
    
    return minSoFar
}","func TestMinsubarraysum(t *testing.T) {
  candidate := minSubArraySum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },
     { actual: candidate([]int{-1, -2, -3}), expected: -6 },
     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },
     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },
     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },
     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },
     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },
     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },
     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },
     { actual: candidate([]int{-10}), expected: -10 },
     { actual: candidate([]int{7}), expected: 7 },
     { actual: candidate([]int{1, -1}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_115,ewe_Latn,go_test.go,"package max_fill_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu 1: //Ŋlɔ zi nenie nàdi be yeado kpoawo la ɖe anyi.//Wò dɔe nye be nàtsɔ agbawo la aɖi vudoawo.//eye agba siawo katã ƒe agbɔsɔsɔ sɔ.//Kpui aɖe le vudo ɖe sia ɖe me si woate ŋu azã atsɔ aku tsi le eme, //eye 1 ɖesiaɖe si le fli me fiaa tsi ƒe agbɔsɔsɔ ɖeka. //Wotsɔ dowo ƒe xadzidzenu si ƒe dzogoe le dzogoe ene la na wò.// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)
// 6
// Example 2:
// >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)
// 5
// Example 3:
// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)
// 0
// Constraints:
// * all wells have the same length
// * 1 <= grid.length <= 10^2
// * 1 <= grid[:,1].length <= 10^2
// * grid[i][j] -> 0 | 1
// * 1 <= capacity <= 10
func max_fill(grid [][]int, capacity int) int {
","package max_fill_test

import (
    ""testing""
    ""fmt""
)

func max_fill(grid [][]int, capacity int) int {
    totalLowerings := 0

    for _, row := range grid {
        waterInRow := 0
        
        for _, cell := range row {
            if cell == 1 {
                waterInRow++
            }
        }

        totalLowerings += (waterInRow + capacity - 1) / capacity
    }

    return totalLowerings
}

func TestMaxFill(t *testing.T) {
    tests := []struct {
        grid     [][]int
        capacity int
        expected int
    }{
        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},
        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},
        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},
    }

    for _, test := range tests {
        result := max_fill(test.grid, test.capacity)
        if result != test.expected {
            t.Errorf(""For grid %v with capacity %d, expected %d but got %d"", test.grid, test.capacity, test.expected, result)
        }
    }
}

func main() {
    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) // Output: 6
    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) // Output: 5
    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) // Output: 0
}","func TestMax_Fill(t *testing.T) {
  candidate := max_fill
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },
     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },
     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },
     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },
     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_116,ewe_Latn,go_test.go,"package sort_array_test

import (
    ""testing""
    ""fmt""
)

//Ele be woawɔe alea: //Ne ame ɖeka ƒe xexlẽme sɔ la, ekema nɔ te ɖe xexlẽme si le teƒe ewo dzi.//ame ɖeka ƒe xexlẽme le woƒe xexlẽdzesi eve ƒe xexlẽdzesi si le dzidzim ɖe edzi me. //Le Kata sia me la, ele be nàɖɔli xexlẽdzesi siwo menye ameŋkumenu o la le ɖoɖo si nu // >>> sort_array([]int{1, 5, 2, 3, 4})
// []int{1, 2, 3, 4, 5}
// >>> sort_array([]int{-2, -3, -4, -5, -6})
// []int{-6, -5, -4, -3, -2}
// >>> sort_array([]int{1, 0, 2, 3, 4})
// []int{0, 1, 2, 3, 4}
func sort_array(arr []int) []int {
","package sort_array_test

import (
    ""sort""
)

func sort_array(arr []int) []int {
    sort.Slice(arr, func(i, j int) bool {
        countOnes := func(x int) int {
            count := 0
            for x != 0 {
                count += x & 1
                x >>= 1
            }
            return count
        }

        countI := countOnes(arr[i])
        countJ := countOnes(arr[j])

        if countI == countJ {
            return arr[i] < arr[j]
        }
        return countI < countJ
    })
    return arr
}","func TestSort_Array(t *testing.T) {
  candidate := sort_array
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },
     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },
     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },
     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },
     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },
     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_117,ewe_Latn,go_test.go,"package select_words_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //De dzesii: àte ŋu abu be ŋɔŋlɔdzesi kple teƒewo koe le nyagbe si nètsɔ de eme la me.//Ne nyagbe s mele ɖeke me o la, ke ele be dɔdzesia nagbugbɔ ŋkɔ si me ɖeke mele o la ana. //n gbeɖiɖiwo, le ɖoɖo si nu nya siawo dze le gbeɖiɖi s me. //enye dɔwɔwɔ si gbugbɔna nya siwo katã le string s me siwo me nya  tututu le la ƒe ŋkɔwo ƒoa ƒu.//Ne wotsɔ string s kple natural number n na wò la, wobia tso asiwò be nàwɔ // >>> select_words(""Mary had a little lamb"", 4)
// []string{""little""}
// >>> select_words(""Mary had a little lamb"", 3)
// []string{""Mary"", ""lamb""}
// >>> select_words(""simple white space"", 2)
// []string{}
// >>> select_words(""Hello world"", 4)
// []string{""world""}
// >>> select_words(""Uncle sam"", 3)
// []string{""Uncle""}
func select_words(s string, n int) []string {
","package select_words_test

import (
	""strings""
	""testing""
)

func select_words(s string, n int) []string {
	// Define a helper function to check if a character is a consonant.
	isConsonant := func(c rune) bool {
		c = rune(strings.ToLower(string(c))[0])
		return c >= 'a' && c <= 'z' && !strings.ContainsRune(""aeiou"", c)
	}

	// Split the string into words.
	words := strings.Fields(s)
	var result []string

	// Iterate over each word.
	for _, word := range words {
		consonantCount := 0
		// Count the consonants in the word.
		for _, char := range word {
			if isConsonant(char) {
				consonantCount++
			}
		}
		// If the number of consonants matches n, add the word to the result.
		if consonantCount == n {
			result = append(result, word)
		}
	}

	return result
}

func TestSelectWords(t *testing.T) {
	testCases := []struct {
		s        string
		n        int
		expected []string
	}{
		{""Mary had a little lamb"", 4, []string{""little""}},
		{""Mary had a little lamb"", 3, []string{""Mary"", ""lamb""}},
		{""simple white space"", 2, []string{}},
		{""Hello world"", 4, []string{""world""}},
		{""Uncle sam"", 3, []string{""Uncle""}},
	}

	for _, testCase := range testCases {
		result := select_words(testCase.s, testCase.n)
		if !equal(result, testCase.expected) {
			t.Errorf(""For input '%s' with n=%d, expected %v, but got %v"", testCase.s, testCase.n, testCase.expected, result)
		}
	}
}

func equal(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestSelect_Words(t *testing.T) {
  candidate := select_words
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Mary had a little lamb"", 4), expected: []string{""little""} },
     { actual: candidate(""Mary had a little lamb"", 3), expected: []string{""Mary"", ""lamb""} },
     { actual: candidate(""simple white space"", 2), expected: []string{} },
     { actual: candidate(""Hello world"", 4), expected: []string{""world""} },
     { actual: candidate(""Uncle sam"", 3), expected: []string{""Uncle""} },
     { actual: candidate("""", 4), expected: []string{} },
     { actual: candidate(""a b c d e f"", 1), expected: []string{""b"", ""c"", ""d"", ""f""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_118,ewe_Latn,go_test.go,"package get_closest_vowel_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Àte ŋu abui be Eŋlisigbe me ŋɔŋlɔdzesi koe le nyagbe si wotsɔ ɖo la me. //kpɔ gbeɖegbe aɖe si ɖo nɔnɔme si le etame la gbɔ.//Gbeɖegbeɖiɖi siwo le gɔmedzedze kple nuwuwu la mele xexlẽ me o. Ne mèwɔe o la, trɔ kpe ƒuƒlu la ɖo.//dzesideŋkɔ eve tso nya la ƒe ɖusime (woaɖɔa nya gã kple suewo me). //Woɖo nya aɖe ɖe wò. Wò dɔe nye be nàkpɔ gbeɖiɖi si tsɔ ɖe eŋu wu si le wo dome.// >>> get_closest_vowel(""yogurt"")
// ""u""
// >>> get_closest_vowel(""FULL"")
// ""U""
// >>> get_closest_vowel(""quick"")
// """"
// >>> get_closest_vowel(""ab"")
// """"
func get_closest_vowel(word string) string {
","package get_closest_vowel_test

import (
    ""testing""
    ""fmt""
)

func get_closest_vowel(word string) string {
    vowels := ""aeiouAEIOU""
    isVowel := make(map[rune]bool)
    for _, v := range vowels {
        isVowel[v] = true
    }
    
    n := len(word)
    for i := n-2; i > 0; i-- {
        if isVowel[rune(word[i])] && 
           !isVowel[rune(word[i-1])] && 
           !isVowel[rune(word[i+1])] {
            return string(word[i])
        }
    }
    return """"
}

// Test functions
func TestGetClosestVowel(t *testing.T) {
    var tests = []struct {
        input    string
        expected string
    }{
        {""yogurt"", ""u""},
        {""FULL"", ""U""},
        {""quick"", """"},
        {""ab"", """"},
    }
    
    for _, test := range tests {
        result := get_closest_vowel(test.input)
        if result != test.expected {
            t.Errorf(""get_closest_vowel(%q) = %q; want %q"", test.input, result, test.expected)
        }
    }
}

func main() {
    fmt.Println(get_closest_vowel(""yogurt"")) // Output: ""u""
    fmt.Println(get_closest_vowel(""FULL""))   // Output: ""U""
    fmt.Println(get_closest_vowel(""quick""))  // Output: """"
    fmt.Println(get_closest_vowel(""ab""))     // Output: """"
}","func TestGet_Closest_Vowel(t *testing.T) {
  candidate := get_closest_vowel
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""yogurt""), expected: ""u"" },
     { actual: candidate(""full""), expected: ""u"" },
     { actual: candidate(""easy""), expected: """" },
     { actual: candidate(""eAsy""), expected: """" },
     { actual: candidate(""ali""), expected: """" },
     { actual: candidate(""bad""), expected: ""a"" },
     { actual: candidate(""most""), expected: ""o"" },
     { actual: candidate(""ab""), expected: """" },
     { actual: candidate(""ba""), expected: """" },
     { actual: candidate(""quick""), expected: """" },
     { actual: candidate(""anime""), expected: ""i"" },
     { actual: candidate(""Asia""), expected: """" },
     { actual: candidate(""Above""), expected: ""o"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_119,ewe_Latn,go_test.go,"package match_parens_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ne mɔ aɖe li si dzi míato awɔ nyaƒoka nyui aɖe la, ekema 'Ɛ̃' ye míatsɔ aɖo eŋu, eye ne mɔ bubu aɖe li la, míatsɔ 'Ao' aɖo eŋu. //"" (()) "" mele eme o. //Le kpɔɖeŋu me: string '(())))' nyo, eye string //Wobua ƒokpli S be enye nyui ne eye ne ƒokpli siwo katã le S me la nye nyui ko.//Ne èwɔ ɖoɖo aɖe la, ekema nya siwo nàgblɔ la adze nyuie.//Wò dɔe nye be nàkpɔe ɖa be àte ŋu atsɔ ka eveawo aƒo ƒu ɖekae hã.//le akpaa dzi "" (("" alo akpaa dzi "") "" ko.//Wona ŋkɔ siwo le ƒuƒoƒo eve me wò, eye wo ame evea siaa nye ƒuƒoƒo si me woʋu le.// >>> match_parens([]string{""()("", "")""})
// ""Yes""
// >>> match_parens([]string{"")"", "")""})
// ""No""
func match_parens(lst []string) string {
","func match_parens(lst []string) string {
	left1, right1 := countParens(lst[0])
	left2, right2 := countParens(lst[1])

	if left1+left2 == right1+right2 {
		return ""Yes""
	}

	if left1-right1+left2-right2 == 0 {
		return ""Yes""
	}

	return ""No""
}

func countParens(s string) (left int, right int) {
	for _, c := range s {
		if c == '(' {
			left++
		} else if c == ')' {
			right++
		}
	}
	return
}

func TestMatchParens(t *testing.T) {
	tests := []struct {
		input    []string
		expected string
	}{
		{[]string{""()("", "")""}, ""Yes""},
		{[]string{"")"", "")""}, ""No""},
		{[]string{""((("", "")))""}, ""Yes""},
		{[]string{""("", "")""}, ""Yes""},
		{[]string{""))("", ""(""}, ""No""},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""%v"", test.input), func(t *testing.T) {
			if got := match_parens(test.input); got != test.expected {
				t.Errorf(""match_parens(%v) = %v; want %v"", test.input, got, test.expected)
			}
		})
	}
}","func TestMatch_Parens(t *testing.T) {
  candidate := match_parens
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""()("", "")""}), expected: ""Yes"" },
     { actual: candidate([]string{"")"", "")""}), expected: ""No"" },
     { actual: candidate([]string{""(()(())"", ""())())""}), expected: ""No"" },
     { actual: candidate([]string{"")())"", ""(()()(""}), expected: ""Yes"" },
     { actual: candidate([]string{""(())))"", ""(()())((""}), expected: ""Yes"" },
     { actual: candidate([]string{""()"", ""())""}), expected: ""No"" },
     { actual: candidate([]string{""(()("", ""()))()""}), expected: ""Yes"" },
     { actual: candidate([]string{""(((("", ""((())""}), expected: ""No"" },
     { actual: candidate([]string{"")(()"", ""(()(""}), expected: ""No"" },
     { actual: candidate([]string{"")("", "")(""}), expected: ""No"" },
     { actual: candidate([]string{""("", "")""}), expected: ""Yes"" },
     { actual: candidate([]string{"")"", ""(""}), expected: ""Yes"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_120,ewe_Latn,go_test.go,"package maximum_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu 1: //le didime k kple xexlẽdzesi k le arr me. //Ne ameƒomevi blibowo ƒe xexlẽdzesi arr kple xexlẽdzesi blibo k le esi la, trɔna ŋkɔ siwo woɖɔ ɖo // >>> maximum([]int{-3, -4, 5}, 3)
// []int{-4, -3, 5}
// Example 2:
// >>> maximum([]int{4, -4, 4}, 2)
// []int{4, 4}
// Example 3:
// >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)
// []int{2}
// Note:
// 1. The length of the list will be in the range of [1, 1000].
// 2. The elements in the list will be in the range of [-1000, 1000].
// 3. 0 <= k <= len(arr)
func maximum(arr []int, k int) []int {
","package maximum_test

import (
    ""sort""
)

func maximum(arr []int, k int) []int {
    if k == 0 {
        return []int{}
    }
    
    // Sort the array
    sort.Ints(arr)
    
    // Get the last k elements, which are the largest
    return arr[len(arr)-k:]
}","func TestMaximum(t *testing.T) {
  candidate := maximum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },
     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },
     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },
     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },
     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },
     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },
     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },
     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },
     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },
     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },
     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_121,ewe_Latn,go_test.go,"package solution_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //Ne míetsɔ xexlẽdzesi siwo menye ƒuƒlu o na la, míana xexlẽdzesi siwo katã le teƒe ɖeka la ƒe xexlẽdzesi ɖeka.// >>> solution([]int{5, 8, 7, 1})
// 12
// >>> solution([]int{3, 3, 3, 3, 3})
// 9
// >>> solution([]int{30, 13, 24, 321})
// 0
func solution(lst []int) int {
","sum := 0
    for i := 0; i < len(lst); i++ {
        if i%2 == 0 && lst[i]%2 != 0 {
            sum += lst[i]
        }
    }
    return sum
}","func TestSolution(t *testing.T) {
  candidate := solution
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },
     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },
     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },
     { actual: candidate([]int{5, 9}), expected: 5 },
     { actual: candidate([]int{2, 4, 8}), expected: 0 },
     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },
     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_122,ewe_Latn,go_test.go,"package add_elements_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //enye arr ƒe akpa siwo ƒe xexlẽdzesi ƒe xexlẽdzesi nye k gbãtɔwo ƒe xexlẽdzesi siwo ƒe xexlẽdzesi ƒe xexlẽdzesi nye xexlẽdzesi eve ƒe xexlẽdzesi. //Ne ameƒomevi siwo menye ƒuƒluwo o ƒe ŋkɔwo le ameƒomevi siwo nye arr kple ameƒomevi k la, trɔ // >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)
// 24
// Constraints:
// 1. 1 <= len(arr) <= 100
// 2. 1 <= k <= len(arr)
func add_elements(arr []int, k int) int {
","func add_elements(arr []int, k int) int {
    sum := 0
    for i := 0; i < k; i++ {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","func TestAdd_Elements(t *testing.T) {
  candidate := add_elements
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },
     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },
     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },
     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },
     { actual: candidate([]int{1}, 1), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_123,ewe_Latn,go_test.go,"package get_odd_collatz_test

import (
    ""testing""
    ""fmt""
)

//get_odd_collatz(5) trɔna [1, 5] # Collatz ƒe ɖoɖo na 5 nye [5, 16, 8, 4, 2, 1], eyata xexlẽdzesi siwo nye ɖeka kple atɔ̃ koe nye ɖeka. //Le kpɔɖeŋu me: //2. woɖɔli ŋkɔ siwo woxɔ la ɖe ɖoɖo si dzi wozi ɖo dzi. //1. Collatz(1) nye [1]. //De dzesii: //Woƒe susue nye be, eɖanye n ƒe asixɔxɔ ka kee o, nu siwo le ɖoɖo nu la katã ade 1 ya.//Ne enye eve la, ke etɔ̃ enye etɔ̃.//Ne nuŋɔŋlɔa nye eve la, nuŋɔŋlɔ si kplɔe ɖo anye afã le //le mɔ sia nu: dze egɔme kple xexlẽdzesi blibo si nye n. Emegbe woɖea xexlẽdzesi ɖesiaɖe tsoa  me.//Collatz ƒe susua nye susua le akɔntabubu me si ku ɖe ɖoɖo aɖe si ŋu woƒo nu tsoe la ŋu.//Ne wotsɔ xexlẽdzesi blibo si nye n na la, trɔna xexlẽdzesi siwo le ɖoɖo nu si me xexlẽdzesi siwo nye ɖeka le le ɖoɖo nu.// >>> get_odd_collatz(5)
// []int{1, 5}
func get_odd_collatz(n int) []int {
","package get_odd_collatz_test

import (
    ""sort""
)

func get_odd_collatz(n int) []int {
    oddNumbers := make(map[int]bool)

    for n != 1 {
        if n%2 != 0 {
            oddNumbers[n] = true
        }
        if n%2 == 0 {
            n /= 2
        } else {
            n = 3*n + 1
        }
    }

    // Add 1 to the set of odd numbers because the sequence always ends at 1
    oddNumbers[1] = true

    // Extract the keys, which represent the odd numbers
    result := make([]int, 0, len(oddNumbers))
    for num := range oddNumbers {
        result = append(result, num)
    }

    // Sort the result
    sort.Ints(result)

    return result
}","func TestGet_Odd_Collatz(t *testing.T) {
  candidate := get_odd_collatz
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },
     { actual: candidate(5), expected: []int{1, 5} },
     { actual: candidate(12), expected: []int{1, 3, 5} },
     { actual: candidate(1), expected: []int{1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_124,ewe_Latn,go_test.go,"package valid_date_test

import (
    ""testing""
    ""fmt""
)

//4. Ŋkekea nanɔ ale: mm-dd-yyyy //3. Ɣletiawo mele be woanɔ sue wu 1 alo kɔkɔ wu 12 o.//Ŋkekewo ƒe xexlẽme mele sue wu 1 alo lolo wu 31 le ɣleti 1,3,5,7,8,10,12 me o, eye ŋkekewo ƒe xexlẽme mele sue wu 1 alo lolo wu 30 le ɣleti 4,6,9,11 me o. Eye ŋkekewo ƒe xexlẽme mele sue wu 1 alo lolo wu 29 le ɣleti 2 me o.//1. Ŋkekea ƒe xexlẽdzesi la menye ƒuƒlu o.//Ne se siwo gbɔna la katã le eme la, ekema ŋkeke la nye esi sɔ: //trɔna true ne ŋkeke la nye nyateƒe, ne menye nenema o la false. //Ele be nàŋlɔ dɔ si ana woabu akɔnta le ŋkeke kple ŋkeke ƒe xexlẽdzesi aɖe ŋu eye // >>> valid_date(""03-11-2000"")
// true
// >>> valid_date(""15-01-2012"")
// false
// >>> valid_date(""04-0-2040"")
// false
// >>> valid_date(""06-04-2020"")
// true
// >>> valid_date(""06/04/2020"")
// false
func valid_date(date string) bool {
","func valid_date(date string) bool {
    if len(date) == 0 {
        return false
    }

    var month, day, year int
    n, err := fmt.Sscanf(date, ""%02d-%02d-%04d"", &month, &day, &year)

    if err != nil || n != 3 {
        return false
    }

    if month < 1 || month > 12 {
        return false
    }

    if month == 2 {
        if day < 1 || day > 29 {
            return false
        }
    } else if month == 4 || month == 6 || month == 9 || month == 11 {
        if day < 1 || day > 30 {
            return false
        }
    } else {
        if day < 1 || day > 31 {
            return false
        }
    }

    return true
}","func TestValid_Date(t *testing.T) {
  candidate := valid_date
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""03-11-2000""), expected: true },
     { actual: candidate(""15-01-2012""), expected: false },
     { actual: candidate(""04-0-2040""), expected: false },
     { actual: candidate(""06-04-2020""), expected: true },
     { actual: candidate(""01-01-2007""), expected: true },
     { actual: candidate(""03-32-2011""), expected: false },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""04-31-3000""), expected: false },
     { actual: candidate(""06-06-2005""), expected: true },
     { actual: candidate(""21-31-2000""), expected: false },
     { actual: candidate(""04-12-2003""), expected: true },
     { actual: candidate(""04122003""), expected: false },
     { actual: candidate(""20030412""), expected: false },
     { actual: candidate(""2003-04""), expected: false },
     { actual: candidate(""2003-04-12""), expected: false },
     { actual: candidate(""04-2003""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_126,ewe_Latn,go_test.go,"package is_sorted_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //number, return false. Meka ɖe edzi be xexlẽdzesi manyomanyo aɖeke meli o eye xexlẽdzesi blibowo koe li.//Ne agbalẽ ɖeka me tɔ wu ɖeka la, ekema nàŋlɔe ɖe agbalẽa me //Ne èkpɔ xexlẽdzesiwo ƒe ŋkɔwo le axa aɖe la, trɔ wo ɖe afi ma ne wole ɖoɖo nu loo alo womele ɖoɖo nu o.// >>> is_sorted([]int{5})
// true
// >>> is_sorted([]int{1, 2, 3, 4, 5})
// true
// >>> is_sorted([]int{1, 3, 2, 4, 5})
// false
// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})
// true
// >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})
// true
// >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})
// false
// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})
// true
// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})
// false
func is_sorted(lst []int) bool {
","func is_sorted(lst []int) bool {
    if len(lst) <= 1 {
        return true
    }
    
    duplicateCount := make(map[int]int)

    for i := 0; i < len(lst)-1; i++ {
        if lst[i] > lst[i+1] {
            return false
        }
        duplicateCount[lst[i]]++
        if duplicateCount[lst[i]] > 1 {
            return false
        }
    }
    
    // Check the last element for duplicate
    duplicateCount[lst[len(lst)-1]]++
    if duplicateCount[lst[len(lst)-1]] > 1 {
        return false
    }

    return true
}","func TestIs_Sorted(t *testing.T) {
  candidate := is_sorted
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },
     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },
     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },
     { actual: candidate([]int{}), expected: true },
     { actual: candidate([]int{1}), expected: true },
     { actual: candidate([]int{3, 2, 1}), expected: false },
     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },
     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },
     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },
     { actual: candidate([]int{1, 2, 3, 4}), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_127,ewe_Latn,go_test.go,"package intersection_test

import (
    ""testing""
    ""fmt""
)

//[Dɔwɔƒe si me woxɔa agbalẽwo le] ƒe kpɔɖeŋuwo: //Ne nu eveawo mewɔ ɖeka o la, gbugbɔ ɖo ""AO"".//Ne menye nenema o la, ɖo ""AO"". //Ne nutome sue aɖe ƒe didime nye xexlẽdzesi gbãtɔ la, ɖo ""YES""//si ƒe didime nye 1, si menye xexlẽdzesi gbãtɔ o.//Le kpɔɖeŋu me, nu siwo le (1, 3), (2, 4) dome ƒe kpuiƒee nye (2, 3) //enye xexlẽdzesi gbãtɔ.//Wò dɔe nye be nànya ne nu eve siawo ƒe didime le teƒe ɖeka.//Le ɣeyiɣi aɖe ƒe didime ɖesiaɖe gome la, wobunɛ be eƒe gɔmedzedze le sue wu alo sɔ kple eƒe nuwuwu.//Eƒo nu tso gɔmedzedze kple nuwuwu siaa ŋu. //Woxe mɔ na ɣeyiɣi siwo le eme, si fia be ɣeyiɣi si (dze egɔme, eye wòwu enu) //le afisia la, xexlẽdzesi blibo evee nyea ɣeyiɣi ɖesiaɖe. Le kpɔɖeŋu me, ɣeyiɣi = (tititi, nuwuwu) = (1, 2).//Woɖo ɣeyiɣi eve na wò, // >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})
// ""NO""
// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})
// ""NO""
// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})
// ""YES""
func intersection(interval1 []interface{}, interval2 []interface{}) string {
","package intersection_test

import (
	""testing""
)

// Helper function to determine if a number is prime
func isPrime(num int) bool {
	if num <= 1 {
		return false
	}
	if num == 2 {
		return true
	}
	if num%2 == 0 {
		return false
	}
	for i := 3; i*i <= num; i += 2 {
		if num%i == 0 {
			return false
		}
	}
	return true
}

func intersection(interval1 []interface{}, interval2 []interface{}) string {
	start1, end1 := interval1[0].(int), interval1[1].(int)
	start2, end2 := interval2[0].(int), interval2[1].(int)

	// Determine the intersection of two intervals
	intersectStart := max(start1, start2)
	intersectEnd := min(end1, end2)

	if intersectStart > intersectEnd {
		return ""NO""
	}

	// The length of intersection is end - start
	lengthOfIntersection := intersectEnd - intersectStart
	if isPrime(lengthOfIntersection) {
		return ""YES""
	}
	return ""NO""
}

// Helper function to find the maximum of two integers
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// Helper function to find the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func TestIntersection(t *testing.T) {
	if intersection([]interface{}{1, 2}, []interface{}{2, 3}) != ""NO"" {
		t.Error(""Expected NO"")
	}
	if intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != ""NO"" {
		t.Error(""Expected NO"")
	}
	if intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != ""YES"" {
		t.Error(""Expected YES"")
	}
}","func TestIntersection(t *testing.T) {
  candidate := intersection
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: ""NO"" },
     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: ""NO"" },
     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: ""YES"" },
     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: ""YES"" },
     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: ""NO"" },
     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: ""NO"" },
     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: ""NO"" },
     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: ""NO"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_129,ewe_Latn,go_test.go,"package minPath_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Etrɔna na xexlẽdzesi siwo le cell siwo dzi mɔ si dzi wòle be woato la ato la ƒe xexlẽdzesi siwo woɖo ɖoɖo nu. //Míeka ɖe edzi be ŋuɖoɖoa ɖeke mesɔ kple bubu aɖeke o. //lst_A[j] = lst_B[j]. //ale be lst_A[i] < lst_B[i] eye be j (1 <= j < i) la, míakpɔ //wu lst_B, le nya bubuwo me la, xexlẽdzesi blibo ƒe xexlẽdzesi si nye i (1 <= i <= k) li.//(Mina míayɔ wo be lst_A kple lst_B), eye le nyagbewo me la, lst_A nye esi me nyawo mesɔ gbɔ o.//Ne èŋlɔ nu siwo le xɔ siwo nye A kple B me la ɖe ɖoɖo nu vɔ la, àkpɔe be://Wobua mɔ A (si ƒe didime nye k) be ele sue wu mɔ B (si ƒe didime nye k) ne //MÀTE ŋu ado le mɔ̃a dzi o.//(Kpɔ aɖaka si nye "" Nu Siwo Le Vevie"").//De dzesii be mɔ si ƒe didime nye k fia be ele be woazã xɔvi k tututu (menye //Ð Ð Ð Ð Ð Ð Ð Ð Ð¡Ð Ð Ð Ð Ð//le nya bubuwo me la, àte ŋu ayi aɖadi xɔ siwo ƒe mlɔenu le ɖeka kple tɔwò la.//le xɔvi ɖesiaɖe me, eye le afɔɖeɖe ɖesiaɖe me la, àte ŋu ayi xɔvi siwo te ɖe eŋu dometɔ ɖesiaɖe me, //Ele be nàkpɔ mɔ si didi wu k le kadodoa me. Àte ŋu adze egɔme.//inclusive dzena zi ɖeka pɛ ko le xɔ siwo le xɔdzesia me la me. //Numevi blibo ɖesiaɖe si le [1, N * N] dome la nyea xexlẽdzesi.//Ne míetsɔ xadzraɖoƒe si me fli N kple sɔti N le (N >= 2) eye wònye xexlẽdzesi blibo k, // >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)
// []int{1, 2, 1}
// >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)
// []int{1}
func minPath(grid [][]int, k int) []int {
","package minPath_test

import (
    ""sort""
)

func minPath(grid [][]int, k int) []int {
    n := len(grid)
    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}
    
    var dfs func(x, y, length int, path []int)
    var minPath []int
    minPath = make([]int, k)
    for i := 0; i < k; i++ {
        minPath[i] = n*n + 1
    }

    dfs = func(x, y, length int, path []int) {
        if length == k {
            if isLess(path, minPath) {
                copy(minPath, path)
            }
            return
        }
        
        for _, dir := range directions {
            nx, ny := x+dir[0], y+dir[1]
            if nx >= 0 && ny >= 0 && nx < n && ny < n {
                path[length] = grid[nx][ny]
                dfs(nx, ny, length+1, path)
            }
        }
    }
    
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            path := make([]int, k)
            path[0] = grid[i][j]
            dfs(i, j, 1, path)
        }
    }
    
    return minPath
}

func isLess(a, b []int) bool {
    for i := 0; i < len(a); i++ {
        if a[i] < b[i] {
            return true
        }
        if a[i] > b[i] {
            return false
        }
    }
    return false
}","func TestMinpath(t *testing.T) {
  candidate := minPath
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },
     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },
     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },
     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },
     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },
     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },
     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },
     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },
     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },
     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },
     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_130,ewe_Latn,go_test.go,"package tri_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Tribonacci ƒe xexlẽdzesi gbãtɔ n + 1 la. //Ne wotsɔ xexlẽdzesi si menye amebe o, si nye n na wò la, ele be nàtrɔ a ƒe xexlẽdzesi siwo nye //= 2 + 3 + 3 = 8 //tri(3) = tri(2) + tri(1) + tri(4) //tri(4) = 3 //tri(2) = 1 + (2 / 2) = 2 //Le kpɔɖeŋu me: //tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ne n nye ɖeka. //tri (n) = 1 + n / 2, ne n nye eve. //tri(1) = 3 //Wozãa Tribonacci ƒe ɖoɖo sia ƒe tɔtrɔ: //Gake nusi amewo menya o enye Tribonacci ƒe ɖoɖo.//Ame sia ame nya Fibonacci ƒe ɖoɖo, eye akɔntanyalawo srɔ̃e tsitotsito le ƒe // >>> tri(3)
// []int{1, 3, 2, 8}
func tri(n int) []int {
","func tri(n int) []int {
    if n < 0 {
        return []int{}
    }
    sequence := make([]int, n+1)
    sequence[0] = 1 // tri(0) is not defined in problem, let's start with tri(1)
    if n >= 1 {
        sequence[1] = 3
    }
    for i := 2; i <= n; i++ {
        if i%2 == 0 {
            sequence[i] = 1 + i/2
        } else {
            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)
        }
    }
    return sequence
}

func getNextTribonacci(n int) int {
    if n%2 == 0 {
        return 1 + n/2
    }
    return getNextTribonacciRec(n+1)
}

func getNextTribonacciRec(n int) int {
    triNext := make([]int, n+1)
    triNext[0] = 1 // again assuming some base start
    if n >= 1 {
        triNext[1] = 3
    }
    for i := 2; i <= n; i++ {
        if i%2 == 0 {
            triNext[i] = 1 + i/2
        } else {
            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)
        }
    }
    return triNext[n]
}","func TestTri(t *testing.T) {
  candidate := tri
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3), expected: []int{1, 3, 2, 8} },
     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },
     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },
     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },
     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },
     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },
     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },
     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },
     { actual: candidate(0), expected: []int{1} },
     { actual: candidate(1), expected: []int{1, 3} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_131,ewe_Latn,go_test.go,"package digits_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Ne xexlẽdzesi siwo katã le xexlẽdzesi sia me nye eve la, ekema trɔna 0 vɛ. //Ne wotsɔ xexlẽdzesi blibo si nye n na mí la, gbugbɔ xlẽ xexlẽdzesi siwo nye ɖeka ƒe xexlẽdzesi. // >>> digits(1)
// 1
// >>> digits(4)
// 0
// >>> digits(235)
// 15
func digits(n int) int {
","product := 1
    hasOdd := false

    for n > 0 {
        digit := n % 10
        if digit%2 != 0 {
            product *= digit
            hasOdd = true
        }
        n /= 10
    }

    if hasOdd {
        return product
    }
    return 0
}","func TestDigits(t *testing.T) {
  candidate := digits
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 5 },
     { actual: candidate(54), expected: 5 },
     { actual: candidate(120), expected: 1 },
     { actual: candidate(5014), expected: 5 },
     { actual: candidate(98765), expected: 315 },
     { actual: candidate(5576543), expected: 2625 },
     { actual: candidate(2468), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_132,ewe_Latn,go_test.go,"package is_nested_test

import (
    ""testing""
    ""fmt""
)

//ne nuŋɔŋlɔawo dometɔ ɖeka ya teti le akpa si kplɔe ɖo me la, woƒo nu tso wo ŋu.//Ele be dɔwɔwɔa nagbugbɔ true ne eye ne bracketwo ƒe ɖoɖovi si sɔ le eme //Wɔ dɔdeasi aɖe si xɔa nyagbe si me akplowo le ko abe nuŋɔŋlɔ ene.// >>> is_nested(""[[]]"")
// true
// >>> is_nested(""[]]]]]]][[[[[]"")
// false
// >>> is_nested(""[][]"")
// false
// >>> is_nested(""[]"")
// false
// >>> is_nested(""[[][]]"")
// true
// >>> is_nested(""[[]][["")
// true
func is_nested(myString string) bool {
","func is_nested(myString string) bool {
	stack := []rune{}
	nestingFound := false

	for _, char := range myString {
		if char == '[' {
			stack = append(stack, char)
		} else if char == ']' {
			if len(stack) > 0 {
				stack = stack[:len(stack)-1]
				if len(stack) > 0 {
					nestingFound = true
				}
			}
		}
	}

	return nestingFound
}","func TestIs_Nested(t *testing.T) {
  candidate := is_nested
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""[[]]""), expected: true },
     { actual: candidate(""[]]]]]]][[[[[]""), expected: false },
     { actual: candidate(""[][]""), expected: false },
     { actual: candidate(""[]""), expected: false },
     { actual: candidate(""[[[[]]]]""), expected: true },
     { actual: candidate(""[]]]]]]]]]]""), expected: false },
     { actual: candidate(""[][][[]]""), expected: true },
     { actual: candidate(""[[]""), expected: false },
     { actual: candidate(""[]]""), expected: false },
     { actual: candidate(""[[]][[""), expected: true },
     { actual: candidate(""[[][]]""), expected: true },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""[[[[[[[[""), expected: false },
     { actual: candidate(""]]]]]]]]""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_133,ewe_Latn,go_test.go,"package sum_squares_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //ƒo xlã nu siwo le wo dome la katã va ɖo woƒe dziƒoxɔ dzi gbã.//Ele be nàtsɔ xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi siwo le xexlẽdzesi//Woana wò xexlẽdzesiwo ƒe ŋkɔwo.// >>> lst([]float64{1.0, 2.0, 3.0})
// 14
// >>> lst([]float64{1.0, 4.0, 9.0})
// 98
// >>> lst([]float64{1.0, 3.0, 5.0, 7.0})
// 84
// >>> lst([]float64{1.4, 4.2, 0.0})
// 29
// >>> lst([]float64{-2.4, 1.0, 1.0})
// 6
func sum_squares(lst []float64) int {
","package sum_squares_test

import (
	""math""
)

func sum_squares(lst []float64) int {
	sum := 0
	for _, num := range lst {
		ceiledNum := math.Ceil(num)
		sum += int(ceiledNum * ceiledNum)
	}
	return sum
}","func TestSum_Squares(t *testing.T) {
  candidate := sum_squares
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },
     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },
     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },
     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },
     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },
     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },
     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },
     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },
     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },
     { actual: candidate([]float64{0.0}), expected: 0 },
     { actual: candidate([]float64{-1.0}), expected: 1 },
     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_134,ewe_Latn,go_test.go,"package check_if_last_char_is_a_letter_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //De dzesii: ""nya"" nye ŋɔŋlɔdzesi siwo dome nɔƒee ɖe vovo. //enye nya aɖe ƒe akpa aɖe, eye enye aʋatso le go bubu me.//enye alfabeta me ŋɔŋlɔdzesi eye menye  o.//Wɔ dɔdeasi aɖe si trɔna true ne ŋɔŋlɔdzesi mamlɛtɔ // >>> check_if_last_char_is_a_letter(""apple pie"")
// false
// >>> check_if_last_char_is_a_letter(""apple pi e"")
// true
// >>> check_if_last_char_is_a_letter(""apple pi e "")
// false
// >>> check_if_last_char_is_a_letter("""")
// false
func check_if_last_char_is_a_letter(txt string) bool {
","package check_if_last_char_is_a_letter_test

import (
    ""testing""
    ""unicode""
)

func check_if_last_char_is_a_letter(txt string) bool {
    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {
        return false
    }
    
    lastCharIndex := len(txt) - 1
    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {
        lastCharIndex--
    }
    
    if lastCharIndex < 0 {
        return false
    }

    if !unicode.IsLetter(rune(txt[lastCharIndex])) {
        return false
    }
    
    // Check if it's part of a word by looking at the previous character
    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {
        return false
    }

    return true
}

func TestCheckIfLastCharIsALetter(t *testing.T) {
    cases := []struct {
        input    string
        expected bool
    }{
        {""apple pie"", false},
        {""apple pi e"", true},
        {""apple pi e "", false},
        {"""", false},
        {""hello world"", true},
        {""a "", true},
        {"" a"", true},
        {""abc"", false},
        {""abc "", false},
    }

    for _, c := range cases {
        t.Run(c.input, func(t *testing.T) {
            result := check_if_last_char_is_a_letter(c.input)
            if result != c.expected {
                t.Errorf(""Expected %v, got %v for input \""%s\"""", c.expected, result, c.input)
            }
        })
    }
}","func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {
  candidate := check_if_last_char_is_a_letter
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""apple""), expected: false },
     { actual: candidate(""apple pi e""), expected: true },
     { actual: candidate(""eeeee""), expected: false },
     { actual: candidate(""A""), expected: true },
     { actual: candidate(""Pumpkin pie ""), expected: false },
     { actual: candidate(""Pumpkin pie 1""), expected: false },
     { actual: candidate(""""), expected: false },
     { actual: candidate(""eeeee e ""), expected: false },
     { actual: candidate(""apple pie""), expected: false },
     { actual: candidate(""apple pi e ""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_135,ewe_Latn,go_test.go,"package can_arrange_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ð Ð Ð Ð Ð¡Ð Ð Ð Ð¡Ð Ð Ð Ð¡Ð Ð Ð Ð Ð¡Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð Ð//nu sia ƒe ɖeke meli o la, ekema woatrɔe na -1.//menye nu si lolo wu alo sɔ kple nu si do ŋgɔ nɛ la o. Ne //Wɔ dɔdeasi aɖe si ana woabu nu vevi aɖe si ƒe // >>> can_arrange([]int{1, 2, 4, 3, 5})
// 3
// >>> can_arrange([]int{1, 2, 3})
// -1
func can_arrange(arr []int) int {
","package can_arrange_test

func can_arrange(arr []int) int {
    for i := len(arr) - 1; i > 0; i-- {
        if arr[i] < arr[i-1] {
            return i
        }
    }
    return -1
}","func TestCan_Arrange(t *testing.T) {
  candidate := can_arrange
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },
     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },
     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },
     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },
     { actual: candidate([]int{}), expected: -1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_136,ewe_Latn,go_test.go,"package largest_smallest_integers_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Ne ameƒomevi siwo nye negative alo positive mele xexlẽdzesi aɖeke me o la, ekema na woatrɔ azu nil. //le xexlẽdzesi blibo siwo nye dzidzɔnyawo me. //Negative integers ƒe gãtɔ, eye b nye suetɔ //Wɔ dɔdeasi aɖe si ana ŋkɔwo (a, b) si me 'a' nye // >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})
// []interface{}{nil, 1}
// >>> largest_smallest_integers([]int{})
// []interface{}{nil, nil}
// >>> largest_smallest_integers([]int{0})
// []interface{}{nil, nil}
func largest_smallest_integers(lst []int) []interface{} {
","func largest_smallest_integers(lst []int) []interface{} {
    var largestNegative *int
    var smallestPositive *int

    for _, num := range lst {
        if num < 0 {
            if largestNegative == nil || num > *largestNegative {
                largestNegative = new(int)
                *largestNegative = num
            }
        } else if num > 0 {
            if smallestPositive == nil || num < *smallestPositive {
                smallestPositive = new(int)
                *smallestPositive = num
            }
        }
    }

    var result = []interface{}{nil, nil}
    if largestNegative != nil {
        result[0] = *largestNegative
    }
    if smallestPositive != nil {
        result[1] = *smallestPositive
    }

    return result
}","func TestLargest_Smallest_Integers(t *testing.T) {
  candidate := largest_smallest_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },
     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },
     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },
     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },
     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },
     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },
     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },
     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },
     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },
     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },
     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_138,ewe_Latn,go_test.go,"package is_equal_to_sum_even_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu //Kpɔe ɖa be xexlẽdzesi si nye n la nye xexlẽdzesi ene siwo nye xexlẽdzesi eve siwo nye dzidzimetɔ la ƒe xexlẽdzesi // >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
func is_equal_to_sum_even(n int) bool {
","package is_equal_to_sum_even_test

import (
    ""testing""
    ""fmt""
)

// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
// Example
// >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
func is_equal_to_sum_even(n int) bool {
    // The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8
    // Therefore, n must be at least 8 and n must be even
    return n >= 8 && n%2 == 0
}

// Testing the function
func TestIsEqualToSumEven(t *testing.T) {
    cases := []struct {
        n      int
        expect bool
    }{
        {4, false},
        {6, false},
        {8, true},
        {10, true},
        {12, true},
        {14, true},
        {16, true},
    }

    for _, c := range cases {
        result := is_equal_to_sum_even(c.n)
        if result != c.expect {
            t.Errorf(""is_equal_to_sum_even(%d) == %v, expect %v"", c.n, result, c.expect)
        } else {
            fmt.Printf(""Success: is_equal_to_sum_even(%d) == %v\n"", c.n, result)
        }
    }
}","func TestIs_Equal_To_Sum_Even(t *testing.T) {
  candidate := is_equal_to_sum_even
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(4), expected: false },
     { actual: candidate(6), expected: false },
     { actual: candidate(8), expected: true },
     { actual: candidate(10), expected: true },
     { actual: candidate(11), expected: false },
     { actual: candidate(12), expected: true },
     { actual: candidate(13), expected: false },
     { actual: candidate(16), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_139,ewe_Latn,go_test.go,"package special_factorial_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //afisi n > 0 //brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! //Woɖea Brazil ƒe nuŋɔŋlɔdzesi me be: // >>> special_factorial(4)
// 288
// The function will receive an integer as input and should return the special
// factorial of this integer.
func special_factorial(n int) int {
","package special_factorial_test

import (
    ""testing""
    ""fmt""
)

func special_factorial(n int) int {
    if n <= 0 {
        return 1
    }
    
    result := 1
    for i := 1; i <= n; i++ {
        result *= factorial(i)
    }
    
    return result
}

func factorial(x int) int {
    if x == 0 {
        return 1
    }
    prod := 1
    for i := 1; i <= x; i++ {
        prod *= i
    }
    return prod
}

func TestSpecialFactorial(t *testing.T) {
    cases := []struct {
        input    int
        expected int
    }{
        {4, 288},      // 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288
        {3, 12},       // 3! * 2! * 1! = 6 * 2 * 1 = 12
        {2, 2},        // 2! * 1! = 2 * 1 = 2
        {1, 1},        // 1! = 1
        {0, 1},        // Edge case for n=0, considered as 1 for special factorial
    }

    for _, c := range cases {
        result := special_factorial(c.input)
        if result != c.expected {
            t.Errorf(""special_factorial(%d) == %d, want %d"", c.input, result, c.expected)
        }
    }
}

func main() {
    fmt.Println(special_factorial(4)) // Output: 288
    fmt.Println(special_factorial(3)) // Output: 12
}","func TestSpecial_Factorial(t *testing.T) {
  candidate := special_factorial
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(4), expected: 288 },
     { actual: candidate(5), expected: 34560 },
     { actual: candidate(7), expected: 125411328000 },
     { actual: candidate(1), expected: 1 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_140,ewe_Latn,go_test.go,"package fix_spaces_test

import (
    ""testing""
    ""fmt""
)

//ekema tsɔ -  ɖɔli teƒe siwo katã le nyatia me.//eye ne nyagbe aɖe me nyagbewo sɔ gbɔ wu eve le wo nɔewo yome la, //Ne èkpɔ nyagbe aɖe la, tsɔ nya siwo le ete la ɖɔli teƒewo katã kple nya siwo le ete, // >>> fix_spaces("" Example"")
// ""Example""
// >>> fix_spaces("" Example 1"")
// ""Example_1""
// >>> fix_spaces("" Example 2"")
// ""_Example_2""
// >>> fix_spaces("" Example 3"")
// ""_Example-3""
func fix_spaces(text string) string {
","package fix_spaces_test

import (
    ""strings""
    ""testing""
)

func fix_spaces(text string) string {
    var result string
    spaceCount := 0

    for _, char := range text {
        if char == ' ' {
            spaceCount++
        } else {
            if spaceCount == 1 {
                result += ""_""
            } else if spaceCount > 1 {
                result += ""-""
            }
            result += string(char)
            spaceCount = 0
        }
    }

    // Handle trailing spaces
    if spaceCount == 1 {
        result += ""_""
    } else if spaceCount > 1 {
        result += ""-""
    }

    return result
}

func TestFixSpaces(t *testing.T) {
    cases := []struct {
        input    string
        expected string
    }{
        {"" Example"", ""Example""},
        {"" Example 1"", ""Example_1""},
        {"" Example 2"", ""_Example_2""},
        {"" Example 3"", ""_Example-3""},
        {"" Hello    world"", ""_Hello-world""},
        {""   Leading spaces"", ""-Leading_spaces""},
    }

    for _, c := range cases {
        result := fix_spaces(c.input)
        if result != c.expected {
            t.Errorf(""fix_spaces(%q) == %q, expected %q"", c.input, result, c.expected)
        }
    }
}","func TestFix_Spaces(t *testing.T) {
  candidate := fix_spaces
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Example""), expected: ""Example"" },
     { actual: candidate(""Mudasir Hanif ""), expected: ""Mudasir_Hanif_"" },
     { actual: candidate(""Yellow Yellow  Dirty  Fellow""), expected: ""Yellow_Yellow__Dirty__Fellow"" },
     { actual: candidate(""Exa   mple""), expected: ""Exa-mple"" },
     { actual: candidate(""   Exa 1 2 2 mple""), expected: ""-Exa_1_2_2_mple"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_141,ewe_Latn,go_test.go,"package file_name_check_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //- Ele be nu siwo gbɔna dometɔ ɖeka nanye nuƒolanɔamesiawo ƒe akpa si le aɖaka la megbe: ['txt', 'exe', 'dll'] //Latingbe me ŋɔŋlɔdzesiwo ('a'-'z' kple 'A'-'Z'). //- Mele be nuŋɔŋlɔdzesi si le aɖaka la ŋgɔ la nazu ƒuƒlu o, eye ele be ŋɔŋlɔdzesi si nye  nanye eƒe gɔmedzedze.//- Nyatakaka la ƒe ŋkɔa me nuŋɔŋlɔ ɖeka pɛe le.//- Nyatakakawo ƒe ŋkɔa megasɔ gbɔ wu xexlẽdzesi etɔ̃ o ('0' - '9'). //me: //Ne nya siwo gbɔna la katã le eme la, ekema nya la ƒe ŋkɔ anɔ eteƒe //Ne ŋkɔa nye nyateƒe la, ekema 'Ɛ̃' eye ne menye nenema o la, ekema 'Ao'//Wɔ dɔdeasi aɖe si xɔa nyakui si nye file ƒe ŋkɔ, eye wòtrɔna // >>> file_name_check(""example.txt"")
// ""Yes""
// >>> file_name_check(""1example.dll"")
// ""No""
func file_name_check(file_name string) string {
","package file_name_check_test

import (
    ""strings""
    ""unicode""
)

func file_name_check(file_name string) string {
    if len(file_name) == 0 {
        return ""No""
    }

    // Condition 2: Check for exactly one dot
    dotIndex := strings.LastIndex(file_name, ""."")
    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {
        return ""No""
    }

    // Split the file name into two parts
    namePart := file_name[:dotIndex]
    extension := file_name[dotIndex+1:]

    // Condition 4: Check the extension
    validExtensions := map[string]bool{
        ""txt"": true,
        ""exe"": true,
        ""dll"": true,
    }
    if !validExtensions[extension] {
        return ""No""
    }

    // Condition 3: Check the first character before the dot
    if !unicode.IsLetter(rune(namePart[0])) {
        return ""No""
    }

    // Condition 1: Count the digits in the file name
    digitCount := 0
    for _, char := range namePart {
        if unicode.IsDigit(char) {
            digitCount++
        }
    }
    if digitCount > 3 {
        return ""No""
    }

    // If all conditions are met, return ""Yes""
    return ""Yes""
}","func TestFile_Name_Check(t *testing.T) {
  candidate := file_name_check
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""example.txt""), expected: ""Yes"" },
     { actual: candidate(""1example.dll""), expected: ""No"" },
     { actual: candidate(""s1sdf3.asd""), expected: ""No"" },
     { actual: candidate(""K.dll""), expected: ""Yes"" },
     { actual: candidate(""MY16FILE3.exe""), expected: ""Yes"" },
     { actual: candidate(""His12FILE94.exe""), expected: ""No"" },
     { actual: candidate(""_Y.txt""), expected: ""No"" },
     { actual: candidate(""?aREYA.exe""), expected: ""No"" },
     { actual: candidate(""/this_is_valid.dll""), expected: ""No"" },
     { actual: candidate(""this_is_valid.wow""), expected: ""No"" },
     { actual: candidate(""this_is_valid.txt""), expected: ""Yes"" },
     { actual: candidate(""this_is_valid.txtexe""), expected: ""No"" },
     { actual: candidate(""#this2_i4s_5valid.ten""), expected: ""No"" },
     { actual: candidate(""@this1_is6_valid.exe""), expected: ""No"" },
     { actual: candidate(""this_is_12valid.6exe4.txt""), expected: ""No"" },
     { actual: candidate(""all.exe.txt""), expected: ""No"" },
     { actual: candidate(""I563_No.exe""), expected: ""Yes"" },
     { actual: candidate(""Is3youfault.txt""), expected: ""Yes"" },
     { actual: candidate(""no_one#knows.dll""), expected: ""Yes"" },
     { actual: candidate(""1I563_Yes3.exe""), expected: ""No"" },
     { actual: candidate(""I563_Yes3.txtt""), expected: ""No"" },
     { actual: candidate(""final..txt""), expected: ""No"" },
     { actual: candidate(""final132""), expected: ""No"" },
     { actual: candidate(""_f4indsartal132.""), expected: ""No"" },
     { actual: candidate("".txt""), expected: ""No"" },
     { actual: candidate(""s.""), expected: ""No"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_142,ewe_Latn,go_test.go,"package sum_squares_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //trɔna nu siwo le nuŋlɔɖi si ƒe index menye 3 alo 4 ƒe teƒe eve o la. Emegbe la, dɔwɔƒea naɖo nu siwo katã le nuŋlɔɖia me la ƒe home.//3 ƒe akpa geɖe eye wòana xexlẽdzesi blibo la ƒe akpa si nye 4 ƒe akpa geɖe eye menye 3 ƒe akpa akpa geɖe o la nazu etɔ̃ ƒe akpa ɖeka.//Dɔwɔƒe sia axɔ xexlẽdzesi blibowo ƒe ŋkɔwo. Le xexlẽdzesi siwo katã le ŋkɔa me gome la, dɔwɔƒe sia ana xexlẽdzesi blibo ƒe ŋkɔa ƒe dzidze naƒoe ne eƒe xexlẽdzesi nye //"" // >>> lst
// []int{1, 2, 3}
// >>> lst
// int{}
// >>> lst
// []int{-1, -5, 2, -1, -5}
func sum_squares(lst []int) int {
","package sum_squares_test

import (
    ""testing""
)

func sum_squares(lst []int) int {
    sum := 0
    for i, val := range lst {
        if i%3 == 0 {
            sum += val * val
        } else if i%4 == 0 {
            sum += val * val * val
        } else {
            sum += val
        }
    }
    return sum
}

func TestSumSquares(t *testing.T) {
    tests := []struct {
        lst      []int
        expected int
    }{
        {[]int{1, 2, 3}, 10},   // 1^2 + 2 + 3 = 10
        {[]int{}, 0},           // empty list
        {[]int{-1, -5, 2, -1, -5}, 0}, // (-1)^2 + (-5)^3 + 2 + (-1) = -118
    }

    for _, test := range tests {
        result := sum_squares(test.lst)
        if result != test.expected {
            t.Errorf(""sum_squares(%v) = %d; expected %d"", test.lst, result, test.expected)
        }
    }
}","func TestSum_Squares(t *testing.T) {
  candidate := sum_squares
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3}), expected: 6 },
     { actual: candidate([]int{1, 4, 9}), expected: 14 },
     { actual: candidate([]int{}), expected: 0 },
     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },
     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },
     { actual: candidate([]int{0}), expected: 0 },
     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },
     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },
     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },
     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },
     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_143,ewe_Latn,go_test.go,"package words_in_sentence_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu 1: //ele be nya siwo le nyagbe yeyea me la nanɔ ɖoɖo ɖeka abe esi nɔ gbãtɔa me ene. //eƒe didime nye xexlẽdzesi gbãtɔwo, //eye ele be nàtrɔ asi le nyagbe si me nya siwo le nyagbe gbãtɔa me le la ŋu, //nyagbea me nya aɖewo le, eye womeklã wo kple nyagbe aɖe o, //Wona nyagbe aɖe si le abe nyagbe ene la wò, // >>> words_in_sentence(""This is a test"")
// ""is""
// Example 2:
// >>> words_in_sentence(""lets go for swimming"")
// ""go for""
// Constraints:
// * 1 <= len(sentence) <= 100
// * sentence contains only letters
func words_in_sentence(sentence string) string {
","package words_in_sentence_test

import (
    ""strings""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n == 2 {
        return true
    }
    if n%2 == 0 {
        return false
    }
    for i := 3; i*i <= n; i += 2 {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func words_in_sentence(sentence string) string {
    words := strings.Split(sentence, "" "")
    var result []string

    for _, word := range words {
        if isPrime(len(word)) {
            result = append(result, word)
        }
    }

    return strings.Join(result, "" "")
}","func TestWords_In_Sentence(t *testing.T) {
  candidate := words_in_sentence
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""This is a test""), expected: ""is"" },
     { actual: candidate(""lets go for swimming""), expected: ""go for"" },
     { actual: candidate(""there is no place available here""), expected: ""there is no place"" },
     { actual: candidate(""Hi I am Hussein""), expected: ""Hi am Hussein"" },
     { actual: candidate(""go for it""), expected: ""go for it"" },
     { actual: candidate(""here""), expected: """" },
     { actual: candidate(""here is""), expected: ""is"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_144,ewe_Latn,go_test.go,"package simplify_test

import (
    ""testing""
    ""fmt""
)

//Míate ŋu agblɔ be x kple n nye mama siwo ŋu viɖe le, eye womenyea nufitifiti o.//<numerator>/<denominator> si me numerator kple denominator siaa nye xexlẽdzesi blibo siwo nye dzidzɔwo. //x kple n siaa nyea xexlẽdzesi siwo wotsɔna ɖea kpukpuiwo me, eye woƒe nɔnɔme enye esi://x * n. Ne x * n nye xexlẽdzesi blibo eye false  nye nyateƒe la, ke dɔwɔnaa ƒe toƒee nye nyateƒe.//Wò dɔdeasi enye be nàzã dɔdeasi aɖe si ana nyagbɔgblɔa nanɔ bɔbɔe wu // >>> simplify(""1/5"", ""5/1"")
// true
// >>> simplify(""1/6"", ""2/1"")
// false
// >>> simplify(""7/10"", ""10/2"")
// false
func simplify(x string, n string) bool {
","package simplify_test

import (
    ""strconv""
    ""strings""
    ""testing""
)

func simplify(x string, n string) bool {
    // Split the input strings into numerators and denominators
    xParts := strings.Split(x, ""/"")
    nParts := strings.Split(n, ""/"")

    // Convert the string parts to integers
    xNumerator, _ := strconv.Atoi(xParts[0])
    xDenominator, _ := strconv.Atoi(xParts[1])
    nNumerator, _ := strconv.Atoi(nParts[0])
    nDenominator, _ := strconv.Atoi(nParts[1])

    // Perform the multiplication (x * n) = (xNumerator/nDenominator) * (nNumerator/nDenominator)
    resultNumerator := xNumerator * nNumerator
    resultDenominator := xDenominator * nDenominator

    // Check if the result is a whole number
    return resultNumerator%resultDenominator == 0
}

func TestSimplify(t *testing.T) {
    if !simplify(""1/5"", ""5/1"") {
        t.Fatalf(""Expected true, got false"")
    }
    if simplify(""1/6"", ""2/1"") {
        t.Fatalf(""Expected false, got true"")
    }
    if simplify(""7/10"", ""10/2"") {
        t.Fatalf(""Expected false, got true"")
    }
}","func TestSimplify(t *testing.T) {
  candidate := simplify
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""1/5"", ""5/1""), expected: true },
     { actual: candidate(""1/6"", ""2/1""), expected: false },
     { actual: candidate(""5/1"", ""3/1""), expected: true },
     { actual: candidate(""7/10"", ""10/2""), expected: false },
     { actual: candidate(""2/10"", ""50/10""), expected: true },
     { actual: candidate(""7/2"", ""4/2""), expected: true },
     { actual: candidate(""11/6"", ""6/1""), expected: true },
     { actual: candidate(""2/3"", ""5/2""), expected: false },
     { actual: candidate(""5/2"", ""3/5""), expected: false },
     { actual: candidate(""2/4"", ""8/4""), expected: true },
     { actual: candidate(""2/4"", ""4/2""), expected: true },
     { actual: candidate(""1/5"", ""5/1""), expected: true },
     { actual: candidate(""1/5"", ""1/5""), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_145,ewe_Latn,go_test.go,"package order_by_points_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Ðo wo ɖe ɖoɖo nu le woƒe ŋkɔwo nu le nuŋlɔɖi gbãtɔa me.//De dzesii: ne nu siwo ƒe xexlẽdzesiwo sɔ la sɔ gbɔ la, //le ɖoɖo si nu woɖina ɖe edzi le le woƒe xexlẽdzesiwo ƒe xexlẽdzesi nu. //Ŋlɔ dɔ si ana xexlẽdzesi blibowo ƒe xexlẽdzesi si míetsɔ na la nanɔ ɖoɖo nu // >>> order_by_points([]int{1, 11, -1, -11, -12})
// []int{-1, -11, 1, -12, 11}
// >>> order_by_points([]int{})
// []int{}
func order_by_points(nums []int) []int {
","package order_by_points_test

import (
	""testing""
	""fmt""
	""sort""
	""strconv""
)

func digitSum(n int) int {
	n = abs(n) // Consider the absolute value for digit sum
	sum := 0
	for n > 0 {
		sum += n % 10
		n /= 10
	}
	return sum
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

func order_by_points(nums []int) []int {
	type numWithIndex struct {
		num   int
		index int
	}

	numsWithIndex := make([]numWithIndex, len(nums))
	for i, num := range nums {
		numsWithIndex[i] = numWithIndex{num, i}
	}

	sort.Slice(numsWithIndex, func(i, j int) bool {
		sumI := digitSum(numsWithIndex[i].num)
		sumJ := digitSum(numsWithIndex[j].num)
		if sumI == sumJ {
			return numsWithIndex[i].index < numsWithIndex[j].index
		}
		return sumI < sumJ
	})

	sortedNums := make([]int, len(nums))
	for i, nwi := range numsWithIndex {
		sortedNums[i] = nwi.num
	}

	return sortedNums
}

func TestOrderByPoints(t *testing.T) {
	testCases := []struct {
		input    []int
		expected []int
	}{
		{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},
		{[]int{}, []int{}},
	}

	for _, tc := range testCases {
		result := order_by_points(tc.input)
		if !equal(result, tc.expected) {
			t.Errorf(""Expected %v, but got %v"", tc.expected, result)
		}
	}
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}","func TestOrder_By_Points(t *testing.T) {
  candidate := order_by_points
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },
     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },
     { actual: candidate([]int{}), expected: []int{} },
     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },
     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },
     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_146,ewe_Latn,go_test.go,"package specialFilter_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //xexlẽdzesi aɖe ƒe xexlẽdzesi gbãtɔ kple mamlɛtɔ nye xexlẽdzesi siwo nye ɖeka (1, 3, 5, 7, 9).//nu siwo le eme siwo wu 10 kple eve la siaa //Ŋlɔ dɔdeasi aɖe si xɔa xexlẽdzesiwo ƒe ŋkɔwo abe nu siwo woanae ene eye wògatrɔa wo // >>> specialFilter([]int{15, -73, 14, -15})
// 1
// >>> specialFilter([]int{33, -2, -3, 45, 21, 109})
// 2
func specialFilter(nums []int) int {
","package specialFilter_test

import (
	""testing""
)

func specialFilter(nums []int) int {
	count := 0
	for _, num := range nums {
		// Consider the absolute value of the number
		absNum := abs(num)
		if absNum > 10 {
			strNum := fmt.Sprintf(""%d"", absNum)
			firstDigit := strNum[0]
			lastDigit := strNum[len(strNum)-1]
			if isOdd(firstDigit) && isOdd(lastDigit) {
				count++
			}
		}
	}
	return count
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

func isOdd(digit byte) bool {
	return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'
}

func TestSpecialFilter(t *testing.T) {
	tests := []struct {
		input    []int
		expected int
	}{
		{[]int{15, -73, 14, -15}, 1},
		{[]int{33, -2, -3, 45, 21, 109}, 2},
		{[]int{8, 4, 12, 55, 99, 111}, 1},
		{[]int{-11, -22, -33, -44, -55}, 1},
	}

	for _, test := range tests {
		result := specialFilter(test.input)
		if result != test.expected {
			t.Errorf(""specialFilter(%v) = %d; want %d"", test.input, result, test.expected)
		}
	}
}","func TestSpecialfilter(t *testing.T) {
  candidate := specialFilter
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },
     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },
     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },
     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },
     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },
     { actual: candidate([]int{1}), expected: 0 },
     { actual: candidate([]int{}), expected: 0 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_147,ewe_Latn,go_test.go,"package get_max_triples_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //eye a[i] + a[j] + a[k] nye 3 ƒe teƒevi. //Gbugbɔ xɔname siwo nye (a[i], a[j], a[k]) ƒe xexlẽme ɖo le a me afisi i < j < k, //Ne èbu eŋu kpɔ la, àkpɔe be nu siwo me míedzro la dometɔ ɖe sia ɖe nyea nu si sɔ.//Wona xexlẽdzesi blibo n wò. Ele be nàŋlɔ xexlẽdzesi blibo a siwo ƒe didime nye n. // >>> get_max_triples(5)
// 1
// Explanation: 
// a = [1, 3, 7, 13, 21]
// The only valid triple is (1, 7, 13).
func get_max_triples(n int) int {
","package get_max_triples_test

import (
    ""testing""
)

func get_max_triples(n int) int {
    a := make([]int, n)
    for i := 1; i <= n; i++ {
        a[i-1] = i*i - i + 1
    }
    
    count := 0
    
    for i := 0; i < n-2; i++ {
        for j := i + 1; j < n-1; j++ {
            for k := j + 1; k < n; k++ {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count++
                }
            }
        }
    }
    
    return count
}

func TestGetMaxTriples(t *testing.T) {
    if get_max_triples(5) != 1 {
        t.Errorf(""Expected 1 but got %d"", get_max_triples(5))
    }
}","func TestGet_Max_Triples(t *testing.T) {
  candidate := get_max_triples
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5), expected: 1 },
     { actual: candidate(6), expected: 4 },
     { actual: candidate(10), expected: 36 },
     { actual: candidate(100), expected: 53361 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_148,ewe_Latn,go_test.go,"package bf_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //menye ɣletinyigbawo ƒe ŋkɔ siwo sɔ o.//Ele be dɔwɔwɔa nagbugbɔ ŋkɔ si me naneke mele o ne planet1 alo planet2 //Ale si wòte ɖe ɣea ŋu.//Anyigba 1 kple Anyigba 2 ƒe mɔwo domee wole, eye woɖɔ wo ɖo ɖe //Ele be dɔwɔƒea nagbugbɔ ŋkɔ siwo katã le ɣletinyigba siwo ƒe mɔwo nye //Ŋlɔ dɔ si xɔa ɣletinyigba eve ƒe ŋkɔwo abe planet1 kple planet2 ƒe kɔpi ene.//Uranus, Neptune. //enye Mercury, si kplɔe ɖo enye Venus, eyome Anyigba, Mars, Jupiter, Saturn, //Ɣletivi enyi ye le míaƒe ɣea me: esiwo te ɖe Ɣea ŋu wu.// >>> bf(""Jupiter"", ""Neptune"")
// []interface{}{""Saturn"", ""Uranus""}
// >>> bf(""Earth"", ""Mercury"")
// ""Venus""
// >>> bf(""Mercury"", ""Uranus"")
// []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""}
func bf(planet1 string, planet2 string) []interface{} {
","package bf_test

import (
    ""testing""
    ""fmt""
)

// Define the solar system slice with planets ordered by their proximity to the Sun
var solarSystem = []string{""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""}

func bf(planet1 string, planet2 string) []interface{} {
    index1 := -1
    index2 := -1

    // Find the indices of the given planet names in the solarSystem slice
    for i, planet := range solarSystem {
        if planet == planet1 {
            index1 = i
        }
        if planet == planet2 {
            index2 = i
        }
    }

    // If either planet name is incorrect, return an empty list
    if index1 == -1 || index2 == -1 {
        return []interface{}{}
    }

    // Ensure index1 is less than index2 to find planets between them
    if index1 > index2 {
        index1, index2 = index2, index1
    }

    // Collect and return planets that are located between the two indices
    var planetsBetween []interface{}
    for i := index1 + 1; i < index2; i++ {
        planetsBetween = append(planetsBetween, solarSystem[i])
    }
    
    return planetsBetween
}

func TestBf(t *testing.T) {
    fmt.Println(bf(""Jupiter"", ""Neptune"")) // Should print: []interface{}{""Saturn"", ""Uranus""}
    fmt.Println(bf(""Earth"", ""Mercury""))  // Should print: []interface{}{""Venus""}
    fmt.Println(bf(""Mercury"", ""Uranus"")) // Should print: []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""}
}","func TestBf(t *testing.T) {
  candidate := bf
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Jupiter"", ""Neptune""), expected: []interface{}{""Saturn"", ""Uranus""} },
     { actual: candidate(""Earth"", ""Mercury""), expected: []interface{}{""Venus""} },
     { actual: candidate(""Mercury"", ""Uranus""), expected: []interface{}{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""} },
     { actual: candidate(""Neptune"", ""Venus""), expected: []interface{}{""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""} },
     { actual: candidate(""Earth"", ""Earth""), expected: []interface{}{} },
     { actual: candidate(""Mars"", ""Earth""), expected: []interface{}{} },
     { actual: candidate(""Jupiter"", ""Makemake""), expected: []interface{}{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_149,ewe_Latn,go_test.go,"package sorted_list_sum_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //Àte ŋu asusu be nyaawo katã ƒe didime anɔ ɖeka.//Ele be dɔdeasi sia nagbugbɔ nyagbewo ƒe ƒuƒoƒo si woɖo ɖe ɖoɖo nu la aɖo. //Ne nya eve ƒe didime sɔ la, ke ŋlɔe ɖe ɖoɖo nu le alfabeta nu. //ele be wòatsɔ ŋkɔawo aɖo agbalẽa me le ɖoɖo nu le se ma nu. //Ele be nya siwo le eme la nanɔ ɖoɖo nu le ɖoɖo nu, eye wò hã nàdi be yeanya nya siwo le eme.//eye ate ŋu anye be agbalẽa me nyawo ƒe akpa eve aɖewoe le eme.//Numewo ƒe ƒuƒoƒowoe le nyatakakawo me, ke menye xexlẽdzesiwo o.//eye wòana woaŋlɔ nu siwo katã le eme la ɖe ɖoɖo nu, //Eɖea mɔ be nya siwo ƒe didime nye eve la nagava nɔ eme o, //Ŋlɔ dɔdeasi aɖe si axɔ stringwo ƒe ŋkɔwo abe parameter ene, // >>> list_sort([]string{""aa"", ""a"", ""aaa""})
// []string{""aa""}
// >>> list_sort([]string{""ab"", ""a"", ""aaa"", ""cd""})
// []string{""ab"", ""cd""}
func sorted_list_sum(lst []string) []string {
","package sorted_list_sum_test

import (
    ""sort""
)

func sorted_list_sum(lst []string) []string {
    // Filter out strings with odd lengths
    filtered := []string{}
    for _, str := range lst {
        if len(str)%2 == 0 {
            filtered = append(filtered, str)
        }
    }

    // Sort the filtered list by length, then alphabetically
    sort.Slice(filtered, func(i, j int) bool {
        if len(filtered[i]) == len(filtered[j]) {
            return filtered[i] < filtered[j]
        }
        return len(filtered[i]) < len(filtered[j])
    })

    return filtered
}","func TestSorted_List_Sum(t *testing.T) {
  candidate := sorted_list_sum
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""aa"", ""a"", ""aaa""}), expected: []string{""aa""} },
     { actual: candidate([]string{""school"", ""AI"", ""asdf"", ""b""}), expected: []string{""AI"", ""asdf"", ""school""} },
     { actual: candidate([]string{""d"", ""b"", ""c"", ""a""}), expected: []string{} },
     { actual: candidate([]string{""d"", ""dcba"", ""abcd"", ""a""}), expected: []string{""abcd"", ""dcba""} },
     { actual: candidate([]string{""AI"", ""ai"", ""au""}), expected: []string{""AI"", ""ai"", ""au""} },
     { actual: candidate([]string{""a"", ""b"", ""b"", ""c"", ""c"", ""a""}), expected: []string{} },
     { actual: candidate([]string{""aaaa"", ""bbbb"", ""dd"", ""cc""}), expected: []string{""cc"", ""dd"", ""aaaa"", ""bbbb""} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_150,ewe_Latn,go_test.go,"package x_or_y_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //ele be wòaɖo y ƒe asixɔxɔ la teƒe.//Enye ɖoɖo bɔbɔe si ana x ƒe home ne n nye // >>> x_or_y(7, 34, 12)
// 34
// >>> x_or_y(15, 8, 5)
// 5
func x_or_y(n int, x int, y int) int {
","package x_or_y_test

import (
    ""testing""
    ""math""
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n%2 == 0 || n%3 == 0 {
        return false
    }
    for i := 5; i*i <= n; i += 6 {
        if n%i == 0 || n%(i+2) == 0 {
            return false
        }
    }
    return true
}

func x_or_y(n int, x int, y int) int {
    if isPrime(n) {
        return x
    }
    return y
}

func TestXOrY(t *testing.T) {
    cases := []struct{
        n, x, y, want int
    }{
        {7, 34, 12, 34},
        {15, 8, 5, 5},
        {2, 10, 20, 10},
        {1, 5, 15, 15},
    }

    for _, c := range cases {
        got := x_or_y(c.n, c.x, c.y)
        if got != c.want {
            t.Errorf(""x_or_y(%d, %d, %d) == %d, want %d"", c.n, c.x, c.y, got, c.want)
        }
    }
}","func TestX_Or_Y(t *testing.T) {
  candidate := x_or_y
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(7, 34, 12), expected: 34 },
     { actual: candidate(15, 8, 5), expected: 5 },
     { actual: candidate(3, 33, 5212), expected: 33 },
     { actual: candidate(1259, 3, 52), expected: 3 },
     { actual: candidate(7919, -1, 12), expected: -1 },
     { actual: candidate(3609, 1245, 583), expected: 583 },
     { actual: candidate(91, 56, 129), expected: 129 },
     { actual: candidate(6, 34, 1234), expected: 1234 },
     { actual: candidate(1, 2, 0), expected: 0 },
     { actual: candidate(2, 2, 0), expected: 2 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_151,ewe_Latn,go_test.go,"package double_the_difference_test

import (
    ""testing""
    ""fmt""
)

//Mègaŋlɔ xexlẽdzesi siwo nye negative alo esiwo menye xexlẽdzesi blibowo o la be o.//Ne èna xexlẽdzesiwo ƒe xexlẽdzesi aɖe mí la, gbugbɔ xexlẽdzesiawo ƒe dzidze ƒe agbɔsɔsɔ ɖo teƒe eve me // >>> double_the_difference([]int{1, 3, 2, 0})
// 10
// >>> double_the_difference([]int{-1, -2, 0})
// 0
// >>> double_the_difference([]int{9, -2})
// 81
// >>> double_the_difference([]int{0})
// 0
// If the input list is empty, return 0.
func double_the_difference(lst []float64) int {
","package double_the_difference_test

import (
    ""testing""
    ""fmt""
    ""math""
)

func double_the_difference(lst []float64) int {
    sum := 0
    for _, num := range lst {
        if num >= 0 && math.Mod(num, 1) == 0 {
            intNum := int(num)
            if intNum%2 != 0 {
                sum += intNum * intNum
            }
        }
    }
    return sum
}

func TestDoubleTheDifference(t *testing.T) {
    cases := []struct {
        input []float64
        expected int
    }{
        {input: []float64{1, 3, 2, 0}, expected: 10},
        {input: []float64{-1, -2, 0}, expected: 0},
        {input: []float64{9, -2}, expected: 81},
        {input: []float64{0}, expected: 0},
        {input: []float64{}, expected: 0},
    }

    for _, c := range cases {
        result := double_the_difference(c.input)
        if result != c.expected {
            t.Errorf(""double_the_difference(%v) == %d, want %d"", c.input, result, c.expected)
        } else {
            fmt.Printf(""Test passed for input %v. Result: %d\n"", c.input, result)
        }
    }
}","func TestDouble_The_Difference(t *testing.T) {
  candidate := double_the_difference
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]float64{}), expected: 0 },
     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },
     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },
     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },
     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },
     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },
     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_152,ewe_Latn,go_test.go,"package compare_test

import (
    ""testing""
    ""fmt""
)

//kpɔɖeŋu: //ne enye 0, eye ne menye nenema o la, ke enye vovototo si le susua kple dzidzedzekpɔkpɔa dome. //Gblɔ ale si gbegbe nu si ŋu woƒo nu tsoe la to vovo na nu si ŋu woƒo nu tsoe la ƒe didime.//Woana numekɔkɔ kple akɔntabubu ƒe nuŋlɔɖi eve siwo ƒe didime sɔ, eye numekɔkɔ ɖesiaɖe fiaa nu ɖeka. //Wò dɔe nye be nàkpɔe ɖa be ame aɖe nya nu si tututu dzɔ le hoʋiʋli aɖewo me hã.//Ðikeke mele eme o be ele be woaŋlɔe ahawɔ eƒe kpɔɖeŋu.//Ne ènya nu si dzɔ la, wò seselelãmewo kple susuwo ava nɔ nyanya na wò mlɔeba.//Meka ɖe edzi be mí katã míeɖoa ŋku seselelãme ma dzi ne ame aɖe ƒe nuxaxa si nɔ anyi didi la ƒe akpa aɖe va eme.// >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})
// []int{0, 0, 0, 0, 3, 3}
// >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})
// []int{4, 4, 1, 0, 0, 6}
func compare(game []int, guess []int) []int {
","package compare_test

import (
    ""math""
    ""testing""
    ""fmt""
)

func compare(game []int, guess []int) []int {
    result := make([]int, len(game))
    for i := 0; i < len(game); i++ {
        if game[i] == guess[i] {
            result[i] = 0
        } else {
            result[i] = int(math.Abs(float64(game[i] - guess[i])))
        }
    }
    return result
}

func TestCompare(t *testing.T) {
    tests := []struct {
        game  []int
        guess []int
        want  []int
    }{
        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},
        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf(""%v vs %v"", tt.game, tt.guess), func(t *testing.T) {
            got := compare(tt.game, tt.guess)
            for i := range got {
                if got[i] != tt.want[i] {
                    t.Errorf(""compare(%v, %v) = %v; want %v"", tt.game, tt.guess, got, tt.want)
                }
            }
        })
    }
}","func TestCompare(t *testing.T) {
  candidate := compare
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },
     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },
     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },
     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_153,ewe_Latn,go_test.go,"package Strongest_Extension_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //(eƒe ŋusẽe nye -1). //return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension //['SErviNGSliCes', 'Cheese', 'StuFfed'] ekema ele be nàŋlɔe be //Le kpɔɖeŋu me, ne wona ""Slices"" wòzu klass kple //tia esi dze ŋgɔwò le ŋkɔa me.//Ne èdi be yeawɔ nu eve alo esi wu nenema eye ŋusẽ le wo ŋu la, ke ele be nàɖe asi le eŋu.//format: ClassName.StrongestExtensionName. //Ele be nàdi nu si ƒe ŋusẽ le wu eye nàtrɔ asi le eŋu wòazu string le afi sia.//le ŋkɔ si wotsɔ na lãwo ƒe agbɔsɔsɔme si wotsɔ na lãwo ƒe agbɔsɔsɔme si wotsɔ na lãwo ƒe agbɔsɔsɔme si wotsɔ na lãwo ƒe agbɔsɔsɔme si wotsɔ na lãwo ƒe agbɔsɔsɔme si wotsɔ na lãwo ƒe agbɔsɔsɔme si wotsɔ na lãwo. //ŋɔŋlɔdzesi siwo le ŋkɔa me, eye na SM nanye ŋɔŋlɔdzesi suewo ƒe xexlẽme //Ŋusẽ si le nyaawo ŋu la le ale: Na CAP nanye xexlẽdzesi si wotsɔ ŋɔŋlɔdzesi gãwo ŋlɔ //Woazã ɖoɖowo atsɔ ade suku bubu me sukuwo.//Woaɖe sukuvi aɖe ƒe ŋkɔ (si nye nyaƒoka) kple eƒe ŋkɔwo me.// >>> Strongest_Extension(""my_class"", []string{""AA"", ""Be"", ""CC""})
// ""my_class.AA""
func Strongest_Extension(class_name string, extensions []string) string {
","func Strongest_Extension(class_name string, extensions []string) string {
    strongestExtension := """"
    maxStrength := -1 << 31

    for _, extension := range extensions {
        capCount, smCount := 0, 0
        for _, char := range extension {
            if char >= 'A' && char <= 'Z' {
                capCount++
            } else if char >= 'a' && char <= 'z' {
                smCount++
            }
        }
        strength := capCount - smCount
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = extension
        }
    }

    return fmt.Sprintf(""%s.%s"", class_name, strongestExtension)
}","func TestStrongest_Extension(t *testing.T) {
  candidate := Strongest_Extension
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""Watashi"", []string{""tEN"", ""niNE"", ""eIGHt8OKe""}), expected: ""Watashi.eIGHt8OKe"" },
     { actual: candidate(""Boku123"", []string{""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""}), expected: ""Boku123.YEs.WeCaNe"" },
     { actual: candidate(""__YESIMHERE"", []string{""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""}), expected: ""__YESIMHERE.NuLl__"" },
     { actual: candidate(""K"", []string{""Ta"", ""TAR"", ""t234An"", ""cosSo""}), expected: ""K.TAR"" },
     { actual: candidate(""__HAHA"", []string{""Tab"", ""123"", ""781345"", ""-_-""}), expected: ""__HAHA.123"" },
     { actual: candidate(""YameRore"", []string{""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""}), expected: ""YameRore.okIWILL123"" },
     { actual: candidate(""finNNalLLly"", []string{""Die"", ""NowW"", ""Wow"", ""WoW""}), expected: ""finNNalLLly.WoW"" },
     { actual: candidate(""_"", []string{""Bb"", ""91245""}), expected: ""_.Bb"" },
     { actual: candidate(""Sp"", []string{""671235"", ""Bb""}), expected: ""Sp.671235"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_154,ewe_Latn,go_test.go,"package cycpattern_check_test

import (
    ""testing""
    ""fmt""
)

//Woana nya eve wò. Ne nya evelia alo eƒe tɔtrɔ ɖesiaɖe nye nya gbãtɔa ƒe akpa aɖe la, ele be nàɖo true.// >>> cycpattern_check(""abcd"", ""abd"")
// false
// >>> cycpattern_check(""hello"", ""ell"")
// true
// >>> cycpattern_check(""whassup"", ""psus"")
// false
// >>> cycpattern_check(""abab"", ""baa"")
// true
// >>> cycpattern_check(""efef"", ""eeff"")
// false
// >>> cycpattern_check(""himenss"", ""simen"")
// true
func cycpattern_check(a string, b string) bool {
","package cycpattern_check_test

import (
    ""testing""
    ""fmt""
    ""strings""
)

func cycpattern_check(a string, b string) bool {
    n := len(b)
    
    // Generate all rotations of b
    for i := 0; i < n; i++ {
        rotated := b[i:] + b[:i]
        if strings.Contains(a, rotated) {
            return true
        }
    }
    
    return false
}","func TestCycpattern_Check(t *testing.T) {
  candidate := cycpattern_check
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""xyzw"", ""xyw""), expected: false },
     { actual: candidate(""yello"", ""ell""), expected: true },
     { actual: candidate(""whattup"", ""ptut""), expected: false },
     { actual: candidate(""efef"", ""fee""), expected: true },
     { actual: candidate(""abab"", ""aabb""), expected: false },
     { actual: candidate(""winemtt"", ""tinem""), expected: true },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_155,ewe_Latn,go_test.go,"package even_odd_count_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Ne wotsɔ xexlẽdzesi blibo aɖe na mí la, ekema míana xexlẽdzesi siwo nye xexlẽdzesi eve kple xexlẽdzesi eve ƒe xexlẽdzesi ɖeka la mí.// >>> even_odd_count(-12)
// []interface{}{1, 1}
// >>> even_odd_count(123)
// []interface{}{1, 2}
func even_odd_count(num int) []interface{} {
","func even_odd_count(num int) []interface{} {
    // Handle negative numbers by taking the absolute value
    if num < 0 {
        num = -num
    }
    
    evenCount, oddCount := 0, 0

    // Iterate over each digit in the number
    for num > 0 {
        digit := num % 10
        if digit%2 == 0 {
            evenCount++
        } else {
            oddCount++
        }
        num /= 10
    }

    return []interface{}{evenCount, oddCount}
}

func TestEvenOddCount(t *testing.T) {
    testCases := []struct {
        input    int
        expected []interface{}
    }{
        {-12, []interface{}{1, 1}},
        {123, []interface{}{1, 2}},
        {2468, []interface{}{4, 0}},
        {1357, []interface{}{0, 4}},
        {0, []interface{}{1, 0}},
    }

    for _, testCase := range testCases {
        result := even_odd_count(testCase.input)
        if fmt.Sprintf(""%v"", result) != fmt.Sprintf(""%v"", testCase.expected) {
            t.Errorf(""even_odd_count(%d) = %v; expected %v"", testCase.input, result, testCase.expected)
        }
    }
}","func TestEven_Odd_Count(t *testing.T) {
  candidate := even_odd_count
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(7), expected: []interface{}{0, 1} },
     { actual: candidate(-78), expected: []interface{}{1, 1} },
     { actual: candidate(3452), expected: []interface{}{2, 2} },
     { actual: candidate(346211), expected: []interface{}{3, 3} },
     { actual: candidate(-345821), expected: []interface{}{3, 3} },
     { actual: candidate(-2), expected: []interface{}{1, 0} },
     { actual: candidate(-45347), expected: []interface{}{2, 3} },
     { actual: candidate(0), expected: []interface{}{1, 0} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_156,ewe_Latn,go_test.go,"package int_to_mini_roman_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo: //Seɖoƒe: 1 <= num <= 1000 //eye nàŋlɔe kple ŋɔŋlɔ suewo. //Ne wotsɔ xexlẽdzesi blibo aɖe si nye dzidzimetɔ na wò la, tsɔ eƒe xexlẽdzesi si sɔ kple Roma xexlẽdzesi la wɔ mɔ̃, // >>> int_to_mini_roman(19)
// ""xix""
// >>> int_to_mini_roman(152)
// ""clii""
// >>> int_to_mini_roman(426)
// ""cdxxvi""
func int_to_mini_roman(number int) string {
","package int_to_mini_roman_test

import (
	""strings""
	""testing""
)

func int_to_mini_roman(number int) string {
	vals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
	symbols := []string{""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""}

	var roman strings.Builder

	for i := 0; i < len(vals); i++ {
		for number >= vals[i] {
			number -= vals[i]
			roman.WriteString(symbols[i])
		}
	}
	return roman.String()
}

func TestIntToMiniRoman(t *testing.T) {
	tests := []struct {
		input    int
		expected string
	}{
		{19, ""xix""},
		{152, ""clii""},
		{426, ""cdxxvi""},
		{1000, ""m""},
		{1, ""i""},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf(""%d"", tt.input), func(t *testing.T) {
			result := int_to_mini_roman(tt.input)
			if result != tt.expected {
				t.Fatalf(""expected %v, but got %v"", tt.expected, result)
			}
		})
	}
}","func TestInt_To_Mini_Roman(t *testing.T) {
  candidate := int_to_mini_roman
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(19), expected: ""xix"" },
     { actual: candidate(152), expected: ""clii"" },
     { actual: candidate(251), expected: ""ccli"" },
     { actual: candidate(426), expected: ""cdxxvi"" },
     { actual: candidate(500), expected: ""d"" },
     { actual: candidate(1), expected: ""i"" },
     { actual: candidate(4), expected: ""iv"" },
     { actual: candidate(43), expected: ""xliii"" },
     { actual: candidate(90), expected: ""xc"" },
     { actual: candidate(94), expected: ""xciv"" },
     { actual: candidate(532), expected: ""dxxxii"" },
     { actual: candidate(900), expected: ""cm"" },
     { actual: candidate(994), expected: ""cmxciv"" },
     { actual: candidate(1000), expected: ""m"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_157,ewe_Latn,go_test.go,"package right_angle_triangle_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //Dzo ƒe dzedzeme: 90°.//Anyigba si ƒe dzogoe nye ɖusime le dzogoe eve dzi la nye anyigba si ƒe dzogoe ɖeka nye dzogoe ɖusime alo //Ne menye nenema o la, ke enye alakpanya.//Ne wotsɔ dzogoe etɔ̃awo ƒe didime na mí la, ekema míagbugbɔ true aɖo ne wo katã ƒe didime nye // >>> right_angle_triangle(3, 4, 5)
// true
// >>> right_angle_triangle(1, 2, 3)
// false
func right_angle_triangle(a int, b int, c int) bool {
","package right_angle_triangle_test

import (
    ""testing""
    ""fmt""
)

func right_angle_triangle(a int, b int, c int) bool {
    // Squaring the sides
    a2, b2, c2 := a*a, b*b, c*c
    // Check the Pythagorean theorem for the combination of sides
    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2
}","func TestRight_Angle_Triangle(t *testing.T) {
  candidate := right_angle_triangle
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(3, 4, 5), expected: true },
     { actual: candidate(1, 2, 3), expected: false },
     { actual: candidate(10, 6, 8), expected: true },
     { actual: candidate(2, 2, 2), expected: false },
     { actual: candidate(7, 24, 25), expected: true },
     { actual: candidate(10, 5, 7), expected: false },
     { actual: candidate(5, 12, 13), expected: true },
     { actual: candidate(15, 8, 17), expected: true },
     { actual: candidate(48, 55, 73), expected: true },
     { actual: candidate(1, 1, 1), expected: false },
     { actual: candidate(2, 2, 10), expected: false },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_158,ewe_Latn,go_test.go,"package find_max_test

import (
    ""testing""
    ""fmt""
)

//Ŋkɔ siwo le ŋɔŋlɔdzesi sia me la dometɔ si dze le nyagbewo ƒe ɖoɖo nu la naɖo. //Ne ŋɔŋlɔdzesi siwo le ƒuƒoƒo me sɔ gbɔ la, ke ŋɔŋlɔdzesi siwo le ƒuƒoƒo me la sɔ gbɔ wu //Nya vovovowoe le nuŋlɔɖia me. Gbugbɔ nya si ƒe xexlẽme wu la na mí //Ŋlɔ dɔdeasi aɖe si axɔ nyagbewo ƒe ƒuƒoƒo.// >>> find_max([]string{""name"", ""of"", ""string""})
// ""string""
// >>> find_max([]string{""name"", ""enam"", ""game""})
// ""enam""
// >>> find_max([]string{""aaaaaaa"", ""bb"", ""cc""})
// ""aaaaaaa""
func find_max(words []string) string {
","package find_max_test

import (
    ""testing""
    ""fmt""
    ""sort""
)

func find_max(words []string) string {
    maxWord := """"
    maxUnique := 0
    
    for _, word := range words {
        uniqueChars := countUniqueChars(word)
        if uniqueChars > maxUnique {
            maxUnique = uniqueChars
            maxWord = word
        } else if uniqueChars == maxUnique {
            if maxWord == """" || word < maxWord {
                maxWord = word
            }
        }
    }
    
    return maxWord
}

func countUniqueChars(word string) int {
    charSet := make(map[rune]struct{})
    for _, c := range word {
        charSet[c] = struct{}{}
    }
    return len(charSet)
}

// Test case runs to verify the solution
func TestFindMax(t *testing.T) {
    testCases := []struct {
        input []string
        expected string
    }{
        {[]string{""name"", ""of"", ""string""}, ""string""},
        {[]string{""name"", ""enam"", ""game""}, ""enam""},
        {[]string{""aaaaaaa"", ""bb"", ""cc""}, ""aaaaaaa""},
    }

    for _, tc := range testCases {
        result := find_max(tc.input)
        if result != tc.expected {
            t.Errorf(""For input %v, expected %s, but got %s"", tc.input, tc.expected, result)
        } else {
            fmt.Printf(""Test passed for input %v\n"", tc.input)
        }
    }
}","func TestFind_Max(t *testing.T) {
  candidate := find_max
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""name"", ""of"", ""string""}), expected: ""string"" },
     { actual: candidate([]string{""name"", ""enam"", ""game""}), expected: ""enam"" },
     { actual: candidate([]string{""aaaaaaa"", ""bb"", ""cc""}), expected: ""aaaaaaa"" },
     { actual: candidate([]string{""abc"", ""cba""}), expected: ""abc"" },
     { actual: candidate([]string{""play"", ""this"", ""game"", ""of"", ""footbott""}), expected: ""footbott"" },
     { actual: candidate([]string{""we"", ""are"", ""gonna"", ""rock""}), expected: ""gonna"" },
     { actual: candidate([]string{""we"", ""are"", ""a"", ""mad"", ""nation""}), expected: ""nation"" },
     { actual: candidate([]string{""this"", ""is"", ""a"", ""prrk""}), expected: ""this"" },
     { actual: candidate([]string{""b""}), expected: ""b"" },
     { actual: candidate([]string{""play"", ""play"", ""play""}), expected: ""play"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_159,ewe_Latn,go_test.go,"package eat_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋu: //ne ŋeʋẽe susɔ la mesɔ gbɔ o la, àɖu ŋeʋẽe susɔawo katã, gake dɔ agawu wò kokoko.//[Ðe wò susu le ʋeʋẽe siwo susɔ le nuɖuɖu megbe ŋu] //[ xexlẽme si nu nèɖu ŋeŋe le nuɖuɖu megbe, //Gake fifia la, ele be nàɖu karoti geɖe wu be nàɖu nu awu ŋkekea ƒe nuɖuɖua nu.//Aɖatsi nɔ wuwòm vevie, eye èɖu ŋdɔnuvi gbogbo aɖewo xoxo, // >>> eat(5, 6, 10)
// []int{11, 4}
// >>> eat(4, 8, 9)
// []int{12, 1}
// >>> eat(1, 10, 10)
// []int{11, 0}
// >>> eat(2, 11, 5)
// []int{7, 0}
// Variables:
// @number : integer
// the number of carrots that you have eaten.
// @need : integer
// the number of carrots that you need to eat.
// @remaining : integer
// the number of remaining carrots thet exist in stock
// Constrain:
// * 0 <= number <= 1000
// * 0 <= need <= 1000
// * 0 <= remaining <= 1000
// Have fun :)
func eat(number int, need int, remaining int) []int {
","package eat_test

import (
    ""testing""
    ""fmt""
)

// eat calculates the total number of eaten carrots after meals and the number of carrots left.
func eat(number int, need int, remaining int) []int {
    if need <= remaining {
        return []int{number + need, remaining - need}
    }
    return []int{number + remaining, 0}
}

func TestEat(t *testing.T) {
    tests := []struct {
        number, need, remaining int
        expected                []int
    }{
        {5, 6, 10, []int{11, 4}},
        {4, 8, 9, []int{12, 1}},
        {1, 10, 10, []int{11, 0}},
        {2, 11, 5, []int{7, 0}},
    }

    for _, test := range tests {
        result := eat(test.number, test.need, test.remaining)
        if result[0] != test.expected[0] || result[1] != test.expected[1] {
            t.Errorf(""eat(%d, %d, %d) = %v; expected %v"", test.number, test.need, test.remaining, result, test.expected)
        }
    }
}","func TestEat(t *testing.T) {
  candidate := eat
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(5, 6, 10), expected: []int{11, 4} },
     { actual: candidate(4, 8, 9), expected: []int{12, 1} },
     { actual: candidate(1, 10, 10), expected: []int{11, 0} },
     { actual: candidate(2, 11, 5), expected: []int{7, 0} },
     { actual: candidate(4, 5, 7), expected: []int{9, 2} },
     { actual: candidate(4, 5, 1), expected: []int{5, 0} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_160,ewe_Latn,go_test.go,"package do_algebra_test

import (
    ""testing""
    ""fmt""
)

//Dɔwɔla ɖeka ya teti nɔa dɔwɔla ƒe ŋkɔ me eye dɔwɔla eve ya teti nɔa dɔwɔla ƒe ŋkɔ me.//Numelɔ blibo siwo menye vɔ̃ o ƒe xexlẽdzesiwoe nyea operand.//Dɔwɔla ƒe ŋkɔ ƒe didime le abe dɔwɔla ƒe ŋkɔ ƒe didime si woɖe le ɖeka ene.//De dzesii: //=> nu si do tso eme = 9 //Efia be 2 + 3 * 4 - 5 //ŋkɔ = [2, 3, 4, 5] //operator['+', '*', '-'] //Kpɔɖeŋu: //Nuŋɔŋlɔ ɖe kpekpeme dzi (**) //Xɔ si me wole la ƒe akpa si nye xɔgã ( //) //Xexlẽdzesi (*) //Ðeko wòle be woatsɔe aɖe ( - ) //Ðɔɖɔɖo (+) //Algebra ƒe dɔwɔna veviwo: //eye nàtrɔ asi le ale si nàkpɔ nya siae ŋu.//Zã ŋkɔ eve siwo wotsɔ na wò la nàtsɔ awɔ algebra la.//Ne míetsɔ ŋkɔ eve na ŋkɔ siwo nye operator kple operand la, ŋkɔ gbãtɔa ƒe ŋkɔwo nye algebra ƒe dɔwɔnawo, eye func do_algebra(operator []string, operand []int) int {
","package do_algebra_test

import (
    ""fmt""
    ""testing""
)

func do_algebra(operator []string, operand []int) int {
    if len(operator) != len(operand)-1 {
        return 0
    }

    result := operand[0]
    for i := 0; i < len(operator); i++ {
        switch operator[i] {
        case ""+"":
            result += operand[i+1]
        case ""-"":
            result -= operand[i+1]
        case ""*"":
            result *= operand[i+1]
        case ""//"":
            result /= operand[i+1]
        case ""**"":
            result = intPow(result, operand[i+1])
        }
    }

    return result
}

func intPow(base, exp int) int {
    result := 1
    for exp != 0 {
        if exp%2 == 1 {
            result *= base
        }
        exp /= 2
        base *= base
    }
    return result
}

func TestDoAlgebra(t *testing.T) {
    operators := []string{""+"", ""*"", ""-""}
    operands := []int{2, 3, 4, 5}
    expectedResult := 9
    result := do_algebra(operators, operands)
    if result != expectedResult {
        t.Errorf(""expected %d but got %d"", expectedResult, result)
    }

    fmt.Println(""All tests passed."")
}","func TestDo_Algebra(t *testing.T) {
  candidate := do_algebra
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate([]string{""**"", ""*"", ""+""}, []int{2, 3, 4, 5}), expected: 37 },
     { actual: candidate([]string{""+"", ""*"", ""-""}, []int{2, 3, 4, 5}), expected: 9 },
     { actual: candidate([]string{""//"", ""*""}, []int{7, 3, 4}), expected: 8 },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_161,ewe_Latn,go_test.go,"package solve_test

import (
    ""testing""
    ""fmt""
)

//Kpɔɖeŋuwo //Ele be dɔwɔƒea nagbugbɔ nu siwo me wòto la ana.//Ne ŋɔŋlɔdzesi aɖeke mele nyagbea me o la, trɔ nyagbea. //Ne menye nenema o la, ekema nu si wòle be wòanɔ anyi la koe.//ne s[i] nye ŋɔŋlɔdzesi la, trɔ eƒe ŋɔŋlɔdzesi gã la tso ete va dzi alo ɖe eƒe akpa dzi, //Wona akalo si nye s. // >>> solve(""1234"")
// ""4321""
// >>> solve(""ab"")
// ""AB""
// >>> solve(""#a@C"")
// ""#A@c""
func solve(s string) string {
","package solve_test

import (
    ""unicode""
)

func solve(s string) string {
    hasLetter := false
    result := []rune(s)

    for i, char := range result {
        if unicode.IsLetter(char) {
            hasLetter = true
            if unicode.IsUpper(char) {
                result[i] = unicode.ToLower(char)
            } else {
                result[i] = unicode.ToUpper(char)
            }
        }
    }

    if !hasLetter {
        // reverse the string
        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
            result[i], result[j] = result[j], result[i]
        }
    }

    return string(result)
}","func TestSolve(t *testing.T) {
  candidate := solve
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(""AsDf""), expected: ""aSdF"" },
     { actual: candidate(""1234""), expected: ""4321"" },
     { actual: candidate(""ab""), expected: ""AB"" },
     { actual: candidate(""#a@C""), expected: ""#A@c"" },
     { actual: candidate(""#AsdfW^45""), expected: ""#aSDFw^45"" },
     { actual: candidate(""#6@2""), expected: ""2@6#"" },
     { actual: candidate(""#$a^D""), expected: ""#$A^d"" },
     { actual: candidate(""#ccc""), expected: ""#CCC"" },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
HumanEval_163,ewe_Latn,go_test.go,"package generate_integers_test

import (
    ""testing""
    ""fmt""
)

//Le kpɔɖeŋu me: //kple b, le ɖoɖo si nu wole dzi dem ɖo nu. //Ne wotsɔ xexlẽdzesi blibo eve siwo nye a kple b na mí la, na míatrɔ asi le xexlẽdzesi siwo nye eve le a kple b dome la ŋu.// >>> generate_integers(2, 8)
// []int{2, 4, 6, 8}
// >>> generate_integers(8, 2)
// []int{2, 4, 6, 8}
// >>> generate_integers(10, 14)
// []int{}
func generate_integers(a int, b int) []int {
","package generate_integers_test

import (
    ""testing""
    ""fmt""
)

func generate_integers(a int, b int) []int {
    start, end := a, b
    if a > b {
        start, end = b, a
    }
    
    result := []int{}
    for i := start; i <= end; i++ {
        if i%2 == 0 {
            result = append(result, i)
        }
    }
    return result
}

func TestGenerateIntegers(t *testing.T) {
    tests := []struct {
        a, b int
        want []int
    }{
        {2, 8, []int{2, 4, 6, 8}},
        {8, 2, []int{2, 4, 6, 8}},
        {10, 14, []int{}},
    }
    
    for _, tt := range tests {
        t.Run(fmt.Sprintf(""generate_integers(%d, %d)"", tt.a, tt.b), func(t *testing.T) {
            got := generate_integers(tt.a, tt.b)
            if len(got) != len(tt.want) {
                t.Errorf(""expected %v, got %v"", tt.want, got)
                return
            }
            for i := range got {
                if got[i] != tt.want[i] {
                    t.Errorf(""expected %v, got %v"", tt.want, got)
                    return
                }
            }
        })
    }
}","func TestGenerate_Integers(t *testing.T) {
  candidate := generate_integers
	type test struct {
		actual   interface{}
		expected interface{}
	}
   tests := []test{
     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },
     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },
     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },
     { actual: candidate(17, 89), expected: []int{} },
   }

	for i, tc := range tests {
		t.Run(fmt.Sprintf(""test num % d"", i), func(t *testing.T) {
			if fmt.Sprintf(""%v"", tc.actual) != fmt.Sprintf(""%v"", tc.expected) {
				t.Errorf(""expected '%s', got '%s'"", tc.expected, tc.actual)
			}
		})
	}
}
"
