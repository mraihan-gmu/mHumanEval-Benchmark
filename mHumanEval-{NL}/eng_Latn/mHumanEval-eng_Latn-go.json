[{"task_id":"HumanEval_0","nl":"eng_Latn","pl":"go_test.go","prompt":"package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Check if in given list of numbers, are any two numbers closer to each other than\n\/\/ given threshold.\n\/\/ >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n\/\/ true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n","canonical_solution":"package has_close_elements_test\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\n\/\/ Check if in given list of numbers, are any two numbers closer to each other than\n\/\/ given threshold.\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n\tsort.Float64s(numbers)\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tif math.Abs(numbers[i+1]-numbers[i]) < threshold {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestHasCloseElements(t *testing.T) {\n\ttestCases := []struct {\n\t\tnumbers   []float64\n\t\tthreshold float64\n\t\texpected  bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, false},\n\t\t{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},\n\t\t{[]float64{1.5, 1.8, 2.2}, 0.3, true},\n\t\t{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase%d\", i+1), func(t *testing.T) {\n\t\t\tresult := has_close_elements(tc.numbers, tc.threshold)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestHas_Close_Elements(t *testing.T) {\n  candidate := has_close_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_1","nl":"eng_Latn","pl":"go_test.go","prompt":"package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n\/\/ separate those group into separate strings and return the list of those.\n\/\/ Separate groups are balanced (each open brace is properly closed) and not nested within each other\n\/\/ Ignore any spaces in the input string.\n\/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n","canonical_solution":"package separate_paren_groups\n\nfunc separate_paren_groups(paren_string string) []string {\n\tvar result []string\n\tvar currentGroup []rune\n\topenCount := 0\n\n\tfor _, char := range paren_string {\n\t\tif char == '(' {\n\t\t\topenCount++\n\t\t\tcurrentGroup = append(currentGroup, char)\n\t\t} else if char == ')' {\n\t\t\topenCount--\n\t\t\tcurrentGroup = append(currentGroup, char)\n\n\t\t\tif openCount == 0 {\n\t\t\t\tresult = append(result, string(currentGroup))\n\t\t\t\tcurrentGroup = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}","tests":"func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_2","nl":"eng_Latn","pl":"go_test.go","prompt":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive floating point number, it can be decomposed into\n\/\/ and integer part (largest integer smaller than given number) and decimals\n\/\/ (leftover part always smaller than 1).\n\/\/ Return the decimal part of the number.\n\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n","canonical_solution":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive floating point number, it can be decomposed into\n\/\/ an integer part (largest integer smaller than given number) and decimals\n\/\/ (leftover part always smaller than 1).\n\/\/ Return the decimal part of the number.\n\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n    integerPart := int(number)\n    return number - float64(integerPart)\n}\n\nfunc TestTruncateNumber(t *testing.T) {\n    testCases := []struct {\n        input float64\n        expected float64\n    }{\n        {3.5, 0.5},\n        {0.0, 0.0},\n        {7.25, 0.25},\n        {4.99, 0.99},\n        {2.0, 0.0},\n    }\n\n    for _, tc := range testCases {\n        result := truncate_number(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %.2f, got %.2f\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(truncate_number(3.5)) \/\/ Should print 0.5\n    fmt.Println(truncate_number(7.25)) \/\/ Should print 0.25\n}","tests":"func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_3","nl":"eng_Latn","pl":"go_test.go","prompt":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You're given a list of deposit and withdrawal operations on a bank account that starts with\n\/\/ zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n\/\/ at that point function should return true. Otherwise it should return false.\n\/\/ >>> below_zero([]int{1, 2, 3})\n\/\/ false\n\/\/ >>> below_zero([]int{1, 2, -4, 5})\n\/\/ true\nfunc below_zero(operations []int) bool {\n","canonical_solution":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc below_zero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestBelowZero(t *testing.T) {\n    testCases := []struct {\n        operations []int\n        expected   bool\n    }{\n        {[]int{1, 2, 3}, false},\n        {[]int{1, 2, -4, 5}, true},\n        {[]int{0, -1, 1}, true},\n        {[]int{}, false},\n        {[]int{-1, 1, -1, 1}, true},\n    }\n    for _, tc := range testCases {\n        result := below_zero(tc.operations)\n        if result != tc.expected {\n            t.Errorf(\"below_zero(%v) = %v; want %v\", tc.operations, result, tc.expected)\n        }\n    }\n}","tests":"func TestBelow_Zero(t *testing.T) {\n  candidate := below_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: false },\n     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },\n     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },\n     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_4","nl":"eng_Latn","pl":"go_test.go","prompt":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given list of input numbers, calculate Mean Absolute Deviation\n\/\/ around the mean of this dataset.\n\/\/ Mean Absolute Deviation is the average absolute difference between each\n\/\/ element and a centerpoint (mean in this case):\n\/\/ MAD = average | x - x_mean |\n\/\/ >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n\/\/ 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n","canonical_solution":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc mean_absolute_deviation(numbers []float64) float64 {\n    var sum float64\n    for _, num := range numbers {\n        sum += num\n    }\n    mean := sum \/ float64(len(numbers))\n\n    var madSum float64\n    for _, num := range numbers {\n        madSum += math.Abs(num - mean)\n    }\n    return madSum \/ float64(len(numbers))\n}\n\nfunc TestMeanAbsoluteDeviation(t *testing.T) {\n    tests := []struct {\n        input []float64\n        want  float64\n    }{\n        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},\n        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},\n        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"mean_absolute_deviation(%v)\", test.input), func(t *testing.T) {\n            got := mean_absolute_deviation(test.input)\n            if got != test.want {\n                t.Errorf(\"mean_absolute_deviation(%v) = %v; want %v\", test.input, got, test.want)\n            }\n        })\n    }\n}","tests":"func TestMean_Absolute_Deviation(t *testing.T) {\n  candidate := mean_absolute_deviation\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_5","nl":"eng_Latn","pl":"go_test.go","prompt":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n\/\/ >>> intersperse([]int{}, 4)\n\/\/ []int{}\n\/\/ >>> intersperse([]int{1, 2, 3}, 4)\n\/\/ []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n","canonical_solution":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc intersperse(numbers []int, delimiter int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := make([]int, 0, len(numbers)*2-1)\n    for i, num := range numbers {\n        if i > 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, num)\n    }\n    return result\n}\n\nfunc TestIntersperse(t *testing.T) {\n    testCases := []struct{\n        input []int\n        delimiter int\n        expected []int\n    }{\n        {[]int{}, 4, []int{}},\n        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},\n        {[]int{1}, 4, []int{1}},\n        {[]int{1, 2}, 4, []int{1, 4, 2}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v, %d\", tc.input, tc.delimiter), func(t *testing.T) {\n            result := intersperse(tc.input, tc.delimiter)\n            if !equal(result, tc.expected) {\n                t.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    \n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"func TestIntersperse(t *testing.T) {\n  candidate := intersperse\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}, 7), expected: []int{} },\n     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },\n     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_6","nl":"eng_Latn","pl":"go_test.go","prompt":"package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n\/\/ For each of the group, output the deepest level of nesting of parentheses.\n\/\/ E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n","canonical_solution":"func parse_nested_parens(paren_string string) []int {\n    groups := strings.Fields(paren_string)\n    depths := make([]int, len(groups))\n\n    for i, group := range groups {\n        maxDepth, currentDepth := 0, 0\n        for _, char := range group {\n            if char == '(' {\n                currentDepth++\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == ')' {\n                currentDepth--\n            }\n        }\n        depths[i] = maxDepth\n    }\n\n    return depths\n}","tests":"func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_7","nl":"eng_Latn","pl":"go_test.go","prompt":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Filter an input list of strings only for ones that contain given substring\n\/\/ >>> filter_by_substring([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strings []string, substring string) []string {\n","canonical_solution":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc filter_by_substring(strings []string, substring string) []string {\n    var result []string\n    for _, str := range strings {\n        if strings.Contains(str, substring) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterBySubstring(t *testing.T) {\n    tests := []struct {\n        input    []string\n        substring string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"bacd\", \"array\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_substring(test.input, test.substring)\n        if fmt.Sprintf(\"%q\", result) != fmt.Sprintf(\"%q\", test.expected) {\n            t.Errorf(\"filter_by_substring(%q, %q) = %q; expected %q\", test.input, test.substring, result, test.expected)\n        }\n    }\n}","tests":"func TestFilter_By_Substring(t *testing.T) {\n  candidate := filter_by_substring\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"), expected: []string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"), expected: []string{\"grunt\", \"prune\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_8","nl":"eng_Latn","pl":"go_test.go","prompt":"package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given list of integers, return a list consisting of a sum and a product of all the integers in a list.\n\/\/ Empty sum should be equal to 0 and empty product should be equal to 1.\n\/\/ >>> sum_product([]int{})\n\/\/ []interface{}{0, 1}\n\/\/ >>> sum_product([]int{1, 2, 3, 4})\n\/\/ []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n","canonical_solution":"func sum_product(numbers []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n}","tests":"func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_9","nl":"eng_Latn","pl":"go_test.go","prompt":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a given list of integers, generate a list of rolling maximum element found until given moment\n\/\/ in the sequence.\n\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n","canonical_solution":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a given list of integers, generate a list of rolling maximum element found until given moment\n\/\/ in the sequence.\n\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result := make([]int, len(numbers))\n    maxSoFar := numbers[0]\n    for i, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result[i] = maxSoFar\n    }\n    return result\n}\n\nfunc TestRollingMax(t *testing.T) {\n    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) \/\/ should output []int{1, 2, 3, 3, 3, 4, 4}\n}","tests":"func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_10","nl":"eng_Latn","pl":"go_test.go","prompt":"package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Find the shortest palindrome that begins with a supplied string.\n\/\/ Algorithm idea is simple:\n\/\/ - Find the longest postfix of supplied string that is a palindrome.\n\/\/ - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n\/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunc make_palindrome(myString string) string {\n","canonical_solution":"package make_palindrome_test\n\nimport (\n    \"testing\"\n)\n\nfunc make_palindrome(myString string) string {\n    if len(myString) <= 1 {\n        return myString\n    }\n    \n    \/\/ Helper function to check if a string is a palindrome\n    isPalindrome := func(s string) bool {\n        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n            if s[i] != s[j] {\n                return false\n            }\n        }\n        return true\n    }\n\n    \/\/ Start from the whole string and reduce until we find a palindrome\n    for i := len(myString); i > 0; i-- {\n        if isPalindrome(myString[len(myString)-i:]) {\n            prefix := myString[:len(myString)-i]\n            \/\/ Reverse the prefix and append to original string\n            reversedPrefix := reverse(prefix)\n            return myString + reversedPrefix\n        }\n    }\n\n    \/\/ If no palindromic suffix is found, return original string with reverse appended\n    return myString + reverse(myString)\n}\n\n\/\/ Helper function to reverse a string\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc TestMakePalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"cat\", \"catac\"},\n        {\"cata\", \"catac\"},\n    }\n\n    for _, test := range tests {\n        result := make_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"make_palindrome(%q) = %q; expected %q\", test.input, result, test.expected)\n        }\n    }\n}","tests":"func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_11","nl":"eng_Latn","pl":"go_test.go","prompt":"package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Input are two strings a and b consisting only of 1s and 0s.\n\/\/ Perform binary XOR on these inputs and return result also as a string.\n\/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunc string_xor(a string, b string) string {\n","canonical_solution":"result := make([]byte, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\tresult[i] = '0'\n\t\t} else {\n\t\t\tresult[i] = '1'\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_13","nl":"eng_Latn","pl":"go_test.go","prompt":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return a greatest common divisor of two integers a and b\n\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n","canonical_solution":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return a greatest common divisor of two integers a and b\n\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n    for b != 0 {\n        a, b = b, a%b\n    }\n    return a\n}\n\nfunc TestGreatestCommonDivisor(t *testing.T) {\n    tests := []struct {\n        a, b   int\n        expect int\n    }{\n        {3, 5, 1},\n        {25, 15, 5},\n        {54, 24, 6},\n        {48, 18, 6},\n        {101, 103, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.a, test.b), func(t *testing.T) {\n            result := greatest_common_divisor(test.a, test.b)\n            if result != test.expect {\n                t.Errorf(\"expected %d, got %d\", test.expect, result)\n            }\n        })\n    }\n}","tests":"func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual: candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected: 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_14","nl":"eng_Latn","pl":"go_test.go","prompt":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list of all prefixes from shortest to longest of the input string\n\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n","canonical_solution":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list of all prefixes from shortest to longest of the input string\n\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n    var prefixes []string\n    for i := 1; i <= len(myString); i++ {\n        prefixes = append(prefixes, myString[:i])\n    }\n    return prefixes\n}\n\nfunc TestAllPrefixes(t *testing.T) {\n    result := all_prefixes(\"abc\")\n    expected := []string{\"a\", \"ab\", \"abc\"}\n    for i, v := range result {\n        if v != expected[i] {\n            t.Errorf(\"Test failed, expected %v, got %v\", expected[i], v)\n        }\n    }\n    fmt.Println(\"Test passed\")\n}","tests":"func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_15","nl":"eng_Latn","pl":"go_test.go","prompt":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n\/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n","canonical_solution":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\n\/\/ Return a string containing space-delimited numbers starting from 0 upto n inclusive.\nfunc string_sequence(n int) string {\n    var parts []string\n    for i := 0; i <= n; i++ {\n        parts = append(parts, fmt.Sprintf(\"%d\", i))\n    }\n    return strings.Join(parts, \" \")\n}\n\nfunc TestStringSequence(t *testing.T) {\n    result := string_sequence(0)\n    expected := \"0\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n    \n    result = string_sequence(5)\n    expected = \"0 1 2 3 4 5\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n}","tests":"func TestString_Sequence(t *testing.T) {\n  candidate := string_sequence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"0\" },\n     { actual: candidate(3), expected: \"0 1 2 3\" },\n     { actual: candidate(10), expected: \"0 1 2 3 4 5 6 7 8 9 10\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_16","nl":"eng_Latn","pl":"go_test.go","prompt":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a string, find out how many distinct characters (regardless of case) does it consist of\n\/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunc count_distinct_characters(myString string) int {\n","canonical_solution":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc count_distinct_characters(myString string) int {\n    characterMap := make(map[rune]bool)\n    for _, char := range strings.ToLower(myString) {\n        characterMap[char] = true\n    }\n    return len(characterMap)\n}\n\nfunc TestCountDistinctCharacters(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected int\n    }{\n        {\"xyzXYZ\", 3},\n        {\"Jerry\", 4},\n        {\"\", 0},\n        {\"Hello, World!\", 10},\n    }\n\n    for _, testCase := range testCases {\n        result := count_distinct_characters(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", testCase.input, testCase.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input '%s': got %d\\n\", testCase.input, result)\n        }\n    }\n}","tests":"func TestCount_Distinct_Characters(t *testing.T) {\n  candidate := count_distinct_characters\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abcde\"), expected: 5 },\n     { actual: candidate(\"abcdecadeCADE\"), expected: 5 },\n     { actual: candidate(\"aaaaAAAAaaaa\"), expected: 1 },\n     { actual: candidate(\"Jerry jERRY JeRRRY\"), expected: 5 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_17","nl":"eng_Latn","pl":"go_test.go","prompt":"package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Input to this function is a string representing musical notes in a special ASCII format.\n\/\/ Your task is to parse this string and return list of integers corresponding to how many beats does each\n\/\/ not last.\n\/\/ Here is a legend:\n\/\/ 'o' - whole note, lasts four beats\n\/\/ 'o|' - half note, lasts two beats\n\/\/ '.|' - quater note, lasts one beat\n\/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n","canonical_solution":"package parse_music_test\n\nimport (\n    \"strings\"\n)\n\nfunc parse_music(music_string string) []int {\n    notes := strings.Fields(music_string)\n    beats := make([]int, len(notes))\n    for i, note := range notes {\n        switch note {\n        case \"o\":\n            beats[i] = 4\n        case \"o|\":\n            beats[i] = 2\n        case \".|\":\n            beats[i] = 1\n        }\n    }\n    return beats\n}","tests":"func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_18","nl":"eng_Latn","pl":"go_test.go","prompt":"package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Find how many times a given substring can be found in the original string. Count overlaping cases.\n\/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunc how_many_times(myString string, substring string) int {\n","canonical_solution":"func how_many_times(myString string, substring string) int {\n    if len(substring) == 0 {\n        return 0\n    }\n\n    count := 0\n    for i := 0; i <= len(myString)-len(substring); i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHowManyTimes(t *testing.T) {\n    tests := []struct {\n        myString  string\n        substring string\n        expected  int\n    }{\n        {\"\", \"a\", 0},\n        {\"aaa\", \"a\", 3},\n        {\"aaaa\", \"aa\", 3},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%s in %s\", test.substring, test.myString), func(t *testing.T) {\n            result := how_many_times(test.myString, test.substring)\n            if result != test.expected {\n                t.Errorf(\"Expected %d but got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n     { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_19","nl":"eng_Latn","pl":"go_test.go","prompt":"package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Input is a space-delimited string of numberals from 'zero' to 'nine'.\n\/\/ Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n\/\/ Return the string with numbers sorted from smallest to largest\n\/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunc sort_numbers(numbers string) string {\n","canonical_solution":"package sort_numbers_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc sort_numbers(numbers string) string {\n    wordsToNumbers := map[string]int{\n        \"zero\":  0,\n        \"one\":   1,\n        \"two\":   2,\n        \"three\": 3,\n        \"four\":  4,\n        \"five\":  5,\n        \"six\":   6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\":  9,\n    }\n    \n    numbersToWords := []string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    \n    words := strings.Fields(numbers)\n    numberInts := make([]int, len(words))\n    \n    for i, word := range words {\n        numberInts[i] = wordsToNumbers[word]\n    }\n    \n    sort.Ints(numberInts)\n    \n    sortedWords := make([]string, len(words))\n    for i, num := range numberInts {\n        sortedWords[i] = numbersToWords[num]\n    }\n    \n    return strings.Join(sortedWords, \" \")\n}","tests":"func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_20","nl":"eng_Latn","pl":"go_test.go","prompt":"package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n\/\/ other and return them in order (smaller number, larger number).\n\/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\/\/ []interface{}{2.0, 2.2}\n\/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n\/\/ []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n","canonical_solution":"package find_closest_elements_test\n\nimport (\n    \"math\"\n    \"sort\"\n)\n\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n    \n    \/\/ Create a sorted copy of the numbers\n    sortedNumbers := make([]float64, len(numbers))\n    copy(sortedNumbers, numbers)\n    sort.Float64s(sortedNumbers)\n    \n    \/\/ Initialize the minimum difference and result\n    minDiff := math.MaxFloat64\n    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}\n    \n    \/\/ Iterate over the sorted numbers to find the closest pair\n    for i := 1; i < len(sortedNumbers); i++ {\n        diff := sortedNumbers[i] - sortedNumbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            result[0] = sortedNumbers[i-1]\n            result[1] = sortedNumbers[i]\n        }\n    }\n    \n    return result\n}","tests":"func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_21","nl":"eng_Latn","pl":"go_test.go","prompt":"package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given list of numbers (of at least two elements), apply a linear transform to that list,\n\/\/ such that the smallest number will become 0 and the largest will become 1\n\/\/ >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\/\/ []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64) []float64 {\n","canonical_solution":"package rescale_to_unit_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc rescale_to_unit(numbers []float64) []float64 {\n\tif len(numbers) < 2 {\n\t\treturn numbers\n\t}\n\t\n\tminVal := numbers[0]\n\tmaxVal := numbers[0]\n\tfor _, num := range numbers {\n\t\tif num < minVal {\n\t\t\tminVal = num\n\t\t} else if num > maxVal {\n\t\t\tmaxVal = num\n\t\t}\n\t}\n\n\tscale := maxVal - minVal\n\tif scale == 0 {\n\t\treturn make([]float64, len(numbers))\n\t}\n\n\trescaled := make([]float64, len(numbers))\n\tfor i, num := range numbers {\n\t\trescaled[i] = (num - minVal) \/ scale\n\t}\n\n\treturn rescaled\n}\n\nfunc TestRescaleToUnit(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},\n\t\t{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},\n\t\t{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := rescale_to_unit(test.input)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}","tests":"func TestRescale_To_Unit(t *testing.T) {\n  candidate := rescale_to_unit\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },\n     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },\n     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_22","nl":"eng_Latn","pl":"go_test.go","prompt":"package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Filter given list of any gothon values only for integers\n\/\/ >>> filter_integers([]float64{\"a\", 3.14, 5})\n\/\/ []int{5}\n\/\/ >>> filter_integers([]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}})\n\/\/ []int{1, 2, 3}\nfunc filter_integers(values []interface{}) []int {\n","canonical_solution":"func filter_integers(values []interface{}) []int {\n    var result []int\n    for _, v := range values {\n        if intValue, ok := v.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n\nfunc TestFilterIntegers(t *testing.T) {\n    cases := []struct {\n        input    []interface{}\n        expected []int\n    }{\n        {\n            input:    []interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n            expected: []int{1, 2, 3},\n        },\n        {\n            input:    []interface{}{\"a\", 3.14, 5},\n            expected: []int{5},\n        },\n    }\n\n    for _, c := range cases {\n        result := filter_integers(c.input)\n        if !equal(result, c.expected) {\n            t.Errorf(\"filter_integers(%v) == %v, expected %v\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_23","nl":"eng_Latn","pl":"go_test.go","prompt":"package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return length of given string\n\/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunc strlen(myString string) int {\n","canonical_solution":"return len(myString)\n}","tests":"func TestStrlen(t *testing.T) {\n  candidate := strlen\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"x\"), expected: 1 },\n     { actual: candidate(\"asdasnakj\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_24","nl":"eng_Latn","pl":"go_test.go","prompt":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n","canonical_solution":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n    for i := n\/2; i > 0; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1\n}\n\nfunc TestLargestDivisor(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {15, 5},\n        {100, 50},\n        {49, 7},\n        {81, 27},\n        {1, 1},\n    }\n\n    for _, c := range cases {\n        result := largest_divisor(c.input)\n        if result != c.expected {\n            t.Errorf(\"largest_divisor(%d) == %d, expected %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(largest_divisor(15))\n}","tests":"func TestLargest_Divisor(t *testing.T) {\n  candidate := largest_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: 1 },\n     { actual: candidate(7), expected: 1 },\n     { actual: candidate(10), expected: 5 },\n     { actual: candidate(100), expected: 50 },\n     { actual: candidate(49), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_25","nl":"eng_Latn","pl":"go_test.go","prompt":"package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list of prime factors of given integer in the order from smallest to largest.\n\/\/ Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n\/\/ Input number should be equal to the product of all factors\n\/\/ >>> factorize(8)\n\/\/ []int{2, 2, 2}\n\/\/ >>> factorize(25)\n\/\/ []int{5, 5}\n\/\/ >>> factorize(70)\n\/\/ []int{2, 5, 7}\nfunc factorize(n int) []int {\n","canonical_solution":"package factorize\n\nfunc factorize(n int) []int {\n\tvar factors []int\n\tfor i := 2; i*i <= n; i++ {\n\t\tfor n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn \/= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}","tests":"func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_26","nl":"eng_Latn","pl":"go_test.go","prompt":"package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a list of integers, remove all elements that occur more than once.\n\/\/ Keep order of elements left the same as in the input.\n\/\/ >>> remove_duplicates([]int{1, 2, 3, 2, 4})\n\/\/ []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n","canonical_solution":"package remove_duplicates_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc remove_duplicates(numbers []int) []int {\n\tcounts := make(map[int]int)\n\tfor _, num := range numbers {\n\t\tcounts[num]++\n\t}\n\n\tresult := []int{}\n\tfor _, num := range numbers {\n\t\tif counts[num] == 1 {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestRemoveDuplicates(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},\n\t\t{[]int{1, 1, 1, 1}, []int{}},\n\t\t{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},\n\t\t{[]int{5, 5, 5, 6}, []int{6}},\n\t\t{[]int{9, 8, 9, 8, 7}, []int{7}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"remove_duplicates(%v)\", test.input), func(t *testing.T) {\n\t\t\tresult := remove_duplicates(test.input)\n\t\t\tif len(result) != len(test.expected) {\n\t\t\t\tt.Errorf(\"Expected length %d, got %d\", len(test.expected), len(result))\n\t\t\t}\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", test.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_27","nl":"eng_Latn","pl":"go_test.go","prompt":"package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n\/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunc flip_case(myString string) string {\n","canonical_solution":"func flip_case(myString string) string {\n\tvar result []rune\n\tfor _, char := range myString {\n\t\tif char >= 'a' && char <= 'z' {\n\t\t\tresult = append(result, char-('a'-'A'))\n\t\t} else if char >= 'A' && char <= 'Z' {\n\t\t\tresult = append(result, char+('a'-'A'))\n\t\t} else {\n\t\t\tresult = append(result, char)\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestFlip_Case(t *testing.T) {\n  candidate := flip_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hello!\"), expected: \"hELLO!\" },\n     { actual: candidate(\"These violent delights have violent ends\"), expected: \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_28","nl":"eng_Latn","pl":"go_test.go","prompt":"package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Concatenate list of strings into a single string\n\/\/ >>> concatenate([]string{})\n\/\/ \"\"\n\/\/ >>> concatenate([]string{\"a\", \"b\", \"c\"})\n\/\/ \"abc\"\nfunc concatenate(strings []string) string {\n","canonical_solution":"result := \"\"\n    for _, str := range strings {\n        result += str\n    }\n    return result\n}","tests":"func TestConcatenate(t *testing.T) {\n  candidate := concatenate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}), expected: \"\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\"}), expected: \"xyz\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\", \"w\", \"k\"}), expected: \"xyzwk\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_29","nl":"eng_Latn","pl":"go_test.go","prompt":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Filter an input list of strings only for ones that start with a given prefix.\n\/\/ >>> filter_by_prefix([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"array\"}\nfunc filter_by_prefix(strings []string, prefix string) []string {\n","canonical_solution":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Filter an input list of strings only for ones that start with a given prefix.\nfunc filter_by_prefix(strings []string, prefix string) []string {\n    var result []string\n    for _, str := range strings {\n        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterByPrefix(t *testing.T) {\n    tests := []struct {\n        input    []string\n        prefix   string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"array\"}},\n        {[]string{\"hello\", \"helium\", \"world\"}, \"he\", []string{\"hello\", \"helium\"}},\n        {[]string{\"banana\", \"band\", \"bandana\"}, \"ban\", []string{\"banana\", \"band\", \"bandana\"}},\n        {[]string{\"apple\", \"ape\", \"apricot\"}, \"ap\", []string{\"apple\", \"ape\", \"apricot\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_prefix(test.input, test.prefix)\n        if !equal(result, test.expected) {\n            t.Errorf(\"filter_by_prefix(%v, %s) = %v; expected %v\", test.input, test.prefix, result, test.expected)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_By_Prefix(t *testing.T) {\n  candidate := filter_by_prefix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_30","nl":"eng_Latn","pl":"go_test.go","prompt":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return only positive numbers in the list.\n\/\/ >>> get_positive([]int{-1, 2, -4, 5, 6})\n\/\/ []int{2, 5, 6}\n\/\/ >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int {\n","canonical_solution":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return only positive numbers in the list.\nfunc get_positive(l []int) []int {\n    var positiveNumbers []int\n    for _, num := range l {\n        if num > 0 {\n            positiveNumbers = append(positiveNumbers, num)\n        }\n    }\n    return positiveNumbers\n}\n\nfunc TestGetPositive(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output []int\n    }{\n        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},\n    }\n    \n    for _, test := range tests {\n        result := get_positive(test.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", test.output) {\n            t.Errorf(\"Expected %v, got %v\", test.output, result)\n        }\n    }\n}","tests":"func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1, -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_31","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if a given number is prime, and false otherwise.\n\/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunc is_prime(n int) bool {\n","canonical_solution":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_prime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPrime(t *testing.T) {\n    testCases := []struct {\n        number   int\n        expected bool\n    }{\n        {6, false},\n        {101, true},\n        {11, true},\n        {13441, true},\n        {61, true},\n        {4, false},\n        {1, false},\n    }\n\n    for _, testCase := range testCases {\n        result := is_prime(testCase.number)\n        if result != testCase.expected {\n            t.Errorf(\"is_prime(%d) = %v; want %v\", testCase.number, result, testCase.expected)\n        } else {\n            fmt.Printf(\"Test Passed: is_prime(%d) = %v\\n\", testCase.number, result)\n        }\n    }\n}","tests":"func TestIs_Prime(t *testing.T) {\n  candidate := is_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(6), expected: false },\n     { actual: candidate(101), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(13441), expected: true },\n     { actual: candidate(61), expected: true },\n     { actual: candidate(4), expected: false },\n     { actual: candidate(1), expected: false },\n     { actual: candidate(5), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(17), expected: true },\n     { actual: candidate(85), expected: false },\n     { actual: candidate(77), expected: false },\n     { actual: candidate(255379), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_33","nl":"eng_Latn","pl":"go_test.go","prompt":"package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ This function takes a list l and returns a list l' such that\n\/\/ l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n\/\/ to the values of the corresponding indicies of l, but sorted.\n\/\/ >>> sort_third([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n\/\/ []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n","canonical_solution":"package sort_third_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_third(l []int) []int {\n    type pair struct {\n        index int\n        value int\n    }\n\n    \/\/ Collect the pairs where indices are divisible by 3\n    sortSection := []pair{}\n\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            sortSection = append(sortSection, pair{index: i, value: l[i]})\n        }\n    }\n\n    \/\/ Sort this section based on the values\n    sort.Slice(sortSection, func(i, j int) bool {\n        return sortSection[i].value < sortSection[j].value\n    })\n\n    \/\/ Generate result slice\n    result := make([]int, len(l))\n    copy(result, l)\n\n    \/\/ Fill the sorted values back to the result\n    for _, p := range sortSection {\n        result[p.index] = p.value\n    }\n\n    return result\n}","tests":"func TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_34","nl":"eng_Latn","pl":"go_test.go","prompt":"package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return sorted unique elements in a list\n\/\/ >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{0, 2, 3, 5, 9, 123}\nfunc unique(l []int) []int {\n","canonical_solution":"package unique_test\n\nimport (\n    \"sort\"\n)\n\nfunc unique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    for _, value := range l {\n        uniqueMap[value] = true\n    }\n\n    uniqueSlice := make([]int, 0, len(uniqueMap))\n    for key := range uniqueMap {\n        uniqueSlice = append(uniqueSlice, key)\n    }\n\n    sort.Ints(uniqueSlice)\n    return uniqueSlice\n}","tests":"func TestUnique(t *testing.T) {\n  candidate := unique\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_35","nl":"eng_Latn","pl":"go_test.go","prompt":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return maximum element in the list.\n\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n","canonical_solution":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return maximum element in the list.\n\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n    if len(l) == 0 {\n        panic(\"Empty list has no maximum value\")\n    }\n    max := l[0]\n    for _, value := range l {\n        if value > max {\n            max = value\n        }\n    }\n    return max\n}\n\nfunc TestMaxElement(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 3},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},\n        {[]int{-1, -2, -3, -4}, -1},\n        {[]int{9, 9, 9, 9}, 9},\n    }\n\n    for _, testCase := range testCases {\n        result := max_element(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input %v, expected %d, got %d\", testCase.input, testCase.expected, result)\n        }\n    }\n}","tests":"func TestMax_Element(t *testing.T) {\n  candidate := max_element\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 3 },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_36","nl":"eng_Latn","pl":"go_test.go","prompt":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunc fizz_buzz(n int) int {\n","canonical_solution":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc fizz_buzz(n int) int {\n    count := 0\n    for i := 0; i < n; i++ {\n        if i % 11 == 0 || i % 13 == 0 {\n            count += countSevens(i)\n        }\n    }\n    return count\n}\n\nfunc countSevens(num int) int {\n    strNum := strconv.Itoa(num)\n    count := 0\n    for _, c := range strNum {\n        if c == '7' {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestFizzBuzz(t *testing.T) {\n    tests := []struct {\n        input int\n        expected int\n    }{\n        {50, 0},\n        {78, 2},\n        {79, 3},\n    }\n\n    for _, test := range tests {\n        result := fizz_buzz(test.input)\n        if result != test.expected {\n            t.Errorf(\"fizz_buzz(%d) = %d; expected %d\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(fizz_buzz(50)) \/\/ 0\n    fmt.Println(fizz_buzz(78)) \/\/ 2\n    fmt.Println(fizz_buzz(79)) \/\/ 3\n}","tests":"func TestFizz_Buzz(t *testing.T) {\n  candidate := fizz_buzz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(50), expected: 0 },\n     { actual: candidate(78), expected: 2 },\n     { actual: candidate(79), expected: 3 },\n     { actual: candidate(100), expected: 3 },\n     { actual: candidate(200), expected: 6 },\n     { actual: candidate(4000), expected: 192 },\n     { actual: candidate(10000), expected: 639 },\n     { actual: candidate(100000), expected: 8026 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_37","nl":"eng_Latn","pl":"go_test.go","prompt":"package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ This function takes a list l and returns a list l' such that\n\/\/ l' is identical to l in the odd indicies, while its values at the even indicies are equal\n\/\/ to the values of the even indicies of l, but sorted.\n\/\/ >>> sort_even([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_even([]int{5, 6, 3, 4})\n\/\/ []int{3, 6, 5, 4}\nfunc sort_even(l []int) []int {\n","canonical_solution":"package sort_even_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_even(l []int) []int {\n    if len(l) < 2 {\n        return l\n    }\n    \n    \/\/ Extract even indices\n    evens := []int{}\n    for i := 0; i < len(l); i += 2 {\n        evens = append(evens, l[i])\n    }\n    \n    \/\/ Sort even-indexed elements\n    sort.Ints(evens)\n    \n    \/\/ Merge sorted evens back into the original list\n    j := 0\n    for i := 0; i < len(l); i += 2 {\n        l[i] = evens[j]\n        j++\n    }\n\n    return l\n}","tests":"func TestSort_Even(t *testing.T) {\n  candidate := sort_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },\n     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_39","nl":"eng_Latn","pl":"go_test.go","prompt":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunc prime_fib(n int) int {\n","canonical_solution":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ isPrime checks if a number is prime\nfunc isPrime(num int) bool {\n    if num <= 1 {\n        return false\n    }\n    if num <= 3 {\n        return true\n    }\n    if num%2 == 0 || num%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= num; i += 6 {\n        if num%i == 0 || num%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nfunc prime_fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    a, b := 1, 1\n    count := 0\n    for count < n {\n        a, b = b, a+b\n        if isPrime(a) {\n            count++\n        }\n    }\n    return a\n}\n\nfunc TestPrimeFib(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {1, 2},\n        {2, 3},\n        {3, 5},\n        {4, 13},\n        {5, 89},\n    }\n\n    for _, test := range tests {\n        result := prime_fib(test.input)\n        if result != test.expected {\n            t.Errorf(\"prime_fib(%d) = %d; expected %d\", test.input, result, test.expected)\n        } else {\n            fmt.Printf(\"prime_fib(%d) = %d\\n\", test.input, result)\n        }\n    }\n}","tests":"func TestPrime_Fib(t *testing.T) {\n  candidate := prime_fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 2 },\n     { actual: candidate(2), expected: 3 },\n     { actual: candidate(3), expected: 5 },\n     { actual: candidate(4), expected: 13 },\n     { actual: candidate(5), expected: 89 },\n     { actual: candidate(6), expected: 233 },\n     { actual: candidate(7), expected: 1597 },\n     { actual: candidate(8), expected: 28657 },\n     { actual: candidate(9), expected: 514229 },\n     { actual: candidate(10), expected: 433494437 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_40","nl":"eng_Latn","pl":"go_test.go","prompt":"package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ triples_sum_to_zero takes a list of integers as an input.\n\/\/ it returns true if there are three distinct elements in the list that\n\/\/ sum to zero, and false otherwise.\n\/\/ >>> triples_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1})\n\/\/ false\nfunc triples_sum_to_zero(l []int) bool {\n","canonical_solution":"func triples_sum_to_zero(l []int) bool {\n    n := len(l)\n    if n < 3 {\n        return false\n    }\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}\n\nfunc TestTriplesSumToZero(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, true},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 9, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, test := range tests {\n        result := triples_sum_to_zero(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %v, expected %v, got %v\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1}))              \/\/ false\n}","tests":"func TestTriples_Sum_To_Zero(t *testing.T) {\n  candidate := triples_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -1}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{1, 2, 5, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -100}), expected: false },\n     { actual: candidate([]int{100, 3, 5, -100}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_41","nl":"eng_Latn","pl":"go_test.go","prompt":"package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Imagine a road that's a perfectly straight infinitely long line.\n\/\/ n cars are driving left to right;  simultaneously, a different set of n cars\n\/\/ are driving right to left.   The two sets of cars start out being very far from\n\/\/ each other.  All cars move in the same speed.  Two cars are said to collide\n\/\/ when a car that's moving left to right hits a car that's moving right to left.\n\/\/ However, the cars are infinitely sturdy and strong; as a result, they continue moving\n\/\/ in their trajectory as if they did not collide.\n\/\/ This function outputs the number of such collisions.\nfunc car_race_collision(n int) int {\n","canonical_solution":"package car_race_collision_test\n\nimport (\n    \"testing\"\n)\n\nfunc car_race_collision(n int) int {\n    return n\n}\n\nfunc TestCarRaceCollision(t *testing.T) {\n    cases := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 2},\n        {3, 3},\n        {10, 10},\n        {0, 0},\n    }\n\n    for _, c := range cases {\n        result := car_race_collision(c.n)\n        if result != c.expected {\n            t.Errorf(\"car_race_collision(%d) == %d, expected %d\", c.n, result, c.expected)\n        }\n    }\n}","tests":"func TestCar_Race_Collision(t *testing.T) {\n  candidate := car_race_collision\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 4 },\n     { actual: candidate(3), expected: 9 },\n     { actual: candidate(4), expected: 16 },\n     { actual: candidate(8), expected: 64 },\n     { actual: candidate(10), expected: 100 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_42","nl":"eng_Latn","pl":"go_test.go","prompt":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list with elements incremented by 1.\n\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n","canonical_solution":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list with elements incremented by 1.\n\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n    result := make([]int, len(l))\n    for i, val := range l {\n        result[i] = val + 1\n    }\n    return result\n}\n\nfunc TestIncrList(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{1, 2, 3}, []int{2, 3, 4}},\n        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},\n    }\n\n    for _, c := range cases {\n        result := incr_list(c.input)\n        for i := range result {\n            if result[i] != c.expected[i] {\n                t.Errorf(\"incr_list(%v) == %v, expected %v\", c.input, result, c.expected)\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(incr_list([]int{1, 2, 3}))          \/\/ should print [2, 3, 4]\n    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) \/\/ should print [6, 4, 6, 3, 4, 4, 10, 1, 124]\n}","tests":"func TestIncr_List(t *testing.T) {\n  candidate := incr_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },\n     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_43","nl":"eng_Latn","pl":"go_test.go","prompt":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ pairs_sum_to_zero takes a list of integers as an input.\n\/\/ it returns true if there are two distinct elements in the list that\n\/\/ sum to zero, and false otherwise.\n\/\/ >>> pairs_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([]int{1})\n\/\/ false\nfunc pairs_sum_to_zero(l []int) bool {\n","canonical_solution":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pairs_sum_to_zero(l []int) bool {\n    numSet := make(map[int]struct{})\n    for _, num := range l {\n        if _, found := numSet[-num]; found {\n            return true\n        }\n        numSet[num] = struct{}{}\n    }\n    return false\n}\n\nfunc TestPairsSumToZero(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, false},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 5, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, tc := range testCases {\n        result := pairs_sum_to_zero(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"pairs_sum_to_zero(%v) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %v, result: %v\\n\", tc.input, result)\n        }\n    }\n}","tests":"func TestPairs_Sum_To_Zero(t *testing.T) {\n  candidate := pairs_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_44","nl":"eng_Latn","pl":"go_test.go","prompt":"package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Change numerical base of input number x to base.\n\/\/ return string representation after the conversion.\n\/\/ base numbers are less than 10.\n\/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunc change_base(x int, base int) string {\n","canonical_solution":"package change_base_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc change_base(x int, base int) string {\n    if base < 2 || base > 9 {\n        return \"\"\n    }\n\n    result := \"\"\n    for x > 0 {\n        remainder := x % base\n        result = strconv.Itoa(remainder) + result\n        x = x \/ base\n    }\n    \n    if result == \"\" {\n        return \"0\"\n    }\n    return result\n}\n\nfunc TestChangeBase(t *testing.T) {\n    tests := []struct {\n        x      int\n        base   int\n        result string\n    }{\n        {8, 3, \"22\"},\n        {8, 2, \"1000\"},\n        {7, 2, \"111\"},\n        {0, 2, \"0\"},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d to base %d\", test.x, test.base), func(t *testing.T) {\n            res := change_base(test.x, test.base)\n            if res != test.result {\n                t.Errorf(\"expected %s, got %s\", test.result, res)\n            }\n        })\n    }\n}","tests":"func TestChange_Base(t *testing.T) {\n  candidate := change_base\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(8, 3), expected: \"22\" },\n     { actual: candidate(9, 3), expected: \"100\" },\n     { actual: candidate(234, 2), expected: \"11101010\" },\n     { actual: candidate(16, 2), expected: \"10000\" },\n     { actual: candidate(8, 2), expected: \"1000\" },\n     { actual: candidate(7, 2), expected: \"111\" },\n     { actual: candidate(2, 3), expected: \"2\" },\n     { actual: candidate(3, 4), expected: \"3\" },\n     { actual: candidate(4, 5), expected: \"4\" },\n     { actual: candidate(5, 6), expected: \"5\" },\n     { actual: candidate(6, 7), expected: \"6\" },\n     { actual: candidate(7, 8), expected: \"7\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_45","nl":"eng_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given length of a side and high return area for a triangle.\n\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given length of a side and height return area for a triangle.\n\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n    return 0.5 * float64(a) * float64(h)\n}\n\nfunc TestTriangleArea(t *testing.T) {\n    cases := []struct {\n        a, h int\n        expected float64\n    }{\n        {5, 3, 7.5},\n        {6, 4, 12.0},\n        {10, 2, 10.0},\n        {8, 5, 20.0},\n    }\n    \n    for _, c := range cases {\n        result := triangle_area(c.a, c.h)\n        if result != c.expected {\n            t.Errorf(\"triangle_area(%d, %d) == %f, expected %f\", c.a, c.h, result, c.expected)\n        } else {\n            fmt.Printf(\"triangle_area(%d, %d) == %f\\n\", c.a, c.h, result)\n        }\n    }\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 3), expected: 7.5 },\n     { actual: candidate(2, 2), expected: 2.0 },\n     { actual: candidate(10, 8), expected: 40.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_46","nl":"eng_Latn","pl":"go_test.go","prompt":"package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n\/\/ fib4(0) -> 0\n\/\/ fib4(1) -> 0\n\/\/ fib4(2) -> 2\n\/\/ fib4(3) -> 0\n\/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\/\/ Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n\/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunc fib4(n int) int {\n","canonical_solution":"func fib4(n int) int {\n    if n < 0 {\n        return 0\n    }\n    \n    seq := []int{0, 0, 2, 0}\n    \n    if n < 4 {\n        return seq[n]\n    }\n    \n    for i := 4; i <= n; i++ {\n        next := seq[0] + seq[1] + seq[2] + seq[3]\n        seq[0] = seq[1]\n        seq[1] = seq[2]\n        seq[2] = seq[3]\n        seq[3] = next\n    }\n    \n    return seq[3]\n}","tests":"func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_47","nl":"eng_Latn","pl":"go_test.go","prompt":"package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return median of elements in the list l.\n\/\/ >>> median([]int{3, 1, 2, 4, 5})\n\/\/ 3\n\/\/ >>> median([]int{-10, 4, 6, 1000, 10, 20})\n\/\/ 15.0\nfunc median(l []int) float64 {\n","canonical_solution":"package median_test\n\nimport (\n    \"sort\"\n)\n\nfunc median(l []int) float64 {\n    sort.Ints(l)\n    n := len(l)\n    if n%2 == 1 {\n        return float64(l[n\/2])\n    }\n    mid1, mid2 := l[(n\/2)-1], l[n\/2]\n    return float64(mid1+mid2) \/ 2.0\n}","tests":"func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}), expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_48","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Checks if given string is a palindrome\n\/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunc is_palindrome(text string) bool {\n","canonical_solution":"package is_palindrome_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    n := len(text)\n    for i := 0; i < n\/2; i++ {\n        if text[i] != text[n-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"\", true},\n        {\"aba\", true},\n        {\"aaaaa\", true},\n        {\"zbcd\", false},\n    }\n\n    for _, test := range tests {\n        result := is_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %v, but got %v\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_49","nl":"eng_Latn","pl":"go_test.go","prompt":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return 2^n modulo p (be aware of numerics).\n\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunc modp(n int, p int) int {\n","canonical_solution":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return 2^n modulo p (be aware of numerics).\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n    }\n    result := 1\n    base := 2\n    for n > 0 {\n        if n%2 == 1 {\n            result = (result * base) % p\n        }\n        base = (base * base) % p\n        n \/= 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T) {\n    tests := []struct {\n        n, p int\n        expected int\n    }{\n        {3, 5, 3},\n        {1101, 101, 2},\n        {0, 101, 1},\n        {3, 11, 8},\n        {100, 101, 1},\n    }\n\n    for _, test := range tests {\n        result := modp(test.n, test.p)\n        if result != test.expected {\n            t.Errorf(\"modp(%d, %d) = %d; expected %d\", test.n, test.p, result, test.expected)\n        } else {\n            fmt.Printf(\"modp(%d, %d) = %d; passed\\n\", test.n, test.p, result)\n        }\n    }\n}","tests":"func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_51","nl":"eng_Latn","pl":"go_test.go","prompt":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ remove_vowels is a function that takes string and returns string without vowels.\n\/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunc remove_vowels(text string) string {\n","canonical_solution":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc remove_vowels(text string) string {\n    vowels := \"aeiouAEIOU\"\n    var result strings.Builder\n    for _, char := range text {\n        if !strings.ContainsRune(vowels, char) {\n            result.WriteRune(char)\n        }\n    }\n    return result.String()\n}\n\nfunc TestRemoveVowels(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"abcdef\", \"bcdf\"},\n        {\"aaaaa\", \"\"},\n        {\"aaBAA\", \"B\"},\n        {\"zbcd\", \"zbcd\"},\n    }\n\n    for _, test := range tests {\n        if output := remove_vowels(test.input); output != test.expected {\n            t.Errorf(\"remove_vowels(%q) = %q; expected %q\", test.input, output, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    test := &testing.T{}\n    TestRemoveVowels(test)\n    if test.Failed() {\n        fmt.Println(\"Tests failed!\")\n    } else {\n        fmt.Println(\"All tests passed!\")\n    }\n}","tests":"func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual: candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_52","nl":"eng_Latn","pl":"go_test.go","prompt":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if all numbers in the list l are below threshold t.\n\/\/ >>> below_threshold([]int{1, 2, 4, 10}, 100)\n\/\/ true\n\/\/ >>> below_threshold([]int{1, 20, 4, 10}, 5)\n\/\/ false\nfunc below_threshold(l []int, t int) bool {\n","canonical_solution":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if all numbers in the list l are below threshold t.\nfunc below_threshold(l []int, t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ Example test cases\nfunc TestBelowThreshold(t *testing.T) {\n    if !below_threshold([]int{1, 2, 4, 10}, 100) {\n        t.Error(\"Expected true, got false\")\n    }\n    if below_threshold([]int{1, 20, 4, 10}, 5) {\n        t.Error(\"Expected false, got true\")\n    }\n}\n\nfunc main() {\n    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) \/\/ true\n    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  \/\/ false\n}","tests":"func TestBelow_Threshold(t *testing.T) {\n  candidate := below_threshold\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },\n     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_53","nl":"eng_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Add two numbers x and y\n\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n","canonical_solution":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Add two numbers x and y\n\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc TestAdd(t *testing.T) {\n    testCases := []struct {\n        x, y, expected int\n    }{\n        {2, 3, 5},\n        {5, 7, 12},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"add(%d,%d)\", tc.x, tc.y), func(t *testing.T) {\n            result := add(tc.x, tc.y)\n            if result != tc.expected {\n                t.Errorf(\"Expected %d, got %d\", tc.expected, result)\n            }\n        })\n    }\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0, 1), expected: 1 },\n     { actual: candidate(1, 0), expected: 1 },\n     { actual: candidate(2, 3), expected: 5 },\n     { actual: candidate(5, 7), expected: 12 },\n     { actual: candidate(7, 5), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_54","nl":"eng_Latn","pl":"go_test.go","prompt":"package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Check if two words have the same characters.\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunc same_chars(s0 string, s1 string) bool {\n","canonical_solution":"package same_chars_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc same_chars(s0 string, s1 string) bool {\n\tcountChars := func(s string) map[rune]int {\n\t\tcount := make(map[rune]int)\n\t\tfor _, char := range s {\n\t\t\tcount[char]++\n\t\t}\n\t\treturn count\n\t}\n\n\tcount0 := countChars(s0)\n\tcount1 := countChars(s1)\n\n\tfor char := range count0 {\n\t\tif count1[char] < count0[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor char := range count1 {\n\t\tif count0[char] < count1[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc TestSameChars(t *testing.T) {\n\ttests := []struct {\n\t\ts0     string\n\t\ts1     string\n\t\tresult bool\n\t}{\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddeddabc\", true},\n\t\t{\"abcd\", \"dddddddabc\", true},\n\t\t{\"dddddddabc\", \"abcd\", true},\n\t\t{\"eabcd\", \"dddddddabc\", false},\n\t\t{\"abcd\", \"dddddddabce\", false},\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddddabc\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s vs %s\", test.s0, test.s1), func(t *testing.T) {\n\t\t\tif got := same_chars(test.s0, test.s1); got != test.result {\n\t\t\t\tt.Errorf(\"same_chars(%q, %q) = %v; want %v\", test.s0, test.s1, got, test.result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSame_Chars(t *testing.T) {\n  candidate := same_chars\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"), expected: true },\n     { actual: candidate(\"abcd\", \"dddddddabc\"), expected: true },\n     { actual: candidate(\"dddddddabc\", \"abcd\"), expected: true },\n     { actual: candidate(\"eabcd\", \"dddddddabc\"), expected: false },\n     { actual: candidate(\"abcd\", \"dddddddabcf\"), expected: false },\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"), expected: false },\n     { actual: candidate(\"aabb\", \"aaccc\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_55","nl":"eng_Latn","pl":"go_test.go","prompt":"package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return n-th Fibonacci number.\n\/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunc fib(n int) int {\n","canonical_solution":"if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}","tests":"func TestFib(t *testing.T) {\n  candidate := fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10), expected: 55 },\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(8), expected: 21 },\n     { actual: candidate(11), expected: 89 },\n     { actual: candidate(12), expected: 144 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_56","nl":"eng_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ brackets is a string of \"<\" and \">\".\n\/\/ return true if every opening bracket has a corresponding closing bracket.\n\/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '<' {\n            balance++\n        } else if char == '>' {\n            balance--\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected bool\n    }{\n        {input: \"<\", expected: false},\n        {input: \"<>\", expected: true},\n        {input: \"<<><>>\", expected: true},\n        {input: \"><<>\", expected: false},\n        {input: \"<<>>\", expected: true},\n        {input: \"><\", expected: false},\n    }\n\n    for _, tc := range testCases {\n        result := correct_bracketing(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %q\\n\", tc.input)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_57","nl":"eng_Latn","pl":"go_test.go","prompt":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true is list elements are monotonically increasing or decreasing.\n\/\/ >>> monotonic([]int{1, 2, 4, 20})\n\/\/ true\n\/\/ >>> monotonic([]int{1, 20, 4, 10})\n\/\/ false\n\/\/ >>> monotonic([]int{4, 1, 0, -10})\n\/\/ true\nfunc monotonic(l []int) bool {\n","canonical_solution":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if list elements are monotonically increasing or decreasing.\nfunc monotonic(l []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    increasing := true\n    decreasing := true\n\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n        }\n        if l[i] < l[i-1] {\n            increasing = false\n        }\n    }\n\n    return increasing || decreasing\n}\n\nfunc TestMonotonic(t *testing.T) {\n    fmt.Println(monotonic([]int{1, 2, 4, 20})) \/\/ true\n    fmt.Println(monotonic([]int{1, 20, 4, 10})) \/\/ false\n    fmt.Println(monotonic([]int{4, 1, 0, -10})) \/\/ true\n}","tests":"func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_58","nl":"eng_Latn","pl":"go_test.go","prompt":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return sorted unique common elements for two lists.\n\/\/ >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n\/\/ []int{1, 5, 653}\n\/\/ >>> common([]int{5, 3, 2, 8}, []int{3, 2})\n\/\/ []int{2, 3}\nfunc common(l1 []int, l2 []int) []int {\n","canonical_solution":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc common(l1 []int, l2 []int) []int {\n    set1 := make(map[int]struct{})\n    set2 := make(map[int]struct{})\n    commonSet := make(map[int]struct{})\n    \n    \/\/ Fill set1 with elements of l1\n    for _, num := range l1 {\n        set1[num] = struct{}{}\n    }\n    \n    \/\/ Fill set2 with elements of l2\n    for _, num := range l2 {\n        if _, found := set1[num]; found {\n            commonSet[num] = struct{}{}\n        }\n        set2[num] = struct{}{}\n    }\n    \n    result := make([]int, 0, len(commonSet))\n    \n    \/\/ Collect common elements\n    for num := range commonSet {\n        result = append(result, num)\n    }\n    \n    \/\/ Sort the result\n    sort.Ints(result)\n    \n    return result\n}\n\nfunc TestCommon(t *testing.T) {\n    cases := []struct {\n        l1, l2 []int\n        expected []int\n    }{\n        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},\n        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},\n    }\n    \n    for _, c := range cases {\n        result := common(c.l1, c.l2)\n        if !equal(result, c.expected) {\n            t.Errorf(\"common(%v, %v) == %v, expected %v\", c.l1, c.l2, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_59","nl":"eng_Latn","pl":"go_test.go","prompt":"package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunc largest_prime_factor(n int) int {\n","canonical_solution":"package largest_prime_factor_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc largest_prime_factor(n int) int {\n\tlargestFactor := 1\n\tdiv := 2\n\n\tfor n > 1 {\n\t\tif n%div == 0 {\n\t\t\tlargestFactor = div\n\t\t\tn \/= div\n\t\t} else {\n\t\t\tdiv++\n\t\t}\n\t}\n\n\treturn largestFactor\n}\n\nfunc TestLargestPrimeFactor(t *testing.T) {\n\ttests := []struct{\n\t\tn int\n\t\texpected int\n\t} {\n\t\t{13195, 29},\n\t\t{2048, 2},\n\t\t{123456, 643},\n\t\t{100, 5},\n\t\t{999, 37},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d\", test.n), func(t *testing.T) {\n\t\t\tif result := largest_prime_factor(test.n); result != test.expected {\n\t\t\t\tt.Errorf(\"largest_prime_factor(%d) = %d; expected %d\", test.n, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual: candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195), expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_60","nl":"eng_Latn","pl":"go_test.go","prompt":"package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ sum_to_n is a function that sums numbers from 1 to n.\n\/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunc sum_to_n(n int) int {\n","canonical_solution":"func sum_to_n(n int) int {\n    return n * (n + 1) \/ 2\n}\n\nfunc TestSumToN(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {30, 465},\n        {100, 5050},\n        {5, 15},\n        {10, 55},\n        {1, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"sum_to_n(%d)\", test.input), func(t *testing.T) {\n            result := sum_to_n(test.input)\n            if result != test.expected {\n                t.Errorf(\"Expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestSum_To_N(t *testing.T) {\n  candidate := sum_to_n\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(6), expected: 21 },\n     { actual: candidate(11), expected: 66 },\n     { actual: candidate(30), expected: 465 },\n     { actual: candidate(100), expected: 5050 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_61","nl":"eng_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ brackets is a string of \"(\" and \")\".\n\/\/ return true if every opening bracket has a corresponding closing bracket.\n\/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '(' {\n            balance++\n        } else if char == ')' {\n            balance--\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"(\", false},\n        {\"()\", true},\n        {\"(()())\", true},\n        {\")(()\", false},\n        {\"\", true},\n        {\"((()))\", true},\n        {\"(()\", false},\n        {\"())\", false},\n    }\n\n    for _, tt := range tests {\n        result := correct_bracketing(tt.input)\n        if result != tt.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; want %v\", tt.input, result, tt.expected)\n        } else {\n            fmt.Printf(\"correct_bracketing(%q) = %v\\n\", tt.input, result)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_62","nl":"eng_Latn","pl":"go_test.go","prompt":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ xs represent coefficients of a polynomial.\n\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\/\/ Return derivative of this polynomial in the same form.\n\/\/ >>> derivative([]int{3, 1, 2, 4, 5})\n\/\/ []int{1, 4, 12, 20}\n\/\/ >>> derivative([]int{1, 2, 3})\n\/\/ []int{2, 6}\nfunc derivative(xs []int) []int {\n","canonical_solution":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ xs represent coefficients of a polynomial.\n\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\/\/ Return derivative of this polynomial in the same form.\nfunc derivative(xs []int) []int {\n    if len(xs) <= 1 {\n        return []int{}\n    }\n    \n    derived := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        derived[i-1] = xs[i] * i\n    }\n    return derived\n}\n\nfunc TestDerivative(t *testing.T) {\n    testCases := []struct{\n        input []int\n        expected []int\n    }{\n        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},\n        {[]int{1, 2, 3}, []int{2, 6}},\n        {[]int{1}, []int{}},\n        {[]int{}, []int{}},\n    }\n\n    for _, testCase := range testCases {\n        result := derivative(testCase.input)\n        if !equal(result, testCase.expected) {\n            t.Errorf(\"For input %v, expected %v, but got %v\", \n                     testCase.input, testCase.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestDerivative(t *testing.T) {\n  candidate := derivative\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },\n     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },\n     { actual: candidate([]int{1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_63","nl":"eng_Latn","pl":"go_test.go","prompt":"package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n\/\/ fibfib(0) == 0\n\/\/ fibfib(1) == 0\n\/\/ fibfib(2) == 1\n\/\/ fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\/\/ Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n\/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunc fibfib(n int) int {\n","canonical_solution":"func fibfib(n int) int {\n    if n == 0 || n == 1 {\n        return 0\n    } else if n == 2 {\n        return 1\n    }\n\n    a, b, c := 0, 0, 1\n    for i := 3; i <= n; i++ {\n        next := a + b + c\n        a = b\n        b = c\n        c = next\n    }\n    return c\n}","tests":"func TestFibfib(t *testing.T) {\n  candidate := fibfib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 1 },\n     { actual: candidate(1), expected: 0 },\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 24 },\n     { actual: candidate(10), expected: 81 },\n     { actual: candidate(12), expected: 274 },\n     { actual: candidate(14), expected: 927 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_64","nl":"eng_Latn","pl":"go_test.go","prompt":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function vowels_count which takes a string representing\n\/\/ a word as input and returns the number of vowels in the string.\n\/\/ Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n\/\/ vowel, but only when it is at the end of the given word.\n\/\/ Example:\n\/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunc vowels_count(s string) int {\n","canonical_solution":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc vowels_count(s string) int {\n    count := 0\n    s = strings.ToLower(s)\n    vowels := \"aeiou\"\n    for i, char := range s {\n        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestVowelsCount(t *testing.T) {\n    tests := []struct {\n        input  string\n        output int\n    }{\n        {\"abcde\", 2},\n        {\"ACEDY\", 3},\n        {\"xyz\", 1},\n        {\"plenty\", 1},\n        {\"queue\", 3},\n    }\n\n    for _, test := range tests {\n        result := vowels_count(test.input)\n        if result != test.output {\n            t.Errorf(\"Expected %d, but got %d for input %s\", test.output, result, test.input)\n        } else {\n            fmt.Printf(\"Success: got %d for input %s\\n\", result, test.input)\n        }\n    }\n}","tests":"func TestVowels_Count(t *testing.T) {\n  candidate := vowels_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\"), expected: 2 },\n     { actual: candidate(\"Alone\"), expected: 3 },\n     { actual: candidate(\"key\"), expected: 2 },\n     { actual: candidate(\"bye\"), expected: 1 },\n     { actual: candidate(\"keY\"), expected: 2 },\n     { actual: candidate(\"bYe\"), expected: 1 },\n     { actual: candidate(\"ACEDY\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_65","nl":"eng_Latn","pl":"go_test.go","prompt":"package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Circular shift the digits of the integer x, shift the digits right by shift\n\/\/ and return the result as a string.\n\/\/ If shift > number of digits, return digits reversed.\n\/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunc circular_shift(x int, shift int) string {\n","canonical_solution":"package circular_shift_test\n\nimport (\n    \"strconv\"\n)\n\nfunc circular_shift(x int, shift int) string {\n    strX := strconv.Itoa(x)\n    numDigits := len(strX)\n\n    if shift > numDigits {\n        \/\/ Reverse the digits if shift is greater than the number of digits\n        reversed := make([]byte, numDigits)\n        for i := 0; i < numDigits; i++ {\n            reversed[i] = strX[numDigits-i-1]\n        }\n        return string(reversed)\n    } else {\n        \/\/ Perform a circular shift\n        shift = shift % numDigits\n        return strX[numDigits-shift:] + strX[:numDigits-shift]\n    }\n}","tests":"func TestCircular_Shift(t *testing.T) {\n  candidate := circular_shift\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(100, 2), expected: \"001\" },\n     { actual: candidate(12, 2), expected: \"12\" },\n     { actual: candidate(97, 8), expected: \"79\" },\n     { actual: candidate(12, 1), expected: \"21\" },\n     { actual: candidate(11, 101), expected: \"11\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_66","nl":"eng_Latn","pl":"go_test.go","prompt":"package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Task\n\/\/ Write a function that takes a string as input and returns the sum of the upper characters only'\n\/\/ ASCII codes.\n\/\/ Examples:\n\/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunc digitSum(s string) int {\n","canonical_solution":"func digitSum(s string) int {\n    sum := 0\n    for _, char := range s {\n        if char >= 'A' && char <= 'Z' {\n            sum += int(char)\n        }\n    }\n    return sum\n}","tests":"func TestDigitsum(t *testing.T) {\n  candidate := digitSum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abAB\"), expected: 131 },\n     { actual: candidate(\"abcCd\"), expected: 67 },\n     { actual: candidate(\"helloE\"), expected: 69 },\n     { actual: candidate(\"woArBld\"), expected: 131 },\n     { actual: candidate(\"aAaaaXa\"), expected: 153 },\n     { actual: candidate(\" How are yOu?\"), expected: 151 },\n     { actual: candidate(\"You arE Very Smart\"), expected: 327 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_67","nl":"eng_Latn","pl":"go_test.go","prompt":"package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ In this task, you will be given a string that represents a number of apples and oranges \n\/\/ that are distributed in a basket of fruit this basket contains \n\/\/ apples, oranges, and mango fruits. Given the string that represents the total number of \n\/\/ the oranges and apples and an integer that represent the total number of the fruits \n\/\/ in the basket return the number of the mango fruits in the basket.\n\/\/ for examble:\n\/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunc fruit_distribution(s string, n int) int {\n","canonical_solution":"package fruit_distribution_test\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"testing\"\n)\n\nfunc fruit_distribution(s string, n int) int {\n    re := regexp.MustCompile(`(\\d+) apples and (\\d+) oranges`)\n    matches := re.FindStringSubmatch(s)\n    \n    if len(matches) != 3 {\n        return -1 \/\/ Could return an error or a sentinel value if input format is incorrect\n    }\n\n    apples, _ := strconv.Atoi(matches[1])\n    oranges, _ := strconv.Atoi(matches[2])\n\n    mangoes := n - (apples + oranges)\n    return mangoes\n}\n\nfunc TestFruitDistribution(t *testing.T) {\n    var tests = []struct {\n        description string\n        inputString string\n        totalFruits int\n        expected    int\n    }{\n        {\"Test case 1\", \"5 apples and 6 oranges\", 19, 8},\n        {\"Test case 2\", \"0 apples and 1 oranges\", 3, 2},\n        {\"Test case 3\", \"2 apples and 3 oranges\", 100, 95},\n        {\"Test case 4\", \"100 apples and 1 oranges\", 120, 19},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.description, func(t *testing.T) {\n            result := fruit_distribution(tt.inputString, tt.totalFruits)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}\n\nfunc main() {\n    fmt.Println(fruit_distribution(\"5 apples and 6 oranges\", 19)) \/\/ 8\n    fmt.Println(fruit_distribution(\"0 apples and 1 oranges\", 3))  \/\/ 2\n    fmt.Println(fruit_distribution(\"2 apples and 3 oranges\", 100)) \/\/ 95\n    fmt.Println(fruit_distribution(\"100 apples and 1 oranges\", 120)) \/\/ 19\n}","tests":"func TestFruit_Distribution(t *testing.T) {\n  candidate := fruit_distribution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"5 apples and 6 oranges\", 19), expected: 8 },\n     { actual: candidate(\"5 apples and 6 oranges\", 21), expected: 10 },\n     { actual: candidate(\"0 apples and 1 oranges\", 3), expected: 2 },\n     { actual: candidate(\"1 apples and 0 oranges\", 3), expected: 2 },\n     { actual: candidate(\"2 apples and 3 oranges\", 100), expected: 95 },\n     { actual: candidate(\"2 apples and 3 oranges\", 5), expected: 0 },\n     { actual: candidate(\"1 apples and 100 oranges\", 120), expected: 19 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_68","nl":"eng_Latn","pl":"go_test.go","prompt":"package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ \"Given a list representing a branch of a tree that has non-negative integer nodes\n\/\/ your task is to pluck one of the nodes and return it.\n\/\/ The plucked node should be the node with the smallest even value.\n\/\/ If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\/\/ The plucked node should be returned in a list, [ smalest_value, its index ],\n\/\/ If there are no even values or the given list is empty, return [].\n\/\/ Example 1:\n\/\/ >>> pluck([]int{4, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([]int{1, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([]int{})\n\/\/ []int{}\n\/\/ Example 4:\n\/\/ >>> pluck([]int{5, 0, 3, 0, 4, 2})\n\/\/ []int{0, 1}\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunc pluck(arr []int) []int {\n","canonical_solution":"package pluck_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ pluck function that implements the solution as described in the problem\nfunc pluck(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn []int{}\n\t}\n\n\tsmallestEvenValue := -1\n\tindex := -1\n\n\tfor i, val := range arr {\n\t\tif val%2 == 0 {\n\t\t\tif smallestEvenValue == -1 || val < smallestEvenValue {\n\t\t\t\tsmallestEvenValue = val\n\t\t\t\tindex = i\n\t\t\t}\n\t\t}\n\t}\n\n\tif index == -1 {\n\t\treturn []int{}\n\t}\n\n\treturn []int{smallestEvenValue, index}\n}\n\n\/\/ Example unit tests can be implemented by using the testing package\nfunc TestPluck(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{4, 2, 3}, []int{2, 1}},\n\t\t{[]int{1, 2, 3}, []int{2, 1}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := pluck(test.input)\n\t\tif len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {\n\t\t\tt.Errorf(\"pluck(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_69","nl":"eng_Latn","pl":"go_test.go","prompt":"package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n\/\/ zero, and has a frequency greater than or equal to the value of the integer itself. \n\/\/ The frequency of an integer is the number of times it appears in the list.\n\/\/ If no such a value exist, return -1.\n\/\/ Examples:\n\/\/ >>> search([]int{4, 1, 2, 2, 3, 1})\n\/\/ 2\n\/\/ >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})\n\/\/ 3\n\/\/ >>> search([]int{5, 5, 4, 4, 4})\n\/\/ -1\nfunc search(lst []int) int {\n","canonical_solution":"package search_test\n\nimport \"sort\"\n\nfunc search(lst []int) int {\n\tfrequency := make(map[int]int)\n\n\tfor _, num := range lst {\n\t\tfrequency[num]++\n\t}\n\n\tcandidates := []int{}\n\tfor num, count := range frequency {\n\t\tif count >= num {\n\t\t\tcandidates = append(candidates, num)\n\t\t}\n\t}\n\n\tif len(candidates) == 0 {\n\t\treturn -1\n\t}\n\n\tsort.Ints(candidates)\n\treturn candidates[len(candidates)-1]\n}","tests":"func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3, 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n     { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}), expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_70","nl":"eng_Latn","pl":"go_test.go","prompt":"package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given list of integers, return list in strange order.\n\/\/ Strange sorting, is when you start with the minimum value,\n\/\/ then maximum of the remaining integers, then minimum and so on.\n\/\/ Examples:\n\/\/ >>> strange_sort_list([]int{1, 2, 3, 4})\n\/\/ []int{1, 4, 2, 3}\n\/\/ >>> strange_sort_list([]int{5, 5, 5, 5})\n\/\/ []int{5, 5, 5, 5}\n\/\/ >>> strange_sort_list([]int{})\n\/\/ []int{}\nfunc strange_sort_list(lst []int) []int {\n","canonical_solution":"package strange_sort_list_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc strange_sort_list(lst []int) []int {\n\tif len(lst) == 0 {\n\t\treturn lst\n\t}\n\t\n\tsort.Ints(lst)\n\tres := make([]int, len(lst))\n\tleft, right := 0, len(lst)-1\n\ti := 0\n\n\tfor left <= right {\n\t\tif i%2 == 0 {\n\t\t\tres[i] = lst[left]\n\t\t\tleft++\n\t\t} else {\n\t\t\tres[i] = lst[right]\n\t\t\tright--\n\t\t}\n\t\ti++\n\t}\n\n\treturn res\n}\n\nfunc TestStrangeSortList(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []int\n\t\toutput []int\n\t}{\n\t\t{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},\n\t\t{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},\n\t}\n\tfor _, test := range tests {\n\t\tif res := strange_sort_list(test.input); !equal(res, test.output) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.output, res)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tfmt.Println(strange_sort_list([]int{1, 2, 3, 4})) \/\/ Should print [1 4 2 3]\n}","tests":"func TestStrange_Sort_List(t *testing.T) {\n  candidate := strange_sort_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },\n     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },\n     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },\n     { actual: candidate([]int{111111}), expected: []int{111111} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_71","nl":"eng_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given the lengths of the three sides of a triangle. Return the area of\n\/\/ the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n\/\/ Otherwise return -1\n\/\/ Three sides make a valid triangle when the sum of any two sides is greater \n\/\/ than the third side.\n\/\/ Example:\n\/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunc triangle_area(a int, b int, c int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"math\"\n)\n\nfunc triangle_area(a int, b int, c int) float64 {\n    \/\/ Check for the validity of the triangle\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    \/\/ Calculate the semi-perimeter\n    s := float64(a+b+c) \/ 2\n    \/\/ Calculate the area using Heron's formula\n    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    \/\/ Round the result to 2 decimal places\n    return math.Round(area*100) \/ 100.0\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: 6.0 },\n     { actual: candidate(1, 2, 10), expected: -1 },\n     { actual: candidate(4, 8, 5), expected: 8.18 },\n     { actual: candidate(2, 2, 2), expected: 1.73 },\n     { actual: candidate(1, 2, 3), expected: -1 },\n     { actual: candidate(10, 5, 7), expected: 16.25 },\n     { actual: candidate(2, 6, 3), expected: -1 },\n     { actual: candidate(1, 1, 1), expected: 0.43 },\n     { actual: candidate(2, 2, 10), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_72","nl":"eng_Latn","pl":"go_test.go","prompt":"package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that returns true if the object q will fly, and false otherwise.\n\/\/ The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\/\/ Example:\n\/\/ >>> will_it_fly([]int{1, 2}, 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([]int{3}, 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w int) bool {\n","canonical_solution":"func will_it_fly(q []int, w int) bool {\n    sum := 0\n    n := len(q)\n\n    \/\/ Calculate the sum of the elements in q\n    for _, value := range q {\n        sum += value\n    }\n\n    \/\/ Check if sum is greater than the maximum possible weight\n    if sum > w {\n        return false\n    }\n\n    \/\/ Check if the list is a palindrome\n    for i := 0; i < n\/2; i++ {\n        if q[i] != q[n-i-1] {\n            return false\n        }\n    }\n\n    \/\/ If the list is balanced and sum is less than or equal to w\n    return true\n}","tests":"func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_73","nl":"eng_Latn","pl":"go_test.go","prompt":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list arr of integers, find the minimum number of elements that\n\/\/ need to be changed to make the list palindromic. A palindromic list is a list that\n\/\/ is read the same backwards and forwards. In one change, you can change one element to any other element.\n\/\/ For example:\n\/\/ >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})\n\/\/ 4\n\/\/ >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})\n\/\/ 1\n\/\/ >>> smallest_change([]int{1, 2, 3, 2, 1})\n\/\/ 0\nfunc smallest_change(arr []int) int {\n","canonical_solution":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc smallest_change(arr []int) int {\n    n := len(arr)\n    changes := 0\n    for i := 0; i < n\/2; i++ {\n        if arr[i] != arr[n-i-1] {\n            changes++\n        }\n    }\n    return changes\n}\n\nfunc TestSmallestChange(t *testing.T) {\n    tests := []struct{\n        input []int\n        expected int\n    }{\n        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},\n        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},\n        {[]int{1, 2, 3, 2, 1}, 0},\n    }\n\n    for _, test := range tests {\n        result := smallest_change(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %v, expected %d but got %d\", test.input, test.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", test.input)\n        }\n    }\n}","tests":"func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_74","nl":"eng_Latn","pl":"go_test.go","prompt":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that accepts two lists of strings and returns the list that has \n\/\/ total number of chars in the all strings of the list less than the other list.\n\/\/ if the two lists have the same number of chars, return the first list.\n\/\/ Examples\n\/\/ >>> total_match([]string{}, []string{})\n\/\/ []string{}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n\/\/ []string{\"hI\", \"Hi\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"})\n\/\/ []string{\"hi\", \"admin\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\/\/ []string{\"hI\", \"hi\", \"hi\"}\n\/\/ >>> total_match([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"})\n\/\/ []string{\"4\"}\nfunc total_match(lst1 []string, lst2 []string) []string {\n","canonical_solution":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ total_match function returns the list with the smaller total character count.\n\/\/ If both lists have the same character count, it returns the first list.\nfunc total_match(lst1 []string, lst2 []string) []string {\n    sumChars := func(lst []string) int {\n        total := 0\n        for _, str := range lst {\n            total += len(str)\n        }\n        return total\n    }\n    \n    sum1 := sumChars(lst1)\n    sum2 := sumChars(lst2)\n\n    if sum1 <= sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\n\/\/ Test functions can go below to verify the behavior of total_match.\nfunc TestTotalMatch(t *testing.T) {\n    cases := []struct {\n        lst1      []string\n        lst2      []string\n        expected  []string\n    }{\n        {[]string{}, []string{}, []string{}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}, []string{\"hI\", \"Hi\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}, []string{\"hi\", \"admin\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}, []string{\"hI\", \"hi\", \"hi\"}},\n        {[]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}, []string{\"4\"}},\n    }\n\n    for _, c := range cases {\n        result := total_match(c.lst1, c.lst2)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"total_match(%v, %v) == %v, expected %v\", c.lst1, c.lst2, result, c.expected)\n        }\n    }\n}","tests":"func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_75","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that returns true if the given number is the multiplication of 3 prime numbers\n\/\/ and false otherwise.\n\/\/ Knowing that (a) is less then 100. \n\/\/ Example:\n\/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a int) bool {\n","canonical_solution":"func is_multiply_prime(a int) bool {\n\tif a < 2 {\n\t\treturn false\n\t}\n\n\tprimeNumbers := generatePrimesUpTo(100)\n\t\n\tfor i := 0; i < len(primeNumbers); i++ {\n\t\tfor j := i; j < len(primeNumbers); j++ {\n\t\t\tfor k := j; k < len(primeNumbers); k++ {\n\t\t\t\tif primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc generatePrimesUpTo(max int) []int {\n\tisPrime := make([]bool, max+1)\n\tfor i := 2; i <= max; i++ {\n\t\tisPrime[i] = true\n\t}\n\tfor i := 2; i*i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tfor j := i * i; j <= max; j += i {\n\t\t\t\tisPrime[j] = false\n\t\t\t}\n\t\t}\n\t}\n\tvar primes []int\n\tfor i := 2; i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\treturn primes\n}","tests":"func TestIs_Multiply_Prime(t *testing.T) {\n  candidate := is_multiply_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: false },\n     { actual: candidate(30), expected: true },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: false },\n     { actual: candidate(125), expected: true },\n     { actual: candidate(105), expected: true },\n     { actual: candidate(126), expected: false },\n     { actual: candidate(729), expected: false },\n     { actual: candidate(891), expected: false },\n     { actual: candidate(1001), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_76","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Your task is to write a function that returns true if a number x is a simple\n\/\/ power of n and false in other cases.\n\/\/ x is a simple power of n if n**int=x\n\/\/ For example:\n\/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunc is_simple_power(x int, n int) bool {\n","canonical_solution":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_simple_power(x int, n int) bool {\n    if n <= 1 {\n        return x == 1\n    }\n    \n    current := n\n    for current <= x {\n        if current == x {\n            return true\n        }\n        current *= n\n    }\n    return false\n}\n\nfunc TestIsSimplePower(t *testing.T) {\n    tests := []struct {\n        x, n     int\n        expected bool\n    }{\n        {1, 4, true},\n        {2, 2, true},\n        {8, 2, true},\n        {3, 2, false},\n        {3, 1, false},\n        {5, 3, false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.x, test.n), func(t *testing.T) {\n            result := is_simple_power(test.x, test.n)\n            if result != test.expected {\n                t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_77","nl":"eng_Latn","pl":"go_test.go","prompt":"package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that takes an integer a and returns true \n\/\/ if this ingeger is a cube of some integer number.\n\/\/ Note: you may assume the input is always valid.\n\/\/ Examples:\n\/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunc iscube(a int) bool {\n","canonical_solution":"package iscube_test\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc iscube(a int) bool {\n\tif a < 0 {\n\t\ta = -a\n\t}\n\tcubeRoot := math.Cbrt(float64(a))\n\treturn cubeRoot == float64(int(cubeRoot))\n}\n\nfunc TestIsCube(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{1, true},\n\t\t{2, false},\n\t\t{-1, true},\n\t\t{64, true},\n\t\t{0, true},\n\t\t{180, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"iscube(%d)\", test.input), func(t *testing.T) {\n\t\t\tresult := iscube(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestIscube(t *testing.T) {\n  candidate := iscube\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: true },\n     { actual: candidate(2), expected: false },\n     { actual: candidate(-1), expected: true },\n     { actual: candidate(64), expected: true },\n     { actual: candidate(180), expected: false },\n     { actual: candidate(1000), expected: true },\n     { actual: candidate(0), expected: true },\n     { actual: candidate(1729), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_78","nl":"eng_Latn","pl":"go_test.go","prompt":"package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You have been tasked to write a function that receives \n\/\/ a hexadecimal number as a string and counts the number of hexadecimal \n\/\/ digits that are primes (prime number, or a prime, is a natural number \n\/\/ greater than 1 that is not a product of two smaller natural numbers).\n\/\/ Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\/\/ Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n\/\/ So you have to determine a number of the following digits: 2, 3, 5, 7, \n\/\/ B (=decimal 11), D (=decimal 13).\n\/\/ Note: you may assume the input is always correct or empty string, \n\/\/ and symbols A,B,C,D,E,F are always uppercase.\n\/\/ Examples:\n\/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunc hex_key(num string) int {\n","canonical_solution":"func hex_key(num string) int {\n    primeDigits := map[rune]struct{}{\n        '2': {},\n        '3': {},\n        '5': {},\n        '7': {},\n        'B': {},\n        'D': {},\n    }\n\n    count := 0\n    for _, digit := range num {\n        if _, found := primeDigits[digit]; found {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHexKey(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"AB\", 1},\n        {\"1077E\", 2},\n        {\"ABED1A33\", 4},\n        {\"123456789ABCDEF0\", 6},\n        {\"2020\", 2},\n        {\"\", 0},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"hex_key(%s)\", test.input), func(t *testing.T) {\n            result := hex_key(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_79","nl":"eng_Latn","pl":"go_test.go","prompt":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You will be given a number in decimal form and your task is to convert it to\n\/\/ binary format. The function should return a string, with each character representing a binary\n\/\/ number. Each character in the string will be '0' or '1'.\n\/\/ There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n\/\/ The extra characters are there to help with the format.\n\/\/ Examples:\n\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n","canonical_solution":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n\/\/ You will be given a number in decimal form and your task is to convert it to\n\/\/ binary format. The function should return a string, with each character representing a binary\n\/\/ number. Each character in the string will be '0' or '1'.\n\/\/ There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n\/\/ The extra characters are there to help with the format.\n\/\/ Examples:\n\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    binary := strconv.FormatInt(int64(decimal), 2)\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimalToBinary(t *testing.T) {\n    tests := []struct {\n        input  int\n        output string\n    }{\n        {15, \"db1111db\"},\n        {32, \"db100000db\"},\n        {0, \"db0db\"},\n        {1, \"db1db\"},\n        {255, \"db11111111db\"},\n    }\n\n    for _, test := range tests {\n        result := decimal_to_binary(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %d, expected %s, but got %s\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(decimal_to_binary(15))  \/\/ Output: db1111db\n    fmt.Println(decimal_to_binary(32))  \/\/ Output: db100000db\n    fmt.Println(decimal_to_binary(255)) \/\/ Output: db11111111db\n}","tests":"func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_80","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a string s.\n\/\/ Your task is to check if the string is hapgo or not.\n\/\/ A string is hapgo if its length is at least 3 and every 3 consecutive letters are distinct\n\/\/ For example:\n\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunc is_happy(s string) bool {\n","canonical_solution":"func is_happy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i <= len(s)-3; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestIs_Happy(t *testing.T) {\n  candidate := is_happy\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a\"), expected: false },\n     { actual: candidate(\"aa\"), expected: false },\n     { actual: candidate(\"abcd\"), expected: true },\n     { actual: candidate(\"aabb\"), expected: false },\n     { actual: candidate(\"adb\"), expected: true },\n     { actual: candidate(\"xyy\"), expected: false },\n     { actual: candidate(\"iopaxpoi\"), expected: true },\n     { actual: candidate(\"iopaxioi\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_81","nl":"eng_Latn","pl":"go_test.go","prompt":"package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ It is the last week of the semester and the teacher has to give the grades\n\/\/ to students. The teacher has been making her own algorithm for grading.\n\/\/ The only problem is, she has lost the code she used for grading.\n\/\/ She has given you a list of GPAs for some students and you have to write \n\/\/ a function that can output a list of letter grades using the following table:\n\/\/ GPA       |    Letter grade\n\/\/ 4.0                A+\n\/\/ > 3.7                A \n\/\/ > 3.3                A- \n\/\/ > 3.0                B+\n\/\/ > 2.7                B \n\/\/ > 2.3                B-\n\/\/ > 2.0                C+\n\/\/ > 1.7                C\n\/\/ > 1.3                C-\n\/\/ > 1.0                D+ \n\/\/ > 0.7                D \n\/\/ > 0.0                D-\n\/\/ 0.0                E\n\/\/ Example:\n\/\/ >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})\n\/\/ []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\nfunc numerical_letter_grade(grades []float64) []string {\n","canonical_solution":"func numerical_letter_grade(grades []float64) []string {\n    letterGrades := []string{}\n    for _, grade := range grades {\n        if grade == 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if grade > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if grade > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if grade > 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if grade > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if grade > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if grade > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if grade > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if grade > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if grade > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if grade > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if grade > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}","tests":"func TestNumerical_Letter_Grade(t *testing.T) {\n  candidate := numerical_letter_grade\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"} },\n     { actual: candidate([]float64{1.2}), expected: []string{\"D+\"} },\n     { actual: candidate([]float64{0.5}), expected: []string{\"D-\"} },\n     { actual: candidate([]float64{0.0}), expected: []string{\"E\"} },\n     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"} },\n     { actual: candidate([]float64{0.0, 0.7}), expected: []string{\"E\", \"D-\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_82","nl":"eng_Latn","pl":"go_test.go","prompt":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that takes a string and returns true if the string\n\/\/ length is a prime number or false otherwise\n\/\/ Examples\n\/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunc prime_length(myString string) bool {\n","canonical_solution":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc prime_length(myString string) bool {\n    length := len(myString)\n    return isPrime(length)\n}\n\nfunc TestPrimeLength(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected bool\n    }{\n        {\"Hello\", true},\n        {\"abcdcba\", true},\n        {\"kittens\", true},\n        {\"orange\", false},\n    }\n\n    for _, testCase := range testCases {\n        result := prime_length(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"prime_length(%v) returned %v, expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(prime_length(\"Hello\"))  \/\/ true\n    fmt.Println(prime_length(\"abcdcba\"))  \/\/ true\n    fmt.Println(prime_length(\"kittens\"))  \/\/ true\n    fmt.Println(prime_length(\"orange\"))  \/\/ false\n}","tests":"func TestPrime_Length(t *testing.T) {\n  candidate := prime_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello\"), expected: true },\n     { actual: candidate(\"abcdcba\"), expected: true },\n     { actual: candidate(\"kittens\"), expected: true },\n     { actual: candidate(\"orange\"), expected: false },\n     { actual: candidate(\"wow\"), expected: true },\n     { actual: candidate(\"world\"), expected: true },\n     { actual: candidate(\"MadaM\"), expected: true },\n     { actual: candidate(\"Wow\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"HI\"), expected: true },\n     { actual: candidate(\"go\"), expected: true },\n     { actual: candidate(\"gogo\"), expected: false },\n     { actual: candidate(\"aaaaaaaaaaaaaaa\"), expected: false },\n     { actual: candidate(\"Madam\"), expected: true },\n     { actual: candidate(\"M\"), expected: false },\n     { actual: candidate(\"0\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_83","nl":"eng_Latn","pl":"go_test.go","prompt":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return the count of the numbers of n-digit\n\/\/ positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n","canonical_solution":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return the count of the numbers of n-digit\n\/\/ positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n    if n == 1 {\n        return 1\n    }\n\n    countStart1 := 1 * pow(10, n-1)\n    countEnd1 := 9 * pow(10, n-2)\n    \n    return countStart1 + countEnd1\n}\n\nfunc pow(base, exp int) int {\n    if exp == 0 {\n        return 1\n    }\n    result := 1\n    for i := 0; i < exp; i++ {\n        result *= base\n    }\n    return result\n}\n\nfunc TestStartsOneEnds(t *testing.T) {\n    tests := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 19},\n        {3, 189},\n        {4, 1899},\n        {5, 18999},\n    }\n\n    for _, tt := range tests {\n        testname := fmt.Sprintf(\"n=%d\", tt.n)\n        t.Run(testname, func(t *testing.T) {\n            result := starts_one_ends(tt.n)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}","tests":"func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected: 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_84","nl":"eng_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer N, return the total sum of its digits in binary.\n\/\/ Example\n\/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunc solve(N int) string {\n","canonical_solution":"func solve(N int) string {\n    sum := 0\n    for N > 0 {\n        sum += N % 10\n        N \/= 10\n    }\n    return fmt.Sprintf(\"%b\", sum)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1000), expected: \"1\" },\n     { actual: candidate(150), expected: \"110\" },\n     { actual: candidate(147), expected: \"1100\" },\n     { actual: candidate(333), expected: \"1001\" },\n     { actual: candidate(963), expected: \"10010\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_85","nl":"eng_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\/\/ Examples:\n\/\/ >>> add([]int{4, 2, 6, 7})\n\/\/ 2\nfunc add(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        if lst[i]%2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 88}), expected: 88 },\n     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },\n     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },\n     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_86","nl":"eng_Latn","pl":"go_test.go","prompt":"package anti_shuffle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that takes a string and returns an ordered version of it.\n\/\/ Ordered version of string, is a string where all words (separated by space)\n\/\/ are replaced by a new word where all the characters arranged in\n\/\/ ascending order based on ascii value.\n\/\/ Note: You should keep the order of words and blank spaces in the sentence.\n\/\/ For example:\n\/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s string) string {\n","canonical_solution":"package anti_shuffle_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc anti_shuffle(s string) string {\n    \/\/ Split the input string into words based on spaces\n    words := strings.Fields(s)\n\n    \/\/ Iterate over each word\n    for i, word := range words {\n        \/\/ Convert the word to a slice of runes for sorting\n        runes := []rune(word)\n        \/\/ Sort the runes using custom comparison\n        sort.Slice(runes, func(i, j int) bool {\n            return runes[i] < runes[j]\n        })\n        \/\/ Reassign the sorted runes back to the word\n        words[i] = string(runes)\n    }\n\n    \/\/ Rejoin the words into a single string, keeping original spaces\n    result := \"\"\n    inputIndex := 0\n\n    for _, word := range words {\n        \/\/ Add the spaces prior to the current word\n        for inputIndex < len(s) && s[inputIndex] == ' ' {\n            result += \" \"\n            inputIndex++\n        }\n        \/\/ Add the current sorted word\n        result += word\n        inputIndex += len(word)\n    }\n\n    \/\/ Add trailing spaces, if any.\n    for inputIndex < len(s) && s[inputIndex] == ' ' {\n        result += \" \"\n        inputIndex++\n    }\n\n    return result\n}","tests":"func TestAnti_Shuffle(t *testing.T) {\n  candidate := anti_shuffle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi\"), expected: \"Hi\" },\n     { actual: candidate(\"hello\"), expected: \"ehllo\" },\n     { actual: candidate(\"number\"), expected: \"bemnru\" },\n     { actual: candidate(\"abcd\"), expected: \"abcd\" },\n     { actual: candidate(\"Hello World!!!\"), expected: \"Hello !!!Wdlor\" },\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hi. My name is Mister Robot. How are you?\"), expected: \".Hi My aemn is Meirst .Rboot How aer ?ouy\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_87","nl":"eng_Latn","pl":"go_test.go","prompt":"package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a 2 dimensional data, as a nested lists,\n\/\/ which is similar to matrix, however, unlike matrices,\n\/\/ each row may contain a different number of columns.\n\/\/ Given lst, and integer x, find integers x in the list,\n\/\/ and return list of lists, [(x1, y1), (x2, y2) ...] such that\n\/\/ each list is a coordinate - (row, columns), starting with 0.\n\/\/ Sort coordinates initially by rows in ascending order.\n\/\/ Also, sort coordinates of the row by columns in descending order.\n\/\/ Examples:\n\/\/ >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n\/\/ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n\/\/ >>> get_row([][]int{}, 1)\n\/\/ [][]interface{}{}\n\/\/ >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n\/\/ [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n","canonical_solution":"package get_row_test\n\nimport (\n\t\"sort\"\n)\n\nfunc get_row(lst [][]int, x int) [][]interface{} {\n\tvar result [][]interface{}\n\n\tfor i, row := range lst {\n\t\tvar temp []interface{}\n\t\tfor j, value := range row {\n\t\t\tif value == x {\n\t\t\t\ttemp = append(temp, []interface{}{i, j})\n\t\t\t}\n\t\t}\n\t\t\/\/ Sort columns in descending order for the current row\n\t\tsort.Slice(temp, func(a, b int) bool {\n\t\t\treturn temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)\n\t\t})\n\t\tresult = append(result, temp...)\n\t}\n\n\t\/\/ result is already sorted by rows since we've traversed `lst` row by row\n\treturn result\n}","tests":"func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_88","nl":"eng_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list of non-negative integers, return a cogo of the given list after sorting,\n\/\/ you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n\/\/ or sort it in descending order if the sum( first index value, last index value) is even.\n\/\/ Note:\n\/\/ * don't change the given list.\n\/\/ Examples:\n\/\/ >>> sort_array([]int{})\n\/\/ []int{}\n\/\/ >>> sort_array([]int{5})\n\/\/ []int{5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n\/\/ []int{0, 1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n\/\/ []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return append([]int{}, array...)\n    }\n\n    result := append([]int{}, array...) \/\/ Copy the array to avoid mutating the input\n    if (result[0]+result[len(result)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(result))) \/\/ Sort in descending order\n    } else {\n        sort.Ints(result) \/\/ Sort in ascending order\n    }\n\n    return result\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_89","nl":"eng_Latn","pl":"go_test.go","prompt":"package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function encrypt that takes a string as an argument and\n\/\/ returns a string encrypted with the alphabet being rotated. \n\/\/ The alphabet should be rotated in a manner such that the letters \n\/\/ shift down by two multiplied to two places.\n\/\/ For example:\n\/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunc encrypt(s string) string {\n","canonical_solution":"func encrypt(s string) string {\n    result := []rune(s)\n    for i, char := range result {\n        if char >= 'a' && char <= 'z' {\n            result[i] = 'a' + (char-'a'+4)%26\n        } else if char >= 'A' && char <= 'Z' {\n            result[i] = 'A' + (char-'A'+4)%26\n        }\n    }\n    return string(result)\n}","tests":"func TestEncrypt(t *testing.T) {\n  candidate := encrypt\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hi\"), expected: \"lm\" },\n     { actual: candidate(\"asdfghjkl\"), expected: \"ewhjklnop\" },\n     { actual: candidate(\"gf\"), expected: \"kj\" },\n     { actual: candidate(\"et\"), expected: \"ix\" },\n     { actual: candidate(\"faewfawefaewg\"), expected: \"jeiajeaijeiak\" },\n     { actual: candidate(\"hellomyfriend\"), expected: \"lippsqcjvmirh\" },\n     { actual: candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), expected: \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" },\n     { actual: candidate(\"a\"), expected: \"e\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_91","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You'll be given a string of words, and your task is to count the number\n\/\/ of boredoms. A boredom is a sentence that starts with the word \"I\".\n\/\/ Sentences are delimited by '.', '?' or '!'.\n\/\/ For example:\n\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunc is_bored(S string) int {\n","canonical_solution":"package is_bored_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_bored(S string) int {\n    sentences := strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' || r == '?' || r == '!'\n    })\n    count := 0\n    for _, sentence := range sentences {\n        trimmed := strings.TrimSpace(sentence)\n        if strings.HasPrefix(trimmed, \"I \") {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestIsBored(t *testing.T) {\n    tests := []struct {\n        input string\n        want  int\n    }{\n        {\"Hello world\", 0},\n        {\"The sky is blue. The sun is shining. I love this weather\", 1},\n        {\"I am here. I am there. I am everywhere\", 3},\n        {\"What's up? Are you ok? Yes, I am!\", 1},\n        {\"\", 0},\n        {\"I.\", 1},\n        {\"I! am excited. I? am curious\", 2},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"is_bored(%q)\", tt.input), func(t *testing.T) {\n            got := is_bored(tt.input)\n            if got != tt.want {\n                t.Errorf(\"got %d, want %d\", got, tt.want)\n            }\n        })\n    }\n}","tests":"func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"), expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual: candidate(\"I feel good today. I will be productive. will kill It\"), expected: 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_92","nl":"eng_Latn","pl":"go_test.go","prompt":"package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function that takes 3 numbers.\n\/\/ Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n\/\/ Returns false in any other cases.\n\/\/ Examples\n\/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunc any_int(x float64, y float64, z float64) bool {\n","canonical_solution":"package any_int_test\n\nimport (\n    \"testing\"\n)\n\nfunc any_int(x float64, y float64, z float64) bool {\n    \/\/ Check if x, y, and z are integers\n    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {\n        return false\n    }\n\n    \/\/ Check if one of the numbers is the sum of the other two\n    if x == y+z || y == x+z || z == x+y {\n        return true\n    }\n\n    return false\n}\n\nfunc TestAnyInt(t *testing.T) {\n    if !any_int(5, 2, 7) {\n        t.Errorf(\"Expected true for any_int(5, 2, 7)\")\n    }\n    if any_int(3, 2, 2) {\n        t.Errorf(\"Expected false for any_int(3, 2, 2)\")\n    }\n    if !any_int(3, -2, 1) {\n        t.Errorf(\"Expected true for any_int(3, -2, 1)\")\n    }\n    if any_int(3.6, -2.2, 2) {\n        t.Errorf(\"Expected false for any_int(3.6, -2.2, 2)\")\n    }\n}","tests":"func TestAny_Int(t *testing.T) {\n  candidate := any_int\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 3, 1), expected: true },\n     { actual: candidate(2.5, 2, 3), expected: false },\n     { actual: candidate(1.5, 5, 3.5), expected: false },\n     { actual: candidate(2, 6, 2), expected: false },\n     { actual: candidate(4, 2, 2), expected: true },\n     { actual: candidate(2.2, 2.2, 2.2), expected: false },\n     { actual: candidate(-4, 6, 2), expected: true },\n     { actual: candidate(2, 1, 1), expected: true },\n     { actual: candidate(3, 4, 7), expected: true },\n     { actual: candidate(3.0, 4, 7), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_93","nl":"eng_Latn","pl":"go_test.go","prompt":"package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that takes a message, and encodes in such a \n\/\/ way that it swaps case of all letters, replaces all vowels in \n\/\/ the message with the letter that appears 2 places ahead of that \n\/\/ vowel in the english alphabet. \n\/\/ Assume only letters. \n\/\/ Examples:\n\/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message string) string {\n","canonical_solution":"package encode_test\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc encode(message string) string {\n\tvar encodedMessage strings.Builder\n\n\t\/\/ Mapping of vowels to the letter appearing 2 places ahead\n\tvowelReplacement := map[rune]rune{\n\t\t'a': 'c',\n\t\t'A': 'C',\n\t\t'e': 'g',\n\t\t'E': 'G',\n\t\t'i': 'k',\n\t\t'I': 'K',\n\t\t'o': 'q',\n\t\t'O': 'Q',\n\t\t'u': 'w',\n\t\t'U': 'W',\n\t}\n\n\tfor _, char := range message {\n\t\tif unicode.IsLetter(char) {\n\t\t\t\/\/ Swap case of the character\n\t\t\tif unicode.IsUpper(char) {\n\t\t\t\tchar = unicode.ToLower(char)\n\t\t\t} else {\n\t\t\t\tchar = unicode.ToUpper(char)\n\t\t\t}\n\n\t\t\t\/\/ Replace vowel if the character is a vowel\n\t\t\tif replacement, isVowel := vowelReplacement[char]; isVowel {\n\t\t\t\tchar = replacement\n\t\t\t}\n\t\t}\n\n\t\tencodedMessage.WriteRune(char)\n\t}\n\n\treturn encodedMessage.String()\n}","tests":"func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_94","nl":"eng_Latn","pl":"go_test.go","prompt":"package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a list of integers.\n\/\/ You need to find the largest prime value and return the sum of its digits.\n\/\/ Examples:\n\/\/ >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\/\/ 10\n\/\/ >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\/\/ 25\n\/\/ >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\/\/ 13\n\/\/ >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\/\/ 11\n\/\/ >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\/\/ 3\n\/\/ >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\/\/ 7\nfunc skjkasdkd(lst []int) int {\n","canonical_solution":"package skjkasdkd_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\/\/ Function to calculate the sum of digits of a number\nfunc sumOfDigits(n int) int {\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\n\/\/ Function to find the largest prime and return the sum of its digits\nfunc skjkasdkd(lst []int) int {\n\tmaxPrime := -1\n\tfor _, num := range lst {\n\t\tif isPrime(num) && num > maxPrime {\n\t\t\tmaxPrime = num\n\t\t}\n\t}\n\tif maxPrime == -1 {\n\t\treturn 0\n\t}\n\treturn sumOfDigits(maxPrime)\n}\n\nfunc TestSkjkasdkd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},\n\t\t{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},\n\t\t{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},\n\t\t{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},\n\t\t{[]int{0, 81, 12, 3, 1, 21}, 3},\n\t\t{[]int{0, 8, 1, 2, 1, 7}, 7},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tresult := skjkasdkd(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"got %v, want %v\", result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSkjkasdkd(t *testing.T) {\n  candidate := skjkasdkd\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },\n     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },\n     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },\n     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },\n     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },\n     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },\n     { actual: candidate([]int{8191}), expected: 19 },\n     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },\n     { actual: candidate([]int{127, 97, 8192}), expected: 10 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_95","nl":"eng_Latn","pl":"go_test.go","prompt":"package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a map, return true if all keys are strings in lower \n\/\/ case or all keys are strings in upper case, else return false.\n\/\/ The function should return false is the given map is empty.\n\/\/ Examples:\n\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunc check_dict_case(dict map[string]string) bool {\n","canonical_solution":"func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n\n    var allLowercase, allUppercase bool\n    for k := range dict {\n        if k != strings.ToLower(k) && k != strings.ToUpper(k) {\n            return false\n        }\n        if k == strings.ToLower(k) {\n            if allUppercase {\n                return false\n            }\n            allLowercase = true\n        }\n        if k == strings.ToUpper(k) {\n            if allLowercase {\n                return false\n            }\n            allUppercase = true\n        }\n    }\n\n    return allLowercase || allUppercase\n}","tests":"func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_96","nl":"eng_Latn","pl":"go_test.go","prompt":"package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Implement a function that takes an non-negative integer and returns a list of the first n\n\/\/ integers that are prime numbers and less than n.\n\/\/ for example:\n\/\/ >>> count_up_to(5)\n\/\/ []int{2, 3}\n\/\/ >>> count_up_to(11)\n\/\/ []int{2, 3, 5, 7}\n\/\/ >>> count_up_to(0)\n\/\/ []int{}\n\/\/ >>> count_up_to(20)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17, 19}\n\/\/ >>> count_up_to(1)\n\/\/ []int{}\n\/\/ >>> count_up_to(18)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int {\n","canonical_solution":"func count_up_to(n int) []int {\n\tprimes := []int{}\n\tfor num := 2; num < n; num++ {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\treturn primes\n}\n\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_97","nl":"eng_Latn","pl":"go_test.go","prompt":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Complete the function that takes two integers and returns \n\/\/ the product of their unit digits.\n\/\/ Assume the input is always valid.\n\/\/ Examples:\n\/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunc multiply(a int, b int) int {\n","canonical_solution":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Complete the function that takes two integers and returns \n\/\/ the product of their unit digits.\n\/\/ Assume the input is always valid.\nfunc multiply(a int, b int) int {\n    unitA := abs(a) % 10\n    unitB := abs(b) % 10\n    return unitA * unitB\n}\n\nfunc abs(n int) int {\n    if n < 0 {\n        return -n\n    }\n    return n\n}\n\nfunc TestMultiply(t *testing.T) {\n    fmt.Println(multiply(148, 412)) \/\/ 16\n    fmt.Println(multiply(19, 28))   \/\/ 72\n    fmt.Println(multiply(2020, 1851)) \/\/ 0\n    fmt.Println(multiply(14, -15))  \/\/ 20\n}","tests":"func TestMultiply(t *testing.T) {\n  candidate := multiply\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(148, 412), expected: 16 },\n     { actual: candidate(19, 28), expected: 72 },\n     { actual: candidate(2020, 1851), expected: 0 },\n     { actual: candidate(14, -15), expected: 20 },\n     { actual: candidate(76, 67), expected: 42 },\n     { actual: candidate(17, 27), expected: 49 },\n     { actual: candidate(0, 1), expected: 0 },\n     { actual: candidate(0, 0), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_98","nl":"eng_Latn","pl":"go_test.go","prompt":"package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a string s, count the number of uppercase vowels in even indices.\n\/\/ For example:\n\/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunc count_upper(s string) int {\n","canonical_solution":"package count_upper_test\n\nimport (\n    \"testing\"\n)\n\nfunc count_upper(s string) int {\n    uppercaseVowels := \"AEIOU\"\n    count := 0\n    \n    for i := 0; i < len(s); i += 2 {\n        if contains(uppercaseVowels, s[i]) {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfunc contains(vowels string, ch byte) bool {\n    for i := 0; i < len(vowels); i++ {\n        if vowels[i] == ch {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCountUpper(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"aBCdEf\", 1},\n        {\"abcdefg\", 0},\n        {\"dBBE\", 0},\n    }\n\n    for _, test := range tests {\n        result := count_upper(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestCount_Upper(t *testing.T) {\n  candidate := count_upper\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"aBCdEf\"), expected: 1 },\n     { actual: candidate(\"abcdefg\"), expected: 0 },\n     { actual: candidate(\"dBBE\"), expected: 0 },\n     { actual: candidate(\"B\"), expected: 0 },\n     { actual: candidate(\"U\"), expected: 1 },\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"EEEE\"), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_99","nl":"eng_Latn","pl":"go_test.go","prompt":"package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function that takes a value (string) representing a number\n\/\/ and returns the closest integer to it. If the number is equidistant\n\/\/ from two integers, round it away from zero.\n\/\/ Examples\n\/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n","canonical_solution":"package closest_integer_test\n\nimport (\n\t\"strconv\"\n\t\"math\"\n)\n\nfunc closest_integer(value string) int {\n\tnum, err := strconv.ParseFloat(value, 64)\n\tif err != nil {\n\t\treturn 0 \/\/ handle error appropriately in real scenarios\n\t}\n\tif num > 0 {\n\t\treturn int(math.Ceil(num - 0.5))\n\t}\n\treturn int(math.Floor(num + 0.5))\n}","tests":"func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_100","nl":"eng_Latn","pl":"go_test.go","prompt":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, you have to make a pile of n levels of stones.\n\/\/ The first level has n stones.\n\/\/ The number of stones in the next level is:\n\/\/ - the next odd number if n is odd.\n\/\/ - the next even number if n is even.\n\/\/ Return the number of stones in each level in a list, where element at index\n\/\/ i represents the number of stones in the level (i+1).\n\/\/ Examples:\n\/\/ >>> make_a_pile(3)\n\/\/ []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n","canonical_solution":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc make_a_pile(n int) []int {\n    pile := make([]int, n)\n    currentStones := n\n\n    for i := 0; i < n; i++ {\n        pile[i] = currentStones\n        if n%2 == 0 {\n            currentStones += 2\n        } else {\n            currentStones += 2\n        }\n    }\n\n    return pile\n}\n\nfunc TestMakeAPile(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected []int\n    }{\n        {3, []int{3, 5, 7}},\n        {4, []int{4, 6, 8, 10}},\n        {1, []int{1}},\n        {5, []int{5, 7, 9, 11, 13}},\n    }\n\n    for _, c := range cases {\n        res := make_a_pile(c.input)\n        if fmt.Sprintf(\"%v\", res) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"make_a_pile(%d) == %v, expected %v\", c.input, res, c.expected)\n        }\n    }\n}","tests":"func TestMake_A_Pile(t *testing.T) {\n  candidate := make_a_pile\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{3, 5, 7} },\n     { actual: candidate(4), expected: []int{4, 6, 8, 10} },\n     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },\n     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },\n     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_101","nl":"eng_Latn","pl":"go_test.go","prompt":"package words_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You will be given a string of words separated by commas or spaces. Your task is\n\/\/ to split the string into words and return a list of the words.\n\/\/ For example:\n\/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\nfunc words_string(s string) []string {\n","canonical_solution":"package words_string_test\n\nimport (\n    \"testing\"\n    \"strings\"\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc words_string(s string) []string {\n    re := regexp.MustCompile(`[,\\s]+`)\n    return re.Split(s, -1)\n}\n\nfunc TestWordsString(t *testing.T) {\n    tests := []struct{\n        input string\n        expected []string\n    }{\n        {\"Hi, my name is John\", []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}},\n        {\"One, two, three, four, five, six\", []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}},\n        {\"a,b,c\", []string{\"a\", \"b\", \"c\"}},\n        {\"hello world\", []string{\"hello\", \"world\"}},\n    }\n\n    for _, test := range tests {\n        result := words_string(test.input)\n        if !equal(result, test.expected) {\n            t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestWords_String(t *testing.T) {\n  candidate := words_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi, my name is John\"), expected: []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"} },\n     { actual: candidate(\"One, two, three, four, five, six\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"Hi, my name\"), expected: []string{\"Hi\", \"my\", \"name\"} },\n     { actual: candidate(\"One,, two, three, four, five, six,\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"ahmed     , gamal\"), expected: []string{\"ahmed\", \"gamal\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_102","nl":"eng_Latn","pl":"go_test.go","prompt":"package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ This function takes two positive numbers x and y and returns the\n\/\/ biggest even integer number that is in the range [x, y] inclusive. If \n\/\/ there's no such number, then the function should return -1.\n\/\/ For example:\n\/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunc choose_num(x int, y int) int {\n","canonical_solution":"func choose_num(x int, y int) int {\n\tif x > y {\n\t\treturn -1\n\t}\n\t\/\/ Start from y and move backwards looking for the largest even number\n\tfor i := y; i >= x; i-- {\n\t\tif i%2 == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc TestChooseNum(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, expected int\n\t}{\n\t\t{12, 15, 14},\n\t\t{13, 12, -1},\n\t\t{4, 10, 10},\n\t\t{5, 5, -1},\n\t\t{6, 6, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"x=%d_y=%d\", test.x, test.y), func(t *testing.T) {\n\t\t\tresult := choose_num(test.x, test.y)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For choose_num(%d, %d), expected %d, but got %d\", test.x, test.y, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestChoose_Num(t *testing.T) {\n  candidate := choose_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(12, 15), expected: 14 },\n     { actual: candidate(13, 12), expected: -1 },\n     { actual: candidate(33, 12354), expected: 12354 },\n     { actual: candidate(5234, 5233), expected: -1 },\n     { actual: candidate(6, 29), expected: 28 },\n     { actual: candidate(27, 10), expected: -1 },\n     { actual: candidate(7, 7), expected: -1 },\n     { actual: candidate(546, 546), expected: 546 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_104","nl":"eng_Latn","pl":"go_test.go","prompt":"package unique_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list of positive integers x. return a sorted list of all \n\/\/ elements that hasn't any even digit.\n\/\/ Note: Returned list should be sorted in increasing order.\n\/\/ For example:\n\/\/ >>> unique_digits([]int{15, 33, 1422, 1})\n\/\/ []int{1, 15, 33}\n\/\/ >>> unique_digits([]int{152, 323, 1422, 10})\n\/\/ []int{}\nfunc unique_digits(x []int) []int {\n","canonical_solution":"package unique_digits_test\n\nimport (\n    \"sort\"\n)\n\n\/\/ unique_digits returns a sorted list of all elements that don't have any even digit.\nfunc unique_digits(x []int) []int {\n    result := []int{}\n    for _, num := range x {\n        if hasEvenDigit(num) == false {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\n\/\/ hasEvenDigit checks if a given number contains any even digit.\nfunc hasEvenDigit(num int) bool {\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            return true\n        }\n        num \/= 10\n    }\n    return false\n}","tests":"func TestUnique_Digits(t *testing.T) {\n  candidate := unique_digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },\n     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },\n     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },\n     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_105","nl":"eng_Latn","pl":"go_test.go","prompt":"package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\/\/ reverse the resulting list, and then replace each digit by its corresponding name from\n\/\/ \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\/\/ For example:\n\/\/ >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})\n\/\/ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\/\/ If the list is empty, return an empty list:\n\/\/ >>> by_length([]int{})\n\/\/ []string{}\n\/\/ If the list has any strange number ignore it:\n\/\/ >>> by_length([]int{1, -1, 55})\n\/\/ []string{\"One\"}\nfunc by_length(arr []int) []string {\n","canonical_solution":"package by_length_test\n\nimport (\n    \"testing\"\n    \"sort\"\n)\n\nfunc by_length(arr []int) []string {\n    \/\/ Filter numbers between 1 and 9\n    filtered := []int{}\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            filtered = append(filtered, num)\n        }\n    }\n\n    \/\/ Sort in ascending order\n    sort.Ints(filtered)\n\n    \/\/ Reverse the sorted slice\n    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {\n        filtered[i], filtered[j] = filtered[j], filtered[i]\n    }\n\n    \/\/ Map numbers to their corresponding names\n    numToString := map[int]string{\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\",\n    }\n\n    \/\/ Create the result slice with names\n    result := []string{}\n    for _, num := range filtered {\n        result = append(result, numToString[num])\n    }\n\n    return result\n}\n\nfunc TestByLength(t *testing.T) {\n    tests := []struct {\n        input []int\n        want  []string\n    }{\n        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}},\n        {[]int{}, []string{}},\n        {[]int{1, -1, 55}, []string{\"One\"}},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n            got := by_length(test.input)\n            if !equals(got, test.want) {\n                t.Errorf(\"got = %v; want %v\", got, test.want)\n            }\n        })\n    }\n}\n\nfunc equals(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_106","nl":"eng_Latn","pl":"go_test.go","prompt":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Implement the function f that takes n as a parameter,\n\/\/ and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n\/\/ or the sum of numbers from 1 to i otherwise.\n\/\/ i starts from 1.\n\/\/ the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n\/\/ Example:\n\/\/ >>> f(5)\n\/\/ []int{1, 2, 6, 24, 15}\nfunc f(n int) []int {\n","canonical_solution":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc f(n int) []int {\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            result[i-1] = factorial(i)\n        } else {\n            result[i-1] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc factorial(num int) int {\n    if num <= 1 {\n        return 1\n    }\n    return num * factorial(num-1)\n}\n\nfunc sum(num int) int {\n    s := 0\n    for i := 1; i <= num; i++ {\n        s += i\n    }\n    return s\n}\n\nfunc TestF(t *testing.T) {\n    expected := []int{1, 2, 6, 24, 15}\n    result := f(5)\n    if !equals(expected, result) {\n        t.Errorf(\"Expected %v, got %v\", expected, result)\n    }\n}\n\nfunc equals(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(f(5)) \/\/ Output: []int{1, 2, 6, 24, 15}\n}","tests":"func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },\n     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },\n     { actual: candidate(1), expected: []int{1} },\n     { actual: candidate(3), expected: []int{1, 2, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_107","nl":"eng_Latn","pl":"go_test.go","prompt":"package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return a list that has the number of even and odd\n\/\/ integer palindromes that fall within the range(1, n), inclusive.\n\/\/ Example 1:\n\/\/ >>> even_odd_palindrome(3)\n\/\/ []interface{}{1, 2}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ []interface{}{4, 6}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned list has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n int) []interface{} {\n","canonical_solution":"func isPalindrome(num int) bool {\n    original := num\n    reversed := 0\n    for num > 0 {\n        reversed = reversed*10 + num%10\n        num \/= 10\n    }\n    return original == reversed\n}\n\nfunc even_odd_palindrome(n int) []interface{} {\n    evenCount, oddCount := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n}","tests":"func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8, 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     { actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63), expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5, 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     { actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1), expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_108","nl":"eng_Latn","pl":"go_test.go","prompt":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function count_nums which takes a list of integers and returns\n\/\/ the number of elements which has a sum of digits > 0.\n\/\/ If a number is negative, then its first signed digit will be negative:\n\/\/ e.g. -123 has signed digits -1, 2, and 3.\n\/\/ >>> count_nums([]int{})\n\/\/ 0\n\/\/ >>> count_nums([]int{-1, 11, -11})\n\/\/ 1\n\/\/ >>> count_nums([]int{1, 1, 2})\n\/\/ 3\nfunc count_nums(arr []int) int {\n","canonical_solution":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        digits := num\n        sum := 0\n\n        if digits < 0 {\n            sum = digits % 10\n            digits = -digits \/ 10\n        }\n\n        for digits > 0 {\n            sum += digits % 10\n            digits \/= 10\n        }\n\n        if sum > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCountNums(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{}, 0},\n        {[]int{-1, 11, -11}, 1},\n        {[]int{1, 1, 2}, 3},\n    }\n\n    for _, tc := range testCases {\n        result := count_nums(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %v, got %v\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(count_nums([]int{-1, 11, -11})) \/\/ Output: 1\n    fmt.Println(count_nums([]int{1, 1, 2}))    \/\/ Output: 3\n}","tests":"func TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_109","nl":"eng_Latn","pl":"go_test.go","prompt":"package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\/\/ numbers in the list will be randomly ordered. Your task is to determine if\n\/\/ it is possible to get a list sorted in non-decreasing order by performing \n\/\/ the following operation on the given list:\n\/\/ You are allowed to perform right shift operation any number of times.\n\/\/ One right shift operation means shifting all elements of the list by one\n\/\/ position in the right direction. The last element of the list will be moved to\n\/\/ the starting position in the list i.e. 0th index. \n\/\/ If it is possible to obtain the sorted list by performing the above operation\n\/\/ then return true else return false.\n\/\/ If the given list is empty then return true.\n\/\/ Note: The given list is guaranteed to have unique elements.\n\/\/ For Example:\n\/\/ >>> move_one_ball([]int{3, 4, 5, 1, 2})\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given list.\n\/\/ >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ list by performing any number of right shift operations.\nfunc move_one_ball(arr []int) bool {\n","canonical_solution":"func move_one_ball(arr []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n    }\n\n    \/\/ Detect the point where the order breaks\n    countBreaks := 0\n    index := -1\n\n    for i := 0; i < n; i++ {\n        if arr[i] > arr[(i+1)%n] {\n            countBreaks++\n            index = i\n        }\n    }\n\n    \/\/ If there is at most one point where the order breaks\n    if countBreaks <= 1 {\n        return true\n    }\n\n    return false\n}","tests":"func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_110","nl":"eng_Latn","pl":"go_test.go","prompt":"package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ In this problem, you will implement a function that takes two lists of numbers,\n\/\/ and determines whether it is possible to perform an exchange of elements\n\/\/ between them to make lst1 a list of only even numbers.\n\/\/ There is no limit on the number of exchanged elements between lst1 and lst2.\n\/\/ If it is possible to exchange elements between the lst1 and lst2 to make\n\/\/ all the elements of lst1 to be even, return \"YES\".\n\/\/ Otherwise, return \"NO\".\n\/\/ For example:\n\/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})\n\/\/ \"YES\"\n\/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})\n\/\/ \"NO\"\n\/\/ It is assumed that the input lists will be non-empty.\nfunc exchange(lst1 []int, lst2 []int) string {\n","canonical_solution":"func exchange(lst1 []int, lst2 []int) string {\n    hasEvenInLst2 := false\n    \n    for _, num := range lst2 {\n        if num%2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasEvenInLst2 {\n        return \"NO\"\n    }\n    \n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"YES\"\n        }\n    }\n\n    return \"YES\"\n}","tests":"func TestExchange(t *testing.T) {\n  candidate := exchange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: \"YES\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: \"NO\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: \"NO\" },\n     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: \"NO\" },\n     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: \"YES\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_111","nl":"eng_Latn","pl":"go_test.go","prompt":"package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a string representing a space separated lowercase letters, return a map\n\/\/ of the letter with the most repetition and containing the corresponding count.\n\/\/ If several letters have the same occurrence, return all of them.\n\/\/ Example:\n\/\/ >>> histogram(\"a b c\")\n\/\/ map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ map[string]int{\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ map[string]int{}\nfunc histogram(test string) map[string]int {\n","canonical_solution":"package histogram_test\n\nimport (\n    \"strings\"\n)\n\nfunc histogram(test string) map[string]int {\n    if test == \"\" {\n        return map[string]int{}\n    }\n\n    counts := make(map[string]int)\n    words := strings.Fields(test)\n    \n    var maxCount int\n    for _, word := range words {\n        counts[word]++\n        if counts[word] > maxCount {\n            maxCount = counts[word]\n        }\n    }\n\n    result := make(map[string]int)\n    for key, count := range counts {\n        if count == maxCount {\n            result[key] = count\n        }\n    }\n\n    return result\n}","tests":"func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_112","nl":"eng_Latn","pl":"go_test.go","prompt":"package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Task\n\/\/ We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n\/\/ then check if the result string is palindrome.\n\/\/ A string is called palindrome if it reads the same backward as forward.\n\/\/ You should return a list containing the result string and true\/false for the check.\n\/\/ Example\n\/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ []interface{}{\"bcd\", false}\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ []interface{}{\"acdef\", false}\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ []interface{}{\"cdedc\", true}\nfunc reverse_delete(s string, c string) []interface{} {\n","canonical_solution":"func reverse_delete(s string, c string) []interface{} {\n    \/\/ Create a map to store the characters to be deleted\n    deleteMap := make(map[rune]bool)\n    for _, ch := range c {\n        deleteMap[ch] = true\n    }\n    \n    \/\/ Filter the string s by removing characters present in deleteMap\n    var filteredString []rune\n    for _, ch := range s {\n        if !deleteMap[ch] {\n            filteredString = append(filteredString, ch)\n        }\n    }\n    \n    \/\/ Check if the filtered string is a palindrome\n    n := len(filteredString)\n    isPalindrome := true\n    for i := 0; i < n\/2; i++ {\n        if filteredString[i] != filteredString[n-1-i] {\n            isPalindrome = false\n            break\n        }\n    }\n    \n    \/\/ Convert filteredString to a string and prepare result\n    resultString := string(filteredString)\n    return []interface{}{resultString, isPalindrome}\n}","tests":"func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\", \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_113","nl":"eng_Latn","pl":"go_test.go","prompt":"package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list of strings, where each string consists of only digits, return a list.\n\/\/ Each element i of the output should be \"the number of odd elements in the\n\/\/ string i of the input.\" where all the i's should be replaced by the number\n\/\/ of odd digits in the i'th string of the input.\n\/\/ >>> odd_count([]string{\"1234567\"})\n\/\/ []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n\/\/ >>> odd_count([]string{\"3\", \"11111111\"})\n\/\/ []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}\nfunc odd_count(lst []string) []string {\n","canonical_solution":"package odd_count_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc odd_count(lst []string) []string {\n\tresult := []string{}\n\tfor _, str := range lst {\n\t\toddCount := 0\n\t\tfor _, char := range str {\n\t\t\tif char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {\n\t\t\t\toddCount++\n\t\t\t}\n\t\t}\n\t\toutput := fmt.Sprintf(\"the number of odd elements %dn the str%1ng %d of the %dnput.\", oddCount, oddCount, oddCount)\n\t\tresult = append(result, output)\n\t}\n\treturn result\n}\n\nfunc TestOddCount(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{[]string{\"1234567\"}, []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}},\n\t\t{[]string{\"3\", \"11111111\"}, []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif result := odd_count(test.input); !equals(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equals(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOdd_Count(t *testing.T) {\n  candidate := odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"1234567\"}), expected: []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"} },\n     { actual: candidate([]string{\"3\", \"11111111\"}), expected: []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"} },\n     { actual: candidate([]string{\"271\", \"137\", \"314\"}), expected: []string{\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_114","nl":"eng_Latn","pl":"go_test.go","prompt":"package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list of integers nums, find the minimum sum of any non-empty sub-list\n\/\/ of nums.\n\/\/ Example\n\/\/ >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n\/\/ 1\n\/\/ >>> minSubArraySum([]int{-1, -2, -3})\n\/\/ -6\nfunc minSubArraySum(nums []int) int {\n","canonical_solution":"if len(nums) == 0 {\n        return 0\n    }\n    \n    minEndingHere := nums[0]\n    minSoFar := nums[0]\n\n    for _, num := range nums[1:] {\n        if minEndingHere > 0 {\n            minEndingHere = num\n        } else {\n            minEndingHere += num\n        }\n        \n        if minEndingHere < minSoFar {\n            minSoFar = minEndingHere\n        }\n    }\n    \n    return minSoFar\n}","tests":"func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     { actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}), expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_115","nl":"eng_Latn","pl":"go_test.go","prompt":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a rectangular grid of wells. Each row represents a single well,\n\/\/ and each 1 in a row represents a single unit of water.\n\/\/ Each well has a corresponding bucket that can be used to extract water from it, \n\/\/ and all buckets have the same capacity.\n\/\/ Your task is to use the buckets to empty the wells.\n\/\/ Output the number of times you need to lower the buckets.\n\/\/ Example 1:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid [][]int, capacity int) int {\n","canonical_solution":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_fill(grid [][]int, capacity int) int {\n    totalLowerings := 0\n\n    for _, row := range grid {\n        waterInRow := 0\n        \n        for _, cell := range row {\n            if cell == 1 {\n                waterInRow++\n            }\n        }\n\n        totalLowerings += (waterInRow + capacity - 1) \/ capacity\n    }\n\n    return totalLowerings\n}\n\nfunc TestMaxFill(t *testing.T) {\n    tests := []struct {\n        grid     [][]int\n        capacity int\n        expected int\n    }{\n        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},\n        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},\n        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},\n    }\n\n    for _, test := range tests {\n        result := max_fill(test.grid, test.capacity)\n        if result != test.expected {\n            t.Errorf(\"For grid %v with capacity %d, expected %d but got %d\", test.grid, test.capacity, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) \/\/ Output: 6\n    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) \/\/ Output: 5\n    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) \/\/ Output: 0\n}","tests":"func TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_116","nl":"eng_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ In this Kata, you have to sort a list of non-negative integers according to\n\/\/ number of ones in their binary representation in ascending order.\n\/\/ For similar number of ones, sort based on decimal value.\n\/\/ It must be implemented like this:\n\/\/ >>> sort_array([]int{1, 5, 2, 3, 4})\n\/\/ []int{1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{-2, -3, -4, -5, -6})\n\/\/ []int{-6, -5, -4, -3, -2}\n\/\/ >>> sort_array([]int{1, 0, 2, 3, 4})\n\/\/ []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(arr []int) []int {\n    sort.Slice(arr, func(i, j int) bool {\n        countOnes := func(x int) int {\n            count := 0\n            for x != 0 {\n                count += x & 1\n                x >>= 1\n            }\n            return count\n        }\n\n        countI := countOnes(arr[i])\n        countJ := countOnes(arr[j])\n\n        if countI == countJ {\n            return arr[i] < arr[j]\n        }\n        return countI < countJ\n    })\n    return arr\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_117","nl":"eng_Latn","pl":"go_test.go","prompt":"package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a string s and a natural number n, you have been tasked to implement \n\/\/ a function that returns a list of all words from string s that contain exactly \n\/\/ n consonants, in order these words appear in the string s.\n\/\/ If the string s is empty then the function should return an empty list.\n\/\/ Note: you may assume the input string contains only letters and spaces.\n\/\/ Examples:\n\/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ []string{\"little\"}\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ []string{\"Mary\", \"lamb\"}\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []string{}\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ []string{\"world\"}\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n","canonical_solution":"package select_words_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc select_words(s string, n int) []string {\n\t\/\/ Define a helper function to check if a character is a consonant.\n\tisConsonant := func(c rune) bool {\n\t\tc = rune(strings.ToLower(string(c))[0])\n\t\treturn c >= 'a' && c <= 'z' && !strings.ContainsRune(\"aeiou\", c)\n\t}\n\n\t\/\/ Split the string into words.\n\twords := strings.Fields(s)\n\tvar result []string\n\n\t\/\/ Iterate over each word.\n\tfor _, word := range words {\n\t\tconsonantCount := 0\n\t\t\/\/ Count the consonants in the word.\n\t\tfor _, char := range word {\n\t\t\tif isConsonant(char) {\n\t\t\t\tconsonantCount++\n\t\t\t}\n\t\t}\n\t\t\/\/ If the number of consonants matches n, add the word to the result.\n\t\tif consonantCount == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc TestSelectWords(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        string\n\t\tn        int\n\t\texpected []string\n\t}{\n\t\t{\"Mary had a little lamb\", 4, []string{\"little\"}},\n\t\t{\"Mary had a little lamb\", 3, []string{\"Mary\", \"lamb\"}},\n\t\t{\"simple white space\", 2, []string{}},\n\t\t{\"Hello world\", 4, []string{\"world\"}},\n\t\t{\"Uncle sam\", 3, []string{\"Uncle\"}},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tresult := select_words(testCase.s, testCase.n)\n\t\tif !equal(result, testCase.expected) {\n\t\t\tt.Errorf(\"For input '%s' with n=%d, expected %v, but got %v\", testCase.s, testCase.n, testCase.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_118","nl":"eng_Latn","pl":"go_test.go","prompt":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a word. Your task is to find the closest vowel that stands between \n\/\/ two consonants from the right side of the word (case sensitive).\n\/\/ Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n\/\/ find any vowel met the above condition. \n\/\/ You may assume that the given string contains English letter only.\n\/\/ Example:\n\/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunc get_closest_vowel(word string) string {\n","canonical_solution":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_closest_vowel(word string) string {\n    vowels := \"aeiouAEIOU\"\n    isVowel := make(map[rune]bool)\n    for _, v := range vowels {\n        isVowel[v] = true\n    }\n    \n    n := len(word)\n    for i := n-2; i > 0; i-- {\n        if isVowel[rune(word[i])] && \n           !isVowel[rune(word[i-1])] && \n           !isVowel[rune(word[i+1])] {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\/\/ Test functions\nfunc TestGetClosestVowel(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"yogurt\", \"u\"},\n        {\"FULL\", \"U\"},\n        {\"quick\", \"\"},\n        {\"ab\", \"\"},\n    }\n    \n    for _, test := range tests {\n        result := get_closest_vowel(test.input)\n        if result != test.expected {\n            t.Errorf(\"get_closest_vowel(%q) = %q; want %q\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(get_closest_vowel(\"yogurt\")) \/\/ Output: \"u\"\n    fmt.Println(get_closest_vowel(\"FULL\"))   \/\/ Output: \"U\"\n    fmt.Println(get_closest_vowel(\"quick\"))  \/\/ Output: \"\"\n    fmt.Println(get_closest_vowel(\"ab\"))     \/\/ Output: \"\"\n}","tests":"func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_119","nl":"eng_Latn","pl":"go_test.go","prompt":"package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a list of two strings, both strings consist of open\n\/\/ parentheses '(' or close parentheses ')' only.\n\/\/ Your job is to check if it is possible to concatenate the two strings in\n\/\/ some order, that the resulting string will be good.\n\/\/ A string S is considered to be good if and only if all parentheses in S\n\/\/ are balanced. For example: the string '(())()' is good, while the string\n\/\/ '())' is not.\n\/\/ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\/\/ Examples:\n\/\/ >>> match_parens([]string{\"()(\", \")\"})\n\/\/ \"Yes\"\n\/\/ >>> match_parens([]string{\")\", \")\"})\n\/\/ \"No\"\nfunc match_parens(lst []string) string {\n","canonical_solution":"func match_parens(lst []string) string {\n\tleft1, right1 := countParens(lst[0])\n\tleft2, right2 := countParens(lst[1])\n\n\tif left1+left2 == right1+right2 {\n\t\treturn \"Yes\"\n\t}\n\n\tif left1-right1+left2-right2 == 0 {\n\t\treturn \"Yes\"\n\t}\n\n\treturn \"No\"\n}\n\nfunc countParens(s string) (left int, right int) {\n\tfor _, c := range s {\n\t\tif c == '(' {\n\t\t\tleft++\n\t\t} else if c == ')' {\n\t\t\tright++\n\t\t}\n\t}\n\treturn\n}\n\nfunc TestMatchParens(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected string\n\t}{\n\t\t{[]string{\"()(\", \")\"}, \"Yes\"},\n\t\t{[]string{\")\", \")\"}, \"No\"},\n\t\t{[]string{\"(((\", \")))\"}, \"Yes\"},\n\t\t{[]string{\"(\", \")\"}, \"Yes\"},\n\t\t{[]string{\"))(\", \"(\"}, \"No\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tif got := match_parens(test.input); got != test.expected {\n\t\t\t\tt.Errorf(\"match_parens(%v) = %v; want %v\", test.input, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_120","nl":"eng_Latn","pl":"go_test.go","prompt":"package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list arr of integers and a positive integer k, return a sorted list \n\/\/ of length k with the maximum k numbers in arr.\n\/\/ Example 1:\n\/\/ >>> maximum([]int{-3, -4, 5}, 3)\n\/\/ []int{-4, -3, 5}\n\/\/ Example 2:\n\/\/ >>> maximum([]int{4, -4, 4}, 2)\n\/\/ []int{4, 4}\n\/\/ Example 3:\n\/\/ >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)\n\/\/ []int{2}\n\/\/ Note:\n\/\/ 1. The length of the list will be in the range of [1, 1000].\n\/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n","canonical_solution":"package maximum_test\n\nimport (\n    \"sort\"\n)\n\nfunc maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    \n    \/\/ Sort the array\n    sort.Ints(arr)\n    \n    \/\/ Get the last k elements, which are the largest\n    return arr[len(arr)-k:]\n}","tests":"func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_121","nl":"eng_Latn","pl":"go_test.go","prompt":"package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\/\/ Examples\n\/\/ >>> solution([]int{5, 8, 7, 1})\n\/\/ 12\n\/\/ >>> solution([]int{3, 3, 3, 3, 3})\n\/\/ 9\n\/\/ >>> solution([]int{30, 13, 24, 321})\n\/\/ 0\nfunc solution(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 0; i < len(lst); i++ {\n        if i%2 == 0 && lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestSolution(t *testing.T) {\n  candidate := solution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },\n     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },\n     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },\n     { actual: candidate([]int{5, 9}), expected: 5 },\n     { actual: candidate([]int{2, 4, 8}), expected: 0 },\n     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },\n     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_122","nl":"eng_Latn","pl":"go_test.go","prompt":"package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a non-empty list of integers arr and an integer k, return\n\/\/ the sum of the elements with at most two digits from the first k elements of arr.\n\/\/ Example:\n\/\/ >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr []int, k int) int {\n","canonical_solution":"func add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd_Elements(t *testing.T) {\n  candidate := add_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },\n     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },\n     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },\n     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },\n     { actual: candidate([]int{1}, 1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_123","nl":"eng_Latn","pl":"go_test.go","prompt":"package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\/\/ The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n\/\/ as follows: start with any positive integer n. Then each term is obtained from the \n\/\/ previous term as follows: if the previous term is even, the next term is one half of \n\/\/ the previous term. If the previous term is odd, the next term is 3 times the previous\n\/\/ term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\/\/ Note: \n\/\/ 1. Collatz(1) is [1].\n\/\/ 2. returned list sorted in increasing order.\n\/\/ For example:\n\/\/ get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\/\/ >>> get_odd_collatz(5)\n\/\/ []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n","canonical_solution":"package get_odd_collatz_test\n\nimport (\n    \"sort\"\n)\n\nfunc get_odd_collatz(n int) []int {\n    oddNumbers := make(map[int]bool)\n\n    for n != 1 {\n        if n%2 != 0 {\n            oddNumbers[n] = true\n        }\n        if n%2 == 0 {\n            n \/= 2\n        } else {\n            n = 3*n + 1\n        }\n    }\n\n    \/\/ Add 1 to the set of odd numbers because the sequence always ends at 1\n    oddNumbers[1] = true\n\n    \/\/ Extract the keys, which represent the odd numbers\n    result := make([]int, 0, len(oddNumbers))\n    for num := range oddNumbers {\n        result = append(result, num)\n    }\n\n    \/\/ Sort the result\n    sort.Ints(result)\n\n    return result\n}","tests":"func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_124","nl":"eng_Latn","pl":"go_test.go","prompt":"package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You have to write a function which validates a given date string and\n\/\/ returns true if the date is valid otherwise false.\n\/\/ The date is valid if all of the following rules are satisfied:\n\/\/ 1. The date string is not empty.\n\/\/ 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n\/\/ 3. The months should not be less than 1 or higher than 12.\n\/\/ 4. The date should be in the format: mm-dd-yyyy\n\/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunc valid_date(date string) bool {\n","canonical_solution":"func valid_date(date string) bool {\n    if len(date) == 0 {\n        return false\n    }\n\n    var month, day, year int\n    n, err := fmt.Sscanf(date, \"%02d-%02d-%04d\", &month, &day, &year)\n\n    if err != nil || n != 3 {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if month == 2 {\n        if day < 1 || day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n\n    return true\n}","tests":"func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_126","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list of numbers, return whether or not they are sorted\n\/\/ in ascending order. If list has more than 1 duplicate of the same\n\/\/ number, return false. Assume no negative numbers and only integers.\n\/\/ Examples\n\/\/ >>> is_sorted([]int{5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n\/\/ false\nfunc is_sorted(lst []int) bool {\n","canonical_solution":"func is_sorted(lst []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    \n    duplicateCount := make(map[int]int)\n\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        duplicateCount[lst[i]]++\n        if duplicateCount[lst[i]] > 1 {\n            return false\n        }\n    }\n    \n    \/\/ Check the last element for duplicate\n    duplicateCount[lst[len(lst)-1]]++\n    if duplicateCount[lst[len(lst)-1]] > 1 {\n        return false\n    }\n\n    return true\n}","tests":"func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_127","nl":"eng_Latn","pl":"go_test.go","prompt":"package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given two intervals,\n\/\/ where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n\/\/ The given intervals are closed which means that the interval (start, end)\n\/\/ includes both start and end.\n\/\/ For each given interval, it is assumed that its start is less or equal its end.\n\/\/ Your task is to determine whether the length of intersection of these two \n\/\/ intervals is a prime number.\n\/\/ Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\/\/ which its length is 1, which not a prime number.\n\/\/ If the length of the intersection is a prime number, return \"YES\",\n\/\/ otherwise, return \"NO\".\n\/\/ If the two intervals don't intersect, return \"NO\".\n\/\/ [input\/output] samples:\n\/\/ >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\/\/ \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n","canonical_solution":"package intersection_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to determine if a number is prime\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tif num == 2 {\n\t\treturn true\n\t}\n\tif num%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= num; i += 2 {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n\tstart1, end1 := interval1[0].(int), interval1[1].(int)\n\tstart2, end2 := interval2[0].(int), interval2[1].(int)\n\n\t\/\/ Determine the intersection of two intervals\n\tintersectStart := max(start1, start2)\n\tintersectEnd := min(end1, end2)\n\n\tif intersectStart > intersectEnd {\n\t\treturn \"NO\"\n\t}\n\n\t\/\/ The length of intersection is end - start\n\tlengthOfIntersection := intersectEnd - intersectStart\n\tif isPrime(lengthOfIntersection) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\n\/\/ Helper function to find the maximum of two integers\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\/\/ Helper function to find the minimum of two integers\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc TestIntersection(t *testing.T) {\n\tif intersection([]interface{}{1, 2}, []interface{}{2, 3}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != \"YES\" {\n\t\tt.Error(\"Expected YES\")\n\t}\n}","tests":"func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_129","nl":"eng_Latn","pl":"go_test.go","prompt":"package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n\/\/ each cell of the grid contains a value. Every integer in the range [1, N * N]\n\/\/ inclusive appears exactly once on the cells of the grid.\n\/\/ You have to find the minimum path of length k in the grid. You can start\n\/\/ from any cell, and in each step you can move to any of the neighbor cells,\n\/\/ in other words, you can go to cells which share an edge with you current\n\/\/ cell.\n\/\/ Please note that a path of length k means visiting exactly k cells (not\n\/\/ necessarily distinct).\n\/\/ You CANNOT go off the grid.\n\/\/ A path A (of length k) is considered less than a path B (of length k) if\n\/\/ after making the ordered lists of the values on the cells that A and B go\n\/\/ through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\/\/ than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\/\/ such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n\/\/ lst_A[j] = lst_B[j].\n\/\/ It is guaranteed that the answer is unique.\n\/\/ Return an ordered list of the values on the cells that the minimum path go through.\n\/\/ Examples:    \n\/\/ >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)\n\/\/ []int{1, 2, 1}\n\/\/ >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)\n\/\/ []int{1}\nfunc minPath(grid [][]int, k int) []int {\n","canonical_solution":"package minPath_test\n\nimport (\n    \"sort\"\n)\n\nfunc minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    \n    var dfs func(x, y, length int, path []int)\n    var minPath []int\n    minPath = make([]int, k)\n    for i := 0; i < k; i++ {\n        minPath[i] = n*n + 1\n    }\n\n    dfs = func(x, y, length int, path []int) {\n        if length == k {\n            if isLess(path, minPath) {\n                copy(minPath, path)\n            }\n            return\n        }\n        \n        for _, dir := range directions {\n            nx, ny := x+dir[0], y+dir[1]\n            if nx >= 0 && ny >= 0 && nx < n && ny < n {\n                path[length] = grid[nx][ny]\n                dfs(nx, ny, length+1, path)\n            }\n        }\n    }\n    \n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            path := make([]int, k)\n            path[0] = grid[i][j]\n            dfs(i, j, 1, path)\n        }\n    }\n    \n    return minPath\n}\n\nfunc isLess(a, b []int) bool {\n    for i := 0; i < len(a); i++ {\n        if a[i] < b[i] {\n            return true\n        }\n        if a[i] > b[i] {\n            return false\n        }\n    }\n    return false\n}","tests":"func TestMinpath(t *testing.T) {\n  candidate := minPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },\n     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },\n     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },\n     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },\n     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },\n     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },\n     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_130","nl":"eng_Latn","pl":"go_test.go","prompt":"package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n\/\/ the last couple centuries. However, what people don't know is Tribonacci sequence.\n\/\/ Tribonacci sequence is defined by the recurrence:\n\/\/ tri(1) = 3\n\/\/ tri(n) = 1 + n \/ 2, if n is even.\n\/\/ tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n\/\/ For example:\n\/\/ tri(2) = 1 + (2 \/ 2) = 2\n\/\/ tri(4) = 3\n\/\/ tri(3) = tri(2) + tri(1) + tri(4)\n\/\/ = 2 + 3 + 3 = 8 \n\/\/ You are given a non-negative integer number n, you have to a return a list of the \n\/\/ first n + 1 numbers of the Tribonacci sequence.\n\/\/ Examples:\n\/\/ >>> tri(3)\n\/\/ []int{1, 3, 2, 8}\nfunc tri(n int) []int {\n","canonical_solution":"func tri(n int) []int {\n    if n < 0 {\n        return []int{}\n    }\n    sequence := make([]int, n+1)\n    sequence[0] = 1 \/\/ tri(0) is not defined in problem, let's start with tri(1)\n    if n >= 1 {\n        sequence[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            sequence[i] = 1 + i\/2\n        } else {\n            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)\n        }\n    }\n    return sequence\n}\n\nfunc getNextTribonacci(n int) int {\n    if n%2 == 0 {\n        return 1 + n\/2\n    }\n    return getNextTribonacciRec(n+1)\n}\n\nfunc getNextTribonacciRec(n int) int {\n    triNext := make([]int, n+1)\n    triNext[0] = 1 \/\/ again assuming some base start\n    if n >= 1 {\n        triNext[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            triNext[i] = 1 + i\/2\n        } else {\n            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)\n        }\n    }\n    return triNext[n]\n}","tests":"func TestTri(t *testing.T) {\n  candidate := tri\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{1, 3, 2, 8} },\n     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },\n     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },\n     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },\n     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },\n     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },\n     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },\n     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },\n     { actual: candidate(0), expected: []int{1} },\n     { actual: candidate(1), expected: []int{1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_131","nl":"eng_Latn","pl":"go_test.go","prompt":"package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return the product of the odd digits.\n\/\/ Return 0 if all digits are even.\n\/\/ For example:\n\/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunc digits(n int) int {\n","canonical_solution":"product := 1\n    hasOdd := false\n\n    for n > 0 {\n        digit := n % 10\n        if digit%2 != 0 {\n            product *= digit\n            hasOdd = true\n        }\n        n \/= 10\n    }\n\n    if hasOdd {\n        return product\n    }\n    return 0\n}","tests":"func TestDigits(t *testing.T) {\n  candidate := digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 5 },\n     { actual: candidate(54), expected: 5 },\n     { actual: candidate(120), expected: 1 },\n     { actual: candidate(5014), expected: 5 },\n     { actual: candidate(98765), expected: 315 },\n     { actual: candidate(5576543), expected: 2625 },\n     { actual: candidate(2468), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_132","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function that takes a string as input which contains only square brackets.\n\/\/ The function should return true if and only if there is a valid subsequence of brackets \n\/\/ where at least one bracket in the subsequence is nested.\n\/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunc is_nested(myString string) bool {\n","canonical_solution":"func is_nested(myString string) bool {\n\tstack := []rune{}\n\tnestingFound := false\n\n\tfor _, char := range myString {\n\t\tif char == '[' {\n\t\t\tstack = append(stack, char)\n\t\t} else if char == ']' {\n\t\t\tif len(stack) > 0 {\n\t\t\t\tstack = stack[:len(stack)-1]\n\t\t\t\tif len(stack) > 0 {\n\t\t\t\t\tnestingFound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nestingFound\n}","tests":"func TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_133","nl":"eng_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a list of numbers.\n\/\/ You need to return the sum of squared numbers in the given list,\n\/\/ round each element in the list to the upper int(Ceiling) first.\n\/\/ Examples:\n\/\/ >>> lst([]float64{1.0, 2.0, 3.0})\n\/\/ 14\n\/\/ >>> lst([]float64{1.0, 4.0, 9.0})\n\/\/ 98\n\/\/ >>> lst([]float64{1.0, 3.0, 5.0, 7.0})\n\/\/ 84\n\/\/ >>> lst([]float64{1.4, 4.2, 0.0})\n\/\/ 29\n\/\/ >>> lst([]float64{-2.4, 1.0, 1.0})\n\/\/ 6\nfunc sum_squares(lst []float64) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n\t\"math\"\n)\n\nfunc sum_squares(lst []float64) int {\n\tsum := 0\n\tfor _, num := range lst {\n\t\tceiledNum := math.Ceil(num)\n\t\tsum += int(ceiledNum * ceiledNum)\n\t}\n\treturn sum\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },\n     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },\n     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },\n     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },\n     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },\n     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },\n     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },\n     { actual: candidate([]float64{0.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0}), expected: 1 },\n     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_134","nl":"eng_Latn","pl":"go_test.go","prompt":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function that returns true if the last character\n\/\/ of a given string is an alphabetical character and is not\n\/\/ a part of a word, and false otherwise.\n\/\/ Note: \"word\" is a group of characters separated by space.\n\/\/ Examples:\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n","canonical_solution":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"unicode\"\n)\n\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {\n        return false\n    }\n    \n    lastCharIndex := len(txt) - 1\n    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {\n        lastCharIndex--\n    }\n    \n    if lastCharIndex < 0 {\n        return false\n    }\n\n    if !unicode.IsLetter(rune(txt[lastCharIndex])) {\n        return false\n    }\n    \n    \/\/ Check if it's part of a word by looking at the previous character\n    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {\n        return false\n    }\n\n    return true\n}\n\nfunc TestCheckIfLastCharIsALetter(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected bool\n    }{\n        {\"apple pie\", false},\n        {\"apple pi e\", true},\n        {\"apple pi e \", false},\n        {\"\", false},\n        {\"hello world\", true},\n        {\"a \", true},\n        {\" a\", true},\n        {\"abc\", false},\n        {\"abc \", false},\n    }\n\n    for _, c := range cases {\n        t.Run(c.input, func(t *testing.T) {\n            result := check_if_last_char_is_a_letter(c.input)\n            if result != c.expected {\n                t.Errorf(\"Expected %v, got %v for input \\\"%s\\\"\", c.expected, result, c.input)\n            }\n        })\n    }\n}","tests":"func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_135","nl":"eng_Latn","pl":"go_test.go","prompt":"package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function which returns the largest index of an element which\n\/\/ is not greater than or equal to the element immediately preceding it. If\n\/\/ no such element exists then return -1. The given list will not contain\n\/\/ duplicate values.\n\/\/ Examples:\n\/\/ >>> can_arrange([]int{1, 2, 4, 3, 5})\n\/\/ 3\n\/\/ >>> can_arrange([]int{1, 2, 3})\n\/\/ -1\nfunc can_arrange(arr []int) int {\n","canonical_solution":"package can_arrange_test\n\nfunc can_arrange(arr []int) int {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_136","nl":"eng_Latn","pl":"go_test.go","prompt":"package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function that returns a list (a, b), where 'a' is\n\/\/ the largest of negative integers, and 'b' is the smallest\n\/\/ of positive integers in a list.\n\/\/ If there is no negative or positive integers, return them as nil.\n\/\/ Examples:\n\/\/ >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\/\/ []interface{}{nil, 1}\n\/\/ >>> largest_smallest_integers([]int{})\n\/\/ []interface{}{nil, nil}\n\/\/ >>> largest_smallest_integers([]int{0})\n\/\/ []interface{}{nil, nil}\nfunc largest_smallest_integers(lst []int) []interface{} {\n","canonical_solution":"func largest_smallest_integers(lst []int) []interface{} {\n    var largestNegative *int\n    var smallestPositive *int\n\n    for _, num := range lst {\n        if num < 0 {\n            if largestNegative == nil || num > *largestNegative {\n                largestNegative = new(int)\n                *largestNegative = num\n            }\n        } else if num > 0 {\n            if smallestPositive == nil || num < *smallestPositive {\n                smallestPositive = new(int)\n                *smallestPositive = num\n            }\n        }\n    }\n\n    var result = []interface{}{nil, nil}\n    if largestNegative != nil {\n        result[0] = *largestNegative\n    }\n    if smallestPositive != nil {\n        result[1] = *smallestPositive\n    }\n\n    return result\n}","tests":"func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_138","nl":"eng_Latn","pl":"go_test.go","prompt":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n\/\/ Example\n\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n","canonical_solution":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n\/\/ Example\n\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n    \/\/ The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    \/\/ Therefore, n must be at least 8 and n must be even\n    return n >= 8 && n%2 == 0\n}\n\n\/\/ Testing the function\nfunc TestIsEqualToSumEven(t *testing.T) {\n    cases := []struct {\n        n      int\n        expect bool\n    }{\n        {4, false},\n        {6, false},\n        {8, true},\n        {10, true},\n        {12, true},\n        {14, true},\n        {16, true},\n    }\n\n    for _, c := range cases {\n        result := is_equal_to_sum_even(c.n)\n        if result != c.expect {\n            t.Errorf(\"is_equal_to_sum_even(%d) == %v, expect %v\", c.n, result, c.expect)\n        } else {\n            fmt.Printf(\"Success: is_equal_to_sum_even(%d) == %v\\n\", c.n, result)\n        }\n    }\n}","tests":"func TestIs_Equal_To_Sum_Even(t *testing.T) {\n  candidate := is_equal_to_sum_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: false },\n     { actual: candidate(6), expected: false },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: true },\n     { actual: candidate(11), expected: false },\n     { actual: candidate(12), expected: true },\n     { actual: candidate(13), expected: false },\n     { actual: candidate(16), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_139","nl":"eng_Latn","pl":"go_test.go","prompt":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ The Brazilian factorial is defined as:\n\/\/ brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\/\/ where n > 0\n\/\/ For example:\n\/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunc special_factorial(n int) int {\n","canonical_solution":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc special_factorial(n int) int {\n    if n <= 0 {\n        return 1\n    }\n    \n    result := 1\n    for i := 1; i <= n; i++ {\n        result *= factorial(i)\n    }\n    \n    return result\n}\n\nfunc factorial(x int) int {\n    if x == 0 {\n        return 1\n    }\n    prod := 1\n    for i := 1; i <= x; i++ {\n        prod *= i\n    }\n    return prod\n}\n\nfunc TestSpecialFactorial(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {4, 288},      \/\/ 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n        {3, 12},       \/\/ 3! * 2! * 1! = 6 * 2 * 1 = 12\n        {2, 2},        \/\/ 2! * 1! = 2 * 1 = 2\n        {1, 1},        \/\/ 1! = 1\n        {0, 1},        \/\/ Edge case for n=0, considered as 1 for special factorial\n    }\n\n    for _, c := range cases {\n        result := special_factorial(c.input)\n        if result != c.expected {\n            t.Errorf(\"special_factorial(%d) == %d, want %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(special_factorial(4)) \/\/ Output: 288\n    fmt.Println(special_factorial(3)) \/\/ Output: 12\n}","tests":"func TestSpecial_Factorial(t *testing.T) {\n  candidate := special_factorial\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: 288 },\n     { actual: candidate(5), expected: 34560 },\n     { actual: candidate(7), expected: 125411328000 },\n     { actual: candidate(1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_140","nl":"eng_Latn","pl":"go_test.go","prompt":"package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a string text, replace all spaces in it with underscores, \n\/\/ and if a string has more than 2 consecutive spaces, \n\/\/ then replace all consecutive spaces with - \n\/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunc fix_spaces(text string) string {\n","canonical_solution":"package fix_spaces_test\n\nimport (\n    \"strings\"\n    \"testing\"\n)\n\nfunc fix_spaces(text string) string {\n    var result string\n    spaceCount := 0\n\n    for _, char := range text {\n        if char == ' ' {\n            spaceCount++\n        } else {\n            if spaceCount == 1 {\n                result += \"_\"\n            } else if spaceCount > 1 {\n                result += \"-\"\n            }\n            result += string(char)\n            spaceCount = 0\n        }\n    }\n\n    \/\/ Handle trailing spaces\n    if spaceCount == 1 {\n        result += \"_\"\n    } else if spaceCount > 1 {\n        result += \"-\"\n    }\n\n    return result\n}\n\nfunc TestFixSpaces(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected string\n    }{\n        {\" Example\", \"Example\"},\n        {\" Example 1\", \"Example_1\"},\n        {\" Example 2\", \"_Example_2\"},\n        {\" Example 3\", \"_Example-3\"},\n        {\" Hello    world\", \"_Hello-world\"},\n        {\"   Leading spaces\", \"-Leading_spaces\"},\n    }\n\n    for _, c := range cases {\n        result := fix_spaces(c.input)\n        if result != c.expected {\n            t.Errorf(\"fix_spaces(%q) == %q, expected %q\", c.input, result, c.expected)\n        }\n    }\n}","tests":"func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n     { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n     { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\" },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n     { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_141","nl":"eng_Latn","pl":"go_test.go","prompt":"package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Create a function which takes a string representing a file's name, and returns\n\/\/ 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\/\/ A file's name is considered to be valid if and only if all the following conditions \n\/\/ are met:\n\/\/ - There should not be more than three digits ('0'-'9') in the file's name.\n\/\/ - The file's name contains exactly one dot '.'\n\/\/ - The substring before the dot should not be empty, and it starts with a letter from \n\/\/ the latin alphapet ('a'-'z' and 'A'-'Z').\n\/\/ - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\/\/ Examples:\n\/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunc file_name_check(file_name string) string {\n","canonical_solution":"package file_name_check_test\n\nimport (\n    \"strings\"\n    \"unicode\"\n)\n\nfunc file_name_check(file_name string) string {\n    if len(file_name) == 0 {\n        return \"No\"\n    }\n\n    \/\/ Condition 2: Check for exactly one dot\n    dotIndex := strings.LastIndex(file_name, \".\")\n    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {\n        return \"No\"\n    }\n\n    \/\/ Split the file name into two parts\n    namePart := file_name[:dotIndex]\n    extension := file_name[dotIndex+1:]\n\n    \/\/ Condition 4: Check the extension\n    validExtensions := map[string]bool{\n        \"txt\": true,\n        \"exe\": true,\n        \"dll\": true,\n    }\n    if !validExtensions[extension] {\n        return \"No\"\n    }\n\n    \/\/ Condition 3: Check the first character before the dot\n    if !unicode.IsLetter(rune(namePart[0])) {\n        return \"No\"\n    }\n\n    \/\/ Condition 1: Count the digits in the file name\n    digitCount := 0\n    for _, char := range namePart {\n        if unicode.IsDigit(char) {\n            digitCount++\n        }\n    }\n    if digitCount > 3 {\n        return \"No\"\n    }\n\n    \/\/ If all conditions are met, return \"Yes\"\n    return \"Yes\"\n}","tests":"func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual: candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"\/this_is_valid.dll\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n     { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual: candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual: candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     { actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected: \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_142","nl":"eng_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ \"\n\/\/ This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n\/\/ multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n\/\/ change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\/\/ Examples:\n\/\/ >>> lst\n\/\/ []int{1, 2, 3}\n\/\/ >>> lst\n\/\/ int{}\n\/\/ >>> lst\n\/\/ []int{-1, -5, 2, -1, -5}\nfunc sum_squares(lst []int) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n    \"testing\"\n)\n\nfunc sum_squares(lst []int) int {\n    sum := 0\n    for i, val := range lst {\n        if i%3 == 0 {\n            sum += val * val\n        } else if i%4 == 0 {\n            sum += val * val * val\n        } else {\n            sum += val\n        }\n    }\n    return sum\n}\n\nfunc TestSumSquares(t *testing.T) {\n    tests := []struct {\n        lst      []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 10},   \/\/ 1^2 + 2 + 3 = 10\n        {[]int{}, 0},           \/\/ empty list\n        {[]int{-1, -5, 2, -1, -5}, 0}, \/\/ (-1)^2 + (-5)^3 + 2 + (-1) = -118\n    }\n\n    for _, test := range tests {\n        result := sum_squares(test.lst)\n        if result != test.expected {\n            t.Errorf(\"sum_squares(%v) = %d; expected %d\", test.lst, result, test.expected)\n        }\n    }\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 6 },\n     { actual: candidate([]int{1, 4, 9}), expected: 14 },\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },\n     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },\n     { actual: candidate([]int{0}), expected: 0 },\n     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },\n     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },\n     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },\n     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },\n     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_143","nl":"eng_Latn","pl":"go_test.go","prompt":"package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a string representing a sentence,\n\/\/ the sentence contains some words separated by a space,\n\/\/ and you have to return a string that contains the words from the original sentence,\n\/\/ whose lengths are prime numbers,\n\/\/ the order of the words in the new string should be the same as the original one.\n\/\/ Example 1:\n\/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n","canonical_solution":"package words_in_sentence_test\n\nimport (\n    \"strings\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc words_in_sentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var result []string\n\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result = append(result, word)\n        }\n    }\n\n    return strings.Join(result, \" \")\n}","tests":"func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_144","nl":"eng_Latn","pl":"go_test.go","prompt":"package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Your task is to implement a function that will simplify the expression\n\/\/ x * n. The function returns true if x * n evaluates to a whole number and false\n\/\/ otherwise. Both x and n, are string representation of a fraction, and have the following format,\n\/\/ <numerator>\/<denominator> where both numerator and denominator are positive whole numbers.\n\/\/ You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunc simplify(x string, n string) bool {\n","canonical_solution":"package simplify_test\n\nimport (\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc simplify(x string, n string) bool {\n    \/\/ Split the input strings into numerators and denominators\n    xParts := strings.Split(x, \"\/\")\n    nParts := strings.Split(n, \"\/\")\n\n    \/\/ Convert the string parts to integers\n    xNumerator, _ := strconv.Atoi(xParts[0])\n    xDenominator, _ := strconv.Atoi(xParts[1])\n    nNumerator, _ := strconv.Atoi(nParts[0])\n    nDenominator, _ := strconv.Atoi(nParts[1])\n\n    \/\/ Perform the multiplication (x * n) = (xNumerator\/nDenominator) * (nNumerator\/nDenominator)\n    resultNumerator := xNumerator * nNumerator\n    resultDenominator := xDenominator * nDenominator\n\n    \/\/ Check if the result is a whole number\n    return resultNumerator%resultDenominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n    if !simplify(\"1\/5\", \"5\/1\") {\n        t.Fatalf(\"Expected true, got false\")\n    }\n    if simplify(\"1\/6\", \"2\/1\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n    if simplify(\"7\/10\", \"10\/2\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n}","tests":"func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/6\", \"2\/1\"), expected: false },\n     { actual: candidate(\"5\/1\", \"3\/1\"), expected: true },\n     { actual: candidate(\"7\/10\", \"10\/2\"), expected: false },\n     { actual: candidate(\"2\/10\", \"50\/10\"), expected: true },\n     { actual: candidate(\"7\/2\", \"4\/2\"), expected: true },\n     { actual: candidate(\"11\/6\", \"6\/1\"), expected: true },\n     { actual: candidate(\"2\/3\", \"5\/2\"), expected: false },\n     { actual: candidate(\"5\/2\", \"3\/5\"), expected: false },\n     { actual: candidate(\"2\/4\", \"8\/4\"), expected: true },\n     { actual: candidate(\"2\/4\", \"4\/2\"), expected: true },\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/5\", \"1\/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_145","nl":"eng_Latn","pl":"go_test.go","prompt":"package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function which sorts the given list of integers\n\/\/ in ascending order according to the sum of their digits.\n\/\/ Note: if there are several items with similar sum of their digits,\n\/\/ order them based on their index in original list.\n\/\/ For example:\n\/\/ >>> order_by_points([]int{1, 11, -1, -11, -12})\n\/\/ []int{-1, -11, 1, -12, 11}\n\/\/ >>> order_by_points([]int{})\n\/\/ []int{}\nfunc order_by_points(nums []int) []int {\n","canonical_solution":"package order_by_points_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc digitSum(n int) int {\n\tn = abs(n) \/\/ Consider the absolute value for digit sum\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc order_by_points(nums []int) []int {\n\ttype numWithIndex struct {\n\t\tnum   int\n\t\tindex int\n\t}\n\n\tnumsWithIndex := make([]numWithIndex, len(nums))\n\tfor i, num := range nums {\n\t\tnumsWithIndex[i] = numWithIndex{num, i}\n\t}\n\n\tsort.Slice(numsWithIndex, func(i, j int) bool {\n\t\tsumI := digitSum(numsWithIndex[i].num)\n\t\tsumJ := digitSum(numsWithIndex[j].num)\n\t\tif sumI == sumJ {\n\t\t\treturn numsWithIndex[i].index < numsWithIndex[j].index\n\t\t}\n\t\treturn sumI < sumJ\n\t})\n\n\tsortedNums := make([]int, len(nums))\n\tfor i, nwi := range numsWithIndex {\n\t\tsortedNums[i] = nwi.num\n\t}\n\n\treturn sortedNums\n}\n\nfunc TestOrderByPoints(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := order_by_points(tc.input)\n\t\tif !equal(result, tc.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_146","nl":"eng_Latn","pl":"go_test.go","prompt":"package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that takes a list of numbers as input and returns \n\/\/ the number of elements in the list that are greater than 10 and both \n\/\/ first and last digits of a number are odd (1, 3, 5, 7, 9).\n\/\/ For example:\n\/\/ >>> specialFilter([]int{15, -73, 14, -15})\n\/\/ 1\n\/\/ >>> specialFilter([]int{33, -2, -3, 45, 21, 109})\n\/\/ 2\nfunc specialFilter(nums []int) int {\n","canonical_solution":"package specialFilter_test\n\nimport (\n\t\"testing\"\n)\n\nfunc specialFilter(nums []int) int {\n\tcount := 0\n\tfor _, num := range nums {\n\t\t\/\/ Consider the absolute value of the number\n\t\tabsNum := abs(num)\n\t\tif absNum > 10 {\n\t\t\tstrNum := fmt.Sprintf(\"%d\", absNum)\n\t\t\tfirstDigit := strNum[0]\n\t\t\tlastDigit := strNum[len(strNum)-1]\n\t\t\tif isOdd(firstDigit) && isOdd(lastDigit) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc isOdd(digit byte) bool {\n\treturn digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'\n}\n\nfunc TestSpecialFilter(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{15, -73, 14, -15}, 1},\n\t\t{[]int{33, -2, -3, 45, 21, 109}, 2},\n\t\t{[]int{8, 4, 12, 55, 99, 111}, 1},\n\t\t{[]int{-11, -22, -33, -44, -55}, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := specialFilter(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"specialFilter(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestSpecialfilter(t *testing.T) {\n  candidate := specialFilter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },\n     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },\n     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },\n     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },\n     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{}), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_147","nl":"eng_Latn","pl":"go_test.go","prompt":"package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a positive integer n. You have to create an integer list a of length n.\n\/\/ For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n\/\/ Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n\/\/ and a[i] + a[j] + a[k] is a multiple of 3.\n\/\/ Example :\n\/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n int) int {\n","canonical_solution":"package get_max_triples_test\n\nimport (\n    \"testing\"\n)\n\nfunc get_max_triples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n    \n    count := 0\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\nfunc TestGetMaxTriples(t *testing.T) {\n    if get_max_triples(5) != 1 {\n        t.Errorf(\"Expected 1 but got %d\", get_max_triples(5))\n    }\n}","tests":"func TestGet_Max_Triples(t *testing.T) {\n  candidate := get_max_triples\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 1 },\n     { actual: candidate(6), expected: 4 },\n     { actual: candidate(10), expected: 36 },\n     { actual: candidate(100), expected: 53361 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_148","nl":"eng_Latn","pl":"go_test.go","prompt":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ There are eight planets in our solar system: the closerst to the Sun \n\/\/ is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\/\/ Uranus, Neptune.\n\/\/ Write a function that takes two planet names as strings planet1 and planet2. \n\/\/ The function should return a list containing all planets whose orbits are \n\/\/ located between the orbit of planet1 and the orbit of planet2, sorted by \n\/\/ the proximity to the sun. \n\/\/ The function should return an empty list if planet1 or planet2\n\/\/ are not correct planet names. \n\/\/ Examples\n\/\/ >>> bf(\"Jupiter\", \"Neptune\")\n\/\/ []interface{}{\"Saturn\", \"Uranus\"}\n\/\/ >>> bf(\"Earth\", \"Mercury\")\n\/\/ \"Venus\"\n\/\/ >>> bf(\"Mercury\", \"Uranus\")\n\/\/ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n","canonical_solution":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Define the solar system slice with planets ordered by their proximity to the Sun\nvar solarSystem = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\nfunc bf(planet1 string, planet2 string) []interface{} {\n    index1 := -1\n    index2 := -1\n\n    \/\/ Find the indices of the given planet names in the solarSystem slice\n    for i, planet := range solarSystem {\n        if planet == planet1 {\n            index1 = i\n        }\n        if planet == planet2 {\n            index2 = i\n        }\n    }\n\n    \/\/ If either planet name is incorrect, return an empty list\n    if index1 == -1 || index2 == -1 {\n        return []interface{}{}\n    }\n\n    \/\/ Ensure index1 is less than index2 to find planets between them\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n\n    \/\/ Collect and return planets that are located between the two indices\n    var planetsBetween []interface{}\n    for i := index1 + 1; i < index2; i++ {\n        planetsBetween = append(planetsBetween, solarSystem[i])\n    }\n    \n    return planetsBetween\n}\n\nfunc TestBf(t *testing.T) {\n    fmt.Println(bf(\"Jupiter\", \"Neptune\")) \/\/ Should print: []interface{}{\"Saturn\", \"Uranus\"}\n    fmt.Println(bf(\"Earth\", \"Mercury\"))  \/\/ Should print: []interface{}{\"Venus\"}\n    fmt.Println(bf(\"Mercury\", \"Uranus\")) \/\/ Should print: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n}","tests":"func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_149","nl":"eng_Latn","pl":"go_test.go","prompt":"package sorted_list_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that accepts a list of strings as a parameter,\n\/\/ deletes the strings that have odd lengths from it,\n\/\/ and returns the resulted list with a sorted order,\n\/\/ The list is always a list of strings and never a list of numbers,\n\/\/ and it may contain duplicates.\n\/\/ The order of the list should be ascending by length of each word, and you\n\/\/ should return the list sorted by that rule.\n\/\/ If two words have the same length, sort the list alphabetically.\n\/\/ The function should return a list of strings in sorted order.\n\/\/ You may assume that all words will have the same length.\n\/\/ For example:\n\/\/ >>> list_sort([]string{\"aa\", \"a\", \"aaa\"})\n\/\/ []string{\"aa\"}\n\/\/ >>> list_sort([]string{\"ab\", \"a\", \"aaa\", \"cd\"})\n\/\/ []string{\"ab\", \"cd\"}\nfunc sorted_list_sum(lst []string) []string {\n","canonical_solution":"package sorted_list_sum_test\n\nimport (\n    \"sort\"\n)\n\nfunc sorted_list_sum(lst []string) []string {\n    \/\/ Filter out strings with odd lengths\n    filtered := []string{}\n    for _, str := range lst {\n        if len(str)%2 == 0 {\n            filtered = append(filtered, str)\n        }\n    }\n\n    \/\/ Sort the filtered list by length, then alphabetically\n    sort.Slice(filtered, func(i, j int) bool {\n        if len(filtered[i]) == len(filtered[j]) {\n            return filtered[i] < filtered[j]\n        }\n        return len(filtered[i]) < len(filtered[j])\n    })\n\n    return filtered\n}","tests":"func TestSorted_List_Sum(t *testing.T) {\n  candidate := sorted_list_sum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"aa\", \"a\", \"aaa\"}), expected: []string{\"aa\"} },\n     { actual: candidate([]string{\"school\", \"AI\", \"asdf\", \"b\"}), expected: []string{\"AI\", \"asdf\", \"school\"} },\n     { actual: candidate([]string{\"d\", \"b\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"d\", \"dcba\", \"abcd\", \"a\"}), expected: []string{\"abcd\", \"dcba\"} },\n     { actual: candidate([]string{\"AI\", \"ai\", \"au\"}), expected: []string{\"AI\", \"ai\", \"au\"} },\n     { actual: candidate([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}), expected: []string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_150","nl":"eng_Latn","pl":"go_test.go","prompt":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ A simple program which should return the value of x if n is \n\/\/ a prime number and should return the value of y otherwise.\n\/\/ Examples:\n\/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunc x_or_y(n int, x int, y int) int {\n","canonical_solution":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc x_or_y(n int, x int, y int) int {\n    if isPrime(n) {\n        return x\n    }\n    return y\n}\n\nfunc TestXOrY(t *testing.T) {\n    cases := []struct{\n        n, x, y, want int\n    }{\n        {7, 34, 12, 34},\n        {15, 8, 5, 5},\n        {2, 10, 20, 10},\n        {1, 5, 15, 15},\n    }\n\n    for _, c := range cases {\n        got := x_or_y(c.n, c.x, c.y)\n        if got != c.want {\n            t.Errorf(\"x_or_y(%d, %d, %d) == %d, want %d\", c.n, c.x, c.y, got, c.want)\n        }\n    }\n}","tests":"func TestX_Or_Y(t *testing.T) {\n  candidate := x_or_y\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7, 34, 12), expected: 34 },\n     { actual: candidate(15, 8, 5), expected: 5 },\n     { actual: candidate(3, 33, 5212), expected: 33 },\n     { actual: candidate(1259, 3, 52), expected: 3 },\n     { actual: candidate(7919, -1, 12), expected: -1 },\n     { actual: candidate(3609, 1245, 583), expected: 583 },\n     { actual: candidate(91, 56, 129), expected: 129 },\n     { actual: candidate(6, 34, 1234), expected: 1234 },\n     { actual: candidate(1, 2, 0), expected: 0 },\n     { actual: candidate(2, 2, 0), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_151","nl":"eng_Latn","pl":"go_test.go","prompt":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a list of numbers, return the sum of squares of the numbers\n\/\/ in the list that are odd. Ignore numbers that are negative or not integers.\n\/\/ >>> double_the_difference([]int{1, 3, 2, 0})\n\/\/ 10\n\/\/ >>> double_the_difference([]int{-1, -2, 0})\n\/\/ 0\n\/\/ >>> double_the_difference([]int{9, -2})\n\/\/ 81\n\/\/ >>> double_the_difference([]int{0})\n\/\/ 0\n\/\/ If the input list is empty, return 0.\nfunc double_the_difference(lst []float64) int {\n","canonical_solution":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc double_the_difference(lst []float64) int {\n    sum := 0\n    for _, num := range lst {\n        if num >= 0 && math.Mod(num, 1) == 0 {\n            intNum := int(num)\n            if intNum%2 != 0 {\n                sum += intNum * intNum\n            }\n        }\n    }\n    return sum\n}\n\nfunc TestDoubleTheDifference(t *testing.T) {\n    cases := []struct {\n        input []float64\n        expected int\n    }{\n        {input: []float64{1, 3, 2, 0}, expected: 10},\n        {input: []float64{-1, -2, 0}, expected: 0},\n        {input: []float64{9, -2}, expected: 81},\n        {input: []float64{0}, expected: 0},\n        {input: []float64{}, expected: 0},\n    }\n\n    for _, c := range cases {\n        result := double_the_difference(c.input)\n        if result != c.expected {\n            t.Errorf(\"double_the_difference(%v) == %d, want %d\", c.input, result, c.expected)\n        } else {\n            fmt.Printf(\"Test passed for input %v. Result: %d\\n\", c.input, result)\n        }\n    }\n}","tests":"func TestDouble_The_Difference(t *testing.T) {\n  candidate := double_the_difference\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{}), expected: 0 },\n     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },\n     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },\n     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },\n     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },\n     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_152","nl":"eng_Latn","pl":"go_test.go","prompt":"package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ I think we all remember that feeling when the result of some long-awaited\n\/\/ event is finally known. The feelings and thoughts you have at that moment are\n\/\/ definitely worth noting down and comparing.\n\/\/ Your task is to determine if a person correctly guessed the results of a number of matches.\n\/\/ You are given two lists of scores and guesses of equal length, where each index shows a match. \n\/\/ Return a list of the same length denoting how far off each guess was. If they have guessed correctly,\n\/\/ the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\/\/ example:\n\/\/ >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})\n\/\/ []int{0, 0, 0, 0, 3, 3}\n\/\/ >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})\n\/\/ []int{4, 4, 1, 0, 0, 6}\nfunc compare(game []int, guess []int) []int {\n","canonical_solution":"package compare_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := 0; i < len(game); i++ {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n\nfunc TestCompare(t *testing.T) {\n    tests := []struct {\n        game  []int\n        guess []int\n        want  []int\n    }{\n        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},\n        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%v vs %v\", tt.game, tt.guess), func(t *testing.T) {\n            got := compare(tt.game, tt.guess)\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"compare(%v, %v) = %v; want %v\", tt.game, tt.guess, got, tt.want)\n                }\n            }\n        })\n    }\n}","tests":"func TestCompare(t *testing.T) {\n  candidate := compare\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },\n     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },\n     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },\n     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_153","nl":"eng_Latn","pl":"go_test.go","prompt":"package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You will be given the name of a class (a string) and a list of extensions.\n\/\/ The extensions are to be used to load additional classes to the class. The\n\/\/ strength of the extension is as follows: Let CAP be the number of the uppercase\n\/\/ letters in the extension's name, and let SM be the number of lowercase letters \n\/\/ in the extension's name, the strength is given by the fraction CAP - SM. \n\/\/ You should find the strongest extension and return a string in this \n\/\/ format: ClassName.StrongestExtensionName.\n\/\/ If there are two or more extensions with the same strength, you should\n\/\/ choose the one that comes first in the list.\n\/\/ For example, if you are given \"Slices\" as the class and a list of the\n\/\/ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\/\/ return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n\/\/ (its strength is -1).\n\/\/ Example:\n\/\/ >>> Strongest_Extension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"})\n\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name string, extensions []string) string {\n","canonical_solution":"func Strongest_Extension(class_name string, extensions []string) string {\n    strongestExtension := \"\"\n    maxStrength := -1 << 31\n\n    for _, extension := range extensions {\n        capCount, smCount := 0, 0\n        for _, char := range extension {\n            if char >= 'A' && char <= 'Z' {\n                capCount++\n            } else if char >= 'a' && char <= 'z' {\n                smCount++\n            }\n        }\n        strength := capCount - smCount\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n\n    return fmt.Sprintf(\"%s.%s\", class_name, strongestExtension)\n}","tests":"func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected: \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected: \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\" },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n     { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_154","nl":"eng_Latn","pl":"go_test.go","prompt":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunc cycpattern_check(a string, b string) bool {\n","canonical_solution":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc cycpattern_check(a string, b string) bool {\n    n := len(b)\n    \n    \/\/ Generate all rotations of b\n    for i := 0; i < n; i++ {\n        rotated := b[i:] + b[:i]\n        if strings.Contains(a, rotated) {\n            return true\n        }\n    }\n    \n    return false\n}","tests":"func TestCycpattern_Check(t *testing.T) {\n  candidate := cycpattern_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"xyzw\", \"xyw\"), expected: false },\n     { actual: candidate(\"yello\", \"ell\"), expected: true },\n     { actual: candidate(\"whattup\", \"ptut\"), expected: false },\n     { actual: candidate(\"efef\", \"fee\"), expected: true },\n     { actual: candidate(\"abab\", \"aabb\"), expected: false },\n     { actual: candidate(\"winemtt\", \"tinem\"), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_155","nl":"eng_Latn","pl":"go_test.go","prompt":"package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given an integer. return a list that has the number of even and odd digits respectively.\n\/\/ Example:\n\/\/ >>> even_odd_count(-12)\n\/\/ []interface{}{1, 1}\n\/\/ >>> even_odd_count(123)\n\/\/ []interface{}{1, 2}\nfunc even_odd_count(num int) []interface{} {\n","canonical_solution":"func even_odd_count(num int) []interface{} {\n    \/\/ Handle negative numbers by taking the absolute value\n    if num < 0 {\n        num = -num\n    }\n    \n    evenCount, oddCount := 0, 0\n\n    \/\/ Iterate over each digit in the number\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            evenCount++\n        } else {\n            oddCount++\n        }\n        num \/= 10\n    }\n\n    return []interface{}{evenCount, oddCount}\n}\n\nfunc TestEvenOddCount(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected []interface{}\n    }{\n        {-12, []interface{}{1, 1}},\n        {123, []interface{}{1, 2}},\n        {2468, []interface{}{4, 0}},\n        {1357, []interface{}{0, 4}},\n        {0, []interface{}{1, 0}},\n    }\n\n    for _, testCase := range testCases {\n        result := even_odd_count(testCase.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", testCase.expected) {\n            t.Errorf(\"even_odd_count(%d) = %v; expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}","tests":"func TestEven_Odd_Count(t *testing.T) {\n  candidate := even_odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7), expected: []interface{}{0, 1} },\n     { actual: candidate(-78), expected: []interface{}{1, 1} },\n     { actual: candidate(3452), expected: []interface{}{2, 2} },\n     { actual: candidate(346211), expected: []interface{}{3, 3} },\n     { actual: candidate(-345821), expected: []interface{}{3, 3} },\n     { actual: candidate(-2), expected: []interface{}{1, 0} },\n     { actual: candidate(-45347), expected: []interface{}{2, 3} },\n     { actual: candidate(0), expected: []interface{}{1, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_156","nl":"eng_Latn","pl":"go_test.go","prompt":"package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer, obtain its roman numeral equivalent as a string,\n\/\/ and return it in lowercase.\n\/\/ Restrictions: 1 <= num <= 1000\n\/\/ Examples:\n\/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n","canonical_solution":"package int_to_mini_roman_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc int_to_mini_roman(number int) string {\n\tvals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\tsymbols := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\n\tvar roman strings.Builder\n\n\tfor i := 0; i < len(vals); i++ {\n\t\tfor number >= vals[i] {\n\t\t\tnumber -= vals[i]\n\t\t\troman.WriteString(symbols[i])\n\t\t}\n\t}\n\treturn roman.String()\n}\n\nfunc TestIntToMiniRoman(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected string\n\t}{\n\t\t{19, \"xix\"},\n\t\t{152, \"clii\"},\n\t\t{426, \"cdxxvi\"},\n\t\t{1000, \"m\"},\n\t\t{1, \"i\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d\", tt.input), func(t *testing.T) {\n\t\t\tresult := int_to_mini_roman(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Fatalf(\"expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_157","nl":"eng_Latn","pl":"go_test.go","prompt":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given the lengths of the three sides of a triangle. Return true if the three\n\/\/ sides form a right-angled triangle, false otherwise.\n\/\/ A right-angled triangle is a triangle in which one angle is right angle or \n\/\/ 90 degree.\n\/\/ Example:\n\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunc right_angle_triangle(a int, b int, c int) bool {\n","canonical_solution":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc right_angle_triangle(a int, b int, c int) bool {\n    \/\/ Squaring the sides\n    a2, b2, c2 := a*a, b*b, c*c\n    \/\/ Check the Pythagorean theorem for the combination of sides\n    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2\n}","tests":"func TestRight_Angle_Triangle(t *testing.T) {\n  candidate := right_angle_triangle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: true },\n     { actual: candidate(1, 2, 3), expected: false },\n     { actual: candidate(10, 6, 8), expected: true },\n     { actual: candidate(2, 2, 2), expected: false },\n     { actual: candidate(7, 24, 25), expected: true },\n     { actual: candidate(10, 5, 7), expected: false },\n     { actual: candidate(5, 12, 13), expected: true },\n     { actual: candidate(15, 8, 17), expected: true },\n     { actual: candidate(48, 55, 73), expected: true },\n     { actual: candidate(1, 1, 1), expected: false },\n     { actual: candidate(2, 2, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_158","nl":"eng_Latn","pl":"go_test.go","prompt":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Write a function that accepts a list of strings.\n\/\/ The list contains different words. Return the word with maximum number\n\/\/ of unique characters. If multiple strings have maximum number of unique\n\/\/ characters, return the one which comes first in lexicographical order.\n\/\/ >>> find_max([]string{\"name\", \"of\", \"string\"})\n\/\/ \"string\"\n\/\/ >>> find_max([]string{\"name\", \"enam\", \"game\"})\n\/\/ \"enam\"\n\/\/ >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\/\/ \"aaaaaaa\"\nfunc find_max(words []string) string {\n","canonical_solution":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc find_max(words []string) string {\n    maxWord := \"\"\n    maxUnique := 0\n    \n    for _, word := range words {\n        uniqueChars := countUniqueChars(word)\n        if uniqueChars > maxUnique {\n            maxUnique = uniqueChars\n            maxWord = word\n        } else if uniqueChars == maxUnique {\n            if maxWord == \"\" || word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    \n    return maxWord\n}\n\nfunc countUniqueChars(word string) int {\n    charSet := make(map[rune]struct{})\n    for _, c := range word {\n        charSet[c] = struct{}{}\n    }\n    return len(charSet)\n}\n\n\/\/ Test case runs to verify the solution\nfunc TestFindMax(t *testing.T) {\n    testCases := []struct {\n        input []string\n        expected string\n    }{\n        {[]string{\"name\", \"of\", \"string\"}, \"string\"},\n        {[]string{\"name\", \"enam\", \"game\"}, \"enam\"},\n        {[]string{\"aaaaaaa\", \"bb\", \"cc\"}, \"aaaaaaa\"},\n    }\n\n    for _, tc := range testCases {\n        result := find_max(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"For input %v, expected %s, but got %s\", tc.input, tc.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", tc.input)\n        }\n    }\n}","tests":"func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_159","nl":"eng_Latn","pl":"go_test.go","prompt":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You're a hungry rabbit, and you already have eaten a certain number of carrots,\n\/\/ but now you need to eat more carrots to complete the day's meals.\n\/\/ you should return a list of [ total number of eaten carrots after your meals,\n\/\/ the number of carrots left after your meals ]\n\/\/ if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n\/\/ Example:\n\/\/ >>> eat(5, 6, 10)\n\/\/ []int{11, 4}\n\/\/ >>> eat(4, 8, 9)\n\/\/ []int{12, 1}\n\/\/ >>> eat(1, 10, 10)\n\/\/ []int{11, 0}\n\/\/ >>> eat(2, 11, 5)\n\/\/ []int{7, 0}\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n","canonical_solution":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ eat calculates the total number of eaten carrots after meals and the number of carrots left.\nfunc eat(number int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{number + need, remaining - need}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n    tests := []struct {\n        number, need, remaining int\n        expected                []int\n    }{\n        {5, 6, 10, []int{11, 4}},\n        {4, 8, 9, []int{12, 1}},\n        {1, 10, 10, []int{11, 0}},\n        {2, 11, 5, []int{7, 0}},\n    }\n\n    for _, test := range tests {\n        result := eat(test.number, test.need, test.remaining)\n        if result[0] != test.expected[0] || result[1] != test.expected[1] {\n            t.Errorf(\"eat(%d, %d, %d) = %v; expected %v\", test.number, test.need, test.remaining, result, test.expected)\n        }\n    }\n}","tests":"func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_160","nl":"eng_Latn","pl":"go_test.go","prompt":"package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given two lists operator, and operand. The first list has basic algebra operations, and \n\/\/ the second list is a list of integers. Use the two given lists to build the algebric \n\/\/ expression and return the evaluation of this expression.\n\/\/ The basic algebra operations:\n\/\/ Addition ( + ) \n\/\/ Subtraction ( - ) \n\/\/ Multiplication ( * ) \n\/\/ Floor division ( \/\/ ) \n\/\/ Exponentiation ( ** ) \n\/\/ Example:\n\/\/ operator['+', '*', '-']\n\/\/ list = [2, 3, 4, 5]\n\/\/ result = 2 + 3 * 4 - 5\n\/\/ => result = 9\n\/\/ Note:\n\/\/ The length of operator list is equal to the length of operand list minus one.\n\/\/ Operand is a list of of non-negative integers.\n\/\/ Operator list has at least one operator, and operand list has at least two operands.\nfunc do_algebra(operator []string, operand []int) int {\n","canonical_solution":"package do_algebra_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc do_algebra(operator []string, operand []int) int {\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n\n    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"\/\/\":\n            result \/= operand[i+1]\n        case \"**\":\n            result = intPow(result, operand[i+1])\n        }\n    }\n\n    return result\n}\n\nfunc intPow(base, exp int) int {\n    result := 1\n    for exp != 0 {\n        if exp%2 == 1 {\n            result *= base\n        }\n        exp \/= 2\n        base *= base\n    }\n    return result\n}\n\nfunc TestDoAlgebra(t *testing.T) {\n    operators := []string{\"+\", \"*\", \"-\"}\n    operands := []int{2, 3, 4, 5}\n    expectedResult := 9\n    result := do_algebra(operators, operands)\n    if result != expectedResult {\n        t.Errorf(\"expected %d but got %d\", expectedResult, result)\n    }\n\n    fmt.Println(\"All tests passed.\")\n}","tests":"func TestDo_Algebra(t *testing.T) {\n  candidate := do_algebra\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}), expected: 37 },\n     { actual: candidate([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}), expected: 9 },\n     { actual: candidate([]string{\"\/\/\", \"*\"}, []int{7, 3, 4}), expected: 8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_161","nl":"eng_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ You are given a string s.\n\/\/ if s[i] is a letter, reverse its case from lower to upper or vise versa, \n\/\/ otherwise keep it as it is.\n\/\/ If the string contains no letters, reverse the string.\n\/\/ The function should return the resulted string.\n\/\/ Examples\n\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunc solve(s string) string {\n","canonical_solution":"package solve_test\n\nimport (\n    \"unicode\"\n)\n\nfunc solve(s string) string {\n    hasLetter := false\n    result := []rune(s)\n\n    for i, char := range result {\n        if unicode.IsLetter(char) {\n            hasLetter = true\n            if unicode.IsUpper(char) {\n                result[i] = unicode.ToLower(char)\n            } else {\n                result[i] = unicode.ToUpper(char)\n            }\n        }\n    }\n\n    if !hasLetter {\n        \/\/ reverse the string\n        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {\n            result[i], result[j] = result[j], result[i]\n        }\n    }\n\n    return string(result)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_163","nl":"eng_Latn","pl":"go_test.go","prompt":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given two positive integers a and b, return the even digits between a\n\/\/ and b, in ascending order.\n\/\/ For example:\n\/\/ >>> generate_integers(2, 8)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(8, 2)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(10, 14)\n\/\/ []int{}\nfunc generate_integers(a int, b int) []int {\n","canonical_solution":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc generate_integers(a int, b int) []int {\n    start, end := a, b\n    if a > b {\n        start, end = b, a\n    }\n    \n    result := []int{}\n    for i := start; i <= end; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestGenerateIntegers(t *testing.T) {\n    tests := []struct {\n        a, b int\n        want []int\n    }{\n        {2, 8, []int{2, 4, 6, 8}},\n        {8, 2, []int{2, 4, 6, 8}},\n        {10, 14, []int{}},\n    }\n    \n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"generate_integers(%d, %d)\", tt.a, tt.b), func(t *testing.T) {\n            got := generate_integers(tt.a, tt.b)\n            if len(got) != len(tt.want) {\n                t.Errorf(\"expected %v, got %v\", tt.want, got)\n                return\n            }\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"expected %v, got %v\", tt.want, got)\n                    return\n                }\n            }\n        })\n    }\n}","tests":"func TestGenerate_Integers(t *testing.T) {\n  candidate := generate_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(17, 89), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]