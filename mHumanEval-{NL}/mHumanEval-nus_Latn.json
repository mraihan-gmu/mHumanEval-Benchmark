[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Guic mi\u0331 r\u025by li\u0331th\u00e4 n\u00e4mb\u00e4ri\u0331, \u025bni\u0331 n\u00e4mb\u00e4ri\u0331 r\u025bw tin thia\u0331k k\u00e4 r\u0254\u0331 \u025b l\u00e4ny k\u025bn pek in ca \u014bun.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input k\u025b la\u0331t \u025bm\u025b \u025b la\u0331t mi\u0331 te bu\u0254\u0331n ti\u0331 \u014buan ti\u0331 ca r\u0254\u0331 mat k\u025b k\u025b\u0308l k\u025b\u0308\u025b\u0308li\u0331. Min g\u00f6rk\u025b \u025b \u0263\u00f6\u00f6 ba bu\u0254\u0331n ti\u0331ti\u0331 da\u0331a\u0331k k\u00e4 bi\u0331 k\u025b cu loc \u025b la li\u0331th ti\u0331 g\u00f6\u00f6l.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Mi\u0331 ca \u014bun \u025b la mi\u0331 tek\u025b pu\u0254\u0331thitib pu\u0254\u0254mp\u00f6nd n\u00e4mb\u00e4r, j\u025bn ba cu d\u00e4k piny \u025b la intejer (in intejer in di\u0331tni\u0331 j\u025bn k\u00e4 min ca \u014bun) k\u025bn\u025b deci\u0331mal (in de\u0331th ni\u0331 j\u025bn k\u00e4 min te piny k\u00e4 min te piny k\u00e4 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ji\u0331n ca ji\u0331 moc k\u025b li\u0331th du\u014b dep\u00f6dhi\u0331\u00f6t k\u025bn\u025b ji\u0331o\u0331m k\u00e4 l\u00e4t k\u025b kui\u0331 ba\u0331nk account min b\u025b tok k\u025b dh\u025br\u00f6 ba\u0331li\u0331\u00f6. La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 ji\u0331 \u014ba\u0331c mi\u0331 te k\u025b gua\u0331a\u0331th mi\u0331 bi\u0331 pek in te k\u00e4 ba\u0331li\u0331\u00f6 w\u00e4 piny dh\u025br\u00f6, k\u00e4 \u025bn gua\u0331a\u0331th \u025bm\u0254 bi\u0331 pa\u0331\u014bciin yi\u0331o\u0331w j\u0254k \u025b la Trueth. Mi\u0331 \/ci\u0331 \u025b j\u025bn, j\u025bn b\u025b yi\u0331o\u0331w j\u0254k \u025b la False. C\u00e4\u00e4t:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" K\u025b kui\u0331 k\u00e4 min ca \u014bun k\u00e4 min ca la\u0331th r\u025by li\u0331th\u00e4 n\u00e4mb\u00e4ri\u0331, ku\u025b\u0308nk\u025b Mean Absolute Deviation (mi\u0331 c\u025b thi\u025bl) k\u00e4 min te kam data\u025btni\u0331. Mean Absolute Deviation (mi\u0331 c\u025b thi\u025bl) \u025b j\u025bn in te kam k\u00e4 tin te d\u00e4\u00e4r k\u00e4 \u025bl\u025bm\u025bni\u0331 k\u025bn\u025b d\u00e4\u00e4r (mi\u0331 c\u025b thi\u025bl r\u025by k\u00e4 n\u025bm\u025b): MAD = average. x - x_mean. C\u00e4\u00e4t:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" La\u0331thk\u025b n\u00e4mb\u00e4r 'd\u00ebl\u00f6mi\u0331t\u025br' kamni\u0331 r\u025bw tin gu\u0254\u0331rk\u025b r\u0254\u0331 k\u00e4 inpuut li\u0331th 'n\u00f6mberni\u0331'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input k\u025b la\u0331t \u025bm\u025b \u025b la\u0331t mi\u0331 cu\u014b \u025b la mi\u0331 ca mat \u025b la bu\u0254\u0331n mi\u0331 \u014buan k\u025b kui\u0331 k\u00e4 tin ca mat k\u00e4 tin ca mat k\u00e4 tin ca da\u0331a\u0331k \u025b kam. k\u025b kui\u0331 k\u00e4 bu\u0254\u0331n k\u025bl, min ca mat k\u00e4 min te piny k\u00e4 tin te piny. c.d. (() (()) tek\u025b k\u025b r\u025bw ti\u0331 di\u0331t k\u00e4 tek\u025b k\u025b di\u0331\u0254\u0331k.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter \u025bni\u0331 inpuut list du\u014b th\u00e4rkithni\u0331 k\u00e4r\u0254a k\u025b kui\u0331 k\u00e4 tin te k\u00e4 th\u00e4rkith min ca \u014bun\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" K\u025b kui\u0331 li\u0331th\u00e4 mi\u0331 ca \u014bun k\u00e4 intejeri\u0331, locni\u0331 tuple mi\u0331 tek\u025b mat k\u025bn\u025b min ca n\u00f6\u00f6\u014b k\u00e4 intejeri\u0331 diaal r\u025by li\u0331th\u00e4. K\u00e4 mi\u0331 te go\u0331l\u00e4 b\u025b yi\u0331k pa\u0331a\u0331r k\u025b 0 k\u025bn\u025b \u0263\u00f6\u00f6 b\u025b yi\u0331k pa\u0331a\u0331r k\u025b min ca n\u00f6\u00f6\u014b b\u025b pa\u0331a\u0331r k\u025b 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \u0190ni\u0331 mi\u0331 ca \u014bun \u025b la li\u0331th intejeri\u0331, ba li\u0331th in te wi\u0331d\u025b thi\u0331n la\u0331t \u025b la mi\u0331 di\u0331i\u0331t k\u00e4 ba jiek \u025b la mi\u0331 ci\u0331 cop gua\u0331a\u0331th in ca \u014bun r\u025by theku\u025bnthi\u0331.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Th\u00ebm mi\u0331 ca \u014bun i\u0331 \u025b pa\u0331lindr\u0254m \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input \u025b r\u025bw ti\u0331 la\u0331tk\u025b \u025b la 1 k\u025bn\u025b 0 k\u00e4r\u0254\u0331. La\u0331t binary XOR k\u00e4 tin la\u0331tk\u025b k\u00e4 b\u025b cu loc \u025b la string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Mi\u0331 ca la\u0331t \u025b la mi\u0331 b\u00e4\u00e4r, locni\u0331 mi\u0331 b\u00e4\u00e4r \u025bl\u0254\u0331\u014b. Mi\u0331 ca la\u0331t \u025b la mi\u0331 tek\u025b ti\u0331 \u014buan ti\u0331 p\u00e4\u00e4r b\u00e4\u00e4r. Mi\u0331 ca la\u0331t \u025b la mi\u0331 thi\u025bl mi\u0331 te thi\u0331n r\u025by l\u00e4\u00e4td\u00e4 in ca la\u0331th thi\u0331n.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" L\u00e4td\u025b \u025b la min di\u0331tni\u0331 j\u025bn k\u00e4 d\u00e4\u00e4kdi\u025bn k\u00e4 intejeri\u0331 r\u025bw a k\u025bn\u025b b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" L\u00e4\u00e4tni\u0331 diaal tin ca la\u0331th thi\u0331n \u025b la tin ci\u0331 r\u0254\u0331 lot k\u025b pek in ci\u0331 r\u0254 lot k\u025b pek in ci\u0331 r\u0254 lot k\u025b pek in ci\u0331 r\u0254 lot k\u025b j\u025b\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" L\u00e4td\u025b j\u0254k \u025b la mi\u0331 tek\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 ca g\u025b\u025br \u025b w\u00e4 k\u00e4 0 \u025b w\u00e4 k\u00e4 n \u025b matk\u025b.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Mi\u0331 ca th\u00e4rkd\u025b \u014bun, g\u00f6r\u025b j\u025b i\u0331 \u025b pek in di\u0331tni\u0331j\u025bn k\u00e4 bi\u0331k\u025b te thi\u0331n (\u025b \/ci\u0331 ku\u025b\u0308\u025b\u0308d\u025b te thi\u0331n)\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \u0190n la\u0331t \u025bm\u025b b\u025b la\u0331th r\u025by j\u0254am min nyooth ni\u0331 no\u0331o\u0331\u014bni\u0331 k\u025b ca\u0331p mi\u0331 r\u025blr\u0254 k\u00e4 ASCII. La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 k\u025b ku l\u025b guic k\u00e4 bi\u0331 k\u025b l\u025b loc ni\u0331 n\u00e4mb\u00e4ri\u0331 tin matk\u025b k\u025b pek in bi\u0331 k\u025b kul\u025b te thi\u0331n.\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Jiek\u025b pek in der\u025b jek ni\u0331 du\u0254\u0331\u0254\u0331r mi\u0331 caa \u014bun k\u00e4 th\u00e4p-th\u00e4p in nhiam. Ku\u025bn\u025b tin ci\u0331 r\u0254\u0331 mat.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input \u025b n\u00e4mb\u00e4ral-in-th\u025brn mi\u0331 ca g\u025b\u025br \u025b kam k\u00e4 'dh\u025br\u00f6' \u025b w\u00e4 k\u00e4 'n\u00e4mb\u00e4ral'. Ca\u0331a\u0331p tin lot r\u0254\u0331 k\u025b k\u025bn 'dh\u025br\u00f6', 'k\u025bl', 'r\u025bw', 'r\u025bw', '\u014buaan', 'li\u0331w', 'dath','b\u00e4r\u0254w', 'b\u00e4r\u0254w' k\u025bn\u025b 'r\u025bw'. L\u0254\u0331a\u0331 n\u00e4mb\u00e4ri\u0331 tin ca riali\u0331k\u00e4 k\u00e4 tin t\u0254atni\u0331 \u025b w\u00e4 k\u00e4 tin di\u0331t\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" \u0190ni\u0331 li\u0331th n\u00e4mb\u00e4ri\u0331 (min te b\u00e4r\u025b k\u00e4 r\u025bw) b\u025b r\u025bw ti\u0331 thi\u0331a\u0331k ti\u0331 ca l\u025by k\u00e4 b\u025b locni\u0331k\u025b k\u00e4 bi\u0331k\u025b cu w\u00e4 k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 cu\u014b (k\u00e4 n\u00e4mb\u00e4r in kuiy, k\u00e4 n\u00e4mb\u00e4r in di\u0331t).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Mi\u0331 ca \u014bun \u025b la li\u0331th n\u00e4mb\u00e4ri\u0331 (k\u025b \u025bl\u025bm\u025bni\u0331 r\u025bw), la\u0331td\u025b k\u025b li\u0331ni\u0331e\u0331e\u0331r tra\u0331ni\u0331thp\u0254rmi\u0331 k\u025b j\u025bn li\u0331th \u025bm\u0254, ce\u0331tk\u025b mi\u0331 j\u025bn n\u00e4mb\u00e4r in kuiy ni\u0331 j\u025bn b\u025b ben \u025b 0 k\u025bn\u025b \u0263\u00f6\u00f6 bi\u0331 min di\u0331tni\u0331 j\u025bn b\u025b ben \u025b 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter mi\u0331 ca \u014bun \u025b la mi\u0331 ci\u0331 r\u0254 lot k\u025b pek in ca \u014bun \u025b la pyth\u0254n mi\u0331 la intejeri\u0331 k\u00e4r\u0254\u0331\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" L\u00e4td\u025b k\u025b pek in ca \u014bun\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" K\u025b kui\u0331 n\u00e4mb\u00e4ri\u0331 ti\u0331 ca \u014bun, n, g\u00f6r n\u00e4mb\u00e4ri\u0331 tin di\u0331t tin d\u00e4\u00e4k n \u025b p\u00e4\u00e4r, tin kuiy ni\u0331 k\u025bn k\u00e4 n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" L\u00e4\u00e4td\u025b min ca \u014bun k\u00e4 min ca \u014bun \u025b mi\u0331 ca \u014bun \u025b mi\u0331 di\u0331i\u0331t k\u00e4 min t\u0254t k\u00e4 min di\u0331i\u0331t. K\u00e4 \u025bni\u0331 pi\u0331r\u025bkci\u025bri\u0331 ba k\u025b l\u025bl \u025b la pek mi\u0331 p\u00e4\u00e4r k\u025b pek in ci\u0331 j\u0254\u0254c r\u025by pi\u0331r\u025bkci\u025bri\u0331. Input n\u00e4mb\u00e4r ba p\u00e4\u00e4r k\u025b min ca n\u00f6\u00f6\u014b \u025b pi\u0331r\u025bkci\u025bri\u0331 diaal\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \u0190ni\u0331 li\u0331th intejeri\u0331, wu\u0254\u0331c \u025bl\u025bm\u025bni\u0331 diaal tin ci\u0331 tu\u0254\u0254k k\u00e4 ti\u0331 \u014buan k\u00e4 k\u025b\u025bl. Ki\u025b jak\u025b \u025bl\u025bm\u025bni\u0331 k\u00e4 bi\u0331 du\u0254th \u025b p\u00e4\u00e4r cie min te r\u025by inpuut\u00e4.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" K\u025b \u0263\u00f6\u00f6 ba th\u00e4rkd\u025b la\u0331t, bi\u0331 min ca g\u0254\u0331r piny \u025b mi\u0331 t\u0254t \u025b ny\u0254k k\u025b lu\u0254cd\u025b k\u00e4 min di\u0331i\u0331t \u025b mi\u0331 t\u0254t.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Mi\u0331 ca li\u0331\u025bt th\u00e4rk\u00e4l mat k\u00e4 th\u00e4rk\u00e4l k\u025bl\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter \u025b mi\u0331 la\u0331thk\u025b r\u025by li\u0331th\u00e4 min te r\u025by th\u00e4rk\u00e4l k\u00e4r\u0254a k\u025b kui\u0331 th\u00e4rk\u00e4l min tok\u025b r\u0254 k\u025b \u025b mi\u0331 ca \u014bun.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Mi\u0331 ci\u0331k\u025b thu\u0254\u0331k k\u025bn n\u00e4mb\u00e4ri\u0331 tin te r\u025by li\u0331th\u00e4.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"L\u0254\u0331ny\u025b thu\u0254\u0331k mi\u0331 ca \u014bun \u025b n\u00e4mb\u00e4r \u025b la praam, k\u025bn\u025b kac mi\u0331 d\u0254\u0331\u014b.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    L\u00e4td\u025b \u025b la mi\u0331 tek\u025b p\u00f6li\u0331n\u00f6mial mi\u0331 tek\u025b k\u00f6\u00ebpci\u025bn xs k\u00e4 p\u0254nt x. l\u00e4\u00e4td\u025b \u025b xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"La\u0331t \u025bm\u025b na\u014b\u025b li\u0331th l k\u00e4 b\u025b li\u0331th l' loc \u025b la mi\u0331 ce\u0331tk\u025b i\u0331l' p\u00e4\u00e4r\u025b k\u025b l r\u025by indi\u0331ci\u0331ni\u0331 tin \/ca de da\u0331a\u0331k \u025b di\u0254\u0331k, ni\u025b gua\u0331a\u0331 m\u0254 bi\u0331 tin te k\u00e4 indi\u0331ci\u0331ni\u0331 tin de da\u0331a\u0331k \u025b di\u0254\u0331k p\u00e4\u00e4r k\u025b tin te k\u00e4 indi\u0331ci\u0331ni\u0331 l, du\u014bni\u0331 \u0263\u00f6\u00f6 ba k\u025b da\u0331a\u0331k.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"L\u00e4td\u025b k\u025b ti\u0331 ca da\u0331a\u0331k r\u025by li\u0331th\u00e4\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Mi\u0331 ci\u0331k\u025b lu\u0254\u0331c j\u0254k \u025b la ti\u0331 \u014buan \u025bl\u0254\u0331\u014b r\u025by li\u0331th\u00e4.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"L\u00e4td\u025b j\u0254k n\u00e4mb\u00e4ri\u0331 gua\u0331thni\u0331 tin ci\u0331 di\u0331jit 7 j\u0254\u0254c r\u025by intejeri\u0331 tin kuiyni\u0331k\u025bn k\u00e4 n tin de da\u0331a\u0331k \u025b 11 ki\u025b 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"La\u0331t \u025bm\u025b na\u014b\u025b li\u0331th l k\u00e4 b\u025b li\u0331th l' loc \u025b la mi\u0331 ce\u0331tk\u025b i\u0331l' p\u00e4\u00e4r\u025b k\u025b l k\u00e4 indi\u0331ci\u0331ni\u0331 tin \/ci\u0331 t\u0254t, ni\u025b gua\u0331a\u0331 m\u0254 bi\u0331 tin te k\u00e4 indi\u0331ci\u0331ni\u0331 tin p\u00e4\u00e4r p\u00e4\u00e4r k\u025b bi\u0331 tin te k\u00e4 indi\u0331ci\u0331ni\u0331 l, du\u014bni\u0331 \u0263\u00f6\u00f6 ba k\u025b da\u0331a\u0331k.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    la lock\u025b ni\u0331 ci\u0331o\u0331o\u0331mni\u0331 ti\u0331 ca k\u0254d k\u025b bu\u0254\u0331n th\u025bkci\u0331li\u014b\u00e4 mi\u0331 tek\u025b k\u025b kark\u025btri\u0331.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib la\u0331td\u025b n\u00e4mb\u00e4r n-th min la n\u00e4mb\u00e4r Fi\u0331b\u00f6na\u0331ci k\u00e4 j\u025bn b\u00e4 \u025b praam.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero na\u014b\u025b li\u0331th intejeri\u0331 cie mi\u0331 \u025b mi\u0331 ca la\u0331th thi\u0331n. j\u025bn luny\u025b True mi\u0331 t\u00eb\u00ebk\u025b \u025bl\u025bm\u025bni\u0331 da\u0331\u014b di\u0254\u0331k ti\u0331 g\u00f6\u00f6l r\u025by li\u0331th\u00e4 min bi\u0331 matdi\u025bn \u025b la dh\u025br\u00f6, k\u025bn\u025b False mi\u0331 d\u0254\u0331\u014b.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    \u0190n du\u0254\u0331\u0254\u0331p in laa j\u00e4l\u025b \u025b mi\u0331 t\u00e4 k\u025b dup ti\u0331 cu\u014b \u025b \/thi\u025bl pek. \u0190n du\u0254\u0331\u0254\u0331p in laa j\u00e4l\u025b \u025b mi\u0331 t\u00e4 k\u025b k\u0254\u0331a\u0331k ti\u0331 \u014buan ti\u0331 j\u00e4l k\u025b kui\u0331c caam \u025b w\u0254\u0331 ni\u0331 kui\u0331c cu\u00eb\u00ebc, k\u00e4 \u025bn du\u0254\u0331\u0254\u0331p in laa j\u00e4l\u025b \u025b mi\u0331 t\u00e4 k\u025b k\u0254\u0331a\u0331k ti\u0331 \u014buan ti\u0331 j\u00e4l k\u025b kui\u0331c cu\u00eb\u00ebc \u025b w\u0254\u0331 ni\u0331 kui\u0331c cu\u00eb\u00ebc. K\u025bn k\u0254\u0331a\u0331k tin laa j\u00e4l k\u025b k\u0254\u0331a\u0331k ti\u0331ti\u0331 diaal laa j\u00e4lk\u025b k\u025b pek mi\u0331 p\u00e4\u00e4r. K\u025bn k\u0254\u0331a\u0331k tin laa j\u00e4l k\u025b kui\u0331c caam laa k\u025b laa w\u0254\u0331 k\u025b k\u0254\u0331a\u0331k tin laa j\u00e4l k\u025b kui\u0331c cu\u00eb\u00ebc \u025b w\u0254\u0331 ni\u0331 kui\u0331c cu\u00eb\u00ebc. K\u00e4 k\u025b \u0263\u00f6\u00f6 \u025bn du\u0254\u0331\u0254\u0331p\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"L\u00e4\u00e4tni\u0331 tin ca la\u0331th j\u0254k k\u025b tin ca la\u0331th nhial \u025b 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero la\u0331th\u025b li\u0331th intejeri\u0331 \u025b la mi\u0331 ca la\u0331th thi\u0331n. j\u025bn b\u025b loc i\u0331 \u025b thu\u0254\u0331k mi\u0331 tek\u025b \u025bl\u025bm\u025bni\u0331 r\u025bw ti\u0331 g\u00f6\u00f6l r\u025by li\u0331th\u00e4 min bi\u0331 matdi\u025bn \u025b la dh\u025br\u00f6, k\u025bn\u025b \u0263\u00f6\u00f6 mi\u0331 \u025b kac i\u0331n\u0254.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"G\u025b\u025br n\u00e4merikal baath du\u014b inpu\u0254\u0254 n\u00e4mb\u00e4r x k\u025b baath. locni\u0331 k\u00e4 min ca nyoth \u025b la i\u0331thti\u0331ri\u0331n k\u025b k\u0254r k\u00e4 mi\u0331 ca loc. baath n\u00e4mb\u00e4ri\u0331 \u025b kuiy ni\u0331 k\u00e4 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Mi\u0331 ca \u014bun \u025b la b\u00e4\u00e4r gua\u0331a\u0331th in bi\u0331 ben k\u025b gua\u0331a\u0331thd\u025b k\u025bn\u025b gua\u0331a\u0331th in bi\u0331 locni\u0331k\u025b thi\u0331n.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"K\u00e4 Fib4 n\u00e4mb\u00e4ri\u0331 theku\u025bnthi\u0331 \u025b mi\u0331 c\u00e4\u00e4t k\u025b Fibbonacci theku\u025bnthi\u0331 min ca lat i\u0331: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Ji\u0331n g\u0254\u0331ri\u0331 pa\u0331\u014bciin k\u025b \u0263\u00f6\u00f6 b\u025b n\u00e4mb\u00e4r \u025b la n-th element k\u00e4 theku\u025bnthi\u0331 n\u00e4mb\u00e4ri\u0331 fib4. \/Cu l\u00e4t k\u025b r\u00f6kci\u0254n.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Mi\u0331 ci\u0331 k\u025bn\u025b lu\u0254\u0331c j\u0254k \u025bn mediaan k\u00e4 el\u025bm\u025bni\u0331 r\u025by li\u0331th\u00e4 l\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Mi\u0331 ca th\u00e4rkd\u025b th\u025bm i\u0331 j\u025bn \u025b pa\u0331li\u0331ndr\u0254m\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"L\u00e4th 2^n modulo p (\u014bi\u0331i\u0331c k\u025b n\u00e4merikni\u0331).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    la lock\u025b ni\u0331 k\u00e4 tin ca g\u0254\u0331r \u025b la nyin i\u0331thku\u025br k\u025b g\u00ebrdi\u025bn k\u025b 5 r\u025by ali\u0331p\u00ebth\u025b.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels \u025b mi\u0331 la\u0331t mi\u0331 na\u014bk\u025b i\u0331thtir\u014b k\u025bn\u025b \u0263\u00f6\u00f6 b\u025b loc i\u0331thtir\u014b mi\u0331 thi\u025bl vowelni\u0331.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Mi\u0331 ci\u0331 n\u00e4mb\u00e4ri\u0331 diaal r\u025by li\u0331th\u00e4 l te piny k\u00e4 th\u00e4rk\u00e4l t, b\u025b loc i\u0331 thu\u0254\u0331k.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Mat n\u00e4mb\u00e4ri da\u0331\u014b r\u025bw x k\u025bn\u025b y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Guic mi\u0331 k\u025bn rie\u0331e\u0331t da\u0331\u014b r\u025bw tek\u025b k\u025b lu\u0254t mi\u0331 c\u00e4\u00e4t.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"L\u0254\u0331a\u0331r n\u00e4mb\u00e4r\u00e4 Fib\u00f6natci\u0331 min la n-th.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" K\u025bn bracketni\u0331 \u025b k\u025bn \"<\" k\u025bn\u025b \">\". b\u025b loc i\u0331 \u025b thu\u0254\u0331k mi\u0331 ci\u0331k\u025b r\u0254\u0331 tok k\u025b loc \u025b la bracketni\u0331 tin la nyinki\u025bn.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"L\u0254\u0331a\u0331rk\u025b thu\u0254\u0331k \u025bni\u0331 mi\u0331 ca li\u0331th \u025bl\u025bm\u025bni\u0331 k\u025b ti\u0331 \u014buan ki\u025b ti\u0331 kuiy.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"L\u00e4td\u025b k\u025b ti\u0331 ca da\u0331a\u0331k ti\u0331 ca mat k\u025b\u025bl k\u025b kui\u0331 li\u0331thni\u0331 da\u0331\u014b r\u025bw.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"L\u00e4td\u025b \u025b la min di\u0331tni\u0331 j\u025bn k\u00e4 pr\u00e4mik pakt\u0254r du\u014b n. \u0194\u0254\u0254r\u025b n > 1 k\u00e4 \/ci\u0331k\u025b pr\u00e4mik.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u025b pa\u0331\u014bcin mi\u0331 la mat n\u00e4mb\u00e4ri\u0331 k\u00e4 1 \u025b w\u00e4 k\u00e4 n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \u025b mi\u0331 la \"(\" k\u025bn\u025b \"\". return True mi\u0331 ci\u0331k\u025blk\u025bl bracket in la\u0331tk\u025b k\u00e4 b\u025b tek\u025b mi\u0331 p\u00e4\u00e4r k\u025b k\u025b.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u025b mi\u0331 nyooth p\u00f6r\u00f6ci\u025bn du\u014b p\u00f6li\u0331n\u00f6mial. xs[0] + xs[1] * x + xs[2] * x^2 +.... La locni\u0331 di\u0331ri\u0331bi\u0331t\u025b du\u014b p\u00f6li\u0331n\u00f6mial \u025bm\u025b k\u025b ta\u0331a\u0331 mi\u0331 c\u00e4\u00e4t.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"K\u00e4 FibFib n\u00e4mb\u00e4r theku\u025bnthi\u0331 \u025b mi\u0331 c\u00e4\u00e4t k\u025b Fibbonacci theku\u025bnthi\u0331 min ca lat i\u0331: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fib ((n-1) + fib ((n-2) + fib ((n-3). G\u0254\u0331r pa\u0331\u014bciin k\u025b \u0263\u00f6\u00f6 ba pek in te k\u00e4 n-th k\u00e4 n\u00e4mb\u00e4r theku\u025bnthi\u0331 k\u00e4 fibfib \u014ba\u0331c.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nMatni\u0331 ti\u0331 \u014buan ti\u0331 ba \u0263\u0254\u0331n.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Mi\u0331 ci\u0331 i\u0331thki\u0331li\u0331e\u0331r \u025b mi\u0331 ci\u0331 di\u0331jitni\u0331 intejer\u00e4 x, bi\u0331 di\u0331jitni\u0331 cu ji\u025bn k\u00e4 kui\u0331c \u025b la di\u0331jit k\u00e4 bi\u0331 j\u00e4kd\u025b ben \u025b la th\u00e4rk. Mi\u0331 ci\u0331 di\u0331jitni\u0331 ti\u0331 \u014buan ji\u025bn k\u00e4 di\u0331jitni\u0331, bi\u0331 j\u00e4k di\u0331jitni\u0331 cu loc j\u0254k.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"L\u00e4t g\u0254\u0331r\u00e4 pa\u0331\u014bciin min na\u014bk\u025b th\u00e4rk \u025b la mi\u0331 ca la\u0331th k\u00e4 b\u025b loc ni\u0331 min ca mat k\u00e4 ta\u0331a\u0331 in ca g\u0254\u0331r thi\u0331n \u025b la ASCII k\u0254dni\u0331. C\u00e4\u00e4tni\u0331: digitSum (((\"\") => 0 digitSum ((\"abAB\") => 131 digitSum ((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum ((\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    R\u025by la\u0331t \u025bm\u025b, ba ji\u0331 ka\u0331m bi\u0331l\u025b\u0308n mi\u0331 nyooth n\u00e4mb\u00e4r du\u014b tu\u0254mni\u0331 k\u025bn\u025b all\u025bnji\u0331ni\u0331 tin caa da\u0331a\u0331k r\u025by th\u00e4rk\u00e4 d\u025bw k\u00e4 th\u00e4rk\u00e4 n\u025bm\u025b t\u00ebk\u025b tu\u0254mni\u0331, all\u025bnji\u0331ni\u0331, k\u025bn\u025b d\u025bw mango. Mi\u0331 ca th\u00e4rk nyoth n\u00e4mb\u00e4r k\u025b\u025bliw du\u014b al\u025bnji\u0331ni\u0331 k\u025bn\u025b al\u025bnji\u0331ni\u0331 k\u025bn\u025b intejer min nyooth n\u00e4mb\u00e4r k\u025b\u025bliw d\u025bw k\u00e4 th\u00e4rk\u00e4 locni\u0331 n\u00e4mb\u00e4r du\u014b d\u025bw mango r\u025by th\u00e4rk\u00e4. c\u00e4\u00e4t: fruit_distribution\"5(tu\u0254mni\u0331 k\u025bn\u025b all\u025bnji\u0331ni\u0331 6\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 apples k\u025bn\u025b 1 oranges\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 apples k\u025bn\u025b 3 oranges\", 100) -> 100 - 2\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    Mi\u0331 ca mat k\u00e4 arr\u025by mi\u0331 cu\u014b k\u025b kui\u0331 kar\u00e4 mi\u0331 tek\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 \/ci\u0331 t\u0254\u0331 a n\u00e4mb\u00e4ri\u0331, bi\u0331 la\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 k\u025b w\u0254\u0331 k\u00e4 k\u025bl k\u00e4 n\u00e4mb\u00e4ri\u0331 k\u00e4 bi\u0331 k\u025b w\u0254\u0331 liny. K\u00e4 n\u00e4mb\u00e4ri\u0331 tin ca mat bi\u0331 k\u025b w\u0254\u0331 k\u00e4 n\u00e4mb\u00e4ri\u0331 tin t\u0254\u0331t\u0254\u0331. Mi\u0331 ca n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan ti\u0331 t\u0254\u0331t\u0254\u0331 jek bi\u0331 k\u025b w\u0254\u0331 k\u00e4 n\u00e4mb\u00e4ri\u0331 tin t\u0254\u0331t\u0254\u0331. K\u00e4 n\u00e4mb\u00e4ri\u0331 tin ca mat bi\u0331 k\u025b w\u0254\u0331 liny r\u025by li\u0331th\u00e4, [thmalest_value, its index] Mi\u0331 thi\u025bl\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 t\u0254\u0331t\u0254\u0331 ki\u025b arr\u025by mi\u0331 ca \u014bun, bi\u0331 w\u0254\u0331 k\u00e4 []. C\u00e4\u00e4t: 1: Input: [4,2,3] Output:\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Mi ca ji\u0331 moc array mi\u0331 t\u00e4 k\u025b intejeri\u0331, g\u00f6r\u025b \u0263\u00f6\u00f6 bi\u0331 pek el\u025bm\u025bni\u0331 tin go\u0331o\u0331r \u0263\u00f6\u00f6 ba g\u025br k\u025b \u0263\u00f6\u00f6 bi\u0331 array \u025bm\u0254 kul\u025b la palindr\u0254mik. Palindr\u0254mik array \u025b array mi\u0331 la ku\u025bnk\u025b ni\u0331 du\u0254\u0331\u0254\u0331r mi\u0331 p\u00e4\u00e4r j\u0254k k\u025bn\u025b nhiam. K\u00e4 du\u0254\u0331\u0254\u0331r k\u025bl mi\u0331 ca g\u025br, deri\u0331 el\u025bm\u025bni\u0331 k\u025bl g\u025br k\u025b \u025bl\u025bm\u025bni\u0331 ti\u0331 k\u0254\u0331ki\u025bn. C\u00e4\u00e4t: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"G\u0254\u0331r ni\u0331 pa\u0331\u014bcin mi\u0331 loc ni\u0331 thu\u0254\u0331k mi\u0331 ca \u014bun k\u00e4 n\u00e4mb\u00e4r in ca \u014bun \u025b la m\u00e4lti\u0331pli\u0331kaci\u0254n du\u014b n\u00e4mb\u00e4ri\u0331 pri\u0331i\u0331m 3 k\u00e4 mi\u0331 \/ci\u0331 m\u0254 \u025b thu\u0254\u0331k. \u014a\u00e4c ni\u0331 \u0263\u00f6\u00f6 (a) \u025b kuiy ni\u0331 j\u025bn k\u00e4 100. C\u00e4\u00e4t: \u025b_m\u00e4lti\u0331pli\u0331_pri\u0331i\u0331m ((30) == thu\u0254\u0331k 30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 la\u0331t mi\u0331 locr\u0254 \u025b thu\u0254\u0331k mi\u0331 ca n\u00e4mb\u00e4r x \u025b mi\u0331 thi\u0331a\u0331k k\u00e4 bu\u0254\u0331m du\u014b n k\u025bn\u025b kac r\u025by k\u00e4 tin k\u0254\u0331ki\u025bn. x \u025b mi\u0331 thi\u0331a\u0331k k\u00e4 bu\u0254\u0331m du\u014b n mi\u0331 n**int=x C\u00e4\u00e4t: \u025b_thimp\u025bl_pu\u0254\u0331r (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (n) (\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Mi\u0331 ci\u0331i\u0331 mi\u0331 bi\u0331 l\u00e4td\u025b la\u0331t, bi\u0331 k\u025b ku\u025bn \u025b la mi\u0331 bi\u0331 n\u00e4mb\u00e4ri\u0331 \u025b la he\u0331kdha\u0331cimal n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan ti\u0331 bi\u0331 k\u025b ku\u025bn \u025b la praam n\u00e4mb\u00e4ri\u0331. K\u00e4 n\u00e4mb\u00e4ri\u0331 \u025b la praam n\u00e4mb\u00e4ri\u0331 tin di\u0331t ni\u0331 j\u025bn k\u00e4 1 tin \/ci\u0331 la\u0331tdi\u025bn la\u0331t \u025b n\u00e4mb\u00e4ri\u0331 tin t\u0254atni\u0331. K\u00e4 n\u00e4mb\u00e4ri\u0331 \u025b la 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. K\u00e4 n\u00e4mb\u00e4ri\u0331 praam n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan ti\u0331ti\u0331 k\u025b: 2, 3, 5, 7, 11, 13, 17,...\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Ba ji\u0331 ka\u0331m n\u00e4mb\u00e4r r\u025by de\u0331ci\u0331mal pu\u0254rmat k\u00e4 ba\u0331ldu \u025b \u0263\u00f6\u00f6 bi\u0331 j\u025b loc k\u00e4 bain\u00e4ri\u0331 pu\u0254rmat. Ba pa\u0331\u014bciin locni\u0331 k\u00e4 thi\u0331r\u025bnd, k\u025b ta\u0331a\u0331 in nyothk\u025b ni\u0331 n\u00e4mb\u00e4r bain\u00e4ri\u0331. Bi\u0331 ta\u0331a\u0331 in te thi\u0331r\u025bnd \u025b '0' ki\u025b '1'. Bi\u0331 tek\u025b ti\u0331 \u014buan ti\u0331 ba\u0331lk\u025b k\u00e4 thi\u0331r\u025bnd 'db' k\u00e4 tukd\u025b k\u025bn\u025b guutd\u025b. Bi\u0331 ta\u0331a\u0331 in ba\u0331lk\u025b thi\u0331n tek\u025b k\u025b \u0263\u00f6\u00f6 ba ji\u0331 lu\u00e4k k\u025b pu\u0254rmat. C\u00e4\u00e4tni\u0331: de\u0331ci\u0331mal_to_binary ((15) # lu\u0254c\u025b \"db1111db\" de\u0331ci\u0331mal_to_binary32) # lu\u0254c\u025b \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Ji\u0331n ca ji\u0331 moc string s. La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 ji\u0331n \u025b ku\u025bn i\u0331 string \u025b mi\u0331 tek\u025b t\u025b\u0308th l\u0254aac ki\u025b \/ci\u0331\u025b j\u025bn. string \u025b mi\u0331 tek\u025b t\u025b\u0308th l\u0254aac mi\u0331 b\u00e4\u00e4r\u025b ni\u0331 k\u00e4 3 k\u00e4 k\u025bn war\u025bgakni\u0331 diaal tin gu\u0254\u0331rk\u025b r\u0254\u0331 tek\u025b d\u00e4\u00e4k c\u00e4\u00e4t: \u025b_happy (a) => False \u025b_happy (aa) => False \u025b_happy (abcd) => True \u025b_happy (aabb) => False \u025b_happy (adb) => True \u025b_happy (xyy) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u0190 j\u025bn ju\u0254k in j\u0254ak k\u00e4 th\u025bmth\u025bd\u00e4r k\u00e4 \u014bi\u0331i\u0331c b\u025b ji\u0331 du\u00eb\u00ebl g\u0254\u0331r\u00e4 ka\u0331m pek in bi\u0331 k\u025bn \u025b kul\u025b ka\u0331m ji\u0331 du\u00eb\u00ebl g\u0254\u0331r\u00e4. \u014ai\u0331i\u0331cd\u025b min la\u0331tk\u025b \u025b \u014bi\u0331i\u0331c \u025b \u0263\u00f6\u00f6 c\u025b du\u0254\u0331\u0254\u0331r mi\u0331 caa l\u025bl k\u025b kui\u0331i\u0331d\u025b kul\u025b bath. J\u025bn c\u025b ji\u0331 ka\u0331m li\u0331th mi\u0331 nyooth pek in bi\u0331 ji\u0331 du\u00eb\u00ebl g\u0254\u0331r\u00e4 \u025b na\u014b k\u025b k\u00e4 bi\u0331 ji\u0331n \u025b g\u0254\u0331r k\u025b \u0263\u00f6\u00f6 bi\u0331 pek in bi\u0331 ji\u0331 du\u00eb\u00ebl g\u0254\u0331r\u00e4 \u025b na\u014b k\u025b j\u025b kul\u025b ji\u0331n \u025b na\u014b k\u025b k\u00e4 bi\u0331 ji\u0331n \u025b g\u0254\u0331r k\u025b ta\u0331a\u0331 in guur k\u025b ji\u0331: GPA. Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"G\u0254\u0331r pa\u0331\u014bciin mi\u0331 na\u014bk\u025b th\u00e4rkd\u025b k\u00e4 b\u025b loc ni\u0331 thu\u0254\u0331k mi\u0331 ci\u0331 th\u00e4rkd\u025b \u025b mi\u0331 b\u00e4\u00e4r ki\u025b mi\u0331 \/ci\u0331 m\u0254 a praam n\u00e4mb\u00e4r c\u00e4\u00e4tni\u0331 prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Mi\u0331 ca \u014bun \u025b la mi\u0331 tek\u025b pu\u0254thtip inteji\u025br n, locni\u0331 n\u00e4mb\u00e4ri\u0331 k\u00e4 n-dhi\u0331jit pu\u0254thtip inteji\u025bri\u0331 tin bi\u0331 tu\u0254k ki\u025b bi\u0331 thu\u0254\u0331k k\u025b 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Mi ca \u014bun \u025b la mi\u0331 tek\u025b pu\u0254\u0331thitib intejer N, locni\u0331 d\u00e4\u00e4k\u025b di\u0331ji\u0331tni\u0331k\u025b r\u025by bain\u00e4ri\u0331. C\u00e4\u00e4t k\u025b kui\u0331 N = 1000, d\u00e4\u00e4k\u025b di\u0331ji\u0331tni\u0331 b\u025b a 1 k\u00e4 min ba na\u014b raar b\u025b a \"1\". k\u025b kui\u0331 N = 150, d\u00e4\u00e4k\u025b di\u0331ji\u0331tni\u0331 b\u025b a 6 k\u00e4 min ba na\u014b raar b\u025b a \"110\". k\u025b kui\u0331 N = 147, d\u00e4\u00e4k\u025b di\u0331ji\u0331tni\u0331 b\u025b a 12 k\u00e4 min ba na\u014b raar b\u025b a \"1100\".\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Mi\u0331 ca \u014bun \u025b la mi\u0331 \/ci\u0331 la\u0331th \u025b la mi\u0331 te go\u0331l\u00e4 k\u00e4 intejeri\u0331 lst, matni\u0331 \u025bl\u025bm\u025bni\u0331 tin te pa\u0331r k\u00e4 tek\u025b \u025bni\u0331 indi\u0331dhi\u0331thni\u0331 ti\u0331 \/ci\u0331 t\u0254t. c\u00e4\u00e4tni\u0331: mat (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    G\u0254\u0331r ni\u0331 pa\u0331\u014bciin mi\u0331 na\u014bk\u025b th\u00e4rkd\u025b k\u00e4 b\u025b locni\u0331 min ca riali\u0331k\u00e4. Th\u00e4rkd\u025b min ca riali\u0331k\u00e4, \u025b th\u00e4rk mi\u0331 te rieet diaal thi\u0331n (mi\u0331 ca da\u0331a\u0331k \u025b kam) k\u025b \u0263\u00f6\u00f6 ba k\u025b ri\u0331i\u0331t \u025b rieet mi\u0331 pay tu\u0254\u0254k mi\u0331 te k\u025bn diaal k\u025b gua\u0331a\u0331th mi\u0331 ci\u0331 r\u0254 r\u00e4th thi\u0331n k\u025b \u0263\u00f6\u00f6 ba lu\u0254tdi\u025bn kul\u025b jiek. N\u0254\u014b: Ji\u0331n bi\u0331 yi\u0331k riali\u0331k\u00e4 rieetni\u0331 k\u025bn\u025b kamni\u0331 tin te j\u0254\u0331\u0254\u0331r r\u025by th\u00e4nt\u025b\u0308\u025b\u0308l. C\u00e4\u00e4t: anti_shuffle ((('Hi') locni\u0331 'Hi' anti_shuffle (('hello') locni\u0331 'ehllo' anti_shuffle (('Hello World!!!\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Mi\u0331 ca ji\u0331 ka\u0331m data mi\u0331 tek\u025b d\u00e4\u00e4kni\u0331 r\u025bw, cetk\u025b lista\u0331 tin ca mat, min c\u00e4\u00e4t k\u025b matrik, du\u014bd\u025b \u0263\u00f6\u00f6, \/ci\u0331 ta\u0331a\u0331 matrikni\u0331, bi\u0331k\u025b tek\u025b n\u00e4mb\u00e4r mi\u0331 g\u00f6l k\u00e4 k\u0254l\u00f6mni\u0331. Mi\u0331 ca lst, k\u025bn\u025b intejer x, go\u0331ri\u0331 intejeri\u0331 x r\u025by li\u0331th\u00e4, k\u025bn\u025b locni\u0331 li\u0331th du\u014b tupul, [(x1, y1), (x2, y2)...] \u025b la \u0263\u00f6\u00f6 bi\u0331 tupul \u025b k\u0254ndi\u0331r\u00ebt - (row, columns), tok\u025b k\u025b 0. C\u0254ali\u0331 k\u0254rdi\u0331n\u025bti\u0331 k\u025b nhiam \u025b la r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331. C\u00e4\u00e4tni\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Mi ca ji\u0331 moc n\u00e4mb\u00e4ri ti \/ci\u0331 k\u025bn negative, loc ni\u0331 n\u00e4mb\u00e4ri tin ca \u014bun k\u00e4 n\u00e4mb\u00e4ri tin ca \u014bun k\u025b k\u0254r k\u00e4 mi ci\u0331 k\u025b da\u0331a\u0331k, bi\u0331 k\u025b da\u0331a\u0331k k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 w\u00e4 nhial mi\u0331 ci\u0331 matdi\u025bn (k\u00e4 index in nhiam, k\u00e4 index in j\u0254ak) \u025b mi\u0331 \/ci\u0331 m\u0254 a k\u025bl, ki\u025b bi\u0331 k\u025b da\u0331a\u0331k k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 w\u00e4 piny mi\u0331 ci\u0331 matdi\u025bn (k\u00e4 index in nhiam, k\u00e4 index in j\u0254ak) \u025b mat.\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"L\u00e4td\u025b k\u025b encrypt mi\u0331 na\u014b\u025b string \u025b la argum\u025bn k\u00e4 b\u025b cu loc ni\u0331 string mi\u0331 ca enkript k\u00e4 ba alphabeth loc. Alphabeth ba loc k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 bi\u0331 l\u025b\u0308\u025b\u0308tni\u0331 cu loc piny \u025b r\u025bw ti\u0331 ca r\u00ebp k\u00e4 gua\u0331th r\u025bw. C\u00e4\u00e4t: encrypt (('hi') locni\u0331 'lm' encrypt (('asdfghjkl') locni\u0331 'ewhjklnop' encrypt (('gf') locni\u0331 'kj' encrypt (('et') locni\u0331 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Ji\u0331n ca ji\u0331 ka\u0331m li\u0331th n\u00e4mb\u00e4ri\u0331 ti\u0331 r\u00e4th k\u00e4 di\u0331t. G\u0254\u0331r ni\u0331 pa\u0331\u014bciin in d\u0254\u0331\u014b_mi\u0331 t\u0254t (() min bi\u0331 loc ni\u0331 \u025bl\u025bm\u025bni\u0331 tin t\u0254t tin 2nd r\u025by li\u0331th\u00e4. L\u00e4tni\u0331 Noth mi\u0331 thi\u025bl\u025b \u025bl\u025bm\u025bni\u0331 ti\u0331 t\u0254t. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Noth next_smallest (([1, 1]) == Noth\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Bi\u0331 ji\u0331n r\u0254 moc riet mi\u0331 bi\u0331 ji\u0331 jak\u00e4 di\u025b\u025br, k\u00e4 bi\u0331 la\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 pek rieetni\u0331 tin ci\u0331 r\u0254\u0331 la\u0331th thi\u0331n ku\u025bn. Ri\u0331e\u0331t mi\u0331 ci\u0331 r\u0254\u0331 la\u0331th thi\u0331n \u025b mi\u0331 tok\u025b k\u025b riet \"\u0194\u00e4n\". Ri\u0331e\u0331t tin caa la\u0331th thi\u0331n laa k\u025b laa th\u025bmk\u025b \u025b '.', '?' ki\u025b '!'.\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    G\u0254\u0331r ni\u0331 pa\u0331\u014bciin mi\u0331 na\u014b\u025b thok, k\u00e4 b\u025b j\u025b ku\u00eb\u014b r\u025by du\u0254\u0331p mi\u0331 bi\u0331 j\u025b g\u025br k\u00e4 bi\u0331 j\u025b ku\u00eb\u014b r\u025by war\u025bgakni\u0331 diaal, b\u025b kamni\u0331 rieet diaal tin la j\u0254wk\u025b r\u025by ruac k\u025b war\u025bgak in ci\u0331 j\u0254\u0254c gua\u0331th da\u0331\u014b r\u025bw nhiamd\u025b \u025bn j\u0254w \u025bm\u0254 r\u025by ali\u0331p\u00ebtheth Li\u014bli\u0331th.\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Mi\u0331 ci\u0331 k\u0254n\u025b ka\u0331m raar \u025b la mi\u0331 caa la\u0331t \u025b la mi\u0331 di\u0331i\u0331t k\u00e4 di\u0331t, bi\u0331 k\u0254n\u025b l\u025b loc \u025b la mi\u0331 caa mat \u025b la mi\u0331 di\u0331i\u0331t k\u00e4 di\u0331t k\u00e4 di\u0331t. C\u00e4\u00e4tni\u0331: Mi\u0331 ci\u0331 lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] bi\u0331 min ca ka\u0331m raar ku l\u025b t\u00e4 k\u025b 10 mi\u0331 ci\u0331 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] bi\u0331 min ca ka\u0331m raar ku l\u025b t\u00e4 k\u025b 25 mi\u0331 ci\u0331 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] bi\u0331 min ca ka\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Mi ca di\u0331kcineri\u0331 ka\u0331m ji, lu\u0254\u0331ck\u025b thu\u0254\u0331k mi\u0331 ci\u0331 ki\u0331i\u0331ni\u0331 diaal \u025b th\u00e4rkcini\u0331 ti\u0331 te r\u025by ci\u0331e\u0331\u014bni\u0331 ti\u0331 t\u0254t ki\u025b bi\u0331 ki\u0331i\u0331ni\u0331 diaal \u025b th\u00e4rkcini\u0331 ti\u0331 te r\u025by ci\u0331e\u0331\u014bni\u0331 ti\u0331 di\u0331t, mi\u0331 ci\u0331e\u0331 m\u0254 lu\u0254\u0331ck\u025b mi\u0331 ji\u0331\u00e4\u00e4k. La\u0331t bi\u0331 dhil lu\u0254\u0331c mi\u0331 ji\u0331\u00e4\u00e4k mi\u0331 ca di\u0331kcineri\u0331 ka\u0331m thi\u025bl mi\u0331 te thi\u0331n. C\u00e4\u00e4tni\u0331: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) bi\u0331 dhil lu\u0254\u0331c mi\u0331 ji\u0331\u00e4\u00e4k. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"L\u00e4td\u025b k\u025b pa\u0331\u014bciin mi\u0331 na\u014bk\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 \/ci\u0331k\u025b neg\u025btib k\u00e4 locni\u0331 n\u00e4mb\u00e4ri\u0331 tin nhiam k\u00e4 n tin la praam n\u00e4mb\u00e4ri\u0331 k\u025bn\u025b tin kuiyni\u0331k\u025bn k\u00e4 n. c\u00e4\u00e4t: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Mi\u0331 ci\u0331 k\u0254n\u025b mat k\u00e4 n\u00e4mb\u00e4ri\u0331 da\u0331\u014b r\u025bw k\u00e4 bi\u0331 k\u025b loc \u025b la mi\u0331 ca mat k\u00e4 n\u00e4mb\u00e4ri\u0331 tin t\u00e4 k\u00e4 k\u025bl. K\u00e4 bi\u0331 k\u025b loc \u025b la ti\u0331 caa mat k\u00e4 ti\u0331 \u014buan. C\u00e4\u00e4tni\u0331: gua\u0331th in t\u00e4 k\u025b 148, 412) bi\u0331 k\u025b loc ni\u0331 16 gua\u0331th in t\u00e4 k\u025b 19 28, 72 gua\u0331th in t\u00e4 k\u025b 2020, 1851) bi\u0331 k\u025b loc ni\u0331 0. gua\u0331th in t\u00e4 k\u025b 14-15 bi\u0331 k\u025b loc ni\u0331 20\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Mi ca th\u00e4rkd\u025b \u014bun, ku\u025bn pek in ci\u0331 r\u0254 g\u0254\u0331r piny \u025b la mi\u0331 di\u0331i\u0331t mi\u0331 caa g\u0254\u0331r piny \u025b la mi\u0331 t\u0254t. C\u00e4\u00e4td\u025b: count_upper (('aBCdEf') b\u025b loc ni\u0331 1 count_upper (('abcdefg') b\u025b loc ni\u0331 0 count_upper (('dBBE') b\u025b loc ni\u0331 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Mi ca \u014bun \u025b la mi\u0331 tek\u025b pu\u0254\u0331r, ba ji\u0331 jak\u00e4 bi\u0331 p\u00e4\u00e4m ti\u0331 \u014buan ti\u0331 \u014buan ti\u0331 \u014buan la\u0331t. K\u00e4 p\u00e4m in nhiam tek\u025b p\u00e4\u00e4m ti\u0331 n. K\u00e4 pek p\u00e4\u00e4mni\u0331 tin te r\u025by p\u00e4m in d\u0254\u0331\u014b b\u025b: - \u025b n\u00e4mb\u00e4r mi\u0331 d\u0254\u0331\u014b mi\u0331 \/ci\u0331 m\u0254 a pa\u0331r mi\u0331 n \u025b pa\u0331r. - \u025b n\u00e4mb\u00e4r mi\u0331 d\u0254\u0331\u014b mi\u0331 p\u00e4\u00e4r mi\u0331 n \u025b pa\u0331r. L\u0254\u0331a\u0331 n\u00e4mb\u00e4r p\u00e4\u00e4mni\u0331 r\u025by p\u00e4mni\u0331 diaal r\u025by li\u0331th\u00e4, gua\u0331th in bi\u0331 \u025bl\u025bm\u025bni\u0331 tin te k\u00e4 indi\u0331dh\u025bth i \u025b nyoth n\u00e4mb\u00e4r p\u00e4\u00e4mni\u0331 r\u025by p\u00e4m (i+1).\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Mi\u0331 ci\u0331i\u0331 mi\u0331 ci\u0331 r\u0254 lot k\u025b du\u0254\u0331\u0254\u0331r mi\u0331 ci\u0331 r\u0254 lot k\u025b du\u0254\u0331\u0254\u0331r mi\u0331 d\u0254\u0331\u014b, bi\u0331 k\u025b j\u025b la\u0331t k\u025b \u0263\u00f6\u00f6 bi\u0331 k\u025b r\u0254\u0331 cu loc \u025b la rie\u0331t ti\u0331 caa da\u0331a\u0331k \u025b la kamni\u0331 ki\u025b kamni\u0331.\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"\u0190n pa\u0331\u014bciin \u025bm\u025b na\u014b\u025b n\u00e4mb\u00e4ri\u0331 r\u025bw ti\u0331 puci\u0331tib (positive) x k\u025bn\u025b y k\u00e4 b\u025b n\u00e4mb\u00e4ri\u0331 diaal ti\u0331 di\u0331t ti\u0331 matk\u025b k\u025b\u025bl ti\u0331 te r\u025by gua\u0331th in te (x, y) thi\u0331n loc. Mi\u0331 thi\u025bl\u025b n\u00e4mb\u00e4r mi\u0331 ce\u0331tk\u025b n\u0254, k\u00e4 bi\u0331 pa\u0331\u014bciin \u025bm\u0254 cu loc \u025b la -1. C\u00e4\u00e4t:\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Ji\u0331n ca ji\u0331 ka\u0331m intejeri\u0331 r\u025bw ti\u0331 puci\u0331tibni\u0331 n k\u025bn\u025b m, k\u00e4 la\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 pek intejeri\u0331 tin te kam n k\u025bn\u025b m \u014ba\u0331c (am\u00e4ni\u0331 n k\u025bn\u025b m). Ji\u0331n bi\u0331 j\u00e4kd\u025b kul\u025b na\u014b k\u00e4 intejeri\u0331 tin thia\u0331k k\u00e4 bi\u0331 k\u025b loc k\u00e4 bain\u00e4ri\u0331. Mi\u0331 n \u025b mi\u0331 di\u0331t ni\u0331 j\u025bn k\u00e4 m, loc -1. C\u00e4\u00e4t: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b11\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Mi\u0331 ca \u014bun \u025b la li\u0331th du\u014b puci\u0331tib intejeri\u0331 x, b\u025b liny \u025b la li\u0331th mi\u0331 ca riali\u0331k\u00e4 k\u00e4 \u025bl\u025bm\u025bni\u0331 diaal tin \/thi\u025bl\u025b di\u0331jit mi\u0331 p\u00e4\u00e4r thi\u0331n.\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Mi ca ji\u0331 moc n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan, bi\u0331 k\u025b ku\u00eb\u014b k\u00e4 1 k\u025bn\u025b 9, bi\u0331 k\u025b ku\u00eb\u014b k\u00e4 mi\u0331 d\u0254\u0331\u014b, k\u00e4 bi\u0331 k\u025b ku\u00eb\u014b k\u00e4 mi\u0331 d\u0254\u0331\u014b. C\u00e4\u00e4td\u025b: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"Eight\", \"Five\", \"Four\", \"Two\", \"Two\", \"One\", \"One\"] Mi\u0331 ci\u0331 n\u00e4mb\u00e4ri\u0331 te j\u0254\u0331\u0254\u0331r, bi\u0331 k\u025b ku\u00eb\u014b k\u00e4 mi\u0331 d\u0254\u0331\u014b: arr = [] return [] Mi\u0331 ci\u0331 n\u00e4mb\u00e4ri\u0331 te j\u0254\u0331\u0254\u0331r, bi\u0331 k\u025b ku\u00eb\u014b k\u00e4 mi\u0331 d\u0254\u0331\u014b: arr = [1, 1, 55] -> arr -> [1, 1], 55 -> reverse\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" L\u00e4td\u025b k\u025b f mi\u0331 na\u014bk\u025b n \u025b la par\u025bmat\u025br, k\u00e4 locni\u0331 li\u0331th mi\u0331 di\u0331i\u0331t n, mi\u0331 ce\u0331tk\u025b \u0263\u00f6\u00f6 ba pek \u025bl\u025bm\u025bni\u0331 k\u00e4 indi\u0331th i \u025b pakt\u0254ri\u0254l du\u014b i mi\u0331 i \u025b pa\u0331r ki\u025b mat n\u00e4mb\u00e4ri\u0331 k\u00e4 1 \u025b w\u00e4 i mi\u0331 \/ci\u0331 m\u0254m\u0254 \u025b j\u025bn. i tok\u025b k\u00e4 1. pakt\u0254ri\u0254l i \u025b mi\u0331 la m\u00e4lti\u0331pli\u0331kaci\u0254n n\u00e4mb\u00e4ri\u0331 k\u00e4 1 \u025b w\u00e4 i (1 * 2 *... * i). C\u00e4\u00e4t: f (((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Mi ca \u014bun \u025b la mi\u0331 tek\u025b pu\u0254\u0331thitib intejer n, locni\u0331 tuple mi\u0331 tek\u025b n\u00e4mb\u00e4r pa\u0331r k\u025bn\u025b pa\u0331r intejer palindrometh tin te r\u025by gua\u0331th in tek\u025b k\u025b (n), cu m\u00e4\u00e4ni\u0331 (n). C\u00e4\u00e4t1: Input: 3 Output: (1, 2) Explanation: Integer palindrometh k\u025bn 1, 2, 3. k\u025bl k\u00e4 k\u025b \u025b pa\u0331r, k\u00e4 r\u025bw k\u00e4 k\u025b \u025b pa\u0331r. C\u00e4\u00e4t2: Input: 12 Output: (4, 6) Explanation: Integer palindrometh k\u025bn 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u014buaan k\u00e4 k\u025b \u025b pa\u0331r, k\u00e4 6 k\u00e4 k\u025b \u025b pa\u0331r. Note: 1. 1 <= n <= 10^3 2. tuple c\u025b n\u00e4mb\u00e4r pa\u0331r k\u025bn\u025b pa\u0331r intejer palindromethni\u0331 locni\u0331.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    G\u0254\u0331r la\u0331t mi\u0331 c\u0254ali\u0331 count_nums min na\u014b\u025b intejeri\u0331 ti\u0331 \u014buan k\u00e4 locni\u0331 n\u00e4mb\u00e4ri\u0331 tin te di\u0331jitni\u0331ki\u025bn thi\u0331n > 0. Mi\u0331 ci\u0331 n\u00e4mb\u00e4r \u025b neg\u025btib, k\u00e4 bi\u0331 di\u0331jit in nhiamdi\u025bn min ca la\u0331t \u025b j\u025bn b\u025b cu la neg\u025btib: c.d. -123 b\u025b di\u0331jitni\u0331 -1, 2, k\u025bn\u025b 3 la\u0331t.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Mi\u0331 ci\u0331 n\u00e4mb\u00e4ri\u0331 r\u025by arr\u025by' arr' k\u00e4 N intejeri\u0331 arr[1], arr[2],..., arr[N] k\u00e4p, bi\u0331 n\u00e4mb\u00e4ri\u0331 r\u025by arr\u025by'\u00e4 cu riali\u0331k\u00e4 k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 \/ci\u0331 r\u0254 lot. La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 ji\u0331n \u025b \u014ba\u0331c i\u0331 de r\u0254 lot k\u025b riali\u0331k\u00e4 arr\u025by'\u00e4 k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 \/ci\u0331 r\u0254 lot k\u025b \u0263\u00f6\u00f6 b\u025b w\u00e4 piny k\u025b la\u0331t in ba la\u0331t k\u00e4 arr\u025by'\u00e4 min ca \u014bun: Ji\u0331n deri\u0331 l\u00e4t mi\u0331 cu\u014b \u025b la \u0263\u00f6\u00f6 bi\u0331 la\u0331t \u025b g\u025b\u025br \u025b w\u00e4 kui\u0331c \u025b w\u00e4 k\u00e4 pek mi\u0331 go\u0331o\u0331r. La\u0331t mi\u0331 cu\u014b \u025b la \u0263\u00f6\u00f6 bi\u0331 la\u0331t in j\u0254akdi\u025bn \u025b g\u025b\u025br \u025b w\u00e4 k\u00e4 pek in tok\u025b r\u0254 r\u025by\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"R\u025by ri\u0331e\u0331e\u0331tni\u0331 ti\u0331ti\u0331, bi\u0331 la\u0331t mi\u0331 na\u014bk\u025b li\u0331thni\u0331 r\u025bw k\u00e4 bi\u0331 j\u025b \u014ba\u0331c i\u0331 de r\u0254 lot k\u025b \u0263\u00f6\u00f6 ba \u025bl\u025bm\u025bni\u0331 g\u025b\u025br kamni\u0331ki\u025bn k\u025b \u0263\u00f6\u00f6 bi\u0331 lst1 a li\u0331th du\u014b n\u00e4mb\u00e4ri\u0331 pa\u0331a\u0331r k\u00e4r\u0254\u0331. \/thi\u025bl\u025b mi\u0331 ca th\u025bm k\u00e4 n\u00e4mb\u00e4ri\u0331 tin ba g\u025br kam lst1 k\u025bn\u025b lst2. Mi\u0331 de r\u0254 lot k\u025b g\u025br \u025bl\u025bm\u025bni\u0331 kam lst1 k\u025bn\u025b lst2 k\u025b \u0263\u00f6\u00f6 bi\u0331 k\u025bn \u025bl\u025bm\u025bni\u0331 lst1 diaal a pa\u0331a\u0331r, locni\u0331 \"\u0194\u0190\u0190\". Mi\u0331 \/ci\u0331 \u025b j\u025bn, locni\u0331 \"\u0194\u0190N\". C\u00e4\u00e4t: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"\u0194\u0190N\" ba cu \u014ba\u0331\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Mi ca ji\u0331 ka\u0331m string mi nyothni\u0331 gua\u0331th in ca kam war\u025bgakni\u0331 tin t\u0254atni\u0331 da\u0331a\u0331k, locni\u0331 di\u0331jikcin k\u00e4 war\u025bgak in ci\u0331 r\u0254 ny\u0254k k\u025b loc k\u00e4 tek\u025b k\u025b n\u00e4mb\u00e4r mi\u0331 p\u00e4\u00e4r. Mi\u0331 ci\u0331 war\u025bgakni\u0331 ti\u0331 \u014buan tek\u025b k\u025b gua\u0331th ti\u0331 c\u00e4\u00e4t, locni\u0331 k\u025bn diaal. C\u00e4\u00e4t: \u0194itht\u00f6gram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} \u0194itht\u00f6gram ((('a b b a') == {'a': 2, 'b': 2} \u0194itht\u00f6gram ((('a b c a b') == {'a': 2, 'b': 2} \u0194itht\u00f6gram ((('b b a') == {'b 4}: \u0194itht\u00f6gram ((('') == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Ta\u0331a\u0331 la\u0331t ca\u0331a\u0331t k\u025b k\u0254r\u025b, ca k\u0254r\u025b ka\u0331m i\u0331thti\u0331r\u025bktni\u0331 r\u025bw ti\u0331 p\u00e4\u00e4rk\u025b k\u025b tin te r\u025by c, bi\u0331 k\u025b dhil woc k\u00e4 bi\u0331 k\u025b kul\u025b pa\u0331lindr\u0254mi\u0331. K\u00e4 bi\u0331 k\u025bn pa\u0331lindr\u0254mi\u0331 tin te r\u025by thitht\u025bm\u00e4 cu pa\u0331lindr\u0254mi\u0331 mi\u0331 ca k\u025b loc j\u0254k \u025b p\u00e4\u00e4r k\u025b w\u00e4 nhiam.\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Mi\u0331 ca \u014bun \u025b la li\u0331th du\u014b th\u00e4rkdi\u0331ni\u0331, gua\u0331th in bi\u0331 th\u00e4rkdi\u0331n \u025b na\u014b ni\u0331 dijitni\u0331 k\u00e4r\u0254\u0331, bi\u0331 li\u0331th ni\u0331 loc. \u0190l\u025bm\u025bni\u0331 i\u0331 k\u00e4 min ba na\u014b raar ba \"nhial \u025bl\u025bm\u025bni\u0331 tin \/ci\u0331 t\u0254\u0331 a k\u025bl r\u025by th\u00e4rkdi\u0331n i\u0331 k\u00e4 min ca na\u014b\". gua\u0331th in bi\u0331 i\u0331 diaal ba loc \u025b n\u00e4mb\u00e4r du\u014b di\u0331jitni\u0331 tin \/ci\u0331 t\u0254\u0331 a k\u025bl r\u025by th\u00e4rkdi\u0331n i\u0331th k\u00e4 min ca na\u014b.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Mi\u0331 ca \u014bun \u025b la mi\u0331th\u025b\u0308r du\u014b intejeri\u0331 n\u00e4mb\u00e4ri\u0331, jiek\u025b min t\u0254t k\u00e4 min \/ci\u0331 pual k\u00e4 tha\u0331b-array du\u014b n\u00e4mb\u00e4ri\u0331. c\u00e4\u00e4t minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Ji\u0331n ca ji\u0331 moc ri\u0331i\u0331th mi\u0331 ca riali\u0331k\u00e4 k\u00e4 ca r\u0254\u0331 yiath piny. Ruey k\u025bl \u025b ri\u0331i\u0331th k\u025bl, k\u00e4 1 \u025b k\u025bl k\u00e4 ruey k\u025bl \u025b k\u025bl mi\u0331 la pi\u0331w. Ri\u0331i\u0331th k\u025bl \u025b mi\u0331 te k\u025b mi\u0331 p\u00e4\u00e4r k\u025b j\u025b mi\u0331 d\u00eb\u00eb ka\u0331m pi\u0331w thi\u0331n, k\u00e4 bi\u0331i\u0331 diaal tek\u025b pek mi\u0331 p\u00e4\u00e4r. La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331i\u0331 tin te r\u025by ri\u0331i\u0331th\u00e4 cu\u0254p. L\u00e4td\u025b ni\u0331 pek in go\u0331o\u0331ri\u0331 k\u025b \u0263\u00f6\u00f6 bi\u0331i\u0331 tin te piny cu\u0254p. C\u00e4\u00e4t 1: Input: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Output: 62: Input: grid: [[0,0,1,1], [0,\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    R\u025by k\u00e4 Kata, bi\u0331 ji\u0331n \u025b go\u0331r i\u0331 bi\u0331 k\u025b ku\u00eb\u014b k\u00e4 mat n\u00e4mb\u00e4ri\u0331 tin \/ci\u0331 negative \u025b la tin ca mat k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bi\u0331 k\u025bn r\u0254\u0331 ku\u00eb\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b k\u00e4 bain\u00e4ri\u0331 tin cu\u014b\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Mi ca th\u00e4rk\u025bn th\u00f6p k\u00e4 ca k\u025b moc n\u00e4mb\u00e4r n, ca ji\u0331 la\u0331t la\u0331t mi bi riet diaal tin te r\u025by th\u00e4rk\u025bn th\u00f6p tin tek\u025b thok mi r\u025blr\u0254, k\u025b \u0263\u00f6\u00f6 bi riet \u025bm\u0254 j\u0254\u0254c r\u025by th\u00e4rk\u025bn th. Mi\u0331 ci\u0331 th\u00e4rk\u025bn th th th th a thil lu\u0254t, bi la\u0331t \u025bm\u0254 l\u025b ny\u0254k k\u025b loc ni\u0331 riet mi\u0331 thi\u025bl lu\u0254t.\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Ji\u0331n ca ji\u0331 moc riet. La\u0331tdu \u025b \u0263\u00f6\u00f6 bi j\u0254w in thia\u0331k in te kam rieetni\u0331 da\u0331\u014b r\u025bw tin j\u0254c kui\u0331c cu\u00eb\u00ebc riet\u00e4 (lu\u0254\u0331cd\u025b k\u025b gua\u0331a\u0331th in g\u0254\u0331rk\u025b ni\u0331 j\u025b). Ji\u0331n \/ci j\u0254w in te nhiamd\u025b k\u025bn\u025b j\u0254w in j\u0254c l\u025b ku\u025b\u0308\u025b\u0308n. Ji\u0331n de ji\u0331 moc rieet ti thi\u025bl lu\u0254t mi\u0331 \/ci\u0331 j\u0254w in ca g\u0254\u0331r thi\u0331n jek mi\u0331 ci\u0331 min ca lat nhial l\u025b cop. Ji\u0331n de\u0331i\u0331 j\u025b car \u025bn \u0263\u00f6\u00f6 \u025bn rieet in ca \u014bun te ni\u0331 riet English k\u00e4r\u0254a. C\u00e4\u00e4t: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"UULL\" get_closest\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Mi ca \u014bun \u025b la mi\u0331 te intejeri\u0331 arr k\u025bn\u025b mi\u0331 tek\u025b positive intejeri\u0331 k, locni\u0331 li\u0331th mi\u0331 ca riali\u0331k\u00e4 k\u00e4 b\u00e4r\u025b k k\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan k\u00e4 arr. C\u00e4\u00e4t1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] C\u00e4\u00e4t2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] C\u00e4\u00e4t3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Note: 1.\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Mi ca \u014bun \u025b la mi\u0331 \/ci\u0331 la pual, locni\u0331 n\u00e4mb\u00e4ri\u0331 diaal tin te gua\u0331thki\u025bn \u025b la pual.\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Mi ca \u014bun \u025b la mi\u0331 \/ci\u0331 la pual k\u00e4 \u025b intejeri\u0331 arr k\u025bn\u025b intejeri\u0331 k, locni\u0331 n\u00e4mb\u00e4ri\u0331 tin te k\u00e4 di\u0331jitni\u0331 r\u025bw k\u00e4 \u025bl\u025bm\u025bni\u0331 tin nhiam k\u00e4 arr. C\u00e4\u00e4t: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Mi ca \u014bun \u025b la mi\u0331 tek\u025b pu\u0254\u0331thitib intejer n, locni\u0331 li\u0331th mi\u0331 ca riali\u0331k\u00e4 min tek\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 ji\u0331di\u0331ni\u0331 r\u025by k\u0254la\u0331tdh theku\u025bnthi\u0331. K\u0254la\u0331tdh k\u0254njeci\u025br \u025b k\u0254njeci\u025br r\u025by m\u025bthematikni\u0331 min ruac k\u025b kui\u0331 theku\u025bnthi\u0331 mi\u0331 ca lat i\u0331 \u025b j\u025bn i\u0331n\u0254: tok\u025b k\u025b mi\u0331 tek\u025b pu\u0254\u0331thitib intejer n. K\u00e4 k\u025b k\u0254r\u025b \u025bn k\u025bl \u025b mi\u0331 ca jiek k\u00e4 min te nhiam: mi\u0331 ci\u0331 min te nhiam \u025b pa\u0331r, min bi\u0331 ben k\u0254\u0254r \u025b j\u025bn nuth k\u00e4 min te nhiam. Mi\u0331 ci\u0331 min te nhiam \u025b pa\u0331r, min bi\u0331 ben k\u0254\u0254r \u025b j\u025bn 3 gua\u0331thni\u0331 tin ci\u0331 ben k\u0254\u0254r \u025b matk\u025b 1. K\u00e4 min ca\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Ji\u0331n bi\u0331i\u0331 mi\u0331 la\u0331t k\u025b \u0263\u00f6\u00f6 bi\u0331 c\u00e4\u014b \u014ba\u0331c k\u00e4 bi\u0331 loc \u025b thu\u0254\u0331k mi\u0331 ci\u0331 c\u00e4\u014b \u014ba\u0331c \u025b thu\u0254\u0331k mi\u0331 ci\u0331 c\u00e4\u014b \u014ba\u0331c \u025b thu\u0254\u0331k mi\u0331 ci\u0331 c\u00e4\u014b \u014ba\u0331c \u025b thu\u0254\u0331k mi\u0331 ci\u0331 c\u00e4\u014b \u014ba\u0331c \u025b thu\u0254\u0331k mi\u0331 ci\u0331 c\u00e4\u014b \u014ba\u0331c \u025b thu\u0254\u0331k mi\u0331 ci\u0331 c\u00e4\u014b \u014ba\u0331c \u025b thu\u0254\u0331k mi\u0331 ci\u0331 c\u00e4\u014b \u014ba\u0331c \u025b thu\u0254\u0331k mi\u0331 ci\u0331 k\u025bn \u014bu\u0254\u0331t diaal tin gu\u0254\u0331\u0254\u0331rk\u025b k\u025b w\u00e4: 1. c\u00e4\u014b \u014ba\u0331c \u025b mi\u0331 \/ci\u0331 m\u0254 a ba\u014b. 2. pek ni\u0331ni\u0331 \/ci\u0331 ku\u025b\u0308\u025b\u0308 ni\u0331 1 ki\u025b di\u0331t ni\u0331 k\u00e4 31 ni\u0331ni\u0331 k\u025b p\u00e4th 1,3,5,7,8,10,12. k\u00e4 pek ni\u0331ni\u0331 \/ci\u0331 ku\u025b\u0308\u025b\u0308 ni\u0331\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Mi\u0331 ca ji\u0331 ka\u0331m kamni\u0331 da\u0331\u014b r\u025bw, bi\u0331 kamni\u0331 diaal \u025b pa\u0331r in ca mat \u025b n\u00e4mb\u00e4ri\u0331 tin te k\u025b\u025bl. C\u00e4\u00e4t, kamni\u0331 da\u0331\u014b r\u025bw = (cu\u0254\u0331p, guut) = (1, 2). K\u00e4 kamni\u0331 da\u0331\u014b r\u025bw t\u00ebk\u025b mi\u0331 ca g\u00e4k min lot ni\u0331 \u0263\u00f6\u00f6 kamni\u0331 (cu\u0254\u0331p, guut) te k\u025b tuk k\u025bn\u025b guut. K\u025b kui\u0331 kamni\u0331 da\u0331\u014b r\u025bw, j\u025bn ba na\u014b i\u0331 j\u025bn tukd\u025b \u025b kuiy ki\u025b p\u00e4\u00e4r k\u025b guutd\u025b. La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 j\u025b \u014ba\u0331c i\u0331 mi\u0331 ci\u0331 pek in ci\u0331 r\u00f6m kamni\u0331 da\u0331\u014b r\u025bw \u025b n\u00e4mb\u00e4r mi\u0331 nhiam. C\u00e4\u00e4t, kamni\u0331 da\u0331\u014b r\u025bw (1, 3), (2, 4) \u025b (2, 3) min ci\u0331 pekd\u025b \u025b 1, min \/ci\u0331 m\u0254 a n\u00e4\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Mi\u0331 ca ji\u0331 ka\u0331m arr\u025by mi\u0331 tek\u025b intejeri\u0331, bi\u0331 ji\u0331 dhil locni\u0331 mat intejeri\u0331 ti\u0331 \u014buan k\u025b \u0263\u00f6\u00f6 ba k\u025b kul\u025b la\u0331t \u025b la mi\u0331 ca la\u0331t \u025b n\u00e4mb\u00e4ri\u0331 diaal tin te r\u025by arr\u025by, min ca nyoth \u025b 1, -1 ki\u025b 0.\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Mi ca ji\u0331 ka\u0331m thurbil mi te k\u025b ri\u0331i\u0331wni\u0331 N k\u025bn\u025b ko\u0331l\u00f6mni\u0331 N (N >= 2) k\u025bn\u025b n\u00e4mb\u00e4r mi\u0331 thu\u0254\u0331k mi\u0331 la k, bi\u0331 thurbil \u025b m\u0254 tek\u025b mi\u0331 ca mat thi\u0331n. Bi\u0331 thurbil \u025b m\u0254 tek\u025b mi\u0331 t\u0254t mi\u0331 t\u0254t mi\u0331 t\u0254t mi\u0331 ca mat thi\u0331n. Ji\u0331n deri\u0331 thurbil \u025b m\u0254 jiek k\u00e4 bi\u0331 j\u0254\u0254c k\u00e4 thurbil \u025b m\u0254. Ji\u0331n deri\u0331 j\u025b tok k\u00e4 thurbil \u025b m\u0254, k\u00e4 bi\u0331 ji\u0331n w\u00e4 k\u00e4 thurbil mi\u0331 t\u0254t mi\u0331 t\u0254t mi\u0331 te thi\u0331n, k\u025b rieet ti\u0331 k\u0254\u0331\u014b, deri\u0331 ji\u0331n w\u00e4 k\u00e4 thurbil mi\u0331 t\u0254t mi\u0331 t\u00e4 thi\u0331n. Ji\u0331n \/ci\u0331 bi\u0331 j\u0254\u0254c k\u00e4 thurbil \u025b m\u0254. thurbil A (mi\u0331\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"K\u025bn diaal \u014ba\u0331ck\u025b pe\u0331k pi\u0331i\u0331b\u0254nacci\u0331, j\u025bn cua \u014bi\u0331e\u0331e\u0331c \u025b g\u0254a \u025b m\u025bthemati\u0331ciani\u0331 r\u025by runti\u0331 kur r\u025bw t\u00eb\u00eb ci\u0331 w\u0254\u0331. Du\u014bd\u025b \u0263\u00f6\u00f6, min kui\u0331c naath \u025b pe\u0331k Trib\u0254nacci\u0331. Pe\u0331k Trib\u0254nacci\u0331 cua lat \u025b la mi\u0331 loc r\u0254: tri(1) = 3 tri(n) = 1 + n \/ 2, mi\u0331 n \u025b pa\u0331r. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), mi\u0331 n \u025b pa\u0331r. C\u00e4\u00e4t: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Ca ji\u0331 ka\u0331m n\u00e4mb\u00e4r mi\u0331 \/ci\u0331\u025b\u025b\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Mi ca \u014bun \u025b la mi\u0331 tek\u025b pu\u0254\u0331thitib inteji\u025br n, locni\u0331 pr\u0254du\u0331kci\u0254n du\u014b di\u0331jitni\u0331 tin \/ci\u0331 t\u0254t. L\u00e4tni\u0331 0 mi\u0331 k\u025bn di\u0331jitni\u0331 diaal \u025b pa\u0331r. C\u00e4\u00e4t: di\u0331jitni\u0331 ((1) == 1 di\u0331jitni\u0331 ((4) == 0 di\u0331jitni\u0331 ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Mi\u0331 ca ji\u0331 ka\u0331m li\u0331t n\u00e4mb\u00e4ri\u0331, bi\u0331 yi\u0331k j\u00e4kni\u0331 n\u00e4mb\u00e4ri\u0331 tin ca ku\u00eb\u014b k\u00e4 i\u0331thku\u025br r\u025by li\u0331th\u00e4 min ca \u014bun, bi\u0331 yi\u0331k \u025bl\u025bm\u025bni\u0331 diaal r\u025by li\u0331th\u00e4 \u025b la tin te nhial k\u00e4 int (c\u00e4\u00e4tni\u0331k\u025b) k\u025b nhiam. C\u00e4\u00e4tni\u0331: k\u025b kui\u0331 lst = [1,2,3] bi\u0331 min ca ku\u00eb\u014b k\u00e4 int bi\u0331 a 14 k\u025b kui\u0331 lst = [1,4,9] bi\u0331 min ca ku\u00eb\u014b k\u00e4 int bi\u0331 a 98 k\u025b kui\u0331 lst = [1,3,5,7] bi\u0331 min ca ku\u00eb\u014b k\u00e4 int bi\u0331 a 84 k\u025b kui\u0331 lst = [1.4,4.2,0] bi\u0331 min ca ku\u00eb\u014b k\u00e4 int bi\u0331 a 29 k\u025b kui\u0331 lst = [-2.4,1,1] bi\u0331 min ca ku\u00eb\u014b k\u00e4 int bi\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Mi\u0331 ci\u0331k\u025b thi\u025bl, bi\u0331 k\u025bn lu\u0254\u0331c \u025b la -1. Mi\u0331 ca mat k\u00e4 matd\u00e4 mi\u0331 ca \u014bun \/ci\u0331 bi\u0331 tek\u025b lu\u0254\u0331\u0254\u0331tni\u0331 ti\u0331 c\u00e4\u00e4t. C\u00e4\u00e4tni\u0331: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    L\u00e4td\u025b k\u025b mi\u0331 na\u014b\u025b intejeri\u0331, floateth, ki\u025b th\u00e4rkith tin cu\u014b k\u025b n\u00e4mb\u00e4ri\u0331 tin thu\u0254\u0331k, k\u00e4 locni\u0331 mi\u0331 di\u0331i\u0331t k\u00e4 bi\u0331 ben raar r\u025by ba\u0331riab\u0254l tin ca \u014bun. \/Ci\u0331k\u025b bi\u0331 locni\u0331 mi\u0331 ca \u014bun \u025b p\u00e4\u00e4r.\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"L\u00e4td\u025b j\u025b mi\u0331 de \u014bun \u025b la n\u00e4mb\u00e4r n mi\u0331 ca \u014bun \u025b la mat n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan ti\u0331 p\u00e4\u00e4r (positive even numbers) c\u00e4\u00e4td\u025b \u025b j\u025bn_mi\u0331 p\u00e4\u00e4r_k\u025b_k\u00e4_mi\u0331 p\u00e4\u00e4r (even) ((4) == Ji\u0331\u00e4\u00e4k \u025b j\u025bn_mi\u0331 p\u00e4\u00e4r (false) \u025b j\u025bn_mi\u0331 p\u00e4\u00e4r (even) ((6) == Ji\u0331\u00e4\u00e4k \u025b j\u025bn_mi\u0331 p\u00e4\u00e4r (false) \u025b j\u025bn_mi\u0331 p\u00e4\u00e4r (even) ((8) == Ci\u0331k\u025b thu\u0254\u0331k\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"K\u00e4 bra\u0331thi\u0331lian pakt\u00f6ri\u0331al cua lat i\u0331: bra\u0331thi\u0331lian_pakt\u00f6ri\u0331al (n) = n! * (n-1)! * (n-2)! *... * 1! gua\u0331th in n > 0 C\u00e4\u00e4td\u025b:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Mi ca ji\u0331 moc bi\u0331i\u0331 mi\u0331 g\u0254a, loc kamni\u0331 diaal k\u025b bi\u0331i\u0331 mi\u0331 te piny, k\u00e4 mi\u0331 ci\u0331 bi\u0331i\u0331 tek\u025b bi\u0331i\u0331 ti\u0331 l\u00e4ny 2 ti\u0331 gu\u0254\u0331rk\u025b r\u0254\u0331, bi\u0331i\u0331 diaal tin gu\u0254\u0331rk\u025b r\u0254\u0331 cu loc k\u025b - fix_spaces (((\"C\u00e4\u00e4t\") == \"C\u00e4\u00e4t\" fix_spaces (((\"C\u00e4\u00e4t1\") == \"C\u00e4\u00e4t_1\" fix_spaces (((\"C\u00e4\u00e4t2\") == \"_C\u00e4\u00e4t_2\" fix_spaces (((\"C\u00e4\u00e4t 3\") == \"_C\u00e4\u00e4t-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"L\u00e4td\u025b mi\u0331 na\u014b\u025b ci\u00f6t mi\u0331 nyooth ci\u00f6t k\u025b\u0308\u025b\u0308l, k\u00e4 b\u025b loc ni\u0331 '\u0194\u0254\u0331\u0254\u0331n' mi\u0331 ci\u0331 ci\u00f6t k\u025b\u0308\u025b\u0308l r\u0254 lot, k\u00e4 b\u025b loc ni\u0331 '\/ci\u0331\u025b\u0331 j\u025bn' mi\u0331 ci\u0331 d\u0254\u0331\u014b. ci\u00f6t k\u025b\u0308\u025b\u0308l ba cu car i\u0331 lotd\u025b r\u0254 mi\u0331 k\u025bn\u025b gua\u0331th tin ca mat thi\u0331n k\u00e4r\u0254\u0331: - \/ci\u0331k\u025b bi\u0331 tek\u025b di\u0331jitni\u0331 di\u0331t k\u00e4 di\u0254\u0331k ('0'-'9') r\u025by ci\u0331\u00f6td\u025b. - Ci\u0331\u00f6t k\u025b\u0308\u025b\u0308l t\u00ebk\u025b dot k\u025bl k\u00e4r\u0254a '.' - Ci\u0331\u00f6t in te nhiam dot \/c\u025b bi\u0331 dhil te baa\u014b, k\u00e4 b\u025b tok k\u025b wargak k\u00e4 laatin alphapet ('a'-'z' k\u025bn\u025b 'A'Z'). - Ci\u0331\u00f6t in te j\u0254k dot b\u025b dhil te k\u025bl k\u00e4 ti\u0331\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" La\u0331t \u025bm\u025b b\u025b na\u014bni\u0331 li\u0331th n\u00e4mb\u00e4ri\u0331 ti\u0331 r\u025blr\u0254\u0331. K\u025b kui\u0331 k\u00e4 tin ca g\u0254\u0331r r\u025by li\u0331th\u00e4, la\u0331t b\u025b r\u025blr\u0254\u0331 \u025b la i\u0331thku\u025br du\u014b intejeri\u0331 mi\u0331 ci\u0331 indi\u0331dh\u025bth \u025b mi\u0331 \u014buan k\u00e4 3 k\u025bn\u025b \u0263\u00f6\u00f6 b\u025b cubi\u0331 la\u0331t intejeri\u0331 mi\u0331 ci\u0331 indi\u0331dh\u025bth \u025b mi\u0331 \u014buan k\u00e4 4 k\u00e4 \/ci\u0331 m\u0254 a mi\u0331 \u014buan k\u00e4 3. \/Ci\u0331 la\u0331t bi\u0331 r\u025blr\u0254\u0331 \u025b la i\u0331thku\u025br r\u025by li\u0331th\u00e4 min ci\u0331 indi\u0331dh\u025bthk\u025b \u025b mi\u0331 \u014buan k\u00e4 3 ki\u025b 4. La\u0331t b\u025b cu locni\u0331 matdi\u025bn diaal k\u00e4 i\u0331thku\u025br. C\u00e4\u00e4tni\u0331: k\u025b kui lst = [1,2,3] bi\u0331 min ca n\u00f6\u00f6\u014b ba 6 k\u025b kui lst = [] min ca\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Mi ca ji moc ri\u0331i\u0331t mi nyoth th\u00ebm, ri\u0331i\u0331t \u025bm\u0254 te rieet ti\u0331 g\u00f6\u00f6l thi\u0331n ti\u0331 caa da\u0331a\u0331k k\u025b kam, k\u00e4 bi\u0331 ji\u0331n ri\u0331i\u0331t mi\u0331 te rieet tin te r\u025by ri\u0331i\u0331tni\u0331 min nhiam, mi\u0331 ci\u0331 pekdi\u025bn \u025b n\u00e4mb\u00e4ri\u0331 tin te piny, bi\u0331 ri\u0331i\u0331t rieetni\u0331 r\u025by ri\u0331i\u0331tni\u0331 min pay ben \u025b mi\u0331 c\u00e4\u00e4t k\u025b min nhiam. C\u00e4\u00e4t1: Input: sentence = \"This is a test\" Output: \"is\" C\u00e4\u00e4t2: Input: sentence = \"let go for swimming\" Output: \"go for\" Constraints: * 1 <= len(sentence) <= 100 * sentence contains only letters\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"La\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 la\u0331t mi\u0331 bi\u0331 du\u0254\u0331\u0254\u0331r jak\u00e4 kuiy k\u00e4 ba cu loc \u025b la thu\u0254\u0331k mi\u0331 \u025b x * n \u025b mi\u0331 ca pekd\u025b \u014ba\u0331c k\u00e4 \u025b mi\u0331 \/ci\u0331 m\u0254 a thu\u0254\u0331k. K\u025bn x k\u025bn\u025b n, k\u025b k\u025bn nyin th\u00e4rkcin du\u014b pi\u0331r\u025bkcin, k\u00e4 tek\u025b k\u025b\u025b ta\u0331a\u0331 in ba lat \u025b la, <numer\u025bt\u0254r>\/<denomin\u025bt\u0254r> gua\u0331th in bi\u0331 n\u00e4mer\u025bt\u0254r k\u025bn\u025b denomin\u025bt\u0254r k\u025bn tek\u025b pu\u0254\u0331thi\u0331jtib intejeri\u0331. Ji\u0331n deri\u0331 j\u025b na\u014b i\u0331 x, k\u025bn\u025b n k\u025b pi\u0331r\u025bkcin ti\u0331 la thu\u0254\u0331\u0254\u0331k, k\u025bn\u025b \u0263\u00f6\u00f6 \/ci\u0331k\u025b dh\u025br\u00f6 bi\u0331 pa\u0331a\u0331r \u025b la denomin\u025bt\u0254r. thi\u0331pli\u0331pi\u0331la\u0331th ((\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    G\u0254\u0331r la\u0331t mi\u0331 bi\u0331 ku l\u025b w\u0254\u0331 raar k\u00e4 int\u025brj\u025brni\u0331 k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 w\u00e4 nhial k\u025b du\u0254\u0331\u0254\u0331p in ci\u0331 di\u0331jitki\u025bn r\u0254\u0331 mat thi\u0331n.\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"G\u0254\u0331r la\u0331t mi\u0331 na\u014bk\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan k\u00e4 ba loc ni\u0331 n\u00e4mb\u00e4ri\u0331 tin te r\u025by n\u00e4mb\u00e4ri\u0331 tin di\u0331t ni\u0331 k\u00e4 10 k\u025bn\u025b \u0263\u00f6\u00f6 \u025bn di\u0331jit in nhiam k\u025bn\u025b min j\u0254ak k\u00e4 n\u00e4mb\u00e4r \u025b mi\u0331 \/ci\u0331 m\u0254 a k\u025bl (1, 3, 5, 7, 9). C\u00e4\u00e4td\u025b: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Mi\u0331 ca ji\u0331 ka\u0331m n\u00e4mb\u00e4r mi\u0331 lot r\u0254 k\u00e4 n, bi\u0331 ji\u0331n \u025b go\u0331r \u025bn \u0263\u00f6\u00f6 bi\u0331 n\u00e4mb\u00e4r in ca mat k\u00e4 b\u00e4r k\u00e4 n. K\u00e4 i\u0331thpeththi\u0331n i\u0331thpeththi\u0331n mi\u0331 tek\u025b i\u0331thpeththi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331thpethi\u0331n i\u0331th\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"G\u0254\u0331r la\u0331t mi\u0331 bi\u0331 r\u0254 lot k\u025b li\u0331th ti\u0331 \u014buan ti\u0331 ci\u0331 r\u0254\u0331 mat k\u025b \u0263\u00f6\u00f6 bi\u0331 k\u025b j\u0254\u0254c, bi\u0331 k\u025b j\u00e4k k\u00e4 tin ci\u0331 r\u0254\u0331 mat k\u025b j\u00e4kdi\u025bn, k\u00e4 bi\u0331 j\u00e4kdi\u025bn j\u0254\u0254c k\u025b du\u0254\u0331\u0254\u0331p mi\u0331 ca riali\u0331k\u00e4. K\u00e4 j\u00e4kdi\u025bn \u025b mi\u0331 la\u0331tk\u025b ni\u0331 j\u00e4kni\u0331 ti\u0331 \u014buan, k\u00e4 \/ci\u0331 j\u00e4kni\u0331 n\u00e4mb\u00e4ri\u0331, k\u00e4 d\u0254\u0331\u014b der\u025b tek\u025b ti\u0331 c\u00e4\u00e4t k\u025b j\u00e4kni\u0331 ti\u0331 k\u0254\u0331ki\u025bn. K\u00e4 j\u00e4kni\u0331 li\u0331th\u00e4 bi\u0331 k\u025b r\u0254\u0331 re\u0331p k\u025b j\u00e4kni\u0331 j\u00e4kni\u0331 rieetni\u0331, k\u00e4 bi\u0331 j\u00e4kni\u0331 j\u00e4kni\u0331 j\u00e4kni\u0331 j\u00e4kni\u0331 j\u00e4kni\u0331 j\u00e4kni\u0331 j\u00e4kni\u0331. Mi\u0331 ci\u0331 rieet da\u0331\u014b\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"P\u00f6ri\u0331gram mi\u0331 thi\u0331a\u0331k mi\u0331 bi\u0331 lu\u0254\u0331c ni\u0331 min la x mi\u0331 n \u025b praam n\u00e4mb\u00e4r k\u00e4 bi\u0331 lu\u0254\u0331c ni\u0331 min la y mi\u0331 d\u0254\u0331\u014b. C\u00e4\u00e4tni\u0331: k\u025b x_or_y ((7, 34, 12) == 34 k\u025b x_or_y ((15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Mi\u0331 ci\u0331 ram k\u025bl k\u00e4 ji\u0331 \u014bieec\u00e4 j\u025b i\u0331 c\u025b \u014b\u00e4ci\u0331 min ci\u0331 tu\u0254\u0254k k\u00e4 min ci\u0331 tu\u0254\u0254k k\u025b gua\u0331a\u0331th mi\u0331 b\u00e4\u00e4r, j\u025bn b\u025b te r\u025by c\u00e4r\u00e4du k\u025bn\u025b min ca car k\u025b j\u025bn gua\u0331a\u0331th \u025bm\u0254. Min bi\u0331 la\u0331tdu \u025b \u0263\u00f6\u00f6 bi\u0331 ji\u0331 \u014ba\u0331c mi\u0331 ci\u0331 ram k\u025bl \u014b\u00e4ci\u0331 min ci\u0331 tu\u0254\u0254k k\u00e4 min ci\u0331 tu\u0254\u0254k k\u00e4 min ci\u0331 tu\u0254\u0254k. Ji\u0331n ca ji\u0331 moc matd\u00e4 r\u025bw ti\u0331 p\u00e4\u00e4r b\u00e4\u00e4r k\u00e4 bi\u0331 k\u025b \u014b\u00e4ci\u0331 min ci\u0331 tu\u0254\u0254k k\u00e4 min ci\u0331 tu\u0254\u0254k, gua\u0331th in bi\u0331 index \u025b nyoth \u025b mat. L\u0254\u0331kni\u0331 matd\u00e4 mi\u0331 p\u00e4\u00e4r b\u00e4\u00e4r mi\u0331 nyooth pek in ci\u0331 w\u00e4 k\u025b \u014b\u00e4ci\u0331. Mi\u0331 ci\u0331 k\u025bn \u014b\u00e4ci\u0331 min ca lar \u025b thu\u0254\u0331k, bi\u0331 pekd\u025b a\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Ba ji\u0331 ka\u0331m ci\u00f6t ki\u0331l\u025bth\u00e4 (th\u025brk) k\u025bn\u025b li\u0331th du\u014b k\u00e4 tin ca r\u0254\u0331 rep. K\u00e4 tin ca r\u0254\u0331 rep ba k\u025b la\u0331th k\u025b \u0263\u00f6\u00f6 ba ki\u0331l\u025bthni\u0331 tin k\u0254\u0331\u014b rep k\u025b k\u025b. K\u00e4 bumni\u0331 ki\u0331l\u025bth\u00e4 \u025b mi\u0331 cie min ba lat: Mi\u0331 ca CAP bi\u0331 la n\u00e4mb\u00e4r k\u00e4 ci\u0331\u00f6t in di\u0331t k\u00e4 ci\u0331\u00f6t in di\u0331i\u0331t, k\u00e4 mi\u0331 ca SM bi\u0331 la n\u00e4mb\u00e4r k\u00e4 ci\u0331\u00f6t in t\u0254t k\u00e4 ci\u0331\u00f6t in di\u0331i\u0331t, k\u00e4 bumni\u0331 ki\u0331l\u025bth\u00e4 ba \u014bun \u025b CAP - SM. Ji\u0331n bi\u0331 yi\u0331k ji\u0331ek k\u00e4 min di\u0331t k\u00e4 di\u0331t k\u00e4 bi\u0331 ben k\u00e4 th\u025brk r\u025by pu\u0254rm\u025bt \u025bm\u025b: ClassName.StrongestExtensionName. Mi\u0331 t\u00eb\u00eb k\u025b\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Ji\u0331n ba ji\u0331 ka\u0331m rie\u0331t da\u0331\u014b r\u025bw. Ji\u0331n bi\u0331 yi\u0331k loc ni\u0331 thu\u0254\u0331k mi\u0331 ci\u0331 riet in r\u025bwd\u025b ki\u025b min ca loc \u025b la mi\u0331 te r\u025by rie\u0331t in nhiam. cycpattern_check{\"abcd\",\"abd\") => False cycpattern_check{\"hello\",\"ell\") => True cycpattern_check{\"whassup\",\"psus\") => False cycpattern_check{\"abab\",\"baa\") => True cycpattern_check{\"efef\",\"eeff\") => False cycpattern_check{\"hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Mi\u0331 ca \u014bun \u025b la intejer, b\u025b tuple mi\u0331 tek\u025b n\u00e4mb\u00e4r mi\u0331 p\u00e4\u00e4r k\u025bn\u025b \u0263\u00f6\u00f6 \/ci\u0331k\u025b bi\u0331 pa\u0331a\u0331r loc. C\u00e4\u00e4t: even_odd_count ((-12) ==> (1, 1) even_odd_count ((123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Mi ca pek mi lot r\u0254 moc, bi pek in lot r\u0254 k\u00e4 Roman numerals \u025b ny\u0254k k\u025b loc k\u00e4 min t\u0254t.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"G\u0254\u0331r ni\u0331 pa\u0331\u014bciin mi\u0331 bi\u0331 r\u0254 lot k\u025b li\u0331th ti\u0331 \u014buan ti\u0331 g\u00f6\u00f6l. K\u00e4 li\u0331th b\u025b tek\u025b rie\u0331t ti\u0331 g\u00f6\u00f6l. L\u0254\u0331k riet mi\u0331 tek\u025b n\u00e4mb\u00e4r mi\u0331 di\u0331i\u0331t \u025bl\u0254\u0331\u014b k\u00e4 bi\u0331 tek\u025b karakterni\u0331 ti\u0331 g\u00f6\u00f6l. Mi\u0331 ca kark\u025btni\u0331 ti\u0331 \u014buan ti\u0331 g\u00f6\u00f6l ti\u0331 g\u00f6\u00f6l ti\u0331 g\u00f6\u00f6l, l\u0254\u0331kni\u0331 k\u025bl mi\u0331 bi\u0331 ben k\u025b nhiam r\u025by leksik\u0254grapi\u0331kal \u0263\u0254\u0331ndi\u025bn.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Ji\u0331n \u025b ji\u0331n la\u0331a\u0331t mi\u0331 ci\u0331 bu\u0254th \u025b n\u00e4k, k\u00e4 ci\u0331 mi\u0331th ti\u0331 \u014buan cam, du\u014bd\u025b \u0263\u00f6\u00f6 \u025bn t\u00e4\u00e4m\u025b go\u0331o\u0331ri\u0331 \u0263\u00f6\u00f6 bi\u0331 mi\u0331th ti\u0331 \u014buan cam k\u025b \u0263\u00f6\u00f6 bi\u0331 mi\u0331th ca\u0331\u014b \u025bm\u0254 kul\u025b thu\u0254\u0331k. Ji\u0331n bi\u0331 yi\u0331k loc ni\u0331 matd\u00e4 mi\u0331 ce\u0331tk\u025b [ pek in ci\u0331 cam k\u025b k\u0254r mi\u0331eth, pek in ci\u0331 cam k\u025b k\u0254r mi\u0331eth ] mi\u0331 \/thi\u025bl\u025b mi\u0331 ro\u0331\u014b k\u025b kar\u0254n ti\u0331 ci\u0331 du\u0254th, bi\u0331 ji\u0331n kar\u0254n diaal tin ci\u0331 du\u0254th cam, du\u014bd\u025b \u0263\u00f6\u00f6 bi\u0331 bu\u0254th \u014bot thi\u0331n. C\u00e4\u00e4t: * cam ((5, 6, 10) -> [11, 4] * cam ((4, 8, 9) -> [12, 1] * cam ((1, 10, 10) -> [11, 0] * cam ((2, 11, 5) ->\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    K\u00e4 li\u0331th in nhiam tek\u025b alj\u025bbri\u0331 min la la\u0331tk\u025b, k\u00e4 li\u0331th in r\u025bwd\u025b \u025b li\u0331th n\u00e4mb\u00e4ri\u0331 tin thu\u0254\u0331\u0254\u0331k. La\u0331t k\u025b li\u0331thni\u0331 r\u025bw tin ca \u014bun k\u025b \u0263\u00f6\u00f6 ba alj\u025bbri\u0331 mi\u0331 ca \u014bun kul\u025b la\u0331t k\u025bn\u025b \u0263\u00f6\u00f6 ba min ca \u014bun kul\u025b lu\u0254\u0331c. K\u00e4 li\u0331thni\u0331 r\u025bw tin ca \u014bun: matk\u025b (+) locni\u0331 (-)) locni\u0331 (*) piny (di\u0331bi\u0331cin) k\u00e4 d\u00e4\u00e4k (**) k\u025b \u0263\u00f6\u00f6 bi\u0331 k\u025b r\u0254\u0331 cu na\u014b \u025b la: operator['+', '*', '-'] matrix = [2, 3, 4, 5] min bi\u0331 ben raar = 2 + 3 * 4 - 5 => min bi\u0331 ben raar = 9 Note: K\u00e4 b\u00e4r li\u0331th\u00e4 du\u014b oper\u025br\u00e4 p\u00e4\u00e4r\u025b k\u025b b\u00e4r li\u0331th\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Mi\u0331 ca ji\u0331 ka\u0331m string s. mi\u0331 \u025b s[i] \u025b letter, loc j\u025b k\u00e4 piny \u025b w\u00e4 nhial ki\u025b vice versa, mi\u0331 \/ci\u0331 m\u0254 \u025b j\u025bn, bi\u0331 k\u025b \u014bot k\u025b mi\u0331 cie j\u025bn. Mi\u0331 thi\u025bl\u025b k\u025b war\u025bgakni\u0331 thi\u0331n, loc string. La\u0331t bi\u0331 cu n\u00f6\u00f6\u014bni\u0331 string mi\u0331 ci\u0331 ben raar. C\u00e4\u00e4tni\u0331 locni\u0331 (((\"1234\") = \"4321\" locni\u0331 ((\"ab\") = \"AB\" locni\u0331 ((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Mi ca th\u00e4rkd\u025b 'thekth' \u014bun, locni j\u025b k\u00e4 md5 mi\u0331 p\u00e4\u00e4r k\u025b j\u025b. Mi\u0331 'thekth' \u025b mi\u0331 thi\u025bl lu\u0254t, locni\u0331 Noth\u025bn.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Mi ca \u014bun \u025b la mi\u0331 tek\u025b n\u00e4mb\u00e4ri\u0331 ti\u0331 \u014buan a k\u025bn\u025b b, locni\u0331 n\u00e4mb\u00e4ri\u0331 ti\u0331 te kam a k\u025bn\u025b b, k\u025b \u0263\u00f6\u00f6 bi\u0331 k\u025b r\u0254\u0331 rep. C\u00e4\u00e4t: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]