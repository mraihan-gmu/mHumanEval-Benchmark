task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,tha_Thai,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""ตรวจสอบว่าในรายการจํานวนที่ให้ไว้ มีจํานวนใด ๆ ที่ใกล้เคียงกันมากกว่าขอบที่ให้ไว้ ตัวอย่าง: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,tha_Thai,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""การเข้าของฟังก์ชันนี้คือ สตริงที่มีกลุ่มหลายกลุ่มของลูกกรงกิ่งที่อยู่ในรัง คุณตั้งเป้าที่จะแยกกลุ่มเหล่านั้นออกเป็นสตริงที่แยกกันและคืนรายการของกลุ่มเหล่านั้น กลุ่มที่แยกกันมีสมดุล (แต่ละลูกกรงกิ่งที่เปิดถูกปิดอย่างถูกต้อง) และไม่อยู่ในรังในตัวอื่นๆ ละเลยช่องว่างใด ๆ ในสตริงการเข้า ตัวอย่าง: >>> separate_paren_groups' ((( ) (() (( ) ) ) ) ) ' ' ' ' (') ', ' (') ', ' (') '""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,tha_Thai,python,"

def truncate_number(number: float) -> float:
    """"""ให้จํานวนจุดลอยบวก, มันสามารถแยกออกเป็น ส่วนทั้งตัว (จํานวนทั้งตัวที่ใหญ่ที่สุดน้อยกว่าจํานวนที่ให้) และส่วนทศนิยม (ส่วนที่เหลือเสมอน้อยกว่า 1) ยกคืนส่วนทศนิยมของจํานวน ตัวอย่าง: >>> truncate_number ((3.5) 0.5 """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,tha_Thai,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""คุณได้รับรายการการฝากและถอนเงินในบัญชีธนาคารที่เริ่มต้นด้วยสมดุลศูนย์. งานของคุณคือการตรวจจับว่าในจุดใดที่สมดุลบัญชีลดลงต่ํากว่าศูนย์ และในจุดนั้นฟังก์ชันควรคืน True. ถ้าไม่ควรคืน False. ตัวอย่าง: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,tha_Thai,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""สําหรับรายการข้อมูลข้อมูลที่ได้รับมา, คํานวณ Mean Absolute Deviation ราวๆค่าเฉลี่ยของชุดข้อมูลนี้ Mean Absolute Deviation คือค่าเฉลี่ยของความแตกต่างเฉลี่ยระหว่างแต่ละองค์ประกอบกับจุดศูนย์กลาง (ค่าเฉลี่ยในกรณีนี้): MAD = average. x - x_mean. ตัวอย่าง: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,tha_Thai,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""เพิ่มเลข ""ขอบเขต"" ระหว่างแต่ละ 2 ตัวประกอบติดต่อกันของรายการข้อมูลเข้า `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,tha_Thai,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""การเข้าของฟังก์ชันนี้คือ สตริงที่แสดงเป็นกลุ่มหลายกลุ่มสําหรับลูกเกสรที่วางกองกัน โดยแยกด้วยช่องว่าง สําหรับกลุ่มแต่ละกลุ่ม ออกระดับที่ลึกที่สุดของลูกเกสร เช่น (() (()) มีระดับการวางกองสูงสุด 2 ระดับ ในขณะที่ ((())) มี 3 ระดับ >>> parse_nested_parens('((()) ((())) () (((()) (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,tha_Thai,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""การกรองรายการการเข้าของสายพันธุ์สําหรับที่บรรจุสายพันธุ์รองที่ได้รับการให้ >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,tha_Thai,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""สําหรับรายการจํานวนเต็มที่ให้มา ให้ค่า tuple ประกอบด้วยผลบวกและผลคูณของจํานวนเต็มทั้งหมดในรายการ ผลบวกว่างควรเท่ากับ 0 และผลคูณว่างควรเท่ากับ 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,tha_Thai,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""จากรายการจํานวนเต็มที่ให้ไว้, สร้างรายการขององค์ประกอบสูงสุดที่พบจนถึงช่วงเวลาที่ให้มาในลําดับ. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,tha_Thai,python,"

def is_palindrome(string: str) -> bool:
    """"""ค้นหา palindrome ที่สั้นที่สุดที่เริ่มด้วย string ที่ได้รับการจัดหา แนวคิดของอัลกอริทึมง่าย: - ค้นหา postfix ที่ยาวที่สุดของ string ที่ได้รับการจัดหาที่เป็น palindrome. - เพิ่มที่ปลายของ string reverse ของ string prefix ที่มาก่อนที่สับปะ palindromic. >>> make_palindrome('') '' >>> make_palindrome('cat') 'catac' >>> make_palindrome('catac') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""ทดสอบว่า string เป็นพาลินโดรมหรือไม่""""""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,tha_Thai,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""การเข้าคือสองสาย a และ b ซึ่งประกอบด้วย 1 และ 0 เท่านั้น ทําการ XOR ไบนารีกับสายเหล่านี้ และคืนผลเป็นสายด้วย. >>> string_xor (('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,tha_Thai,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""จากรายการของสายการเขียน ให้คืนสายที่ยาวที่สุด กลับสายแรกในกรณีที่มีสายการเขียนหลายสายความยาวเดียวกัน กลับไม่มีในกรณีที่รายการข้อมูลเข้าว่าง >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,tha_Thai,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""คืนค่าส่วนร่วมที่ใหญ่ที่สุดของจํานวนเต็ม a และ b >>> greatest_common_divisor ((3, 5) 1 >>> greatest_common_divisor ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,tha_Thai,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""รายการคืนของตัวอักษรทั้งหมดจากตัวอักษรที่สั้นที่สุดไปยังตัวอักษรที่ยาวที่สุดของสายข้อมูล >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,tha_Thai,python,"

def string_sequence(n: int) -> str:
    """"""คืนสายที่มีตัวเลขที่จํากัดด้วยพื้นที่ เริ่มจาก 0 ถึง n รวมกัน. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,tha_Thai,python,"

def count_distinct_characters(string: str) -> int:
    """"""ให้ string, หาว่ามีตัวอักษรแตกต่างกันกี่ตัว (ไม่ว่าจะเป็นตัวเอก) ที่ประกอบด้วย >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,tha_Thai,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""การเข้าสู่ฟังก์ชันนี้คือสายที่แสดงตัวอักษรดนตรีในรูปแบบ ASCII ที่พิเศษ การทํางานของคุณคือการวิเคราะห์รายการสายของจํานวนเต็มที่ตรงกับหลายจังหวะ ทําที่นี่เป็นตํานาน: 'o' โน้ต, ล่าสุดตีสี่ 'o' จอ' - ครึ่งโน้ต, ล่าสุดสองตี' จอ' - quater โน้ต, ล่าสุดตีหนึ่ง >>> parse_music. 'o' จอ' . o' จอ' o' จอ' .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,tha_Thai,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""หาว่าจํานวนครั้งที่ซับสตริงใด ๆ สามารถพบได้ในสตริงเดิม นับกรณีซ้อนกัน >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,tha_Thai,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""การเข้าคือ สตริงที่มีการจํากัดพื้นที่ของตัวเลขจาก 'ศูนย์' ถึง 'เก้า' ตัวเลือกที่ใช้ได้คือ 'ศูนย์', 'หนึ่ง', 'สอง', 'สาม', 'สี่', 'ห้า', 'หก', 'เจ็ด', 'แปด' และ 'เก้า' ส่งคืน สตริงที่มีตัวเลขเรียงจากตัวเล็กที่สุดไปยังตัวใหญ่ที่สุด >>> sort_numbers (('สาม หนึ่ง ห้า') 'หนึ่ง สาม ห้า' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,tha_Thai,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""จากรายการจํานวนที่ได้รับ (ความยาวอย่างน้อย 2 ตัว) เลือกและคืน 2 ตัวที่ใกล้กันที่สุด และคืนตามลําดับ (ตัวเลขเล็กกว่าตัวเลขใหญ่) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,tha_Thai,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""ให้รายการของตัวเลข (ของอย่างน้อย 2 องค์ประกอบ) ใช้การแปลงเชิงเส้นกับรายการนั้น เช่น ตัวเลขที่เล็กที่สุดจะกลายเป็น 0 และตัวเลขที่ใหญ่ที่สุดจะกลายเป็น 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,tha_Thai,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""การกรองรายการของค่าพีธอนใด ๆ สําหรับจํานวนเต็มเท่านั้น >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,tha_Thai,python,"

def strlen(string: str) -> int:
    """"""ความยาวของการคืนของ string >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,tha_Thai,python,"

def largest_divisor(n: int) -> int:
    """"""สําหรับจํานวน n ให้แล้วหาจํานวนที่ใหญ่ที่สุดที่หาร n ได้เท่ากัน, เล็กกว่า n >>> ใหญ่ที่สุด_ผู้หาร ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,tha_Thai,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""คืนรายการของตัวประกอบหลักของจํานวนเต็มที่ให้มาตามลําดับจากตัวเล็กที่สุดไปยังตัวใหญ่ที่สุด. ตัวประกอบแต่ละตัวควรถูกรายชื่อจํานวนครั้งที่ตรงกับจํานวนครั้งที่มันปรากฏในการแยกตัวประกอบ. ตัวเลขทางเข้าควรเท่ากับผลคูณของตัวประกอบทั้งหมด >>> factorise(8) [2, 2, 2] >>> factorise(25) [5, 5] >>> factorise(70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,tha_Thai,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""จากรายการของจํานวนเต็ม ลบองค์ประกอบทั้งหมดที่เกิดขึ้นมากกว่าครั้งหนึ่ง ใส่ลําดับขององค์ประกอบที่เหลือเหมือนในข้อมูลเข้า >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,tha_Thai,python,"

def flip_case(string: str) -> str:
    """"""สําหรับสตริงที่ให้การ, เปลี่ยนตัวอักษรตัวเล็กเป็นตัวใหญ่ และตัวใหญ่เป็นตัวเล็ก. >>> flip_case ((('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,tha_Thai,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""การต่อสายเป็นสายเดียว >>> การต่อสาย (([]) '' >>> การต่อสาย ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,tha_Thai,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""การกรองรายการการเข้าของสายเสียงสําหรับที่เริ่มต้นด้วยตัวอักษรที่กําหนดไว้เท่านั้น. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,tha_Thai,python,"

def get_positive(l: list):
    """"""คืนจํานวนบวกในรายการเท่านั้น. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,tha_Thai,python,"

def is_prime(n):
    """"""คืน true หากจํานวนที่ให้ไว้เป็นจํานวนหลัก และ false หากไม่ >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,tha_Thai,python,"import math


def poly(xs: list, x: float):
    """"""xs คือสัมประสิทธิ์ของพหุนาม find_zero find x เช่น poly(x) = 0. find_zero คืนเพียงแค่จุดศูนย์เท่านั้น แม้จะมีหลายจุด นอกจากนี้ find_zero ยังใช้รายการ xs ที่มีสัมประสิทธิ์จํานวนเท่าและสัมประสิทธิ์ที่ไม่เท่ากับศูนย์ที่ใหญ่ที่สุดเท่านั้น เพราะมันรับประกันคําตอบ >>> round ((find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 1.0 """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""ประเมินพหุนามที่มีสัมประสิทธิ์ xs ที่จุด x. คืน xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,tha_Thai,python,"

def sort_third(l: list):
    """"""ฟังก์ชันนี้ใช้รายการ l และคืนรายการ l' แบบที่ l' เป็นตัวเดียวกันกับ l ในอัณฑ์ที่ไม่หารด้วยสาม ขณะที่ค่าของมันที่อัณฑ์ที่หารด้วยสาม เท่ากับค่าของอัณฑ์ที่ตรงกันของ l แต่จัดเรียง. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,tha_Thai,python,"

def unique(l: list):
    """"""คืนรายการที่จัดเรียงมาเป็นเอกลักษณ์ในรายการ >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,tha_Thai,python,"

def max_element(l: list):
    """"""คืนค่าธาตุสูงสุดในรายการ. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,tha_Thai,python,"

def fizz_buzz(n: int):
    """"""คืนจํานวนครั้งที่หลัก 7 ปรากฏในจํานวนเต็มน้อยกว่า n ที่หารด้วย 11 หรือ 13 >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,tha_Thai,python,"

def sort_even(l: list):
    """"""ฟังก์ชันนี้ใช้รายการ l และคืนรายการ l' แบบที่ l' เป็นเหมือนกันกับ l ในอัตราตัวเลขคราด ขณะที่ค่าของมันที่อัตราตัวเลขคู่ เท่ากับค่าของอัตราตัวเลขคู่ของ l แต่จัดเรียง. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,tha_Thai,python,"

def encode_cyclic(s: str):
    """"""รับเป็น string ที่เข้าเข้าแบบโค้ดด้วยฟังก์ชัน encode_cyclic คืน string ที่ถอดรหัส""""""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""คืน string ที่เข้ารหัสโดยกลุ่มรอบของสามตัวอักษร""""""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,tha_Thai,python,"

def prime_fib(n: int):
    """"""prime_fib คืนเลขที่ n ที่เป็นเลขฟิโบนาคซี่ และยังเป็นจํานวนหลัก. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,tha_Thai,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero ใช้รายการของจํานวนเต็มเป็นอินพุต มันคืน True ถ้ามีองค์ประกอบที่แตกต่างกันสามอย่างในรายการที่รวมเป็นศูนย์ และ False ถ้าไม่เช่นนั้น >>> triples_sum_to_zero (([1, 3, 5, 0]) False >>> triples_sum_to_zero (([1, 3, -2, 1]) True >>> triples_sum_to_zero (([1, 2, 3, 7]) False >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero (([1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,tha_Thai,python,"

def car_race_collision(n: int):
    """"""ลองจินตนาการถนนที่ตรงตรงอย่างสมบูรณ์แบบเป็นเส้นยาวไม่สิ้นสุด. n รถกําลังขับรถไปทางซ้ายไปทางขวา; ในขณะเดียวกัน, รถที่แตกต่างกัน n รถกําลังขับรถไปทางขวาไปทางซ้าย. รถสองชุดเริ่มต้นที่ห่างไกลจากกันและกัน. รถทั้งหมดเคลื่อนที่ด้วยความเร็วเท่ากัน. สองรถบอกว่าจะชนกันเมื่อรถที่เคลื่อนไปทางซ้ายไปทางขวาชนรถที่เคลื่อนไปทางขวาไปทางซ้าย. อย่างไรก็ตาม, รถมีความแข็งแรงและแข็งแรงอย่างไม่สิ้นสุด; ผลลัพธ์คือ, พวกเขากําลังดําเนินการในเส้นทางของพวกเขาเหมือนว่าพวกเขาไม่ได้ชนกัน. ฟังก์ชันนี้ออกจํานวนของชนกันดังกล่าว.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,tha_Thai,python,"

def incr_list(l: list):
    """"""รายการคืนที่มีองค์ประกอบเพิ่มขึ้นด้วย 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,tha_Thai,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero ใช้รายการของจํานวนเต็มเป็นข้อมูลเข้า มันคืน True ถ้ามีองค์ประกอบที่แตกต่างกันในรายการที่รวมเป็น 0 และ False ถ้าไม่. >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero (([1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,tha_Thai,python,"

def change_base(x: int, base: int):
    """"""เปลี่ยนฐานเลขของตัวเลข x เป็นฐาน. คืนตัวแทนสายหลังจากการแปลง. ตัวเลขฐานน้อยกว่า 10 >>> เปลี่ยน_ฐาน(8, 3) '22' >>> เปลี่ยน_ฐาน(8, 2) '1000' >>> เปลี่ยน_ฐาน(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,tha_Thai,python,"

def triangle_area(a, h):
    """"""ความยาวด้านและพื้นที่กลับสูงสําหรับสามเหลี่ยม >>> triangle_area ((5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,tha_Thai,python,"

def fib4(n: int):
    """"""การเรียงลําดับเลข Fib4 เป็นการเรียงลําดับที่คล้ายกับการเรียงลําดับ Fibbonacci ที่ถูกกําหนดดังนี้: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). กรุณาเขียนฟังก์ชันเพื่อคํานวณองค์ประกอบที่ n ของการเรียงลําดับเลข fib4 อย่างมีประสิทธิภาพ. อย่าใช้การเรียงลําดับ. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,tha_Thai,python,"

def median(l: list):
    """"""คืนค่าเฉลี่ยของธาตุในรายการ l. >>> median (([3, 1, 2, 4, 5]) 3 >>> median (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,tha_Thai,python,"

def is_palindrome(text: str):
    """"""ตรวจสอบว่าสตริงที่ให้มาเป็นพาลินดรอม >>> is_palindrome (('') จริง >>> is_palindrome (('aba') จริง >>> is_palindrome (('aaaaa') จริง >>> is_palindrome (('zbcd') ผิด""""""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,tha_Thai,python,"

def modp(n: int, p: int):
    """"""คืน 2^n modulo p (ต้องรู้ตัวเลข) >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,tha_Thai,python,"

def encode_shift(s: str):
    """"""รับเป็น string ที่เข้าเข้าโดยใช้ฟังก์ชัน encode_shift คืน string ที่ถอดรหัส""""""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""คืน string ที่เข้ารหัส โดยการเลื่อนตัวอักษรทุกตัวด้วย 5 ในอักษร""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,tha_Thai,python,"

def remove_vowels(text):
    """"""remove_vowels เป็นฟังก์ชันที่ใช้ string และคืน string ที่ไม่มีตัวเสียง. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,tha_Thai,python,"

def below_threshold(l: list, t: int):
    """"""คืน True หากเลขทั้งหมดในรายการ l อยู่ใต้ขอบ t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,tha_Thai,python,"

def add(x: int, y: int):
    """"""บวกเลข x และ y >>> บวก ((2, 3) 5 >>> บวก ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,tha_Thai,python,"

def same_chars(s0: str, s1: str):
    """"""ตรวจสอบว่าคําสองคํามีตัวอักษรเหมือนกันหรือไม่ >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') จริง >>> same_chars (('abcd', 'dddddddabc') จริง >>> same_chars (('dddddddabc', 'abcd') จริง >>> same_chars (('eabcd', 'dddddddabc') ผิด >>> same_chars ((('abcd', 'dddddddabddce') ผิด >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') ผิด """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,tha_Thai,python,"

def fib(n: int):
    """"""คืนเลขฟิโบนาคซีที่ n. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,tha_Thai,python,"

def correct_bracketing(brackets: str):
    """"""brackets เป็นสายของ ""<"" และ "">"". return True ถ้าทุก bracket ที่เปิดมี bracket ที่ปิดที่ตรงกัน. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,tha_Thai,python,"

def monotonic(l: list):
    """"""Return True คือรายการมีองค์ประกอบที่เพิ่มขึ้นหรือลดลงอย่างเป็นประจํา >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,tha_Thai,python,"

def common(l1: list, l2: list):
    """"""คืนประเภทประเภทร่วมที่จัดเรียงมาเป็นเอกลักษณ์สําหรับสองรายการ. >>> common (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> common (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,tha_Thai,python,"

def largest_prime_factor(n: int):
    """"""คืนตัวประกอบหลักที่ใหญ่ที่สุดของ n สมมุติว่า n > 1 และไม่ใช่ตัวประกอบหลัก >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,tha_Thai,python,"

def sum_to_n(n: int):
    """"""sum_to_n เป็นฟังก์ชันที่รวมตัวเลขจาก 1 ถึง n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,tha_Thai,python,"

def correct_bracketing(brackets: str):
    """"""brackets เป็นสายของ ""("" และ "")"". return True ถ้าทุก bracket ที่เปิดมี bracket ที่ปิดที่ตรงกัน. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") True >>> correct_bracketing("")""""""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,tha_Thai,python,"

def derivative(xs: list):
    """"""xs เป็นตัวประกอบของพหุนาม xs[0] + xs[1] * x + xs[2] * x^2 + .... คืนอนุพันธ์ของพหุนามนี้ในรูปเดียวกัน. >>> derivative (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivative[(1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,tha_Thai,python,"

def fibfib(n: int):
    """"""การเรียงลําดับเลข FibFib เป็นการเรียงลําดับที่คล้ายกับการเรียงลําดับ Fibbonacci ที่ถูกกําหนดดังนี้: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3 กรุณาเขียนฟังก์ชันเพื่อคํานวณองค์ประกอบที่ n ของการเรียงลําดับเลข fibfib. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,tha_Thai,python,"
FIX = """"""เขียนฟังก์ชัน vowels_count ที่ใช้สายเสียงแทนคําเป็นอินพุต และคืนจํานวนเสียงในสายเสียง. ตัวเสียงในกรณีนี้คือ 'a', 'e', 'i', 'o', 'u'. ในที่นี้ 'y' ก็เป็นเสียง แต่เป็นเสียงในตอนท้ายของคําที่ให้ตัวอย่าง: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""เพิ่มกรณีทดลองเพิ่มเติม""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,tha_Thai,python,"
def circular_shift(x, shift):
    """"""การเคลื่อนย้ายหลักของจํานวนเต็ม x เป็นวงกลม, การเคลื่อนย้ายหลักไปทางขวาโดยการเคลื่อนย้าย และคืนผลเป็นสตริง หาก shift > จํานวนหลัก, ให้เลขกลับ. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,tha_Thai,python,"
def digitSum(s):
    """"""การเขียนฟังก์ชันที่ใช้สายคอมเป็นข้อมูลเข้า และคืนผลรวมของตัวอักษรบนเท่านั้น' รหัส ASCII ตัวอย่าง: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,tha_Thai,python,"
def fruit_distribution(s,n):
    """"""ในงานนี้ คุณจะได้รับสตริงที่แสดงจํานวนแอปเปิ้ลและส้มที่กระจายอยู่ในถังผลไม้ถังนี้มีแอปเปิ้ล, ส้ม, และผลไม้มังโกะ. ให้สตริงที่แสดงจํานวนทั้งหมดของส้มและแอปเปิ้ลและจํานวนเต็มที่แสดงจํานวนทั้งหมดของผลไม้ในถังคืนจํานวนผลไม้มังโกะในถัง. สําหรับตัวอย่าง: fruit_distribution""5(แอปเปิ้ลและ 6 ส้ม"", 19) -> 19 - 5 - 6 = 8 ผล_การกระจาย""0แอปเปิ้ลและ 1 ส้ม"",3) -> 3 - 0 - 1 = 2 ผล_การกระจาย""2แอปเปิ้ลและ 3 ส้ม"", 100) -> 100 - 2 - 3 = 95 ผล_การกระจาย""100แอปเปิ้ลและ 1 ส้ม"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,tha_Thai,python,"
def pluck(arr):
    """"""""ให้เรียงตัวแทนสาขาของต้นไม้ที่มีมุมจํานวนเต็มที่ไม่ลบ หน้าที่ของคุณคือการหยิบมุมหนึ่งและคืนมัน ถ้ามุมที่หยิบมาควรจะเป็นมุมที่มีค่าคู่ที่เล็กที่สุด ถ้าพบมุมหลายอันที่มีค่าคู่ที่เล็กที่สุดก็คืนมุมที่มีดัชนีที่เล็กที่สุด มุมที่หยิบมาควรถูกคืนในรายการ, [smallest_value, its index] ถ้าไม่มีค่าคู่หรือเรียงที่ให้มาว่างเปล่า, return []. ตัวอย่าง1: อินพุต: [4,2,3] ผลิต: [2, 1] คําอธิบาย: 2 มีค่าคู่ที่เล็กที่สุด, และ 2 มีดัชนีที่เล็กที่สุด ตัวอย่าง2: อินพุต: [1,2,3] ผลิต: [2, 1] คําอธิบาย: 2 มีค่าคู่ที่เล็กที่สุด, และ 2 มีดัชนีที่เล็กที่สุด ตัวอย่าง3: อินพุต: [] ผลิต: [] อินพุต: [4,5, 3, 4, 2] ผลิต: 1 [0, 0] ผลิต: 1 มีค่าคู่ที่เล็กที่สุด แต่มีค่าตัวเลขที่เล็กที่สุด ตัวอย่างที่สองคือศูนย์เล็กที่สุด ตัวอย่าง: * * เราเลือกมุมแรกที่มีค่าค่าเท่ากับ 0 แต่มีค่าศูนย์เล็กที่สุด ตัวอย่าง: 1 มีค่าศูนย์เล็กที่สุด""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,tha_Thai,python,"
def search(lst):
    '''คุณได้รับรายการจํานวนเต็มบวกที่ไม่ว่าง ให้จํานวนเต็มที่ใหญ่ที่สุดที่มากกว่า 0 และมีความถี่มากกว่าหรือเท่ากับค่าของจํานวนเต็มตัวนั้นเอง ความถี่ของจํานวนเต็มคือจํานวนครั้งที่มันปรากฏในรายการ ถ้าไม่มีค่าดังกล่าวอยู่, ให้คืน -1. ตัวอย่าง: ค้นหา (([4, 1, 2, 2, 3, 1]) == 2 ค้นหา ([1, 2, 2, 3, 3, 3, 4, 4]) == 3 ค้นหา ([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,tha_Thai,python,"
def strange_sort_list(lst):
    '''การจัดเรียงแบบแปลก คือการเริ่มต้นด้วยค่าต่ําสุด จากนั้นก็เลือกค่าสูงสุดของจํานวนเต็มที่เหลือ จากนั้นก็เลือกค่าต่ําสุด เป็นต้น ตัวอย่าง: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,tha_Thai,python,"
def triangle_area(a, b, c):
    '''ให้ความยาวของสามด้านของสามเหลี่ยม. คืนพื้นที่ของสามเหลี่ยมโดยประมวลผลเป็น 2 ตัวกลางนิศนาม หากสามด้านเป็นสามเหลี่ยมที่ใช้ได้. ถ้าไม่คืน -1 สามด้านสร้างสามเหลี่ยมที่ใช้ได้เมื่อผลรวมของสองด้านใด ๆ มากกว่าด้านที่สาม. ตัวอย่าง: triangle_area ((3, 4, 5) == 6.00 triangle_area ((1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,tha_Thai,python,"
def will_it_fly(q,w):
    '''เขียนฟังก์ชันที่คืน True หากวัตถุ q จะบิน และ False ถ้าไม่วัตถุ q จะบิน หากมันสมดุล (มันเป็นรายการ palindromic) และผลรวมขององค์ประกอบของมันน้อยกว่าหรือเท่ากับน้ําหนักสูงสุดที่อาจเป็นได้ w ตัวอย่าง: will_it_fly (([1, 2], 5) â -> False # 1+2 น้อยกว่าน้ําหนักสูงสุดที่อาจเป็นได้ แต่มันไม่สมดุล will_it_fly (([3, 2, 3], 1) â -> False # มันสมดุล แต่ 3+2+3 มากกว่าน้ําหนักสูงสุดที่อาจเป็นได้ will_it_fly (([3, 2, 3], 9) â -> True # 3+23 น้อยกว่าน้ําหนักสูงสุดที่อาจเป็นได้ และมันสมดุล will_it_fly ((([3], 5) â -> True # 3 น้อยกว่าน้ําหนักสูงสุดที่อาจเป็นได้ และมันสมดุล '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,tha_Thai,python,"
def smallest_change(arr):
    """"""การให้จํานวนจํานวนเต็มที่ในเรียงตัวเรียงหาจํานวนลดน้อยที่สุดขององค์ประกอบที่ต้องเปลี่ยนเพื่อให้เรียงตัวเรียงเป็นพาลินดรอม เรียงพาลินดรอมคือเรียงที่อ่านไปข้างหลังและข้างหน้าเหมือนกัน ในการเปลี่ยนแปลงครั้งเดียวคุณสามารถเปลี่ยนองค์ประกอบหนึ่งไปยังองค์ประกอบอื่น ๆ เช่น: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,tha_Thai,python,"
def total_match(lst1, lst2):
    '''เขียนฟังก์ชันที่รับสองรายการของสายและคืนรายการที่มีจํานวนทั้งหมดของตัวอักษรในทุกสายของรายการน้อยกว่ารายการอื่น ๆ หากสองรายการมีจํานวนตัวอักษรเท่ากัน ให้รายการแรกกลับ ตัวอย่าง total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['i', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['hi', 'admin'], ['i', 'hi', 'hi']) â -> ['i', 'hi', 'hi'] total_match ((['4', [''1', '2', '3', '4', '5', ['4]) -> '4' ]]'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,tha_Thai,python,"
def is_multiply_prime(a):
    """"""เขียนฟังก์ชันที่คืนค่า true หากจํานวนที่ให้คือการคูณของ 3 หลักและ false ถ้าไม่เช่นนั้น. รู้ว่า (a) น้อยกว่า 100 ตัวอย่าง: is_multiply_prime(30) == True 30 = 2 * 3 * 5 """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,tha_Thai,python,"
def is_simple_power(x, n):
    """"""งานของคุณคือเขียนฟังก์ชันที่คืนค่า true หากจํานวน x เป็นกําลังง่ายของ n และ false ในกรณีอื่นๆ. x เป็นกําลังง่ายของ n หาก n**int=x ตัวอย่าง: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,tha_Thai,python,"
def iscube(a):
    '''เขียนฟังก์ชันที่ใช้จํานวนเต็ม a และคืนค่า True หากตัวเลขนี้เป็นลูกบาศก์ของจํานวนเต็มใด ๆ. หมายเหตุ: คุณอาจสมมุติว่าข้อมูลเข้าเป็นจริงเสมอ. ตัวอย่าง: iscube ((1) ==> true iscube ((2) ==> false iscube ((-1) ==> true iscube ((64) ==> true iscube ((0) ==> true iscube ((180) ==> false '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,tha_Thai,python,"
def hex_key(num):
    """"""คุณได้รับภาระการเขียนฟังก์ชันที่รับจํานวน hexadecimal เป็น string และนับจํานวนของหลัก hexadecimal ที่เป็นตัวเลขอนุพันธ์ (ตัวเลขอนุพันธ์, หรือ prime, เป็นจํานวนธรรมชาติที่ใหญ่กว่า 1 ซึ่งไม่ใช่ผลผลผลิตของสองตัวเลขธรรมชาติที่เล็กกว่า) ตัวเลข hexadecimal คือ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ตัวเลขอนุพันธ์คือ 2, 3, 5, 7, 11, 13, 17,... ดังนั้นคุณต้องกําหนดจํานวนของหลักต่อไปนี้: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13) หมายเหตุ: คุณอาจคิดว่าการเข้าจะถูกต้องเสมอหรือว่างและ string, และสัญลักษณ์ A,B,C,D,E,F, เป็นเสมอตัวเลขใหญ่. ตัวอย่าง: สําหรับ num ""AB"" ผลิตผลิตผลิตผลิตควรจะเป็น num = 1. สําหรับ num = 1077E ผลิตผลิตผลควรจะเป็น 2. สําหรับ num ""AB"" = 331EDA ผลิตผลิตผลผลควรจะเป็น 4. ""BC"" = 6.067123DEF ""สําหรับผลิตผลิตผลควรจะเป็น 2. ""2020""""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,tha_Thai,python,"
def decimal_to_binary(decimal):
    """"""คุณจะได้รับตัวเลขในรูปแบบทศนิยม และงานของคุณคือการแปลงมันเป็นรูปแบบไบนารี ฟังก์ชันควรคืนสาย, โดยแต่ละตัวอักษรแสดงตัวเลขไบนารี แต่ละตัวอักษรในสายจะเป็น '0' หรือ '1' จะมีตัวอักษรเพิ่มเติม 'db' ในตอนต้นและตอนท้ายของสาย ตัวอักษรเพิ่มเติมจะช่วยในการจัดรูปแบบ ตัวอย่าง: decimal_to_binary ((15) #คืน ""db1111db"" decimal_to_binary32) #คืน ""db100000db""""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,tha_Thai,python,"
def is_happy(s):
    """"""คุณได้รับ string s. งานของคุณคือตรวจสอบว่า string เป็น happy หรือไม่. string เป็น happy ถ้าความยาวของ string เป็นอย่างน้อย 3 ตัว และทุก 3 ตัวอักษรติดต่อกันจะแตกต่างกัน ตัวอย่าง: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,tha_Thai,python,"
def numerical_letter_grade(grades):
    """"""เป็นสัปดาห์สุดท้ายของภาคเรียน และครูต้องให้คะแนนกับนักเรียน ครูได้ทําอัลกอริทึมของตัวเองสําหรับการให้คะแนน ปัญหาเดียวคือ เธอได้สูญเสียรหัสที่เธอใช้ในการให้คะแนน เธอได้ให้รายการ GPA สําหรับนักเรียนบางราย และคุณต้องเขียนฟังก์ชันที่สามารถออกรายการของคะแนนอักษรโดยใช้ตารางต่อไปนี้: GPA หมายเลขอักษร 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,tha_Thai,python,"
def prime_length(string):
    """"""เขียนฟังก์ชันที่ใช้สายและคืน True หากความยาวสายเป็นจํานวนหลักหรือ False หากไม่เช่นนั้น ตัวอย่าง prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,tha_Thai,python,"
def starts_one_ends(n):
    """"""ให้จํานวนเต็มบวก n, คืนจํานวนจํานวนของจํานวนเต็มบวก n-หลักที่เริ่มต้นหรือจบด้วย 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,tha_Thai,python,"
def solve(N):
    """"""ให้จํานวนเต็มบวก N, คืนผลรวมของหลักในตัวเลขไบนารี ตัวอย่าง สําหรับ N = 1000, ผลรวมของหลักจะเป็น 1 ผลิตผลควรจะเป็น ""1"". สําหรับ N = 150, ผลรวมของหลักจะเป็น 6 ผลิตผลควรจะเป็น ""110"". สําหรับ N = 147, ผลรวมของหลักจะเป็น 12 ผลิตผลควรจะเป็น ""1100"". ตัวแปร: @N จํากัดจํานวนเต็ม: 0 â‰¤ N â‰¤ 10000. ผลิตผล: สตริงของเลขไบนารี """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,tha_Thai,python,"
def add(lst):
    """"""ให้รายการจํานวนเต็มที่ไม่ว่าง lst. บวกจํานวนจํานวนคู่ที่อยู่ในอัณฑ์คราด ตัวอย่าง: บวก (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,tha_Thai,python,"
def anti_shuffle(s):
    """"""เขียนฟังก์ชันที่ใช้สายและคืนการสั่งการของมัน สายที่สั่งการของสาย, เป็นสายที่คําทั้งหมด (แยกด้วยช่องว่าง) ถูกแทนด้วยคําใหม่ที่ตัวอักษรทั้งหมดจัดเรียงลําดับขึ้นไปตามค่า ascii. หมายเหตุ: คุณควรรักษาลําดับของคําและช่องว่างในประโยค. ตัวอย่าง: anti_shuffle ((('Hi') คืน 'Hi' anti_shuffle ((('hello') คืน 'ehllo' anti_shuffle (('Hello World!!!') คืน 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,tha_Thai,python,"
def get_row(lst, x):
    """"""คุณได้รับข้อมูล 2 มิติ, เป็นรายการที่รัง, ซึ่งคล้ายกับเมทริกซ์, อย่างไรก็ตาม, ไม่เหมือนกับเมทริกซ์, แต่ละแถวอาจมีจํานวนคอลัมน์ที่แตกต่างกัน. ให้ lst, และ integer x, หาจํานวนทั้ง x ในรายการ, และคืนรายการของ tuples, [(x1, y1), (x2, y2) ...] เช่นว่าแต่ละ tuple เป็นพิกัด - (แถว, คอลัมน์), เริ่มต้นด้วย 0. เรียงพิกัดในตอนแรกโดยแถวในลําดับขึ้นไป. นอกจากนี้, เรียงพิกัดของแถวโดยคอลัมน์ในลําดับลงมา. ตัวอย่าง: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), (2, 5), (2, 0) get_((1), [] == [[แถวัด]], [1, 2, 3, 2]] [2, 3]""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,tha_Thai,python,"
def sort_array(array):
    """"""ให้เรียงของจํานวนเต็มที่ไม่ลบ, ย้อนสําเนาของเรียงที่ได้รับการจัดเรียงหลังจากการจัดเรียง, คุณจะจัดเรียงเรียงที่ได้รับการจัดเรียงในลําดับขึ้นหากผลรวม ((ค่าดัชนีแรก, ราคาดัชนีสุดท้าย) เป็นคราด, หรือจัดเรียงมันในลําดับลดลงหากผลรวม ((ค่าดัชนีแรก, ราคาดัชนีสุดท้าย) เป็นคู่. หมายเหตุ: * ไม่เปลี่ยนเรียงที่ได้รับการจัดเรียง ตัวอย่าง: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,tha_Thai,python,"
def encrypt(s):
    """"""สร้างฟังก์ชัน encrypt ที่ใช้ string เป็นอาร์กูเมนต์ และคืน string ที่ถูกเข้ารหัส โดยการหมุนตัวอักษรตัวอักษรควรถูกหมุนในลักษณะที่ตัวอักษรจะลดลงสองคูณกับสองที่ เช่น: encrypt (('hi') คืน 'lm' encrypt (('asdfghjkl') คืน 'ewhjklnop' encrypt (('gf') คืน 'kj' encrypt (('et') คืน 'ix'""""""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,tha_Thai,python,"
def next_smallest(lst):
    """"""คุณได้รับรายการของจํานวนเต็ม เขียนฟังก์ชัน next_smallest (() ที่คืนองค์ประกอบที่เล็กที่สุดที่ 2 ของรายการ กลับค่า None หากไม่มีองค์ประกอบดังกล่าว next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == ไม่มี next_smallest (([1, 1]) == ไม่มี """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,tha_Thai,python,"
def is_bored(S):
    """"""คุณจะได้รับการให้คําจํานวนหนึ่งและงานของคุณคือการนับจํานวนความเบื่อหน่าย ความเบื่อหน่ายเป็นประโยคที่เริ่มด้วยคําว่า ""I"" ประโยคถูกจํากัดด้วย '.', '?' หรือ '!'. ตัวอย่าง: >>> is_bored ((""Hello world"") 0 >>> is_bored ((""ฟ้าสีฟ้า ดวงอาทิตย์กําลังส่องแสง ฉันรักสภาพอากาศนี้"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,tha_Thai,python,"
def any_int(x, y, z):
    '''สร้างฟังก์ชันที่ใช้ 3 ตัวเลข คืน true ถ้าตัวเลขหนึ่งเท่ากับผลบวกของตัวเลขอีกสองตัว และตัวเลขทั้งหมดเป็นจํานวนเต็ม คืน false ในกรณีอื่น ๆ ตัวอย่าง any_int ((5, 2, 7) â -> True any_int ((3, 2, 2) â -> False any_int ((3, -2, 1) â -> True any_int ((3.6, -2.2, 2) â -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,tha_Thai,python,"
def encode(message):
    """"""เขียนฟังก์ชันที่รับข้อความ และโค้ดในแบบที่มันเปลี่ยนตัวอักษรทั้งหมด แทนตัวเสียงทั้งหมดในข้อความด้วยตัวอักษรที่ปรากฏ 2 อันดับก่อนตัวเสียงในอักษรอังกฤษ สมมุติว่ามีเพียงตัวอักษร ตัวอย่าง: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,tha_Thai,python,"

def skjkasdkd(lst):
    """"""คุณได้รับรายการของจํานวนเต็ม คุณจําเป็นต้องหาค่าเฉพาะที่ใหญ่ที่สุด และคืนผลรวมของหลักของมัน ตัวอย่าง: สําหรับ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ผลิตภัณฑ์ควรเป็น 10 สําหรับ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ผลิตภัณฑ์ควรเป็น 25 สําหรับ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ผลิตภัณฑ์ควรเป็น 13 สําหรับ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ผลิตภัณฑ์ควรเป็น 11 สําหรับ lst = [0,81,12,31,21] ผลิตภัณฑ์ควรเป็น 3 สําหรับ lst = [1,0,8,1,2,1,7] ผลิตภัณฑ์ควรเป็น 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,tha_Thai,python,"
def check_dict_case(dict):
    """"""การให้คําศัพท์, return True ถ้าคีย์ทั้งหมดเป็นสายในตัวเล็กหรือคีย์ทั้งหมดเป็นสายในตัวใหญ่, return False. ฟังก์ชันควรคืน False หากคําศัพท์ที่ให้ไว้ว่างเปล่า. ตัวอย่าง: check_dict_case{""a"":""apple"", ""b"":""banana""}) ควรคืน True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) ควรคืน False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) ควรคืน False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) False ควรคืน check.dict_case{""NC"":""STATE"", ""Z"":""IP""45"") }""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,tha_Thai,python,"
def count_up_to(n):
    """"""ปฏิบัติฟังก์ชันที่ใช้จํานวนเต็มที่ไม่ลบ และคืนเรียงของจํานวนเต็ม n ตัวแรกที่เป็นจํานวนหลักและน้อยกว่า n ตัวอย่าง: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,tha_Thai,python,"
def multiply(a, b):
    """"""กรอกฟังก์ชันที่ใช้จํานวนเต็มสองตัว และคืนผลคูณของหลักหน่วยของมัน สมมุติว่าข้อมูลเข้าใช้ได้เสมอ ตัวอย่าง: คูณ ((148, 412) ควรคืน 16. คูณ ((19, 28) ควรคืน 72. คูณ ((2020, 1851) ควรคืน 0. คูณ ((14,-15) ควรคืน 20. """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,tha_Thai,python,"
def count_upper(s):
    """"""ให้ string s นับจํานวนตัวเสียงตัวใหญ่ในอัคคีพาร์ ตัวอย่าง: count_upper (('aBCdEf') คืน 1 count_upper (('abcdefg') คืน 0 count_upper (('dBBE') คืน 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,tha_Thai,python,"
def closest_integer(value):
    '''สร้างฟังก์ชันที่ใช้ค่า (สตริง) ที่แสดงตัวเลข และคืนเลขเต็มที่ใกล้ที่สุด ถ้าเลขมีระยะห่างเท่ากันจากจํานวนเต็มสองตัว เลยกลมมันออกไปจากศูนย์ ตัวอย่าง >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 หมายเหตุ: การกลมออกไปจากศูนย์ หมายถึงถ้าเลขที่ให้มามีระยะห่างเท่ากันจากจํานวนเต็มสองตัว ตัวอย่างที่คุณควรคืนคือตัวเลขที่ห่างจากศูนย์ที่สุด สําหรับตัวอย่าง closest_integer "" ((14.5"") ควรคืน 15 และ closest_integer "" ((-14.5"") ควรคืน -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,tha_Thai,python,"
def make_a_pile(n):
    """"""ให้จํานวนเต็มบวก n, คุณจะต้องสร้างกองหิน n ระดับ. ระดับแรกมี n หิน. จํานวนหินในระดับต่อไปคือ: - เลขไม่เท่าตัวต่อไปถ้า n เป็นเลขไม่เท่าตัว - เลขคู่ต่อไปถ้า n เป็นเลขคู่. คืนจํานวนหินในแต่ละระดับในรายการ, โดยมีธาตุที่อินเด็กซ์ i เป็นตัวแทนจํานวนหินในระดับ (i+1). ตัวอย่าง: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,tha_Thai,python,"
def words_string(s):
    """"""คุณจะได้รับสายคําที่แยกด้วยคอมมาหรือช่องว่าง หน้าที่ของคุณคือการแยกสายคําเป็นคําและคืนเรียงของคํา ตัวอย่าง: words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,tha_Thai,python,"
def choose_num(x, y):
    """"""ฟังก์ชันนี้ใช้จํานวนบวก x และ y และคืนจํานวนเต็มคู่ที่ใหญ่ที่สุดในช่วง [x, y] รวมกัน ถ้าไม่มีจํานวนดังกล่าวแล้วฟังก์ชันควรคืน -1. ตัวอย่าง: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,tha_Thai,python,"
def rounded_avg(n, m):
    """"""คุณได้รับจํานวนเต็มบวก n และ m และงานของคุณคือคํานวณค่าเฉลี่ยของจํานวนเต็มจาก n ถึง m (รวม n และ m) รอบคําตอบเป็นจํานวนเต็มที่ใกล้ที่สุดและแปลงมันเป็นไบนารี หาก n มากกว่า m, ให้ค่า -1. ตัวอย่าง: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b1111"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,tha_Thai,python,"
def unique_digits(x):
    """"""ให้รายการของจํานวนเต็มบวก x. คืนรายการที่เรียงลําดับของทุกองค์ประกอบที่ไม่มีหลักคู่ใด ๆ. หมายเหตุ: รายการที่คืนมาควรถูกเรียงลําดับโดยเพิ่มขึ้น. ตัวอย่าง: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,tha_Thai,python,"
def by_length(arr):
    """"""ให้เรียงตัวเลขเต็ม, เรียงตัวเลขเต็มที่อยู่ระหว่าง 1 และ 9 รวมกัน, ย้อนเรียงผลลัพธ์, และต่อมาแทนแต่ละหลักด้วยชื่อที่สอดคล้องจาก ""หนึ่ง"", ""สอง"", ""สาม"", ""สี่"", ""ห้า"", ""หก"", ""เจ็ด"", ""แปด"", ""เก้า"". ตัวอย่าง: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> เรียง arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> เรียงกลับ arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""แปด"", ""สี่"", ""สาม"", ""สอง"", ""สอง"", ""หนึ่ง"", ""หนึ่ง""] ถ้าเรียงว่าง, การคืนเรียง: arr = [] return [] ถ้าเรียงมีเลขแปลกใด ๆ ละเลย: arr = [1, 1 , 55 -> arr -> [1, 1 , 55 -> arr -> [55, 1] - return ['One'] กลับ""""""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,tha_Thai,python,"
def f(n):
    """"""ปฏิบัติฟังก์ชัน f ที่ใช้ n เป็นพาราเมตร และคืนรายการขนาด n โดยให้ค่าขององค์ประกอบที่อินเด็กซ์ i เป็นตัวประกอบของ i หาก i เป็นคู่ หรือผลรวมของจํานวนจาก 1 ถึง i หากไม่. i เริ่มจาก 1. ตัวประกอบของ i คือการคูณจํานวนจาก 1 ถึง i (1 * 2 * ... * i) ตัวอย่าง: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,tha_Thai,python,"
def even_odd_palindrome(n):
    """"""ให้จํานวนเต็มบวก n, ให้ทับพลที่มีจํานวนของพาลินดรอมจํานวนเต็มคู่และพากย์ ที่อยู่ในช่วง ((1, n) รวมตัวอย่าง1: อินปุต: 3 ผลิตผล: (1, 2) คําอธิบาย: พาลินดรอมจํานวนเต็มมี 1, 2, 3 หนึ่งในนั้นเป็นพาร์ และสองในนั้นเป็นพาร์ ตัวอย่าง2: อินปุต: 12 ผลิตผล: (4, 6) คําอธิบาย: พาลินดรอมจํานวนเต็มมี 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. สี่ในนั้นเป็นพาร์ และ 6 ในนั้นเป็นพาร์ หมายเหตุ: 1. 1 <= n <= 10^3 2. ทับพลให้จํานวนของพาลินดรอมจํานวนคู่และพากย์ ตามลําดับ""""""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,tha_Thai,python,"
def count_nums(arr):
    """"""เขียนฟังก์ชัน count_nums ที่ใช้เรียงของจํานวนเต็ม และคืนจํานวนขององค์ประกอบที่มีผลรวมของหลัก > 0. ถ้าจํานวนเป็นลบ, แล้วหลักแรกที่ลงนามของมันจะเป็นลบ: เช่น -123 มีหลักลงนาม -1, 2, และ 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,tha_Thai,python,"
def move_one_ball(arr):
    """"""เรามีเรียง 'arr' ของจํานวนเต็ม N arr[1], arr[2], ..., arr[N] ตัวเลขในเรียงจะถูกเรียงตามสุ่ม หน้าที่ของคุณคือการกําหนดว่าเป็นไปได้หรือไม่ที่จะจัดเรียงเรียงในลําดับที่ไม่ลดลงโดยการดําเนินการปฏิบัติการต่อไปนี้บนเรียงที่ได้รับ: คุณได้รับอนุญาตให้ดําเนินการขวาขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางขวางข้ อมูล 0th ถ้าเป็นไปได้ที่จะได้รับเรียงเรียงโดยการดําเนินการด้านบนแล้วกลับ True หรือกลับ False ถ้าเรียงที่ได้รับจะว่างแล้วกลับ True หมายเหตุ: รายการที่ได้รับการรับประกันว่ามีองค์ประกอบที่ไม่เหมือนกัน เช่น: move_one_(ball_[3, 4, 5, 2]================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,tha_Thai,python,"
def exchange(lst1, lst2):
    """"""ในปัญหานี้คุณจะใช้ฟังก์ชันที่ใช้ 2 รายการของเลข และกําหนดว่าสามารถแลกเปลี่ยนตัวประกอบระหว่างมันได้หรือไม่ เพื่อให้ lst1 เป็นรายการของตัวเลขคู่เท่านั้น ไม่มีขั้นต่ําในการแลกเปลี่ยนตัวประกอบระหว่าง lst1 และ lst2 หากสามารถแลกเปลี่ยนตัวประกอบระหว่าง lst1 และ lst2 เพื่อให้ตัวประกอบทั้งหมดของ lst1 เป็นคู่ ให้คืน ""YES"" ไม่งั้นให้คืน ""NO"" ตัวอย่าง: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => ""YES"" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" สมมุติว่ารายการข้อมูลเข้าจะไม่ว่าง""""""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,tha_Thai,python,"
def histogram(test):
    """"""กําหนดการคัดสรรตัวอักษรเล็กแยกด้วยช่องว่าง ให้คําศัพท์ของตัวอักษรที่มีการซ้ํามากที่สุดและมีจํานวนที่ตรงกัน หากมีตัวอักษรหลายตัวมีการปรากฏเหมือนกัน ให้คําศัพท์คืนทั้งหมด ตัวอย่าง: ฮิสโตแกรม ((('a b c') == {'a': 1, 'b': 1, 'c': 1} ฮิสโตแกรม ((('a b b a') == {'a': 2, 'b': 2} ฮิสโตแกรม ((('a b c a b') == {'a': 2, 'b': 2} ฮิสโตแกรม ((('b b a') == {'b 4}': ฮิสโตแกรม (((')) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,tha_Thai,python,"
def reverse_delete(s,c):
    """"""การทํางาน เราได้รับสองสาย s และ c, คุณจะต้องลบตัวอักษรทั้งหมดใน s ที่เท่ากับตัวอักษรใด ๆ ใน c แล้วตรวจสอบว่าผลลัพธ์สายเป็น palindrome. สตริงเรียกว่า palindrome ถ้ามันอ่านเหมือนไปข้างหน้าและกลับข้างหลัง. คุณควรคืน tuple ที่มีผลลัพธ์สายและ True/False สําหรับการตรวจสอบ. ตัวอย่างสําหรับ s = ""abcde"", c = ""ae"", ผลลัพธ์ควรจะเป็น ('bcd', False) สําหรับ s = ""abcdef"", c = ""b"" ผลลัพธ์ควรจะเป็น ('acdef', False) สําหรับ s = ""abcdedcba"", c = ""ab"", ผลลัพธ์ควรจะเป็น ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,tha_Thai,python,"
def odd_count(lst):
    """"""ให้รายการของสตริง, ที่สตริงแต่ละตัวประกอบด้วยหลักเพียงตัวเลข, ให้รายการ. แต่ละองค์ประกอบ i ของผลผลิตควรจะเป็น ""จํานวนขององค์ประกอบครางในสตริง i ของการเข้า. "" ที่ i ทั้งหมดควรถูกแทนด้วยจํานวนของหลักครางในสตริง i ของการเข้า. >>> odd_count['1234567']) [""จํานวนขององค์ประกอบคราง 4n สตริง 4 ของ 4nput.""] >>> odd_count['3',""111111""]) [""จํานวนขององค์ประกอบคราง 1n สตริง 1 ของ 1nput. "", ""จํานวนองค์ประกอบคราง 8n สตริง 8 ของ 8nput. ""]""""""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,tha_Thai,python,"
def minSubArraySum(nums):
    """"""ให้เรียงของจํานวนเต็ม n, หาผลรวมขั้นต่ําของทุกการไม่ว่างของ n. ตัวอย่าง minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,tha_Thai,python,"
def max_fill(grid, capacity):
    import math
    """"""คุณได้รับกรีดสี่เหลี่ยมของบ่อน้ํา. แต่ละแถวแสดงให้เห็นถึงบ่อน้ําเดียว, และแต่ละ 1 ในแถวแสดงให้เห็นถึงหน่วยเดียวของน้ํา. แต่ละบ่อน้ํามีถังที่ตรงกันที่สามารถใช้ในการสกัดน้ําจากมัน, และถังทั้งหมดมีจุลภาพเดียวกัน. งานของคุณคือการใช้ถังที่จะว่างบ่อน้ํา. ผลิตจํานวนครั้งที่คุณต้องการที่จะลดถัง. ตัวอย่าง1: อุปกรณ์: กริด: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 ผลิต: 6 ตัวอย่าง2: อุปกรณ์: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1,1]] bucket_capacity: 2 ผลิต: 5 ตัวอย่าง3: [[:0,0,0], [0,0,0]] bucket_capacity: 5 ผลิต: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,tha_Thai,python,"
def sort_array(arr):
    """"""ในคัตานี้, คุณจะต้องเรียงเรียงเรียงของจํานวนเต็มที่ไม่ลบตามจํานวนหนึ่งในตัวแทนไบนารีของพวกเขาในลําดับเพิ่มขึ้น สําหรับจํานวนหนึ่งที่เหมือนกัน, เรียงตามค่าทศนิยม. มันต้องถูกนําไปใช้เช่นนี้: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,tha_Thai,python,"
def select_words(s, n):
    """"""ถ้า string s และ natural number n ให้คุณได้รับภาระการดําเนินการฟังก์ชันที่คืนรายการของคําทั้งหมดจาก string s ที่มีเสียงสะกดตรง n เพื่อให้คําเหล่านี้ปรากฏใน string s หาก string s ไม่มีเสียงแล้วฟังก์ชันควรคืนรายการที่ว่างไว้ ข้อสังเกต: คุณอาจสมมุติว่า string ที่ใส่มีแต่ตัวอักษรและช่องว่าง ตัวอย่าง: select_words (((""Mary had a little lamb"", 4) ==> [""little""] select_words (((""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""] select_words"" (((simple white space"", 2) ==> [] select_words (((""Hello world"", 4) ==> [""world""] select_words (((""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,tha_Thai,python,"
def get_closest_vowel(word):
    """"""คุณได้รับคําหนึ่ง. งานของคุณคือหาเสียงสัญชาติที่ใกล้ที่สุดที่อยู่ระหว่างเสียงสัญชาติสองจากด้านขวาของคํา ( case sensitive). เสียงสัญชาติในตอนต้นและตอนจบไม่ได้นับ. คืนสายว่างถ้าคุณไม่พบเสียงสัญชาติใด ๆ ที่ตรงกับเงื่อนไขข้างต้น. คุณอาจคิดว่าสายที่ให้มีเพียงตัวอักษรภาษาอังกฤษเท่านั้น. ตัวอย่าง: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,tha_Thai,python,"
def match_parens(lst):
    '''คุณได้รับรายการของสองสาย, ทั้งสองสายประกอบด้วยลูกกรงเปิด '(' หรือลูกกรงปิด ') 'เท่านั้น. งานของคุณคือการตรวจสอบว่าเป็นไปได้ที่จะผูกสายทั้งสองในลําดับใด ๆ, ที่ผลลัพธ์ของสายจะดี. สาย S ถือว่าดีถ้าและเพียงแต่ถ้าลูกกรงทั้งหมดใน S มีความสมดุล. ตัวอย่าง: สาย '((()) 'ดี, ในขณะที่สาย '()) 'ไม่. กลับ 'ใช่' ถ้ามีวิธีที่จะทําให้สายที่ดี, และกลับ 'ไม่' อย่างอื่น. ตัวอย่าง: match_parens[('() ', ') ']) == 'Yes' match_parens[(') ', ') ']) == 'No' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,tha_Thai,python,"
def maximum(arr, k):
    """"""ให้เรียงเรียงของจํานวนเต็ม arr และจํานวนเต็มบวก k, ให้รายการที่เรียงลําดับความยาว k กับจํานวน k สูงสุดใน arr. ตัวอย่าง1: อินพุต: arr = [-3, -4, 5], k = 3 ผลิต: [-4, -3, 5] ตัวอย่าง2: อินพุต: arr = [4, -4, 4], k = 2 ผลิต: [4, 4] ตัวอย่าง3: อินพุต: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 ผลิต: [2] หมายเหตุ: 1.ความยาวของเรียงจะอยู่ในช่วง [1, 1000]. 2.องค์ประกอบในเรียงจะอยู่ในช่วง [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,tha_Thai,python,"
def solution(lst):
    """"""ให้รายการจํานวนเต็มที่ไม่ว่าง, คืนผลรวมขององค์ประกอบประเภทประเภทที่อยู่ในตําแหน่งคู่ ตัวอย่างคําตอบ (([5, 8, 7, 1]) ==> 12 คําตอบ (([3, 3, 3, 3, 3]) ==> 9 คําตอบ (([30, 13, 24, 321]) ==> 0 """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,tha_Thai,python,"
def add_elements(arr, k):
    """"""ให้เรียงจํานวนเต็ม arr และจํานวนเต็ม k ที่ไม่ใช่ว่าง ให้ผลรวมขององค์ประกอบที่มีเลขสองหลักจากองค์ประกอบ k ตัวแรกของ arr ตัวอย่าง: อินพุต: arr = [111,21,3,4000,5,6,7,8,9], k = 4 ผลิต: 24 # ผลรวมของ 21 + 3 ข้อจํากัด: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,tha_Thai,python,"
def get_odd_collatz(n):
    """"""การคาดเดาของคอลลาตซ์ (Collatz conjecture) เป็นการคาดเดาในคณิตศาสตร์ที่เกี่ยวกับลําดับที่กําหนดไว้ดังนี้: เริ่มต้นด้วยจํานวนเต็มบวก n ใด ๆ แล้วแต่ละเทอมจะถูกหาจากเทอมก่อนหน้านี้ดังนี้: หากเทอมก่อนหน้าเป็นคู่, เทอมต่อไปจะเป็นครึ่งหนึ่งของเทอมก่อนหน้า หากเทอมก่อนหน้าเป็นคราวก็เป็น 3 เท่าเทอมก่อนหน้าบวก 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,tha_Thai,python,"
def valid_date(date):
    """"""คุณต้องเขียนฟังก์ชันที่ตรวจสอบความถูกต้องของเส้นประจําวันที่กําหนด และคืน True หากวันที่ถูกต้อง ไม่ถูกต้อง. วันที่ถูกต้องถ้ามีกฎทั้งหมดต่อไปนี้: 1. สายวันที่ไม่ได้ว่าง. 2. จํานวนวันไม่น้อยกว่า 1 หรือมากกว่า 31 วันสําหรับเดือน 1,3,5,7,8,10,12. และจํานวนวันไม่น้อยกว่า 1 หรือมากกว่า 30 วันสําหรับเดือน 4,6,9,11. และจํานวนวันไม่น้อยกว่า 1 หรือมากกว่า 29 สําหรับเดือน 2. 3. เดือนไม่ควรน้อยกว่า 1 หรือมากกว่า 12. 4. วันที่ควรอยู่ในรูปแบบ: mm-dd-yyyy เช่น: valid_date (('03-11-2000') => true_date (('15-01-2012') => false_date (('04-01-2040') => false_date (('06-04-2020') => true_date (('06/04/2020') => false""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,tha_Thai,python,"
def split_words(txt):
    '''ให้คําจํานวนหนึ่ง, คืนรายการคําที่แยกด้วยช่องว่าง, ถ้าไม่มีช่องว่างในข้อความ คุณควรแยกด้วยคอมมา ',' ถ้าไม่มีคอมมา คุณควรคืนจํานวนตัวอักษรเล็กๆ ด้วยลําดับไม่เหมือนกันในอัลฟาเบท, ord('a') = 0, ord'(b') = 1, ... ord('z') = 25 ตัวอย่าง split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words"")'''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,tha_Thai,python,"
def is_sorted(lst):
    '''ให้รายการของตัวเลข, คืนไม่ว่าพวกเขาจะเรียงลําดับขึ้นไป. ถ้ารายการมีมากกว่า 1 ฉบับของจํานวนเดียวกัน, คืน False. สมมุติว่าไม่มีจํานวนลบและเพียงจํานวนเต็ม. ตัวอย่าง is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) -> False is_sorted (([1, 2, 2, 3, 3, 3, 4]) -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,tha_Thai,python,"
def intersection(interval1, interval2):
    """"""คุณได้รับช่วงสองช่วง, โดยช่วงแต่ละช่วงเป็นจํานวนทั้งคู่. ตัวอย่างเช่น, ช่วง = (เริ่มต้น, จบ) = (1, 2). ช่วงที่ได้รับการปิดซึ่งหมายถึงว่าช่วง (เริ่มต้น, จบ) รวมทั้งเริ่มต้นและสิ้นสุด. สําหรับช่วงที่ได้รับการให้, มันสมมุติว่าเริ่มต้นของมันน้อยกว่าหรือเท่ากับปลายของมัน. งานของคุณคือการกําหนดว่าความยาวของตัดของสองช่วงนี้เป็นจํานวนหลัก. ตัวอย่างเช่น, การตัดของช่วง (1, 3), (2, 4) คือ (2, 3) ซึ่งความยาวของมันคือ 1, ซึ่งไม่ใช่จํานวนหลัก. ถ้าความยาวของตัดเป็นจํานวนหลัก, กลับ ""ใช่"", หรือไม่, กลับ ""ไม่"". ถ้าสองช่วงไม่ตัดกัน, กลับ ""ไม่"". [input/output] ตัวอย่าง: ช่วง(((1, 2), (2, 3) ==> ""ตัด-1,((1), 4) ==> ""ตัด"", (0, ""NO"", 5-1,((5) ==> ""ES"", (-))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,tha_Thai,python,"
def prod_signs(arr):
    """"""คุณได้รับเรียงของจํานวนเต็มและคุณต้องคืนผลรวมของขนาดของจํานวนเต็มคูณกับผลผลคูณของทุกตัวอย่างของแต่ละตัวเลขในเรียง ซึ่งแสดงด้วย 1, -1 หรือ 0 หมายเหตุ: return ไม่มีสําหรับเรียงว่าง ตัวอย่าง: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == ไม่มี""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,tha_Thai,python,"
def minPath(grid, k):
    """"""ให้กรีดที่มี N แถวและ N คอลัมน์ (N >= 2) และจํานวนเต็มบวก k, แต่ละเซลล์ของกรีดมีค่า. ทุกจํานวนเต็มในช่วง [1, N * N] รวมไปถึงปรากฏอยู่อย่างถูกต้องครั้งเดียวในเซลล์ของกรีด. คุณจะต้องหาเส้นทางขั้นต่ําความยาว k ในกรีด. คุณสามารถเริ่มจากเซลล์ใด ๆ, และในแต่ละขั้นตอนคุณสามารถย้ายไปยังเซลล์เพื่อนบ้านใด ๆ, ในคําอื่น ๆ, คุณสามารถไปยังเซลล์ที่แบ่งขอบกับเซลล์ปัจจุบันของคุณ. กรุณาสังเกตว่าเส้นทางความยาว k หมายถึงการเยี่ยมชมเซลล์อย่างถูกต้อง k (ไม่จําเป็นต้องแตกต่างกัน). คุณไม่สามารถออกจากกรีด. เส้นทาง A (ความยาว k) ถือว่าน้อยกว่าเส้นทาง B (ความยาว k) หากหลังจากทํารายการที่กําหนดของค่าบนเซลล์ที่ผ่าน A และ B (ขอเรียกมันว่า l_st และ l_Ast), l_stB กลับ, l_stA ภาษาภาษาลักษณะน้อยกว่า l_stB, ในคําอื่น ๆ, คุณสามารถเริ่มจากเซลล์ใด ๆ และในแต่ละขั้นตอนคุณสามารถย้ายไปที่เซลล์เพื่อนบ้าน, โดยวิธีอื่น ๆ คุณสามารถย้ายไปที่เซลล์ใด ๆ ที่มีขอบริ่งขอบที่เหมือนกันกับขอบด้วยขอบด้วยขอบขอบขอบ (ไม่จําเป็นต้องใช้ขอบขอบขอบขอบขอบขอบขอบขอบขอบ) กรุ้อกว่าเส้นทางความยาว k (ไม่เกิน k) คุณไม่สามารถไปนอกกรีด่านที่ตรงกับกรีด A (ไม่เกิน 1 กร่องขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบขอบข""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,tha_Thai,python,"
def tri(n):
    """"""ทุกคนรู้จักลําดับฟิโบนาคซี่ มันถูกศึกษาอย่างลึกซึ้งโดยนักคณิตศาสตร์ในสองสามศตวรรษที่ผ่านมา อย่างไรก็ตามสิ่งที่คนไม่ทราบคือลําดับทริโบนาคซี่ ลําดับทริโบนาคซี่ถูกกําหนดโดยการซ้ําซ้ํา: tri(1) = 3 tri(n) = 1 + n / 2 ถ้า n เป็นคู่. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ถ้า n เป็นคณิต. ตัวอย่าง: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 คุณได้รับจํานวนเต็มที่ไม่ลบ n, คุณจะต้องคืนรายการของจํานวนแรก n + 1 ของลําดับทริโบนาคซี่ ตัวอย่าง: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,tha_Thai,python,"
def digits(n):
    """"""ให้จํานวนเต็มบวก n, คืนผลคูณของหลักไม่เท่าตัว. คืน 0 หากหลักทั้งหมดเป็นคู่. ตัวอย่าง:หลัก(1) == 1หลัก(4) == 0หลัก(235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,tha_Thai,python,"
def is_nested(string):
    '''สร้างฟังก์ชันที่ใช้สายคูณเป็นอินพุต ซึ่งมีแค่กรอบสี่เหลี่ยม. ฟังก์ชันควรคืนค่า True ถ้าและเพียงแต่มีรุ่นย่อยของกรอบสี่เหลี่ยมที่ใช้ได้ โดยมีกรอบสี่เหลี่ยมอย่างน้อยหนึ่งในรุ่นย่อยที่ซ้อนกัน. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]]') â -> True is_nested'[[]]]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,tha_Thai,python,"

def sum_squares(lst):
    """"""คุณได้รับรายการของตัวเลข คุณจําเป็นต้องคืนผลรวมของจํานวนที่กําลังสองในรายการที่ได้รับ การรอบแต่ละองค์ประกอบในรายการไปยัง int บน ((เพดาน) ก่อน ตัวอย่าง: สําหรับ lst = [1,2,3] ผลผลิตควรจะเป็น 14 สําหรับ lst = [1,4,9] ผลผลิตควรจะเป็น 98 สําหรับ lst = [1,3,5,7] ผลผลิตควรจะเป็น 84 สําหรับ lst = [1.4,4.2,0] ผลผลิตควรจะเป็น 29 สําหรับ lst = [-2.4,1,1] ผลผลิตควรจะเป็น 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,tha_Thai,python,"
def check_if_last_char_is_a_letter(txt):
    '''สร้างฟังก์ชันที่คืน True หากตัวอักษรสุดท้ายของสตริงที่ให้การเป็นตัวอักษรอักษรและไม่ใช่ส่วนหนึ่งของคํา และ False ถ้าไม่เช่นนั้น. หมายเหตุ: ""คํา"" เป็นกลุ่มตัวอักษรที่แยกด้วยช่องว่าง ตัวอย่าง: check_if_last_char_is_a_letter ((""apple pie"") â -> False check_if_last_char_is_a_letter ((""apple pi e"") â -> True check_if_last_char_is_a_letter ((""apple pi e"") â -> False check_if_last_char_is_a_letter"" (("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,tha_Thai,python,"
def can_arrange(arr):
    """"""สร้างฟังก์ชันที่คืนดัชนีที่ใหญ่ที่สุดขององค์ประกอบที่ไม่ใหญ่หรือเท่ากับองค์ประกอบที่อยู่เบื้องหน้ามันโดยตรง หากไม่มีองค์ประกอบดังกล่าวแล้วคืน -1. แอรเรย์ที่ได้รับจะไม่มีค่าซ้ําตัวอย่าง: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,tha_Thai,python,"
def largest_smallest_integers(lst):
    '''สร้างฟังก์ชันที่คืนทับเปิ้ล (a, b), โดยที่ 'a' เป็นจํานวนเต็มลบที่ใหญ่ที่สุด, และ 'b' เป็นจํานวนเต็มบวกที่เล็กที่สุดในรายการ. หากไม่มีจํานวนเต็มบวกหรือลบ, ให้คืนเป็น None. ตัวอย่าง: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,tha_Thai,python,"
def compare_one(a, b):
    """"""สร้างฟังก์ชันที่ใช้จํานวนเต็ม, floats, หรือ string ที่แสดงตัวเลขจริง และคืนตัวแปรที่ใหญ่กว่าในตัวแปรประเภทที่กําหนดไว้ หากค่าเท่ากัน ก็คืนค่า None หมายเหตุ: หากตัวเลขจริงถูกแสดงเป็น string จุดเคลื่อนไหวอาจเป็น . หรือ , compare_one(1, 2.5) â -> 2.5 compare_one(1, ""2,3"") â -> ""2,3"" compare_one(""5,1"", ""6"") â -> ""6"" compare_one(""1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,tha_Thai,python,"
def is_equal_to_sum_even(n):
    """"""ประเมินว่าจํานวน n สามารถเขียนได้เป็นผลรวมของจํานวนคู่บวก 4 ตัวอย่าง is_equal_to_sum_even ((4) == ผิด = is_equal_to_sum_even ((6) == ผิด = is_equal_to_sum_even ((8) == จริง """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,tha_Thai,python,"
def special_factorial(n):
    """"""การนิยามตัวประกอบบราซิลคือ: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! โดย n > 0 ตัวอย่าง: >>> special_factorial ((4) 288 ฟังก์ชันนี้จะรับจํานวนเต็มเป็นอินพุต และควรคืนตัวประกอบพิเศษของจํานวนเต็มนี้""""""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,tha_Thai,python,"
def fix_spaces(text):
    """"""_ ตัวอย่างที่ 3องสายการเขียนแทนที่ช่องว่างทั้งหมดด้วยเครื่องย่อ และถ้าสายการเขียนมีช่องว่างติดต่อกันมากกว่า 2 ตัว, แทนที่ว่างติดต่อกันทั้งหมดด้วย - fix_spaces (((""ตัวอย่าง"") == ""ตัวอย่าง"" fix_spaces (((""ตัวอย่าง1"") == ""ตัวอย่าง_1"" fix_spaces (((""ตัวอย่าง2"") == ""_ตัวอย่าง_2"" fix_spaces (((""ตัวอย่าง 3"") == ""_ตัวอย่าง-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,tha_Thai,python,"
def file_name_check(file_name):
    """"""สร้างฟังก์ชันที่ใช้สตริงแทนชื่อไฟล์ และคืน 'Yes' หากชื่อไฟล์เป็นจริง และคืน 'No' หากไม่เป็นจริง ชื่อไฟล์จะถือว่าเป็นจริง หากและเพียงแต่ถ้าเงื่อนไขทั้งหมดต่อไปนี้ถูกต้อง - ไม่ควรมีมากกว่าสามหลัก ('0'-'9') ในชื่อไฟล์ - ชื่อไฟล์มีจุด '.' - สตริงรองก่อนจุดไม่ควรว่าง และเริ่มด้วยตัวอักษรจากอัลฟาเปตลาติน ('a'-'z' และ 'A'Z'). - สตริงรองหลังจากจุดควรเป็นหนึ่งในตัวอักษรเหล่านี้: ['txt', 'exe', 'lld'] ตัวอย่าง: file_name_check""(example.txt"") # => 'Yes' file_name_check""(example.dll1"") => 'No' # (ชื่อควรเริ่มด้วยตัวอัลฟาเปตลาติน)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,tha_Thai,python,"


def sum_squares(lst):
    """"""""ฟังก์ชันนี้จะใช้รายการของจํานวนเต็ม สําหรับทุกรายการในรายการนี้ฟังก์ชันจะยกกําลังสองรายการจํานวนเต็ม หากดัชนีของมันเป็นคูณของ 3 และจะยกกําลังลูกสามรายการจํานวนเต็ม หากดัชนีของมันเป็นคูณของ 4 และไม่ใช่คูณของ 3 ฟังก์ชันนี้จะไม่เปลี่ยนแปลงรายการในรายการที่มีดัชนีไม่เป็นคูณของ 3 หรือ 4 ฟังก์ชันนี้จะคืนผลรวมของรายการทั้งหมด ตัวอย่าง: สําหรับ lst = [1,2,3] ผลผลผลิตควรเป็น 6 สําหรับ lst = [] ผลผลผลิตควรเป็น 0 สําหรับ lst = [-1,-5,2,-1,-5] ผลผลิตควรเป็น -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,tha_Thai,python,"
def words_in_sentence(sentence):
    """"""คุณได้รับสายที่เป็นตัวแทนของประโยค ประโยคนั้นมีคําบางคําแยกด้วยช่องว่าง และคุณต้องคืนสายที่มีคําจากประโยคเดิม ซึ่งความยาวของมันเป็นจํานวนหลัก ลําดับคําในสายใหม่ควรเป็นเหมือนกันกับตัวเดิม ตัวอย่าง1: อินพุต: ประโยค = ""นี่คือการทดสอบ"" ผลิต: ""คือ"" ตัวอย่าง2: อินพุต: ประโยค = ""ขอไปว่ายน้ํา"" ผลิต: ""ไปสําหรับ"" ข้อจํากัด: * 1 <= len(ประโยค) <= 100 * ประโยคมีตัวอักษรเท่านั้น """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,tha_Thai,python,"
def simplify(x, n):
    """"""การทํางานของคุณคือการนําฟังก์ชันที่จะทําให้คําว่า x * n ง่ายขึ้นฟังก์ชันจะคืน True ถ้า x * n เป็นจํานวนทั้งตัว และ False ถ้าไม่อย่างนั้น ทั้ง x และ n เป็นตัวแทนของสัดส่วนและมีรูปแบบต่อไปนี้, <numerator>/<denominator> ซึ่งทั้งตัวเศษและตัวส่วนเป็นจํานวนทั้งตัวบวก คุณสามารถสมมุติว่า x, และ n เป็นเศษส่วนที่ใช้ได้ และไม่มีศูนย์เป็นตัวส่วน. simplify "" 1/5"", ""5/1"") = True simplify "" 1/6"", ""2/1"") = False simplify "" 7/10"", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,tha_Thai,python,"
def order_by_points(nums):
    """"""เขียนฟังก์ชันที่จัดลําดับรายการจํานวนเต็มตามลําดับขึ้นไปตามผลรวมของหลักของตัวเลขที่ให้ไว้. หมายเหตุ: หากมีรายการหลายรายการที่มีผลรวมของหลักที่เหมือนกัน, ให้เรียงตามดัชนีในรายการเดิม. ตัวอย่าง: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,tha_Thai,python,"
def specialFilter(nums):
    """"""เขียนฟังก์ชันที่ใช้เรียงตัวเลขเป็นอินพุต และคืนจํานวนองค์ประกอบในเรียงที่ใหญ่กว่า 10 และทั้งหลักแรกและหลักสุดท้ายของเลขเป็นเลขคี่ (1, 3, 5, 7, 9) ตัวอย่าง: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,tha_Thai,python,"
def get_max_triples(n):
    """"""คุณได้รับจํานวนเต็มบวก n. คุณต้องสร้างเรียงจํานวนเต็ม a ความยาว n. สําหรับแต่ละ i (1 ‰¤ i ‰¤ n), ค่าของ a[i] = i * i - i + 1. คืนจํานวนของ triples (a[i], a[j], a[k]) ของ a ที่ i < j < k, และ a[i] + a[j] + a[k] เป็นคูณของ 3. ตัวอย่าง: อินพุต: n = 5 ผลิต: 1 คําอธิบาย: a = [1, 3, 7, 13, 21] ค่า triples เท่านั้นคือ (1, 7, 13).""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,tha_Thai,python,"
def bf(planet1, planet2):
    '''มีดาวเคราะห์ 8 ดวงในระบบสุริยจักรของเรา ดาวเคราะห์ที่ใกล้ดวงอาทิตย์ที่สุดคือพฤกษ์ ดาวเวนัสที่ใกล้ดวงอาทิตย์ที่สุดแล้วเป็นโลก ดาวอังคาร ดาวพฤกษ์ ดาวเสาร์ ดาวอูเรนัส ดาวนพฤกษ์ เขียนฟังก์ชันที่ใช้ชื่อดาวเคราะห์ 2 ดวงเป็นสายดาวเคราะห์ 1 และดาวเคราะห์ 2 ฟังก์ชันนี้ควรคืนทับพลที่มีดาวเคราะห์ทั้งหมดที่มีวงโคจรอยู่ระหว่างวงโคจรดาวเคราะห์ 1 และวงโคจรดาวเคราะห์ 2 โดยเรียงตามความใกล้เคียงกับดวงอาทิตย์ ฟังก์ชันนี้ควรคืนทับพลที่ว่างเปล่าถ้าดาวเคราะห์ 1 หรือดาวเคราะห์ 2 ไม่ถูกต้องเป็นชื่อดาวเคราะห์ ตัวอย่าง bf""(ดาวเคราะห์"", ""ดาวเคราะห์"") ==> (""ดาวเคราะห์"") bf""(ดาวเคราะห์"", ""ดาวเคราะห์"") ==> (""ดาวเคราะห์"", ""ดาวเคราะห์"", ""ดาวเคราะห์"", ""ดาวเคราะห์"", ""ดาวเคราะห์"")'''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,tha_Thai,python,"
def sorted_list_sum(lst):
    """"""เขียนฟังก์ชันที่รับรายการของสายเป็นพาราเมทร์ ลบสายที่มีความยาวไม่เท่ากันจากมัน และคืนรายการที่ได้รับผลด้วยลําดับที่เรียงลําดับ รายการนี้เป็นรายการของสายเสมอและไม่เคยเป็นเรียงของตัวเลข และมันอาจมีซ้ํากัน การเรียงลําดับของรายการควรจะขึ้นตามความยาวของแต่ละคํา และคุณควรคืนรายการที่เรียงตามกฎนั้น ถ้าสองคํามีความยาวเท่ากัน ให้เรียงรายการเป็นลําดับอักษร ฟังก์ชันควรคืนรายการของสายในลําดับที่เรียงลําดับ คุณอาจสมมุติว่าคําทั้งหมดจะมีความยาวเท่ากัน ตัวอย่าง: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""ab"", ""cd ])""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,tha_Thai,python,"
def x_or_y(n, x, y):
    """"""โปรแกรมง่ายๆที่ควรคืนค่าของ x หาก n เป็นจํานวนหลัก และควรคืนค่าของ y หากไม่เช่นนั้น ตัวอย่าง: สําหรับ x_or_y ((7, 34, 12) == 34 สําหรับ x_or_y ((15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,tha_Thai,python,"
def double_the_difference(lst):
    '''ให้รายการจํานวน, คืนผลรวมกําลังสองของจํานวนในรายการที่คด. ละเลยจํานวนที่ลบหรือไม่ใช่จํานวนเต็ม. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 หากรายการข้อมูลว่าง, คืนค่า 0 '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,tha_Thai,python,"
def compare(game,guess):
    """"""ผมว่าทุกคนจําได้ถึงความรู้สึกนั้น เมื่อได้ทราบผลของเหตุการณ์ที่รอคอยมานานแล้ว ความรู้สึกและความคิดที่คุณมีในขณะนั้นแน่นอนว่าคุ้มที่จะบันทึกและเปรียบเทียบ คุณมีหน้าที่คือการกําหนดว่าผู้คนได้เดาผลของจํานวนการแข่งขันถูกต้องหรือไม่ คุณได้รับการจัดเรียงคะแนนและการเดาความยาวเท่ากันสองอันดับ โดยที่แต่ละดัชนีแสดงการแข่งขัน ให้คืนการจัดเรียงความยาวเท่ากันแสดงว่าการเดาแต่ละอันดับมีความห่างไกลแค่ไหน หากพวกเขาได้เดาถูกต้อง ค่าค่าคือ 0 และถ้าไม่ ค่าค่าคือความแตกต่างที่แน่นอนระหว่างการเดาและคะแนน ตัวอย่าง: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,4]) -> [4,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,tha_Thai,python,"
def Strongest_Extension(class_name, extensions):
    """"""คุณจะได้รับชื่อของคลาส (สาย) และรายการของขยาย. ขยายจะใช้ในการโหลดคลาสเพิ่มเติมในคลาส ความแข็งแรงของขยายเป็นดังนี้: ให้ CAP เป็นจํานวนตัวอักษรใหญ่ในชื่อขยาย, และให้ SM เป็นจํานวนตัวอักษรเล็กในชื่อขยาย, ความแข็งแรงถูกให้โดยเศษส่วน CAP - SM. คุณควรหาขยายที่แข็งแรงที่สุดและคืนสายในรูปแบบนี้: ClassName.StrongestExtensionName. ถ้ามีขยายสองหรือมากกว่าที่มีความแข็งแรงเดียวกัน, คุณควรเลือกอันที่มาแรกในรายการ. ตัวอย่างเช่น, ถ้าคุณได้รับ ""Slices"" เป็นคลาสและรายการของขยาย: ['SEviviSliNGCes', 'Cheese', 'Stufed'] แล้วคุณควรคืน 'Slices.SEviSliNGCes' เนื่องจาก 'SviSliNGCes' 'mySviSliNGCes']) เป็นการขยายที่แข็งแรงที่สุด (ตัวอย่าง: 'AA_Beats' = 'StrongestExtensionName', 'AA_Class' = 'Strongest_Extension'), สําหรับ 'AA_Class' = 'Strongest_Class'""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,tha_Thai,python,"
def cycpattern_check(a , b):
    """"""คุณได้รับ 2 คํา. คุณต้องคืน True หากคําที่สองหรือการหมุนของมันเป็นซับสตริงในคําแรก cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,tha_Thai,python,"
def even_odd_count(num):
    """"""ให้จํานวนเต็ม. คืนทับเปิ้ลที่มีจํานวนหลักเป็นคู่และเป็นคด ตามลําดับ ตัวอย่าง: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,tha_Thai,python,"
def int_to_mini_roman(number):
    """"""ให้จํานวนเต็มบวก, หาตัวเลขโรมันที่เทียบเท่าในรูปของสตริง, และคืนมันในตัวเล็ก: 1 <= num <= 1000 ตัวอย่าง: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,tha_Thai,python,"
def right_angle_triangle(a, b, c):
    '''ให้ความยาวของสามด้านของสามเหลี่ยม. คืน True ถ้าสามด้านเป็นสามเหลี่ยมมุมฉาก, False ถ้าไม่เป็นเช่นนั้น. สามเหลี่ยมมุมฉากคือสามเหลี่ยมที่มีมุมหนึ่งเป็นมุมฉากหรือ 90 องศา. ตัวอย่าง: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,tha_Thai,python,"
def find_max(words):
    """"""เขียนฟังก์ชันที่รับรายการของสายเสียง รายการมีคําต่างกัน กลับคําที่มีจํานวนมากที่สุดของตัวอักษรที่ไม่เหมือนกัน ถ้าสายเสียงหลายตัวมีจํานวนมากที่สุดของตัวอักษรที่ไม่เหมือนกัน กลับคําที่มาแรกตามลําดับคําศัพท์ find_max ((([""name"", ""of"", ""string""]) == ""string"" find_max (([""name"", ""enam"", ""game""]) == ""enam"" find_max (([""aaaaaaa"", ""bb"" , ""cc""]) == """"aaaaaaa"" """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,tha_Thai,python,"
def eat(number, need, remaining):
    """"""คุณเป็นกระต่ายหิว และคุณได้กินมะเขือเทศจํานวนหนึ่งแล้ว แต่ตอนนี้คุณต้องกินมะเขือเทศเพิ่มขึ้นเพื่อให้ครบอาหารในวันนี้ คุณควรคืนเรียงของ [ จํานวนมะเขือเทศทั้งหมดที่กินหลังจากอาหาร, จํานวนมะเขือเทศที่เหลือหลังจากอาหาร ] ถ้าไม่มีมะเขือเทศที่เหลือพอ คุณก็จะกินมะเขือเทศที่เหลือทั้งหมด แต่ยังคงหิว ตัวอย่าง: * กิน(5, 6, 10) -> [11, 4] * กิน(4, 8, 9) -> [12, 1] * กิน(1, 10, 10) -> [11, 0] * กิน(2, 11, 5) -> [7, 0] ตัวแปร: @number: จํานวนมะเขือเทศที่คุณได้กิน. @need: จํานวนมะเขือเทศที่คุณต้องการกิน. @remaining: จํานวนมะเขือเทศที่เหลือในสต๊อก: * Constrain: 0= <= 0 * 1000 <= 0 * จํานวนมะเขือเทศที่เหลือในสต๊อก: 0 = <= 1000 <= 0""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,tha_Thai,python,"
def do_algebra(operator, operand):
    """"""การปฏิบัติงานพีชคณิตฐาน: การบวก (+) การลบ (-)) การคูณ (*) การแบ่งชั้น (-)) การยกกําลัง (**) ตัวอย่าง: operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 หมายเหตุ: ความยาวของรายการผู้ปฏิบัติงานเท่ากับความยาวของรายการผู้ปฏิบัติงาน ลบหนึ่ง ตัวประกอบคือรายการของจํานวนเต็มที่ไม่ลบ ตัวประกอบมีผู้ปฏิบัติงานอย่างน้อย 1 ตัวประกอบและรายการผู้ปฏิบัติงานมีผู้ปฏิบัติงานอย่างน้อย 2 ตัวประกอบ""""""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,tha_Thai,python,"
def solve(s):
    """"""คุณได้รับ string s. ถ้า s[i] เป็นตัวอักษร, เปลี่ยนตัวเลขจากล่างไปบน หรือตรงข้าม, ไม่งั้นก็เก็บมันไว้. ถ้า string ไม่มีตัวอักษร, เปลี่ยน string. ฟังก์ชันควรคืน string ผลลัพธ์. ตัวอย่าง solve ((""1234"") = ""4321"" solve ((""ab"") = ""AB"" solve ((""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,tha_Thai,python,"
def string_to_md5(text):
    """"""ถ้า string 'text' มีให้แล้ว ให้ string คู่เทียบ md5 ของมัน ถ้า 'text' เป็น string ไม่มีอะไร ให้ None >>> string_to_md5 (('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,tha_Thai,python,"
def generate_integers(a, b):
    """"""ให้เลขเต็มบวก a และ b สองตัว, คืนเลขคู่ระหว่าง a และ b, ตามลําดับเพิ่มขึ้น. ตัวอย่าง: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
