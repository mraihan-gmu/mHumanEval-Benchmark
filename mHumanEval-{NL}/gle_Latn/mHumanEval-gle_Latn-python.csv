task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,gle_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Seiceáil an bhfuil dhá uimhir ar bith níos gaire dá chéile ná an tairseach a thugtar i liosta áirithe uimhreacha. Sampla: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,gle_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Is é an t-ionchur a chuirtear isteach sa fheidhm seo sreang ina bhfuil grúpaí il-chraoltais neadaithe. Is é do chuspóir na grúpaí sin a scaradh i sreangaí ar leithligh agus liosta na ndaoine sin a thabhairt ar ais. Tá na grúpaí ar leithligh cothrom (tá gach brace oscailte dúnta i gceart) agus ní neadaithe laistigh dá chéile Ignórtáil aon spásanna sa sreang ionchuir. Sampla: >>> separate_paren_groups'(( ) (() (( ) ) ) ) ) ) ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,gle_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Má thugtar uimhir dearfach pointe luaidhe, is féidir é a dhoilliú ina chuid iomlánach (an t-ionad iomlánach is mó níos lú ná an uimhir a thugtar) agus i gcúigí (an chuid fágtha níos lú i gcónaí ná 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,gle_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Tá liosta de na hoibríochtaí taisce agus aistarraingthe ar chuntas bainc agat a thosaíonn le nialach. Is é do chuspóir a bhrath má thiteann iarmhéid an chuntas faoi bhun nialas ag pointe ar bith, agus ag an bpointe sin ba chóir go dtiocfadh feidhm True ar ais. Seachas sin ba cheart go dtiocfadh False ar ais. Sampla: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,gle_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""I gcás liosta áirithe de na huimhreacha ionchuir, déan an Mean Absolute Deviation a ríomh timpeall meán an tacar sonraí seo. Is é Mean Absolute Deviation an meándifríocht absoliúid idir gach eilimint agus pointe lár (mean sa chás seo): MAD = meán █ x - x_mean █ Exemple: >>> mean_absolute_deviation █ [1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,gle_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Cuir uimhir 'delimiter' isteach idir dhá ghné as a chéile de liosta ionchuir `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,gle_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Is é ionchur an fheidhm seo sreang a léiríonn grúpaí iomadúla do phráinteas snáthaithe arna scaradh le spásanna. Do gach ceann den ghrúpa, téigh amach an leibhéal is doimhne snáthaithe na bprátais. E.g. (() (()) tá dhá leibhéal snáthaithe ar a mhéad agus tá trí ((())) ann. >>> parse_nested_parens (('((()) ((())) () ((()) ((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,gle_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filter a input list of strings only for ones that contain given substring >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,gle_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Chun liosta áirithe de na hionad iomlán, tabhair tuairisc ar tuple ina bhfuil suim agus táirge de na hionad iomlán go léir i liosta. Ba chóir go mbeadh suim folamh comhionann le 0 agus ba chóir go mbeadh táirge folamh comhionann le 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,gle_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Ó liosta de na hionstraimí, cruthaigh liosta de na huimhreacha is mó a fhaightear go dtí an nóiméad áirithe sa seicheamh. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,gle_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Faigh an palindrome is giorra a thosaíonn le sraith soláthair. Tá smaoineamh na halgartaim simplí: - Faigh an postfix is faide de shreang soláthair atá ina palindrome. - Cuir i gcoinne deireadh an shreang prefix shreang a thagann roimh an iar-scríbhneoir palindromic. >>> make_palindrome (('') ' ' >>> make_palindrome (('cat') 'catac' >>> make_palindrome (('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Déan tástáil má tá sreang ar leith ina palindrome """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,gle_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Tá dhá shraith ionchuir a agus b nach bhfuil ach 1 agus 0 ann. Déan XOR dénártha ar na hionchuir seo agus toradh a thabhairt ar ais mar shraith freisin. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,gle_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Sa liosta de shreanghanna, cuir ar ais an ceann is faide. Cuir ar ais an chéad cheann i gcás go bhfuil go leor shreanghanna den fhad céanna. Ná filleadh ar bith i gcás go bhfuil an liosta ionchuir folamh. >>> is faide (([]) >>> is faide ((['a', 'b', 'c']) 'a' >>> is faide ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,gle_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Fill ar ais an comhdhíolóir is mó de dhá líon iomlán a agus b >>> an comhdhíolóir is mó_choitianta_ (a) (3, 5) 1 >>> an comhdhíolóir is mó_choitianta_ (a) (b) (c) (d) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e))""""""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,gle_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Liosta ar ais de na réamhtheachtaí go léir ón gceann is giorra go dtí an ceann is faide den shreang ionchuir >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,gle_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Cuir snáithín ina bhfuil uimhreacha spáis-chríochnaithe ag tosú ó 0 go n san áireamh ar ais. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,gle_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Le sraith de shraith, faigh amach cé mhéad carachtar ar leith (gan aird ar an gcás) a bhfuil sé comhdhéanta de >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,gle_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Tá an t-ionchur a chur isteach sa fheidhm seo ar shraith a léiríonn nótaí ceoil i bhformáid speisialta ASCII. Is é do tasc a parsáil liosta shraith de inteagóirí a fhreagraíonn do go leor builleanna a dhéanann. Anseo tá legend: 'o' nóta, builleanna ceithre beats 'o' - leath nóta, builleanna dhá beats ' - quater nóta, builleanna ceann >>> parse_music '. 'o' . o' . o' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,gle_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Faigh amach cé mhéad uair is féidir fo-shreang a fháil sa shreang bunaidh. Líon cásanna tras-scríofa. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,gle_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Is sraith deimhní deartha spás é ionchur ó 'null' go 'naoi'. Is iad na roghanna bailí 'null', 'aon', 'dhá', 'trí', 'ceithre', 'cúig', 'sé', 'seacht', 'och' agus 'naoi'. Cuirfidh sé an sreang ar ais le huimhreacha arna ndéanamh ordú ó is lú go dtí is mó >>> sort_numbers (('three one five') 'one three five' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,gle_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Ó liosta soláthraithe uimhreacha (de fhad dhá cheann ar a laghad) roghnaigh agus filleadh dhá cheann is gaire dá chéile agus filleadh iad in ord (uimhir níos lú, uimhir níos mó). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,gle_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Liosta de uimhreacha (de dhá eilimint ar a laghad) a thabhairt, déan tras-athrú líneach ar an liosta sin, ar nós go mbeidh an uimhir is lú ina 0 agus go mbeidh an ceann is mó ina 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,gle_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter given list of any python values only for integers >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,gle_Latn,python,"

def strlen(string: str) -> int:
    """"""Tá an t-eachtra seo ar fáil i bhfoirm aistrithe.""""""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,gle_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Le haghaidh uimhir n, faigh an uimhir is mó a roinnte n go cothrom, níos lú ná n >>> largest_divisor ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,gle_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Tá an liosta de na fachtóirí príomh de líon iomlán ar leith a thabhairt ar ais in ord ón is lú go dtí an ceann is mó. Ba cheart líon na n-uaireanta a liostáil a fhreagraíonn do na hamanna a thagann sé i fachtóirú. Ba cheart go mbeadh uimhir ionchuir comhionann le táirge na n-uaireanta go léir >>> factorize ((8) [2, 2, 2] >>> factorize ((25) [5, 5] >>> factorize ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,gle_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Ó liosta de na hionad iomlán, cuir na heilimintí go léir a tharlaíonn níos mó ná uair amháin. Coinnigh ord na n-eilimintí ar chlé mar an gcéanna leis an ionchur. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,gle_Latn,python,"

def flip_case(string: str) -> str:
    """"""I gcás sreang ar leith, flip carachtair bheag go mór-litreacha agus mór-litreacha go mion-litreacha. >>> flip_case ((('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,gle_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Liosta de shreanghanna a chomhcheangal i sraith amháin >>> concatenate (([]) '' >>> concatenate ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,gle_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filter a input list of strings only for ones that start with a given prefix. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,gle_Latn,python,"

def get_positive(l: list):
    """"""Ní thugann sé ach uimhreacha dearfacha sa liosta ar ais. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,gle_Latn,python,"

def is_prime(n):
    """"""Fill ar ais fíor má tá uimhir ar leith réasúnta, agus bréagach ar shlí eile. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,gle_Latn,python,"import math


def poly(xs: list, x: float):
    """"""Is comhéifeachtaí polynomial iad xs. find_zero find x mar sin go bhfuil poly ((x) = 0. find_zero ní thugann sé ach pointe nialach amháin, fiú má tá go leor ann. Ina theannta sin, ní thógann find_zero ach liosta xs a bhfuil líon fiú comhéifeachtaí agus an comhéifeacht neamh-nialach is mó aige mar gheall ar réiteach a ráthú. >>> round ((find_zero[(1, 2]), 2) # f ((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Measann sé polynomial le comhéifeachtaí xs ag pointe x. filleadh xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,gle_Latn,python,"

def sort_third(l: list):
    """"""Tógann an fheidhm seo liosta l agus tugann sé liosta l' ar nós go bhfuil l' comhionann le l sna tásca nach bhfuil inrochtaineach trí, agus go bhfuil a luachanna ag na tásca atá inrochtaineach trí comhionann le luachanna na n-innéacs comhfhreagrach de l, ach ordáilte. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,gle_Latn,python,"

def unique(l: list):
    """"""Cuirfidh sé eilimintí uathúla seolta ar ais i liosta >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,gle_Latn,python,"

def max_element(l: list):
    """"""Cuir ar ais an eilimint is mó sa liosta. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,gle_Latn,python,"

def fizz_buzz(n: int):
    """"""Cuir ar ais líon na n-uaireanna a thagann an uimhir 7 i n-uimhreacha iomlána níos lú ná n atá inrochtana le 11 nó 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,gle_Latn,python,"

def sort_even(l: list):
    """"""Tógann an fheidhm seo liosta l agus tugann sé liosta l' ar nós go bhfuil l' comhionann le l sna táscairí neamhghnácha, agus go bhfuil a luachanna ag na táscairí páirleacha comhionann le luachanna na n-táscairí páirleacha de l, ach ordáilte. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,gle_Latn,python,"

def encode_cyclic(s: str):
    """"""Glacann sé mar shreang ionchuir atá códaithe le feidhm encode_cyclic. Tugann sé sraang díchódáilte ar ais. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""a aisíocann sreang códaithe ag grúpaí rothaíochta trí charachtar. """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,gle_Latn,python,"

def prime_fib(n: int):
    """"""Tugann prime_fib ar ais an n-ú uimhir is uimhir Fibonacci é agus tá sé ina phríomh-uimhir freisin. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,gle_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""tagann tripla_suma_go_null liosta de líon iomlán mar ionchur. Tugann sé Fíor ar ais má tá trí eilimint dhifriúla sa liosta a sholann go n-aon, agus False ar shlí eile. >>> tripla_suma_go_null (([1, 3, 5, 0]) False >>> tripla_suma_go_null (([1, 3, -2, 1]) Fíor >>> tripla_suma_go_null (([1, 2, 3, 7]) False >>> tripla_suma_go_null (([2, 4, -5, 3, 9, 7]) Fíor >>> tripla_suma_go_null [1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,gle_Latn,python,"

def car_race_collision(n: int):
    """"""Is é an t-amhrán seo an t-amhrán is fearr a úsáid chun an t-amhrán a chur ar fáil do dhaoine a bhfuil an-tóir orthu. Is é an t-amhrán an t-amhrán is fearr a úsáid chun an t-amhrán a chur ar fáil do dhaoine a bhfuil an t-amhrán is fearr a úsáid dóibh.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,gle_Latn,python,"

def incr_list(l: list):
    """"""Liosta ar ais le heilimintí a mhéadú le 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,gle_Latn,python,"

def pairs_sum_to_zero(l):
    """"""Tagann pairs_sum_to_zero liosta de líon iomlán mar ionchur. Tugann sé Fíor ar ais má tá dhá eilimint dhifriúla sa liosta a sholann go nialas, agus False ar shlí eile. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,gle_Latn,python,"

def change_base(x: int, base: int):
    """"""Athraigh bunús uimhriúil uimhir ionchuir x go bunús. léargas sreang ar ais tar éis an tiontaithe. tá uimhreacha bunús níos lú ná 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,gle_Latn,python,"

def triangle_area(a, h):
    """"""Le fadacht taobh agus ard-réim ar thriantán. >>> triantán_réim (5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,gle_Latn,python,"

def fib4(n: int):
    """"""Is sraith é sraith uimhreacha Fib4 atá cosúil le sraith Fibbonacci a shainmhínítear mar seo a leanas: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Scríobh feidhm le do thoil chun an n-ú eilimint de shreath uimhreacha fib4 a ríomh go héifeachtach. Ná húsáid athfhilleadh. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,gle_Latn,python,"

def median(l: list):
    """"""Meán aisghabhála eilimintí sa liosta l. >>> meán (([3, 1, 2, 4, 5]) 3 >>> meán (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,gle_Latn,python,"

def is_palindrome(text: str):
    """"""Seiceálann sé an bhfuil sreang ar leith ina palindrome >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,gle_Latn,python,"

def modp(n: int, p: int):
    """"""Fill ar ais 2 ^ n modulo p (a bheith ar an eolas faoi na huimhreacha). >>> modp ((3, 5) 3 >>> modp ((1101, 101) 2 >>> modp ((0, 101) 1 >>> modp ((3, 11) 8 >>> modp ((100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,gle_Latn,python,"

def encode_shift(s: str):
    """"""Glacann sé mar shreang ionchuir atá códaithe le feidhm encode_shift. Tugann sé srian díchódáilte ar ais. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""ar ais sreang códaithe trí gach carachtar a aistriú le 5 san aibítir. """"""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,gle_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels is function that takes string and returns string without vowels. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,gle_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Fill ar ais True má tá na huimhreacha go léir sa liosta l faoi bhun tairseach t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,gle_Latn,python,"

def add(x: int, y: int):
    """"""Cuir dhá uimhir x agus y le chéile >>> cuir ((2, 3) 5 >>> cuir ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,gle_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Seiceáil an bhfuil na carachtair chéanna ag dhá fhocal. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Fíor >>> same_chars (('abcd', 'dddddddabc') Fíor >>> same_chars (('dddddddabc', 'abcd') Fíor >>> same_chars (('eabcd', 'dddddddddabc') False >>> same_chars ((('abcd', 'dddddddabddce') False >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') False """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,gle_Latn,python,"

def fib(n: int):
    """"""Cuir ar ais an n-ú uimhir Fibonacci. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,gle_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets is a string of ""<"" and "">"". return True if each opening bracket has a corresponding closing bracket. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,gle_Latn,python,"

def monotonic(l: list):
    """"""Is é an aisíocaíocht True ná go bhfuil eilimintí liosta ag méadú nó ag laghdú go monotónach. >>> monotónach (([1, 2, 4, 20]) True >>> monotónach (([1, 20, 4, 10]) False >>> monotónach (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,gle_Latn,python,"

def common(l1: list, l2: list):
    """"""Fill ar ais ar eilimintí coitianta uathúla seolta le haghaidh dhá liosta. >>> coitianta (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> coitianta (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,gle_Latn,python,"

def largest_prime_factor(n: int):
    """"""Cuir an fachtóir príomh is mó de n ar ais. Glac le n > 1 agus ní príomhfhochtóir é. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,gle_Latn,python,"

def sum_to_n(n: int):
    """"""Is feidhm é sum_to_n a sholann uimhreacha ó 1 go n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,gle_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets is a string of ""("" and "")"". return True if each opening bracket has a corresponding closing bracket. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,gle_Latn,python,"

def derivative(xs: list):
    """"""Léiríonn xs comhéifeachtaí polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Fill ar ais díorthaigh an polynomial seo sa fhoirm chéanna. >>> díorthaigh (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> díorthaigh ([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,gle_Latn,python,"

def fibfib(n: int):
    """"""Is sraith é sraith uimhreacha FibFib cosúil le sraith Fibbonacci a shainmhínítear mar seo a leanas: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Léigh feidhm chun an n-ú eilimint den sraith uimhreacha fibfib a ríomh go héifeachtach. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,gle_Latn,python,"
FIX = """"""Scríobh feidhm vowels_count a ghlacann sraith a léiríonn focal mar ionchur agus a thugann ar ais líon na vowels sa sraith. Is iad na vowels sa chás seo 'a', 'e', 'i', 'o', 'u'. Anseo, is vowel é 'y' freisin, ach amháin nuair a bhíonn sé ag deireadh an fhocail a thugtar. Sampla: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Cuir cásanna tástála eile leis. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,gle_Latn,python,"
def circular_shift(x, shift):
    """"""Cuir an t-amhrán ar ais i bhfoirm ciorclach. >>> circular_shift{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\displaystyle \circular_shift}{\shift}}""""""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,gle_Latn,python,"
def digitSum(s):
    """"""Tasc Funcún a scríobh a ghlacann sraith sreinge mar ionchur agus a thugann suim na gcarachtair uachtaracha amháin ar ais' cóid ASCII. Samplaí: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,gle_Latn,python,"
def fruit_distribution(s,n):
    """"""Sa tasc seo, tabharfar sraith duit a léiríonn líon na n-áblaí agus na n-ailc a dháileadh i gcorba torthaí ina bhfuil uibheacha, oráistí agus torthaí mango. Le sraith a léiríonn líon iomlán na n-ailc agus na n-ailc agus líon iomlán a léiríonn líon iomlán na dtorthaí sa chorn, cuir ar ais líon na dtorthaí mango sa chorn. mar shampla: fruit_distribution""5(áblaí agus 6 oráiste"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 apples agus 1 oráiste"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 apples agus 3 oráiste"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 apples agus 1 oráiste"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,gle_Latn,python,"
def pluck(arr):
    """"""""Ar mhaithe le sraith a léiríonn brainse de chrann a bhfuil nóid iomlána neamh-diúltacha aige, is é do tasc ná ceann de na nóid a phiocadh agus é a thabhairt ar ais. Ba chóir go mbeadh an nóid phiocáilte mar an nóid leis an luach pá is lú. Má aimsítear go leor nóid leis an luach pá is lú, tabhair ar ais an nóid a bhfuil an t-innéacs is lú. Ba chóir an nóid phiocáilte a thabhairt ar ais i liosta, [small_value, a innéacs], Mura bhfuil aon luachanna pá ann nó má tá an sraith ar fáil folamh, filleadh ar []. Eispéireas 1: Iompar: [4,2,3] aschur: [2, 1] Míníocht: Tá an luach pá is lú ag 2 agus tá an t-innéacs is lú ag 2 . Eispéireas 2: Iompar: [1,2,3] aschur: [2, 1] Míníocht: Tá an luach is lú ag 2 agus tá an t-innéacs is lú ag 2 . Is sampla 3: Iompar: [] Is é an toradh: [4: [5, 3, 4] , [0, 2] Is é an toradh: 1 is lú nóid, is lú: tá an luach is lú, ach tá an t-innéacs is lú ann.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,gle_Latn,python,"
def search(lst):
    '''Tá liosta neamh-folamh de líon iomlán dearfach ar fáil duit. Cuir ar ais an líon iomlán is mó atá níos mó ná nialas, agus a bhfuil minicíocht níos mó ná nó comhionann le luach an líon iomlán féin. Is é minicíocht an líon iomlán an líon uaireanta a thagann sé ar an liosta. Mura bhfuil aon luach den sórt sin ann, cuir ar ais -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,gle_Latn,python,"
def strange_sort_list(lst):
    '''Is é an t-earráid aisteach, nuair a thosaíonn tú leis an luach íosta, ansin uasmhéid na n-einteoirí atá fágtha, ansin íosta agus mar sin de. Samplaí: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,gle_Latn,python,"
def triangle_area(a, b, c):
    '''Má tá na trí thaobh de thriantán bailí, cuirfear limistéar an thriantáin ar ais go dtí 2 phointe deisceach. Má tá na trí thaobh bailí, cuirfear -1 ar ais. Má tá suim dhá thaobh ar bith níos mó ná an tríú taobh, déantar trí thaobh bailí. Sampla: triantán_ limistéar (a) 3, 4, 5) == 6.00 triantán_ limistéar (a) 1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,gle_Latn,python,"
def will_it_fly(q,w):
    '''Scríobh feidhm a thugann True ar ais má eitiltfidh an réad q, agus False ar shlí eile. Éiríonn an réad q má tá sé cothrom (líosta palindrómach é) agus má tá suim a chuid eilimintí níos lú ná nó comhionann leis an uasmhéid is féidir w. Sampla: will_it_fly (([1, 2], 5) â -> False # 1+2 is lú ná an uasmhéid is féidir, ach tá sé neamhchothrom. will_it_fly (([3, 2, 3], 1) â -> False # tá sé cothrom, ach tá 3+2+3 níos mó ná an uasmhéid is féidir. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 is lú ná an uasmhéid is féidir, agus tá sé cothrom. will_it_fly ((([3], â 5) -> True # 3 is lú ná an uasmhéid is féidir, agus tá sé cothrom. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,gle_Latn,python,"
def smallest_change(arr):
    """"""Ar an ábhar seo, is féidir leat a fháil ar an líon íosta de na gnéithe a chaithfear a athrú chun an t-airgead a dhéanamh palindromic. Is é an t-airgead palindromic an t-airgead a léitear ar an mbealach céanna ar ais agus ar aghaidh. I athrú amháin, is féidir leat aon ghné a athrú go haon ghné eile. Mar shampla: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,gle_Latn,python,"
def total_match(lst1, lst2):
    '''Scríobh feidhm a ghlacann le dhá liosta de shreanghanna agus a thugann ar ais an liosta a bhfuil líon iomlán na gcártaí sna shreanghanna uile den liosta níos lú ná an liosta eile. má tá an líon céanna carachtair ag an dá liosta, tabhair ar ais an chéad liosta. Samplaí total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi]) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'], '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,gle_Latn,python,"
def is_multiply_prime(a):
    """"""Scríobh feidhm a thugann fíor ar ais má tá an uimhir a tugadh mar mhéadú ar 3 uimhir phríomh agus bréagach ar shlí eile.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,gle_Latn,python,"
def is_simple_power(x, n):
    """"""Is é do tasc a scríobh feidhme a thugann ar ais fíor má tá uimhir x ina cumhacht simplí de n agus bréagach i gcásanna eile. x is cumhacht simplí de n má n**int=x Mar shampla: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,gle_Latn,python,"
def iscube(a):
    '''Scríobh feidhm a ghlacann le hionad iomlán a agus a thugann True ar ais má tá an ingeger seo ina chiúb de roinnt uimhir iomlánach. Nóta: is féidir leat a ghlacadh go bhfuil an ionchur bailí i gcónaí. Samplaí: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,gle_Latn,python,"
def hex_key(num):
    """"""Tá sé de chúram ort feidhm a scríobh a fhaigheann uimhir heicseadaimhiúil mar shraith agus a chomhaireamh líon na n-aicme heicseadaimhiúil atá príomha (is uimhir phríomh, nó príomh, uimhir nádúrtha níos mó ná 1 nach táirge de dhá uimhir nádúrtha níos lú). Is iad na huimhreacha heicseadaimhiúla 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Is iad na huimhreacha príomha 2, 3, 5, 7, 11, 13, 17,... Mar sin ní mór duit líon na n-aicmeanna seo a leanas a chinneadh: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13). Nóta: is féidir leat a ghlacadh go bhfuil an ionchur i gcónaí ceart nó folamh, agus is comharthaí A, B, C, D, E, F i gcónaí i gcúrsa. Samplaí: Maidir le num = AB, ba chóir go mbeadh an t-ionchur num = 1. Maidir le num = 1077E, ba cheart go mbeadh an aschur 2. Maidir le num = ""AB33"" ba cheart go mbeadh an t-ionmhéide = 4. ""ABC"" ba cheart go mbeadh 6.01234567DEF 6.0202020""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,gle_Latn,python,"
def decimal_to_binary(decimal):
    """"""Beidh uimhir i bhfoirm dheicheálach agus is é do tasc é a thiontú go formáid dhiainéar. Ba chóir go dtiocfadh an fheidhm sreang, le gach carachtar a léiríonn uimhir dhiainéar. Beidh gach carachtar sa sreang a bheith '0' nó '1'. Beidh cúpla breise carachtair 'db' ag tús agus ag deireadh an sreang. Tá na carachtair breise ann chun cabhrú leis an bhformáid. Samplaí: decimal_to_binary ((15) # a aisíocann ""db1111db"" decimal_to_binary32) # a aisíocann ""db100000db"" """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,gle_Latn,python,"
def is_happy(s):
    """"""Tá sraith de litreacha ar fáil duit, agus is é do chuspóir a sheiceáil an bhfuil an sraith sásta nó nach bhfuil. Tá sraith sásta má tá a fhad 3 ar a laghad agus má tá gach 3 litir as a chéile ar leith, mar shampla: is_happy (a) => False is_happy (a) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,gle_Latn,python,"
def numerical_letter_grade(grades):
    """"""Tá sé an tseachtain dheireanach den séimeastar agus tá an múinteoir a thabhairt na gráid do mhic léinn. Tá an múinteoir a dhéanamh a algartam féin le haghaidh grádú. Is é an fhadhb amháin, tá sí caillte an cód a d'úsáid sí le haghaidh grádú. Tá sí a thug tú liosta de GPAs do roinnt mic léinn agus tá tú a scríobh feidhm a d'fhéadfadh a aschur liosta de grád litreacha ag baint úsáide as an tábla seo a leanas: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,gle_Latn,python,"
def prime_length(string):
    """"""Scríobh feidhm a ghlacann le sraith sreinge agus a thugann ar ais Fíor má tá an fad sreinge ina uimhir phríomh nó False ar shlí eile Eispéiris prime_length (('Hello') == Fíor prime_length (('abcdcba') == Fíor prime_length (('kittens') == Fíor prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,gle_Latn,python,"
def starts_one_ends(n):
    """"""Ag tabhairt iomlán-uimhreacha dearfacha n, cuir ar ais líon na n-uimhreacha dearfacha n-sigit a thosaíonn nó a chríochnaíonn le 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,gle_Latn,python,"
def solve(N):
    """"""Má tá uimhir iomlán dearfach N, cuir suim iomlán a dhigití ar ais i mbinéar. Sampla Le haghaidh N = 1000, beidh suim na n-aicmí 1 ba chóir go mbeadh an toradh ""1"". Le haghaidh N = 150, beidh suim na n-aicmí 6 ba chóir go mbeadh an toradh ""110"". Le haghaidh N = 147, beidh suim na n-aicmí 12 ba chóir go mbeadh an toradh ""1100"". Athraitheacha: @N Constraints iomlán: 0 â‰¤ N â‰¤ 10000. Torthaí: sraith de uimhir dhúchasach """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,gle_Latn,python,"
def add(lst):
    """"""Tabhair liosta neamh-folamh de na hionad iomlán lst. cuir na heilimintí fiú atá ag innéacsanna gan leithreas .. Samplaí: cuir (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,gle_Latn,python,"
def anti_shuffle(s):
    """"""Scríobh feidhm a ghlacann le sraith sreinge agus a thugann leagan ordnaithe de. Is sraith sreinge é leagan ordnaithe de shreang, ina ndéantar gach focal (arna scaradh le spás) a chur in ionad focal nua ina ndéantar na carachtair go léir a shocrú in ord ardú bunaithe ar luach ascii. Nóta: Ba cheart duit ord na bhfocal agus na spásanna folamh sa abairt a choinneáil. Mar shampla: anti_shuffle ((('Hi') a thugann 'Hi' anti_shuffle ((('hello') a thugann 'ehllo' anti_shuffle (('Hello World!!!') a thugann 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,gle_Latn,python,"
def get_row(lst, x):
    """"""Tá sonraí 2 dhímeánta agat, mar liostaí neadaithe, atá cosúil le mátrix, áfach, murab ionann agus mátraí, d'fhéadfadh líon difriúil colún a bheith ag gach sraith. Le linn an tsraith, agus líon iomlán x, faigh na n-intéir x sa liosta, agus liosta tuplaí a thabhairt ar ais, [(x1, y1), (x2, y2) ...] ionas go mbeidh gach tupla ina chomhordanú - (líne, colúin), ag tosú le 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,gle_Latn,python,"
def sort_array(array):
    """"""Má tá sraith de líon iomlán neamh-diúltach agat, cuir cóip den sraith a tugadh ar ais tar éis é a shórtáil, sorcóidh tú an sraith a tugadh in ord ardú má tá an suim (luach an chéad innéacs, luach an innéacs deireanach) neamhfhoirmeach, nó é a shórtáil in ord ísle má tá an suim (luach an chéad innéacs, luach an innéacs deireanach) fiú. Nóta: * ná athraigh an sraith a tugadh. Samplaí: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,gle_Latn,python,"
def encrypt(s):
    """"""Cruthaigh feidhm encrypt a ghlacann sraith sreinge mar argóint agus a thugann sreang criptithe ar ais agus an aibítir á rothlú. Ba cheart an aibítir a rothlú ar bhealach a fhágann go n-athraíonn na litreacha síos trí dhá iolrú go dhá áit. Mar shampla: encrypt('hi') a thugann 'lm' encrypt('asdfghjkl') a thugann 'ewhjklnop' encrypt('gf') a thugann 'kj' encrypt('et') a thugann 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,gle_Latn,python,"
def next_smallest(lst):
    """"""Tá liosta de na hionad iomlán tugtha duit. Scríobh feidhm next_smallest (() a thugann ar ais an dara eilimint is lú den liosta. Ní thugann sé ar ais aon cheann mura bhfuil aon eilimint den sórt sin ann. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,gle_Latn,python,"
def is_bored(S):
    """"""Beidh tú a thabhairt ar sreang de na focail, agus is é do tasc a chomhaireamh an líon na boredoms. Is boredom abairt a thosaíonn leis an bhfocal ""I"". Baintear abairtí delimited ag '.', '?' nó '!'. Mar shampla: >>> is_bored(""Hello domhan"") 0 >>> is_bored(""Tá an spéir gorm. Tá an ghrian ag soilsithe. Is breá liom an aimsir seo"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,gle_Latn,python,"
def any_int(x, y, z):
    '''Déan feidhm a ghlacann le 3 uimhir. Deireann sé fíor má tá ceann de na huimhreacha comhionann le suim an dá uimhir eile, agus is ionann na huimhreacha go léir agus uimhreacha iomlána. Deireann sé bréagach in aon chás eile. Samplaí any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,gle_Latn,python,"
def encode(message):
    """"""Scríobh feidhm a ghlacann teachtaireacht, agus a chódálann ar bhealach a mhalartú cás de gach litir, a athsholáthar gach vowels sa teachtaireacht leis an litir a bhfuil le feiceáil 2 áiteanna roimh an vowel sa aibítir Béarla. Glacann le litreacha amháin. Samplaí: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,gle_Latn,python,"

def skjkasdkd(lst):
    """"""Tá liosta de líon iomlán tugtha duit. Ní mór duit an luach príomh is mó a aimsiú agus suim a dhigití a thabhairt ar ais. Samplaí: Le haghaidh lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ba chóir go mbeadh an toradh 10 Le haghaidh lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ba chóir go mbeadh an toradh 25 Le haghaidh lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ba chóir go mbeadh an toradh 13 Le haghaidh lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ba chóir go mbeadh an toradh 11 Le haghaidh lst = [0,81,12,31,21] ba chóir go mbeadh an toradh 3 Le haghaidh lst = [1,8,1,2,1,7] ba chóir go mbeadh an toradh 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,gle_Latn,python,"
def check_dict_case(dict):
    """"""Má tá foclóir ar fáil, filleann sé Fíor má tá gach eochair ina shreangáin i gcúrsaí beaga nó má tá gach eochair ina shreangáin i gcúrsaí móra, eile filleann sé False. Ba chóir go filleadh an fheidhm False má tá an foclóir ar fáil folamh. Samplaí: check_dict_case{""a"":""apple"", ""b"":""banana""}) ba chóir go filleadh sé Fíor. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) ba chóir go filleadh sé False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) ba chóir go filleadh sé False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) ba chóir go filleadh sé False. check_dict_case{""NC"":""STATE"", ""Z"":""IP""12345}) ba chóir go filleadh sé Fíor.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,gle_Latn,python,"
def count_up_to(n):
    """"""Feidhm a chur i bhfeidhm a ghlacann le hionad iomlán neamh-diúltach agus a thugann sreang de na chéad n n-ionad iomlán a bhfuil uimhreacha príomh agus níos lú ná n. mar shampla: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,gle_Latn,python,"
def multiply(a, b):
    """"""Cuir an fheidhm a thógann dhá fhigiúr iomlán agus a thugann toradh a n-aigneanna aonad ar ais. Glac leis go bhfuil an ionchur bailí i gcónaí. Samplaí: ba chóir go dtiocfadh 16 ar ais ó mhnáid 148, 412. ba cheart go dtiocfadh 72. ba cheart go dtiocfadh 0. ba cheart go dtiocfadh 20 ar ais ó mhnáid 148, 412. ba cheart go dtiocfadh 0 ar ais ó mhnáid 185. ba cheart go dtiocfadh 20 ar ais ó mhnáid 185. ba cheart go dtiocfadh 20 ar ais ó mhnáid 195. ba cheart go dtiocfadh 20 ar ais ó mhnáid 195. ba cheart go dtiocfadh 20 ar ais ó mhnáid 195. ba cheart go dtiocfadh 20 ar ais ó mhnáid 195. ba cheart go dtiocfadh 20 ar ais ó mhnáid 195. ba cheart go dtiocfadh 20 ar ais ó mhnáid 195. ba cheart go dtiocfadh 20 ar ais ó mhnáid 195. ba cheart go dtiocfadh 20 ar ais ó mhnáid 196.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,gle_Latn,python,"
def count_upper(s):
    """"""Má thugtar sraith s, déan líon na mbróga móra i n-innéacsanna pá a chomhaireamh. Mar shampla: count_upper (('aBCdEf') a aisíocann 1 count_upper (('abcdefg') a aisíocann 0 count_upper (('dBBE') a aisíocann 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,gle_Latn,python,"
def closest_integer(value):
    '''Déan feidhm a thógann luach (string) a léiríonn uimhir agus a thugann an t-ionad iomlán is gaire dó. Má tá an uimhir chomh fada ó dhá iomláine, cuardaigh é ar shiúl ó nialas. Samplaí >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 Nóta: Ciallaíonn cuardach ar shiúl ó nialas go bhfuil an uimhir a thugtar chomh fada ó dhá iomláine, is é an ceann ba chóir duit a thabhairt ar ais an ceann is faide ó nialas. Le haghaidh sampla ba chóir go dtabharfadh closest_integer "" ((14.5"") 15 agus ba cheart go dtabharfadh closest_integer "" ((-14.5"") -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,gle_Latn,python,"
def make_a_pile(n):
    """"""Má tá n iomlán dearfach ann, ní mór duit cúlra de n leibhéal clocha a dhéanamh. Tá n chloch sa chéad leibhéal. Is é líon na gcloch sa chéad leibhéal eile: - an chéad uimhir gan leithéid más cúlra é n. - an chéad uimhir chomhlána más cúlra é n. Cuir ar ais líon na gcloch i ngach leibhéal i liosta, áit a léiríonn an eilimint ag innéacs i líon na gcloch sa leibhéal (i+1). Samplaí: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,gle_Latn,python,"
def words_string(s):
    """"""Beidh sraith focal ar fáil duit a bheidh scartha le coimhde nó le spásanna. Is é do chuspóir an sraith a roinnt ina bhfocail agus sraith de na focail a thabhairt ar ais. Mar shampla: words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,gle_Latn,python,"
def choose_num(x, y):
    """"""Tógann an fheidhm seo dhá uimhir dhearfacha x agus y agus déanann sí an uimhir iomlánach is mó atá sa raon [x, y] san áireamh. Mura bhfuil uimhir den sórt sin ann, ba cheart don fheidhm -1 a thabhairt ar ais. Mar shampla: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,gle_Latn,python,"
def rounded_avg(n, m):
    """"""Tá dhá n-uimhreacha iomlána dearfacha n agus m agat, agus is é do chuspóir meán na n-uimhreacha iomlána ó n go m a ríomh (lena n agus m san áireamh). Cuardaigh an freagra go dtí an t-uimhreacha iomlána is gaire agus é a thiontú go binary. Má tá n níos mó ná m, filleadh ar -1.""""""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,gle_Latn,python,"
def unique_digits(x):
    """"""Tabhair liosta de na hionad iomlán dearfach x. a thabhairt ar ais liosta sordaithe de na heilimintí go léir nach bhfuil aon digit fiú. Nóta: Ba chóir an liosta a d'fhill a sordaítear in ord méadaithe. Mar shampla: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,gle_Latn,python,"
def by_length(arr):
    """"""Mar shampla: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""Eight"", ""Five"", ""Four"", ""Three"", ""One"", ""Two"", ""One""] Má tá an sraith folamh, a thabhairt ar ais sraith folamh: arr = [] return [] Má tá an sraith aon uimhir aisteach, neamhaird a dhéanamh air: arr = [1, 1 , 1 - 1 , 55 -> arr - 1 , 55 -> arr - 1 , 55 -> reverse arr = [51] return - 'One' """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,gle_Latn,python,"
def f(n):
    """"""Cuir an fheidhm f i bhfeidhm a ghlacann n mar pharaiméadar, agus a thugann liosta de mhéid n ar ais, ar nós go bhfuil luach an eiliminte ag innéacs i mar fhachtóirial i má tá i fiú nó mar suim na n-uimhreacha ó 1 go i ar shlí eile. i tosaíonn ó 1. is é an fhachtóirial i ná iolrú na n-uimhreacha ó 1 go i (1 * 2 * ... * i). Sampla: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,gle_Latn,python,"
def even_odd_palindrome(n):
    """"""Má tá n-uimhir iomlán dearfach, tabhair tuairisc ar tupl a bhfuil líon na paindróimí iomlána fiú agus neamhghnácha a thagann laistigh den raon ((1, n), lena n-áirítear. Sampla1: Ionchur: 3 aschur: (1, 2) Míniú: Tá paindróimí iomlána 1, 2, 3. tá ceann acu páirteach, agus tá beirt acu neamhghnácha. Sampla2: Ionchur: 12 Aschur: (4, 6) Míniú: Tá paindróimí iomlána 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. tá ceithre acu páirteach, agus tá 6 acu neamhghnácha. Nóta: 1. 1 <= n <= 10^3 2. tá líon na paindróimí iomlána fiú agus neamhghnácha ar ais ag tupl. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,gle_Latn,python,"
def count_nums(arr):
    """"""Scríobh feidhm count_nums a ghlacann sraith de líon iomlán agus a thugann ar ais líon na n-eilimintí a bhfuil suim na n-aicmí > 0. Má tá uimhir diúltach, ansin beidh a chéad dhigit sínithe diúltach: e.g. -123 tá na sigití sínithe -1, 2, agus 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,gle_Latn,python,"
def move_one_ball(arr):
    """"""Tá sraith 'arr' againn de N uimhreacha iomlána arr[1], arr[2], ..., arr[N].Beidh na huimhreacha sa sraith ordáilte go randamach. Is é do chuspóir a chinneadh an féidir sraith a shocrú in ord neamh-imní trí na hoibríochtaí seo a leanas a dhéanamh ar an sraith ar leith: Tá cead agat oibríocht sciatháin dheis a dhéanamh aon líon uaireanta. Ciallaíonn oibríocht sciatháin dheis go n-aistreoidh tú gach eilimint den sraith ag suíomh amháin sa treo ceart. Aistreofar an eilimint deireanach den sraith chuig an suíomh tosaigh sa sraith i.e. 0th innéacs. Má tá sé indéanta an sraith ordáilte a fháil trí na hoibríochtaí thuas a dhéanamh ansin filleadh Fíor eile filleadh False. Má tá an sraith ar leith folamh ansin filleadh Fíor. Nóta: Tá sé de ráthaithe go mbeidh eilimintí uathúla ag an liosta ar leith. Mar shampla: move_one_{(ball_[3, 4, 5, 1== 2>>> Mínniú Fíor: Trí mhíchill 2} oibríochtaí ar leith, is féidir ord neamh-imní a bhaint amach don sraith ar leith.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,gle_Latn,python,"
def exchange(lst1, lst2):
    """"""Sa fhadhb seo, cuirfidh tú feidhm i bhfeidhm a ghlacann dhá liosta uimhreacha, agus a chinnfidh an féidir le hailt a mhalartú eatarthu chun go mbeidh liosta de uimhreacha pá amháin ag lst1. Níl aon teorainn ar líon na n-eilimintí a mhalartú idir lst1 agus lst2. Má tá sé indéanta eilimintí a mhalartú idir lst1 agus lst2 chun go mbeidh na heilimintí go léir de lst1 pá, filleadh ar ""ÍDE"". Seachas sin, filleadh ar ""NÍDE"". Mar shampla: malartú [(1, 2, 3, 4], [1, 2, 3, 4]) => ""ÍDE"" malartú [(1, 2, 3, 4], [1, 5, 3, 4]) => ""NÍDE"" Meastar nach mbeidh na liostaí ionchuir folamh. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,gle_Latn,python,"
def histogram(test):
    """"""Má tá sraith de litreacha ann, cuir an litreach a bhfuil an líon is mó athdhéanta ann agus an líon comhfhreagrach leis ar ais. Má tá roinnt litreacha ag teacht ar an gcéanna, cuir iad go léir ar ais.""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,gle_Latn,python,"
def reverse_delete(s,c):
    """"""Tasc Tugtar dhá shraith s agus c dúinn, ní mór duit na carachtair go léir i s a scriosadh atá comhionann le carachtar ar bith i c ansin seiceáil an bhfuil an sreang toradh palindrome. Tugtar palindrome ar shraith má léann sé an méid céanna ar ais agus ar aghaidh. Ba cheart duit tupla a thabhairt ar ais ina bhfuil an sreang toradh agus Fíor/Fíor chun an seiceáil. Sampla Le haghaidh s = ""abcde"", c = ""ae"", ba chóir go mbeadh an toradh ('bcd',Fíor) Le haghaidh s = ""abcdef"", c = ""b"" ba chóir go mbeadh an toradh ('acdef',Fíor) Le haghaidh s = ""abcdedcba"", c = ""ab"", ba cheart go mbeadh an toradh ('cdedc',Fíor) """"""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,gle_Latn,python,"
def odd_count(lst):
    """"""Má thugtar liosta de shreanghanna, nach bhfuil ach digiteach i ngach sreang, cuir liosta ar ais. Ba chóir go mbeadh ""amhrán na n-eilimintí gan leithéid i sreang i na hionchuir"". áit ar chóir na ianna go léir a chur in ionad líon na n-iolracha gan leithéid i i'th sraang an ionchuir. >>> odd_count['1234567']) [""amhrán na n-eilimintí gan leithéid 4n an str4ng 4 den 4nput.""] >>> odd_count['3',""111111""]) [""amhrán na n-eilimintí gan leithéid 1n an str1ng 1 den 1nput."", ""amhrán na n-eilimintí gan leithéid 8n an str8ng 8 den 8nput.""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,gle_Latn,python,"
def minSubArraySum(nums):
    """"""Má tá sraith de n-uimhreacha iomlána á thabhairt, faigh an suim íosta de aon fho-sreath neamh-folamh de n-uimhreacha. Sampla minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,gle_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche. Tá grianghraf de na tobar ag an gcluiche.""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,gle_Latn,python,"
def sort_array(arr):
    """"""Sa Kata seo, ní mór duit sraith de líon iomlán neamh-diúltach a shocrú de réir líon na ndaoine a bhfuil a léiriú dénártha acu in ord ardú. Maidir le líon comhchosúil daoine, sortaigh bunaithe ar luach deiciúil. Ní mór é a chur i bhfeidhm mar seo: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,gle_Latn,python,"
def select_words(s, n):
    """"""Má tá an s i lár an tsraith, ba cheart go mbeadh liosta folamh ag an bhfeidhm. Nóta: is féidir leat a mheas nach bhfuil ach litreacha agus spásanna sa tsraith ionchuir. Samplaí: select_words (""Mary had a little lamb"", 4) ==> [""little""] select_words (""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""] select_words ""simple white space"", 2) ==> [] select_words (""Hello world"", 4) ==> [""world""] select_words (""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,gle_Latn,python,"
def get_closest_vowel(word):
    """"""Tá focal ar fáil duit. Is é do chuspóir an vowel is gaire a aimsiú atá idir dhá chonsúinte ón taobh dheis den focal (scéal-saineolach). Ní chomhaireamh na vowels ag tús agus ag deireadh. Cuir sreang folamh ar ais mura bhfaighidh tú aon vowel a chomhlíonann an choinníoll thuas. Is féidir leat a mheas nach bhfuil sa sreang atá tugtha ach litir Béarla. Sampla: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" ((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,gle_Latn,python,"
def match_parens(lst):
    '''Tá liosta de dhá shreangán tugtha duit, agus tá an dá shreangán comhdhéanta de phráinteas oscailte '(' nó phráinteas dúnta ') ' amháin. Is é do phost a sheiceáil an féidir an dá shreangán a nascadh in ord éigin, go mbeidh an t-sreangán a bheidh mar thoradh air go maith. Meastar go bhfuil S maith má tá agus amháin má tá gach parentheses i S cothrom. Mar shampla: tá an t-sreangán '((()) ' maith, agus níl an t-sreangán '()) ' .'''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,gle_Latn,python,"
def maximum(arr, k):
    """"""Ar shraith de na hionad ar inteach agus ar iomad iomlán dearfach k, tabhair liosta sordaithe de fhad k leis na huimhreacha k is mó in arr. Sampla1: Ionchur: arr = [-3, -4, 5], k = 3 Torthaí: [-4, -3, 5] Sampla2: Ionchur: arr = [4, -4, 4], k = 2 Torthaí: [4, 4] Sampla3: Ionchur: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Torthaí: [2] Nóta: 1. Beidh fad an array i raon [1, 1000]. 2. Beidh na heilimintí sa array i raon [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,gle_Latn,python,"
def solution(lst):
    """"""Má tá liosta neamhfhada de na hionad iomlán ann, cuir suim na n-eilimintí gan aon cheann atá i suíomhanna fiú ar ais.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,gle_Latn,python,"
def add_elements(arr, k):
    """"""Ar mhaithe le sraith neamhfhada de na hionad iomlán arr agus iomlán k, cuir ar ais suim na n-eilimintí a bhfuil dhá dhigit ar a mhéad acu ó na chéad eilimintí k de arr. Sampla: Ionchur: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Torthaí: 24 # suim 21 + 3 srianta: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,gle_Latn,python,"
def get_odd_collatz(n):
    """"""Is é an tuairimíocht Collatz ná tuairimíocht sa mhatamaitic a bhaineann le seicheamh a shainítear mar seo a leanas: tosú le haon iomlán dearfach n. Ansin gheobhaidh gach téarma ón téarma roimhe seo mar seo a leanas: má tá an téarma roimhe seo pá, tá an téarma eile leath den téarma roimhe seo. Má tá an téarma roimhe seo gan pá, tá an téarma eile 3 huaire an téarma roimhe seo móide 1. Is é an tuairimíocht ná is cuma cén luach de n, beidh an seicheamh ag teacht i gcónaí ar 1. Tabhair faoi deara: 1. Collatz ((1) is é [1]. 2. Tá an liosta a d'fhill sé sordaithe in ord méadaithe. Mar shampla: get_odd_collatz ((5) filleann [1, 5] # Is é an seicheamh Collatz do 5 [5, 8, 16, 4, 2, 1], mar sin níl na huimhreacha gan pá ach 1, agus 5. """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,gle_Latn,python,"
def valid_date(date):
    """"""Ní mór duit feidhm a scríobh a bhailíonn sraith dáta áirithe agus a thugann Fíor ar ais má tá an dáta bailí ar shlí eile Mícheart. Tá an dáta bailí má tá na rialacha seo a leanas go léir sásta: 1. Níl an sraith dáta folamh. 2. Níl an líon laethanta níos lú ná 1 nó níos airde ná 31 lá do mhí 1,3,5,7,8,10,12. Agus níl an líon laethanta níos lú ná 1 nó níos airde ná 30 lá do mhí 4,6,9,11. Agus, níl an líon laethanta níos lú ná 1 nó níos airde ná 29 don mhí 2. 3. Ní chóir go mbeadh na míonna níos lú ná 1 nó níos airde ná 12. 4. Ba chóir go mbeadh an dáta sa fhormáid: mm-dd-yyyy mar shampla: valid_date (('03-11-2000') => True_date (dáta bailí) => False_date (dáta bailí) => False_date (dáta bailí) => False_date (dáta bailí) => False_date (dáta bailí) => False_date (dáta bailí) => False_date (dáta bailí) => False_date (dáta bailí) => False_date (dáta bailí)""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,gle_Latn,python,"
def split_words(txt):
    '''Má tá sreang focal ar fáil, tabhair liosta focal a roinnt ar spás bán, mura bhfuil spás bán ann sa téacs ba cheart duit a roinnt ar choimhdeacha ',' má níl aon choimhdeacha ann ba cheart duit líon na litreacha beaga a thabhairt ar ais le horduithe gan leithéid san aibítir, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 Samplaí de roinnt_focail (a) -> (a) -> (a) -> (a) -> (a) -> (a) == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,gle_Latn,python,"
def is_sorted(lst):
    '''Má tá liosta de uimhreacha, filleadh cibé acu a bhfuil siad a ordú in ord ardú. Má tá liosta níos mó ná 1 dúbailte den uimhir chéanna, filleadh False. Glac aon uimhreacha diúltacha agus uimhreacha iomlána amháin. Samplaí is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5, 5]) â -> True is_sorted (([1, 2, 3, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,gle_Latn,python,"
def intersection(interval1, interval2):
    """"""Tá dhá earra á thabhairt duit, áit a bhfuil gach earra ina péire de líon iomlán. Mar shampla, earra = (tús, deireadh) = (1, 2). Tá na earra dúnta, rud a chiallaíonn go n-áirítear an earra (tús, deireadh) tús agus deireadh araon. Maidir le gach earra, tá sé meastar go bhfuil a thús níos lú ná nó comhionann lena deireadh. Is é do tasc a chinneadh an bhfuil fad idirthréimhse na dhá earra seo ina uimhir phríomh. Mar shampla, is é an t-idirthréimhse na n-earra (1, 3), (2, 4) (2, 3) a bhfuil a fhad 1, nach uimhir phríomh é. Má tá fad an idirthréimhse ina uimhir phríomh, filleadh ""ÍDE"", ar shlí eile, filleadh ""NÍDE"". Mura ndéanann an dá earra idirthréimhse, filleadh ""NÍDE"". [input/output] samplaí: intersection (((1, 2), (2, 3) ==> ""intersection ((-1, 1) ""), intersection (==> 0, 4) ""NO"" ==> 5 - (((1, 5), "" (YES (-5, 3) "")) ))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,gle_Latn,python,"
def prod_signs(arr):
    """"""Tugtar sraith de líon iomlán duit agus ní mór duit suim na n-uimhir iomlán a mhéadú le táirge gach comhartha de gach uimhir sa sraith, a léirítear le 1, -1 nó 0. Tabhair faoi deara: ní fhillfidh aon cheann ar shraith folamh. Sampla: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,gle_Latn,python,"
def minPath(grid, k):
    """"""I gcás gríd le N sraitheanna agus N colún (N >= 2) agus le k-ionad iomlán dearfach, tá luach ag gach cill den ghríd. Tá gach ionad iomlán sa raon [1, N * N] san áireamh le feiceáil uair amháin ar na cill den ghríd. Caithfidh tú an bealach íosta fad k a fháil sa ghríd. Is féidir leat tosú ó aon chill, agus i ngach céim is féidir leat bogadh go dtí aon cheann de na cill chomharsanacha, i bhfocail eile, is féidir leat dul chuig cill a bhfuil imeall acu leat cill reatha. Tabhair faoi deara le do thoil go gciallaíonn bealach fad k cuairt a thabhairt ar díreach k chealla (ní gá go mbeadh siad ar leith). NÍ MÓCH tú dul amach as an ghríd. Meastar go bhfuil bealach A (fhad k) níos lú ná bealach B (fhad k) má tá liostaí ordnaithe de na luachanna ar na cealla A agus B a théann tríd (gaimid iad a ghlaoch ar lA_st agus lA_st), tá lA_st níos lú ná lA_st go léarscéimeach, i bhfocail eile, tá innéacs iomlán agat i ngach cill. Is féidir leat tosú ó aon cheall, agus i ngach céim is féidir leat bogadh chuig aon chealla comharsanacha eile, i bhfocail eile, is féidir leat dul chuig cealla a chéile, i bhfocail eile, i bhfocail eile, i bhfocail eile, i bhfocail eile, i bhfocail eile, i bhfocail, i bhfocail, i bhfocail, i bhfocail, i bhfocail, i bhfocail, i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail i bhfocail ifocail i bhfocail i bhfocail ifo""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,gle_Latn,python,"
def tri(n):
    """"""Tá sé ar eolas ag gach duine, rinne matamaiticeoirí staidéar domhain air le cúpla céad bliain anuas. Mar sin féin, is é an rud nach bhfuil a fhios ag daoine ná ordú Tribonacci. Sainmhínítear ordú Tribonacci leis an athrá: tri(1) = 3 tri(n) = 1 + n / 2, má tá n fiú. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), má tá n neamhghnáchasach. Mar shampla: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Tugtar uimhir iomlán neamh-diúltach n duit, caithfidh tú liosta de na chéad n + 1 uimhreacha de shraith Tribonacci a thabhairt ar ais. Samplaí: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,gle_Latn,python,"
def digits(n):
    """"""Má tá uimhir iomlán dearfach n, tabhair toradh na n-aicmeanna neamhghnácha ar ais. Tabhair 0 ar ais má tá na huimhreacha go léir pá. Mar shampla: digits(1) == 1 digits(4) == 0 digits(235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,gle_Latn,python,"
def is_nested(string):
    '''Is féidir le feidhm a chruthú a ghlacann le sraith sreinge mar ionchur nach bhfuil ach braicéid chearnacha ann. Ba cheart go dtiocfadh an fheidhm True má agus amháin má tá fo-sreath bailí de braicéid ann ina bhfuil braicéid amháin ar a laghad sa fho-sreath snáthaithe. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,gle_Latn,python,"

def sum_squares(lst):
    """"""Tá liosta de uimhreacha tugtha duit. Ní mór duit suim na n-uimhreacha cearnach sa liosta a thabhairt ar ais, gach eilimint sa liosta a bhabhtaigh go dtí an int uachtarach (~) ar dtús. Samplaí: Maidir le lst = [1,2,3] ba chóir go mbeadh an aschur 14 Maidir le lst = [1,4,9] ba chóir go mbeadh an aschur 98 Maidir le lst = [1,3,5,7] ba chóir go mbeadh an aschur 84 Maidir le lst = [1.4,4.2,0] ba chóir go mbeadh an aschur 29 Maidir le lst = [-2.4,1,1] ba cheart go mbeadh an aschur 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,gle_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Creach feidhm a thugann Fíor má tá carachtar deireanach sraith áirithe carachtar aibítreach agus nach cuid de fhocal é, agus False ar shlí eile. Nóta: Is grúpa carachtair é ""fhocal"" a scarann spás. Samplaí: check_if_last_char_is_a_letter"" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,gle_Latn,python,"
def can_arrange(arr):
    """"""Déan feidhm a chruthú a thugann an t-innéacs is mó d'eileamh nach bhfuil níos mó ná nó comhionann leis an eilimint atá díreach roimh é. Mura bhfuil aon eilimint den sórt sin ann ansin filleadh -1. Ní bheidh luachanna dúblacha sa sraith ar leith. Samplaí: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,gle_Latn,python,"
def largest_smallest_integers(lst):
    '''Déan feidhm a aisíocann tupla (a, b), áit a bhfuil 'a' an ceann is mó de na hionad iomlán diúltach, agus 'b' an ceann is lú de na hionad iomlán dearfacha i liosta. Mura bhfuil aon ionad iomlán diúltach nó dearfach ann, cuir iad ar ais mar None. Samplaí: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,gle_Latn,python,"
def compare_one(a, b):
    """"""Déan feidhm a ghlacann le hionadaithe iomlána, le floatanna nó le sreangaí a léiríonn uimhreacha fíor agus a thugann an t-athraitheach is mó ina chineál athraitheach ar leith. Ní thugann sé ar ais aon cheann má tá na luachanna comhionann. Nóta: Má léirítear uimhreacha fíor mar shreang, d'fhéadfadh an pointe suite a bheith . nó , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,gle_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Déan meastóireacht ar an féidir an uimhir a tugadh n a scríobh mar shúile 4 uimhir shocraithe dearfacha fiú go díreach Sampla is_equal_to_sum_even (a) == False is_equal_to_sum_even (a) == False is_equal_to_sum_even (a) == True """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,gle_Latn,python,"
def special_factorial(n):
    """"""Sainmhínítear an fhachtóirial Bhrasaíl mar: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! áit a bhfuil n > 0 Mar shampla: >>> special_factorial ((4) 288 Gheobhaidh an fheidhm líon iomlán mar ionchur agus ba cheart dó an fhachtóirial speisialta den líon iomlán seo a thabhairt ar ais. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,gle_Latn,python,"
def fix_spaces(text):
    """"""_Sampla-3he ann, cuir faoi léarscáil gach spás ann, agus má tá níos mó ná 2 spás i ndiaidh a chéile ag sraith, cuir na spásanna i ndiaidh a chéile in ionad - fix_spaces ((""Eisimpleire"") == ""Eisimpleire"" fix_spaces ((""Eisimpleire1"") == ""Eisimpleire1"" fix_spaces (((""Eisimpleire2"") == ""_Eisimpleire2"") fix_spaces ((""Eisimpleire 3"") == ""_Eisimpleire-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,gle_Latn,python,"
def file_name_check(file_name):
    """"""Cruthaigh feidhm a ghlacann le sraith sreinge a léiríonn ainm comhaid, agus a thugann 'Tá' ar ais má tá ainm an chomhaid bailí, agus a thugann 'Níl' ar ais ar shlí eile. Meastar go bhfuil ainm comhaid bailí má chomhlíontar na coinníollacha seo a leanas: - Níor chóir go mbeadh níos mó ná trí dhigit ('0'-'9') i ainm an chomhaid. - Ní mór an t-ainm comhaid a bheith ina dháta amháin '.' - Ní chóir go mbeadh an fho-shreang roimh an bpointe folamh, agus ba chóir go dtosaíonn sé le litir ón alfa laidin ('a'-'z' agus 'A'Z'). - Ba cheart go mbeadh an fho-shreang tar éis an phointe fo-leathrú ar cheann de na litreacha seo: ['txt', 'exe', 'lld'] Samplaí: file_name_check""{example.txt"") # => 'Tá' file_name_check""{example.dll1"") => 'Níl' (ba chóir go dtosóidh an t-ainm le litir laidin) # => 'Ní mór an ainm a thosú le litir laidin'""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,gle_Latn,python,"


def sum_squares(lst):
    """""""" Bainfidh an fheidhm seo liosta de líon iomlán. Maidir le hiontrálacha uile sa liosta, cuirfidh an fheidhm an iontráil iomlán ar chearnóg má tá a innéacs ina iomadán de 3 agus cuirfidh sé an iontráil iomlán ar chearnóg má tá a innéacs ina iomadán de 4 agus ní iomadán de 3. Ní athróidh an fheidhm na hiontrálacha sa liosta nach bhfuil a n-innéacsanna ina iomadán de 3 nó 4. Ba cheart don fheidhm ansin suim na n-iontrálacha go léir a thabhairt ar ais. Samplaí: Le haghaidh lst = [1,2,3] ba chóir go mbeadh an aschur 6 Le haghaidh lst = [] ba cheart go mbeadh an aschur 0 Le haghaidh lst = [-1,-5,2,-1,-5] ba cheart go mbeadh an aschur -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,gle_Latn,python,"
def words_in_sentence(sentence):
    """"""Tugtar sreang duit a léiríonn abairt, tá roinnt focail ar an abairt atá scartha le spás, agus caithfidh tú sreang a thabhairt ar ais ina bhfuil na focail ón abairt bhunaidh, a bhfuil uimhreacha príomhúla ina fhad, ba cheart go mbeadh ord na bhfocal sa sreang nua mar an gcéanna leis an gceann bunaidh. Sampla1: Iontráil: abairt = ""Is tástáil é seo"" Torthaí: ""is"" Sampla2: Iontráil: abairt = ""déanaimid dul ag snámh"" Torthaí: ""go for"" srianta: * 1 <= len(sentence) <= 100 * níl ach litreacha sa abairt """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,gle_Latn,python,"
def simplify(x, n):
    """"""Is é do tasc feidhm a chur i bhfeidhm a shimpliú an abairt x * n. Tugann an fheidhm True ar ais má mheastar x * n go líon iomlán agus False ar shlí eile. Tá an dá x agus n, léiriú sraithe de chion, agus tá an fhormáid seo a leanas acu, <numerator>/<denominator> áit a bhfuil an t-uimhir agus an t-ainmníocht araon ina n-uimhreacha iomlána dearfacha. Is féidir leat a mheas go bhfuil x, agus n ina chion bailí, agus nach bhfuil an núil mar ainmníocht. simplify "" 1/5 "", ""5/1"") = True simplify "" 1/6 "", ""2/1"") = False simplify "" 7/10 "", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,gle_Latn,python,"
def order_by_points(nums):
    """"""Scríobh feidhm a ordóidh an liosta iomlán de na hionadaithe i ord ardú de réir suim a n-sigití. Nóta: má tá roinnt earraí ann a bhfuil suim den chineál céanna acu ar a n-sigití, ordú iad bunaithe ar a n-innéacs sa liosta bunaidh. Mar shampla: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points []) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,gle_Latn,python,"
def specialFilter(nums):
    """"""Scríobh feidhm a ghlacann sraith uimhreacha mar ionchur agus a thugann ar ais líon na n-eilimintí sa sraith atá níos mó ná 10 agus is é an chéad agus an dara digit de uimhir gan uimhreacha (1, 3, 5, 7, 9). Mar shampla: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,gle_Latn,python,"
def get_max_triples(n):
    """"""Tá líon iomlán dearfach n agat. Caithfidh tú sraith iomlán a a fhad n a chruthú. Maidir le gach i (1 ‰¤ i ‰¤ n), luach a[i] = i * i - i + 1. Cuir ar ais líon na dtríúile (a[i], a[j], a[k]) de a áit a bhfuil i < j < k, agus a[i] + a[j] + a[k] is iomaí de 3.""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,gle_Latn,python,"
def bf(planet1, planet2):
    '''Tá ocht bpláinéad inár gcóras gréine: is é an ceann is gaire don Ghrian Mearcair, an ceann eile Vínas, ansin an Domhan, Mars, Iúpatar, Seatúrn, Úránas, Neiptiún. Scríobh feidhm a ghlacann dhá ainm pláinéid mar shreanghanna pláinéad1 agus pláinéad2. Ba cheart don fheidhm tupla a thabhairt ar ais ina bhfuil na pláinéid go léir a bhfuil a n-orbitaí suite idir orbit na pláinéid1 agus orbit na pláinéid2, arna dtriallú de réir an dlús leis an ngrian. Ba cheart don fheidhm tupla folamh a thabhairt ar ais mura bhfuil ainmneacha na pláinéid ceart ag pláinéad1 nó pláinéad2. Samplaí bf ""(Jupiter"", ""Neiptiún"") ==> (""Saturn"", ""Uranus"") bf ((""Earth"", ""Mercury"") ==> (""Venus"") bf (((""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,gle_Latn,python,"
def sorted_list_sum(lst):
    """"""Scríobh feidhm a ghlacann le liosta sreanga mar pharaiméadar, a scriosann na sreangacha a bhfuil fad neamhghnácha acu, agus a thugann an liosta a tháinig leis ar ais le horduithe ordraithe, Is liosta sreangaí i gcónaí an liosta agus ní sraith uimhreacha riamh, agus d'fhéadfadh go mbeadh dúblacha ann. Ba cheart ord an liosta a bheith ag ardú de réir fad gach focal, agus ba cheart duit an liosta a ordú de réir an riail sin a thabhairt ar ais. Má tá dhá fhocal den fhad céanna, ordú an liosta go aibítreach. Ba cheart don fheidhm liosta sreangacha a thabhairt ar ais in ord ordraithe. Is féidir leat a mheas go mbeidh an fhad céanna ag na focail go léir. Mar shampla: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,gle_Latn,python,"
def x_or_y(n, x, y):
    """"""Clár simplí a d'fhéadfadh luach x a thabhairt ar ais má tá n ina uimhir phríomh agus a d'fhéadfadh luach y a thabhairt ar ais mura bhfuil. Samplaí: le haghaidh x_or_y(7, 34, 12) == 34 le haghaidh x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,gle_Latn,python,"
def double_the_difference(lst):
    '''Má tá liosta de uimhreacha agat, tabhair suim chearnach na n-uimhreacha atá neamhghnácha sa liosta ar ais. Ignoráil uimhreacha atá diúltach nó nach ionann iad agus uimhreacha iomlána. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Má tá an liosta ionchuir folamh, tabhair 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,gle_Latn,python,"
def compare(game,guess):
    """"""Is é an rud is mó a dhéanann tú ná a fháil amach an bhfuil an t-am ceart chun an t-am ceart a fháil. Is é an rud is mó a dhéanann tú ná a fháil amach an bhfuil an t-am ceart chun an t-am ceart a fháil. Is é an rud is mó a dhéanann tú ná a fháil amach an bhfuil an t-am ceart chun an t-am ceart a fháil. Is é an rud is mó a dhéanann tú ná a fháil amach an bhfuil an t-am ceart chun an t-am ceart a fháil.""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,gle_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Tabharfar ainm rang (string) agus liosta de leathnúcháin duit. Ba chóir na leathnúcháin a úsáid chun ranganna breise a uaslódáil chuig an rang. Is é seo a leanas neart na leathnúcháin: Lig CAP a bheith mar líon na litreacha móra i ainm an leathnúcháin, agus lig SM a bheith mar líon na litreacha beaga i ainm an leathnúcháin, tugtar an neart ag an gcodán CAP - SM. Ba cheart duit an leathnúchán is láidre a aimsiú agus sreang a thabhairt ar ais sa fhormáid seo: ClassName.StrongestExtensionName. Má tá dhá leathnúchán nó níos mó leis an neart céanna, ba cheart duit an ceann a thagann ar dtús sa liosta a roghnú. Mar shampla, má tá ""Slices"" tugtha duit mar an rang agus liosta de na leathnúcháin: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] ansin ba cheart duit 'Slices.SEviRNGSliCes' a thabhairt ar ais ós rud é go bhfuil 'SviRNGSliCes' (mySliCes'viRNGSliCes') an leathnúchán is láidre (['Extension_AA'], mar shampla: 'Be'Strongest_class' = 'Class_AA').""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,gle_Latn,python,"
def cycpattern_check(a , b):
    """"""Tá 2 fhocal tugtha duit. Ní mór duit True a thabhairt ar ais má tá an dara focal nó aon cheann dá rothaí ina fho-shraith sa chéad fhocal cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,gle_Latn,python,"
def even_odd_count(num):
    """"""Má thugtar uimhir iomlán, cuir ar ais tupla a bhfuil líon na n-aicme pá agus neamhphéasta faoi seach. Sampla: fiú_neamhphéasta_amharc (a) ==> (1, 1) fiú_neamhphéasta_amharc (a) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,gle_Latn,python,"
def int_to_mini_roman(number):
    """"""Má thugtar iomlán dearfach, faigh a chomhfhreagras uimhreacha Rómhánacha mar shraith, agus cuir ar ais é i gcúrsa beag.""""""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,gle_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Má tá na trí thaobh de thriantán ar fad, a thabhairt ar ais fíor má tá na trí thaobh a fhoirmiú triantán ceart-uillinn, False ar shlí eile. triantán ceart-uillinn is triantán ina bhfuil uillinn amháin ceart-uillinn nó 90 céim. Sampla: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,gle_Latn,python,"
def find_max(words):
    """"""Scríobh feidhm a ghlacann le liosta de shreanghanna. Tá focail éagsúla sa liosta. Cuir an focal leis an uasmhéid de charachtair uathúla ar ais. Má tá uasmhéid de charachtair uathúla ag shreanghanna iomadúla, cuir ar ais an ceann a thagann ar dtús in ord léasaicografach. find_max (([""ainm"", ""de"", ""shreang""]) == ""shreang"" find_max (([""ainm"", ""enam"", ""cluiche""]) == ""enam"" find_max (([""aaaaaaa"", ""bb"" , ""cc""]) == """"aaaaaaa"" """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,gle_Latn,python,"
def eat(number, need, remaining):
    """"""Tá tú ar coinín ocras, agus tá tú ag ithe cheana féin ar líon áirithe de carróidí, ach anois is gá duit a ithe níos mó carróidí a chur ar fáil chun a lán de na béilí an lae. ba chóir duit a thabhairt ar ais sraith de [ líon iomlán na carróidí a itheadh tar éis do béilí, an líon na carróidí fágtha tar éis do béilí ] más rud é nach bhfuil go leor carróidí fágtha, beidh tú ag ithe gach carróidí fágtha, ach beidh tú fós a bheith ocras. Sampla: * ithe ((5, 6, 10) -> [11, 4] * ithe ((4, 8, 9) -> [12, 1] * ithe ((1, 10, 10) -> [11, 0] * ithe ((2, 11, 5) -> [7, 0] Athraitheacha: @number: líon iomlán na carróidí a bhfuil tú ag ithe. @need: líon iomlán na carróidí a bhfuil tú ag ithe. @remaining: líon iomlán na carróidí fágtha i stoc Constrain: * 0= <= 1000 * 0 = <= 1000 * 0 = <= 1000 = = = = 1000 = = = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,gle_Latn,python,"
def do_algebra(operator, operand):
    """"""Tá dhá liosta oibrí, agus oibrí. Tá oibrí bunúsacha algaibí sa chéad liosta, agus tá liosta iomlán de na hionadanna ar an dara liosta. Bain úsáid as an dá liosta a thugtar chun an léiriú algaibreach a thógáil agus meastóireacht an léiriú seo a thabhairt ar ais. Na hoibríochtaí algaibí bunúsacha: Cuir ( +) Aistarraingt ( - ) Iolrú ( *) Roinnt urláir ( //) Exponentiation ( **) Sampla: oibrí['+', '*', '-'] array = [2, 3, 4, 5] toradh = 2 + 3 * 4 - 5 => toradh = 9 Nóta: Tá fad liosta oibrí comhionann le fad liosta oibrí mínus ceann. Tá liosta iomlán neamh-díobhálach ag an oibrí. Tá liosta oibrí amháin ar a laghad ag an oibrí, agus tá liosta oibrí ar a laghad dhá oibrí. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,gle_Latn,python,"
def solve(s):
    """"""Má tá s[i] ina litir, cas an cás ó bhun go barr nó vice versa, mura bhfuil aon litir sa shraith, cas an shraith. Ba chóir don fheidhm an shraith a tháinig as a ais. Samplaí réitigh ((""1234"") = ""4321"" réitigh ((""ab"") = ""AB"" réitigh ((""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,gle_Latn,python,"
def string_to_md5(text):
    """"""Má tá 'text' ina shreang folamh, filleadh ar None. >>> string_to_md5 (('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,gle_Latn,python,"
def generate_integers(a, b):
    """"""Mar shampla: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
