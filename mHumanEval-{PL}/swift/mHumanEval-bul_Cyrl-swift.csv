task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,bul_Cyrl,swift,"
// даден праг. // Проверете дали в даден масив от числа, има две числа по-близо един до друг от /// >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)
/// false
/// >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)
/// true
func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
","func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
    let sortedNumbers = numbers.sorted()
    for i in 0..<sortedNumbers.count - 1 {
        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"
HumanEval_1,bul_Cyrl,swift,"
// Не обръщай внимание на празнините в въведения ред. // Отделни групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.// разделя тези групи в отделни низове и връща масив от тях. // Входът на тази функция е низ, съдържащ множество групи от вложени скоби./// >>> separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"")
/// [""()"", ""(())"", ""(()())""]
func separate_paren_groups(paren_string: String) -> [String] {
","func separate_paren_groups(paren_string: String) -> [String] {
    var results = [String]()
    var currentGroup = """"
    var balance = 0

    for char in paren_string {
        // Ignore spaces
        if char == "" "" {
            continue
        }
        
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }

        currentGroup.append(char)

        if balance == 0 && !currentGroup.isEmpty {
            results.append(currentGroup)
            currentGroup = """"
        }
    }
    
    return results
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(separate_paren_groups(paren_string: ""(()()) ((())) () ((())()())"") == [""(()())"", ""((()))"", ""()"", ""((())()())""])
assert(separate_paren_groups(paren_string: ""() (()) ((())) (((())))"") == [""()"", ""(())"", ""((()))"", ""(((())))""])
assert(separate_paren_groups(paren_string: ""(()(())((())))"") == [""(()(())((())))""])
assert(separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"") == [""()"", ""(())"", ""(()())""])"
HumanEval_2,bul_Cyrl,swift,"
// Връща десетичната част на числото. // (остатъчната част винаги е по-малка от 1). // и част от цело число (най-голямото цело число, по-малко от даденото число) и десетични знаци // При положително число с плаваща точка, може да се разложи на /// >>> truncate_number(number: 3.5)
/// 0.5
func truncate_number(number: Double) -> Double {
","func truncate_number(number: Double) -> Double {
    return number - Double(Int(number))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(truncate_number(number: 3.5) == 0.5)
assert(truncate_number(number: 1.25) == 0.25)
assert(truncate_number(number: 123.0) == 0.0)"
HumanEval_3,bul_Cyrl,swift,"
// в този момент функцията трябва да върне true. В противен случай трябва да върне false. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нулата и // Имате на разположение редица операции за депозиране и теглене на банкова сметка, които започват с /// >>> below_zero(operations: [1, 2, 3])
/// false
/// >>> below_zero(operations: [1, 2, -4, 5])
/// true
func below_zero(operations: [Int]) -> Bool {
","func below_zero(operations: [Int]) -> Bool {
    var balance = 0
    for operation in operations {
        balance += operation
        if balance < 0 {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_zero(operations: [] as [Int]) == false)
assert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)
assert(below_zero(operations: [1, 2, -4, 5, 6]) == true)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)
assert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"
HumanEval_4,bul_Cyrl,swift,"
// MAD = средно. x - x_мейн. // елемент и център (средно в този случай): // Средната абсолютна отклонение е средната абсолютна разлика между всеки // около средната стойност на този набор от данни. // За даден масив от входящи числа, изчисли средното абсолютно отклонение./// >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])
/// 1.0
func mean_absolute_deviation(numbers: [Double]) -> Double {
","func mean_absolute_deviation(numbers: [Double]) -> Double {
    guard !numbers.isEmpty else { return 0.0 }
    
    let mean = numbers.reduce(0.0, +) / Double(numbers.count)
    let absoluteDifferences = numbers.map { abs($0 - mean) }
    let mad = absoluteDifferences.reduce(0.0, +) / Double(absoluteDifferences.count)
    
    return mad
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"
HumanEval_5,bul_Cyrl,swift,"
// Вмъкнете число ""делиметър"" между всеки два последователни елемента на входния масив `numbers' /// >>> intersperse(numbers: [] as [Int], delimeter: 4)
/// [] as [Int]
/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)
/// [1, 4, 2, 4, 3]
func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
","func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
    guard !numbers.isEmpty else { return [] }
    
    var result: [Int] = []
    
    for number in numbers {
        result.append(number)
        result.append(delimeter)
    }
    
    // Remove the last added delimiter
    result.removeLast()
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])
assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])
assert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
HumanEval_6,bul_Cyrl,swift,"
// Например (() (()) има максимум две нива на гнездене, докато ((())) има три. // За всяка група, изберете най-дълбокото ниво на вграждане на скоби. // Входът на тази функция е низ, представляващ множество групи за вложени скоби, разделени с пробели. /// >>> parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"")
/// [2, 3, 1, 3]
func parse_nested_parens(paren_string: String) -> [Int] {
","func parse_nested_parens(paren_string: String) -> [Int] {
    let groups = paren_string.split(separator: "" "")
    var depths: [Int] = []
    
    for group in groups {
        var maxDepth = 0
        var currentDepth = 0
        
        for char in group {
            if char == ""("" {
                currentDepth += 1
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == "")"" {
                currentDepth -= 1
            }
        }
        
        depths.append(maxDepth)
    }
    
    return depths
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"") == [2, 3, 1, 3])
assert(parse_nested_parens(paren_string: ""() (()) ((())) (((())))"") == [1, 2, 3, 4])
assert(parse_nested_parens(paren_string: ""(()(())((())))"") == [4])"
HumanEval_7,bul_Cyrl,swift,"
// Филтрира въведения масив от низове само за тези, които съдържат даден подряд./// >>> filter_by_substring(strings: [] as [String], substring: ""a"")
/// [] as [String]
/// >>> filter_by_substring(strings: [""abc"", ""bacd"", ""cde"", ""array""], substring: ""a"")
/// [""abc"", ""bacd"", ""array""]
func filter_by_substring(strings: [String], substring: String) -> [String] {
","func filter_by_substring(strings: [String], substring: String) -> [String] {
    return strings.filter { $0.contains(substring) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_substring(strings: [] as [String], substring: ""john"") == [] as [String])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xx"") == [""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""grunt"", ""trumpet"", ""prune"", ""gruesome""], substring: ""run"") == [""grunt"", ""prune""])"
HumanEval_8,bul_Cyrl,swift,"
// Празната сума трябва да е равна на 0 и празното произведение трябва да е равна на 1.// За даден масив от цели числа, върнете тупъл, състоящ се от сума и произведение на всички цели числа в масив. /// >>> sum_product(numbers: [] as [Int])
/// (0, 1)
/// >>> sum_product(numbers: [1, 2, 3, 4])
/// (10, 24)
func sum_product(numbers: [Int]) -> (Int, Int) {
","func sum_product(numbers: [Int]) -> (Int, Int) {
    let sum = numbers.reduce(0, +)
    let product = numbers.reduce(1, *)
    return (sum, product)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_product(numbers: [] as [Int]) == (0, 1))
assert(sum_product(numbers: [1, 1, 1]) == (3, 1))
assert(sum_product(numbers: [100, 0]) == (100, 0))
assert(sum_product(numbers: [3, 5, 7]) == (15, 105))
assert(sum_product(numbers: [10]) == (10, 10))"
HumanEval_9,bul_Cyrl,swift,"
В последователността.// От даден масив от цели числа, генерира масив от въртящи се максимални елементи, открити до даден момент./// >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])
/// [1, 2, 3, 3, 3, 4, 4]
func rolling_max(numbers: [Int]) -> [Int] {
","func rolling_max(numbers: [Int]) -> [Int] {
    var result = [Int]()
    var currentMax: Int? = nil
    for number in numbers {
        if let max = currentMax {
            currentMax = max > number ? max : number
        } else {
            currentMax = number
        }
        result.append(currentMax!)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rolling_max(numbers: [] as [Int]) == [] as [Int])
assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])
assert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
HumanEval_10,bul_Cyrl,swift,"
// - Добавете към края на струнния обрат на префикс, който идва преди палиндромния суфикс. // - Намерете най-дългия постфикс от дадения нисък, който е палиндром. Идеята за алгоритъма е проста:// Намерете най-късият палиндром, който започва с дадена низа. /// >>> make_palindrome(string: """")
/// """"
/// >>> make_palindrome(string: ""cat"")
/// ""catac""
/// >>> make_palindrome(string: ""cata"")
/// ""catac""
func make_palindrome(string: String) -> String {
","func make_palindrome(string: String) -> String {
    func isPalindrome(_ s: String) -> Bool {
        return s == String(s.reversed())
    }
    
    if string.isEmpty || isPalindrome(string) {
        return string
    }
    
    for i in stride(from: string.count, through: 0, by: -1) {
        let suffixIndex = string.index(string.startIndex, offsetBy: i)
        let suffix = String(string[suffixIndex..<string.endIndex])
        if isPalindrome(suffix) {
            let prefix = String(string[string.startIndex..<suffixIndex])
            return string + String(prefix.reversed())
        }
    }
    
    return string
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_palindrome(string: """") == """")
assert(make_palindrome(string: ""x"") == ""x"")
assert(make_palindrome(string: ""xyz"") == ""xyzyx"")
assert(make_palindrome(string: ""xyx"") == ""xyx"")
assert(make_palindrome(string: ""jerry"") == ""jerryrrej"")"
HumanEval_11,bul_Cyrl,swift,"
// Извършва двоичен XOR върху тези входове и връща резултат също като низ. // Входът са две струни a и b, състоящи се само от 1 и 0./// >>> string_xor(a: ""010"", b: ""110"")
/// ""100""
func string_xor(a: String, b: String) -> String {
","func string_xor(a: String, b: String) -> String {
    let charactersA = Array(a)
    let charactersB = Array(b)
    var result = """"

    for i in 0..<charactersA.count {
        let bitA = charactersA[i]
        let bitB = charactersB[i]
        
        if bitA != bitB {
            result.append(""1"")
        } else {
            result.append(""0"")
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: ""111000"", b: ""101010"") == ""010010"")
assert(string_xor(a: ""1"", b: ""1"") == ""0"")
assert(string_xor(a: ""0101"", b: ""0000"") == ""0101"")"
HumanEval_12,bul_Cyrl,swift,"
Връща нил, ако въведеният масив е празен.// Извън масив от струни, връща най-дългата. В случай на множествена /// >>> longest(strings: [] as [String])
/// nil
/// >>> longest(strings: [""a"", ""b"", ""c""])
/// ""a""
/// >>> longest(strings: [""a"", ""bb"", ""ccc""])
/// ""ccc""
func longest(strings: [String]) -> String? {
","func longest(strings: [String]) -> String? {
    guard !strings.isEmpty else { return nil }
    var longestString = strings[0]
    for string in strings {
        if string.count > longestString.count {
            longestString = string
        }
    }
    return longestString
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(longest(strings: [] as [String]) == nil)
assert(longest(strings: [""x"", ""y"", ""z""]) == ""x"")
assert(longest(strings: [""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]) == ""zzzz"")"
HumanEval_13,bul_Cyrl,swift,"
// Връща най-големия общ делител на две цели числа a и b /// >>> greatest_common_divisor(a: 3, b: 5)
/// 1
/// >>> greatest_common_divisor(a: 25, b: 15)
/// 5
func greatest_common_divisor(a: Int, b: Int) -> Int {
","func greatest_common_divisor(a: Int, b: Int) -> Int {
    if b == 0 {
        return a
    } else {
        return greatest_common_divisor(a: b, b: a % b)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(greatest_common_divisor(a: 3, b: 7) == 1)
assert(greatest_common_divisor(a: 10, b: 15) == 5)
assert(greatest_common_divisor(a: 49, b: 14) == 7)
assert(greatest_common_divisor(a: 144, b: 60) == 12)"
HumanEval_14,bul_Cyrl,swift,"
// Връща масив от всички префикси от най-краткия до най-дългия от въведения нисък /// >>> all_prefixes(string: ""abc"")
/// [""a"", ""ab"", ""abc""]
func all_prefixes(string: String) -> [String] {
","func all_prefixes(string: String) -> [String] {
    var prefixes: [String] = []
    for i in 1...string.count {
        let prefix = String(string.prefix(i))
        prefixes.append(prefix)
    }
    return prefixes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(all_prefixes(string: """") == [] as [String])
assert(all_prefixes(string: ""asdfgh"") == [""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""])
assert(all_prefixes(string: ""WWW"") == [""W"", ""WW"", ""WWW""])"
HumanEval_15,bul_Cyrl,swift,"
// Връща низа, съдържаща пространствено-ограничени числа, започвайки от 0 до n включително. /// >>> string_sequence(n: 0)
/// ""0""
/// >>> string_sequence(n: 5)
/// ""0 1 2 3 4 5""
func string_sequence(n: Int) -> String {
","func string_sequence(n: Int) -> String {
    return (0...n).map { String($0) }.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_sequence(n: 0) == ""0"")
assert(string_sequence(n: 3) == ""0 1 2 3"")
assert(string_sequence(n: 10) == ""0 1 2 3 4 5 6 7 8 9 10"")"
HumanEval_16,bul_Cyrl,swift,"
// Дадена нишка, намери колко различни знака (без значение от казуса) се състои от /// >>> count_distinct_characters(string: ""xyzXYZ"")
/// 3
/// >>> count_distinct_characters(string: ""Jerry"")
/// 4
func count_distinct_characters(string: String) -> Int {
","func count_distinct_characters(string: String) -> Int {
    let lowercasedString = string.lowercased()
    let distinctCharacters = Set(lowercasedString)
    return distinctCharacters.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_distinct_characters(string: """") == 0)
assert(count_distinct_characters(string: ""abcde"") == 5)
assert(count_distinct_characters(string: ""abcdecadeCADE"") == 5)
assert(count_distinct_characters(string: ""aaaaAAAAaaaa"") == 1)
assert(count_distinct_characters(string: ""Jerry jERRY JeRRRY"") == 5)"
HumanEval_17,bul_Cyrl,swift,"
""Със"" - четвърт нота, продължава един ритъм.""Ооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооооо""О"" - цяла нота, продължава четири удара.Ето една легенда:Не и последно.// Вашата задача е да анализирате този низ и да върнете масив от цели числа, съответстващи на това колко удара прави всеки.// Входът на тази функция е струна, представляваща музикални ноти в специален ASCII формат. /// >>> parse_music(music_string: ""o o| .| o| o| .| .| .| .| o o"")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
","func parse_music(music_string: String) -> [Int] {
    let notes = music_string.split(separator: "" "")
    var beats: [Int] = []
    
    for note in notes {
        switch note {
        case ""o"":
            beats.append(4)
        case ""o|"":
            beats.append(2)
        case "".|"":
            beats.append(1)
        default:
            continue
        }
    }
    
    return beats
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: """") == [] as [Int])
assert(parse_music(music_string: ""o o o o"") == [4, 4, 4, 4])
assert(parse_music(music_string: "".| .| .| .|"") == [1, 1, 1, 1])
assert(parse_music(music_string: ""o| o| .| .| o o o o"") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: ""o| .| o| .| o o| o o|"") == [2, 1, 2, 1, 4, 2, 4, 2])"
HumanEval_18,bul_Cyrl,swift,"
// Изчисли колко пъти даден подряд може да бъде намерен в оригиналния низ./// >>> how_many_times(string: """", substring: ""a"")
/// 0
/// >>> how_many_times(string: ""aaa"", substring: ""a"")
/// 3
/// >>> how_many_times(string: ""aaaa"", substring: ""aa"")
/// 3
func how_many_times(string: String, substring: String) -> Int {
","func how_many_times(string: String, substring: String) -> Int {
    guard !substring.isEmpty else { return 0 }
    
    var count = 0
    var startIndex = string.startIndex
    
    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {
        count += 1
        startIndex = string.index(after: range.lowerBound)
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(how_many_times(string: """", substring: ""x"") == 0)
assert(how_many_times(string: ""xyxyxyx"", substring: ""x"") == 4)
assert(how_many_times(string: ""cacacacac"", substring: ""cac"") == 4)
assert(how_many_times(string: ""john doe"", substring: ""john"") == 1)"
HumanEval_19,bul_Cyrl,swift,"
// Връща низовете с числа подредени от най-малки до най-големи // Валидни варианти са ""нула"", ""един"", ""два"", ""три"", ""четири"", ""пет"", ""шест"", ""седем"", ""осем"" и "" девет"". // Входът е пространствено-ограничен низ от числа от ""нула"" до "" девет""./// >>> sort_numbers(numbers: ""three one five"")
/// ""one three five""
func sort_numbers(numbers: String) -> String {
","func sort_numbers(numbers: String) -> String {
    // Mapping of word numbers to digits
    let numberWords: [String: Int] = [
        ""zero"": 0,
        ""one"": 1,
        ""two"": 2,
        ""three"": 3,
        ""four"": 4,
        ""five"": 5,
        ""six"": 6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"": 9
    ]

    // Split the input string into words
    let words = numbers.split(separator: "" "")

    // Sort the words based on their corresponding number values
    let sortedWords = words.sorted { 
        numberWords[String($0)]! < numberWords[String($1)]! 
    }

    // Join the sorted words back into a single string
    return sortedWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_numbers(numbers: """") == """")
assert(sort_numbers(numbers: ""three"") == ""three"")
assert(sort_numbers(numbers: ""three five nine"") == ""three five nine"")
assert(sort_numbers(numbers: ""five zero four seven nine eight"") == ""zero four five seven eight nine"")
assert(sort_numbers(numbers: ""six five four three two one zero"") == ""zero one two three four five six"")"
HumanEval_20,bul_Cyrl,swift,"
// други и ги връща по ред (по-малък брой, по-голям брой).// От даден масив от числа (с дължина най-малко две) изберете и върнете две, които са най-близки до всеки /// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
func find_closest_elements(numbers: [Double]) -> (Double, Double) {
","func find_closest_elements(numbers: [Double]) -> (Double, Double) {
    // Sort the array to bring closest numbers next to each other
    let sortedNumbers = numbers.sorted()
    
    // Initialize variables to keep track of the smallest difference and the pair
    var minDifference = Double.greatestFiniteMagnitude
    var closestPair: (Double, Double) = (0.0, 0.0)
    
    // Iterate over the sorted numbers to find the smallest difference
    for i in 0..<sortedNumbers.count - 1 {
        let num1 = sortedNumbers[i]
        let num2 = sortedNumbers[i + 1]
        let difference = abs(num1 - num2)
        
        if difference < minDifference {
            minDifference = difference
            closestPair = (num1, num2)
        }
    }
    
    return closestPair
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))
assert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))
assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
HumanEval_21,bul_Cyrl,swift,"
// така че най-малкото число ще стане 0 и най-голямото ще стане 1 // При даден масив от числа (от поне два елемента), приложи линейна трансформация към този масив, /// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])
/// [0.0, 0.25, 0.5, 0.75, 1.0]
func rescale_to_unit(numbers: [Double]) -> [Double] {
","func rescale_to_unit(numbers: [Double]) -> [Double] {
    guard numbers.count > 1 else { return numbers }
    
    let minValue = numbers.min()!
    let maxValue = numbers.max()!
    let range = maxValue - minValue
    
    guard range != 0 else {
        return numbers.map { _ in 0.0 }
    }
    
    return numbers.map { ($0 - minValue) / range }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])
assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])
assert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])
assert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])
assert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
HumanEval_22,bul_Cyrl,swift,"
// Филтрирайте даден масив от всички SWIFTTHON стойности само за цели числа./// >>> filter_integers(values: [""a"", 3.14, 5])
/// [5]
/// >>> filter_integers(values: [1, 2, 3, ""abc"", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])
/// [1, 2, 3]
func filter_integers(values: [AnyHashable]) -> [Int] {
","func filter_integers(values: [AnyHashable]) -> [Int] {
    return values.compactMap { $0 as? Int }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])
assert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, ""adasd""]) == [4, 9])
assert(filter_integers(values: [3, ""c"", 3, 3, ""a"", ""b""]) == [3, 3, 3])"
HumanEval_23,bul_Cyrl,swift,"
// Връща дължината на дадения нисък /// >>> strlen(string: """")
/// 0
/// >>> strlen(string: ""abc"")
/// 3
func strlen(string: String) -> Int {
","func strlen(string: String) -> Int {
    return string.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strlen(string: """") == 0)
assert(strlen(string: ""x"") == 1)
assert(strlen(string: ""asdasnakj"") == 9)"
HumanEval_24,bul_Cyrl,swift,"
// За дадено число n, намери най-голямото число, което разделя равномерно n, по-малко от n /// >>> largest_divisor(n: 15)
/// 5
func largest_divisor(n: Int) -> Int {
","func largest_divisor(n: Int) -> Int {
    for i in stride(from: n / 2, to: 0, by: -1) {
        if n % i == 0 {
            return i
        }
    }
    return 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_divisor(n: 3) == 1)
assert(largest_divisor(n: 7) == 1)
assert(largest_divisor(n: 10) == 5)
assert(largest_divisor(n: 100) == 50)
assert(largest_divisor(n: 49) == 7)"
HumanEval_25,bul_Cyrl,swift,"
// Входящият номер трябва да е равен на произведението на всички фактори.// Всеки от факторите трябва да бъде подреден брой пъти, съответстващ на това колко пъти се появява в разчленяването.// Връща масив от прости фактори на дадено цяло число в ред от най-малкия до най-големия. /// >>> factorize(n: 8)
/// [2, 2, 2]
/// >>> factorize(n: 25)
/// [5, 5]
/// >>> factorize(n: 70)
/// [2, 5, 7]
func factorize(n: Int) -> [Int] {
","func factorize(n: Int) -> [Int] {
    guard n > 1 else { return [] }
    var number = n
    var factors: [Int] = []
    var divisor = 2
    
    while number >= divisor {
        while number % divisor == 0 {
            factors.append(divisor)
            number /= divisor
        }
        divisor += 1
    }
    
    return factors
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(factorize(n: 2) == [2])
assert(factorize(n: 4) == [2, 2])
assert(factorize(n: 8) == [2, 2, 2])
assert(factorize(n: 57) == [3, 19])
assert(factorize(n: 3249) == [3, 3, 19, 19])
assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])
assert(factorize(n: 20577) == [3, 19, 19, 19])
assert(factorize(n: 18) == [2, 3, 3])"
HumanEval_26,bul_Cyrl,swift,"
// Запази реда на елементите, както е в входната. // От масив от цели числа, премахнете всички елементи, които се появяват повече от веднъж./// >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])
/// [1, 3, 4]
func remove_duplicates(numbers: [Int]) -> [Int] {
","func remove_duplicates(numbers: [Int]) -> [Int] {
    var elementCount = [Int: Int]()
    for number in numbers {
        elementCount[number, default: 0] += 1
    }
    return numbers.filter { elementCount[$0] == 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])
assert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
HumanEval_27,bul_Cyrl,swift,"
// За даден низ, преобърнете малките букви в големи и големите в малки. /// >>> flip_case(string: ""Hello"")
/// ""hELLO""
func flip_case(string: String) -> String {
","func flip_case(string: String) -> String {
    return String(string.map { character in
        if character.isLowercase {
            return character.uppercased()
        } else if character.isUppercase {
            return character.lowercased()
        } else {
            return String(character)
        }
    }.joined())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: """") == """")
assert(flip_case(string: ""Hello!"") == ""hELLO!"")
assert(flip_case(string: ""These violent delights have violent ends"") == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")"
HumanEval_28,bul_Cyrl,swift,"
// Свържете масива от струни в една струна./// >>> concatenate(strings: [] as [String])
/// """"
/// >>> concatenate(strings: [""a"", ""b"", ""c""])
/// ""abc""
func concatenate(strings: [String]) -> String {
","func concatenate(strings: [String]) -> String {
    return strings.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(concatenate(strings: [] as [String]) == """")
assert(concatenate(strings: [""x"", ""y"", ""z""]) == ""xyz"")
assert(concatenate(strings: [""x"", ""y"", ""z"", ""w"", ""k""]) == ""xyzwk"")"
HumanEval_29,bul_Cyrl,swift,"
// Филтрира въведения масив от струни само за тези, които започват с даден префикс. /// >>> filter_by_prefix(strings: [] as [String], prefix: ""a"")
/// [] as [String]
/// >>> filter_by_prefix(strings: [""abc"", ""bcd"", ""cde"", ""array""], prefix: ""a"")
/// [""abc"", ""array""]
func filter_by_prefix(strings: [String], prefix: String) -> [String] {
","func filter_by_prefix(strings: [String], prefix: String) -> [String] {
    return strings.filter { $0.hasPrefix(prefix) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_prefix(strings: [] as [String], prefix: ""john"") == [] as [String])
assert(filter_by_prefix(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], prefix: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])"
HumanEval_30,bul_Cyrl,swift,"
// Връща само положителни числа в масива. /// >>> get_positive(l: [-1, 2, -4, 5, 6])
/// [2, 5, 6]
/// >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// [5, 3, 2, 3, 9, 123, 1]
func get_positive(l: [Int]) -> [Int] {
","func get_positive(l: [Int]) -> [Int] {
    return l.filter { $0 > 0 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])
assert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])
assert(get_positive(l: [-1, -2]) == [] as [Int])
assert(get_positive(l: [] as [Int]) == [] as [Int])"
HumanEval_31,bul_Cyrl,swift,"
// Връща true, ако дадено число е просто, и false в противен случай. /// >>> is_prime(n: 6)
/// false
/// >>> is_prime(n: 101)
/// true
/// >>> is_prime(n: 11)
/// true
/// >>> is_prime(n: 13441)
/// true
/// >>> is_prime(n: 61)
/// true
/// >>> is_prime(n: 4)
/// false
/// >>> is_prime(n: 1)
/// false
func is_prime(n: Int) -> Bool {
","func is_prime(n: Int) -> Bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    var i = 5
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_prime(n: 6) == false)
assert(is_prime(n: 101) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 13441) == true)
assert(is_prime(n: 61) == true)
assert(is_prime(n: 4) == false)
assert(is_prime(n: 1) == false)
assert(is_prime(n: 5) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 17) == true)
assert(is_prime(n: 85) == false)
assert(is_prime(n: 77) == false)
assert(is_prime(n: 255379) == false)"
HumanEval_33,bul_Cyrl,swift,"
// към стойностите на съответните индекси на l, но подредени. // l' е идентичен с l при индекси, които не са делими на три, докато стойностите му при индекси, които са делими на три, са равни // Тази функция приема масив l и връща масив l' такъв, че /// >>> sort_third(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])
/// [2, 6, 3, 4, 8, 9, 5]
func sort_third(l: [Int]) -> [Int] {
","func sort_third(l: [Int]) -> [Int] {
    // Collect indices and their values where index is divisible by 3
    var divisibleByThreeValues: [(index: Int, value: Int)] = []
    for (index, value) in l.enumerated() where index % 3 == 0 {
        divisibleByThreeValues.append((index, value))
    }
    
    // Sort the values that were at the indices divisible by 3
    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()
    
    // Create a mutable copy of original array to modify
    var result = l
    
    // Replace the sorted values back into their original indices
    for (i, sortedValue) in sortedValues.enumerated() {
        result[divisibleByThreeValues[i].index] = sortedValue
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])
assert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])
assert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"
HumanEval_34,bul_Cyrl,swift,"
// Връща сортирани уникални елементи в масив /// >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [0, 2, 3, 5, 9, 123]
func unique(l: [Int]) -> [Int] {
","func unique(l: [Int]) -> [Int] {
    return Array(Set(l)).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"
HumanEval_35,bul_Cyrl,swift,"
// Връща максималния елемент в масива. /// >>> max_element(l: [1, 2, 3])
/// 3
/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
func max_element(l: [Int]) -> Int {
","func max_element(l: [Int]) -> Int {
    guard let max = l.max() else {
        fatalError(""Array should not be empty"")
    }
    return max
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_element(l: [1, 2, 3]) == 3)
assert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
HumanEval_36,bul_Cyrl,swift,"
// Връща броя на пъти, в които цифрът 7 се появява в цели числа по-малки от n, които са делими на 11 или 13. /// >>> fizz_buzz(n: 50)
/// 0
/// >>> fizz_buzz(n: 78)
/// 2
/// >>> fizz_buzz(n: 79)
/// 3
func fizz_buzz(n: Int) -> Int {
","func fizz_buzz(n: Int) -> Int {
    var count = 0
    for number in 0..<n {
        if number % 11 == 0 || number % 13 == 0 {
            var current = number
            while current > 0 {
                if current % 10 == 7 {
                    count += 1
                }
                current /= 10
            }
        }
    }
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fizz_buzz(n: 50) == 0)
assert(fizz_buzz(n: 78) == 2)
assert(fizz_buzz(n: 79) == 3)
assert(fizz_buzz(n: 100) == 3)
assert(fizz_buzz(n: 200) == 6)
assert(fizz_buzz(n: 4000) == 192)
assert(fizz_buzz(n: 10000) == 639)
assert(fizz_buzz(n: 100000) == 8026)"
HumanEval_37,bul_Cyrl,swift,"
// към стойностите на четните индекси на l, но подредени. // l' е идентичен с l в нечетни показатели, докато стойностите му в четните показатели са равни // Тази функция приема масив l и връща масив l' такъв, че /// >>> sort_even(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_even(l: [5, 6, 3, 4])
/// [3, 6, 5, 4]
func sort_even(l: [Int]) -> [Int] {
","func sort_even(l: [Int]) -> [Int] {
    var evenIndicesValues = [Int]()
    
    // Collect values from even indices
    for (index, value) in l.enumerated() {
        if index % 2 == 0 {
            evenIndicesValues.append(value)
        }
    }
    
    // Sort the collected even indices values
    evenIndicesValues.sort()
    
    var result = l
    var evenIndex = 0
    
    // Replace even-indexed elements in result with sorted values
    for i in 0..<result.count {
        if i % 2 == 0 {
            result[i] = evenIndicesValues[evenIndex]
            evenIndex += 1
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])
assert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
HumanEval_39,bul_Cyrl,swift,"
// prime_fib връща n-то число, което е число на Фибоначи и също е просто число. /// >>> prime_fib(n: 1)
/// 2
/// >>> prime_fib(n: 2)
/// 3
/// >>> prime_fib(n: 3)
/// 5
/// >>> prime_fib(n: 4)
/// 13
/// >>> prime_fib(n: 5)
/// 89
func prime_fib(n: Int) -> Int {
","func isPrime(_ num: Int) -> Bool {
    if num <= 1 { return false }
    if num <= 3 { return true }
    if num % 2 == 0 || num % 3 == 0 { return false }
    var i = 5
    while i * i <= num {
        if num % i == 0 || num % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}

func generateFibonacci(n: Int) -> [Int] {
    var fibs = [1, 2]
    var next = fibs[0] + fibs[1]
    while fibs.count < n || !isPrime(next) {
        fibs.append(next)
        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]
    }
    return fibs
}

func prime_fib(n: Int) -> Int {
    var count = 0
    var fibs = generateFibonacci(n: n)
    for fib in fibs {
        if isPrime(fib) {
            count += 1
            if count == n {
                return fib
            }
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_fib(n: 1) == 2)
assert(prime_fib(n: 2) == 3)
assert(prime_fib(n: 3) == 5)
assert(prime_fib(n: 4) == 13)
assert(prime_fib(n: 5) == 89)
assert(prime_fib(n: 6) == 233)
assert(prime_fib(n: 7) == 1597)
assert(prime_fib(n: 8) == 28657)
assert(prime_fib(n: 9) == 514229)
assert(prime_fib(n: 10) == 433494437)"
HumanEval_40,bul_Cyrl,swift,"
// с нулева сума, и фалшиво в останалите случаи. // връща true, ако има три различни елемента в масива, които // triples_sum_to_zero приема масив от цели числа като вход. /// >>> triples_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(l: [1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(l: [1])
/// false
func triples_sum_to_zero(l: [Int]) -> Bool {
","func triples_sum_to_zero(l: [Int]) -> Bool {
    let count = l.count
    if count < 3 {
        return false
    }
    
    let sortedArray = l.sorted()
    
    for i in 0..<count - 2 {
        var left = i + 1
        var right = count - 1
        
        while left < right {
            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]
            if currentSum == 0 {
                return true
            } else if currentSum < 0 {
                left += 1
            } else {
                right -= 1
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)
assert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)
assert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)
assert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)
assert(triples_sum_to_zero(l: [1]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)
assert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"
HumanEval_41,bul_Cyrl,swift,"
// Тази функция дава на изход броя на такива сблъсъци. // в траекторията си, сякаш не са се сблъскали. Но колите са безкрайно здрави и силни, в резултат на което продължават да се движат.Когато кола, която се движи от ляво на дясно, се блъска в кола, която се движи от дясно на ляво.Всички коли се движат със същата скорост.Двете коли започват да се движат много далеч от ъгъла.// n коли се движат отляво надясно; едновременно, различен набор от n коли Представете си път, който е перфектно права безкрайно дълга линия.func car_race_collision(n: Int) -> Int {
","func car_race_collision(n: Int) -> Int {
    return n
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(car_race_collision(n: 2) == 4)
assert(car_race_collision(n: 3) == 9)
assert(car_race_collision(n: 4) == 16)
assert(car_race_collision(n: 8) == 64)
assert(car_race_collision(n: 10) == 100)"
HumanEval_42,bul_Cyrl,swift,"
// Връща масив с елементи, увеличени с 1./// >>> incr_list(l: [1, 2, 3])
/// [2, 3, 4]
/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [6, 4, 6, 3, 4, 4, 10, 1, 124]
func incr_list(l: [Int]) -> [Int] {
","func incr_list(l: [Int]) -> [Int] {
    return l.map { $0 + 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(incr_list(l: [] as [Int]) == [] as [Int])
assert(incr_list(l: [3, 2, 1]) == [4, 3, 2])
assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
HumanEval_43,bul_Cyrl,swift,"
// с нулева сума, и фалшиво в останалите случаи. // връща true, ако има два различни елемента в масива, които // pairs_sum_to_zero приема масив от цели числа като вход. /// >>> pairs_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(l: [1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(l: [1])
/// false
func pairs_sum_to_zero(l: [Int]) -> Bool {
","func pairs_sum_to_zero(l: [Int]) -> Bool {
    var set = Set<Int>()
    for num in l {
        if set.contains(-num) {
            return true
        }
        set.insert(num)
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)
assert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)
assert(pairs_sum_to_zero(l: [1]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"
HumanEval_44,bul_Cyrl,swift,"
// числата на основата са по-малки от 10. // връща струнно представяне след преобразуването. // Променете числовата основа на входния номер x на база. /// >>> change_base(x: 8, base: 3)
/// ""22""
/// >>> change_base(x: 8, base: 2)
/// ""1000""
/// >>> change_base(x: 7, base: 2)
/// ""111""
func change_base(x: Int, base: Int) -> String {
","func change_base(x: Int, base: Int) -> String {
    guard base > 1 && base < 10 else {
        return """"
    }
    
    var number = x
    var result = """"
    
    repeat {
        let remainder = number % base
        result = ""\(remainder)"" + result
        number /= base
    } while number > 0
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(change_base(x: 8, base: 3) == ""22"")
assert(change_base(x: 9, base: 3) == ""100"")
assert(change_base(x: 234, base: 2) == ""11101010"")
assert(change_base(x: 16, base: 2) == ""10000"")
assert(change_base(x: 8, base: 2) == ""1000"")
assert(change_base(x: 7, base: 2) == ""111"")
assert(change_base(x: 2, base: 3) == ""2"")
assert(change_base(x: 3, base: 4) == ""3"")
assert(change_base(x: 4, base: 5) == ""4"")
assert(change_base(x: 5, base: 6) == ""5"")
assert(change_base(x: 6, base: 7) == ""6"")
assert(change_base(x: 7, base: 8) == ""7"")"
HumanEval_45,bul_Cyrl,swift,"
// При условие, че има дължина на страницата и висока повратна площ за триъгълник. /// >>> triangle_area(a: 5, h: 3)
/// 7.5
func triangle_area(a: Int, h: Int) -> Double {
","func triangle_area(a: Int, h: Int) -> Double {
    return 0.5 * Double(a) * Double(h)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 5, h: 3) == 7.5)
assert(triangle_area(a: 2, h: 2) == 2.0)
assert(triangle_area(a: 10, h: 8) == 40.0)"
HumanEval_46,bul_Cyrl,swift,"
// Моля, напишете функция, за да изчислите ефективно n-тия елемент от последователността от числа fib4.// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). // fib4(3) -> 0 - Да, сър.// fib4(1) -> 0 // fib4(0) -> 0 // Fib4 последователността е последователност, подобна на последователността на Фибоначи, която е дефинирана по следния начин: /// >>> fib4(n: 5)
/// 4
/// >>> fib4(n: 6)
/// 8
/// >>> fib4(n: 7)
/// 14
func fib4(n: Int) -> Int {
","func fib4(n: Int) -> Int {
    if n == 0 || n == 1 || n == 3 {
        return 0
    } else if n == 2 {
        return 2
    }
    
    var fibs = [0, 0, 2, 0]
    
    for i in 4...n {
        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]
        fibs.append(nextFib)
    }
    
    return fibs[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib4(n: 5) == 4)
assert(fib4(n: 8) == 28)
assert(fib4(n: 10) == 104)
assert(fib4(n: 12) == 386)"
HumanEval_47,bul_Cyrl,swift,"
// Връща медиана на елементите в масива l. /// >>> median(l: [3, 1, 2, 4, 5])
/// 3
/// >>> median(l: [-10, 4, 6, 1000, 10, 20])
/// 15.0
func median(l: [Int]) -> Double {
","func median(l: [Int]) -> Double {
    let sorted = l.sorted()
    let count = sorted.count
    if count % 2 == 0 {
        return Double(sorted[count / 2 - 1] + sorted[count / 2]) / 2.0
    } else {
        return Double(sorted[count / 2])
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(median(l: [3, 1, 2, 4, 5]) == 3)
assert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)
assert(median(l: [5]) == 5)
assert(median(l: [6, 5]) == 5.5)
assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
HumanEval_48,bul_Cyrl,swift,"
// Проверява дали даденият ред е палиндром./// >>> is_palindrome(text: """")
/// true
/// >>> is_palindrome(text: ""aba"")
/// true
/// >>> is_palindrome(text: ""aaaaa"")
/// true
/// >>> is_palindrome(text: ""zbcd"")
/// false
func is_palindrome(text: String) -> Bool {
","func is_palindrome(text: String) -> Bool {
    return text == String(text.reversed())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: """") == true)
assert(is_palindrome(text: ""aba"") == true)
assert(is_palindrome(text: ""aaaaa"") == true)
assert(is_palindrome(text: ""zbcd"") == false)
assert(is_palindrome(text: ""xywyx"") == true)
assert(is_palindrome(text: ""xywyz"") == false)
assert(is_palindrome(text: ""xywzx"") == false)"
HumanEval_49,bul_Cyrl,swift,"
// Връща 2^n модул p (съзнавайте числовите знаци). /// >>> modp(n: 3, p: 5)
/// 3
/// >>> modp(n: 1101, p: 101)
/// 2
/// >>> modp(n: 0, p: 101)
/// 1
/// >>> modp(n: 3, p: 11)
/// 8
/// >>> modp(n: 100, p: 101)
/// 1
func modp(n: Int, p: Int) -> Int {
","func modp(n: Int, p: Int) -> Int {
    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(modp(n: 3, p: 5) == 3)
assert(modp(n: 1101, p: 101) == 2)
assert(modp(n: 0, p: 101) == 1)
assert(modp(n: 3, p: 11) == 8)
assert(modp(n: 100, p: 101) == 1)
assert(modp(n: 30, p: 5) == 4)
assert(modp(n: 31, p: 5) == 3)"
HumanEval_51,bul_Cyrl,swift,"
// remove_vowels е функция, която взема string и връща string без гласни. /// >>> remove_vowels(text: """")
/// """"
/// >>> remove_vowels(text: ""abcdef"")
/// ""bcdf""
/// >>> remove_vowels(text: ""aaaaa"")
/// """"
/// >>> remove_vowels(text: ""aaBAA"")
/// ""B""
/// >>> remove_vowels(text: ""zbcd"")
/// ""zbcd""
func remove_vowels(text: String) -> String {
","func remove_vowels(text: String) -> String {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    return String(text.filter { !vowels.contains($0) })
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_vowels(text: """") == """")
assert(remove_vowels(text: ""abcdef\nghijklm"") == ""bcdf\nghjklm"")
assert(remove_vowels(text: ""fedcba"") == ""fdcb"")
assert(remove_vowels(text: ""eeeee"") == """")
assert(remove_vowels(text: ""acBAA"") == ""cB"")
assert(remove_vowels(text: ""EcBOO"") == ""cB"")
assert(remove_vowels(text: ""ybcd"") == ""ybcd"")"
HumanEval_52,bul_Cyrl,swift,"
// Връща true, ако всички числа в масива l са под праг t. /// >>> below_threshold(l: [1, 2, 4, 10], t: 100)
/// true
/// >>> below_threshold(l: [1, 20, 4, 10], t: 5)
/// false
func below_threshold(l: [Int], t: Int) -> Bool {
","func below_threshold(l: [Int], t: Int) -> Bool {
    for number in l {
        if number >= t {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)
assert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"
HumanEval_53,bul_Cyrl,swift,"
// Събираме две числа x и y /// >>> add(x: 2, y: 3)
/// 5
/// >>> add(x: 5, y: 7)
/// 12
func add(x: Int, y: Int) -> Int {
","func add(x: Int, y: Int) -> Int {
    return x + y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(x: 0, y: 1) == 1)
assert(add(x: 1, y: 0) == 1)
assert(add(x: 2, y: 3) == 5)
assert(add(x: 5, y: 7) == 12)
assert(add(x: 7, y: 5) == 12)"
HumanEval_54,bul_Cyrl,swift,"
// Проверете дали две думи имат едни и същи знаци. /// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"")
/// true
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabc"")
/// true
/// >>> same_chars(s0: ""dddddddabc"", s1: ""abcd"")
/// true
/// >>> same_chars(s0: ""eabcd"", s1: ""dddddddabc"")
/// false
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabce"")
/// false
/// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"")
/// false
func same_chars(s0: String, s1: String) -> Bool {
","func same_chars(s0: String, s1: String) -> Bool {
    let set0 = Set(s0)
    let set1 = Set(s1)
    return set0 == set1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"") == true)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabc"") == true)
assert(same_chars(s0: ""dddddddabc"", s1: ""abcd"") == true)
assert(same_chars(s0: ""eabcd"", s1: ""dddddddabc"") == false)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabcf"") == false)
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"") == false)
assert(same_chars(s0: ""aabb"", s1: ""aaccc"") == false)"
HumanEval_55,bul_Cyrl,swift,"
// Връща n-то число на Фибоначи. /// >>> fib(n: 10)
/// 55
/// >>> fib(n: 1)
/// 1
/// >>> fib(n: 8)
/// 21
func fib(n: Int) -> Int {
","func fib(n: Int) -> Int {
    if n <= 0 {
        return 0
    } else if n == 1 {
        return 1
    }
    
    var a = 0
    var b = 1
    for _ in 2...n {
        let temp = a + b
        a = b
        b = temp
    }
    return b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib(n: 10) == 55)
assert(fib(n: 1) == 1)
assert(fib(n: 8) == 21)
assert(fib(n: 11) == 89)
assert(fib(n: 12) == 144)"
HumanEval_56,bul_Cyrl,swift,"
// връща true, ако всяка отваряща скоба има съответстваща затваряща скоба. // скоби е низ от ""<"" и "">"". /// >>> correct_bracketing(brackets: ""<"")
/// false
/// >>> correct_bracketing(brackets: ""<>"")
/// true
/// >>> correct_bracketing(brackets: ""<<><>>"")
/// true
/// >>> correct_bracketing(brackets: ""><<>"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    
    for bracket in brackets {
        if bracket == ""<"" {
            balance += 1
        } else if bracket == "">"" {
            balance -= 1
            if balance < 0 {
                return false
            }
        }
    }
    
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""<>"") == true)
assert(correct_bracketing(brackets: ""<<><>>"") == true)
assert(correct_bracketing(brackets: ""<><><<><>><>"") == true)
assert(correct_bracketing(brackets: ""<><><<<><><>><>><<><><<>>>"") == true)
assert(correct_bracketing(brackets: ""<<<><>>>>"") == false)
assert(correct_bracketing(brackets: ""><<>"") == false)
assert(correct_bracketing(brackets: ""<"") == false)
assert(correct_bracketing(brackets: ""<<<<"") == false)
assert(correct_bracketing(brackets: "">"") == false)
assert(correct_bracketing(brackets: ""<<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>><<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>>><>"") == false)"
HumanEval_57,bul_Cyrl,swift,"
// Връща true, ако елементите на масива се увеличават или намаляват монотонно. /// >>> monotonic(l: [1, 2, 4, 20])
/// true
/// >>> monotonic(l: [1, 20, 4, 10])
/// false
/// >>> monotonic(l: [4, 1, 0, -10])
/// true
func monotonic(l: [Int]) -> Bool {
","func monotonic(l: [Int]) -> Bool {
    guard l.count > 1 else {
        return true
    }
    
    var increasing = true
    var decreasing = true
    
    for i in 1..<l.count {
        if l[i] > l[i - 1] {
            decreasing = false
        } else if l[i] < l[i - 1] {
            increasing = false
        }
    }
    
    return increasing || decreasing
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(monotonic(l: [1, 2, 4, 10]) == true)
assert(monotonic(l: [1, 2, 4, 20]) == true)
assert(monotonic(l: [1, 20, 4, 10]) == false)
assert(monotonic(l: [4, 1, 0, -10]) == true)
assert(monotonic(l: [4, 1, 1, 0]) == true)
assert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)
assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)
assert(monotonic(l: [9, 9, 9, 9]) == true)"
HumanEval_58,bul_Cyrl,swift,"
// Връща сортирани уникални общи елементи за два масива. /// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])
/// [1, 5, 653]
/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])
/// [2, 3]
func common(l1: [Int], l2: [Int]) -> [Int] {
","func common(l1: [Int], l2: [Int]) -> [Int] {
    let set1 = Set(l1)
    let set2 = Set(l2)
    let commonElements = set1.intersection(set2)
    return Array(commonElements).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])
assert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])
assert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])
assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
HumanEval_59,bul_Cyrl,swift,"
// Връща най-големия прост коефициент на n. Приемаме, че n > 1 и не е прост. /// >>> largest_prime_factor(n: 13195)
/// 29
/// >>> largest_prime_factor(n: 2048)
/// 2
func largest_prime_factor(n: Int) -> Int {
","func largest_prime_factor(n: Int) -> Int {
    var number = n
    var divisor = 2
    
    while number > 1 {
        if number % divisor == 0 {
            number /= divisor
        } else {
            divisor += 1
        }
    }
    
    return divisor
}

// Example usage:
// print(largest_prime_factor(n: 13195)) // Output: 29
// print(largest_prime_factor(n: 2048))  // Output: 2","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_prime_factor(n: 15) == 5)
assert(largest_prime_factor(n: 27) == 3)
assert(largest_prime_factor(n: 63) == 7)
assert(largest_prime_factor(n: 330) == 11)
assert(largest_prime_factor(n: 13195) == 29)"
HumanEval_60,bul_Cyrl,swift,"
// sum_to_n е функция, която събира числа от 1 до n. /// >>> sum_to_n(n: 30)
/// 465
/// >>> sum_to_n(n: 100)
/// 5050
/// >>> sum_to_n(n: 5)
/// 15
/// >>> sum_to_n(n: 10)
/// 55
/// >>> sum_to_n(n: 1)
/// 1
func sum_to_n(n: Int) -> Int {
","func sum_to_n(n: Int) -> Int {
    return (n * (n + 1)) / 2
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_to_n(n: 1) == 1)
assert(sum_to_n(n: 6) == 21)
assert(sum_to_n(n: 11) == 66)
assert(sum_to_n(n: 30) == 465)
assert(sum_to_n(n: 100) == 5050)"
HumanEval_61,bul_Cyrl,swift,"
// връща true, ако всяка отваряща скоба има съответстваща затваряща скоба. // скоби е низ от ""("" и "")"". /// >>> correct_bracketing(brackets: ""("")
/// false
/// >>> correct_bracketing(brackets: ""()"")
/// true
/// >>> correct_bracketing(brackets: ""(()())"")
/// true
/// >>> correct_bracketing(brackets: "")(()"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    for char in brackets {
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""()"") == true)
assert(correct_bracketing(brackets: ""(()())"") == true)
assert(correct_bracketing(brackets: ""()()(()())()"") == true)
assert(correct_bracketing(brackets: ""()()((()()())())(()()(()))"") == true)
assert(correct_bracketing(brackets: ""((()())))"") == false)
assert(correct_bracketing(brackets: "")(()"") == false)
assert(correct_bracketing(brackets: ""("") == false)
assert(correct_bracketing(brackets: ""(((("") == false)
assert(correct_bracketing(brackets: "")"") == false)
assert(correct_bracketing(brackets: ""(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())())(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())()))()"") == false)"
HumanEval_62,bul_Cyrl,swift,"
// Връща производна на този полином в същата форма. // xs[0] + xs[1] * x + xs[2] * x^2 + .... // xs представляват коефициенти на полином. /// >>> derivative(xs: [3, 1, 2, 4, 5])
/// [1, 4, 12, 20]
/// >>> derivative(xs: [1, 2, 3])
/// [2, 6]
func derivative(xs: [Int]) -> [Int] {
","func derivative(xs: [Int]) -> [Int] {
    guard xs.count > 1 else { return [] }
    var result: [Int] = []
    for i in 1..<xs.count {
        result.append(xs[i] * i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])
assert(derivative(xs: [1, 2, 3]) == [2, 6])
assert(derivative(xs: [3, 2, 1]) == [2, 2])
assert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])
assert(derivative(xs: [1]) == [] as [Int])"
HumanEval_63,bul_Cyrl,swift,"
// Моля напишете функция за ефективно изчисляване на n-тия елемент от последователността от числа fibfib. // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). - Да, сър.- Да, сър.- Да, сър.// FibFib последователност е последователност, подобна на последователността на Фибоначи, която се дефинира по следния начин: /// >>> fibfib(n: 1)
/// 0
/// >>> fibfib(n: 5)
/// 4
/// >>> fibfib(n: 8)
/// 24
func fibfib(n: Int) -> Int {
","func fibfib(n: Int) -> Int {
    if n == 0 || n == 1 {
        return 0
    }
    if n == 2 {
        return 1
    }
    
    var fibfibNums = [0, 0, 1]
    
    for i in 3...n {
        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]
        fibfibNums.append(nextFibFib)
    }
    
    return fibfibNums[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fibfib(n: 2) == 1)
assert(fibfib(n: 1) == 0)
assert(fibfib(n: 5) == 4)
assert(fibfib(n: 8) == 24)
assert(fibfib(n: 10) == 81)
assert(fibfib(n: 12) == 274)
assert(fibfib(n: 14) == 927)"
HumanEval_64,bul_Cyrl,swift,"
// Пример: // гласна, но само когато е в края на дадена дума. В този случай гласниците са ""а"", ""е"", ""и"", ""о"", ""у"".// дума като вход и връща броя на гласниците в струната. // Напишете функция vowels_count, която приема буквен /// >>> vowels_count(s: ""abcde"")
/// 2
/// >>> vowels_count(s: ""ACEDY"")
/// 3
func vowels_count(s: String) -> Int {
","func vowels_count(s: String) -> Int {
    guard !s.isEmpty else { return 0 }
    
    let vowels = Set(""aeiouAEIOU"")
    var count = 0
    let characters = Array(s)
    
    for i in 0..<characters.count {
        let char = characters[i]
        
        if vowels.contains(char) {
            count += 1
        } else if char == ""y"" || char == ""Y"" {
            if i == characters.count - 1 {
                count += 1
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(vowels_count(s: ""abcde"") == 2)
assert(vowels_count(s: ""Alone"") == 3)
assert(vowels_count(s: ""key"") == 2)
assert(vowels_count(s: ""bye"") == 1)
assert(vowels_count(s: ""keY"") == 2)
assert(vowels_count(s: ""bYe"") == 1)
assert(vowels_count(s: ""ACEDY"") == 3)"
HumanEval_65,bul_Cyrl,swift,"
// Ако shift > брой цифри, връща цифри с обратна посока. // и връща резултата като низ. // Кръжно изместване на цифри на цело число x, изместване на цифри надясно с преместване /// >>> circular_shift(x: 12, shift: 1)
/// ""21""
/// >>> circular_shift(x: 12, shift: 2)
/// ""12""
func circular_shift(x: Int, shift: Int) -> String {
","func circular_shift(x: Int, shift: Int) -> String {
    let digits = Array(String(x))
    let count = digits.count
    
    // If shift is greater than the number of digits, return the digits reversed
    if shift >= count {
        return String(digits.reversed())
    }
    
    // Calculate the actual shift needed by using modulo operation
    let actualShift = shift % count
    
    // Perform the circular shift to the right
    let splitIndex = count - actualShift
    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]
    
    return String(shiftedDigits)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(circular_shift(x: 100, shift: 2) == ""001"")
assert(circular_shift(x: 12, shift: 2) == ""12"")
assert(circular_shift(x: 97, shift: 8) == ""79"")
assert(circular_shift(x: 12, shift: 1) == ""21"")
assert(circular_shift(x: 11, shift: 101) == ""11"")"
HumanEval_66,bul_Cyrl,swift,"
// Примери: // ASCII кодове. // Напишете функция, която приема низ от букви като вход и връща само сумата на горните знаци.- Задача./// >>> digitSum(s: """")
/// 0
/// >>> digitSum(s: ""abAB"")
/// 131
/// >>> digitSum(s: ""abcCd"")
/// 67
/// >>> digitSum(s: ""helloE"")
/// 69
/// >>> digitSum(s: ""woArBld"")
/// 131
/// >>> digitSum(s: ""aAaaaXa"")
/// 153
func digitSum(s: String) -> Int {
","func digitSum(s: String) -> Int {
    var sum = 0
    for character in s {
        if character.isUppercase {
            sum += Int(character.asciiValue ?? 0)
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: """") == 0)
assert(digitSum(s: ""abAB"") == 131)
assert(digitSum(s: ""abcCd"") == 67)
assert(digitSum(s: ""helloE"") == 69)
assert(digitSum(s: ""woArBld"") == 131)
assert(digitSum(s: ""aAaaaXa"") == 153)
assert(digitSum(s: "" How are yOu?"") == 151)
assert(digitSum(s: ""You arE Very Smart"") == 327)"
HumanEval_67,bul_Cyrl,swift,"
- За какво?// в кошчето връща броя на плодовете от мангото в кошчето. Портокалите и ябълките и цяло число, което представлява общия брой плодове.// ябълки, портокали и манго.// които са разпределени в кошница с плодове, която тази кошница съдържа.// В тази задача, ще ви бъде дадена верига, която представлява брой ябълки и портокали./// >>> fruit_distribution(s: ""5 apples and 6 oranges"", n: 19)
/// 8
/// >>> fruit_distribution(s: ""0 apples and 1 oranges"", n: 3)
/// 2
/// >>> fruit_distribution(s: ""2 apples and 3 oranges"", n: 100)
/// 95
/// >>> fruit_distribution(s: ""100 apples and 1 oranges"", n: 120)
/// 19
func fruit_distribution(s: String, n: Int) -> Int {
","func fruit_distribution(s: String, n: Int) -> Int {
    let components = s.components(separatedBy: "" "")
    var apples = 0
    var oranges = 0
    
    for (index, component) in components.enumerated() {
        if component == ""apples"" || component == ""apple"" {
            if let number = Int(components[index - 1]) {
                apples = number
            }
        } else if component == ""oranges"" || component == ""orange"" {
            if let number = Int(components[index - 1]) {
                oranges = number
            }
        }
    }
    
    let totalApplesOranges = apples + oranges
    let mangoes = n - totalApplesOranges
    return mangoes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 19) == 8)
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 21) == 10)
assert(fruit_distribution(s: ""0 apples and 1 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""1 apples and 0 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 100) == 95)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 5) == 0)
assert(fruit_distribution(s: ""1 apples and 100 oranges"", n: 120) == 19)"
HumanEval_68,bul_Cyrl,swift,"
// Пример 1: // Ако няма четни стойности или даденият масив е празен, връщаме []. // Изваденото възело трябва да бъде върнато в масив, [ smalest_value, неговия индекс ], // Ако се намерят няколко възела с една и съща най-малка четна стойност, върнете възела с най-малък индекс. // Изтръгнатият възел трябва да е възелът с най-малката четна стойност. // Вашата задача е да извадите един от възелите и да го върнете. // ""Дан низа, представляваща клон на дърво, което има неотрицателни цели числа възли /// >>> pluck(arr: [4, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(arr: [1, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(arr: [] as [Int])
/// [] as [Int]
/// Example 4:
/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])
/// [0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
func pluck(arr: [Int]) -> [Int] {
","func pluck(arr: [Int]) -> [Int] {
    var smallestEvenValue: Int? = nil
    var smallestIndex: Int? = nil

    for (index, value) in arr.enumerated() {
        if value % 2 == 0 {
            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {
                smallestEvenValue = value
                smallestIndex = index
            }
        }
    }

    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {
        return [smallestEvenValue, smallestIndex]
    } else {
        return []
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pluck(arr: [4, 2, 3]) == [2, 1])
assert(pluck(arr: [1, 2, 3]) == [2, 1])
assert(pluck(arr: [] as [Int]) == [] as [Int])
assert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])
assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])
assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])
assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])
assert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
HumanEval_69,bul_Cyrl,swift,"
// Примери: // Ако такава стойност не съществува, връщаме -1. // Честотата на едно цяло число е броят пъти, в които се появява в масива. // нула, и има честота по-голяма или равна на стойността на самия цял брой. // Във всеки масив от положителни цели числа, който е по-голям от /// >>> search(lst: [4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(lst: [5, 5, 4, 4, 4])
/// -1
func search(lst: [Int]) -> Int {
","func search(lst: [Int]) -> Int {
    var frequencyMap = [Int: Int]()
    
    // Count frequencies of each number in the list
    for number in lst {
        frequencyMap[number, default: 0] += 1
    }
    
    var result = -1
    
    // Iterate through the frequency map to find the greatest integer that satisfies the condition
    for (number, frequency) in frequencyMap {
        if frequency >= number {
            result = max(result, number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(search(lst: [5, 5, 5, 5, 1]) == 1)
assert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)
assert(search(lst: [3, 3]) == -1)
assert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)
assert(search(lst: [2, 3, 3, 2, 2]) == 2)
assert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)
assert(search(lst: [3, 2, 8, 2]) == 2)
assert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)
assert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)
assert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)
assert(search(lst: [1, 9, 10, 1, 3]) == 1)
assert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)
assert(search(lst: [1]) == 1)
assert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)
assert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)
assert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)
assert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)
assert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)
assert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)
assert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)
assert(search(lst: [10]) == -1)
assert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)
assert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)
assert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)
assert(search(lst: [3, 10, 10, 9, 2]) == -1)"
HumanEval_70,bul_Cyrl,swift,"
// Примери: // след това максимум от останалите цели числа, след това минимум и така нататък. // Странно сортиране, е когато започнете с минималната стойност, // При даден масив от цели числа, връща масив в странен ред./// >>> strange_sort_list(lst: [1, 2, 3, 4])
/// [1, 4, 2, 3]
/// >>> strange_sort_list(lst: [5, 5, 5, 5])
/// [5, 5, 5, 5]
/// >>> strange_sort_list(lst: [] as [Int])
/// [] as [Int]
func strange_sort_list(lst: [Int]) -> [Int] {
","func strange_sort_list(lst: [Int]) -> [Int] {
    var sortedList = lst.sorted()
    var result: [Int] = []
    
    while !sortedList.isEmpty {
        if let min = sortedList.first {
            result.append(min)
            sortedList.removeFirst()
        }
        
        if let max = sortedList.last {
            result.append(max)
            sortedList.removeLast()
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])
assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])
assert(strange_sort_list(lst: [] as [Int]) == [] as [Int])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])
assert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])
assert(strange_sort_list(lst: [111111]) == [111111])"
HumanEval_71,bul_Cyrl,swift,"
// Пример: // от третата страна. // Три страни правят валиден триъгълник, когато сумата на всякакви две страни е по-голяма.// В противен случай връща -1 // триъгълникът закръглен до 2 десетични точки, ако трите страни образуват валиден триъгълник. // Като се вземат дължините на трите страни на триъгълник, да се върне площта на /// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
","func triangle_area(a: Int, b: Int, c: Int) -> Double {
    // Check if the sides form a valid triangle
    if a + b > c && a + c > b && b + c > a {
        // Calculate the semi-perimeter
        let s = Double(a + b + c) / 2.0
        // Calculate the area using Heron's formula
        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
        // Round to 2 decimal places
        return round(area * 100) / 100
    } else {
        return -1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)"
HumanEval_72,bul_Cyrl,swift,"
// Пример: // Обектът q ще лети, ако е балансиран (това е палиндромен масив) и сумата от елементите му е по-малка или равна на максимално възможното тегло w. // Напишете функция, която връща true, ако обект q ще лети, и false в противен случай. /// >>> will_it_fly(q: [1, 2], w: 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(q: [3, 2, 3], w: 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(q: [3, 2, 3], w: 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(q: [3], w: 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q: [Int], w: Int) -> Bool {
","func will_it_fly(q: [Int], w: Int) -> Bool {
    func isPalindromic(_ array: [Int]) -> Bool {
        return array == array.reversed()
    }
    
    let sum = q.reduce(0, +)
    return isPalindromic(q) && sum <= w
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(will_it_fly(q: [3, 2, 3], w: 9) == true)
assert(will_it_fly(q: [1, 2], w: 5) == false)
assert(will_it_fly(q: [3], w: 5) == true)
assert(will_it_fly(q: [3, 2, 3], w: 1) == false)
assert(will_it_fly(q: [1, 2, 3], w: 6) == false)
assert(will_it_fly(q: [5], w: 5) == true)"
HumanEval_73,bul_Cyrl,swift,"
Например:// се чете еднакво напред и назад. В една промяна можете да промените един елемент в друг елемент.Палиндромният масив е масив, който // При дадена матрица arr от цели числа, намерите минималния брой елементи, които /// >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(arr: [1, 2, 3, 2, 1])
/// 0
func smallest_change(arr: [Int]) -> Int {
","func smallest_change(arr: [Int]) -> Int {
    var changes = 0
    let n = arr.count

    for i in 0..<(n / 2) {
        if arr[i] != arr[n - i - 1] {
            changes += 1
        }
    }

    return changes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)
assert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)
assert(smallest_change(arr: [1, 4, 2]) == 1)
assert(smallest_change(arr: [1, 4, 4, 2]) == 1)
assert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)
assert(smallest_change(arr: [3, 1, 1, 3]) == 0)
assert(smallest_change(arr: [1]) == 0)
assert(smallest_change(arr: [0, 1]) == 1)"
HumanEval_74,bul_Cyrl,swift,"
// Примери // ако двата масива имат същия брой символи, връща първия масив. // общият брой на символите във всички стрии на масива е по-малък от другия масив. // Напишете функция, която приема два масива от струнки и връща масив, който има /// >>> total_match(lst1: [] as [String], lst2: [] as [String])
/// [] as [String]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""])
/// [""hI"", ""Hi""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""])
/// [""hi"", ""admin""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""])
/// [""hI"", ""hi"", ""hi""]
/// >>> total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""])
/// [""4""]
func total_match(lst1: [String], lst2: [String]) -> [String] {
","func total_match(lst1: [String], lst2: [String]) -> [String] {
    let totalChars1 = lst1.reduce(0) { $0 + $1.count }
    let totalChars2 = lst2.reduce(0) { $0 + $1.count }
    
    if totalChars1 < totalChars2 {
        return lst1
    } else if totalChars2 < totalChars1 {
        return lst2
    } else {
        return lst1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi""]) == [""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""]) == [""hi"", ""admin""])
assert(total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""]) == [""4""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""]) == [""hI"", ""Hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""]) == [""hI"", ""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hii""]) == [""hi"", ""admin""])
assert(total_match(lst1: [] as [String], lst2: [""this""]) == [] as [String])
assert(total_match(lst1: [""this""], lst2: [] as [String]) == [] as [String])"
HumanEval_75,bul_Cyrl,swift,"
// Пример: // Знаейки, че (a) е по-малко от 100. // и фалшиви в противен случай. // Напишете функция, която връща true, ако даденото число е умножение на 3 прости числа./// >>> is_multiply_prime(a: 30)
/// true
/// 30 = 2 * 3 * 5
func is_multiply_prime(a: Int) -> Bool {
","func is_multiply_prime(a: Int) -> Bool {
    // Function to check if a number is prime
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Generate all prime numbers less than 100
    var primes = [Int]()
    for i in 2..<100 {
        if isPrime(i) {
            primes.append(i)
        }
    }
    
    // Check combinations of 3 primes
    let primeCount = primes.count
    for i in 0..<primeCount {
        for j in i..<primeCount {
            for k in j..<primeCount {
                if primes[i] * primes[j] * primes[k] == a {
                    return true
                }
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_multiply_prime(a: 5) == false)
assert(is_multiply_prime(a: 30) == true)
assert(is_multiply_prime(a: 8) == true)
assert(is_multiply_prime(a: 10) == false)
assert(is_multiply_prime(a: 125) == true)
assert(is_multiply_prime(a: 105) == true)
assert(is_multiply_prime(a: 126) == false)
assert(is_multiply_prime(a: 729) == false)
assert(is_multiply_prime(a: 891) == false)
assert(is_multiply_prime(a: 1001) == true)"
HumanEval_76,bul_Cyrl,swift,"
Например:// x е проста степен на n, ако n**int=x // степен на n и фалшива в други случаи. // Вашата задача е да напишете функция, която връща true, ако числото x е просто /// >>> is_simple_power(x: 1, n: 4)
/// true
/// >>> is_simple_power(x: 2, n: 2)
/// true
/// >>> is_simple_power(x: 8, n: 2)
/// true
/// >>> is_simple_power(x: 3, n: 2)
/// false
/// >>> is_simple_power(x: 3, n: 1)
/// false
/// >>> is_simple_power(x: 5, n: 3)
/// false
func is_simple_power(x: Int, n: Int) -> Bool {
","func is_simple_power(x: Int, n: Int) -> Bool {
    if x < 1 || n < 1 {
        return false
    }
    if x == 1 {
        return true // n**0 = 1
    }
    var power = 1
    while power < x {
        power *= n
    }
    return power == x
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_simple_power(x: 16, n: 2) == true)
assert(is_simple_power(x: 143214, n: 16) == false)
assert(is_simple_power(x: 4, n: 2) == true)
assert(is_simple_power(x: 9, n: 3) == true)
assert(is_simple_power(x: 16, n: 4) == true)
assert(is_simple_power(x: 24, n: 2) == false)
assert(is_simple_power(x: 128, n: 4) == false)
assert(is_simple_power(x: 12, n: 6) == false)
assert(is_simple_power(x: 1, n: 1) == true)
assert(is_simple_power(x: 1, n: 12) == true)"
HumanEval_77,bul_Cyrl,swift,"
// Примери: // Забележка: може да приемете, че входът винаги е валиден. // ако този ингегер е куб на някакво цяло число. // Напишете функция, която приема цяло число а и връща true./// >>> iscube(a: 1)
/// true
/// >>> iscube(a: 2)
/// false
/// >>> iscube(a: -1)
/// true
/// >>> iscube(a: 64)
/// true
/// >>> iscube(a: 0)
/// true
/// >>> iscube(a: 180)
/// false
func iscube(a: Int) -> Bool {
","func iscube(a: Int) -> Bool {
    if a == 0 { return true } // 0 is a cube (0^3)
    let absA = abs(a)
    let cubeRoot = Int(round(pow(Double(absA), 1.0/3.0)))
    return cubeRoot * cubeRoot * cubeRoot == absA
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(iscube(a: 1) == true)
assert(iscube(a: 2) == false)
assert(iscube(a: -1) == true)
assert(iscube(a: 64) == true)
assert(iscube(a: 180) == false)
assert(iscube(a: 1000) == true)
assert(iscube(a: 0) == true)
assert(iscube(a: 1729) == false)"
HumanEval_78,bul_Cyrl,swift,"
// Примери: И символите А,Б,С,Д,Е,Ф винаги са с големи букви.// Забележка: може да приемете, че входът винаги е правилен или празен string, // B (= десетична 11), D (= десетична 13). // Значи трябва да определите число от следните цифри: 2, 3, 5, 7, // Първозначителните числа са 2, 3, 5, 7, 11, 13, 17,... // Хексадецималните цифри са 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, А, Б, С, Д, Е, Ф. // по-голямо от 1 което не е произведение на две по-малки натурални числа).//цифри, които са прости числа (прости числа, или прости, е естествено число // хексадецимално число като низ и броя хексадецималните числа // На вас ви е възложено да напишете функция, която получава /// >>> hex_key(num: ""AB"")
/// 1
/// >>> hex_key(num: ""1077E"")
/// 2
/// >>> hex_key(num: ""ABED1A33"")
/// 4
/// >>> hex_key(num: ""123456789ABCDEF0"")
/// 6
/// >>> hex_key(num: ""2020"")
/// 2
func hex_key(num: String) -> Int {
","func hex_key(num: String) -> Int {
    // Define hexadecimal digits that are prime numbers
    let primeHexDigits: Set<Character> = [""2"", ""3"", ""5"", ""7"", ""B"", ""D""]
    
    // Initialize count
    var primeCount = 0
    
    // Iterate over each character in the string
    for char in num {
        // Check if the character is a prime hexadecimal digit
        if primeHexDigits.contains(char) {
            primeCount += 1
        }
    }
    
    return primeCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: ""AB"") == 1)
assert(hex_key(num: ""1077E"") == 2)
assert(hex_key(num: ""ABED1A33"") == 4)
assert(hex_key(num: ""2020"") == 2)
assert(hex_key(num: ""123456789ABCDEF0"") == 6)
assert(hex_key(num: ""112233445566778899AABBCCDDEEFF00"") == 12)"
HumanEval_79,bul_Cyrl,swift,"
// Примери: // Допълнителните знаци са там, за да помогнат с формата. // Ще има допълнителни символи 'db' в началото и в края на строката. // брой. Всеки символ в низката ще бъде '0' или '1'.Функцията трябва да върне по една строка, като всеки знак представлява двоичен код // Ще ви бъде дадено число в десетична форма и вашата задача е да го преобразувате в /// >>> decimal_to_binary(decimal: 15)
/// ""db1111db""
/// >>> decimal_to_binary(decimal: 32)
/// ""db100000db""
func decimal_to_binary(decimal: Int) -> String {
","func decimal_to_binary(decimal: Int) -> String {
    let binaryString = String(decimal, radix: 2)
    return ""db"" + binaryString + ""db""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(decimal_to_binary(decimal: 0) == ""db0db"")
assert(decimal_to_binary(decimal: 32) == ""db100000db"")
assert(decimal_to_binary(decimal: 103) == ""db1100111db"")
assert(decimal_to_binary(decimal: 15) == ""db1111db"")"
HumanEval_80,bul_Cyrl,swift,"
Например:// Ако дължината на една нишка е поне 3 и всяка от трите последователни букви е различна, тя е хапсвиф.// Вашата задача е да проверите дали нишката е хапсвифт или не. // Дават ви string s. /// >>> is_happy(s: ""a"")
/// false
/// >>> is_happy(s: ""aa"")
/// false
/// >>> is_happy(s: ""abcd"")
/// true
/// >>> is_happy(s: ""aabb"")
/// false
/// >>> is_happy(s: ""adb"")
/// true
/// >>> is_happy(s: ""xyy"")
/// false
func is_happy(s: String) -> Bool {
","func is_happy(s: String) -> Bool {
    let characters = Array(s)
    if characters.count < 3 {
        return false
    }
    
    for i in 0..<(characters.count - 2) {
        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_happy(s: ""a"") == false)
assert(is_happy(s: ""aa"") == false)
assert(is_happy(s: ""abcd"") == true)
assert(is_happy(s: ""aabb"") == false)
assert(is_happy(s: ""adb"") == true)
assert(is_happy(s: ""xyy"") == false)
assert(is_happy(s: ""iopaxpoi"") == true)
assert(is_happy(s: ""iopaxioi"") == false)"
HumanEval_81,bul_Cyrl,swift,"
// Пример: // 0.0 Е // > 0,0 D- // > 0,7 D // > 1,0 D+ // > 1.3 C- // > 1,7 °C // > 2,0 С+ // > 2.3 Б- // > 2,7 B // > 3,0 B+ // > 3.3 А- // > 3.7 А // 4.0 А+ Средно оценяване.// функция, която може да извести масив от букви, използвайки следната таблица: Тя ти е дала няколко оценки за някои ученици и трябва да пишеш.Единственият проблем е, че е загубила кода, който е използвала за оценяване.Учителят е създал свой алгоритъм за оценяване.// Това е последната седмица от семестъра и учителят трябва да даде оценките./// >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])
/// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
func numerical_letter_grade(grades: [Double]) -> [String] {
","func numerical_letter_grade(grades: [Double]) -> [String] {
    return grades.map { gpa in
        switch gpa {
        case 4.0:
            return ""A+""
        case 3.7...4.0:
            return ""A""
        case 3.3..<3.7:
            return ""A-""
        case 3.0..<3.3:
            return ""B+""
        case 2.7..<3.0:
            return ""B""
        case 2.3..<2.7:
            return ""B-""
        case 2.0..<2.3:
            return ""C+""
        case 1.7..<2.0:
            return ""C""
        case 1.3..<1.7:
            return ""C-""
        case 1.0..<1.3:
            return ""D+""
        case 0.7..<1.0:
            return ""D""
        case 0.0..<0.7:
            return ""D-""
        default:
            return ""E""
        }
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [""A+"", ""B"", ""C-"", ""C"", ""A-""])
assert(numerical_letter_grade(grades: [1.2]) == [""D+""])
assert(numerical_letter_grade(grades: [0.5]) == [""D-""])
assert(numerical_letter_grade(grades: [0.0]) == [""E""])
assert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [""D"", ""D-"", ""C-"", ""B"", ""B+""])
assert(numerical_letter_grade(grades: [0.0, 0.7]) == [""E"", ""D-""])"
HumanEval_82,bul_Cyrl,swift,"
// Примери // дължината е просто число или е фалшива в противен случай // Напишете функция, която приема поредица от числа и връща true, ако поредицата /// >>> prime_length(string: ""Hello"")
/// true
/// >>> prime_length(string: ""abcdcba"")
/// true
/// >>> prime_length(string: ""kittens"")
/// true
/// >>> prime_length(string: ""orange"")
/// false
func prime_length(string: String) -> Bool {
","func prime_length(string: String) -> Bool {
    let length = string.count
    
    guard length > 1 else {
        return false
    }
    
    for i in 2..<length {
        if length % i == 0 {
            return false
        }
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_length(string: ""Hello"") == true)
assert(prime_length(string: ""abcdcba"") == true)
assert(prime_length(string: ""kittens"") == true)
assert(prime_length(string: ""orange"") == false)
assert(prime_length(string: ""wow"") == true)
assert(prime_length(string: ""world"") == true)
assert(prime_length(string: ""MadaM"") == true)
assert(prime_length(string: ""Wow"") == true)
assert(prime_length(string: """") == false)
assert(prime_length(string: ""HI"") == true)
assert(prime_length(string: ""go"") == true)
assert(prime_length(string: ""gogo"") == false)
assert(prime_length(string: ""aaaaaaaaaaaaaaa"") == false)
assert(prime_length(string: ""Madam"") == true)
assert(prime_length(string: ""M"") == false)
assert(prime_length(string: ""0"") == false)"
HumanEval_83,bul_Cyrl,swift,"
// положителни цели числа, които започват или завършват с 1. // При положително цяло число n, да се върне броя на n-цифровите числа func starts_one_ends(n: Int) -> Int {
","func starts_one_ends(n: Int) -> Int {
    if n == 1 {
        // For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.
        return 1
    }
    
    // Count of n-digit numbers starting with 1:
    // First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.
    let startWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Count of n-digit numbers ending with 1:
    // Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.
    // So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.
    let endWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Intersection of both sets is the numbers starting and ending with 1
    // which are of the form `1` followed by (n-2) digits and `1`, so:
    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))
    
    return startWithOne + endWithOne - startAndEndWithOne
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(starts_one_ends(n: 1) == 1)
assert(starts_one_ends(n: 2) == 18)
assert(starts_one_ends(n: 3) == 180)
assert(starts_one_ends(n: 4) == 1800)
assert(starts_one_ends(n: 5) == 18000)"
HumanEval_84,bul_Cyrl,swift,"
// Пример // Дадено положително цяло число N, връща общата сума на неговите цифри в двоичен код. /// >>> solve(N: 1000)
/// ""1""
/// >>> solve(N: 150)
/// ""110""
/// >>> solve(N: 147)
/// ""1100""
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
func solve(N: Int) -> String {
","func solve(N: Int) -> String {
    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)
    return String(sumOfDigits, radix: 2)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(N: 1000) == ""1"")
assert(solve(N: 150) == ""110"")
assert(solve(N: 147) == ""1100"")
assert(solve(N: 333) == ""1001"")
assert(solve(N: 963) == ""10010"")"
HumanEval_85,bul_Cyrl,swift,"
// Примери: // При положение, че масивът е непразен, първо добавете четните елементи, които са на нечетни индекси./// >>> add(lst: [4, 2, 6, 7])
/// 2
func add(lst: [Int]) -> Int {
","func add(lst: [Int]) -> Int {
    var sum = 0
    for i in stride(from: 1, to: lst.count, by: 2) {
        if lst[i] % 2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(lst: [4, 88]) == 88)
assert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)
assert(add(lst: [4, 0, 6, 7]) == 0)
assert(add(lst: [4, 4, 6, 8]) == 12)"
HumanEval_86,bul_Cyrl,swift,"
Например:// Забележка: Трябва да запазите реда на думите и празни места в изречението.// по нарастващ ред, базиран на стойността на ASCII.// се заменят с нова дума, в която всички символи са подредени в // Наредена версия на string, е string, където всички думи (разделени с пробела) // Напишете функция, която взема един низ и връща подредена версия на него. /// >>> anti_shuffle(s: ""Hi"")
/// ""Hi""
/// >>> anti_shuffle(s: ""hello"")
/// ""ehllo""
/// >>> anti_shuffle(s: ""Hello World!!!"")
/// ""Hello !!!Wdlor""
func anti_shuffle(s: String) -> String {
","func anti_shuffle(s: String) -> String {
    let words = s.components(separatedBy: .whitespaces)
    let orderedWords = words.map { String($0.sorted()) }
    var result = """"
    var wordIndex = 0
    
    for character in s {
        if character.isWhitespace {
            result.append(character)
        } else if wordIndex < orderedWords.count {
            if let currentWord = orderedWords[wordIndex].first {
                result.append(currentWord)
                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)
            }
        }
        
        if let lastCharacter = result.last {
            if lastCharacter.isWhitespace {
                wordIndex += 1
            }
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(anti_shuffle(s: ""Hi"") == ""Hi"")
assert(anti_shuffle(s: ""hello"") == ""ehllo"")
assert(anti_shuffle(s: ""number"") == ""bemnru"")
assert(anti_shuffle(s: ""abcd"") == ""abcd"")
assert(anti_shuffle(s: ""Hello World!!!"") == ""Hello !!!Wdlor"")
assert(anti_shuffle(s: """") == """")
assert(anti_shuffle(s: ""Hi. My name is Mister Robot. How are you?"") == "".Hi My aemn is Meirst .Rboot How aer ?ouy"")"
HumanEval_87,bul_Cyrl,swift,"
// Примери: // Също така, сортирайте координатите на реда по колоните в низходящ ред. // Първоначално подредете координатите по редове в нарастващ ред.// всяка тупла е координата - (ряд, колона), започваща с 0. // и връща масив от tuples, [(x1, y1), (x2, y2) ...] така че // Като се има предвид lst, и цело число x, намерите числата x в масива, // всеки ред може да съдържа различен брой колони. // което е подобно на матрицата, но за разлика от матриците, // Дават ви двуизмерни данни, като вложени масиви, /// >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)
/// [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(lst: [] as [[Int]], x: 1)
/// [] as [(Int, Int)]
/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)
/// [(2, 2)]
func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
","func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
    var coordinates: [(Int, Int)] = []
    
    for (rowIndex, row) in lst.enumerated() {
        for (colIndex, value) in row.enumerated() {
            if value == x {
                coordinates.append((rowIndex, colIndex))
            }
        }
    }
    
    let sortedCoordinates = coordinates.sorted {
        if $0.0 == $1.0 {
            return $0.1 > $1.1
        } else {
            return $0.0 < $1.0
        }
    }
    
    return sortedCoordinates
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])
assert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])
assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])
assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
HumanEval_88,bul_Cyrl,swift,"
// Примери: // * не променяйте дадения масив. // Забележка: // или го подрежда в низходящ ред, ако сумата ((първа индексна стойност, последна индексна стойност) е четна. // ще сортирате дадения масив в нарастващ ред, ако сумата ((първа индексна стойност, последна индексна стойност) е нечетна, // Като се има предвид масив от неотрицателни цели числа, връщаме coswift на дадения масив след сортиране, /// >>> sort_array(array: [] as [Int])
/// [] as [Int]
/// >>> sort_array(array: [5])
/// [5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5])
/// [0, 1, 2, 3, 4, 5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])
/// [6, 5, 4, 3, 2, 1, 0]
func sort_array(array: [Int]) -> [Int] {
","func sort_array(array: [Int]) -> [Int] {
    guard let first = array.first, let last = array.last else {
        return array
    }
    let sum = first + last
    if sum % 2 == 0 {
        return array.sorted(by: >) // Descending order
    } else {
        return array.sorted() // Ascending order
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(array: [] as [Int]) == [] as [Int])
assert(sort_array(array: [5]) == [5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])
assert(sort_array(array: [2, 1]) == [1, 2])
assert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])
assert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"
HumanEval_89,bul_Cyrl,swift,"
Например:// измести се надолу по два пъти на две места. // Алфавита трябва да се върти по такъв начин, че буквите // връща кодиран низ, като азбуката се върти. // Създаване на функция за криптиране, която приема един низ като аргумент и /// >>> encrypt(s: ""hi"")
/// ""lm""
/// >>> encrypt(s: ""asdfghjkl"")
/// ""ewhjklnop""
/// >>> encrypt(s: ""gf"")
/// ""kj""
/// >>> encrypt(s: ""et"")
/// ""ix""
func encrypt(s: String) -> String {
","func encrypt(s: String) -> String {
    let alphabet = Array(""abcdefghijklmnopqrstuvwxyz"")
    let shift = 2 * 2 // shift down by two multiplied by two places, i.e., 4
    var result = """"

    for character in s {
        if let index = alphabet.firstIndex(of: character) {
            let newIndex = (index + shift) % alphabet.count
            result.append(alphabet[newIndex])
        } else {
            result.append(character) // append non-alphabetic characters unchanged
        }
    }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: ""hi"") == ""lm"")
assert(encrypt(s: ""asdfghjkl"") == ""ewhjklnop"")
assert(encrypt(s: ""gf"") == ""kj"")
assert(encrypt(s: ""et"") == ""ix"")
assert(encrypt(s: ""faewfawefaewg"") == ""jeiajeaijeiak"")
assert(encrypt(s: ""hellomyfriend"") == ""lippsqcjvmirh"")
assert(encrypt(s: ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"") == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")
assert(encrypt(s: ""a"") == ""e"")"
HumanEval_90,bul_Cyrl,swift,"
// Връща null, ако няма такъв елемент. // Напишете функция next_smallest ((), която връща втория най-малък елемент от масива. // Даваме ви масив от цели числа. /// >>> next_smallest(lst: [1, 2, 3, 4, 5])
/// 2
/// >>> next_smallest(lst: [5, 1, 4, 3, 2])
/// 2
/// >>> next_smallest(lst: [] as [Int])
/// nil
/// >>> next_smallest(lst: [1, 1])
/// nil
func next_smallest(lst: [Int]) -> Int? {
","func next_smallest(lst: [Int]) -> Int? {
    if lst.count < 2 {
        return nil
    }
    
    var uniqueSorted = Array(Set(lst)).sorted()
    
    if uniqueSorted.count < 2 {
        return nil
    }
    
    return uniqueSorted[1]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)
assert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)
assert(next_smallest(lst: [] as [Int]) == nil)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
HumanEval_91,bul_Cyrl,swift,"
Например:// Изреченията се разграничават с '.', '?' или '!'. Досадата е изречение, което започва с думата ""аз"".Ще ви бъде дадена поредица от думи, и вашата задача е да преброите броя./// >>> is_bored(S: ""Hello world"")
/// 0
/// >>> is_bored(S: ""The sky is blue. The sun is shining. I love this weather"")
/// 1
func is_bored(S: String) -> Int {
","func is_bored(S: String) -> Int {
    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }
    var boredomCount = 0
    
    for sentence in sentences {
        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)
        if trimmedSentence.hasPrefix(""I"") {
            boredomCount += 1
        }
    }
    
    return boredomCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_bored(S: ""Hello world"") == 0)
assert(is_bored(S: ""Is the sky blue?"") == 0)
assert(is_bored(S: ""I love It !"") == 1)
assert(is_bored(S: ""bIt"") == 0)
assert(is_bored(S: ""I feel good today. I will be productive. will kill It"") == 2)
assert(is_bored(S: ""You and I are going for a walk"") == 0)"
HumanEval_92,bul_Cyrl,swift,"
// Примери // Връща false в всички останали случаи. // Връща вярно, ако едно от числата е равно на сумата от другите две, и всички числа са цели числа. // Създайте функция, която приема 3 числа. /// >>> any_int(x: 5, y: 2, z: 7)
/// true
/// >>> any_int(x: 3, y: 2, z: 2)
/// false
/// >>> any_int(x: 3, y: -2, z: 1)
/// true
/// >>> any_int(x: 3.6, y: -2.2, z: 2)
/// false
func any_int(x: Double, y: Double, z: Double) -> Bool {
","func any_int(x: Double, y: Double, z: Double) -> Bool {
    guard x == floor(x), y == floor(y), z == floor(z) else {
        return false
    }
    
    let a = Int(x)
    let b = Int(y)
    let c = Int(z)
    
    return a == b + c || b == a + c || c == a + b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(any_int(x: 2, y: 3, z: 1) == true)
assert(any_int(x: 2.5, y: 2, z: 3) == false)
assert(any_int(x: 1.5, y: 5, z: 3.5) == false)
assert(any_int(x: 2, y: 6, z: 2) == false)
assert(any_int(x: 4, y: 2, z: 2) == true)
assert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)
assert(any_int(x: -4, y: 6, z: 2) == true)
assert(any_int(x: 2, y: 1, z: 1) == true)
assert(any_int(x: 3, y: 4, z: 7) == true)
assert(any_int(x: 3.0, y: 4, z: 7) == false)"
HumanEval_93,bul_Cyrl,swift,"
// Примери: // Приеми само букви. // гласна в английската азбука. // съобщението с буквата, която се появява на 2 места пред това // начин, по който се сменят буквите, заменя всички гласни в // Напишете функция, която приема съобщение и го кодира в такава /// >>> encode(message: ""test"")
/// ""TGST""
/// >>> encode(message: ""This is a message"")
/// ""tHKS KS C MGSSCGG""
func encode(message: String) -> String {
","func encode(message: String) -> String {
    let vowels = ""aeiouAEIOU""
    let vowelReplacement = [
        ""a"": ""c"", ""e"": ""g"", ""i"": ""k"", ""o"": ""q"", ""u"": ""w"",
        ""A"": ""C"", ""E"": ""G"", ""I"": ""K"", ""O"": ""Q"", ""U"": ""W""
    ]
    
    var encodedMessage = """"
    
    for char in message {
        if vowels.contains(char) {
            if let replacement = vowelReplacement[String(char)] {
                encodedMessage.append(replacement)
            }
        } else {
            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())
            encodedMessage.append(swappedCase)
        }
    }
    
    return encodedMessage
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: ""TEST"") == ""tgst"")
assert(encode(message: ""Mudasir"") == ""mWDCSKR"")
assert(encode(message: ""YES"") == ""ygs"")
assert(encode(message: ""This is a message"") == ""tHKS KS C MGSSCGG"")
assert(encode(message: ""I DoNt KnOw WhAt tO WrItE"") == ""k dQnT kNqW wHcT Tq wRkTg"")"
HumanEval_94,bul_Cyrl,swift,"
// Примери: // Трябва да намерим най-голямата проста стойност и да върнем сумата от нейните цифри. // Даваме ви масив от цели числа. /// >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])
/// 7
func skjkasdkd(lst: [Int]) -> Int {
","func skjkasdkd(lst: [Int]) -> Int {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    var largestPrime: Int? = nil
    for number in lst {
        if isPrime(number) {
            if largestPrime == nil || number > largestPrime! {
                largestPrime = number
            }
        }
    }
    
    if let largestPrime = largestPrime {
        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)
    }
    
    return 0 // In case there are no prime numbers
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)
assert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)
assert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)
assert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)
assert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)
assert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)
assert(skjkasdkd(lst: [8191]) == 19)
assert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)
assert(skjkasdkd(lst: [127, 97, 8192]) == 10)"
HumanEval_96,bul_Cyrl,swift,"
// Например: // Цели числа, които са прости числа и по-малки от n. // Използваме функция, която взема неотрицателно цяло число и връща масив от първите n /// >>> count_up_to(n: 5)
/// [2, 3]
/// >>> count_up_to(n: 11)
/// [2, 3, 5, 7]
/// >>> count_up_to(n: 0)
/// [] as [Int]
/// >>> count_up_to(n: 20)
/// [2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(n: 1)
/// [] as [Int]
/// >>> count_up_to(n: 18)
/// [2, 3, 5, 7, 11, 13, 17]
func count_up_to(n: Int) -> [Int] {
","func count_up_to(n: Int) -> [Int] {
    guard n > 2 else { return [] }
    
    var primes: [Int] = [2]
    
    for number in 3..<n {
        var isPrime = true
        for prime in primes {
            if prime * prime > number {
                break
            }
            if number % prime == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            primes.append(number)
        }
    }
    
    return primes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_up_to(n: 5) == [2, 3])
assert(count_up_to(n: 6) == [2, 3, 5])
assert(count_up_to(n: 7) == [2, 3, 5])
assert(count_up_to(n: 10) == [2, 3, 5, 7])
assert(count_up_to(n: 0) == [] as [Int])
assert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])
assert(count_up_to(n: 1) == [] as [Int])
assert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])
assert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
assert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"
HumanEval_97,bul_Cyrl,swift,"
// Примери: // Приеми, че входът е винаги валиден.// произведението на техните единици. // Завършва функцията, която взема две цели числа и връща /// >>> multiply(a: 148, b: 412)
/// 16
/// >>> multiply(a: 19, b: 28)
/// 72
/// >>> multiply(a: 2020, b: 1851)
/// 0
/// >>> multiply(a: 14, b: -15)
/// 20
func multiply(a: Int, b: Int) -> Int {
","func multiply(a: Int, b: Int) -> Int {
    let unitDigitA = abs(a % 10)
    let unitDigitB = abs(b % 10)
    return unitDigitA * unitDigitB
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(multiply(a: 148, b: 412) == 16)
assert(multiply(a: 19, b: 28) == 72)
assert(multiply(a: 2020, b: 1851) == 0)
assert(multiply(a: 14, b: -15) == 20)
assert(multiply(a: 76, b: 67) == 42)
assert(multiply(a: 17, b: 27) == 49)
assert(multiply(a: 0, b: 1) == 0)
assert(multiply(a: 0, b: 0) == 0)"
HumanEval_98,bul_Cyrl,swift,"
Например:// При string s, изчисли броя на гласниците с големи букви в четни знаци. /// >>> count_upper(s: ""aBCdEf"")
/// 1
/// >>> count_upper(s: ""abcdefg"")
/// 0
/// >>> count_upper(s: ""dBBE"")
/// 0
func count_upper(s: String) -> Int {
","func count_upper(s: String) -> Int {
    let upperVowels = Set<Character>([""A"", ""E"", ""I"", ""O"", ""U""])
    var count = 0

    for (index, char) in s.enumerated() {
        if index % 2 == 0 && upperVowels.contains(char) {
            count += 1
        }
    }

    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_upper(s: ""aBCdEf"") == 1)
assert(count_upper(s: ""abcdefg"") == 0)
assert(count_upper(s: ""dBBE"") == 0)
assert(count_upper(s: ""B"") == 0)
assert(count_upper(s: ""U"") == 1)
assert(count_upper(s: """") == 0)
assert(count_upper(s: ""EEEE"") == 2)"
HumanEval_99,bul_Cyrl,swift,"
// Примери // от две цели числа, закръгляне далеч от нулата. // и връща най-близкото цяло число до него.// Създаване на функция, която приема стойност (ряд) представляваща число /// >>> closest_integer(value: ""10"")
/// 10
/// >>> closest_integer(value: ""15.3"")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value: String) -> Int {
","func closest_integer(value: String) -> Int {
    if let number = Double(value) {
        return Int(number.rounded(.awayFromZero))
    }
    return 0 // or handle error as needed
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: ""10"") == 10)
assert(closest_integer(value: ""14.5"") == 15)
assert(closest_integer(value: ""-15.5"") == -16)
assert(closest_integer(value: ""15.3"") == 15)
assert(closest_integer(value: ""0"") == 0)"
HumanEval_100,bul_Cyrl,swift,"
// Примери: // i представлява броя на камъните в нивото (i+1). // Връща броя на камъните във всеки ниво в масив, където елементът в индекс // - следващото четно число, ако n е четно. // - следващото нечетно число, ако n е нечетно. // Броят на камъните в следващото ниво е: // Първото ниво има n камъни. // При положително цяло число n, трябва да направите купчина от n нива камъни./// >>> make_a_pile(n: 3)
/// [3, 5, 7]
func make_a_pile(n: Int) -> [Int] {
","func make_a_pile(n: Int) -> [Int] {
    var pile = [Int]()
    var currentLevelStones = n
    
    for _ in 0..<n {
        pile.append(currentLevelStones)
        if n % 2 == 0 {
            currentLevelStones += 2
        } else {
            currentLevelStones += 2
        }
    }
    
    return pile
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_a_pile(n: 3) == [3, 5, 7])
assert(make_a_pile(n: 4) == [4, 6, 8, 10])
assert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])
assert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])
assert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"
HumanEval_101,bul_Cyrl,swift,"
Например:// да разделя низовете на думи и да връща масив от думи. Ще ви бъде дадена поредица от думи, разделени с запетая или пробела./// >>> words_string(s: ""Hi, my name is John"")
/// [""Hi"", ""my"", ""name"", ""is"", ""John""]
/// >>> words_string(s: ""One, two, three, four, five, six"")
/// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
func words_string(s: String) -> [String] {
","func words_string(s: String) -> [String] {
    let separators = CharacterSet(charactersIn: "", "")
    return s.components(separatedBy: separators).filter { !$0.isEmpty }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_string(s: ""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""])
assert(words_string(s: ""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: ""Hi, my name"") == [""Hi"", ""my"", ""name""])
assert(words_string(s: ""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: """") == [] as [String])
assert(words_string(s: ""ahmed     , gamal"") == [""ahmed"", ""gamal""])"
HumanEval_102,bul_Cyrl,swift,"
Например:// няма такова число, тогава функцията трябва да върне -1. // най-голямото четно цяло число, което е в диапазона [x, y] включително.// Тази функция взема две положителни числа x и y и връща /// >>> choose_num(x: 12, y: 15)
/// 14
/// >>> choose_num(x: 13, y: 12)
/// -1
func choose_num(x: Int, y: Int) -> Int {
","func choose_num(x: Int, y: Int) -> Int {
    // Determine the starting and ending range values
    let start = min(x, y)
    let end = max(x, y)
    
    // Iterate from the end of the range to the start
    for num in (start...end).reversed() {
        // Check if the current number is even
        if num % 2 == 0 {
            return num
        }
    }
    
    // Return -1 if no even number is found
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(choose_num(x: 12, y: 15) == 14)
assert(choose_num(x: 13, y: 12) == -1)
assert(choose_num(x: 33, y: 12354) == 12354)
assert(choose_num(x: 5234, y: 5233) == -1)
assert(choose_num(x: 6, y: 29) == 28)
assert(choose_num(x: 27, y: 10) == -1)
assert(choose_num(x: 7, y: 7) == -1)
assert(choose_num(x: 546, y: 546) == 546)"
HumanEval_103,bul_Cyrl,swift,"
extension Int: Error {}
        
// Пример: // Ако n е по-голямо от m, връщаме -1. // Закръгляйте отговора до най-близкото цяло число и го преобразувайте в двоичен. // средни стойности на цели числа от n до m (включително n и m). // Дават ти две положителни цели числа n и m, и задачата ти е да изчислиш /// >>> rounded_avg(n: 1, m: 5)
/// .success(""0b11"")
/// >>> rounded_avg(n: 7, m: 5)
/// .failure(-1)
/// >>> rounded_avg(n: 10, m: 20)
/// .success(""0b1111"")
/// >>> rounded_avg(n: 20, m: 33)
/// .success(""0b11010"")
func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
","func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
    if n > m {
        return .failure(-1)
    }
    
    let count = m - n + 1
    let sum = (n + m) * count / 2
    let average = Double(sum) / Double(count)
    let roundedAverage = Int(average.rounded())
    let binaryString = String(roundedAverage, radix: 2)
    
    return .success(""0b"" + binaryString)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rounded_avg(n: 1, m: 5) == .success(""0b11""))
assert(rounded_avg(n: 7, m: 13) == .success(""0b1010""))
assert(rounded_avg(n: 964, m: 977) == .success(""0b1111001010""))
assert(rounded_avg(n: 996, m: 997) == .success(""0b1111100100""))
assert(rounded_avg(n: 560, m: 851) == .success(""0b1011000010""))
assert(rounded_avg(n: 185, m: 546) == .success(""0b101101110""))
assert(rounded_avg(n: 362, m: 496) == .success(""0b110101101""))
assert(rounded_avg(n: 350, m: 902) == .success(""0b1001110010""))
assert(rounded_avg(n: 197, m: 233) == .success(""0b11010111""))
assert(rounded_avg(n: 7, m: 5) == .failure(-1))
assert(rounded_avg(n: 5, m: 1) == .failure(-1))
assert(rounded_avg(n: 5, m: 5) == .success(""0b101""))"
HumanEval_104,bul_Cyrl,swift,"
Например:// Забележка: Върнатите масиви трябва да се сортират в нарастващ ред. // елементите, които нямат четна цифра. // Дадено низове от положителни цели числа x. връща сортиран масив от всички /// >>> unique_digits(x: [15, 33, 1422, 1])
/// [1, 15, 33]
/// >>> unique_digits(x: [152, 323, 1422, 10])
/// [] as [Int]
func unique_digits(x: [Int]) -> [Int] {
","func unique_digits(x: [Int]) -> [Int] {
    return x.filter { number in
        var hasEvenDigit = false
        var num = number
        while num > 0 {
            if (num % 10) % 2 == 0 {
                hasEvenDigit = true
                break
            }
            num /= 10
        }
        return !hasEvenDigit
    }.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])
assert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])
assert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])
assert(unique_digits(x: [135, 103, 31]) == [31, 135])"
HumanEval_105,bul_Cyrl,swift,"
Например:Едно, две, три, четири, пет, шест, седем, осем, девет.// да обърнем получената матрица и след това да заменим всяка цифра с съответния й име от // Предвид масив от цели числа, сортирайте числата, които са между 1 и 9 включително, /// >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])
/// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
/// If the array is empty, return an empty array:
/// >>> by_length(arr: [] as [Int])
/// [] as [String]
/// If the array has any strange number ignore it:
/// >>> by_length(arr: [1, -1, 55])
/// [""One""]
func by_length(arr: [Int]) -> [String] {
","func by_length(arr: [Int]) -> [String] {
    let numberNames: [Int: String] = [
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine""
    ]
    
    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }
                                           .sorted(by: >)
    
    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? """" }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""])
assert(by_length(arr: [] as [Int]) == [] as [String])
assert(by_length(arr: [1, -1, 55]) == [""One""])
assert(by_length(arr: [1, -1, 3, 2]) == [""Three"", ""Two"", ""One""])
assert(by_length(arr: [9, 4, 8]) == [""Nine"", ""Eight"", ""Four""])"
HumanEval_106,bul_Cyrl,swift,"
// Пример: // факториалът на i е умножението на числата от 1 до i (1 * 2 * ... * i). // започвам от 1. // или сборът от числата от 1 до i.// и връща масив с размер n, така че стойността на елемента в индекс i е факториал на i, ако i е четна.// Използвайте функцията f, която приема n като параметър, /// >>> f(n: 5)
/// [1, 2, 6, 24, 15]
func f(n: Int) -> [Int] {
","func f(n: Int) -> [Int] {
    func factorial(_ x: Int) -> Int {
        guard x > 1 else { return 1 }
        return (1...x).reduce(1, *)
    }
    
    func sumTo(_ x: Int) -> Int {
        return (1...x).reduce(0, +)
    }
    
    var result = [Int]()
    for i in 1...n {
        if i % 2 == 0 {
            result.append(factorial(i))
        } else {
            result.append(sumTo(i))
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(f(n: 5) == [1, 2, 6, 24, 15])
assert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])
assert(f(n: 1) == [1])
assert(f(n: 3) == [1, 2, 6])"
HumanEval_107,bul_Cyrl,swift,"
// Пример 1: // цели палиндроми, които попадат в диапазона ((1, n), включително. // Като се има предвид положително цяло число n, връщаме тупъл, който има броя на четните и нечетните числа /// >>> even_odd_palindrome(n: 3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(n: 12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n: Int) -> (Int, Int) {
","func even_odd_palindrome(n: Int) -> (Int, Int) {
    func isPalindrome(_ num: Int) -> Bool {
        let str = String(num)
        return str == String(str.reversed())
    }
    
    var evenCount = 0
    var oddCount = 0
    
    for i in 1...n {
        if isPalindrome(i) {
            if i % 2 == 0 {
                evenCount += 1
            } else {
                oddCount += 1
            }
        }
    }
    
    return (evenCount, oddCount)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_palindrome(n: 123) == (8, 13))
assert(even_odd_palindrome(n: 12) == (4, 6))
assert(even_odd_palindrome(n: 3) == (1, 2))
assert(even_odd_palindrome(n: 63) == (6, 8))
assert(even_odd_palindrome(n: 25) == (5, 6))
assert(even_odd_palindrome(n: 19) == (4, 6))
assert(even_odd_palindrome(n: 9) == (4, 5))
assert(even_odd_palindrome(n: 1) == (0, 1))"
HumanEval_108,bul_Cyrl,swift,"
// Например -123 има цифрите -1, 2 и 3. // Ако числото е отрицателно, тогава първата му цифра ще бъде отрицателна: // броя на елементите, чиято сума от цифри е > 0. // Напишете функция count_nums, която приема масив от цели числа и връща /// >>> count_nums(arr: [] as [Int])
/// 0
/// >>> count_nums(arr: [-1, 11, -11])
/// 1
/// >>> count_nums(arr: [1, 1, 2])
/// 3
func count_nums(arr: [Int]) -> Int {
","func count_nums(arr: [Int]) -> Int {
    return arr.filter { number in
        var n = number
        var sumOfDigits = 0

        while n != 0 {
            sumOfDigits += n % 10
            n /= 10
        }

        return sumOfDigits > 0
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_nums(arr: [] as [Int]) == 0)
assert(count_nums(arr: [-1, -2, 0]) == 0)
assert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)
assert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)
assert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)
assert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)
assert(count_nums(arr: [0, 1]) == 1)
assert(count_nums(arr: [1]) == 1)"
HumanEval_109,bul_Cyrl,swift,"
// Например: // Забележка: Даденият масив е гарантиран да има уникални елементи. // Ако даденият масив е празен, връща true. // тогава върни true, или върни false. // Ако е възможно да се получи сортирания масив, като се извърши горепосочената операция // началната позиция в масива, т.е. 0-ти индекс. Последният елемент от масива ще бъде преместен в // Една операция на право изместване означава изместване на всички елементи на масива с един.// Имате право да извършвате операция за право преместване колкото искате пъти. // следната операция върху дадения масив: // е възможно да се сортира масив в не намаляващ ред, като се изпълни Вашата задача е да определите дали // Имаме масив 'arr' от N цели числа arr[1], arr[2], ..., arr[N]./// >>> move_one_ball(arr: [3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given array.
/// >>> move_one_ball(arr: [3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// array by performing any number of right shift operations.
func move_one_ball(arr: [Int]) -> Bool {
","func move_one_ball(arr: [Int]) -> Bool {
    guard !arr.isEmpty else { return true }
    
    let n = arr.count
    var breakPointCount = 0
    
    // Find the number of break points where the array is decreasing
    for i in 0..<n {
        if arr[i] > arr[(i + 1) % n] {
            breakPointCount += 1
        }
    }
    
    // If there's at most one break point, the array can be right shifted
    return breakPointCount <= 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)
assert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)
assert(move_one_ball(arr: [4, 3, 1, 2]) == false)
assert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)
assert(move_one_ball(arr: [] as [Int]) == true)"
HumanEval_110,bul_Cyrl,swift,"
Например:// В противен случай, върнете ""НЕ"". // всички елементи на lst1 да са четни, връща ""ДА"". // Ако е възможно да се обменят елементи между lst1 и lst2 за да се направи // Няма ограничение за броя на обменените елементи между lst1 и lst2. // между тях, за да направи lst1 масив само от четни числа. // и определя дали е възможно да се извърши обмяна на елементи // В този проблем, ще приложите функция, която приема два масива от числа, /// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])
/// ""YES""
/// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])
/// ""NO""
/// It is assumed that the input arrays will be non-empty.
func exchange(lst1: [Int], lst2: [Int]) -> String {
","func exchange(lst1: [Int], lst2: [Int]) -> String {
    var hasOddInLst1 = false
    var hasEvenInLst2 = false
    
    for num in lst1 {
        if num % 2 != 0 {
            hasOddInLst1 = true
            break
        }
    }
    
    for num in lst2 {
        if num % 2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasOddInLst1 {
        return ""YES""
    }
    
    if hasEvenInLst2 {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == ""YES"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == ""NO"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == ""NO"")
assert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == ""NO"")
assert(exchange(lst1: [100, 200], lst2: [200, 200]) == ""YES"")"
HumanEval_111,bul_Cyrl,swift,"
// Пример: // Ако няколко букви имат еднакво появяване, върнете всички. // на буквата с най-много повторения и съдържаща съответния брой. // Предвид че низа представлява малки букви, разделени с пространство, връща речник /// >>> histogram(test: ""a b c"")
/// [""a"" : 1, ""b"" : 1, ""c"" : 1]
/// >>> histogram(test: ""a b b a"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""a b c a b"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""b b b b a"")
/// [""b"" : 4]
/// >>> histogram(test: """")
/// [:] as [String : Int]
func histogram(test: String) -> [String : Int] {
","func histogram(test: String) -> [String : Int] {
    var letterCount: [String: Int] = [:]

    // Split the string into an array of letters
    let letters = test.split(separator: "" "").map { String($0) }

    // Count occurrences of each letter
    for letter in letters {
        letterCount[letter, default: 0] += 1
    }

    // Determine the maximum number of occurrences
    guard let maxCount = letterCount.values.max() else {
        return [:] as [String : Int]
    }

    // Filter the letterCount dictionary to only include letters with the max count
    let result = letterCount.filter { $0.value == maxCount }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(histogram(test: ""a b b a"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c a b"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c d g"") == [""a"" : 1, ""b"" : 1, ""c"" : 1, ""d"" : 1, ""g"" : 1])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: ""b b b b a"") == [""b"" : 4])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: """") == [:] as [String : Int])
assert(histogram(test: ""a"") == [""a"" : 1])"
HumanEval_112,bul_Cyrl,swift,"
// Пример // Трябва да върнете тупела, съдържащ резултата и true/false за проверката. // Струн се нарича палиндром, ако се чете еднакво назад и напред. // след това проверете дали резултатът е палиндром. // Имаме два струнни n и c, трябва да изтрием всички знаци в n, които са равни на всеки знак в c.- Задача./// >>> reverse_delete(s: ""abcde"", c: ""ae"")
/// (""bcd"", false)
/// >>> reverse_delete(s: ""abcdef"", c: ""b"")
/// (""acdef"", false)
/// >>> reverse_delete(s: ""abcdedcba"", c: ""ab"")
/// (""cdedc"", true)
func reverse_delete(s: String, c: String) -> (String, Bool) {
","func reverse_delete(s: String, c: String) -> (String, Bool) {
    // Remove characters from s that are in c
    let filteredString = s.filter { !c.contains($0) }
    
    // Check if the resulting string is a palindrome
    let isPalindrome = filteredString == String(filteredString.reversed())
    
    // Return the resulting string and the palindrome check result
    return (filteredString, isPalindrome)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(reverse_delete(s: ""abcde"", c: ""ae"") == (""bcd"", false))
assert(reverse_delete(s: ""abcdef"", c: ""b"") == (""acdef"", false))
assert(reverse_delete(s: ""abcdedcba"", c: ""ab"") == (""cdedc"", true))
assert(reverse_delete(s: ""dwik"", c: ""w"") == (""dik"", false))
assert(reverse_delete(s: ""a"", c: ""a"") == ("""", true))
assert(reverse_delete(s: ""abcdedcba"", c: """") == (""abcdedcba"", true))
assert(reverse_delete(s: ""abcdedcba"", c: ""v"") == (""abcdedcba"", true))
assert(reverse_delete(s: ""vabba"", c: ""v"") == (""abba"", true))
assert(reverse_delete(s: ""mamma"", c: ""mia"") == ("""", true))"
HumanEval_113,bul_Cyrl,swift,"
// на нечетни цифри в i-тия ред на входната. // string i от входната стойност. "" където всички i трябва да бъдат заменени с числото // Всеки елемент i от изхода трябва да бъде ""броя на нечетни елементи в // Като се има предвид масив от стрии, където всеки стрийнг се състои само от цифри, връща масив. /// >>> odd_count(lst: [""1234567""])
/// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
/// >>> odd_count(lst: [""3"", ""11111111""])
/// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
func odd_count(lst: [String]) -> [String] {
","func odd_count(lst: [String]) -> [String] {
    return lst.map { str in
        let oddCount = str.filter { ""13579"".contains($0) }.count
        return ""the number of odd elements \(oddCount)n the str\(oddCount)ng \(oddCount) of the \(oddCount)nput.""
    }
}

// Example Usage
print(odd_count(lst: [""1234567""]))
print(odd_count(lst: [""3"", ""11111111""]))","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(odd_count(lst: [""1234567""]) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""])
assert(odd_count(lst: [""3"", ""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""])
assert(odd_count(lst: [""271"", ""137"", ""314""]) == [""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""])"
HumanEval_114,bul_Cyrl,swift,"
// Пример - Не, не, не.// Предвид масив от цели числа, намери минималната сума на всеки непразен под-масив /// >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(nums: [-1, -2, -3])
/// -6
func minSubArraySum(nums: [Int]) -> Int {
","func minSubArraySum(nums: [Int]) -> Int {
    guard !nums.isEmpty else { return 0 }
    
    var currentMin = nums[0]
    var overallMin = nums[0]
    
    for i in 1..<nums.count {
        currentMin = min(nums[i], currentMin + nums[i])
        overallMin = min(overallMin, currentMin)
    }
    
    return overallMin
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)
assert(minSubArraySum(nums: [-1, -2, -3]) == -6)
assert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)
assert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)
assert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)
assert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)
assert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)
assert(minSubArraySum(nums: [-10]) == -10)
assert(minSubArraySum(nums: [7]) == 7)
assert(minSubArraySum(nums: [1, -1]) == -1)"
HumanEval_115,bul_Cyrl,swift,"
// Пример 1: // Изберете броя на пъти, които трябва да се свали кофата. Задачата ви е да използвате кофите, за да изпразните кладенците.И всички кофи имат еднакъв капацитет.// Всяка кладенец има съответстваща кофа, която може да се използва за извличане на вода от него, // и всяка 1 в ред представлява една единица вода. // Получавате правоъгълна решетка от кладенци./// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)
/// 6
/// Example 2:
/// >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)
/// 5
/// Example 3:
/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
func max_fill(grid: [[Int]], capacity: Int) -> Int {
","func max_fill(grid: [[Int]], capacity: Int) -> Int {
    var totalWater = 0
    for row in grid {
        for unit in row {
            if unit == 1 {
                totalWater += 1
            }
        }
    }
    return (totalWater + capacity - 1) / capacity
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)
assert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)
assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
HumanEval_116,bul_Cyrl,swift,"
// Трябва да се изпълни така: // За подобни числа от единици, сортирайте въз основа на десетична стойност. // броя на единици в тяхното двоично представяне в нарастващ ред. // В тази Ката, трябва да сортирате масив от неотрицателни цели числа според /// >>> sort_array(arr: [1, 5, 2, 3, 4])
/// [1, 2, 3, 4, 5]
/// >>> sort_array(arr: [-2, -3, -4, -5, -6])
/// [-6, -5, -4, -3, -2]
/// >>> sort_array(arr: [1, 0, 2, 3, 4])
/// [0, 1, 2, 3, 4]
func sort_array(arr: [Int]) -> [Int] {
","func sort_array(arr: [Int]) -> [Int] {
    return arr.sorted {
        let onesCount1 = $0.nonNegativeOnesCount()
        let onesCount2 = $1.nonNegativeOnesCount()
        return (onesCount1, $0) < (onesCount2, $1)
    }
}

extension Int {
    func nonNegativeOnesCount() -> Int {
        return self < 0 ? 0 : self.nonBitCount()
    }
    
    private func nonBitCount() -> Int {
        var count = 0
        var num = self
        while num > 0 {
            count += num & 1
            num >>= 1
        }
        return count
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])
assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])
assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])
assert(sort_array(arr: [] as [Int]) == [] as [Int])
assert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])
assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
HumanEval_117,bul_Cyrl,swift,"
// Примери: // Забележка: може да приемете, че въведеният нисък съдържа само букви и пробели. // Ако string s е празен, тогава функцията трябва да върне празен масив. // n съгласни, в реда, в който тези думи се появяват в струната s. // функция, която връща масив от всички думи от string s, които съдържат точно // При string s и естествено число n, вие сте натоварени да изпълните /// >>> select_words(s: ""Mary had a little lamb"", n: 4)
/// [""little""]
/// >>> select_words(s: ""Mary had a little lamb"", n: 3)
/// [""Mary"", ""lamb""]
/// >>> select_words(s: ""simple white space"", n: 2)
/// [] as [String]
/// >>> select_words(s: ""Hello world"", n: 4)
/// [""world""]
/// >>> select_words(s: ""Uncle sam"", n: 3)
/// [""Uncle""]
func select_words(s: String, n: Int) -> [String] {
","func select_words(s: String, n: Int) -> [String] {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    let words = s.split(separator: "" "")
    var result: [String] = []
    
    for word in words {
        let consonantCount = word.filter { !vowels.contains($0) }.count
        if consonantCount == n {
            result.append(String(word))
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(select_words(s: ""Mary had a little lamb"", n: 4) == [""little""])
assert(select_words(s: ""Mary had a little lamb"", n: 3) == [""Mary"", ""lamb""])
assert(select_words(s: ""simple white space"", n: 2) == [] as [String])
assert(select_words(s: ""Hello world"", n: 4) == [""world""])
assert(select_words(s: ""Uncle sam"", n: 3) == [""Uncle""])
assert(select_words(s: """", n: 4) == [] as [String])
assert(select_words(s: ""a b c d e f"", n: 1) == [""b"", ""c"", ""d"", ""f""])"
HumanEval_118,bul_Cyrl,swift,"
// Пример: // Може да приемем, че даденият string съдържа само английски букви. // намери всяка гласна, която отговаря на горепосоченото условие. // гласниците в началото и края не се броят. Върнете празен string ако не сте // две съгласни от дясната страна на думата (чувствителни към големи и малки букви).Задачата ви е да намерите най-близката гласна, която стои между  и /// >>> get_closest_vowel(word: ""yogurt"")
/// ""u""
/// >>> get_closest_vowel(word: ""FULL"")
/// ""U""
/// >>> get_closest_vowel(word: ""quick"")
/// """"
/// >>> get_closest_vowel(word: ""ab"")
/// """"
func get_closest_vowel(word: String) -> String {
","func get_closest_vowel(word: String) -> String {
    let vowels = Set(""aeiouAEIOU"")
    var foundVowel: Character? = nil
    
    for i in stride(from: word.count - 2, through: 1, by: -1) {
        let currentIndex = word.index(word.startIndex, offsetBy: i)
        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)
        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)
        
        if vowels.contains(word[currentIndex]) && 
            !vowels.contains(word[previousIndex]) && 
            !vowels.contains(word[nextIndex]) {
            foundVowel = word[currentIndex]
            break
        }
    }
    
    return foundVowel != nil ? String(foundVowel!) : """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: ""yogurt"") == ""u"")
assert(get_closest_vowel(word: ""full"") == ""u"")
assert(get_closest_vowel(word: ""easy"") == """")
assert(get_closest_vowel(word: ""eAsy"") == """")
assert(get_closest_vowel(word: ""ali"") == """")
assert(get_closest_vowel(word: ""bad"") == ""a"")
assert(get_closest_vowel(word: ""most"") == ""o"")
assert(get_closest_vowel(word: ""ab"") == """")
assert(get_closest_vowel(word: ""ba"") == """")
assert(get_closest_vowel(word: ""quick"") == """")
assert(get_closest_vowel(word: ""anime"") == ""i"")
assert(get_closest_vowel(word: ""Asia"") == """")
assert(get_closest_vowel(word: ""Above"") == ""o"")"
HumanEval_119,bul_Cyrl,swift,"
// Примери: // Връща ""Да"", ако има начин да се направи добър низ, и в противен случай връща ""Не"". // ""()) "" не е.Например: строката ""(()))))) "" е добра, докато строката // Струн S се счита за добър, ако и само ако всички скоби в S // някакъв ред, че получената низа ще бъде добра. // Вашата работа е да проверите дали е възможно да се свържат двете струни в // само в скоби "" (("" или в близки скоби "") "". // Даваме ви масив от два реда, и двата реда са от отворени /// >>> match_parens(lst: [""()("", "")""])
/// ""Yes""
/// >>> match_parens(lst: ["")"", "")""])
/// ""No""
func match_parens(lst: [String]) -> String {
","func match_parens(lst: [String]) -> String {
    let combined1 = lst[0] + lst[1]
    let combined2 = lst[1] + lst[0]
    
    func isBalanced(_ s: String) -> Bool {
        var balance = 0
        for char in s {
            if char == ""("" {
                balance += 1
            } else if char == "")"" {
                balance -= 1
            }
            if balance < 0 {
                return false
            }
        }
        return balance == 0
    }
    
    if isBalanced(combined1) || isBalanced(combined2) {
        return ""Yes""
    } else {
        return ""No""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(match_parens(lst: [""()("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", "")""]) == ""No"")
assert(match_parens(lst: [""(()(())"", ""())())""]) == ""No"")
assert(match_parens(lst: ["")())"", ""(()()(""]) == ""Yes"")
assert(match_parens(lst: [""(())))"", ""(()())((""]) == ""Yes"")
assert(match_parens(lst: [""()"", ""())""]) == ""No"")
assert(match_parens(lst: [""(()("", ""()))()""]) == ""Yes"")
assert(match_parens(lst: [""(((("", ""((())""]) == ""No"")
assert(match_parens(lst: ["")(()"", ""(()(""]) == ""No"")
assert(match_parens(lst: ["")("", "")(""]) == ""No"")
assert(match_parens(lst: [""("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", ""(""]) == ""Yes"")"
HumanEval_120,bul_Cyrl,swift,"
// Пример 1: // с максимална дължина k с максимални k числа в arr. // Като се има предвид масив arr от цели числа и положително цяло k, връща сортиран масив /// >>> maximum(arr: [-3, -4, 5], k: 3)
/// [-4, -3, 5]
/// Example 2:
/// >>> maximum(arr: [4, -4, 4], k: 2)
/// [4, 4]
/// Example 3:
/// >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)
/// [2]
/// Note:
/// 1. The length of the array will be in the range of [1, 1000].
/// 2. The elements in the array will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
func maximum(arr: [Int], k: Int) -> [Int] {
","func maximum(arr: [Int], k: Int) -> [Int] {
    guard k > 0 else { return [] }
    let sortedArr = arr.sorted(by: >)
    let maxElements = Array(sortedArr.prefix(k))
    return maxElements.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])
assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])
assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])
assert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])
assert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])
assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])
assert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])
assert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])
assert(maximum(arr: [4, -4], k: 2) == [-4, 4])
assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])
assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
HumanEval_121,bul_Cyrl,swift,"
// Примери // Като се има предвид, че масивът не е празен, върнете сумата на всички непарни елементи, които са в четни позиции. /// >>> solution(lst: [5, 8, 7, 1])
/// 12
/// >>> solution(lst: [3, 3, 3, 3, 3])
/// 9
/// >>> solution(lst: [30, 13, 24, 321])
/// 0
func solution(lst: [Int]) -> Int {
","func solution(lst: [Int]) -> Int {
    var sum = 0
    for (index, value) in lst.enumerated() {
        if index % 2 == 0 && value % 2 != 0 {
            sum += value
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solution(lst: [5, 8, 7, 1]) == 12)
assert(solution(lst: [3, 3, 3, 3, 3]) == 9)
assert(solution(lst: [30, 13, 24, 321]) == 0)
assert(solution(lst: [5, 9]) == 5)
assert(solution(lst: [2, 4, 8]) == 0)
assert(solution(lst: [30, 13, 23, 32]) == 23)
assert(solution(lst: [3, 13, 2, 9]) == 3)"
HumanEval_122,bul_Cyrl,swift,"
// Пример: // сумата от елементите с най-много две цифри от първите k елемента на arr. // При наличие на непразен масив от цели числа arr и цяло число k, връщаме /// >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
func add_elements(arr: [Int], k: Int) -> Int {
","func add_elements(arr: [Int], k: Int) -> Int {
    var sum = 0
    for i in 0..<k {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)
assert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)
assert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)
assert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)
assert(add_elements(arr: [1], k: 1) == 1)"
HumanEval_123,bul_Cyrl,swift,"
// get_odd_collatz(5) връща [1, 5] # Колац последователността за 5 е [5, 16, 8, 4, 2, 1], така че непарните числа са само 1 и 5. Например:// 2. връща масив, подреден в нарастващ ред. // 1. Collatz(1) е [1]. // Забележка: // термин плюс 1. Предположението е, че независимо от стойността на n, последователността винаги ще достигне 1. Ако предходният член е нечетен, следващият член е 3 пъти по-голям от предишния.// предходния член, както следва: ако предходният член е четен, следващият член е половината от // както следва: започнете с всяко положително цяло число n. След това всеки член се получава от // Колетцовата хипотеза е хипотеза в математиката, която се отнася до определена последователност.// Като се има предвид положително цяло число n, връща сортиран масив, който има непарни числа в последователност collatz. /// >>> get_odd_collatz(n: 5)
/// [1, 5]
func get_odd_collatz(n: Int) -> [Int] {
","func get_odd_collatz(n: Int) -> [Int] {
    var collatzSequence: [Int] = []
    var number = n

    while number != 1 {
        if number % 2 != 0 {
            collatzSequence.append(number)
        }
        if number % 2 == 0 {
            number /= 2
        } else {
            number = 3 * number + 1
        }
    }

    collatzSequence.append(1) // append 1 as the sequence ends at 1

    let sortedOdds = collatzSequence.sorted()
    
    return sortedOdds
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])
assert(get_odd_collatz(n: 5) == [1, 5])
assert(get_odd_collatz(n: 12) == [1, 3, 5])
assert(get_odd_collatz(n: 1) == [1])"
HumanEval_124,bul_Cyrl,swift,"
// 4. Датата трябва да бъде във формат: мм-ггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггггг// 3. Мястото на месеца не трябва да бъде по-малко от 1 или по-голямо от 12.// 2. броят на дните не е по-малко от 1 или по-висок от 31 дни за месеца 1,3,5,7,8,10,12. и броят на дните не е по-малко от 1 или по-висок от 30 дни за месеца 4,6,9,11. и броят на дните не е по-малко от 1 или по-висок от 29 за месец 2. // 1. Струнът с дата не е празен. // Датата е валидна, ако са спазени всички от следните правила: // връща true, ако датата е валидна, в противен случай false. // Трябва да напишете функция, която валидира даден стрийнг на дата и /// >>> valid_date(date: ""03-11-2000"")
/// true
/// >>> valid_date(date: ""15-01-2012"")
/// false
/// >>> valid_date(date: ""04-0-2040"")
/// false
/// >>> valid_date(date: ""06-04-2020"")
/// true
/// >>> valid_date(date: ""06/04/2020"")
/// false
func valid_date(date: String) -> Bool {
","func valid_date(date: String) -> Bool {
    // Check if the date is empty
    if date.isEmpty {
        return false
    }
    
    // Split the date into components using the ""-"" delimiter
    let components = date.split(separator: ""-"")
    
    // Ensure the date has exactly three components
    if components.count != 3 {
        return false
    }
    
    // Ensure the date components are integers
    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {
        return false
    }
    
    // Check if the month is within the valid range
    if month < 1 || month > 12 {
        return false
    }
    
    // Define the number of days in each month
    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    // Check the day range for each month
    if day < 1 || day > daysInMonth[month] {
        return false
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(valid_date(date: ""03-11-2000"") == true)
assert(valid_date(date: ""15-01-2012"") == false)
assert(valid_date(date: ""04-0-2040"") == false)
assert(valid_date(date: ""06-04-2020"") == true)
assert(valid_date(date: ""01-01-2007"") == true)
assert(valid_date(date: ""03-32-2011"") == false)
assert(valid_date(date: """") == false)
assert(valid_date(date: ""04-31-3000"") == false)
assert(valid_date(date: ""06-06-2005"") == true)
assert(valid_date(date: ""21-31-2000"") == false)
assert(valid_date(date: ""04-12-2003"") == true)
assert(valid_date(date: ""04122003"") == false)
assert(valid_date(date: ""20030412"") == false)
assert(valid_date(date: ""2003-04"") == false)
assert(valid_date(date: ""2003-04-12"") == false)
assert(valid_date(date: ""04-2003"") == false)"
HumanEval_125,bul_Cyrl,swift,"
extension Int: Error {}
        
// Примери // азбука, ред (a) = 0, ред (b) = 1, ... ред (z) = 25 // трябва да се разделя на запетая ',' ако не съществува запетая трябва да се върне броя на малки букви с нечетен ред в // Ако има поредица от думи, връща масив от думи, разделен на празни места, ако в текста няма празни места./// >>> split_words(txt: ""Hello world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""Hello,world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""abcdef"")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
","func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains("" "") {
        let words = txt.split(separator: "" "").map { String($0) }
        return .success(words)
    } else if txt.contains("","") {
        let words = txt.split(separator: "","").map { String($0) }
        return .success(words)
    } else {
        let oddOrderedLowerCaseLetters = txt.filter { char in
            if let asciiValue = char.asciiValue {
                let order = asciiValue - Character(""a"").asciiValue!
                return order % 2 == 1
            }
            return false
        }
        return .failure(oddOrderedLowerCaseLetters.count)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: ""Hello world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello,world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello world,!"") == .success([""Hello"", ""world,!""]))
assert(split_words(txt: ""Hello,Hello,world !"") == .success([""Hello,Hello,world"", ""!""]))
assert(split_words(txt: ""abcdef"") == .failure(3))
assert(split_words(txt: ""aaabb"") == .failure(2))
assert(split_words(txt: ""aaaBb"") == .failure(1))
assert(split_words(txt: """") == .failure(0))"
HumanEval_126,bul_Cyrl,swift,"
// Примери // число, връща false. Приемаме, че няма отрицателни числа и само цели числа.Ако масивът има повече от 1 дубликат от същия // Даден масив от числа, връща независимо дали са подредени или не./// >>> is_sorted(lst: [5])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])
/// false
func is_sorted(lst: [Int]) -> Bool {
","func is_sorted(lst: [Int]) -> Bool {
    guard !lst.isEmpty else { return true }

    var previous = lst[0]
    var duplicates = 0

    for i in 1..<lst.count {
        if lst[i] < previous {
            return false
        } else if lst[i] == previous {
            duplicates += 1
            if duplicates > 1 {
                return false
            }
        } else {
            duplicates = 0
        }
        previous = lst[i]
    }

    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_sorted(lst: [5]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)
assert(is_sorted(lst: [] as [Int]) == true)
assert(is_sorted(lst: [1]) == true)
assert(is_sorted(lst: [3, 2, 1]) == false)
assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)
assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
HumanEval_127,bul_Cyrl,swift,"
// [вход/изход] проби: // Ако двата интервала не се пресичат, връщаме ""НЕ"". // в противен случай, връща ""НЕ"". // Ако дължината на пресечната точка е просто число, връщаме ""ДА"", // чиято дължина е 1, което не е просто число. // Пример, пресечната точка на интервалите (1, 3), (2, 4) е (2, 3) // интервали е просто число. // Вашата задача е да определите дали дължината на пресичането на тези две // За всеки даден интервал се приема, че началото му е по-малко или равно на края му.// включва както началото, така и края. // Дадените интервали са затворени, което означава, че интервалът (начало, край) // където всеки интервал е чифт цели числа.// Имате два интервала, /// >>> intersection(interval1: (1, 2), interval2: (2, 3))
/// ""NO""
/// >>> intersection(interval1: (-1, 1), interval2: (0, 4))
/// ""NO""
/// >>> intersection(interval1: (-3, -1), interval2: (-5, 5))
/// ""YES""
func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
","func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
    // Helper function to determine if a number is prime
    func isPrime(_ num: Int) -> Bool {
        if num <= 1 {
            return false
        }
        if num <= 3 {
            return true
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false
        }
        var i = 5
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Find the start and end of the intersection
    let intersectStart = max(interval1.0, interval2.0)
    let intersectEnd = min(interval1.1, interval2.1)
    
    // Calculate the length of the intersection
    let intersectionLength = intersectEnd - intersectStart

    // Check if intersection length is positive and prime
    if intersectionLength > 0 && isPrime(intersectionLength) {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersection(interval1: (1, 2), interval2: (2, 3)) == ""NO"")
assert(intersection(interval1: (-1, 1), interval2: (0, 4)) == ""NO"")
assert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == ""YES"")
assert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == ""YES"")
assert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (3, 5)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (1, 2)) == ""NO"")
assert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == ""NO"")"
HumanEval_128,bul_Cyrl,swift,"
// Пример: // Забележка: връща нил за празен arr. // на всяко число в масива, представено с 1, -1 или 0. // сумата от величините на цели числа умножена по произведението на всички знаци // Даваме ви масив arr от цели числа и трябва да върнете /// >>> prod_signs(arr: [1, 2, 2, -4])
/// 9
/// >>> prod_signs(arr: [0, 1])
/// 0
/// >>> prod_signs(arr: [] as [Int])
/// nil
func prod_signs(arr: [Int]) -> Int? {
","func prod_signs(arr: [Int]) -> Int? {
    // Return nil for empty array
    if arr.isEmpty {
        return nil
    }

    // Calculate the sum of magnitudes
    let sumOfMagnitudes = arr.reduce(0) { sum, num in
        return sum + abs(num)
    }

    // Calculate the product of all signs
    let productOfSigns = arr.reduce(1) { product, num in
        if num > 0 {
            return product * 1
        } else if num < 0 {
            return product * -1
        } else {
            return 0
        }
    }

    // Return the result of sum of magnitudes multiplied by product of signs
    return sumOfMagnitudes * productOfSigns
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prod_signs(arr: [1, 2, 2, -4]) == -9)
assert(prod_signs(arr: [0, 1]) == 0)
assert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)
assert(prod_signs(arr: [] as [Int]) == nil)
assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)
assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)
assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)
assert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
HumanEval_129,bul_Cyrl,swift,"
// Примери: // Връща подреден масив от стойностите на клетките, през които минава минималният път. // Гарантирано е, че отговорът е уникален. // lst_A[j] = lst_B[j]. // така че lst_A[i] < lst_B[i] и за всяко j (1 <= j < i) имаме // от lst_B, с други думи, съществува цяло число с индекс i (1 <= i <= k) // чрез (да ги наречем lst_A и lst_B), lst_A е лексикографски по-малко // след като се направят подредените масиви от стойностите на клетките, които А и Б отиват // Път A (с дължина k) се счита за по-малък от път B (с дължина k), ако Не можеш да се скриеш от мрежата.Необходимо е да са различни.// Моля, имайте предвид, че път с дължина k означава посещение на точно k клетки (не // клетки. С други думи, можете да отидете до клетки, които споделят ръб с вас.// от всяка клетка, и във всяка стъпка можете да се преместите в която и да е от съседните клетки, Трябва да намерим минималния път с дължина k в мрежата.// включва се появява точно веднъж на клетките на мрежата. // всяка клетка на решетката съдържа стойност.// При наличие на мрежа с N редове и N колони (N >= 2) и положително цяло число k, /// >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)
/// [1, 2, 1]
/// >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)
/// [1]
func minPath(grid: [[Int]], k: Int) -> [Int] {
","func minPath(grid: [[Int]], k: Int) -> [Int] {
    let n = grid.count
    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    struct Path: Comparable {
        let cells: [Int]
        
        static func < (lhs: Path, rhs: Path) -> Bool {
            return lhs.cells.lexicographicallyPrecedes(rhs.cells)
        }
    }
    
    var minPath: Path? = nil
    
    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {
        var currentPath = currentPath
        currentPath.append(grid[x][y])
        
        if currentPath.count == k {
            let newPath = Path(cells: currentPath)
            if minPath == nil || newPath < minPath! {
                minPath = newPath
            }
            return
        }
        
        for direction in directions {
            let newX = x + direction.0
            let newY = y + direction.1
            if newX >= 0 && newX < n && newY >= 0 && newY < n {
                dfs(x: newX, y: newY, k: k, currentPath: currentPath)
            }
        }
    }
    
    for i in 0..<n {
        for j in 0..<n {
            dfs(x: i, y: j, k: k, currentPath: [])
        }
    }
    
    return minPath!.cells
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])
assert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])
assert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])
assert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])
assert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])
assert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])
assert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])
assert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])
assert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])
assert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])
assert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"
HumanEval_130,bul_Cyrl,swift,"
// Примери: // първите n + 1 числа от поредицата на Трибоначи. // Дадено ви е неотрицателно цяло число n, трябва да върнете масив от 2+3+3=8 // три(3) = три(2) + три(1) + три(4) // три ((4) = 3 // три(2) = 1 + (2 / 2) = 2 Например:// tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ако n е нечетно. // tri (n) = 1 + n / 2, ако n е четно число. // три(1) = 3 // Поредицата на Трибоначи се определя от повтарянето: Но това, което хората не знаят е последователността на Трибоначи.Всички знаят по последователността на Фибоначи, тя е била проучена дълбоко от математиците през /// >>> tri(n: 3)
/// [1, 3, 2, 8]
func tri(n: Int) -> [Int] {
","func tri(n: Int) -> [Int] {
    guard n >= 0 else { return [] }
    if n == 0 { return [1] }
    if n == 1 { return [1, 3] }
    if n == 2 { return [1, 3, 2] }
    
    var sequence = [1, 3, 2]
    
    for i in 3...n {
        if i % 2 == 0 {
            sequence.append(1 + i / 2)
        } else {
            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]
            sequence.append(nextVal)
        }
    }
    
    return sequence
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(tri(n: 3) == [1, 3, 2, 8])
assert(tri(n: 4) == [1, 3, 2, 8, 3])
assert(tri(n: 5) == [1, 3, 2, 8, 3, 15])
assert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])
assert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])
assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])
assert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])
assert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])
assert(tri(n: 0) == [1])
assert(tri(n: 1) == [1, 3])"
HumanEval_131,bul_Cyrl,swift,"
Например:// Връща 0 ако всички цифри са четни. // При положително цяло число n, да се върне произведението на непарните цифри. /// >>> digits(n: 1)
/// 1
/// >>> digits(n: 4)
/// 0
/// >>> digits(n: 235)
/// 15
func digits(n: Int) -> Int {
","func digits(n: Int) -> Int {
    var num = n
    var product = 1
    var hasOdd = false
    
    while num > 0 {
        let digit = num % 10
        if digit % 2 != 0 {
            hasOdd = true
            product *= digit
        }
        num /= 10
    }
    
    return hasOdd ? product : 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digits(n: 5) == 5)
assert(digits(n: 54) == 5)
assert(digits(n: 120) == 1)
assert(digits(n: 5014) == 5)
assert(digits(n: 98765) == 315)
assert(digits(n: 5576543) == 2625)
assert(digits(n: 2468) == 0)"
HumanEval_132,bul_Cyrl,swift,"
// където поне една скоба в подпоредицата е вложен. // Функцията трябва да върне true, ако и само ако има валидна подпоредица от скоби // Създаване на функция, която приема като вход струн, който съдържа само квадратни скоби. /// >>> is_nested(string: ""[[]]"")
/// true
/// >>> is_nested(string: ""[]]]]]]][[[[[]"")
/// false
/// >>> is_nested(string: ""[][]"")
/// false
/// >>> is_nested(string: ""[]"")
/// false
/// >>> is_nested(string: ""[[][]]"")
/// true
/// >>> is_nested(string: ""[[]][["")
/// true
func is_nested(string: String) -> Bool {
","func is_nested(string: String) -> Bool {
    var stack: [Character] = []
    var nested = false

    for bracket in string {
        if bracket == ""["" {
            stack.append(bracket)
        } else if bracket == ""]"" {
            if let last = stack.last, last == ""["" {
                stack.removeLast()
                if !stack.isEmpty {
                    nested = true
                }
            } else {
                return false
            }
        }
    }
    return nested
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_nested(string: ""[[]]"") == true)
assert(is_nested(string: ""[]]]]]]][[[[[]"") == false)
assert(is_nested(string: ""[][]"") == false)
assert(is_nested(string: ""[]"") == false)
assert(is_nested(string: ""[[[[]]]]"") == true)
assert(is_nested(string: ""[]]]]]]]]]]"") == false)
assert(is_nested(string: ""[][][[]]"") == true)
assert(is_nested(string: ""[[]"") == false)
assert(is_nested(string: ""[]]"") == false)
assert(is_nested(string: ""[[]][["") == true)
assert(is_nested(string: ""[[][]]"") == true)
assert(is_nested(string: """") == false)
assert(is_nested(string: ""[[[[[[[["") == false)
assert(is_nested(string: ""]]]]]]]]"") == false)"
HumanEval_133,bul_Cyrl,swift,"
// Примери: // първо закръгляйте всеки елемент в масива до горния int ((Ceiling). // Трябва да върнете сумата на числата на квадрат в дадения масив, // Даваме ти масив от числа./// >>> sum_squares(lst: [1.0, 2.0, 3.0])
/// 14
/// >>> sum_squares(lst: [1.0, 4.0, 9.0])
/// 98
/// >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> sum_squares(lst: [1.4, 4.2, 0.0])
/// 29
/// >>> sum_squares(lst: [-2.4, 1.0, 1.0])
/// 6
func sum_squares(lst: [Double]) -> Int {
","func sum_squares(lst: [Double]) -> Int {
    return lst.map { ceil($0) } // Round each element to the upper int (Ceiling)
              .map { Int($0 * $0) } // Square each element
              .reduce(0, +) // Sum all squared elements
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)
assert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)
assert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)
assert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)
assert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)
assert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)
assert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)
assert(sum_squares(lst: [0.0]) == 0)
assert(sum_squares(lst: [-1.0]) == 1)
assert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"
HumanEval_134,bul_Cyrl,swift,"
// Примери: // Забележка: ""Дума"" е група от знаци, разделени с пробела. // част от думата, и фалшива в противен случай. // на дадена струна е азбучен знак и не е // Създайте функция, която връща true, ако последният знак /// >>> check_if_last_char_is_a_letter(txt: ""apple pie"")
/// false
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e"")
/// true
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e "")
/// false
/// >>> check_if_last_char_is_a_letter(txt: """")
/// false
func check_if_last_char_is_a_letter(txt: String) -> Bool {
","func check_if_last_char_is_a_letter(txt: String) -> Bool {
    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {
        return false
    }
    
    if lastChar.isLetter {
        let words = txt.split(separator: "" "")
        if let lastWord = words.last {
            return lastWord.count == 1
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(check_if_last_char_is_a_letter(txt: ""apple"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e"") == true)
assert(check_if_last_char_is_a_letter(txt: ""eeeee"") == false)
assert(check_if_last_char_is_a_letter(txt: ""A"") == true)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie "") == false)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie 1"") == false)
assert(check_if_last_char_is_a_letter(txt: """") == false)
assert(check_if_last_char_is_a_letter(txt: ""eeeee e "") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pie"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e "") == false)"
HumanEval_135,bul_Cyrl,swift,"
// Примери: // дублиращи се стойности. // няма такъв елемент, тогава връщаме -1.// не е по-голямо или равно на елемента, който го предхожда.// Създаване на функция, която връща най-големия индекс на елемент, който /// >>> can_arrange(arr: [1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(arr: [1, 2, 3])
/// -1
func can_arrange(arr: [Int]) -> Int {
","func can_arrange(arr: [Int]) -> Int {
    for i in (1..<arr.count).reversed() {
        if arr[i] < arr[i - 1] {
            return i
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)
assert(can_arrange(arr: [1, 2, 4, 5]) == -1)
assert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)
assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)
assert(can_arrange(arr: [] as [Int]) == -1)"
HumanEval_136,bul_Cyrl,swift,"
// Примери: // Ако няма отрицателни или положителни цели числа, връщаме като nil. // на положителни цели числа в масив. // най-голямото от отрицателните цели числа, а 'b' е най-малкото // Създайте функция, която връща тупъл (a, b), където 'a' е /// >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])
/// (nil, 1)
/// >>> largest_smallest_integers(lst: [] as [Int])
/// (nil, nil)
/// >>> largest_smallest_integers(lst: [0])
/// (nil, nil)
func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
","func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
    var largestNegative: Int? = nil
    var smallestPositive: Int? = nil

    for number in lst {
        if number < 0 {
            if largestNegative == nil || number > largestNegative! {
                largestNegative = number
            }
        } else if number > 0 {
            if smallestPositive == nil || number < smallestPositive! {
                smallestPositive = number
            }
        }
    }

    return (largestNegative, smallestPositive)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))
assert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))
assert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))
assert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))
assert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))
assert(largest_smallest_integers(lst: [0]) == (nil, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"
HumanEval_137,bul_Cyrl,swift,"
enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
// Забележка: Ако реално число е представено като низ, плаващата точка може да бъде . или , // Връща null, ако стойностите са равни. // реални числа и връща по-голямата променлива в дадения вид променлива. // Създайте функция, която приема цели числа, floats или стрии, представляващи /// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue(""2,3""))
/// .stringValue(""2,3"")
/// >>> compare_one(a: .stringValue(""5,1""), b: .stringValue(""6""))
/// .stringValue(""6"")
/// >>> compare_one(a: .stringValue(""1""), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
","func compare_one(a: Value, b: Value) -> Value? {
    func convertToDouble(value: Value) -> Double? {
        switch value {
        case .intValue(let int):
            return Double(int)
        case .doubleValue(let double):
            return double
        case .stringValue(let string):
            let formatter = NumberFormatter()
            formatter.locale = Locale(identifier: ""en_US_POSIX"")
            if string.contains("","") {
                formatter.decimalSeparator = "",""
            } else {
                formatter.decimalSeparator = "".""
            }
            return formatter.number(from: string)?.doubleValue
        }
    }
    
    let aDouble = convertToDouble(value: a)
    let bDouble = convertToDouble(value: b)
    
    if let aDouble = aDouble, let bDouble = bDouble {
        if aDouble > bDouble {
            return a
        } else if bDouble > aDouble {
            return b
        }
    }
    
    return nil
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue(""2,3"")) == .stringValue(""2,3""))
assert(compare_one(a: .stringValue(""5,1""), b: .stringValue(""6"")) == .stringValue(""6""))
assert(compare_one(a: .stringValue(""1""), b: .stringValue(""2"")) == .stringValue(""2""))
assert(compare_one(a: .stringValue(""1""), b: .intValue(1)) == nil)"
HumanEval_138,bul_Cyrl,swift,"
// Пример // Оценете дали даденото число n може да бъде записано като сума от точно 4 положителни четни числа /// >>> is_equal_to_sum_even(n: 4)
/// false
/// >>> is_equal_to_sum_even(n: 6)
/// false
/// >>> is_equal_to_sum_even(n: 8)
/// true
func is_equal_to_sum_even(n: Int) -> Bool {
","func is_equal_to_sum_even(n: Int) -> Bool {
    if n <= 8 {
        return false
    }
    return n % 2 == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_equal_to_sum_even(n: 4) == false)
assert(is_equal_to_sum_even(n: 6) == false)
assert(is_equal_to_sum_even(n: 8) == true)
assert(is_equal_to_sum_even(n: 10) == true)
assert(is_equal_to_sum_even(n: 11) == false)
assert(is_equal_to_sum_even(n: 12) == true)
assert(is_equal_to_sum_even(n: 13) == false)
assert(is_equal_to_sum_even(n: 16) == true)"
HumanEval_139,bul_Cyrl,swift,"
Например:// където n > 0 // бразилски_факториал (n) = n! * (n-1)! * (n-2)! * ... * 1! // Бразилският факториал е дефиниран като: /// >>> special_factorial(n: 4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
func special_factorial(n: Int) -> Int {
","func factorial(_ n: Int) -> Int {
    return n <= 1 ? 1 : n * factorial(n - 1)
}

func special_factorial(n: Int) -> Int {
    var result = 1
    for i in 1...n {
        result *= factorial(i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(special_factorial(n: 4) == 288)
assert(special_factorial(n: 5) == 34560)
assert(special_factorial(n: 7) == 125411328000)
assert(special_factorial(n: 1) == 1)"
HumanEval_140,bul_Cyrl,swift,"
// след това заменете всички последователни пробели с - // и ако една струна има повече от 2 последователни пространства, // Ако има текстов низ, заменете всички пространства с подчертаващи знаци, /// >>> fix_spaces(text: "" Example"")
/// ""Example""
/// >>> fix_spaces(text: "" Example 1"")
/// ""Example_1""
/// >>> fix_spaces(text: "" Example 2"")
/// ""_Example_2""
/// >>> fix_spaces(text: "" Example 3"")
/// ""_Example-3""
func fix_spaces(text: String) -> String {
","func fix_spaces(text: String) -> String {
    var result = """"
    var spaceCount = 0
    
    for character in text {
        if character == "" "" {
            spaceCount += 1
        } else {
            if spaceCount == 1 {
                result.append(""_"")
            } else if spaceCount > 1 {
                result.append(""-"")
            }
            result.append(character)
            spaceCount = 0
        }
    }
    
    if spaceCount == 1 {
        result.append(""_"")
    } else if spaceCount > 1 {
        result.append(""-"")
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: ""Example"") == ""Example"")
assert(fix_spaces(text: ""Mudasir Hanif "") == ""Mudasir_Hanif_"")
assert(fix_spaces(text: ""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"")
assert(fix_spaces(text: ""Exa   mple"") == ""Exa-mple"")
assert(fix_spaces(text: ""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"")"
HumanEval_141,bul_Cyrl,swift,"
// Примери: // - Подрядът след точката трябва да бъде един от тези: ['txt', 'exe', 'dll'] // латинската азбука ('a'-'z' и 'A'-'Z'). // - Подрядът преди точката не трябва да е празен, и започва с буквата от // - Името на файла съдържа точно една точка '.' // - В името на файла не трябва да има повече от три цифри ('0'-'9'). // са изпълнени: // Името на файла се счита за валидно, ако и само ако всички следните условия са изпълнени // ""Да"", ако името на файла е валидно, и връща ""Не"", в противен случай. // Създаване на функция, която взема буквен низ, представляващ името на файла, и връща /// >>> file_name_check(file_name: ""example.txt"")
/// ""Yes""
/// >>> file_name_check(file_name: ""1example.dll"")
/// ""No""
func file_name_check(file_name: String) -> String {
","func file_name_check(file_name: String) -> String {
    // Split by the dot.
    let components = file_name.split(separator: ""."", omittingEmptySubsequences: false)
    
    // Check if there's exactly one dot.
    guard components.count == 2 else {
        return ""No""
    }
    
    // Extract the prefix and suffix.
    let prefix = String(components[0])
    let suffix = String(components[1])
    
    // Check if the prefix is non-empty and starts with a letter.
    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {
        return ""No""
    }
    
    // Check if the suffix is one of the allowed types.
    let validSuffixes = [""txt"", ""exe"", ""dll""]
    guard validSuffixes.contains(suffix) else {
        return ""No""
    }
    
    // Count digits in the file name.
    let digitCount = file_name.filter { $0.isNumber }.count
    
    // Ensure that there are not more than 3 digits.
    guard digitCount <= 3 else {
        return ""No""
    }
    
    // If all checks pass, it's a valid file name.
    return ""Yes""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(file_name_check(file_name: ""example.txt"") == ""Yes"")
assert(file_name_check(file_name: ""1example.dll"") == ""No"")
assert(file_name_check(file_name: ""s1sdf3.asd"") == ""No"")
assert(file_name_check(file_name: ""K.dll"") == ""Yes"")
assert(file_name_check(file_name: ""MY16FILE3.exe"") == ""Yes"")
assert(file_name_check(file_name: ""His12FILE94.exe"") == ""No"")
assert(file_name_check(file_name: ""_Y.txt"") == ""No"")
assert(file_name_check(file_name: ""?aREYA.exe"") == ""No"")
assert(file_name_check(file_name: ""/this_is_valid.dll"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.wow"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.txt"") == ""Yes"")
assert(file_name_check(file_name: ""this_is_valid.txtexe"") == ""No"")
assert(file_name_check(file_name: ""#this2_i4s_5valid.ten"") == ""No"")
assert(file_name_check(file_name: ""@this1_is6_valid.exe"") == ""No"")
assert(file_name_check(file_name: ""this_is_12valid.6exe4.txt"") == ""No"")
assert(file_name_check(file_name: ""all.exe.txt"") == ""No"")
assert(file_name_check(file_name: ""I563_No.exe"") == ""Yes"")
assert(file_name_check(file_name: ""Is3youfault.txt"") == ""Yes"")
assert(file_name_check(file_name: ""no_one#knows.dll"") == ""Yes"")
assert(file_name_check(file_name: ""1I563_Yes3.exe"") == ""No"")
assert(file_name_check(file_name: ""I563_Yes3.txtt"") == ""No"")
assert(file_name_check(file_name: ""final..txt"") == ""No"")
assert(file_name_check(file_name: ""final132"") == ""No"")
assert(file_name_check(file_name: ""_f4indsartal132."") == ""No"")
assert(file_name_check(file_name: "".txt"") == ""No"")
assert(file_name_check(file_name: ""s."") == ""No"")"
HumanEval_143,bul_Cyrl,swift,"
// Пример 1: // реда на думите в новия ред трябва да бъде същият като оригиналния. // чиито дължини са прости числа, // и трябва да върнете низ, който съдържа думите от първоначалното изречение, // изречението съдържа няколко думи, разделени с пробела, // Даваме ви една нишка, която представлява изречение, /// >>> words_in_sentence(sentence: ""This is a test"")
/// ""is""
/// Example 2:
/// >>> words_in_sentence(sentence: ""lets go for swimming"")
/// ""go for""
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
func words_in_sentence(sentence: String) -> String {
","func words_in_sentence(sentence: String) -> String {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    let words = sentence.split(separator: "" "")
    let primeLengthWords = words.filter { isPrime($0.count) }
    return primeLengthWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_in_sentence(sentence: ""This is a test"") == ""is"")
assert(words_in_sentence(sentence: ""lets go for swimming"") == ""go for"")
assert(words_in_sentence(sentence: ""there is no place available here"") == ""there is no place"")
assert(words_in_sentence(sentence: ""Hi I am Hussein"") == ""Hi am Hussein"")
assert(words_in_sentence(sentence: ""go for it"") == ""go for it"")
assert(words_in_sentence(sentence: ""here"") == """")
assert(words_in_sentence(sentence: ""here is"") == ""is"")"
HumanEval_144,bul_Cyrl,swift,"
// Може да приемем, че х и n са валидни дробни и нямат нула като знаменател. // <числител>/<номинант>, където и числителът и знаменателят са положителни цели числа. И двете, x и n, са струнно представяне на дроб и имат следния формат, // x * n. Функцията връща true, ако x * n се оценява на цяло число и false // Вашата задача е да приложите функция, която ще опрости израза /// >>> simplify(x: ""1/5"", n: ""5/1"")
/// true
/// >>> simplify(x: ""1/6"", n: ""2/1"")
/// false
/// >>> simplify(x: ""7/10"", n: ""10/2"")
/// false
func simplify(x: String, n: String) -> Bool {
","func simplify(x: String, n: String) -> Bool {
    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {
        let parts = fraction.split(separator: ""/"").map { Int($0)! }
        return (numerator: parts[0], denominator: parts[1])
    }
    
    let (xNumerator, xDenominator) = parseFraction(fraction: x)
    let (nNumerator, nDenominator) = parseFraction(fraction: n)
    
    // Multiply the two fractions: (xNumerator * nNumerator) / (xDenominator * nDenominator)
    let resultNumerator = xNumerator * nNumerator
    let resultDenominator = xDenominator * nDenominator
    
    // Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator
    return resultNumerator % resultDenominator == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/6"", n: ""2/1"") == false)
assert(simplify(x: ""5/1"", n: ""3/1"") == true)
assert(simplify(x: ""7/10"", n: ""10/2"") == false)
assert(simplify(x: ""2/10"", n: ""50/10"") == true)
assert(simplify(x: ""7/2"", n: ""4/2"") == true)
assert(simplify(x: ""11/6"", n: ""6/1"") == true)
assert(simplify(x: ""2/3"", n: ""5/2"") == false)
assert(simplify(x: ""5/2"", n: ""3/5"") == false)
assert(simplify(x: ""2/4"", n: ""8/4"") == true)
assert(simplify(x: ""2/4"", n: ""4/2"") == true)
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/5"", n: ""1/5"") == false)"
HumanEval_145,bul_Cyrl,swift,"
Например:// подредете ги въз основа на индекса им в оригиналния масив. // Забележка: ако има няколко елемента със сходна сума на техните цифри, // в нарастващ ред според сумата на техните цифри. // Напишете функция, която сортира дадения масив от цели числа./// >>> order_by_points(nums: [1, 11, -1, -11, -12])
/// [-1, -11, 1, -12, 11]
/// >>> order_by_points(nums: [] as [Int])
/// [] as [Int]
func order_by_points(nums: [Int]) -> [Int] {
","func order_by_points(nums: [Int]) -> [Int] {
    return nums.enumerated().sorted {
        let sum1 = digitSum($0.element)
        let sum2 = digitSum($1.element)
        if sum1 == sum2 {
            return $0.offset < $1.offset
        } else {
            return sum1 < sum2
        }
    }.map { $0.element }
}

func digitSum(_ number: Int) -> Int {
    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])
assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])
assert(order_by_points(nums: [] as [Int]) == [] as [Int])
assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])
assert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])
assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
HumanEval_146,bul_Cyrl,swift,"
Например:// първата и последната цифра на числото са нечетни (1, 3, 5, 7, 9).// броя на елементите в масива, които са по-големи от 10 и двете // Напишете функция, която приема масив от числа като вход и връща /// >>> specialFilter(nums: [15, -73, 14, -15])
/// 1
/// >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])
/// 2
func specialFilter(nums: [Int]) -> Int {
","func specialFilter(nums: [Int]) -> Int {
    return nums.filter { num in
        let absNum = abs(num)
        
        guard absNum > 10 else {
            return false
        }
        
        let firstDigit = String(String(absNum).first!)
        let lastDigit = String(absNum % 10)
        
        let oddDigits: Set = [""1"", ""3"", ""5"", ""7"", ""9""]
        
        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(specialFilter(nums: [5, -2, 1, -5]) == 0)
assert(specialFilter(nums: [15, -73, 14, -15]) == 1)
assert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)
assert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)
assert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)
assert(specialFilter(nums: [1]) == 0)
assert(specialFilter(nums: [] as [Int]) == 0)"
HumanEval_147,bul_Cyrl,swift,"
// Пример: // и a[i] + a[j] + a[k] е кратно на 3. // Връща броя на тройките (a[i], a[j], a[k]) на a, където i < j < k, // За всяко i (1 ≤ i ≤ n), стойността на a[i] = i * i - i + 1. // Дадено ви е положително цяло число n. Трябва да създадете целочислен масив с дължина n. /// >>> get_max_triples(n: 5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
func get_max_triples(n: Int) -> Int {
","func get_max_triples(n: Int) -> Int {
    // Create the array a based on the problem description
    var a = [Int](repeating: 0, count: n)
    for i in 1...n {
        a[i - 1] = i * i - i + 1
    }
    
    var count = 0
    // Check for all possible triples
    for i in 0..<n {
        for j in (i + 1)..<n {
            for k in (j + 1)..<n {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count += 1
                }
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_max_triples(n: 5) == 1)
assert(get_max_triples(n: 6) == 4)
assert(get_max_triples(n: 10) == 36)
assert(get_max_triples(n: 100) == 53361)"
HumanEval_149,bul_Cyrl,swift,"
Например:// Може да предположите, че всички думи ще имат еднаква дължина. // Функцията трябва да върне масив от стрии в сортиран ред. // Ако две думи имат еднаква дължина, сортирайте масива по азбучен ред. // трябва да върне масив, сортиран по това правило. // Поръчката на масива трябва да бъде възходяща по дължина на всяка дума, и вие Може да има дубликати.// Масивът винаги е масив от струни и никога масив от числа, // и връща получения масив със сортиран ред, // изтрива низовете, които имат нечетна дължина от него, // Напишете функция, която приема масив от струнки като параметър, /// >>> sorted_list_sum(lst: [""aa"", ""a"", ""aaa""])
/// [""aa""]
/// >>> sorted_list_sum(lst: [""ab"", ""a"", ""aaa"", ""cd""])
/// [""ab"", ""cd""]
func sorted_list_sum(lst: [String]) -> [String] {
","func sorted_list_sum(lst: [String]) -> [String] {
    return lst.filter { $0.count % 2 == 0 }
              .sorted { 
                  if $0.count == $1.count {
                      return $0 < $1
                  }
                  return $0.count < $1.count
              }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sorted_list_sum(lst: [""aa"", ""a"", ""aaa""]) == [""aa""])
assert(sorted_list_sum(lst: [""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""])
assert(sorted_list_sum(lst: [""d"", ""b"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""])
assert(sorted_list_sum(lst: [""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""])
assert(sorted_list_sum(lst: [""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""aaaa"", ""bbbb"", ""dd"", ""cc""]) == [""cc"", ""dd"", ""aaaa"", ""bbbb""])"
HumanEval_150,bul_Cyrl,swift,"
// Примери: // първо число и трябва да върне стойността на y в противен случай. // Проста програма, която трябва да върне стойността на x, ако n е /// >>> x_or_y(n: 7, x: 34, y: 12)
/// 34
/// >>> x_or_y(n: 15, x: 8, y: 5)
/// 5
func x_or_y(n: Int, x: Int, y: Int) -> Int {
","func x_or_y(n: Int, x: Int, y: Int) -> Int {
    func isPrime(_ number: Int) -> Bool {
        if number <= 1 { return false }
        if number <= 3 { return true }
        if number % 2 == 0 || number % 3 == 0 { return false }
        
        var i = 5
        while i * i <= number {
            if number % i == 0 || number % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    return isPrime(n) ? x : y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(x_or_y(n: 7, x: 34, y: 12) == 34)
assert(x_or_y(n: 15, x: 8, y: 5) == 5)
assert(x_or_y(n: 3, x: 33, y: 5212) == 33)
assert(x_or_y(n: 1259, x: 3, y: 52) == 3)
assert(x_or_y(n: 7919, x: -1, y: 12) == -1)
assert(x_or_y(n: 3609, x: 1245, y: 583) == 583)
assert(x_or_y(n: 91, x: 56, y: 129) == 129)
assert(x_or_y(n: 6, x: 34, y: 1234) == 1234)
assert(x_or_y(n: 1, x: 2, y: 0) == 0)
assert(x_or_y(n: 2, x: 2, y: 0) == 2)"
HumanEval_151,bul_Cyrl,swift,"
Игнорирай числата, които са отрицателни или не са цели числа.// Дадена масив от числа, връща сумата на квадратите на числата./// >>> double_the_difference(lst: [1, 3, 2, 0])
/// 10
/// >>> double_the_difference(lst: [-1, -2, 0])
/// 0
/// >>> double_the_difference(lst: [9, -2])
/// 81
/// >>> double_the_difference(lst: [0])
/// 0
/// If the input array is empty, return 0.
func double_the_difference(lst: [Double]) -> Int {
","func double_the_difference(lst: [Double]) -> Int {
    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }
              .map { Int($0) * Int($0) }
              .reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(double_the_difference(lst: [] as [Double]) == 0)
assert(double_the_difference(lst: [5.0, 4.0]) == 25)
assert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)
assert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)
assert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)
assert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)
assert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"
HumanEval_152,bul_Cyrl,swift,"
// Пример: // стойността е 0, а ако не е, стойността е абсолютната разлика между предположението и резултата. // Връща масив със същата дължина, показващ колко далеч е било всяко предположение.// Имате два масива от резултати и предположения с еднаква дължина, където всеки индекс показва съвпадение. // Вашата задача е да определите дали човек е познал правилно резултатите от няколко съвпадения. // определено си струва да се отбележи и сравняване. Чувствата и мислите, които изпитваш в този момент са...Мисля, че всички помним това чувство, когато резултатът от дългоочакваното.../// >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])
/// [0, 0, 0, 0, 3, 3]
/// >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])
/// [4, 4, 1, 0, 0, 6]
func compare(game: [Int], guess: [Int]) -> [Int] {
","func compare(game: [Int], guess: [Int]) -> [Int] {
    var result: [Int] = []
    
    for i in 0..<game.count {
        let difference = abs(game[i] - guess[i])
        result.append(difference)
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])
assert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])
assert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])
assert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"
HumanEval_153,bul_Cyrl,swift,"
// Пример: (Силата му е -1).// връща ""Slices.SERVINGSliCes"", тъй като ""SERVINGSliCes"" е най-силното разширение // разширения: ['СЕРВИГСЛИЦИ', 'ЧИР', 'СТУФЕД'] тогава трябва да // Например, ако ви е дадена ""Slices"" като клас и масив от // Изберете този, който е първи в масива. Ако има две или повече разширения със същата сила, трябва да се направи // формат: ClassName.StrongestExtensionName. // Трябва да намерим най-силното разширение и да върнем един string в това // в името на разширението, силата се дава от фракцията CAP - SM. // букви в името на разширението, и нека SM е броят на малките букви // силата на разширението е следната: нека CAP е числото на големите букви // Разширенията се използват за зареждане на допълнителни класове към класа.// Ще ви бъде дадено името на клас (стрък) и масив от разширения. /// >>> Strongest_Extension(class_name: ""my_class"", extensions: [""AA"", ""Be"", ""CC""])
/// ""my_class.AA""
func Strongest_Extension(class_name: String, extensions: [String]) -> String {
","func Strongest_Extension(class_name: String, extensions: [String]) -> String {
    var strongestExtension: String? = nil
    var maxStrength = Int.min
    
    for ext in extensions {
        let cap = ext.filter { $0.isUppercase }.count
        let sm = ext.filter { $0.isLowercase }.count
        let strength = cap - sm
        
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = ext
        }
    }
    
    if let strongestExt = strongestExtension {
        return ""\(class_name).\(strongestExt)""
    }
    
    return class_name
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(Strongest_Extension(class_name: ""Watashi"", extensions: [""tEN"", ""niNE"", ""eIGHt8OKe""]) == ""Watashi.eIGHt8OKe"")
assert(Strongest_Extension(class_name: ""Boku123"", extensions: [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]) == ""Boku123.YEs.WeCaNe"")
assert(Strongest_Extension(class_name: ""__YESIMHERE"", extensions: [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]) == ""__YESIMHERE.NuLl__"")
assert(Strongest_Extension(class_name: ""K"", extensions: [""Ta"", ""TAR"", ""t234An"", ""cosSo""]) == ""K.TAR"")
assert(Strongest_Extension(class_name: ""__HAHA"", extensions: [""Tab"", ""123"", ""781345"", ""-_-""]) == ""__HAHA.123"")
assert(Strongest_Extension(class_name: ""YameRore"", extensions: [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]) == ""YameRore.okIWILL123"")
assert(Strongest_Extension(class_name: ""finNNalLLly"", extensions: [""Die"", ""NowW"", ""Wow"", ""WoW""]) == ""finNNalLLly.WoW"")
assert(Strongest_Extension(class_name: ""_"", extensions: [""Bb"", ""91245""]) == ""_.Bb"")
assert(Strongest_Extension(class_name: ""Sp"", extensions: [""671235"", ""Bb""]) == ""Sp.671235"")"
HumanEval_154,bul_Cyrl,swift,"
// Имате 2 думи. Трябва да върнете true, ако втората дума или някоя от нейните ротации е подряд в първата дума./// >>> cycpattern_check(a: ""abcd"", b: ""abd"")
/// false
/// >>> cycpattern_check(a: ""hello"", b: ""ell"")
/// true
/// >>> cycpattern_check(a: ""whassup"", b: ""psus"")
/// false
/// >>> cycpattern_check(a: ""abab"", b: ""baa"")
/// true
/// >>> cycpattern_check(a: ""efef"", b: ""eeff"")
/// false
/// >>> cycpattern_check(a: ""himenss"", b: ""simen"")
/// true
func cycpattern_check(a: String, b: String) -> Bool {
","func cycpattern_check(a: String, b: String) -> Bool {
    guard !b.isEmpty else { return true }
    let bCombined = b + b
    for i in 0..<b.count {
        let rotation = String(bCombined.dropFirst(i).prefix(b.count))
        if a.contains(rotation) {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(cycpattern_check(a: ""xyzw"", b: ""xyw"") == false)
assert(cycpattern_check(a: ""yello"", b: ""ell"") == true)
assert(cycpattern_check(a: ""whattup"", b: ""ptut"") == false)
assert(cycpattern_check(a: ""efef"", b: ""fee"") == true)
assert(cycpattern_check(a: ""abab"", b: ""aabb"") == false)
assert(cycpattern_check(a: ""winemtt"", b: ""tinem"") == true)"
HumanEval_155,bul_Cyrl,swift,"
// Пример: // При дадено цяло число. връща тупла, която има съответно броя на четните и нечетните цифри. /// >>> even_odd_count(num: -12)
/// (1, 1)
/// >>> even_odd_count(num: 123)
/// (1, 2)
func even_odd_count(num: Int) -> (Int, Int) {
","func even_odd_count(num: Int) -> (Int, Int) {
    var countEvens = 0
    var countOdds = 0
    var number = abs(num) // Handle negative numbers by taking absolute value

    while number > 0 {
        let digit = number % 10
        if digit % 2 == 0 {
            countEvens += 1
        } else {
            countOdds += 1
        }
        number /= 10
    }
    return (countEvens, countOdds)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_count(num: 7) == (0, 1))
assert(even_odd_count(num: -78) == (1, 1))
assert(even_odd_count(num: 3452) == (2, 2))
assert(even_odd_count(num: 346211) == (3, 3))
assert(even_odd_count(num: -345821) == (3, 3))
assert(even_odd_count(num: -2) == (1, 0))
assert(even_odd_count(num: -45347) == (2, 3))
assert(even_odd_count(num: 0) == (1, 0))"
HumanEval_156,bul_Cyrl,swift,"
// Примери: // Ограничения: 1 <= num <= 1000 // и да го върнем с малки букви. // Дадено положително цяло число, получете еквивалента му в римски цифри като низа, /// >>> int_to_mini_roman(number: 19)
/// ""xix""
/// >>> int_to_mini_roman(number: 152)
/// ""clii""
/// >>> int_to_mini_roman(number: 426)
/// ""cdxxvi""
func int_to_mini_roman(number: Int) -> String {
","func int_to_mini_roman(number: Int) -> String {
    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    let numerals = [""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""]
    
    var num = number
    var result = """"
    
    for (index, value) in values.enumerated() {
        while num >= value {
            result += numerals[index]
            num -= value
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(int_to_mini_roman(number: 19) == ""xix"")
assert(int_to_mini_roman(number: 152) == ""clii"")
assert(int_to_mini_roman(number: 251) == ""ccli"")
assert(int_to_mini_roman(number: 426) == ""cdxxvi"")
assert(int_to_mini_roman(number: 500) == ""d"")
assert(int_to_mini_roman(number: 1) == ""i"")
assert(int_to_mini_roman(number: 4) == ""iv"")
assert(int_to_mini_roman(number: 43) == ""xliii"")
assert(int_to_mini_roman(number: 90) == ""xc"")
assert(int_to_mini_roman(number: 94) == ""xciv"")
assert(int_to_mini_roman(number: 532) == ""dxxxii"")
assert(int_to_mini_roman(number: 900) == ""cm"")
assert(int_to_mini_roman(number: 994) == ""cmxciv"")
assert(int_to_mini_roman(number: 1000) == ""m"")"
HumanEval_157,bul_Cyrl,swift,"
// Пример: // 90 градуса. // Правоъгълният триъгълник е триъгълник, в който един ъгъл е прав ъгъл или // страни образуват правоъгълен триъгълник, в противен случай е невярно. // При условие, че са дължините на трите страни на триъгълник. Връща true, ако трите /// >>> right_angle_triangle(a: 3, b: 4, c: 5)
/// true
/// >>> right_angle_triangle(a: 1, b: 2, c: 3)
/// false
func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
","func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
    let sides = [a, b, c].sorted()
    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(right_angle_triangle(a: 3, b: 4, c: 5) == true)
assert(right_angle_triangle(a: 1, b: 2, c: 3) == false)
assert(right_angle_triangle(a: 10, b: 6, c: 8) == true)
assert(right_angle_triangle(a: 2, b: 2, c: 2) == false)
assert(right_angle_triangle(a: 7, b: 24, c: 25) == true)
assert(right_angle_triangle(a: 10, b: 5, c: 7) == false)
assert(right_angle_triangle(a: 5, b: 12, c: 13) == true)
assert(right_angle_triangle(a: 15, b: 8, c: 17) == true)
assert(right_angle_triangle(a: 48, b: 55, c: 73) == true)
assert(right_angle_triangle(a: 1, b: 1, c: 1) == false)
assert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"
HumanEval_158,bul_Cyrl,swift,"
// символи, връща този, който е първи по лексикографски ред. Ако няколко низове имат максимален брой уникални // Масивът съдържа различни думи. Връща думата с максимален брой // Напишете функция, която приема масив от струнки. /// >>> find_max(words: [""name"", ""of"", ""string""])
/// ""string""
/// >>> find_max(words: [""name"", ""enam"", ""game""])
/// ""enam""
/// >>> find_max(words: [""aaaaaaa"", ""bb"", ""cc""])
/// ""aaaaaaa""
func find_max(words: [String]) -> String {
","func find_max(words: [String]) -> String {
    func uniqueCharacterCount(in word: String) -> Int {
        return Set(word).count
    }
    
    return words.max { a, b in
        let uniqueCountA = uniqueCharacterCount(in: a)
        let uniqueCountB = uniqueCharacterCount(in: b)
        
        if uniqueCountA == uniqueCountB {
            return a > b
        }
        
        return uniqueCountA < uniqueCountB
    } ?? """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_max(words: [""name"", ""of"", ""string""]) == ""string"")
assert(find_max(words: [""name"", ""enam"", ""game""]) == ""enam"")
assert(find_max(words: [""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa"")
assert(find_max(words: [""abc"", ""cba""]) == ""abc"")
assert(find_max(words: [""play"", ""this"", ""game"", ""of"", ""footbott""]) == ""footbott"")
assert(find_max(words: [""we"", ""are"", ""gonna"", ""rock""]) == ""gonna"")
assert(find_max(words: [""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation"")
assert(find_max(words: [""this"", ""is"", ""a"", ""prrk""]) == ""this"")
assert(find_max(words: [""b""]) == ""b"")
assert(find_max(words: [""play"", ""play"", ""play""]) == ""play"")"
HumanEval_159,bul_Cyrl,swift,"
// Пример: Ако няма достатъчно остатъци от моркови, ще изядеш всички останали моркови, но все пак ще си гладен.// броя на морковите, останали след храненето ви] // трябва да върнете набор от [ общ брой на изядените моркови след хранене, Но сега трябва да ядеш повече моркови, за да завършиш дневното хранене.Ти си гладен заек, и вече си изял определен брой моркови./// >>> eat(number: 5, need: 6, remaining: 10)
/// [11, 4]
/// >>> eat(number: 4, need: 8, remaining: 9)
/// [12, 1]
/// >>> eat(number: 1, need: 10, remaining: 10)
/// [11, 0]
/// >>> eat(number: 2, need: 11, remaining: 5)
/// [7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
func eat(number: Int, need: Int, remaining: Int) -> [Int] {
","func eat(number: Int, need: Int, remaining: Int) -> [Int] {
    let totalNeeded = number + need
    let totalEaten = min(totalNeeded, number + remaining)
    let carrotsLeft = max(0, remaining - (totalEaten - number))
    return [totalEaten, carrotsLeft]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])
assert(eat(number: 4, need: 8, remaining: 9) == [12, 1])
assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])
assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])
assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])
assert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
HumanEval_160,bul_Cyrl,swift,"
// Operator array има поне един оператор, а operand array има поне два операнда. // Операнд е масив от неотрицателни цели числа. // Дължината на оператора е равна на дължината на операнда минус един.// Забележка: // => резултат = 9 // резултат = 2 + 3 * 4 - 5 // масив = [2, 3, 4, 5] // оператор['+', '*', '-'] // Пример: // Експоненциране (**) // Подзелено на етажи ( // ) // Умножение (*) // Отстраняване ( - ) // Слагане (+) // Основните алгебрични операции: // израз и връща оценката на този израз. // втория масив е масив от цели числа. Използвайте двата дадени масива за изграждане на алгебрата.Първият масив има основни алгебрични операции, а func do_algebra(operator: [String], operand: [Int]) -> Int {
","func do_algebra(operator: [String], operand: [Int]) -> Int {
    var result = operand[0]
    let precedence: [String: Int] = [""+"": 1, ""-"": 1, ""*"": 2, ""//"": 2, ""**"": 3]
    
    var opStack: [String] = []
    var numStack: [Int] = [result]
    
    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {
        switch op {
        case ""+"":
            return a + b
        case ""-"":
            return a - b
        case ""*"":
            return a * b
        case ""//"":
            return a / b
        case ""**"":
            return Int(pow(Double(a), Double(b)))
        default:
            fatalError(""Unsupported operator: \(op)"")
        }
    }
    
    for i in 0..<operator.count {
        let currentOp = `operator`[i]
        let currentNum = operand[i + 1]
        
        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {
            opStack.removeLast()
            let b = numStack.removeLast()
            let a = numStack.removeLast()
            numStack.append(applyOperator(lastOp, b, a))
        }
        
        opStack.append(currentOp)
        numStack.append(currentNum)
    }
    
    while let lastOp = opStack.popLast() {
        let b = numStack.removeLast()
        let a = numStack.removeLast()
        numStack.append(applyOperator(lastOp, b, a))
    }
    
    return numStack.first!
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(do_algebra(operator: [""**"", ""*"", ""+""], operand: [2, 3, 4, 5]) == 37)
assert(do_algebra(operator: [""+"", ""*"", ""-""], operand: [2, 3, 4, 5]) == 9)
assert(do_algebra(operator: [""//"", ""*""], operand: [7, 3, 4]) == 8)"
HumanEval_161,bul_Cyrl,swift,"
// Примери // Функцията трябва да върне резултата.// Ако нишката не съдържа букви, обърнете нишката. В противен случай, оставете нещата така.// ако s[i] е буква, обърнете буквата от долната към горната или обратно, // Дават ви string s. /// >>> solve(s: ""1234"")
/// ""4321""
/// >>> solve(s: ""ab"")
/// ""AB""
/// >>> solve(s: ""#a@C"")
/// ""#A@c""
func solve(s: String) -> String {
","func solve(s: String) -> String {
    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {
        return String(s.reversed())
    }
    
    var result = """"
    for char in s {
        if char.isLetter {
            if char.isLowercase {
                result.append(char.uppercased())
            } else {
                result.append(char.lowercased())
            }
        } else {
            result.append(char)
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: ""AsDf"") == ""aSdF"")
assert(solve(s: ""1234"") == ""4321"")
assert(solve(s: ""ab"") == ""AB"")
assert(solve(s: ""#a@C"") == ""#A@c"")
assert(solve(s: ""#AsdfW^45"") == ""#aSDFw^45"")
assert(solve(s: ""#6@2"") == ""2@6#"")
assert(solve(s: ""#$a^D"") == ""#$A^d"")
assert(solve(s: ""#ccc"") == ""#CCC"")"
HumanEval_162,bul_Cyrl,swift,"
// Ако 'text' е празен string, връща nil. // При наличие на строка 'text', върнете нейния md5 хеш еквивалентен строка. /// >>> string_to_md5(text: ""Hello world"")
/// ""3e25960a79dbc69b674cd4ec67a72c62""
func string_to_md5(text: String) -> String? {
","import Foundation
import CommonCrypto

func string_to_md5(text: String) -> String? {
    guard !text.isEmpty else { return nil }
    
    let length = Int(CC_MD5_DIGEST_LENGTH)
    let messageData = text.data(using: .utf8)!
    var digestData = Data(count: length)
    
    _ = digestData.withUnsafeMutableBytes { digestBytes in
        messageData.withUnsafeBytes { messageBytes in
            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)
        }
    }
    
    return digestData.map { String(format: ""%02hhx"", $0) }.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_to_md5(text: ""Hello world"") == ""3e25960a79dbc69b674cd4ec67a72c62"")
assert(string_to_md5(text: """") == nil)
assert(string_to_md5(text: ""A B C"") == ""0ef78513b0cb8cef12743f5aeb35f888"")
assert(string_to_md5(text: ""password"") == ""5f4dcc3b5aa765d61d8327deb882cf99"")"
HumanEval_163,bul_Cyrl,swift,"
Например:// и b, в нарастващ ред. // Като се имат предвид две положителни цели числа a и b, върнете четните цифри между a /// >>> generate_integers(a: 2, b: 8)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 8, b: 2)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 10, b: 14)
/// [] as [Int]
func generate_integers(a: Int, b: Int) -> [Int] {
","func generate_integers(a: Int, b: Int) -> [Int] {
    let lower = min(a, b)
    let upper = max(a, b)
    var result = [Int]()
    
    for number in lower...upper {
        if number % 2 == 0 {
            result.append(number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])
assert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 17, b: 89) == [] as [Int])"
