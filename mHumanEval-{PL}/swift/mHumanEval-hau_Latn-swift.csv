task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,hau_Latn,swift,"
// an ba da ƙofar. // Bincika idan a cikin jerin lambobi, akwai wasu lambobi biyu da ke kusa da juna fiye da /// >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)
/// false
/// >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)
/// true
func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
","func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
    let sortedNumbers = numbers.sorted()
    for i in 0..<sortedNumbers.count - 1 {
        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"
HumanEval_1,hau_Latn,swift,"
// Ka yi watsi da duk wani sarari a cikin layin shigarwa. // Ƙungiyoyi daban-daban suna daidaita (kowane buɗewa yana rufewa sosai) kuma ba a haɗa su cikin juna ba // raba waɗannan rukuni zuwa cikin keɓaɓɓun zaren kuma dawo da jeri na waɗancan. // Input ga wannan aiki ne mai kirtani dauke da mahara kungiyoyin nested iyaka./// >>> separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"")
/// [""()"", ""(())"", ""(()())""]
func separate_paren_groups(paren_string: String) -> [String] {
","func separate_paren_groups(paren_string: String) -> [String] {
    var results = [String]()
    var currentGroup = """"
    var balance = 0

    for char in paren_string {
        // Ignore spaces
        if char == "" "" {
            continue
        }
        
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }

        currentGroup.append(char)

        if balance == 0 && !currentGroup.isEmpty {
            results.append(currentGroup)
            currentGroup = """"
        }
    }
    
    return results
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(separate_paren_groups(paren_string: ""(()()) ((())) () ((())()())"") == [""(()())"", ""((()))"", ""()"", ""((())()())""])
assert(separate_paren_groups(paren_string: ""() (()) ((())) (((())))"") == [""()"", ""(())"", ""((()))"", ""(((())))""])
assert(separate_paren_groups(paren_string: ""(()(())((())))"") == [""(()(())((())))""])
assert(separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"") == [""()"", ""(())"", ""(()())""])"
HumanEval_2,hau_Latn,swift,"
// Koma da goma na lambar. // (rabin da ya rage koyaushe ya fi ƙasa da 1). // da ɓangaren ɗabi'a (mafi girman ɗabi'a mafi ƙanƙanta fiye da lambar da aka ba) da kuma ƙididdiga // An ba da lambar mai canzawa mai kyau, ana iya rushe shi zuwa /// >>> truncate_number(number: 3.5)
/// 0.5
func truncate_number(number: Double) -> Double {
","func truncate_number(number: Double) -> Double {
    return number - Double(Int(number))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(truncate_number(number: 3.5) == 0.5)
assert(truncate_number(number: 1.25) == 0.25)
assert(truncate_number(number: 123.0) == 0.0)"
HumanEval_3,hau_Latn,swift,"
// a wannan lokacin aikin ya kamata ya dawo gaskiya. In ba haka ba ya kamata ya dawo ƙarya. // zero balance. Your aiki ne don gane idan a kowane batu da balance na account faduwa kasa da sifili, kuma // An ba ku jerin ayyukan ajiya da cirewa a kan asusun banki wanda ya fara da /// >>> below_zero(operations: [1, 2, 3])
/// false
/// >>> below_zero(operations: [1, 2, -4, 5])
/// true
func below_zero(operations: [Int]) -> Bool {
","func below_zero(operations: [Int]) -> Bool {
    var balance = 0
    for operation in operations {
        balance += operation
        if balance < 0 {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_zero(operations: [] as [Int]) == false)
assert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)
assert(below_zero(operations: [1, 2, -4, 5, 6]) == true)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)
assert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"
HumanEval_4,hau_Latn,swift,"
// MAD = matsakaici ∙ x - x_mean ∙// kashi da kuma cibiyar cibiyar (ma'ana a wannan yanayin): // Ma'anar Ma'anar Ma'anar Ma'anar ita ce matsakaicin bambancin da ke tsakanin kowane // a kusa da matsakaicin wannan dataset. // Don wani saitin na shigar lambobi, lissafi Ma'ana cikakkiyar karkacewa /// >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])
/// 1.0
func mean_absolute_deviation(numbers: [Double]) -> Double {
","func mean_absolute_deviation(numbers: [Double]) -> Double {
    guard !numbers.isEmpty else { return 0.0 }
    
    let mean = numbers.reduce(0.0, +) / Double(numbers.count)
    let absoluteDifferences = numbers.map { abs($0 - mean) }
    let mad = absoluteDifferences.reduce(0.0, +) / Double(absoluteDifferences.count)
    
    return mad
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"
HumanEval_5,hau_Latn,swift,"
// Saka lamba 'delimeter' tsakanin kowane abubuwa biyu na jere na shigarwa array `numbers' /// >>> intersperse(numbers: [] as [Int], delimeter: 4)
/// [] as [Int]
/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)
/// [1, 4, 2, 4, 3]
func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
","func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
    guard !numbers.isEmpty else { return [] }
    
    var result: [Int] = []
    
    for number in numbers {
        result.append(number)
        result.append(delimeter)
    }
    
    // Remove the last added delimiter
    result.removeLast()
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])
assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])
assert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
HumanEval_6,hau_Latn,swift,"
// Misali (() (()) yana da matsakaicin matakai biyu na nesting yayin da ((())) yana da uku. // Ga kowane rukuni, fitarwa mafi zurfi matakin nesting na parentheses. // Input ga wannan aiki ne mai kirtani wakilci mahara kungiyoyin for nested iyaye rabu da sarari. /// >>> parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"")
/// [2, 3, 1, 3]
func parse_nested_parens(paren_string: String) -> [Int] {
","func parse_nested_parens(paren_string: String) -> [Int] {
    let groups = paren_string.split(separator: "" "")
    var depths: [Int] = []
    
    for group in groups {
        var maxDepth = 0
        var currentDepth = 0
        
        for char in group {
            if char == ""("" {
                currentDepth += 1
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == "")"" {
                currentDepth -= 1
            }
        }
        
        depths.append(maxDepth)
    }
    
    return depths
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"") == [2, 3, 1, 3])
assert(parse_nested_parens(paren_string: ""() (()) ((())) (((())))"") == [1, 2, 3, 4])
assert(parse_nested_parens(paren_string: ""(()(())((())))"") == [4])"
HumanEval_7,hau_Latn,swift,"
// Tace wani shigar da tsararru na kirtani kawai ga wadanda cewa dauke da aka ba substring /// >>> filter_by_substring(strings: [] as [String], substring: ""a"")
/// [] as [String]
/// >>> filter_by_substring(strings: [""abc"", ""bacd"", ""cde"", ""array""], substring: ""a"")
/// [""abc"", ""bacd"", ""array""]
func filter_by_substring(strings: [String], substring: String) -> [String] {
","func filter_by_substring(strings: [String], substring: String) -> [String] {
    return strings.filter { $0.contains(substring) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_substring(strings: [] as [String], substring: ""john"") == [] as [String])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xx"") == [""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""grunt"", ""trumpet"", ""prune"", ""gruesome""], substring: ""run"") == [""grunt"", ""prune""])"
HumanEval_8,hau_Latn,swift,"
// Sumar da ba ta da komai ya zama daidai da 0 kuma samfurin da ba shi da komai ya zama daidai da 1. // Ga wani sa na integers, dawo da wani tuple kunshi wani jimla da kuma wani samfurin dukan integers a cikin wani tsararru. /// >>> sum_product(numbers: [] as [Int])
/// (0, 1)
/// >>> sum_product(numbers: [1, 2, 3, 4])
/// (10, 24)
func sum_product(numbers: [Int]) -> (Int, Int) {
","func sum_product(numbers: [Int]) -> (Int, Int) {
    let sum = numbers.reduce(0, +)
    let product = numbers.reduce(1, *)
    return (sum, product)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_product(numbers: [] as [Int]) == (0, 1))
assert(sum_product(numbers: [1, 1, 1]) == (3, 1))
assert(sum_product(numbers: [100, 0]) == (100, 0))
assert(sum_product(numbers: [3, 5, 7]) == (15, 105))
assert(sum_product(numbers: [10]) == (10, 10))"
HumanEval_9,hau_Latn,swift,"
// a cikin jerin. // Daga wani saitin na integers, samar da wani saitin na mirgina iyakar kashi samu har zuwa ba lokacin /// >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])
/// [1, 2, 3, 3, 3, 4, 4]
func rolling_max(numbers: [Int]) -> [Int] {
","func rolling_max(numbers: [Int]) -> [Int] {
    var result = [Int]()
    var currentMax: Int? = nil
    for number in numbers {
        if let max = currentMax {
            currentMax = max > number ? max : number
        } else {
            currentMax = number
        }
        result.append(currentMax!)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rolling_max(numbers: [] as [Int]) == [] as [Int])
assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])
assert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
HumanEval_10,hau_Latn,swift,"
// - Ƙara zuwa ƙarshen layin layin layin layin da ya zo kafin palindromic suffix. // - Nemo mafi tsawo postfix na samar da kirtani wanda yake palindrome. // Algorithm ra'ayin mai sauki ne: // Nemo mafi guntu palindrome da ya fara da wani tsararru da aka bayar. /// >>> make_palindrome(string: """")
/// """"
/// >>> make_palindrome(string: ""cat"")
/// ""catac""
/// >>> make_palindrome(string: ""cata"")
/// ""catac""
func make_palindrome(string: String) -> String {
","func make_palindrome(string: String) -> String {
    func isPalindrome(_ s: String) -> Bool {
        return s == String(s.reversed())
    }
    
    if string.isEmpty || isPalindrome(string) {
        return string
    }
    
    for i in stride(from: string.count, through: 0, by: -1) {
        let suffixIndex = string.index(string.startIndex, offsetBy: i)
        let suffix = String(string[suffixIndex..<string.endIndex])
        if isPalindrome(suffix) {
            let prefix = String(string[string.startIndex..<suffixIndex])
            return string + String(prefix.reversed())
        }
    }
    
    return string
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_palindrome(string: """") == """")
assert(make_palindrome(string: ""x"") == ""x"")
assert(make_palindrome(string: ""xyz"") == ""xyzyx"")
assert(make_palindrome(string: ""xyx"") == ""xyx"")
assert(make_palindrome(string: ""jerry"") == ""jerryrrej"")"
HumanEval_11,hau_Latn,swift,"
// Yi binary XOR a kan waɗannan shigarwar kuma dawo da sakamakon kuma a matsayin kirtani. // Input ne biyu kirtani a da b kunshi kawai 1s da 0s. /// >>> string_xor(a: ""010"", b: ""110"")
/// ""100""
func string_xor(a: String, b: String) -> String {
","func string_xor(a: String, b: String) -> String {
    let charactersA = Array(a)
    let charactersB = Array(b)
    var result = """"

    for i in 0..<charactersA.count {
        let bitA = charactersA[i]
        let bitB = charactersB[i]
        
        if bitA != bitB {
            result.append(""1"")
        } else {
            result.append(""0"")
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: ""111000"", b: ""101010"") == ""010010"")
assert(string_xor(a: ""1"", b: ""1"") == ""0"")
assert(string_xor(a: ""0101"", b: ""0000"") == ""0101"")"
HumanEval_12,hau_Latn,swift,"
// kirtani na tsawon lokaci guda. Komawa null idan shigar da matrix ne m. // Daga cikin jerin kirtani, dawo da mafi tsawo daya. Koma na farko daya a yanayin da mahara /// >>> longest(strings: [] as [String])
/// nil
/// >>> longest(strings: [""a"", ""b"", ""c""])
/// ""a""
/// >>> longest(strings: [""a"", ""bb"", ""ccc""])
/// ""ccc""
func longest(strings: [String]) -> String? {
","func longest(strings: [String]) -> String? {
    guard !strings.isEmpty else { return nil }
    var longestString = strings[0]
    for string in strings {
        if string.count > longestString.count {
            longestString = string
        }
    }
    return longestString
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(longest(strings: [] as [String]) == nil)
assert(longest(strings: [""x"", ""y"", ""z""]) == ""x"")
assert(longest(strings: [""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]) == ""zzzz"")"
HumanEval_13,hau_Latn,swift,"
// Koma mafi girma na kowa divisor biyu integers a da b /// >>> greatest_common_divisor(a: 3, b: 5)
/// 1
/// >>> greatest_common_divisor(a: 25, b: 15)
/// 5
func greatest_common_divisor(a: Int, b: Int) -> Int {
","func greatest_common_divisor(a: Int, b: Int) -> Int {
    if b == 0 {
        return a
    } else {
        return greatest_common_divisor(a: b, b: a % b)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(greatest_common_divisor(a: 3, b: 7) == 1)
assert(greatest_common_divisor(a: 10, b: 15) == 5)
assert(greatest_common_divisor(a: 49, b: 14) == 7)
assert(greatest_common_divisor(a: 144, b: 60) == 12)"
HumanEval_14,hau_Latn,swift,"
// Koma array na duk prefixes daga gajere zuwa mafi tsawo na shigar da kirtani /// >>> all_prefixes(string: ""abc"")
/// [""a"", ""ab"", ""abc""]
func all_prefixes(string: String) -> [String] {
","func all_prefixes(string: String) -> [String] {
    var prefixes: [String] = []
    for i in 1...string.count {
        let prefix = String(string.prefix(i))
        prefixes.append(prefix)
    }
    return prefixes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(all_prefixes(string: """") == [] as [String])
assert(all_prefixes(string: ""asdfgh"") == [""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""])
assert(all_prefixes(string: ""WWW"") == [""W"", ""WW"", ""WWW""])"
HumanEval_15,hau_Latn,swift,"
// Koma wani kirtani dauke da sarari-delimited lambobi fara daga 0 upto n hada. /// >>> string_sequence(n: 0)
/// ""0""
/// >>> string_sequence(n: 5)
/// ""0 1 2 3 4 5""
func string_sequence(n: Int) -> String {
","func string_sequence(n: Int) -> String {
    return (0...n).map { String($0) }.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_sequence(n: 0) == ""0"")
assert(string_sequence(n: 3) == ""0 1 2 3"")
assert(string_sequence(n: 10) == ""0 1 2 3 4 5 6 7 8 9 10"")"
HumanEval_16,hau_Latn,swift,"
// An ba da kirtani, gano yawan haruffa daban-daban (ba tare da la'akari da shari'ar ba) ya ƙunshi /// >>> count_distinct_characters(string: ""xyzXYZ"")
/// 3
/// >>> count_distinct_characters(string: ""Jerry"")
/// 4
func count_distinct_characters(string: String) -> Int {
","func count_distinct_characters(string: String) -> Int {
    let lowercasedString = string.lowercased()
    let distinctCharacters = Set(lowercasedString)
    return distinctCharacters.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_distinct_characters(string: """") == 0)
assert(count_distinct_characters(string: ""abcde"") == 5)
assert(count_distinct_characters(string: ""abcdecadeCADE"") == 5)
assert(count_distinct_characters(string: ""aaaaAAAAaaaa"") == 1)
assert(count_distinct_characters(string: ""Jerry jERRY JeRRRY"") == 5)"
HumanEval_17,hau_Latn,swift,"
'Daidaita' - bayanin kula na hudu, yana da tsawon lokaci guda.// 'o "" dakata "" - rabin bayanin kula, yana da biyu beats // 'o' - cikakkiyar bayanin kula, yana da tsawon lokaci hudu // Ga wani labari: // ba na ƙarshe ba. // Aikinku shine bincika wannan kirtani kuma dawo da jerin lambobi masu dacewa da yawan bugun jini kowannensu yake yi // Shigarwa zuwa wannan aikin shine kirtani mai wakiltar bayanan kiɗa a cikin tsarin ASCII na musamman. /// >>> parse_music(music_string: ""o o| .| o| o| .| .| .| .| o o"")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
","func parse_music(music_string: String) -> [Int] {
    let notes = music_string.split(separator: "" "")
    var beats: [Int] = []
    
    for note in notes {
        switch note {
        case ""o"":
            beats.append(4)
        case ""o|"":
            beats.append(2)
        case "".|"":
            beats.append(1)
        default:
            continue
        }
    }
    
    return beats
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: """") == [] as [Int])
assert(parse_music(music_string: ""o o o o"") == [4, 4, 4, 4])
assert(parse_music(music_string: "".| .| .| .|"") == [1, 1, 1, 1])
assert(parse_music(music_string: ""o| o| .| .| o o o o"") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: ""o| .| o| .| o o| o o|"") == [2, 1, 2, 1, 4, 2, 4, 2])"
HumanEval_18,hau_Latn,swift,"
// Gano sau nawa za a iya samun wani takamaiman substring a cikin asalin kirtani. Karanta lokuta masu juyawa. /// >>> how_many_times(string: """", substring: ""a"")
/// 0
/// >>> how_many_times(string: ""aaa"", substring: ""a"")
/// 3
/// >>> how_many_times(string: ""aaaa"", substring: ""aa"")
/// 3
func how_many_times(string: String, substring: String) -> Int {
","func how_many_times(string: String, substring: String) -> Int {
    guard !substring.isEmpty else { return 0 }
    
    var count = 0
    var startIndex = string.startIndex
    
    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {
        count += 1
        startIndex = string.index(after: range.lowerBound)
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(how_many_times(string: """", substring: ""x"") == 0)
assert(how_many_times(string: ""xyxyxyx"", substring: ""x"") == 4)
assert(how_many_times(string: ""cacacacac"", substring: ""cac"") == 4)
assert(how_many_times(string: ""john doe"", substring: ""john"") == 1)"
HumanEval_19,hau_Latn,swift,"
// Koma da kirtani da lambobi da aka jera daga karami zuwa babba // Zaɓuɓɓuka masu inganci sune 'sifili', 'ɗaya', 'biyu', 'uku', 'hudu', 'biyar', 'shida', 'bakwai', 'takwas' da 'tara'. // Input ne sarari-delimited kirtani na numeral daga 'sifili' to 'tara'. /// >>> sort_numbers(numbers: ""three one five"")
/// ""one three five""
func sort_numbers(numbers: String) -> String {
","func sort_numbers(numbers: String) -> String {
    // Mapping of word numbers to digits
    let numberWords: [String: Int] = [
        ""zero"": 0,
        ""one"": 1,
        ""two"": 2,
        ""three"": 3,
        ""four"": 4,
        ""five"": 5,
        ""six"": 6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"": 9
    ]

    // Split the input string into words
    let words = numbers.split(separator: "" "")

    // Sort the words based on their corresponding number values
    let sortedWords = words.sorted { 
        numberWords[String($0)]! < numberWords[String($1)]! 
    }

    // Join the sorted words back into a single string
    return sortedWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_numbers(numbers: """") == """")
assert(sort_numbers(numbers: ""three"") == ""three"")
assert(sort_numbers(numbers: ""three five nine"") == ""three five nine"")
assert(sort_numbers(numbers: ""five zero four seven nine eight"") == ""zero four five seven eight nine"")
assert(sort_numbers(numbers: ""six five four three two one zero"") == ""zero one two three four five six"")"
HumanEval_20,hau_Latn,swift,"
// wasu kuma dawo da su a cikin tsari (mafi ƙarancin lamba, mafi girma lamba). // Daga jerin lambobi da aka bayar (na tsawon akalla biyu) zaɓi kuma dawo da biyu waɗanda suka fi kusa da kowane /// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
func find_closest_elements(numbers: [Double]) -> (Double, Double) {
","func find_closest_elements(numbers: [Double]) -> (Double, Double) {
    // Sort the array to bring closest numbers next to each other
    let sortedNumbers = numbers.sorted()
    
    // Initialize variables to keep track of the smallest difference and the pair
    var minDifference = Double.greatestFiniteMagnitude
    var closestPair: (Double, Double) = (0.0, 0.0)
    
    // Iterate over the sorted numbers to find the smallest difference
    for i in 0..<sortedNumbers.count - 1 {
        let num1 = sortedNumbers[i]
        let num2 = sortedNumbers[i + 1]
        let difference = abs(num1 - num2)
        
        if difference < minDifference {
            minDifference = difference
            closestPair = (num1, num2)
        }
    }
    
    return closestPair
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))
assert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))
assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
HumanEval_21,hau_Latn,swift,"
// irin wannan cewa mafi ƙarancin lamba zai zama 0 kuma mafi girma zai zama 1 // An ba da jerin lambobi (aƙalla abubuwa biyu), yi amfani da canjin layi zuwa wannan jerin, /// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])
/// [0.0, 0.25, 0.5, 0.75, 1.0]
func rescale_to_unit(numbers: [Double]) -> [Double] {
","func rescale_to_unit(numbers: [Double]) -> [Double] {
    guard numbers.count > 1 else { return numbers }
    
    let minValue = numbers.min()!
    let maxValue = numbers.max()!
    let range = maxValue - minValue
    
    guard range != 0 else {
        return numbers.map { _ in 0.0 }
    }
    
    return numbers.map { ($0 - minValue) / range }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])
assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])
assert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])
assert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])
assert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
HumanEval_22,hau_Latn,swift,"
// Filter ba sa na kowane swiftthon dabi'u kawai ga integers /// >>> filter_integers(values: [""a"", 3.14, 5])
/// [5]
/// >>> filter_integers(values: [1, 2, 3, ""abc"", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])
/// [1, 2, 3]
func filter_integers(values: [AnyHashable]) -> [Int] {
","func filter_integers(values: [AnyHashable]) -> [Int] {
    return values.compactMap { $0 as? Int }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])
assert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, ""adasd""]) == [4, 9])
assert(filter_integers(values: [3, ""c"", 3, 3, ""a"", ""b""]) == [3, 3, 3])"
HumanEval_23,hau_Latn,swift,"
// Koma tsawon layin da aka bayar /// >>> strlen(string: """")
/// 0
/// >>> strlen(string: ""abc"")
/// 3
func strlen(string: String) -> Int {
","func strlen(string: String) -> Int {
    return string.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strlen(string: """") == 0)
assert(strlen(string: ""x"") == 1)
assert(strlen(string: ""asdasnakj"") == 9)"
HumanEval_24,hau_Latn,swift,"
// Ga lambar da aka ba n, sami mafi girma lambar da ya raba n ko da yaushe, karami fiye da n /// >>> largest_divisor(n: 15)
/// 5
func largest_divisor(n: Int) -> Int {
","func largest_divisor(n: Int) -> Int {
    for i in stride(from: n / 2, to: 0, by: -1) {
        if n % i == 0 {
            return i
        }
    }
    return 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_divisor(n: 3) == 1)
assert(largest_divisor(n: 7) == 1)
assert(largest_divisor(n: 10) == 5)
assert(largest_divisor(n: 100) == 50)
assert(largest_divisor(n: 49) == 7)"
HumanEval_25,hau_Latn,swift,"
// Input lamba ya zama daidai da samfurin dukan dalilai // Kowane daga cikin abubuwan da ya kamata a saita adadin sau daidai da sau nawa ya bayyana a factorization. // Koma array na firaministan dalilai na ba da lamba a cikin tsari daga karami zuwa mafi girma. /// >>> factorize(n: 8)
/// [2, 2, 2]
/// >>> factorize(n: 25)
/// [5, 5]
/// >>> factorize(n: 70)
/// [2, 5, 7]
func factorize(n: Int) -> [Int] {
","func factorize(n: Int) -> [Int] {
    guard n > 1 else { return [] }
    var number = n
    var factors: [Int] = []
    var divisor = 2
    
    while number >= divisor {
        while number % divisor == 0 {
            factors.append(divisor)
            number /= divisor
        }
        divisor += 1
    }
    
    return factors
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(factorize(n: 2) == [2])
assert(factorize(n: 4) == [2, 2])
assert(factorize(n: 8) == [2, 2, 2])
assert(factorize(n: 57) == [3, 19])
assert(factorize(n: 3249) == [3, 3, 19, 19])
assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])
assert(factorize(n: 20577) == [3, 19, 19, 19])
assert(factorize(n: 18) == [2, 3, 3])"
HumanEval_26,hau_Latn,swift,"
// Ka kiyaye tsari na abubuwa bar guda kamar yadda a cikin shigar. // Daga jerin lambobi, cire dukkan abubuwan da suka faru fiye da sau daya. /// >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])
/// [1, 3, 4]
func remove_duplicates(numbers: [Int]) -> [Int] {
","func remove_duplicates(numbers: [Int]) -> [Int] {
    var elementCount = [Int: Int]()
    for number in numbers {
        elementCount[number, default: 0] += 1
    }
    return numbers.filter { elementCount[$0] == 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])
assert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
HumanEval_27,hau_Latn,swift,"
// Don a ba da kirtani, juyawa ƙananan haruffa zuwa babban haruffa da babban haruffa zuwa ƙananan haruffa. /// >>> flip_case(string: ""Hello"")
/// ""hELLO""
func flip_case(string: String) -> String {
","func flip_case(string: String) -> String {
    return String(string.map { character in
        if character.isLowercase {
            return character.uppercased()
        } else if character.isUppercase {
            return character.lowercased()
        } else {
            return String(character)
        }
    }.joined())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: """") == """")
assert(flip_case(string: ""Hello!"") == ""hELLO!"")
assert(flip_case(string: ""These violent delights have violent ends"") == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")"
HumanEval_28,hau_Latn,swift,"
// Concatenate array na kirtani a cikin guda kirtani /// >>> concatenate(strings: [] as [String])
/// """"
/// >>> concatenate(strings: [""a"", ""b"", ""c""])
/// ""abc""
func concatenate(strings: [String]) -> String {
","func concatenate(strings: [String]) -> String {
    return strings.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(concatenate(strings: [] as [String]) == """")
assert(concatenate(strings: [""x"", ""y"", ""z""]) == ""xyz"")
assert(concatenate(strings: [""x"", ""y"", ""z"", ""w"", ""k""]) == ""xyzwk"")"
HumanEval_29,hau_Latn,swift,"
// Tace wani shigar da tsararru na kirtani kawai ga wadanda suka fara da wani prefix. /// >>> filter_by_prefix(strings: [] as [String], prefix: ""a"")
/// [] as [String]
/// >>> filter_by_prefix(strings: [""abc"", ""bcd"", ""cde"", ""array""], prefix: ""a"")
/// [""abc"", ""array""]
func filter_by_prefix(strings: [String], prefix: String) -> [String] {
","func filter_by_prefix(strings: [String], prefix: String) -> [String] {
    return strings.filter { $0.hasPrefix(prefix) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_prefix(strings: [] as [String], prefix: ""john"") == [] as [String])
assert(filter_by_prefix(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], prefix: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])"
HumanEval_30,hau_Latn,swift,"
// Koma kawai lambobi masu kyau a cikin tsararru. /// >>> get_positive(l: [-1, 2, -4, 5, 6])
/// [2, 5, 6]
/// >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// [5, 3, 2, 3, 9, 123, 1]
func get_positive(l: [Int]) -> [Int] {
","func get_positive(l: [Int]) -> [Int] {
    return l.filter { $0 > 0 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])
assert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])
assert(get_positive(l: [-1, -2]) == [] as [Int])
assert(get_positive(l: [] as [Int]) == [] as [Int])"
HumanEval_31,hau_Latn,swift,"
// Koma gaskiya idan an ba da lambar farko, kuma ƙarya in ba haka ba. /// >>> is_prime(n: 6)
/// false
/// >>> is_prime(n: 101)
/// true
/// >>> is_prime(n: 11)
/// true
/// >>> is_prime(n: 13441)
/// true
/// >>> is_prime(n: 61)
/// true
/// >>> is_prime(n: 4)
/// false
/// >>> is_prime(n: 1)
/// false
func is_prime(n: Int) -> Bool {
","func is_prime(n: Int) -> Bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    var i = 5
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_prime(n: 6) == false)
assert(is_prime(n: 101) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 13441) == true)
assert(is_prime(n: 61) == true)
assert(is_prime(n: 4) == false)
assert(is_prime(n: 1) == false)
assert(is_prime(n: 5) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 17) == true)
assert(is_prime(n: 85) == false)
assert(is_prime(n: 77) == false)
assert(is_prime(n: 255379) == false)"
HumanEval_33,hau_Latn,swift,"
// zuwa ga dabi'u na daidai indices na l, amma ana rarraba su. // l' daidai yake da l a cikin alamun da ba za a iya raba su da uku ba, yayin da ƙimominsa a cikin alamun da za a iya raba su da uku daidai suke // Wannan aikin yana ɗaukar jeri l kuma ya dawo da jeri l' irin wannan cewa /// >>> sort_third(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])
/// [2, 6, 3, 4, 8, 9, 5]
func sort_third(l: [Int]) -> [Int] {
","func sort_third(l: [Int]) -> [Int] {
    // Collect indices and their values where index is divisible by 3
    var divisibleByThreeValues: [(index: Int, value: Int)] = []
    for (index, value) in l.enumerated() where index % 3 == 0 {
        divisibleByThreeValues.append((index, value))
    }
    
    // Sort the values that were at the indices divisible by 3
    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()
    
    // Create a mutable copy of original array to modify
    var result = l
    
    // Replace the sorted values back into their original indices
    for (i, sortedValue) in sortedValues.enumerated() {
        result[divisibleByThreeValues[i].index] = sortedValue
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])
assert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])
assert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"
HumanEval_34,hau_Latn,swift,"
// Komawa abubuwa masu banbanci da aka tsara a cikin tsararru /// >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [0, 2, 3, 5, 9, 123]
func unique(l: [Int]) -> [Int] {
","func unique(l: [Int]) -> [Int] {
    return Array(Set(l)).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"
HumanEval_35,hau_Latn,swift,"
// Koma mafi girman kashi a cikin tsararru. /// >>> max_element(l: [1, 2, 3])
/// 3
/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
func max_element(l: [Int]) -> Int {
","func max_element(l: [Int]) -> Int {
    guard let max = l.max() else {
        fatalError(""Array should not be empty"")
    }
    return max
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_element(l: [1, 2, 3]) == 3)
assert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
HumanEval_36,hau_Latn,swift,"
// Koma yawan lokutan da lambar 7 ta bayyana a cikin lambobi ƙasa da n waɗanda za a iya raba su da 11 ko 13. /// >>> fizz_buzz(n: 50)
/// 0
/// >>> fizz_buzz(n: 78)
/// 2
/// >>> fizz_buzz(n: 79)
/// 3
func fizz_buzz(n: Int) -> Int {
","func fizz_buzz(n: Int) -> Int {
    var count = 0
    for number in 0..<n {
        if number % 11 == 0 || number % 13 == 0 {
            var current = number
            while current > 0 {
                if current % 10 == 7 {
                    count += 1
                }
                current /= 10
            }
        }
    }
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fizz_buzz(n: 50) == 0)
assert(fizz_buzz(n: 78) == 2)
assert(fizz_buzz(n: 79) == 3)
assert(fizz_buzz(n: 100) == 3)
assert(fizz_buzz(n: 200) == 6)
assert(fizz_buzz(n: 4000) == 192)
assert(fizz_buzz(n: 10000) == 639)
assert(fizz_buzz(n: 100000) == 8026)"
HumanEval_37,hau_Latn,swift,"
// zuwa ga dabi'u na ma'auni na ma'auni na l, amma an tsara su. // l' daidai yake da l a cikin alamun ban mamaki, yayin da ƙimominsa a cikin alamun ma'auni daidai suke // Wannan aikin yana ɗaukar jeri l kuma ya dawo da jeri l' irin wannan cewa /// >>> sort_even(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_even(l: [5, 6, 3, 4])
/// [3, 6, 5, 4]
func sort_even(l: [Int]) -> [Int] {
","func sort_even(l: [Int]) -> [Int] {
    var evenIndicesValues = [Int]()
    
    // Collect values from even indices
    for (index, value) in l.enumerated() {
        if index % 2 == 0 {
            evenIndicesValues.append(value)
        }
    }
    
    // Sort the collected even indices values
    evenIndicesValues.sort()
    
    var result = l
    var evenIndex = 0
    
    // Replace even-indexed elements in result with sorted values
    for i in 0..<result.count {
        if i % 2 == 0 {
            result[i] = evenIndicesValues[evenIndex]
            evenIndex += 1
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])
assert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
HumanEval_39,hau_Latn,swift,"
// prime_fib ya dawo da lambar n-th wanda shine lambar Fibonacci kuma shima firamare ne. /// >>> prime_fib(n: 1)
/// 2
/// >>> prime_fib(n: 2)
/// 3
/// >>> prime_fib(n: 3)
/// 5
/// >>> prime_fib(n: 4)
/// 13
/// >>> prime_fib(n: 5)
/// 89
func prime_fib(n: Int) -> Int {
","func isPrime(_ num: Int) -> Bool {
    if num <= 1 { return false }
    if num <= 3 { return true }
    if num % 2 == 0 || num % 3 == 0 { return false }
    var i = 5
    while i * i <= num {
        if num % i == 0 || num % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}

func generateFibonacci(n: Int) -> [Int] {
    var fibs = [1, 2]
    var next = fibs[0] + fibs[1]
    while fibs.count < n || !isPrime(next) {
        fibs.append(next)
        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]
    }
    return fibs
}

func prime_fib(n: Int) -> Int {
    var count = 0
    var fibs = generateFibonacci(n: n)
    for fib in fibs {
        if isPrime(fib) {
            count += 1
            if count == n {
                return fib
            }
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_fib(n: 1) == 2)
assert(prime_fib(n: 2) == 3)
assert(prime_fib(n: 3) == 5)
assert(prime_fib(n: 4) == 13)
assert(prime_fib(n: 5) == 89)
assert(prime_fib(n: 6) == 233)
assert(prime_fib(n: 7) == 1597)
assert(prime_fib(n: 8) == 28657)
assert(prime_fib(n: 9) == 514229)
assert(prime_fib(n: 10) == 433494437)"
HumanEval_40,hau_Latn,swift,"
// jimlar zuwa sifili, kuma ƙarya in ba haka ba. // yana dawowa gaskiya idan akwai abubuwa uku daban-daban a cikin tsararren cewa // triples_sum_to_zero yana ɗaukar jerin lambobi masu ɗorewa azaman shigarwa. /// >>> triples_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(l: [1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(l: [1])
/// false
func triples_sum_to_zero(l: [Int]) -> Bool {
","func triples_sum_to_zero(l: [Int]) -> Bool {
    let count = l.count
    if count < 3 {
        return false
    }
    
    let sortedArray = l.sorted()
    
    for i in 0..<count - 2 {
        var left = i + 1
        var right = count - 1
        
        while left < right {
            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]
            if currentSum == 0 {
                return true
            } else if currentSum < 0 {
                left += 1
            } else {
                right -= 1
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)
assert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)
assert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)
assert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)
assert(triples_sum_to_zero(l: [1]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)
assert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"
HumanEval_41,hau_Latn,swift,"
// Wannan aikin yana fitar da adadin irin wannan karo. // a cikin hanyarsu kamar ba su yi karo ba. // Duk da haka, motocin suna da ƙarfi da ƙarfi; sakamakon haka, suna ci gaba da tafiya // lokacin da mota da ke motsawa daga hagu zuwa dama ta buga motar da ke motsawa dama zuwa hagu. Dukkan motoci suna tafiya a daidai wannan gudun.A cikin wannan yanayin, motar da ke da kyau ta kasance a cikin wani wuri mai nisa daga inda motar ta fito.// motoci n suna tuki hagu zuwa dama; lokaci guda, saiti daban na motocin n // Ka yi tunanin wata hanya da ke daidai madaidaiciya madaidaiciya.func car_race_collision(n: Int) -> Int {
","func car_race_collision(n: Int) -> Int {
    return n
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(car_race_collision(n: 2) == 4)
assert(car_race_collision(n: 3) == 9)
assert(car_race_collision(n: 4) == 16)
assert(car_race_collision(n: 8) == 64)
assert(car_race_collision(n: 10) == 100)"
HumanEval_42,hau_Latn,swift,"
// Koma array tare da abubuwa incremented da 1. /// >>> incr_list(l: [1, 2, 3])
/// [2, 3, 4]
/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [6, 4, 6, 3, 4, 4, 10, 1, 124]
func incr_list(l: [Int]) -> [Int] {
","func incr_list(l: [Int]) -> [Int] {
    return l.map { $0 + 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(incr_list(l: [] as [Int]) == [] as [Int])
assert(incr_list(l: [3, 2, 1]) == [4, 3, 2])
assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
HumanEval_43,hau_Latn,swift,"
// jimlar zuwa sifili, kuma ƙarya in ba haka ba. // yana dawowa gaskiya idan akwai abubuwa biyu daban-daban a cikin tsararren cewa // pairs_sum_to_zero yana ɗaukar jerin lambobi masu ɗorewa azaman shigarwa. /// >>> pairs_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(l: [1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(l: [1])
/// false
func pairs_sum_to_zero(l: [Int]) -> Bool {
","func pairs_sum_to_zero(l: [Int]) -> Bool {
    var set = Set<Int>()
    for num in l {
        if set.contains(-num) {
            return true
        }
        set.insert(num)
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)
assert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)
assert(pairs_sum_to_zero(l: [1]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"
HumanEval_44,hau_Latn,swift,"
// lambobin tushe sun fi ƙasa da 10. // dawo da wakilcin kirtani bayan juyawa. // Canja lambar tushe na shigar da lambar x zuwa tushe. /// >>> change_base(x: 8, base: 3)
/// ""22""
/// >>> change_base(x: 8, base: 2)
/// ""1000""
/// >>> change_base(x: 7, base: 2)
/// ""111""
func change_base(x: Int, base: Int) -> String {
","func change_base(x: Int, base: Int) -> String {
    guard base > 1 && base < 10 else {
        return """"
    }
    
    var number = x
    var result = """"
    
    repeat {
        let remainder = number % base
        result = ""\(remainder)"" + result
        number /= base
    } while number > 0
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(change_base(x: 8, base: 3) == ""22"")
assert(change_base(x: 9, base: 3) == ""100"")
assert(change_base(x: 234, base: 2) == ""11101010"")
assert(change_base(x: 16, base: 2) == ""10000"")
assert(change_base(x: 8, base: 2) == ""1000"")
assert(change_base(x: 7, base: 2) == ""111"")
assert(change_base(x: 2, base: 3) == ""2"")
assert(change_base(x: 3, base: 4) == ""3"")
assert(change_base(x: 4, base: 5) == ""4"")
assert(change_base(x: 5, base: 6) == ""5"")
assert(change_base(x: 6, base: 7) == ""6"")
assert(change_base(x: 7, base: 8) == ""7"")"
HumanEval_45,hau_Latn,swift,"
// Ba da tsawon gefen da kuma babban dawo da yanki don alwatika. /// >>> triangle_area(a: 5, h: 3)
/// 7.5
func triangle_area(a: Int, h: Int) -> Double {
","func triangle_area(a: Int, h: Int) -> Double {
    return 0.5 * Double(a) * Double(h)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 5, h: 3) == 7.5)
assert(triangle_area(a: 2, h: 2) == 2.0)
assert(triangle_area(a: 10, h: 8) == 40.0)"
HumanEval_46,hau_Latn,swift,"
// Da fatan za a rubuta aiki don ƙididdige ƙididdigar n-th na jerin lambobin fib4. Kada ku yi amfani da maimaitawa. // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). // fib4(3) -> 0 // fib4(2) -> 2 // fib4(1) -> 0 // fib4(0) -> 0 // Fib4 lambar jerin ne mai jerin kama da Fibbonacci jerin cewa an ayyana kamar haka: /// >>> fib4(n: 5)
/// 4
/// >>> fib4(n: 6)
/// 8
/// >>> fib4(n: 7)
/// 14
func fib4(n: Int) -> Int {
","func fib4(n: Int) -> Int {
    if n == 0 || n == 1 || n == 3 {
        return 0
    } else if n == 2 {
        return 2
    }
    
    var fibs = [0, 0, 2, 0]
    
    for i in 4...n {
        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]
        fibs.append(nextFib)
    }
    
    return fibs[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib4(n: 5) == 4)
assert(fib4(n: 8) == 28)
assert(fib4(n: 10) == 104)
assert(fib4(n: 12) == 386)"
HumanEval_47,hau_Latn,swift,"
// Komawa tsakiya na abubuwa a cikin array l. /// >>> median(l: [3, 1, 2, 4, 5])
/// 3
/// >>> median(l: [-10, 4, 6, 1000, 10, 20])
/// 15.0
func median(l: [Int]) -> Double {
","func median(l: [Int]) -> Double {
    let sorted = l.sorted()
    let count = sorted.count
    if count % 2 == 0 {
        return Double(sorted[count / 2 - 1] + sorted[count / 2]) / 2.0
    } else {
        return Double(sorted[count / 2])
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(median(l: [3, 1, 2, 4, 5]) == 3)
assert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)
assert(median(l: [5]) == 5)
assert(median(l: [6, 5]) == 5.5)
assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
HumanEval_48,hau_Latn,swift,"
// Bincike idan aka ba da kirtani ne palindrome /// >>> is_palindrome(text: """")
/// true
/// >>> is_palindrome(text: ""aba"")
/// true
/// >>> is_palindrome(text: ""aaaaa"")
/// true
/// >>> is_palindrome(text: ""zbcd"")
/// false
func is_palindrome(text: String) -> Bool {
","func is_palindrome(text: String) -> Bool {
    return text == String(text.reversed())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: """") == true)
assert(is_palindrome(text: ""aba"") == true)
assert(is_palindrome(text: ""aaaaa"") == true)
assert(is_palindrome(text: ""zbcd"") == false)
assert(is_palindrome(text: ""xywyx"") == true)
assert(is_palindrome(text: ""xywyz"") == false)
assert(is_palindrome(text: ""xywzx"") == false)"
HumanEval_49,hau_Latn,swift,"
// Koma 2 ^ n modulo p (ku kasance da sanin lambobi). /// >>> modp(n: 3, p: 5)
/// 3
/// >>> modp(n: 1101, p: 101)
/// 2
/// >>> modp(n: 0, p: 101)
/// 1
/// >>> modp(n: 3, p: 11)
/// 8
/// >>> modp(n: 100, p: 101)
/// 1
func modp(n: Int, p: Int) -> Int {
","func modp(n: Int, p: Int) -> Int {
    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(modp(n: 3, p: 5) == 3)
assert(modp(n: 1101, p: 101) == 2)
assert(modp(n: 0, p: 101) == 1)
assert(modp(n: 3, p: 11) == 8)
assert(modp(n: 100, p: 101) == 1)
assert(modp(n: 30, p: 5) == 4)
assert(modp(n: 31, p: 5) == 3)"
HumanEval_51,hau_Latn,swift,"
// remove_vowels aiki ne wanda yake ɗaukar kirtani kuma yana dawo da kirtani ba tare da muryoyi ba. /// >>> remove_vowels(text: """")
/// """"
/// >>> remove_vowels(text: ""abcdef"")
/// ""bcdf""
/// >>> remove_vowels(text: ""aaaaa"")
/// """"
/// >>> remove_vowels(text: ""aaBAA"")
/// ""B""
/// >>> remove_vowels(text: ""zbcd"")
/// ""zbcd""
func remove_vowels(text: String) -> String {
","func remove_vowels(text: String) -> String {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    return String(text.filter { !vowels.contains($0) })
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_vowels(text: """") == """")
assert(remove_vowels(text: ""abcdef\nghijklm"") == ""bcdf\nghjklm"")
assert(remove_vowels(text: ""fedcba"") == ""fdcb"")
assert(remove_vowels(text: ""eeeee"") == """")
assert(remove_vowels(text: ""acBAA"") == ""cB"")
assert(remove_vowels(text: ""EcBOO"") == ""cB"")
assert(remove_vowels(text: ""ybcd"") == ""ybcd"")"
HumanEval_52,hau_Latn,swift,"
// Koma gaskiya idan duk lambobi a cikin tsararru l suna ƙasa da ƙofar t. /// >>> below_threshold(l: [1, 2, 4, 10], t: 100)
/// true
/// >>> below_threshold(l: [1, 20, 4, 10], t: 5)
/// false
func below_threshold(l: [Int], t: Int) -> Bool {
","func below_threshold(l: [Int], t: Int) -> Bool {
    for number in l {
        if number >= t {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)
assert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"
HumanEval_53,hau_Latn,swift,"
// Ƙara lambobi biyu x da y /// >>> add(x: 2, y: 3)
/// 5
/// >>> add(x: 5, y: 7)
/// 12
func add(x: Int, y: Int) -> Int {
","func add(x: Int, y: Int) -> Int {
    return x + y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(x: 0, y: 1) == 1)
assert(add(x: 1, y: 0) == 1)
assert(add(x: 2, y: 3) == 5)
assert(add(x: 5, y: 7) == 12)
assert(add(x: 7, y: 5) == 12)"
HumanEval_54,hau_Latn,swift,"
// Bincika idan kalmomi biyu suna da haruffa iri ɗaya. /// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"")
/// true
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabc"")
/// true
/// >>> same_chars(s0: ""dddddddabc"", s1: ""abcd"")
/// true
/// >>> same_chars(s0: ""eabcd"", s1: ""dddddddabc"")
/// false
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabce"")
/// false
/// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"")
/// false
func same_chars(s0: String, s1: String) -> Bool {
","func same_chars(s0: String, s1: String) -> Bool {
    let set0 = Set(s0)
    let set1 = Set(s1)
    return set0 == set1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"") == true)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabc"") == true)
assert(same_chars(s0: ""dddddddabc"", s1: ""abcd"") == true)
assert(same_chars(s0: ""eabcd"", s1: ""dddddddabc"") == false)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabcf"") == false)
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"") == false)
assert(same_chars(s0: ""aabb"", s1: ""aaccc"") == false)"
HumanEval_55,hau_Latn,swift,"
// Koma lambar Fibonacci ta n. /// >>> fib(n: 10)
/// 55
/// >>> fib(n: 1)
/// 1
/// >>> fib(n: 8)
/// 21
func fib(n: Int) -> Int {
","func fib(n: Int) -> Int {
    if n <= 0 {
        return 0
    } else if n == 1 {
        return 1
    }
    
    var a = 0
    var b = 1
    for _ in 2...n {
        let temp = a + b
        a = b
        b = temp
    }
    return b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib(n: 10) == 55)
assert(fib(n: 1) == 1)
assert(fib(n: 8) == 21)
assert(fib(n: 11) == 89)
assert(fib(n: 12) == 144)"
HumanEval_56,hau_Latn,swift,"
// dawo gaskiya idan kowane buɗe bracket yana da daidai kusa bracket. // brackets ne mai kirtani na ""<"" da kuma "">"". /// >>> correct_bracketing(brackets: ""<"")
/// false
/// >>> correct_bracketing(brackets: ""<>"")
/// true
/// >>> correct_bracketing(brackets: ""<<><>>"")
/// true
/// >>> correct_bracketing(brackets: ""><<>"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    
    for bracket in brackets {
        if bracket == ""<"" {
            balance += 1
        } else if bracket == "">"" {
            balance -= 1
            if balance < 0 {
                return false
            }
        }
    }
    
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""<>"") == true)
assert(correct_bracketing(brackets: ""<<><>>"") == true)
assert(correct_bracketing(brackets: ""<><><<><>><>"") == true)
assert(correct_bracketing(brackets: ""<><><<<><><>><>><<><><<>>>"") == true)
assert(correct_bracketing(brackets: ""<<<><>>>>"") == false)
assert(correct_bracketing(brackets: ""><<>"") == false)
assert(correct_bracketing(brackets: ""<"") == false)
assert(correct_bracketing(brackets: ""<<<<"") == false)
assert(correct_bracketing(brackets: "">"") == false)
assert(correct_bracketing(brackets: ""<<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>><<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>>><>"") == false)"
HumanEval_57,hau_Latn,swift,"
// Koma gaskiya ne abubuwa masu yawa suna karuwa ko raguwa. /// >>> monotonic(l: [1, 2, 4, 20])
/// true
/// >>> monotonic(l: [1, 20, 4, 10])
/// false
/// >>> monotonic(l: [4, 1, 0, -10])
/// true
func monotonic(l: [Int]) -> Bool {
","func monotonic(l: [Int]) -> Bool {
    guard l.count > 1 else {
        return true
    }
    
    var increasing = true
    var decreasing = true
    
    for i in 1..<l.count {
        if l[i] > l[i - 1] {
            decreasing = false
        } else if l[i] < l[i - 1] {
            increasing = false
        }
    }
    
    return increasing || decreasing
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(monotonic(l: [1, 2, 4, 10]) == true)
assert(monotonic(l: [1, 2, 4, 20]) == true)
assert(monotonic(l: [1, 20, 4, 10]) == false)
assert(monotonic(l: [4, 1, 0, -10]) == true)
assert(monotonic(l: [4, 1, 1, 0]) == true)
assert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)
assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)
assert(monotonic(l: [9, 9, 9, 9]) == true)"
HumanEval_58,hau_Latn,swift,"
// Komawa da aka tsara abubuwa na musamman na kowa don nau'i biyu. /// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])
/// [1, 5, 653]
/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])
/// [2, 3]
func common(l1: [Int], l2: [Int]) -> [Int] {
","func common(l1: [Int], l2: [Int]) -> [Int] {
    let set1 = Set(l1)
    let set2 = Set(l2)
    let commonElements = set1.intersection(set2)
    return Array(commonElements).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])
assert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])
assert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])
assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
HumanEval_59,hau_Latn,swift,"
// Koma mafi girma firam factor na n. Ka ɗauka n > 1 kuma ba firam ba ne. /// >>> largest_prime_factor(n: 13195)
/// 29
/// >>> largest_prime_factor(n: 2048)
/// 2
func largest_prime_factor(n: Int) -> Int {
","func largest_prime_factor(n: Int) -> Int {
    var number = n
    var divisor = 2
    
    while number > 1 {
        if number % divisor == 0 {
            number /= divisor
        } else {
            divisor += 1
        }
    }
    
    return divisor
}

// Example usage:
// print(largest_prime_factor(n: 13195)) // Output: 29
// print(largest_prime_factor(n: 2048))  // Output: 2","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_prime_factor(n: 15) == 5)
assert(largest_prime_factor(n: 27) == 3)
assert(largest_prime_factor(n: 63) == 7)
assert(largest_prime_factor(n: 330) == 11)
assert(largest_prime_factor(n: 13195) == 29)"
HumanEval_60,hau_Latn,swift,"
// sum_to_n aiki ne wanda ya tara lambobi daga 1 zuwa n. /// >>> sum_to_n(n: 30)
/// 465
/// >>> sum_to_n(n: 100)
/// 5050
/// >>> sum_to_n(n: 5)
/// 15
/// >>> sum_to_n(n: 10)
/// 55
/// >>> sum_to_n(n: 1)
/// 1
func sum_to_n(n: Int) -> Int {
","func sum_to_n(n: Int) -> Int {
    return (n * (n + 1)) / 2
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_to_n(n: 1) == 1)
assert(sum_to_n(n: 6) == 21)
assert(sum_to_n(n: 11) == 66)
assert(sum_to_n(n: 30) == 465)
assert(sum_to_n(n: 100) == 5050)"
HumanEval_61,hau_Latn,swift,"
// dawo gaskiya idan kowane buɗe bracket yana da daidai kusa bracket. // brackets ne mai kirtani na ""("" da kuma "")"". /// >>> correct_bracketing(brackets: ""("")
/// false
/// >>> correct_bracketing(brackets: ""()"")
/// true
/// >>> correct_bracketing(brackets: ""(()())"")
/// true
/// >>> correct_bracketing(brackets: "")(()"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    for char in brackets {
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""()"") == true)
assert(correct_bracketing(brackets: ""(()())"") == true)
assert(correct_bracketing(brackets: ""()()(()())()"") == true)
assert(correct_bracketing(brackets: ""()()((()()())())(()()(()))"") == true)
assert(correct_bracketing(brackets: ""((()())))"") == false)
assert(correct_bracketing(brackets: "")(()"") == false)
assert(correct_bracketing(brackets: ""("") == false)
assert(correct_bracketing(brackets: ""(((("") == false)
assert(correct_bracketing(brackets: "")"") == false)
assert(correct_bracketing(brackets: ""(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())())(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())()))()"") == false)"
HumanEval_62,hau_Latn,swift,"
// Koma da samuwar wannan polynomial a cikin wannan nau'i. // xs[0] + xs[1] * x + xs[2] * x^2 + .... // xs wakiltar coefficients na wani polynomial. /// >>> derivative(xs: [3, 1, 2, 4, 5])
/// [1, 4, 12, 20]
/// >>> derivative(xs: [1, 2, 3])
/// [2, 6]
func derivative(xs: [Int]) -> [Int] {
","func derivative(xs: [Int]) -> [Int] {
    guard xs.count > 1 else { return [] }
    var result: [Int] = []
    for i in 1..<xs.count {
        result.append(xs[i] * i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])
assert(derivative(xs: [1, 2, 3]) == [2, 6])
assert(derivative(xs: [3, 2, 1]) == [2, 2])
assert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])
assert(derivative(xs: [1]) == [] as [Int])"
HumanEval_63,hau_Latn,swift,"
// Da fatan za a rubuta aiki don ƙididdige ƙididdigar n-th na jerin lambobin fibfib. // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). // fib fib ((2) == 1 // fib fib ((1) == 0 // fib fib ((0) == 0 // FibFib lambar jerin ne mai jerin kama da Fibbonacci jerin cewa an ayyana kamar haka: /// >>> fibfib(n: 1)
/// 0
/// >>> fibfib(n: 5)
/// 4
/// >>> fibfib(n: 8)
/// 24
func fibfib(n: Int) -> Int {
","func fibfib(n: Int) -> Int {
    if n == 0 || n == 1 {
        return 0
    }
    if n == 2 {
        return 1
    }
    
    var fibfibNums = [0, 0, 1]
    
    for i in 3...n {
        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]
        fibfibNums.append(nextFibFib)
    }
    
    return fibfibNums[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fibfib(n: 2) == 1)
assert(fibfib(n: 1) == 0)
assert(fibfib(n: 5) == 4)
assert(fibfib(n: 8) == 24)
assert(fibfib(n: 10) == 81)
assert(fibfib(n: 12) == 274)
assert(fibfib(n: 14) == 927)"
HumanEval_64,hau_Latn,swift,"
// Misali: // murya, amma kawai lokacin da yake a ƙarshen kalmar da aka ba. // Vowels a wannan yanayin sune 'a', 'e', 'i', 'o', 'u'. A nan, 'y' ma a // kalma a matsayin shigar da kuma dawo da yawan wasulan a cikin kirtani. // Rubuta wani aiki vowels_count wanda yake ɗaukar kirtani mai wakiltar /// >>> vowels_count(s: ""abcde"")
/// 2
/// >>> vowels_count(s: ""ACEDY"")
/// 3
func vowels_count(s: String) -> Int {
","func vowels_count(s: String) -> Int {
    guard !s.isEmpty else { return 0 }
    
    let vowels = Set(""aeiouAEIOU"")
    var count = 0
    let characters = Array(s)
    
    for i in 0..<characters.count {
        let char = characters[i]
        
        if vowels.contains(char) {
            count += 1
        } else if char == ""y"" || char == ""Y"" {
            if i == characters.count - 1 {
                count += 1
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(vowels_count(s: ""abcde"") == 2)
assert(vowels_count(s: ""Alone"") == 3)
assert(vowels_count(s: ""key"") == 2)
assert(vowels_count(s: ""bye"") == 1)
assert(vowels_count(s: ""keY"") == 2)
assert(vowels_count(s: ""bYe"") == 1)
assert(vowels_count(s: ""ACEDY"") == 3)"
HumanEval_65,hau_Latn,swift,"
// Idan matsawa > yawan lambobi, dawo da lambobi baya. // kuma ya dawo da sakamakon a matsayin kirtani. // Zagaye a zagaye na sauya lambobi na lamba x, sauya lambobi dama ta hanyar sauyawa /// >>> circular_shift(x: 12, shift: 1)
/// ""21""
/// >>> circular_shift(x: 12, shift: 2)
/// ""12""
func circular_shift(x: Int, shift: Int) -> String {
","func circular_shift(x: Int, shift: Int) -> String {
    let digits = Array(String(x))
    let count = digits.count
    
    // If shift is greater than the number of digits, return the digits reversed
    if shift >= count {
        return String(digits.reversed())
    }
    
    // Calculate the actual shift needed by using modulo operation
    let actualShift = shift % count
    
    // Perform the circular shift to the right
    let splitIndex = count - actualShift
    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]
    
    return String(shiftedDigits)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(circular_shift(x: 100, shift: 2) == ""001"")
assert(circular_shift(x: 12, shift: 2) == ""12"")
assert(circular_shift(x: 97, shift: 8) == ""79"")
assert(circular_shift(x: 12, shift: 1) == ""21"")
assert(circular_shift(x: 11, shift: 101) == ""11"")"
HumanEval_66,hau_Latn,swift,"
// Misalai: // Lambobin ASCII. // Rubuta wani aiki da daukan wani kirtani a matsayin shigar da kuma dawo da jimlar na sama haruffa kawai' // Aiki /// >>> digitSum(s: """")
/// 0
/// >>> digitSum(s: ""abAB"")
/// 131
/// >>> digitSum(s: ""abcCd"")
/// 67
/// >>> digitSum(s: ""helloE"")
/// 69
/// >>> digitSum(s: ""woArBld"")
/// 131
/// >>> digitSum(s: ""aAaaaXa"")
/// 153
func digitSum(s: String) -> Int {
","func digitSum(s: String) -> Int {
    var sum = 0
    for character in s {
        if character.isUppercase {
            sum += Int(character.asciiValue ?? 0)
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: """") == 0)
assert(digitSum(s: ""abAB"") == 131)
assert(digitSum(s: ""abcCd"") == 67)
assert(digitSum(s: ""helloE"") == 69)
assert(digitSum(s: ""woArBld"") == 131)
assert(digitSum(s: ""aAaaaXa"") == 153)
assert(digitSum(s: "" How are yOu?"") == 151)
assert(digitSum(s: ""You arE Very Smart"") == 327)"
HumanEval_67,hau_Latn,swift,"
// don examble: // a cikin kwandon dawo da yawan 'ya'yan itacen mango a cikin kwandon. // da lemu da apples da wani lamba cewa wakiltar jimlar yawan 'ya'yan itatuwa // apples, oranges, da kuma mango 'ya'yan itatuwa. Ba da kirtani da cewa wakiltar jimlar yawan // da aka rarraba a cikin kwandon 'ya'yan itace wannan kwandon ya ƙunshi // A cikin wannan aikin, za a ba ku kirtani wanda ke wakiltar adadin apples da lemu /// >>> fruit_distribution(s: ""5 apples and 6 oranges"", n: 19)
/// 8
/// >>> fruit_distribution(s: ""0 apples and 1 oranges"", n: 3)
/// 2
/// >>> fruit_distribution(s: ""2 apples and 3 oranges"", n: 100)
/// 95
/// >>> fruit_distribution(s: ""100 apples and 1 oranges"", n: 120)
/// 19
func fruit_distribution(s: String, n: Int) -> Int {
","func fruit_distribution(s: String, n: Int) -> Int {
    let components = s.components(separatedBy: "" "")
    var apples = 0
    var oranges = 0
    
    for (index, component) in components.enumerated() {
        if component == ""apples"" || component == ""apple"" {
            if let number = Int(components[index - 1]) {
                apples = number
            }
        } else if component == ""oranges"" || component == ""orange"" {
            if let number = Int(components[index - 1]) {
                oranges = number
            }
        }
    }
    
    let totalApplesOranges = apples + oranges
    let mangoes = n - totalApplesOranges
    return mangoes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 19) == 8)
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 21) == 10)
assert(fruit_distribution(s: ""0 apples and 1 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""1 apples and 0 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 100) == 95)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 5) == 0)
assert(fruit_distribution(s: ""1 apples and 100 oranges"", n: 120) == 19)"
HumanEval_68,hau_Latn,swift,"
// Misali na 1: // Idan babu ma'auni ko ma'auni da aka ba shi ne fanko, dawo da []. // The tsince kumburi ya kamata a mayar a cikin wani tsararru, [small_value, da index ], // Idan mahara nodes da wannan karami ma darajar da aka samu dawo da kumburi da cewa yana da karami index. // The tsince kumburi ya zama kumburi da karami ko da darajar. // aikinku shine cire ɗayan nodes kuma dawo da shi. // ""An ba da wani tsari wanda yake wakiltar reshe na itace wanda ke da ƙididdigar ƙididdiga masu ƙarancin ƙididdiga /// >>> pluck(arr: [4, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(arr: [1, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(arr: [] as [Int])
/// [] as [Int]
/// Example 4:
/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])
/// [0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
func pluck(arr: [Int]) -> [Int] {
","func pluck(arr: [Int]) -> [Int] {
    var smallestEvenValue: Int? = nil
    var smallestIndex: Int? = nil

    for (index, value) in arr.enumerated() {
        if value % 2 == 0 {
            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {
                smallestEvenValue = value
                smallestIndex = index
            }
        }
    }

    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {
        return [smallestEvenValue, smallestIndex]
    } else {
        return []
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pluck(arr: [4, 2, 3]) == [2, 1])
assert(pluck(arr: [1, 2, 3]) == [2, 1])
assert(pluck(arr: [] as [Int]) == [] as [Int])
assert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])
assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])
assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])
assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])
assert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
HumanEval_69,hau_Latn,swift,"
// Misalai: // Idan babu irin wannan darajar ta wanzu, dawo -1. // Yawan adadin lambobi shine yawan lokutan da ya bayyana a cikin tsari. // sifili, kuma yana da mita mafi girma ko daidai da darajar da integer kanta. // An ba ku jerin abubuwan da ba komai ba na lambobi masu kyau. Koma mafi girman adadin da ya fi /// >>> search(lst: [4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(lst: [5, 5, 4, 4, 4])
/// -1
func search(lst: [Int]) -> Int {
","func search(lst: [Int]) -> Int {
    var frequencyMap = [Int: Int]()
    
    // Count frequencies of each number in the list
    for number in lst {
        frequencyMap[number, default: 0] += 1
    }
    
    var result = -1
    
    // Iterate through the frequency map to find the greatest integer that satisfies the condition
    for (number, frequency) in frequencyMap {
        if frequency >= number {
            result = max(result, number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(search(lst: [5, 5, 5, 5, 1]) == 1)
assert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)
assert(search(lst: [3, 3]) == -1)
assert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)
assert(search(lst: [2, 3, 3, 2, 2]) == 2)
assert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)
assert(search(lst: [3, 2, 8, 2]) == 2)
assert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)
assert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)
assert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)
assert(search(lst: [1, 9, 10, 1, 3]) == 1)
assert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)
assert(search(lst: [1]) == 1)
assert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)
assert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)
assert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)
assert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)
assert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)
assert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)
assert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)
assert(search(lst: [10]) == -1)
assert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)
assert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)
assert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)
assert(search(lst: [3, 10, 10, 9, 2]) == -1)"
HumanEval_70,hau_Latn,swift,"
// Misalai: // to, mafi girma daga cikin sauran integers, to, m da sauransu. // Baƙon rarrabuwa, shine lokacin da kuka fara da mafi ƙarancin darajar, // An ba da jerin lambobi, dawo da jerin a cikin tsari mai ban mamaki. /// >>> strange_sort_list(lst: [1, 2, 3, 4])
/// [1, 4, 2, 3]
/// >>> strange_sort_list(lst: [5, 5, 5, 5])
/// [5, 5, 5, 5]
/// >>> strange_sort_list(lst: [] as [Int])
/// [] as [Int]
func strange_sort_list(lst: [Int]) -> [Int] {
","func strange_sort_list(lst: [Int]) -> [Int] {
    var sortedList = lst.sorted()
    var result: [Int] = []
    
    while !sortedList.isEmpty {
        if let min = sortedList.first {
            result.append(min)
            sortedList.removeFirst()
        }
        
        if let max = sortedList.last {
            result.append(max)
            sortedList.removeLast()
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])
assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])
assert(strange_sort_list(lst: [] as [Int]) == [] as [Int])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])
assert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])
assert(strange_sort_list(lst: [111111]) == [111111])"
HumanEval_71,hau_Latn,swift,"
// Misali: // fiye da na uku gefen. // Uku bangarorin yin inganci triangle lokacin da adadin kowane bangarorin biyu ne mafi girma // In ba haka ba dawo -1 // triangle zagaye zuwa 2 goma maki idan bangarorin uku samar da wani inganci triangle. // Ganin tsawon bangarorin uku na alwatika. Koma yankin /// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
","func triangle_area(a: Int, b: Int, c: Int) -> Double {
    // Check if the sides form a valid triangle
    if a + b > c && a + c > b && b + c > a {
        // Calculate the semi-perimeter
        let s = Double(a + b + c) / 2.0
        // Calculate the area using Heron's formula
        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
        // Round to 2 decimal places
        return round(area * 100) / 100
    } else {
        return -1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)"
HumanEval_72,hau_Latn,swift,"
// Misali: // Abu q zai tashi idan yana da daidaito (yana da palindromic array) kuma jimlar abubuwansa sun fi ƙasa ko daidai da matsakaicin yiwuwar w. // Rubuta wani aiki da ya dawo gaskiya idan abu q zai tashi, kuma ƙarya in ba haka ba. /// >>> will_it_fly(q: [1, 2], w: 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(q: [3, 2, 3], w: 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(q: [3, 2, 3], w: 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(q: [3], w: 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q: [Int], w: Int) -> Bool {
","func will_it_fly(q: [Int], w: Int) -> Bool {
    func isPalindromic(_ array: [Int]) -> Bool {
        return array == array.reversed()
    }
    
    let sum = q.reduce(0, +)
    return isPalindromic(q) && sum <= w
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(will_it_fly(q: [3, 2, 3], w: 9) == true)
assert(will_it_fly(q: [1, 2], w: 5) == false)
assert(will_it_fly(q: [3], w: 5) == true)
assert(will_it_fly(q: [3, 2, 3], w: 1) == false)
assert(will_it_fly(q: [1, 2, 3], w: 6) == false)
assert(will_it_fly(q: [5], w: 5) == true)"
HumanEval_73,hau_Latn,swift,"
// Misali: // ana karanta iri ɗaya a gaba da baya. A cikin canji ɗaya, zaku iya canza wani abu zuwa kowane abu. // yana buƙatar canzawa don yin tsari na palindromic. Tsarin palindromic shine tsari wanda // An ba da jerin arr na integers, sami mafi ƙarancin adadin abubuwan da /// >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(arr: [1, 2, 3, 2, 1])
/// 0
func smallest_change(arr: [Int]) -> Int {
","func smallest_change(arr: [Int]) -> Int {
    var changes = 0
    let n = arr.count

    for i in 0..<(n / 2) {
        if arr[i] != arr[n - i - 1] {
            changes += 1
        }
    }

    return changes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)
assert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)
assert(smallest_change(arr: [1, 4, 2]) == 1)
assert(smallest_change(arr: [1, 4, 4, 2]) == 1)
assert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)
assert(smallest_change(arr: [3, 1, 1, 3]) == 0)
assert(smallest_change(arr: [1]) == 0)
assert(smallest_change(arr: [0, 1]) == 1)"
HumanEval_74,hau_Latn,swift,"
// Misalai // idan biyu arrays da wannan adadin chars, dawo da farko array. // jimlar adadin chars a cikin dukkan kirtani na tsararru kasa da sauran tsararru. // Rubuta wani aiki da ya yarda da biyu arrays na kirtani da kuma dawo da tsararru da cewa yana da /// >>> total_match(lst1: [] as [String], lst2: [] as [String])
/// [] as [String]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""])
/// [""hI"", ""Hi""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""])
/// [""hi"", ""admin""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""])
/// [""hI"", ""hi"", ""hi""]
/// >>> total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""])
/// [""4""]
func total_match(lst1: [String], lst2: [String]) -> [String] {
","func total_match(lst1: [String], lst2: [String]) -> [String] {
    let totalChars1 = lst1.reduce(0) { $0 + $1.count }
    let totalChars2 = lst2.reduce(0) { $0 + $1.count }
    
    if totalChars1 < totalChars2 {
        return lst1
    } else if totalChars2 < totalChars1 {
        return lst2
    } else {
        return lst1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi""]) == [""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""]) == [""hi"", ""admin""])
assert(total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""]) == [""4""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""]) == [""hI"", ""Hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""]) == [""hI"", ""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hii""]) == [""hi"", ""admin""])
assert(total_match(lst1: [] as [String], lst2: [""this""]) == [] as [String])
assert(total_match(lst1: [""this""], lst2: [] as [String]) == [] as [String])"
HumanEval_75,hau_Latn,swift,"
// Misali: // Sanin cewa (a) ya fi ƙasa da 100. // kuma ƙarya in ba haka ba. // Rubuta wani aiki da ya dawo gaskiya idan lambar da aka bayar ita ce ta ninka lambobi 3 na farko /// >>> is_multiply_prime(a: 30)
/// true
/// 30 = 2 * 3 * 5
func is_multiply_prime(a: Int) -> Bool {
","func is_multiply_prime(a: Int) -> Bool {
    // Function to check if a number is prime
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Generate all prime numbers less than 100
    var primes = [Int]()
    for i in 2..<100 {
        if isPrime(i) {
            primes.append(i)
        }
    }
    
    // Check combinations of 3 primes
    let primeCount = primes.count
    for i in 0..<primeCount {
        for j in i..<primeCount {
            for k in j..<primeCount {
                if primes[i] * primes[j] * primes[k] == a {
                    return true
                }
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_multiply_prime(a: 5) == false)
assert(is_multiply_prime(a: 30) == true)
assert(is_multiply_prime(a: 8) == true)
assert(is_multiply_prime(a: 10) == false)
assert(is_multiply_prime(a: 125) == true)
assert(is_multiply_prime(a: 105) == true)
assert(is_multiply_prime(a: 126) == false)
assert(is_multiply_prime(a: 729) == false)
assert(is_multiply_prime(a: 891) == false)
assert(is_multiply_prime(a: 1001) == true)"
HumanEval_76,hau_Latn,swift,"
// Misali: // x mai sauki ne na n idan n**int=x // iko na n da ƙarya a wasu lokuta. // Aikinku shi ne rubuta wani aiki da ya dawo gaskiya idan lamba x ne mai sauki /// >>> is_simple_power(x: 1, n: 4)
/// true
/// >>> is_simple_power(x: 2, n: 2)
/// true
/// >>> is_simple_power(x: 8, n: 2)
/// true
/// >>> is_simple_power(x: 3, n: 2)
/// false
/// >>> is_simple_power(x: 3, n: 1)
/// false
/// >>> is_simple_power(x: 5, n: 3)
/// false
func is_simple_power(x: Int, n: Int) -> Bool {
","func is_simple_power(x: Int, n: Int) -> Bool {
    if x < 1 || n < 1 {
        return false
    }
    if x == 1 {
        return true // n**0 = 1
    }
    var power = 1
    while power < x {
        power *= n
    }
    return power == x
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_simple_power(x: 16, n: 2) == true)
assert(is_simple_power(x: 143214, n: 16) == false)
assert(is_simple_power(x: 4, n: 2) == true)
assert(is_simple_power(x: 9, n: 3) == true)
assert(is_simple_power(x: 16, n: 4) == true)
assert(is_simple_power(x: 24, n: 2) == false)
assert(is_simple_power(x: 128, n: 4) == false)
assert(is_simple_power(x: 12, n: 6) == false)
assert(is_simple_power(x: 1, n: 1) == true)
assert(is_simple_power(x: 1, n: 12) == true)"
HumanEval_77,hau_Latn,swift,"
// Misalai: // Lura: za ka iya ɗauka da shigar da shi ne ko da yaushe inganci. // idan wannan ingeger ne mai kauri na wasu lamba mai tsawo. // Rubuta wani aiki da daukan wani lamba mai lamba a kuma ya dawo gaskiya /// >>> iscube(a: 1)
/// true
/// >>> iscube(a: 2)
/// false
/// >>> iscube(a: -1)
/// true
/// >>> iscube(a: 64)
/// true
/// >>> iscube(a: 0)
/// true
/// >>> iscube(a: 180)
/// false
func iscube(a: Int) -> Bool {
","func iscube(a: Int) -> Bool {
    if a == 0 { return true } // 0 is a cube (0^3)
    let absA = abs(a)
    let cubeRoot = Int(round(pow(Double(absA), 1.0/3.0)))
    return cubeRoot * cubeRoot * cubeRoot == absA
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(iscube(a: 1) == true)
assert(iscube(a: 2) == false)
assert(iscube(a: -1) == true)
assert(iscube(a: 64) == true)
assert(iscube(a: 180) == false)
assert(iscube(a: 1000) == true)
assert(iscube(a: 0) == true)
assert(iscube(a: 1729) == false)"
HumanEval_78,hau_Latn,swift,"
// Misalai: // da alamomin A, B, C, D, E, F koyaushe manyan haruffa ne. // Note: za ka iya ɗauka da shigar da shi ne ko da yaushe daidai ko m kirtani, // B (= goma sha ɗaya 11), D (= goma sha uku 13). // Don haka dole ne ka tantance adadin lambobi masu zuwa: 2, 3, 5, 7, // Lambobi masu mahimmanci sune 2, 3, 5, 7, 11, 13, 17,... // Lambobi na hexadecimal sune 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. // mafi girma fiye da 1 wanda ba samfurin ƙananan lambobi biyu ba). // lambobi da suke da farko (first lamba, ko firamare, shi ne na halitta lamba // lambar hexadecimal a matsayin kirtani kuma ƙidaya yawan hexadecimal // An umarce ku da ku rubuta aikin da ke karɓa /// >>> hex_key(num: ""AB"")
/// 1
/// >>> hex_key(num: ""1077E"")
/// 2
/// >>> hex_key(num: ""ABED1A33"")
/// 4
/// >>> hex_key(num: ""123456789ABCDEF0"")
/// 6
/// >>> hex_key(num: ""2020"")
/// 2
func hex_key(num: String) -> Int {
","func hex_key(num: String) -> Int {
    // Define hexadecimal digits that are prime numbers
    let primeHexDigits: Set<Character> = [""2"", ""3"", ""5"", ""7"", ""B"", ""D""]
    
    // Initialize count
    var primeCount = 0
    
    // Iterate over each character in the string
    for char in num {
        // Check if the character is a prime hexadecimal digit
        if primeHexDigits.contains(char) {
            primeCount += 1
        }
    }
    
    return primeCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: ""AB"") == 1)
assert(hex_key(num: ""1077E"") == 2)
assert(hex_key(num: ""ABED1A33"") == 4)
assert(hex_key(num: ""2020"") == 2)
assert(hex_key(num: ""123456789ABCDEF0"") == 6)
assert(hex_key(num: ""112233445566778899AABBCCDDEEFF00"") == 12)"
HumanEval_79,hau_Latn,swift,"
// Misalai: // Karin haruffa suna nan don taimakawa tare da tsari. // Za a sami karin wasu haruffa 'db' a farkon da kuma karshen kirtani. // lamba. Kowane hali a cikin kirtani zai zama '0' ko '1'. // binary format. A aiki ya kamata dawo da wani kirtani, tare da kowane hali wakiltar wani binary // Za a ba ku lamba a cikin nau'i na goma kuma aikinku shine canza shi zuwa /// >>> decimal_to_binary(decimal: 15)
/// ""db1111db""
/// >>> decimal_to_binary(decimal: 32)
/// ""db100000db""
func decimal_to_binary(decimal: Int) -> String {
","func decimal_to_binary(decimal: Int) -> String {
    let binaryString = String(decimal, radix: 2)
    return ""db"" + binaryString + ""db""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(decimal_to_binary(decimal: 0) == ""db0db"")
assert(decimal_to_binary(decimal: 32) == ""db100000db"")
assert(decimal_to_binary(decimal: 103) == ""db1100111db"")
assert(decimal_to_binary(decimal: 15) == ""db1111db"")"
HumanEval_80,hau_Latn,swift,"
// Misali: // A kirtani ne hapswift idan ta tsawon ne a kalla 3 da kuma kowane 3 jere haruffa ne daban-daban // Aikinku shine bincika ko kirtani yana da sauri ko a'a. // An ba ku wani kirtani s. /// >>> is_happy(s: ""a"")
/// false
/// >>> is_happy(s: ""aa"")
/// false
/// >>> is_happy(s: ""abcd"")
/// true
/// >>> is_happy(s: ""aabb"")
/// false
/// >>> is_happy(s: ""adb"")
/// true
/// >>> is_happy(s: ""xyy"")
/// false
func is_happy(s: String) -> Bool {
","func is_happy(s: String) -> Bool {
    let characters = Array(s)
    if characters.count < 3 {
        return false
    }
    
    for i in 0..<(characters.count - 2) {
        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_happy(s: ""a"") == false)
assert(is_happy(s: ""aa"") == false)
assert(is_happy(s: ""abcd"") == true)
assert(is_happy(s: ""aabb"") == false)
assert(is_happy(s: ""adb"") == true)
assert(is_happy(s: ""xyy"") == false)
assert(is_happy(s: ""iopaxpoi"") == true)
assert(is_happy(s: ""iopaxioi"") == false)"
HumanEval_81,hau_Latn,swift,"
// Misali: // 0.0 E // > 0.0 D- // > 0.7 D // > 1.0 D + // > 1.3 C- // > 1.7 C // > 2.0 C + // > 2.3 B- // > 2.7 B // > 3.0 B + // > 3.3 A- // > 3.7 A // 4.0 A + GPA. Darajar rubutu.// wani aiki wanda zai iya fitarwa jerin haruffa na haruffa ta amfani da tebur mai zuwa: // Ta ba ku jerin GPAs ga wasu ɗalibai kuma dole ne ku rubuta // Matsalar kawai ita ce, ta rasa lambar da ta yi amfani da ita don kimantawa. Malamin ya kasance yana yin nasa algorithm don kimantawa. // A makon karshe na semester ne kuma malamin ya bayar da maki /// >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])
/// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
func numerical_letter_grade(grades: [Double]) -> [String] {
","func numerical_letter_grade(grades: [Double]) -> [String] {
    return grades.map { gpa in
        switch gpa {
        case 4.0:
            return ""A+""
        case 3.7...4.0:
            return ""A""
        case 3.3..<3.7:
            return ""A-""
        case 3.0..<3.3:
            return ""B+""
        case 2.7..<3.0:
            return ""B""
        case 2.3..<2.7:
            return ""B-""
        case 2.0..<2.3:
            return ""C+""
        case 1.7..<2.0:
            return ""C""
        case 1.3..<1.7:
            return ""C-""
        case 1.0..<1.3:
            return ""D+""
        case 0.7..<1.0:
            return ""D""
        case 0.0..<0.7:
            return ""D-""
        default:
            return ""E""
        }
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [""A+"", ""B"", ""C-"", ""C"", ""A-""])
assert(numerical_letter_grade(grades: [1.2]) == [""D+""])
assert(numerical_letter_grade(grades: [0.5]) == [""D-""])
assert(numerical_letter_grade(grades: [0.0]) == [""E""])
assert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [""D"", ""D-"", ""C-"", ""B"", ""B+""])
assert(numerical_letter_grade(grades: [0.0, 0.7]) == [""E"", ""D-""])"
HumanEval_82,hau_Latn,swift,"
// Misalai // tsawon lambobi ne ko kuma ba gaskiya bane in ba haka ba // Rubuta wani aiki da daukan wani kirtani da kuma dawo da gaskiya idan kirtani /// >>> prime_length(string: ""Hello"")
/// true
/// >>> prime_length(string: ""abcdcba"")
/// true
/// >>> prime_length(string: ""kittens"")
/// true
/// >>> prime_length(string: ""orange"")
/// false
func prime_length(string: String) -> Bool {
","func prime_length(string: String) -> Bool {
    let length = string.count
    
    guard length > 1 else {
        return false
    }
    
    for i in 2..<length {
        if length % i == 0 {
            return false
        }
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_length(string: ""Hello"") == true)
assert(prime_length(string: ""abcdcba"") == true)
assert(prime_length(string: ""kittens"") == true)
assert(prime_length(string: ""orange"") == false)
assert(prime_length(string: ""wow"") == true)
assert(prime_length(string: ""world"") == true)
assert(prime_length(string: ""MadaM"") == true)
assert(prime_length(string: ""Wow"") == true)
assert(prime_length(string: """") == false)
assert(prime_length(string: ""HI"") == true)
assert(prime_length(string: ""go"") == true)
assert(prime_length(string: ""gogo"") == false)
assert(prime_length(string: ""aaaaaaaaaaaaaaa"") == false)
assert(prime_length(string: ""Madam"") == true)
assert(prime_length(string: ""M"") == false)
assert(prime_length(string: ""0"") == false)"
HumanEval_83,hau_Latn,swift,"
// lambobi masu kyau waɗanda suka fara ko ƙare da 1. // Ba da wani m lamba n, dawo da count na lambobi na n-digit func starts_one_ends(n: Int) -> Int {
","func starts_one_ends(n: Int) -> Int {
    if n == 1 {
        // For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.
        return 1
    }
    
    // Count of n-digit numbers starting with 1:
    // First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.
    let startWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Count of n-digit numbers ending with 1:
    // Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.
    // So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.
    let endWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Intersection of both sets is the numbers starting and ending with 1
    // which are of the form `1` followed by (n-2) digits and `1`, so:
    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))
    
    return startWithOne + endWithOne - startAndEndWithOne
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(starts_one_ends(n: 1) == 1)
assert(starts_one_ends(n: 2) == 18)
assert(starts_one_ends(n: 3) == 180)
assert(starts_one_ends(n: 4) == 1800)
assert(starts_one_ends(n: 5) == 18000)"
HumanEval_84,hau_Latn,swift,"
// Misali // Ba da wani m lamba N, dawo da jimlar da lambobi a binary. /// >>> solve(N: 1000)
/// ""1""
/// >>> solve(N: 150)
/// ""110""
/// >>> solve(N: 147)
/// ""1100""
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
func solve(N: Int) -> String {
","func solve(N: Int) -> String {
    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)
    return String(sumOfDigits, radix: 2)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(N: 1000) == ""1"")
assert(solve(N: 150) == ""110"")
assert(solve(N: 147) == ""1100"")
assert(solve(N: 333) == ""1001"")
assert(solve(N: 963) == ""10010"")"
HumanEval_85,hau_Latn,swift,"
// Misalai: // Ba da wani ba-takarar tsararru na integers lst. ƙara ko da abubuwa da suke a m fihirisa .. /// >>> add(lst: [4, 2, 6, 7])
/// 2
func add(lst: [Int]) -> Int {
","func add(lst: [Int]) -> Int {
    var sum = 0
    for i in stride(from: 1, to: lst.count, by: 2) {
        if lst[i] % 2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(lst: [4, 88]) == 88)
assert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)
assert(add(lst: [4, 0, 6, 7]) == 0)
assert(add(lst: [4, 4, 6, 8]) == 12)"
HumanEval_86,hau_Latn,swift,"
// Misali: // Lura: Ya kamata ku kiyaye umarnin kalmomi da sararin samaniya a cikin jumla. // tsari na hawa bisa ga darajar ascii. // An maye gurbinsu da wata kalma inda duk haruffan da aka tsara a cikin // Ya umurce version na kirtani, shi ne kirtani inda duk kalmomi (rarrabe ta sarari) // Rubuta wani aiki da daukan wani kirtani da kuma dawo da wani tsari version of shi. /// >>> anti_shuffle(s: ""Hi"")
/// ""Hi""
/// >>> anti_shuffle(s: ""hello"")
/// ""ehllo""
/// >>> anti_shuffle(s: ""Hello World!!!"")
/// ""Hello !!!Wdlor""
func anti_shuffle(s: String) -> String {
","func anti_shuffle(s: String) -> String {
    let words = s.components(separatedBy: .whitespaces)
    let orderedWords = words.map { String($0.sorted()) }
    var result = """"
    var wordIndex = 0
    
    for character in s {
        if character.isWhitespace {
            result.append(character)
        } else if wordIndex < orderedWords.count {
            if let currentWord = orderedWords[wordIndex].first {
                result.append(currentWord)
                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)
            }
        }
        
        if let lastCharacter = result.last {
            if lastCharacter.isWhitespace {
                wordIndex += 1
            }
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(anti_shuffle(s: ""Hi"") == ""Hi"")
assert(anti_shuffle(s: ""hello"") == ""ehllo"")
assert(anti_shuffle(s: ""number"") == ""bemnru"")
assert(anti_shuffle(s: ""abcd"") == ""abcd"")
assert(anti_shuffle(s: ""Hello World!!!"") == ""Hello !!!Wdlor"")
assert(anti_shuffle(s: """") == """")
assert(anti_shuffle(s: ""Hi. My name is Mister Robot. How are you?"") == "".Hi My aemn is Meirst .Rboot How aer ?ouy"")"
HumanEval_87,hau_Latn,swift,"
// Misalai: // Hakanan, tsara haɗin gwiwar jere ta ginshiƙai a cikin tsari mai saukowa. // Sort tsarawa da farko ta layuka a cikin hauhawar tsari. // kowane tuple ne mai tsarawa - ( jere, ginshikan), fara da 0. // da kuma dawo da tsararru na tuples, [(x1, y1), (x2, y2) ...] irin wannan cewa // Ba lst, da kuma lamba x, sami integers x a cikin tsararru, // kowane jere na iya ƙunsar adadin ginshiƙai daban-daban. // wanda yake kama da matrix, duk da haka, ba kamar matrices, // An ba ku bayanai na 2 dimensional, a matsayin matattarar da aka saka, /// >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)
/// [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(lst: [] as [[Int]], x: 1)
/// [] as [(Int, Int)]
/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)
/// [(2, 2)]
func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
","func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
    var coordinates: [(Int, Int)] = []
    
    for (rowIndex, row) in lst.enumerated() {
        for (colIndex, value) in row.enumerated() {
            if value == x {
                coordinates.append((rowIndex, colIndex))
            }
        }
    }
    
    let sortedCoordinates = coordinates.sorted {
        if $0.0 == $1.0 {
            return $0.1 > $1.1
        } else {
            return $0.0 < $1.0
        }
    }
    
    return sortedCoordinates
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])
assert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])
assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])
assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
HumanEval_88,hau_Latn,swift,"
// Misalai: // * Kada ku canza tsarin da aka ba ku. // Lura: // ko rarraba shi a cikin tsari mai saukowa idan adadin ((farkon darajar darajar, darajar darajar karshe) ma'auni ne. // za ku rarraba da aka ba tsararru a cikin hauhawar tsari idan da jimlar ((farko index darajar, karshe index darajar) ne m, // Ba da wani tsararru na ba-negative integers, dawo da wani coswift na ba tsararru bayan rarrabuwa, /// >>> sort_array(array: [] as [Int])
/// [] as [Int]
/// >>> sort_array(array: [5])
/// [5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5])
/// [0, 1, 2, 3, 4, 5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])
/// [6, 5, 4, 3, 2, 1, 0]
func sort_array(array: [Int]) -> [Int] {
","func sort_array(array: [Int]) -> [Int] {
    guard let first = array.first, let last = array.last else {
        return array
    }
    let sum = first + last
    if sum % 2 == 0 {
        return array.sorted(by: >) // Descending order
    } else {
        return array.sorted() // Ascending order
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(array: [] as [Int]) == [] as [Int])
assert(sort_array(array: [5]) == [5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])
assert(sort_array(array: [2, 1]) == [1, 2])
assert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])
assert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"
HumanEval_89,hau_Latn,swift,"
// Misali: // matsawa ƙasa da biyu ninka zuwa wurare biyu. // Ya kamata a juya haruffa ta yadda haruffa // dawo da wani kirtani rufaffen da haruffa da ake juya. // Ƙirƙiri wani aiki encrypt cewa daukan wani kirtani a matsayin hujja da kuma /// >>> encrypt(s: ""hi"")
/// ""lm""
/// >>> encrypt(s: ""asdfghjkl"")
/// ""ewhjklnop""
/// >>> encrypt(s: ""gf"")
/// ""kj""
/// >>> encrypt(s: ""et"")
/// ""ix""
func encrypt(s: String) -> String {
","func encrypt(s: String) -> String {
    let alphabet = Array(""abcdefghijklmnopqrstuvwxyz"")
    let shift = 2 * 2 // shift down by two multiplied by two places, i.e., 4
    var result = """"

    for character in s {
        if let index = alphabet.firstIndex(of: character) {
            let newIndex = (index + shift) % alphabet.count
            result.append(alphabet[newIndex])
        } else {
            result.append(character) // append non-alphabetic characters unchanged
        }
    }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: ""hi"") == ""lm"")
assert(encrypt(s: ""asdfghjkl"") == ""ewhjklnop"")
assert(encrypt(s: ""gf"") == ""kj"")
assert(encrypt(s: ""et"") == ""ix"")
assert(encrypt(s: ""faewfawefaewg"") == ""jeiajeaijeiak"")
assert(encrypt(s: ""hellomyfriend"") == ""lippsqcjvmirh"")
assert(encrypt(s: ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"") == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")
assert(encrypt(s: ""a"") == ""e"")"
HumanEval_90,hau_Latn,swift,"
// Komawa ba kome ba idan babu irin wannan abu. // Rubuta aiki na gaba_mafi ƙanƙanta (() wanda ya dawo da ƙaramin abu na 2 na tsararren. // An ba ku jerin lambobi masu cikakke. /// >>> next_smallest(lst: [1, 2, 3, 4, 5])
/// 2
/// >>> next_smallest(lst: [5, 1, 4, 3, 2])
/// 2
/// >>> next_smallest(lst: [] as [Int])
/// nil
/// >>> next_smallest(lst: [1, 1])
/// nil
func next_smallest(lst: [Int]) -> Int? {
","func next_smallest(lst: [Int]) -> Int? {
    if lst.count < 2 {
        return nil
    }
    
    var uniqueSorted = Array(Set(lst)).sorted()
    
    if uniqueSorted.count < 2 {
        return nil
    }
    
    return uniqueSorted[1]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)
assert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)
assert(next_smallest(lst: [] as [Int]) == nil)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
HumanEval_91,hau_Latn,swift,"
// Misali: // Ana rarraba jumla ta '.', '?' ko '!'. ""Boredom"" wata magana ce da take farawa da kalmar ""I"".// Za a ba ku jerin kalmomi, kuma aikinku shi ne ƙidaya lambar /// >>> is_bored(S: ""Hello world"")
/// 0
/// >>> is_bored(S: ""The sky is blue. The sun is shining. I love this weather"")
/// 1
func is_bored(S: String) -> Int {
","func is_bored(S: String) -> Int {
    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }
    var boredomCount = 0
    
    for sentence in sentences {
        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)
        if trimmedSentence.hasPrefix(""I"") {
            boredomCount += 1
        }
    }
    
    return boredomCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_bored(S: ""Hello world"") == 0)
assert(is_bored(S: ""Is the sky blue?"") == 0)
assert(is_bored(S: ""I love It !"") == 1)
assert(is_bored(S: ""bIt"") == 0)
assert(is_bored(S: ""I feel good today. I will be productive. will kill It"") == 2)
assert(is_bored(S: ""You and I are going for a walk"") == 0)"
HumanEval_92,hau_Latn,swift,"
// Misalai // Yana dawowa ƙarya a kowane sauran lokuta. // Yana dawowa gaskiya idan daya daga cikin lambobi daidai yake da jimlar sauran biyu, kuma dukkan lambobi lambobi ne. // Ƙirƙiri aiki wanda ke ɗaukar lambobi 3. /// >>> any_int(x: 5, y: 2, z: 7)
/// true
/// >>> any_int(x: 3, y: 2, z: 2)
/// false
/// >>> any_int(x: 3, y: -2, z: 1)
/// true
/// >>> any_int(x: 3.6, y: -2.2, z: 2)
/// false
func any_int(x: Double, y: Double, z: Double) -> Bool {
","func any_int(x: Double, y: Double, z: Double) -> Bool {
    guard x == floor(x), y == floor(y), z == floor(z) else {
        return false
    }
    
    let a = Int(x)
    let b = Int(y)
    let c = Int(z)
    
    return a == b + c || b == a + c || c == a + b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(any_int(x: 2, y: 3, z: 1) == true)
assert(any_int(x: 2.5, y: 2, z: 3) == false)
assert(any_int(x: 1.5, y: 5, z: 3.5) == false)
assert(any_int(x: 2, y: 6, z: 2) == false)
assert(any_int(x: 4, y: 2, z: 2) == true)
assert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)
assert(any_int(x: -4, y: 6, z: 2) == true)
assert(any_int(x: 2, y: 1, z: 1) == true)
assert(any_int(x: 3, y: 4, z: 7) == true)
assert(any_int(x: 3.0, y: 4, z: 7) == false)"
HumanEval_93,hau_Latn,swift,"
// Misalai: // Kawai ka ɗauki haruffa. // murya a cikin haruffan Turanci. // saƙo tare da wasika da ya bayyana 2 wurare gaba da cewa // hanyar da shi swaps hali na duk haruffa, ya maye gurbin duk vowels a // Rubuta wani aiki da daukan wani sako, da kuma encodes a cikin irin wannan /// >>> encode(message: ""test"")
/// ""TGST""
/// >>> encode(message: ""This is a message"")
/// ""tHKS KS C MGSSCGG""
func encode(message: String) -> String {
","func encode(message: String) -> String {
    let vowels = ""aeiouAEIOU""
    let vowelReplacement = [
        ""a"": ""c"", ""e"": ""g"", ""i"": ""k"", ""o"": ""q"", ""u"": ""w"",
        ""A"": ""C"", ""E"": ""G"", ""I"": ""K"", ""O"": ""Q"", ""U"": ""W""
    ]
    
    var encodedMessage = """"
    
    for char in message {
        if vowels.contains(char) {
            if let replacement = vowelReplacement[String(char)] {
                encodedMessage.append(replacement)
            }
        } else {
            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())
            encodedMessage.append(swappedCase)
        }
    }
    
    return encodedMessage
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: ""TEST"") == ""tgst"")
assert(encode(message: ""Mudasir"") == ""mWDCSKR"")
assert(encode(message: ""YES"") == ""ygs"")
assert(encode(message: ""This is a message"") == ""tHKS KS C MGSSCGG"")
assert(encode(message: ""I DoNt KnOw WhAt tO WrItE"") == ""k dQnT kNqW wHcT Tq wRkTg"")"
HumanEval_94,hau_Latn,swift,"
// Misalai: // Kana bukatar ka sami mafi girma firam darajar da kuma dawo da jimlar da lambobi. // An ba ku jerin lambobi masu cikakke. /// >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])
/// 7
func skjkasdkd(lst: [Int]) -> Int {
","func skjkasdkd(lst: [Int]) -> Int {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    var largestPrime: Int? = nil
    for number in lst {
        if isPrime(number) {
            if largestPrime == nil || number > largestPrime! {
                largestPrime = number
            }
        }
    }
    
    if let largestPrime = largestPrime {
        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)
    }
    
    return 0 // In case there are no prime numbers
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)
assert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)
assert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)
assert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)
assert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)
assert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)
assert(skjkasdkd(lst: [8191]) == 19)
assert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)
assert(skjkasdkd(lst: [127, 97, 8192]) == 10)"
HumanEval_96,hau_Latn,swift,"
// misali: // integers da suke da farko lambobi da kuma kasa da n. // Aiwatar da wani aiki daukan wani ba-korau lamba kuma ya dawo da wani tsararru na farko n /// >>> count_up_to(n: 5)
/// [2, 3]
/// >>> count_up_to(n: 11)
/// [2, 3, 5, 7]
/// >>> count_up_to(n: 0)
/// [] as [Int]
/// >>> count_up_to(n: 20)
/// [2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(n: 1)
/// [] as [Int]
/// >>> count_up_to(n: 18)
/// [2, 3, 5, 7, 11, 13, 17]
func count_up_to(n: Int) -> [Int] {
","func count_up_to(n: Int) -> [Int] {
    guard n > 2 else { return [] }
    
    var primes: [Int] = [2]
    
    for number in 3..<n {
        var isPrime = true
        for prime in primes {
            if prime * prime > number {
                break
            }
            if number % prime == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            primes.append(number)
        }
    }
    
    return primes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_up_to(n: 5) == [2, 3])
assert(count_up_to(n: 6) == [2, 3, 5])
assert(count_up_to(n: 7) == [2, 3, 5])
assert(count_up_to(n: 10) == [2, 3, 5, 7])
assert(count_up_to(n: 0) == [] as [Int])
assert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])
assert(count_up_to(n: 1) == [] as [Int])
assert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])
assert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
assert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"
HumanEval_97,hau_Latn,swift,"
// Misalai: // Ka ɗauka cewa shigarwar koyaushe tana da inganci. // da samfurin na raka'a na raka'a. // Kammala aikin da yake ɗaukar lambobi biyu kuma ya dawo /// >>> multiply(a: 148, b: 412)
/// 16
/// >>> multiply(a: 19, b: 28)
/// 72
/// >>> multiply(a: 2020, b: 1851)
/// 0
/// >>> multiply(a: 14, b: -15)
/// 20
func multiply(a: Int, b: Int) -> Int {
","func multiply(a: Int, b: Int) -> Int {
    let unitDigitA = abs(a % 10)
    let unitDigitB = abs(b % 10)
    return unitDigitA * unitDigitB
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(multiply(a: 148, b: 412) == 16)
assert(multiply(a: 19, b: 28) == 72)
assert(multiply(a: 2020, b: 1851) == 0)
assert(multiply(a: 14, b: -15) == 20)
assert(multiply(a: 76, b: 67) == 42)
assert(multiply(a: 17, b: 27) == 49)
assert(multiply(a: 0, b: 1) == 0)
assert(multiply(a: 0, b: 0) == 0)"
HumanEval_98,hau_Latn,swift,"
// Misali: // An ba da kirtani s, ƙidaya adadin manyan haruffa a cikin alamomi ma. /// >>> count_upper(s: ""aBCdEf"")
/// 1
/// >>> count_upper(s: ""abcdefg"")
/// 0
/// >>> count_upper(s: ""dBBE"")
/// 0
func count_upper(s: String) -> Int {
","func count_upper(s: String) -> Int {
    let upperVowels = Set<Character>([""A"", ""E"", ""I"", ""O"", ""U""])
    var count = 0

    for (index, char) in s.enumerated() {
        if index % 2 == 0 && upperVowels.contains(char) {
            count += 1
        }
    }

    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_upper(s: ""aBCdEf"") == 1)
assert(count_upper(s: ""abcdefg"") == 0)
assert(count_upper(s: ""dBBE"") == 0)
assert(count_upper(s: ""B"") == 0)
assert(count_upper(s: ""U"") == 1)
assert(count_upper(s: """") == 0)
assert(count_upper(s: ""EEEE"") == 2)"
HumanEval_99,hau_Latn,swift,"
// Misalai // daga biyu integers, zagaye shi daga sifili. // kuma ya dawo da mafi kusa da shi. Idan lambar ne equidistant // Ƙirƙiri wani aiki wanda yake ɗaukar darajar (kirtani) wakiltar lamba /// >>> closest_integer(value: ""10"")
/// 10
/// >>> closest_integer(value: ""15.3"")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value: String) -> Int {
","func closest_integer(value: String) -> Int {
    if let number = Double(value) {
        return Int(number.rounded(.awayFromZero))
    }
    return 0 // or handle error as needed
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: ""10"") == 10)
assert(closest_integer(value: ""14.5"") == 15)
assert(closest_integer(value: ""-15.5"") == -16)
assert(closest_integer(value: ""15.3"") == 15)
assert(closest_integer(value: ""0"") == 0)"
HumanEval_100,hau_Latn,swift,"
// Misalai: // i wakiltar yawan duwatsu a matakin (i + 1). // Koma yawan duwatsu a kowane matakin a cikin wani tsararru, inda kashi a index // - lambar da ta gaba idan n ta kasance ma'aurata. // - lambar da ta gaba idan n ba ta da kyau. // Yawan duwatsu a mataki na gaba shine: // Mataki na farko yana da duwatsu n. // Ganin wani m lamba n, dole ka yi a tari na n matakan duwatsu. /// >>> make_a_pile(n: 3)
/// [3, 5, 7]
func make_a_pile(n: Int) -> [Int] {
","func make_a_pile(n: Int) -> [Int] {
    var pile = [Int]()
    var currentLevelStones = n
    
    for _ in 0..<n {
        pile.append(currentLevelStones)
        if n % 2 == 0 {
            currentLevelStones += 2
        } else {
            currentLevelStones += 2
        }
    }
    
    return pile
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_a_pile(n: 3) == [3, 5, 7])
assert(make_a_pile(n: 4) == [4, 6, 8, 10])
assert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])
assert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])
assert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"
HumanEval_101,hau_Latn,swift,"
// Misali: // don raba kirtani zuwa kalmomi kuma dawo da jerin kalmomin. Za a ba ku jerin kalmomi da aka raba ta hanyar commas ko sarari./// >>> words_string(s: ""Hi, my name is John"")
/// [""Hi"", ""my"", ""name"", ""is"", ""John""]
/// >>> words_string(s: ""One, two, three, four, five, six"")
/// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
func words_string(s: String) -> [String] {
","func words_string(s: String) -> [String] {
    let separators = CharacterSet(charactersIn: "", "")
    return s.components(separatedBy: separators).filter { !$0.isEmpty }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_string(s: ""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""])
assert(words_string(s: ""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: ""Hi, my name"") == [""Hi"", ""my"", ""name""])
assert(words_string(s: ""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: """") == [] as [String])
assert(words_string(s: ""ahmed     , gamal"") == [""ahmed"", ""gamal""])"
HumanEval_102,hau_Latn,swift,"
// Misali: // babu irin wannan lambar, to aikin ya kamata ya dawo -1. // mafi girma ma'auni lamba cewa shi ne a cikin kewayon [x, y] hada. Idan // Wannan aikin yana ɗaukar lambobi biyu masu kyau x da y kuma ya dawo da /// >>> choose_num(x: 12, y: 15)
/// 14
/// >>> choose_num(x: 13, y: 12)
/// -1
func choose_num(x: Int, y: Int) -> Int {
","func choose_num(x: Int, y: Int) -> Int {
    // Determine the starting and ending range values
    let start = min(x, y)
    let end = max(x, y)
    
    // Iterate from the end of the range to the start
    for num in (start...end).reversed() {
        // Check if the current number is even
        if num % 2 == 0 {
            return num
        }
    }
    
    // Return -1 if no even number is found
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(choose_num(x: 12, y: 15) == 14)
assert(choose_num(x: 13, y: 12) == -1)
assert(choose_num(x: 33, y: 12354) == 12354)
assert(choose_num(x: 5234, y: 5233) == -1)
assert(choose_num(x: 6, y: 29) == 28)
assert(choose_num(x: 27, y: 10) == -1)
assert(choose_num(x: 7, y: 7) == -1)
assert(choose_num(x: 546, y: 546) == 546)"
HumanEval_103,hau_Latn,swift,"
extension Int: Error {}
        
// Misali: // Idan n ya fi m girma, dawo -1. // Zagaye amsar zuwa lambar da ta fi kusa kuma canza shi zuwa binary. // matsakaicin lambobi daga n zuwa m (ciki har da n da m). // An ba ku lambobi biyu masu kyau n da m, kuma aikinku shine yin lissafin /// >>> rounded_avg(n: 1, m: 5)
/// .success(""0b11"")
/// >>> rounded_avg(n: 7, m: 5)
/// .failure(-1)
/// >>> rounded_avg(n: 10, m: 20)
/// .success(""0b1111"")
/// >>> rounded_avg(n: 20, m: 33)
/// .success(""0b11010"")
func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
","func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
    if n > m {
        return .failure(-1)
    }
    
    let count = m - n + 1
    let sum = (n + m) * count / 2
    let average = Double(sum) / Double(count)
    let roundedAverage = Int(average.rounded())
    let binaryString = String(roundedAverage, radix: 2)
    
    return .success(""0b"" + binaryString)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rounded_avg(n: 1, m: 5) == .success(""0b11""))
assert(rounded_avg(n: 7, m: 13) == .success(""0b1010""))
assert(rounded_avg(n: 964, m: 977) == .success(""0b1111001010""))
assert(rounded_avg(n: 996, m: 997) == .success(""0b1111100100""))
assert(rounded_avg(n: 560, m: 851) == .success(""0b1011000010""))
assert(rounded_avg(n: 185, m: 546) == .success(""0b101101110""))
assert(rounded_avg(n: 362, m: 496) == .success(""0b110101101""))
assert(rounded_avg(n: 350, m: 902) == .success(""0b1001110010""))
assert(rounded_avg(n: 197, m: 233) == .success(""0b11010111""))
assert(rounded_avg(n: 7, m: 5) == .failure(-1))
assert(rounded_avg(n: 5, m: 1) == .failure(-1))
assert(rounded_avg(n: 5, m: 5) == .success(""0b101""))"
HumanEval_104,hau_Latn,swift,"
// Misali: // Lura: Ya kamata a tsara jerin da aka dawo a cikin tsari mai girma. // abubuwan da ba su da wani ma'ana. // Ba da wani tsararru na m integers x. dawo da wani tsararru na dukan /// >>> unique_digits(x: [15, 33, 1422, 1])
/// [1, 15, 33]
/// >>> unique_digits(x: [152, 323, 1422, 10])
/// [] as [Int]
func unique_digits(x: [Int]) -> [Int] {
","func unique_digits(x: [Int]) -> [Int] {
    return x.filter { number in
        var hasEvenDigit = false
        var num = number
        while num > 0 {
            if (num % 10) % 2 == 0 {
                hasEvenDigit = true
                break
            }
            num /= 10
        }
        return !hasEvenDigit
    }.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])
assert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])
assert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])
assert(unique_digits(x: [135, 103, 31]) == [31, 135])"
HumanEval_105,hau_Latn,swift,"
// Misali: // ""Daya"", ""Biyu"", ""Uku"", ""Hudu"", ""Biyar"", ""Shida"", ""Bakwai"", ""Takwas"", ""Tasa'i"". // jujjuya sakamakon jeri, sannan maye gurbin kowane lamba da sunan da ya dace daga // Ba da wani tsararru na integers, rarraba da integers da suke tsakanin 1 da kuma 9 hada, /// >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])
/// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
/// If the array is empty, return an empty array:
/// >>> by_length(arr: [] as [Int])
/// [] as [String]
/// If the array has any strange number ignore it:
/// >>> by_length(arr: [1, -1, 55])
/// [""One""]
func by_length(arr: [Int]) -> [String] {
","func by_length(arr: [Int]) -> [String] {
    let numberNames: [Int: String] = [
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine""
    ]
    
    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }
                                           .sorted(by: >)
    
    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? """" }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""])
assert(by_length(arr: [] as [Int]) == [] as [String])
assert(by_length(arr: [1, -1, 55]) == [""One""])
assert(by_length(arr: [1, -1, 3, 2]) == [""Three"", ""Two"", ""One""])
assert(by_length(arr: [9, 4, 8]) == [""Nine"", ""Eight"", ""Four""])"
HumanEval_106,hau_Latn,swift,"
// Misali: // factor na i shine ninka lambobi daga 1 zuwa i (1 * 2 * ... * i). // i yana farawa daga 1. // ko jimlar lambobi daga 1 zuwa i in ba haka ba. // kuma ya dawo da wani tsararru na size n, irin wannan cewa darajar da kashi a index i ne factorial na i idan i ne ko da // Aiwatar da aiki f cewa daukan n a matsayin siga, /// >>> f(n: 5)
/// [1, 2, 6, 24, 15]
func f(n: Int) -> [Int] {
","func f(n: Int) -> [Int] {
    func factorial(_ x: Int) -> Int {
        guard x > 1 else { return 1 }
        return (1...x).reduce(1, *)
    }
    
    func sumTo(_ x: Int) -> Int {
        return (1...x).reduce(0, +)
    }
    
    var result = [Int]()
    for i in 1...n {
        if i % 2 == 0 {
            result.append(factorial(i))
        } else {
            result.append(sumTo(i))
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(f(n: 5) == [1, 2, 6, 24, 15])
assert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])
assert(f(n: 1) == [1])
assert(f(n: 3) == [1, 2, 6])"
HumanEval_107,hau_Latn,swift,"
// Misali na 1: // palindromes na lamba wanda ya faɗi cikin kewayon ((1, n), ciki har da. // Ba da wani m lamba n, dawo da wani tuple cewa yana da yawan ma da m /// >>> even_odd_palindrome(n: 3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(n: 12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n: Int) -> (Int, Int) {
","func even_odd_palindrome(n: Int) -> (Int, Int) {
    func isPalindrome(_ num: Int) -> Bool {
        let str = String(num)
        return str == String(str.reversed())
    }
    
    var evenCount = 0
    var oddCount = 0
    
    for i in 1...n {
        if isPalindrome(i) {
            if i % 2 == 0 {
                evenCount += 1
            } else {
                oddCount += 1
            }
        }
    }
    
    return (evenCount, oddCount)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_palindrome(n: 123) == (8, 13))
assert(even_odd_palindrome(n: 12) == (4, 6))
assert(even_odd_palindrome(n: 3) == (1, 2))
assert(even_odd_palindrome(n: 63) == (6, 8))
assert(even_odd_palindrome(n: 25) == (5, 6))
assert(even_odd_palindrome(n: 19) == (4, 6))
assert(even_odd_palindrome(n: 9) == (4, 5))
assert(even_odd_palindrome(n: 1) == (0, 1))"
HumanEval_108,hau_Latn,swift,"
// misali -123 yana da alamun lambobi -1, 2, da 3. // Idan lamba ta kasance mara kyau, to, lambar farko da aka sanya hannu za ta zama mara kyau: // yawan abubuwan da ke da adadin lambobi > 0. // Rubuta aikin count_nums wanda ke ɗaukar jerin lambobi kuma ya dawo /// >>> count_nums(arr: [] as [Int])
/// 0
/// >>> count_nums(arr: [-1, 11, -11])
/// 1
/// >>> count_nums(arr: [1, 1, 2])
/// 3
func count_nums(arr: [Int]) -> Int {
","func count_nums(arr: [Int]) -> Int {
    return arr.filter { number in
        var n = number
        var sumOfDigits = 0

        while n != 0 {
            sumOfDigits += n % 10
            n /= 10
        }

        return sumOfDigits > 0
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_nums(arr: [] as [Int]) == 0)
assert(count_nums(arr: [-1, -2, 0]) == 0)
assert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)
assert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)
assert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)
assert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)
assert(count_nums(arr: [0, 1]) == 1)
assert(count_nums(arr: [1]) == 1)"
HumanEval_109,hau_Latn,swift,"
// Misali: // Lura: An ba da tabbacin cewa jerin sunayen suna da abubuwa na musamman. // Idan da aka ba tsararru ne fanko sa'an nan kuma dawo gaskiya. // to sai ku dawo da gaskiya ko kuma ku dawo da karya. // Idan yana yiwuwa a samu da rarraba tsararru ta hanyar yin sama aiki // Matsayin farawa a cikin jeri watau 0th index. // matsayi a cikin hanyar da ta dace. Ƙarshen kashi na array za a koma zuwa // Ɗaya daga cikin aikin motsawa na dama yana nufin motsa dukkan abubuwa na array ta daya // An ba ku izinin yin aiki na dama sau da yawa. // da wadannan aiki a kan ba tsararru: // yana yiwuwa a samu wani tsararru da aka jera a cikin ba ragewa domin ta hanyar yin // lambobi a cikin tsararru za a yi amfani da su ba tare da izini ba.// Muna da jerin 'arr' na N integers arr[1], arr[2], ..., arr[N].The /// >>> move_one_ball(arr: [3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given array.
/// >>> move_one_ball(arr: [3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// array by performing any number of right shift operations.
func move_one_ball(arr: [Int]) -> Bool {
","func move_one_ball(arr: [Int]) -> Bool {
    guard !arr.isEmpty else { return true }
    
    let n = arr.count
    var breakPointCount = 0
    
    // Find the number of break points where the array is decreasing
    for i in 0..<n {
        if arr[i] > arr[(i + 1) % n] {
            breakPointCount += 1
        }
    }
    
    // If there's at most one break point, the array can be right shifted
    return breakPointCount <= 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)
assert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)
assert(move_one_ball(arr: [4, 3, 1, 2]) == false)
assert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)
assert(move_one_ball(arr: [] as [Int]) == true)"
HumanEval_110,hau_Latn,swift,"
// Misali: // In ba haka ba, dawo da ""NO"". // duk abubuwa na lst1 su zama ma, dawo ""YES"". // Idan yana yiwuwa a musanya abubuwa tsakanin lst1 da lst2 don yin // Babu iyaka ga yawan abubuwan da aka musayar tsakanin lst1 da lst2. // tsakanin su don yin lst1 wani tsararru na kawai ma lambobin. // kuma yana ƙayyade ko yana yiwuwa a yi musayar abubuwa // A cikin wannan matsala, za ka yi wani aiki da daukan biyu arrays na lambobi, /// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])
/// ""YES""
/// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])
/// ""NO""
/// It is assumed that the input arrays will be non-empty.
func exchange(lst1: [Int], lst2: [Int]) -> String {
","func exchange(lst1: [Int], lst2: [Int]) -> String {
    var hasOddInLst1 = false
    var hasEvenInLst2 = false
    
    for num in lst1 {
        if num % 2 != 0 {
            hasOddInLst1 = true
            break
        }
    }
    
    for num in lst2 {
        if num % 2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasOddInLst1 {
        return ""YES""
    }
    
    if hasEvenInLst2 {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == ""YES"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == ""NO"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == ""NO"")
assert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == ""NO"")
assert(exchange(lst1: [100, 200], lst2: [200, 200]) == ""YES"")"
HumanEval_111,hau_Latn,swift,"
// Misali: // Idan haruffa da yawa suna da wannan abin da ya faru, dawo da su duka. // na harafin da ya fi maimaitawa kuma yana ƙunshe da adadin da ya dace. // Ba da kirtani wakiltar sarari rabu kananan haruffa, dawo da wani kamus /// >>> histogram(test: ""a b c"")
/// [""a"" : 1, ""b"" : 1, ""c"" : 1]
/// >>> histogram(test: ""a b b a"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""a b c a b"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""b b b b a"")
/// [""b"" : 4]
/// >>> histogram(test: """")
/// [:] as [String : Int]
func histogram(test: String) -> [String : Int] {
","func histogram(test: String) -> [String : Int] {
    var letterCount: [String: Int] = [:]

    // Split the string into an array of letters
    let letters = test.split(separator: "" "").map { String($0) }

    // Count occurrences of each letter
    for letter in letters {
        letterCount[letter, default: 0] += 1
    }

    // Determine the maximum number of occurrences
    guard let maxCount = letterCount.values.max() else {
        return [:] as [String : Int]
    }

    // Filter the letterCount dictionary to only include letters with the max count
    let result = letterCount.filter { $0.value == maxCount }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(histogram(test: ""a b b a"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c a b"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c d g"") == [""a"" : 1, ""b"" : 1, ""c"" : 1, ""d"" : 1, ""g"" : 1])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: ""b b b b a"") == [""b"" : 4])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: """") == [:] as [String : Int])
assert(histogram(test: ""a"") == [""a"" : 1])"
HumanEval_112,hau_Latn,swift,"
// Misali // Ya kamata ka dawo da wani tuple dauke da sakamakon kirtani da kuma gaskiya / ƙarya ga dubawa. // Ana kiran kirtani palindrome idan ya karanta daidai da baya kamar gaba. // sannan ka duba idan sakamakon kirtani palindrome ne. // An ba mu igiyoyi biyu s da c, dole ne ka share duk haruffa a s da suke daidai da kowane hali a c // Aiki /// >>> reverse_delete(s: ""abcde"", c: ""ae"")
/// (""bcd"", false)
/// >>> reverse_delete(s: ""abcdef"", c: ""b"")
/// (""acdef"", false)
/// >>> reverse_delete(s: ""abcdedcba"", c: ""ab"")
/// (""cdedc"", true)
func reverse_delete(s: String, c: String) -> (String, Bool) {
","func reverse_delete(s: String, c: String) -> (String, Bool) {
    // Remove characters from s that are in c
    let filteredString = s.filter { !c.contains($0) }
    
    // Check if the resulting string is a palindrome
    let isPalindrome = filteredString == String(filteredString.reversed())
    
    // Return the resulting string and the palindrome check result
    return (filteredString, isPalindrome)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(reverse_delete(s: ""abcde"", c: ""ae"") == (""bcd"", false))
assert(reverse_delete(s: ""abcdef"", c: ""b"") == (""acdef"", false))
assert(reverse_delete(s: ""abcdedcba"", c: ""ab"") == (""cdedc"", true))
assert(reverse_delete(s: ""dwik"", c: ""w"") == (""dik"", false))
assert(reverse_delete(s: ""a"", c: ""a"") == ("""", true))
assert(reverse_delete(s: ""abcdedcba"", c: """") == (""abcdedcba"", true))
assert(reverse_delete(s: ""abcdedcba"", c: ""v"") == (""abcdedcba"", true))
assert(reverse_delete(s: ""vabba"", c: ""v"") == (""abba"", true))
assert(reverse_delete(s: ""mamma"", c: ""mia"") == ("""", true))"
HumanEval_113,hau_Latn,swift,"
// na m lambobi a cikin i'th kirtani na shigar da. // kirtani na shigarwa. "" inda duk i's ya kamata a maye gurbinsu da lambar // Kowane kashi na fitarwa ya kamata ya zama ""yawan abubuwa marasa daidaituwa a cikin // An ba da jerin jeri, inda kowane jeri ya ƙunshi lambobi kawai, dawo da jeri. /// >>> odd_count(lst: [""1234567""])
/// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
/// >>> odd_count(lst: [""3"", ""11111111""])
/// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
func odd_count(lst: [String]) -> [String] {
","func odd_count(lst: [String]) -> [String] {
    return lst.map { str in
        let oddCount = str.filter { ""13579"".contains($0) }.count
        return ""the number of odd elements \(oddCount)n the str\(oddCount)ng \(oddCount) of the \(oddCount)nput.""
    }
}

// Example Usage
print(odd_count(lst: [""1234567""]))
print(odd_count(lst: [""3"", ""11111111""]))","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(odd_count(lst: [""1234567""]) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""])
assert(odd_count(lst: [""3"", ""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""])
assert(odd_count(lst: [""271"", ""137"", ""314""]) == [""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""])"
HumanEval_114,hau_Latn,swift,"
// Misali // na lambobi. // An ba da jerin lambobi masu lamba n, sami mafi ƙarancin jimlar kowane ɓangaren da ba komai ba /// >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(nums: [-1, -2, -3])
/// -6
func minSubArraySum(nums: [Int]) -> Int {
","func minSubArraySum(nums: [Int]) -> Int {
    guard !nums.isEmpty else { return 0 }
    
    var currentMin = nums[0]
    var overallMin = nums[0]
    
    for i in 1..<nums.count {
        currentMin = min(nums[i], currentMin + nums[i])
        overallMin = min(overallMin, currentMin)
    }
    
    return overallMin
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)
assert(minSubArraySum(nums: [-1, -2, -3]) == -6)
assert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)
assert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)
assert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)
assert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)
assert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)
assert(minSubArraySum(nums: [-10]) == -10)
assert(minSubArraySum(nums: [7]) == 7)
assert(minSubArraySum(nums: [1, -1]) == -1)"
HumanEval_115,hau_Latn,swift,"
// Misali na 1: // Fitar da yawan lokutan da kake buƙatar saukar da buckets. // Aikinku shi ne amfani da bokiti don zubar da rijiyoyin. // kuma duk buckets suna da irin wannan damar. // Kowane rijiya tana da guga mai dacewa wanda za'a iya amfani dashi don cire ruwa daga ciki, // kuma kowane 1 a jere yana wakiltar raka'a guda na ruwa. // An ba ku grid na ma'adanai. Kowane jere yana wakiltar rijiyar guda ɗaya, /// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)
/// 6
/// Example 2:
/// >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)
/// 5
/// Example 3:
/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
func max_fill(grid: [[Int]], capacity: Int) -> Int {
","func max_fill(grid: [[Int]], capacity: Int) -> Int {
    var totalWater = 0
    for row in grid {
        for unit in row {
            if unit == 1 {
                totalWater += 1
            }
        }
    }
    return (totalWater + capacity - 1) / capacity
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)
assert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)
assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
HumanEval_116,hau_Latn,swift,"
// Dole ne a aiwatar da shi kamar haka: // Don irin wannan adadin na daya, rarrabe bisa ga darajar decimal. // yawan wadanda suke wakiltar binary a cikin tsari mai tasowa. // A cikin wannan Kata, dole ne ka rarraba jerin lambobi marasa kyau bisa ga /// >>> sort_array(arr: [1, 5, 2, 3, 4])
/// [1, 2, 3, 4, 5]
/// >>> sort_array(arr: [-2, -3, -4, -5, -6])
/// [-6, -5, -4, -3, -2]
/// >>> sort_array(arr: [1, 0, 2, 3, 4])
/// [0, 1, 2, 3, 4]
func sort_array(arr: [Int]) -> [Int] {
","func sort_array(arr: [Int]) -> [Int] {
    return arr.sorted {
        let onesCount1 = $0.nonNegativeOnesCount()
        let onesCount2 = $1.nonNegativeOnesCount()
        return (onesCount1, $0) < (onesCount2, $1)
    }
}

extension Int {
    func nonNegativeOnesCount() -> Int {
        return self < 0 ? 0 : self.nonBitCount()
    }
    
    private func nonBitCount() -> Int {
        var count = 0
        var num = self
        while num > 0 {
            count += num & 1
            num >>= 1
        }
        return count
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])
assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])
assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])
assert(sort_array(arr: [] as [Int]) == [] as [Int])
assert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])
assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
HumanEval_117,hau_Latn,swift,"
// Misalai: // Note: za ka iya ɗauka da shigar da kirtani ya ƙunshi kawai haruffa da sarari. // Idan kirtani s ne m sa'an nan aikin ya kamata dawo da wani m tsararru. // n consonants, domin wadannan kalmomi sun bayyana a cikin kirtani s. // wani aiki da ya dawo da wani tsararru na dukan kalmomi daga kirtani s cewa dauke daidai // An ba da kirtani s da lambar halitta n, an ba ku aikin aiwatar da /// >>> select_words(s: ""Mary had a little lamb"", n: 4)
/// [""little""]
/// >>> select_words(s: ""Mary had a little lamb"", n: 3)
/// [""Mary"", ""lamb""]
/// >>> select_words(s: ""simple white space"", n: 2)
/// [] as [String]
/// >>> select_words(s: ""Hello world"", n: 4)
/// [""world""]
/// >>> select_words(s: ""Uncle sam"", n: 3)
/// [""Uncle""]
func select_words(s: String, n: Int) -> [String] {
","func select_words(s: String, n: Int) -> [String] {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    let words = s.split(separator: "" "")
    var result: [String] = []
    
    for word in words {
        let consonantCount = word.filter { !vowels.contains($0) }.count
        if consonantCount == n {
            result.append(String(word))
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(select_words(s: ""Mary had a little lamb"", n: 4) == [""little""])
assert(select_words(s: ""Mary had a little lamb"", n: 3) == [""Mary"", ""lamb""])
assert(select_words(s: ""simple white space"", n: 2) == [] as [String])
assert(select_words(s: ""Hello world"", n: 4) == [""world""])
assert(select_words(s: ""Uncle sam"", n: 3) == [""Uncle""])
assert(select_words(s: """", n: 4) == [] as [String])
assert(select_words(s: ""a b c d e f"", n: 1) == [""b"", ""c"", ""d"", ""f""])"
HumanEval_118,hau_Latn,swift,"
// Misali: // Za ka iya ɗauka cewa da aka ba kirtani ƙunshi Turanci harafi kawai. // sami kowane mai magana ya sadu da yanayin da ke sama. // Vowels a farkon da kuma kawo karshen ba ya ƙidaya. Koma blank kirtani idan ba ka // biyu consonants daga gefen dama na kalmar (case m). // An ba ku kalma. Aikinku shine gano mafi kusa da wasula wanda ke tsaye tsakanin /// >>> get_closest_vowel(word: ""yogurt"")
/// ""u""
/// >>> get_closest_vowel(word: ""FULL"")
/// ""U""
/// >>> get_closest_vowel(word: ""quick"")
/// """"
/// >>> get_closest_vowel(word: ""ab"")
/// """"
func get_closest_vowel(word: String) -> String {
","func get_closest_vowel(word: String) -> String {
    let vowels = Set(""aeiouAEIOU"")
    var foundVowel: Character? = nil
    
    for i in stride(from: word.count - 2, through: 1, by: -1) {
        let currentIndex = word.index(word.startIndex, offsetBy: i)
        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)
        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)
        
        if vowels.contains(word[currentIndex]) && 
            !vowels.contains(word[previousIndex]) && 
            !vowels.contains(word[nextIndex]) {
            foundVowel = word[currentIndex]
            break
        }
    }
    
    return foundVowel != nil ? String(foundVowel!) : """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: ""yogurt"") == ""u"")
assert(get_closest_vowel(word: ""full"") == ""u"")
assert(get_closest_vowel(word: ""easy"") == """")
assert(get_closest_vowel(word: ""eAsy"") == """")
assert(get_closest_vowel(word: ""ali"") == """")
assert(get_closest_vowel(word: ""bad"") == ""a"")
assert(get_closest_vowel(word: ""most"") == ""o"")
assert(get_closest_vowel(word: ""ab"") == """")
assert(get_closest_vowel(word: ""ba"") == """")
assert(get_closest_vowel(word: ""quick"") == """")
assert(get_closest_vowel(word: ""anime"") == ""i"")
assert(get_closest_vowel(word: ""Asia"") == """")
assert(get_closest_vowel(word: ""Above"") == ""o"")"
HumanEval_119,hau_Latn,swift,"
// Misalai: // Koma 'Yes' idan akwai wata hanya ta yin kyau kirtani, da kuma dawo 'No' in ba haka ba. // '()) ' ba haka ba ne. // suna daidaita. Alal misali: kirtani '(()))) yana da kyau, yayin da kirtani // A kirtani S an dauke su zama mai kyau idan kuma kawai idan duk parentheses a S // wasu tsari, cewa sakamakon kirtani zai zama mai kyau. // Aikinku shi ne duba idan yana yiwuwa a haɗa igiyoyi biyu a cikin // kawai a cikin ' ((' ko kusa da ') ' kawai. // An ba ku jerin jeri biyu, duka jeri sun ƙunshi bude /// >>> match_parens(lst: [""()("", "")""])
/// ""Yes""
/// >>> match_parens(lst: ["")"", "")""])
/// ""No""
func match_parens(lst: [String]) -> String {
","func match_parens(lst: [String]) -> String {
    let combined1 = lst[0] + lst[1]
    let combined2 = lst[1] + lst[0]
    
    func isBalanced(_ s: String) -> Bool {
        var balance = 0
        for char in s {
            if char == ""("" {
                balance += 1
            } else if char == "")"" {
                balance -= 1
            }
            if balance < 0 {
                return false
            }
        }
        return balance == 0
    }
    
    if isBalanced(combined1) || isBalanced(combined2) {
        return ""Yes""
    } else {
        return ""No""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(match_parens(lst: [""()("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", "")""]) == ""No"")
assert(match_parens(lst: [""(()(())"", ""())())""]) == ""No"")
assert(match_parens(lst: ["")())"", ""(()()(""]) == ""Yes"")
assert(match_parens(lst: [""(())))"", ""(()())((""]) == ""Yes"")
assert(match_parens(lst: [""()"", ""())""]) == ""No"")
assert(match_parens(lst: [""(()("", ""()))()""]) == ""Yes"")
assert(match_parens(lst: [""(((("", ""((())""]) == ""No"")
assert(match_parens(lst: ["")(()"", ""(()(""]) == ""No"")
assert(match_parens(lst: ["")("", "")(""]) == ""No"")
assert(match_parens(lst: [""("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", ""(""]) == ""Yes"")"
HumanEval_120,hau_Latn,swift,"
// Misali na 1: // na tsawon k tare da mafi yawan k lambobi a cikin arr. // An ba da jerin arr na integers da kuma tabbatacce lamba k, dawo da wani tsari tsari /// >>> maximum(arr: [-3, -4, 5], k: 3)
/// [-4, -3, 5]
/// Example 2:
/// >>> maximum(arr: [4, -4, 4], k: 2)
/// [4, 4]
/// Example 3:
/// >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)
/// [2]
/// Note:
/// 1. The length of the array will be in the range of [1, 1000].
/// 2. The elements in the array will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
func maximum(arr: [Int], k: Int) -> [Int] {
","func maximum(arr: [Int], k: Int) -> [Int] {
    guard k > 0 else { return [] }
    let sortedArr = arr.sorted(by: >)
    let maxElements = Array(sortedArr.prefix(k))
    return maxElements.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])
assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])
assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])
assert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])
assert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])
assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])
assert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])
assert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])
assert(maximum(arr: [4, -4], k: 2) == [-4, 4])
assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])
assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
HumanEval_121,hau_Latn,swift,"
// Misalai // Ba da wani ba-takarar tsararru na integers, dawo da jimlar dukan m abubuwa da suke a ko da matsayi. /// >>> solution(lst: [5, 8, 7, 1])
/// 12
/// >>> solution(lst: [3, 3, 3, 3, 3])
/// 9
/// >>> solution(lst: [30, 13, 24, 321])
/// 0
func solution(lst: [Int]) -> Int {
","func solution(lst: [Int]) -> Int {
    var sum = 0
    for (index, value) in lst.enumerated() {
        if index % 2 == 0 && value % 2 != 0 {
            sum += value
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solution(lst: [5, 8, 7, 1]) == 12)
assert(solution(lst: [3, 3, 3, 3, 3]) == 9)
assert(solution(lst: [30, 13, 24, 321]) == 0)
assert(solution(lst: [5, 9]) == 5)
assert(solution(lst: [2, 4, 8]) == 0)
assert(solution(lst: [30, 13, 23, 32]) == 23)
assert(solution(lst: [3, 13, 2, 9]) == 3)"
HumanEval_122,hau_Latn,swift,"
// Misali: // jimlar abubuwan da ke da lambobi biyu daga farkon abubuwa k na arr. // An ba da jerin abubuwan da ba komai ba na cikakkun lambobi arr da kuma cikakkiyar k, dawo da /// >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
func add_elements(arr: [Int], k: Int) -> Int {
","func add_elements(arr: [Int], k: Int) -> Int {
    var sum = 0
    for i in 0..<k {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)
assert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)
assert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)
assert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)
assert(add_elements(arr: [1], k: 1) == 1)"
HumanEval_123,hau_Latn,swift,"
// get_odd_collatz(5) dawo da [1, 5] # Jerin collatz don 5 shine [5, 16, 8, 4, 2, 1], don haka lambobin ban mamaki sune 1 da 5. // Misali: // 2. dawo da tsararru da aka tsara cikin tsari mai tasowa. // 1. Collatz ((1) shine [1]. // Lura: // lokaci da 1. da zato shi ne cewa ko da abin da darajar n, da jerin za su ko da yaushe kai 1. Idan kashi na baya ya zama mai ban mamaki, kashi na gaba zai zama sau 3 na na baya.// previous term kamar haka: idan previous term yana da ma'ana, na gaba lokaci ne daya rabin // kamar haka: fara da kowane tabbatacce lamba n. Sa'an nan kowane lokaci da aka samu daga // Hasashen Collatz shine hasashe a cikin lissafi wanda ya shafi jerin abubuwan da aka bayyana // Ba da wani m lamba n, dawo da wani tsari tsararru cewa yana da m lambobin a collatz jerin. /// >>> get_odd_collatz(n: 5)
/// [1, 5]
func get_odd_collatz(n: Int) -> [Int] {
","func get_odd_collatz(n: Int) -> [Int] {
    var collatzSequence: [Int] = []
    var number = n

    while number != 1 {
        if number % 2 != 0 {
            collatzSequence.append(number)
        }
        if number % 2 == 0 {
            number /= 2
        } else {
            number = 3 * number + 1
        }
    }

    collatzSequence.append(1) // append 1 as the sequence ends at 1

    let sortedOdds = collatzSequence.sorted()
    
    return sortedOdds
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])
assert(get_odd_collatz(n: 5) == [1, 5])
assert(get_odd_collatz(n: 12) == [1, 3, 5])
assert(get_odd_collatz(n: 1) == [1])"
HumanEval_124,hau_Latn,swift,"
// 4. kwanan wata ya kamata a cikin tsari: mm-dd-yyyy Watanni ba za su zama ƙasa da 1 ko sama da 12 ba.// 2. Yawan kwanaki ba kasa da 1 ko mafi girma fiye da 31 kwanaki ga watanni 1,3,5,7,8,10,12. Kuma yawan kwanaki ba kasa da 1 ko mafi girma fiye da 30 kwanaki ga watanni 4,6,9,11. Kuma, yawan kwanaki ba kasa da 1 ko mafi girma fiye da 29 ga watan 2. // 1. Ranar kwanan wata ba ta da komai. // Ranar tana da inganci idan duk ka'idojin da ke gaba sun cika: // dawo gaskiya idan kwanan wata yana da inganci in ba haka ba ƙarya. // Dole ne ka rubuta wani aiki wanda ya inganta a ba kwanan wata kirtani da kuma /// >>> valid_date(date: ""03-11-2000"")
/// true
/// >>> valid_date(date: ""15-01-2012"")
/// false
/// >>> valid_date(date: ""04-0-2040"")
/// false
/// >>> valid_date(date: ""06-04-2020"")
/// true
/// >>> valid_date(date: ""06/04/2020"")
/// false
func valid_date(date: String) -> Bool {
","func valid_date(date: String) -> Bool {
    // Check if the date is empty
    if date.isEmpty {
        return false
    }
    
    // Split the date into components using the ""-"" delimiter
    let components = date.split(separator: ""-"")
    
    // Ensure the date has exactly three components
    if components.count != 3 {
        return false
    }
    
    // Ensure the date components are integers
    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {
        return false
    }
    
    // Check if the month is within the valid range
    if month < 1 || month > 12 {
        return false
    }
    
    // Define the number of days in each month
    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    // Check the day range for each month
    if day < 1 || day > daysInMonth[month] {
        return false
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(valid_date(date: ""03-11-2000"") == true)
assert(valid_date(date: ""15-01-2012"") == false)
assert(valid_date(date: ""04-0-2040"") == false)
assert(valid_date(date: ""06-04-2020"") == true)
assert(valid_date(date: ""01-01-2007"") == true)
assert(valid_date(date: ""03-32-2011"") == false)
assert(valid_date(date: """") == false)
assert(valid_date(date: ""04-31-3000"") == false)
assert(valid_date(date: ""06-06-2005"") == true)
assert(valid_date(date: ""21-31-2000"") == false)
assert(valid_date(date: ""04-12-2003"") == true)
assert(valid_date(date: ""04122003"") == false)
assert(valid_date(date: ""20030412"") == false)
assert(valid_date(date: ""2003-04"") == false)
assert(valid_date(date: ""2003-04-12"") == false)
assert(valid_date(date: ""04-2003"") == false)"
HumanEval_125,hau_Latn,swift,"
extension Int: Error {}
        
// Misalai // haruffa, umarni a ') = 0, umarni b' ') = 1, ... umarni z' ') = 25 // kamata raba a kan ',' idan babu commas wanzu ya kamata ka dawo da yawan kananan haruffa da m domin a cikin // Ba da jerin kalmomi, dawo da jerin kalmomi raba a kan sarari, idan babu sarari a cikin rubutu da kake /// >>> split_words(txt: ""Hello world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""Hello,world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""abcdef"")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
","func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains("" "") {
        let words = txt.split(separator: "" "").map { String($0) }
        return .success(words)
    } else if txt.contains("","") {
        let words = txt.split(separator: "","").map { String($0) }
        return .success(words)
    } else {
        let oddOrderedLowerCaseLetters = txt.filter { char in
            if let asciiValue = char.asciiValue {
                let order = asciiValue - Character(""a"").asciiValue!
                return order % 2 == 1
            }
            return false
        }
        return .failure(oddOrderedLowerCaseLetters.count)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: ""Hello world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello,world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello world,!"") == .success([""Hello"", ""world,!""]))
assert(split_words(txt: ""Hello,Hello,world !"") == .success([""Hello,Hello,world"", ""!""]))
assert(split_words(txt: ""abcdef"") == .failure(3))
assert(split_words(txt: ""aaabb"") == .failure(2))
assert(split_words(txt: ""aaaBb"") == .failure(1))
assert(split_words(txt: """") == .failure(0))"
HumanEval_126,hau_Latn,swift,"
// Misalai // lamba, dawo da ƙarya. Ka yi tunanin babu lambobin da ba daidai ba kuma kawai lambobi ne. Idan array yana da fiye da 1 duplicate na wannan // Ba da jerin lambobi, dawo ko suna da tsari ko a'a /// >>> is_sorted(lst: [5])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])
/// false
func is_sorted(lst: [Int]) -> Bool {
","func is_sorted(lst: [Int]) -> Bool {
    guard !lst.isEmpty else { return true }

    var previous = lst[0]
    var duplicates = 0

    for i in 1..<lst.count {
        if lst[i] < previous {
            return false
        } else if lst[i] == previous {
            duplicates += 1
            if duplicates > 1 {
                return false
            }
        } else {
            duplicates = 0
        }
        previous = lst[i]
    }

    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_sorted(lst: [5]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)
assert(is_sorted(lst: [] as [Int]) == true)
assert(is_sorted(lst: [1]) == true)
assert(is_sorted(lst: [3, 2, 1]) == false)
assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)
assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
HumanEval_127,hau_Latn,swift,"
// [shigarwa / fitarwa] samfurori: // Idan biyu tazara ba intersect, dawo ""NO"". // in ba haka ba, dawo da ""NO"". // Idan tsawon da intersection ne mai firamare lamba, dawo ""YES"", // wanda tsawonsa ya kai 1, wanda ba shi ne lamba ta farko ba. // Misali, da intersection na tazara (1, 3), (2, 4) ne (2, 3) // tazara ne mai farko lamba. // Aikinku shine sanin ko tsawon tsinkayar wadannan biyu // Ga kowane lokaci da aka ba, an ɗauka cewa farkonsa ya fi ƙasa ko daidai da ƙarshen. // ya hada da farawa da ƙarshe. // An ba da tazara a rufe wanda ke nufin cewa tazara (farawa, ƙare) // inda kowane lokaci ne biyu na integers. Alal misali, lokaci = (fara, karshen) = (1, 2). // An ba ku tazara biyu, /// >>> intersection(interval1: (1, 2), interval2: (2, 3))
/// ""NO""
/// >>> intersection(interval1: (-1, 1), interval2: (0, 4))
/// ""NO""
/// >>> intersection(interval1: (-3, -1), interval2: (-5, 5))
/// ""YES""
func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
","func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
    // Helper function to determine if a number is prime
    func isPrime(_ num: Int) -> Bool {
        if num <= 1 {
            return false
        }
        if num <= 3 {
            return true
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false
        }
        var i = 5
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Find the start and end of the intersection
    let intersectStart = max(interval1.0, interval2.0)
    let intersectEnd = min(interval1.1, interval2.1)
    
    // Calculate the length of the intersection
    let intersectionLength = intersectEnd - intersectStart

    // Check if intersection length is positive and prime
    if intersectionLength > 0 && isPrime(intersectionLength) {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersection(interval1: (1, 2), interval2: (2, 3)) == ""NO"")
assert(intersection(interval1: (-1, 1), interval2: (0, 4)) == ""NO"")
assert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == ""YES"")
assert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == ""YES"")
assert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (3, 5)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (1, 2)) == ""NO"")
assert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == ""NO"")"
HumanEval_128,hau_Latn,swift,"
// Misali: // Lura: dawo da nil don komai arr. // na kowane lamba a cikin tsararru, wakilta ta 1, -1 ko 0. // jimlar girman lambobi masu yawa da aka ninka da samfurin dukkan alamu // An ba ku array na integers kuma kuna buƙatar dawowa /// >>> prod_signs(arr: [1, 2, 2, -4])
/// 9
/// >>> prod_signs(arr: [0, 1])
/// 0
/// >>> prod_signs(arr: [] as [Int])
/// nil
func prod_signs(arr: [Int]) -> Int? {
","func prod_signs(arr: [Int]) -> Int? {
    // Return nil for empty array
    if arr.isEmpty {
        return nil
    }

    // Calculate the sum of magnitudes
    let sumOfMagnitudes = arr.reduce(0) { sum, num in
        return sum + abs(num)
    }

    // Calculate the product of all signs
    let productOfSigns = arr.reduce(1) { product, num in
        if num > 0 {
            return product * 1
        } else if num < 0 {
            return product * -1
        } else {
            return 0
        }
    }

    // Return the result of sum of magnitudes multiplied by product of signs
    return sumOfMagnitudes * productOfSigns
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prod_signs(arr: [1, 2, 2, -4]) == -9)
assert(prod_signs(arr: [0, 1]) == 0)
assert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)
assert(prod_signs(arr: [] as [Int]) == nil)
assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)
assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)
assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)
assert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
HumanEval_129,hau_Latn,swift,"
// Misalai: // Koma wani tsari array na dabi'u a kan Kwayoyin cewa m hanya tafi, ta hanyar. // An tabbatar da cewa amsar ita ce ta musamman. // lst_A[j] = lst_B[j].  Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙungiyar Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ Ƙ// irin wannan lst_A[i] < lst_B[i] kuma ga kowane j (1 <= j < i) muna da // fiye da lst_B, a wasu kalmomi, akwai akwai wani lamba index i (1 <= i <= k) // ta hanyar (bari mu kira su lst_A da lst_B), lst_A yana da ƙarancin lexicographically // bayan yin tsari arrays na dabi'u a kan Kwayoyin cewa A da B tafi // Hanya A (na tsawon k) ana ɗaukarsa ƙasa da hanya B (na tsawon k) idan // Ba za ku iya fita daga cikin grid ba. // dole ne ya bambanta). // Lura cewa hanyar tsawon k yana nufin ziyartar daidai da sel k (ba // tantanin halitta. // a wasu kalmomi, za ka iya zuwa Kwayoyin da raba wani gefen tare da ku halin yanzu // daga kowane cell, kuma a kowane mataki za ka iya matsawa zuwa wani daga cikin makwabta Kwayoyin, // Dole ne ku sami mafi ƙarancin hanya na tsawon k a cikin grid. Za ku iya farawa // m ya bayyana daidai sau ɗaya a kan sel na grid. // kowane cell na grid yana dauke da darajar. Kowane lamba a cikin kewayon [1, N * N] // An ba da grid tare da layuka N da ginshiƙai N (N > = 2) da kuma cikakkiyar lamba k, /// >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)
/// [1, 2, 1]
/// >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)
/// [1]
func minPath(grid: [[Int]], k: Int) -> [Int] {
","func minPath(grid: [[Int]], k: Int) -> [Int] {
    let n = grid.count
    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    struct Path: Comparable {
        let cells: [Int]
        
        static func < (lhs: Path, rhs: Path) -> Bool {
            return lhs.cells.lexicographicallyPrecedes(rhs.cells)
        }
    }
    
    var minPath: Path? = nil
    
    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {
        var currentPath = currentPath
        currentPath.append(grid[x][y])
        
        if currentPath.count == k {
            let newPath = Path(cells: currentPath)
            if minPath == nil || newPath < minPath! {
                minPath = newPath
            }
            return
        }
        
        for direction in directions {
            let newX = x + direction.0
            let newY = y + direction.1
            if newX >= 0 && newX < n && newY >= 0 && newY < n {
                dfs(x: newX, y: newY, k: k, currentPath: currentPath)
            }
        }
    }
    
    for i in 0..<n {
        for j in 0..<n {
            dfs(x: i, y: j, k: k, currentPath: [])
        }
    }
    
    return minPath!.cells
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])
assert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])
assert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])
assert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])
assert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])
assert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])
assert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])
assert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])
assert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])
assert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])
assert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"
HumanEval_130,hau_Latn,swift,"
// Misalai: // na farko n + 1 lambobi na jerin Tribonacci. // An ba ku lamba mai lamba n, dole ne ku dawo da wani tsari na // = 2 + 3 + 3 = 8 // uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku uku// tri(4) = 3 // tri(2) = 1 + (2 / 2) = 2 // Misali: // tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), idan n ba shi da kyau. // tri ((n) = 1 + n / 2, idan n yana da ma'ana. // tri(1) = 3 // An bayyana jerin Tribonacci ta hanyar maimaitawa: Duk da haka, abin da mutane ba su sani ba ne jerin Tribonacci.// Kowa ya san jerin Fibonacci, an yi nazari sosai da masana lissafi a cikin /// >>> tri(n: 3)
/// [1, 3, 2, 8]
func tri(n: Int) -> [Int] {
","func tri(n: Int) -> [Int] {
    guard n >= 0 else { return [] }
    if n == 0 { return [1] }
    if n == 1 { return [1, 3] }
    if n == 2 { return [1, 3, 2] }
    
    var sequence = [1, 3, 2]
    
    for i in 3...n {
        if i % 2 == 0 {
            sequence.append(1 + i / 2)
        } else {
            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]
            sequence.append(nextVal)
        }
    }
    
    return sequence
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(tri(n: 3) == [1, 3, 2, 8])
assert(tri(n: 4) == [1, 3, 2, 8, 3])
assert(tri(n: 5) == [1, 3, 2, 8, 3, 15])
assert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])
assert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])
assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])
assert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])
assert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])
assert(tri(n: 0) == [1])
assert(tri(n: 1) == [1, 3])"
HumanEval_131,hau_Latn,swift,"
// Misali: // Koma 0 idan duk lambobi ne ma. // Ganin wani m lamba n, dawo da samfurin na m lambobi. /// >>> digits(n: 1)
/// 1
/// >>> digits(n: 4)
/// 0
/// >>> digits(n: 235)
/// 15
func digits(n: Int) -> Int {
","func digits(n: Int) -> Int {
    var num = n
    var product = 1
    var hasOdd = false
    
    while num > 0 {
        let digit = num % 10
        if digit % 2 != 0 {
            hasOdd = true
            product *= digit
        }
        num /= 10
    }
    
    return hasOdd ? product : 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digits(n: 5) == 5)
assert(digits(n: 54) == 5)
assert(digits(n: 120) == 1)
assert(digits(n: 5014) == 5)
assert(digits(n: 98765) == 315)
assert(digits(n: 5576543) == 2625)
assert(digits(n: 2468) == 0)"
HumanEval_132,hau_Latn,swift,"
// inda aƙalla bracket ɗaya a cikin ƙaramin tsari yana da ƙuƙwalwa. // A aiki ya kamata dawo gaskiya idan kuma kawai idan akwai wani inganci subsequence na brackets // Create a aiki daukan wani kirtani a matsayin shigar da cewa yana dauke da kawai square baka. /// >>> is_nested(string: ""[[]]"")
/// true
/// >>> is_nested(string: ""[]]]]]]][[[[[]"")
/// false
/// >>> is_nested(string: ""[][]"")
/// false
/// >>> is_nested(string: ""[]"")
/// false
/// >>> is_nested(string: ""[[][]]"")
/// true
/// >>> is_nested(string: ""[[]][["")
/// true
func is_nested(string: String) -> Bool {
","func is_nested(string: String) -> Bool {
    var stack: [Character] = []
    var nested = false

    for bracket in string {
        if bracket == ""["" {
            stack.append(bracket)
        } else if bracket == ""]"" {
            if let last = stack.last, last == ""["" {
                stack.removeLast()
                if !stack.isEmpty {
                    nested = true
                }
            } else {
                return false
            }
        }
    }
    return nested
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_nested(string: ""[[]]"") == true)
assert(is_nested(string: ""[]]]]]]][[[[[]"") == false)
assert(is_nested(string: ""[][]"") == false)
assert(is_nested(string: ""[]"") == false)
assert(is_nested(string: ""[[[[]]]]"") == true)
assert(is_nested(string: ""[]]]]]]]]]]"") == false)
assert(is_nested(string: ""[][][[]]"") == true)
assert(is_nested(string: ""[[]"") == false)
assert(is_nested(string: ""[]]"") == false)
assert(is_nested(string: ""[[]][["") == true)
assert(is_nested(string: ""[[][]]"") == true)
assert(is_nested(string: """") == false)
assert(is_nested(string: ""[[[[[[[["") == false)
assert(is_nested(string: ""]]]]]]]]"") == false)"
HumanEval_133,hau_Latn,swift,"
// Misalai: // zagaye kowane kashi a cikin tsararru zuwa saman int ((Ceiling) na farko. // Kana bukatar ka dawo da jimlar squared lambobi a cikin ba tsararru, // An ba ku jerin lambobi. /// >>> sum_squares(lst: [1.0, 2.0, 3.0])
/// 14
/// >>> sum_squares(lst: [1.0, 4.0, 9.0])
/// 98
/// >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> sum_squares(lst: [1.4, 4.2, 0.0])
/// 29
/// >>> sum_squares(lst: [-2.4, 1.0, 1.0])
/// 6
func sum_squares(lst: [Double]) -> Int {
","func sum_squares(lst: [Double]) -> Int {
    return lst.map { ceil($0) } // Round each element to the upper int (Ceiling)
              .map { Int($0 * $0) } // Square each element
              .reduce(0, +) // Sum all squared elements
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)
assert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)
assert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)
assert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)
assert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)
assert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)
assert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)
assert(sum_squares(lst: [0.0]) == 0)
assert(sum_squares(lst: [-1.0]) == 1)
assert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"
HumanEval_134,hau_Latn,swift,"
// Misalai: // Lura: ""kalma"" rukuni ne na haruffa da aka raba ta sarari. // wani ɓangare na kalma, kuma ƙarya in ba haka ba. // na wani da aka ba kirtani ne haruffa haruffa da kuma ba // Ƙirƙiri wani aiki wanda ya dawo gaskiya idan haruffa na ƙarshe /// >>> check_if_last_char_is_a_letter(txt: ""apple pie"")
/// false
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e"")
/// true
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e "")
/// false
/// >>> check_if_last_char_is_a_letter(txt: """")
/// false
func check_if_last_char_is_a_letter(txt: String) -> Bool {
","func check_if_last_char_is_a_letter(txt: String) -> Bool {
    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {
        return false
    }
    
    if lastChar.isLetter {
        let words = txt.split(separator: "" "")
        if let lastWord = words.last {
            return lastWord.count == 1
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(check_if_last_char_is_a_letter(txt: ""apple"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e"") == true)
assert(check_if_last_char_is_a_letter(txt: ""eeeee"") == false)
assert(check_if_last_char_is_a_letter(txt: ""A"") == true)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie "") == false)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie 1"") == false)
assert(check_if_last_char_is_a_letter(txt: """") == false)
assert(check_if_last_char_is_a_letter(txt: ""eeeee e "") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pie"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e "") == false)"
HumanEval_135,hau_Latn,swift,"
// Misalai: // ninka dabi'u. // babu irin wannan abu ya wanzu to dawo -1. da aka ba saitin ba zai dauke da // ba ya fi ko daidai da kashi na gaba da shi. Idan // Create a aiki wanda ya dawo da mafi girma index na wani kashi wanda /// >>> can_arrange(arr: [1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(arr: [1, 2, 3])
/// -1
func can_arrange(arr: [Int]) -> Int {
","func can_arrange(arr: [Int]) -> Int {
    for i in (1..<arr.count).reversed() {
        if arr[i] < arr[i - 1] {
            return i
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)
assert(can_arrange(arr: [1, 2, 4, 5]) == -1)
assert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)
assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)
assert(can_arrange(arr: [] as [Int]) == -1)"
HumanEval_136,hau_Latn,swift,"
// Misalai: // Idan babu wani mummunan ko tabbatacce integers, dawo da su a matsayin nil. // na lambobi masu kyau a cikin wani tsari. // mafi girma daga cikin mummunan integers, da kuma 'b' ne karami // Create a aiki da ya dawo da wani tuple (a, b), inda 'a' ne /// >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])
/// (nil, 1)
/// >>> largest_smallest_integers(lst: [] as [Int])
/// (nil, nil)
/// >>> largest_smallest_integers(lst: [0])
/// (nil, nil)
func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
","func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
    var largestNegative: Int? = nil
    var smallestPositive: Int? = nil

    for number in lst {
        if number < 0 {
            if largestNegative == nil || number > largestNegative! {
                largestNegative = number
            }
        } else if number > 0 {
            if smallestPositive == nil || number < smallestPositive! {
                smallestPositive = number
            }
        }
    }

    return (largestNegative, smallestPositive)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))
assert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))
assert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))
assert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))
assert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))
assert(largest_smallest_integers(lst: [0]) == (nil, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"
HumanEval_137,hau_Latn,swift,"
enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
// Lura: Idan an wakilci lamba ta ainihi a matsayin kirtani, maɓallin kewayawa zai iya zama . ko , // Koma nil idan dabi'u sun daidaita. // real lambobi, da kuma dawo da ya fi girma m a cikin da aka ba m irin. // Create a aiki daukan integers, floats, ko kirtani wakiltar /// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue(""2,3""))
/// .stringValue(""2,3"")
/// >>> compare_one(a: .stringValue(""5,1""), b: .stringValue(""6""))
/// .stringValue(""6"")
/// >>> compare_one(a: .stringValue(""1""), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
","func compare_one(a: Value, b: Value) -> Value? {
    func convertToDouble(value: Value) -> Double? {
        switch value {
        case .intValue(let int):
            return Double(int)
        case .doubleValue(let double):
            return double
        case .stringValue(let string):
            let formatter = NumberFormatter()
            formatter.locale = Locale(identifier: ""en_US_POSIX"")
            if string.contains("","") {
                formatter.decimalSeparator = "",""
            } else {
                formatter.decimalSeparator = "".""
            }
            return formatter.number(from: string)?.doubleValue
        }
    }
    
    let aDouble = convertToDouble(value: a)
    let bDouble = convertToDouble(value: b)
    
    if let aDouble = aDouble, let bDouble = bDouble {
        if aDouble > bDouble {
            return a
        } else if bDouble > aDouble {
            return b
        }
    }
    
    return nil
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue(""2,3"")) == .stringValue(""2,3""))
assert(compare_one(a: .stringValue(""5,1""), b: .stringValue(""6"")) == .stringValue(""6""))
assert(compare_one(a: .stringValue(""1""), b: .stringValue(""2"")) == .stringValue(""2""))
assert(compare_one(a: .stringValue(""1""), b: .intValue(1)) == nil)"
HumanEval_138,hau_Latn,swift,"
// Misali // Yi la'akari da ko lambar da aka ba n za a iya rubuta shi azaman adadin daidai lambobi 4 masu kyau daidai /// >>> is_equal_to_sum_even(n: 4)
/// false
/// >>> is_equal_to_sum_even(n: 6)
/// false
/// >>> is_equal_to_sum_even(n: 8)
/// true
func is_equal_to_sum_even(n: Int) -> Bool {
","func is_equal_to_sum_even(n: Int) -> Bool {
    if n <= 8 {
        return false
    }
    return n % 2 == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_equal_to_sum_even(n: 4) == false)
assert(is_equal_to_sum_even(n: 6) == false)
assert(is_equal_to_sum_even(n: 8) == true)
assert(is_equal_to_sum_even(n: 10) == true)
assert(is_equal_to_sum_even(n: 11) == false)
assert(is_equal_to_sum_even(n: 12) == true)
assert(is_equal_to_sum_even(n: 13) == false)
assert(is_equal_to_sum_even(n: 16) == true)"
HumanEval_139,hau_Latn,swift,"
// Misali: // inda n > 0 // brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! // An bayyana ma'anar Brazil a matsayin: /// >>> special_factorial(n: 4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
func special_factorial(n: Int) -> Int {
","func factorial(_ n: Int) -> Int {
    return n <= 1 ? 1 : n * factorial(n - 1)
}

func special_factorial(n: Int) -> Int {
    var result = 1
    for i in 1...n {
        result *= factorial(i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(special_factorial(n: 4) == 288)
assert(special_factorial(n: 5) == 34560)
assert(special_factorial(n: 7) == 125411328000)
assert(special_factorial(n: 1) == 1)"
HumanEval_140,hau_Latn,swift,"
// sannan maye gurbin dukkan sararin samaniya tare da - // kuma idan wani kirtani yana da fiye da 2 jere sarari, // Ba da wani rubutu kirtani, maye gurbin duk sarari a cikin shi da underscores, /// >>> fix_spaces(text: "" Example"")
/// ""Example""
/// >>> fix_spaces(text: "" Example 1"")
/// ""Example_1""
/// >>> fix_spaces(text: "" Example 2"")
/// ""_Example_2""
/// >>> fix_spaces(text: "" Example 3"")
/// ""_Example-3""
func fix_spaces(text: String) -> String {
","func fix_spaces(text: String) -> String {
    var result = """"
    var spaceCount = 0
    
    for character in text {
        if character == "" "" {
            spaceCount += 1
        } else {
            if spaceCount == 1 {
                result.append(""_"")
            } else if spaceCount > 1 {
                result.append(""-"")
            }
            result.append(character)
            spaceCount = 0
        }
    }
    
    if spaceCount == 1 {
        result.append(""_"")
    } else if spaceCount > 1 {
        result.append(""-"")
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: ""Example"") == ""Example"")
assert(fix_spaces(text: ""Mudasir Hanif "") == ""Mudasir_Hanif_"")
assert(fix_spaces(text: ""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"")
assert(fix_spaces(text: ""Exa   mple"") == ""Exa-mple"")
assert(fix_spaces(text: ""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"")"
HumanEval_141,hau_Latn,swift,"
// Misalai: // - The substring bayan da dot ya zama daya daga cikin wadannan: ['txt', 'exe', 'dll'] // Latin haruffa ('a'-'z' da 'A'-'Z'). // - The substring kafin dot kamata ba zama fanko, kuma shi yana farawa da wata wasika daga // - Sunan fayil ɗin ya ƙunshi daidai da dot '.' // - Bai kamata a sami lambobi fiye da uku ba ('0'-'9') a cikin sunan fayil ɗin. // an sadu da: // An dauke sunan fayil din inganci ne idan kuma kawai idan duk yanayin da ke gaba // 'Ee' idan sunan fayil ɗin yana da inganci, kuma ya dawo 'A'a' in ba haka ba. // Create a aiki wanda daukan wani kirtani wakiltar fayil ta sunan, da kuma dawo da /// >>> file_name_check(file_name: ""example.txt"")
/// ""Yes""
/// >>> file_name_check(file_name: ""1example.dll"")
/// ""No""
func file_name_check(file_name: String) -> String {
","func file_name_check(file_name: String) -> String {
    // Split by the dot.
    let components = file_name.split(separator: ""."", omittingEmptySubsequences: false)
    
    // Check if there's exactly one dot.
    guard components.count == 2 else {
        return ""No""
    }
    
    // Extract the prefix and suffix.
    let prefix = String(components[0])
    let suffix = String(components[1])
    
    // Check if the prefix is non-empty and starts with a letter.
    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {
        return ""No""
    }
    
    // Check if the suffix is one of the allowed types.
    let validSuffixes = [""txt"", ""exe"", ""dll""]
    guard validSuffixes.contains(suffix) else {
        return ""No""
    }
    
    // Count digits in the file name.
    let digitCount = file_name.filter { $0.isNumber }.count
    
    // Ensure that there are not more than 3 digits.
    guard digitCount <= 3 else {
        return ""No""
    }
    
    // If all checks pass, it's a valid file name.
    return ""Yes""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(file_name_check(file_name: ""example.txt"") == ""Yes"")
assert(file_name_check(file_name: ""1example.dll"") == ""No"")
assert(file_name_check(file_name: ""s1sdf3.asd"") == ""No"")
assert(file_name_check(file_name: ""K.dll"") == ""Yes"")
assert(file_name_check(file_name: ""MY16FILE3.exe"") == ""Yes"")
assert(file_name_check(file_name: ""His12FILE94.exe"") == ""No"")
assert(file_name_check(file_name: ""_Y.txt"") == ""No"")
assert(file_name_check(file_name: ""?aREYA.exe"") == ""No"")
assert(file_name_check(file_name: ""/this_is_valid.dll"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.wow"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.txt"") == ""Yes"")
assert(file_name_check(file_name: ""this_is_valid.txtexe"") == ""No"")
assert(file_name_check(file_name: ""#this2_i4s_5valid.ten"") == ""No"")
assert(file_name_check(file_name: ""@this1_is6_valid.exe"") == ""No"")
assert(file_name_check(file_name: ""this_is_12valid.6exe4.txt"") == ""No"")
assert(file_name_check(file_name: ""all.exe.txt"") == ""No"")
assert(file_name_check(file_name: ""I563_No.exe"") == ""Yes"")
assert(file_name_check(file_name: ""Is3youfault.txt"") == ""Yes"")
assert(file_name_check(file_name: ""no_one#knows.dll"") == ""Yes"")
assert(file_name_check(file_name: ""1I563_Yes3.exe"") == ""No"")
assert(file_name_check(file_name: ""I563_Yes3.txtt"") == ""No"")
assert(file_name_check(file_name: ""final..txt"") == ""No"")
assert(file_name_check(file_name: ""final132"") == ""No"")
assert(file_name_check(file_name: ""_f4indsartal132."") == ""No"")
assert(file_name_check(file_name: "".txt"") == ""No"")
assert(file_name_check(file_name: ""s."") == ""No"")"
HumanEval_143,hau_Latn,swift,"
// Misali na 1: // tsari na kalmomin a cikin sabon kirtani ya zama daidai da na asali. // wanda tsawonsa lambobi ne na farko, // kuma dole ka dawo da wani kirtani da ya ƙunshi kalmomin daga asali jumla, // jimlar ta ƙunshi wasu kalmomi da aka raba ta sarari, // An ba ku kirtani wanda ke wakiltar jumla, /// >>> words_in_sentence(sentence: ""This is a test"")
/// ""is""
/// Example 2:
/// >>> words_in_sentence(sentence: ""lets go for swimming"")
/// ""go for""
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
func words_in_sentence(sentence: String) -> String {
","func words_in_sentence(sentence: String) -> String {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    let words = sentence.split(separator: "" "")
    let primeLengthWords = words.filter { isPrime($0.count) }
    return primeLengthWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_in_sentence(sentence: ""This is a test"") == ""is"")
assert(words_in_sentence(sentence: ""lets go for swimming"") == ""go for"")
assert(words_in_sentence(sentence: ""there is no place available here"") == ""there is no place"")
assert(words_in_sentence(sentence: ""Hi I am Hussein"") == ""Hi am Hussein"")
assert(words_in_sentence(sentence: ""go for it"") == ""go for it"")
assert(words_in_sentence(sentence: ""here"") == """")
assert(words_in_sentence(sentence: ""here is"") == ""is"")"
HumanEval_144,hau_Latn,swift,"
// Za ka iya ɗauka cewa x, da kuma n ne inganci fractions, kuma ba su da sifili a matsayin mai kiran. // <numerator>/<denominator> inda duka mai lamba da mai suna suna lambobi masu kyau. Dukansu x da n, suna wakiltar layi na kashi, kuma suna da tsari mai zuwa, // x * n. Aikin ya dawo gaskiya idan x * n kimantawa zuwa wani lamba da kuma ƙarya // Aikinku shine aiwatar da aikin da zai sauƙaƙa bayanin /// >>> simplify(x: ""1/5"", n: ""5/1"")
/// true
/// >>> simplify(x: ""1/6"", n: ""2/1"")
/// false
/// >>> simplify(x: ""7/10"", n: ""10/2"")
/// false
func simplify(x: String, n: String) -> Bool {
","func simplify(x: String, n: String) -> Bool {
    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {
        let parts = fraction.split(separator: ""/"").map { Int($0)! }
        return (numerator: parts[0], denominator: parts[1])
    }
    
    let (xNumerator, xDenominator) = parseFraction(fraction: x)
    let (nNumerator, nDenominator) = parseFraction(fraction: n)
    
    // Multiply the two fractions: (xNumerator * nNumerator) / (xDenominator * nDenominator)
    let resultNumerator = xNumerator * nNumerator
    let resultDenominator = xDenominator * nDenominator
    
    // Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator
    return resultNumerator % resultDenominator == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/6"", n: ""2/1"") == false)
assert(simplify(x: ""5/1"", n: ""3/1"") == true)
assert(simplify(x: ""7/10"", n: ""10/2"") == false)
assert(simplify(x: ""2/10"", n: ""50/10"") == true)
assert(simplify(x: ""7/2"", n: ""4/2"") == true)
assert(simplify(x: ""11/6"", n: ""6/1"") == true)
assert(simplify(x: ""2/3"", n: ""5/2"") == false)
assert(simplify(x: ""5/2"", n: ""3/5"") == false)
assert(simplify(x: ""2/4"", n: ""8/4"") == true)
assert(simplify(x: ""2/4"", n: ""4/2"") == true)
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/5"", n: ""1/5"") == false)"
HumanEval_145,hau_Latn,swift,"
// Misali: // tsara su bisa ga index a cikin asali tsararru. // Lura: idan akwai abubuwa da yawa tare da irin wannan adadin lambobi, // a cikin tsari mai tasowa bisa ga adadin lambobi. // Rubuta wani aiki wanda ya tsara jerin lambobi na lambobi /// >>> order_by_points(nums: [1, 11, -1, -11, -12])
/// [-1, -11, 1, -12, 11]
/// >>> order_by_points(nums: [] as [Int])
/// [] as [Int]
func order_by_points(nums: [Int]) -> [Int] {
","func order_by_points(nums: [Int]) -> [Int] {
    return nums.enumerated().sorted {
        let sum1 = digitSum($0.element)
        let sum2 = digitSum($1.element)
        if sum1 == sum2 {
            return $0.offset < $1.offset
        } else {
            return sum1 < sum2
        }
    }.map { $0.element }
}

func digitSum(_ number: Int) -> Int {
    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])
assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])
assert(order_by_points(nums: [] as [Int]) == [] as [Int])
assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])
assert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])
assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
HumanEval_146,hau_Latn,swift,"
// Misali: // na farko da na karshe lambobi na lamba ne m (1, 3, 5, 7, 9). // yawan abubuwa a cikin tsararru da suke da girma fiye da 10 da kuma duka // Rubuta wani aiki daukan wani tsararru na lambobi kamar yadda shigar da dawowa /// >>> specialFilter(nums: [15, -73, 14, -15])
/// 1
/// >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])
/// 2
func specialFilter(nums: [Int]) -> Int {
","func specialFilter(nums: [Int]) -> Int {
    return nums.filter { num in
        let absNum = abs(num)
        
        guard absNum > 10 else {
            return false
        }
        
        let firstDigit = String(String(absNum).first!)
        let lastDigit = String(absNum % 10)
        
        let oddDigits: Set = [""1"", ""3"", ""5"", ""7"", ""9""]
        
        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(specialFilter(nums: [5, -2, 1, -5]) == 0)
assert(specialFilter(nums: [15, -73, 14, -15]) == 1)
assert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)
assert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)
assert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)
assert(specialFilter(nums: [1]) == 0)
assert(specialFilter(nums: [] as [Int]) == 0)"
HumanEval_147,hau_Latn,swift,"
// Misali: // kuma a[i] + a[j] + a[k] ya ninka na 3. // Koma yawan sau uku (a[i], a[j], a[k]) na a inda i < j < k, // Ga kowane i (1 ≤ i ≤ n), ƙimar a[i] = i * i - i + 1. // An ba ku lamba mai kyau n. Dole ne ku ƙirƙiri jerin lambobi na tsawon n. /// >>> get_max_triples(n: 5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
func get_max_triples(n: Int) -> Int {
","func get_max_triples(n: Int) -> Int {
    // Create the array a based on the problem description
    var a = [Int](repeating: 0, count: n)
    for i in 1...n {
        a[i - 1] = i * i - i + 1
    }
    
    var count = 0
    // Check for all possible triples
    for i in 0..<n {
        for j in (i + 1)..<n {
            for k in (j + 1)..<n {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count += 1
                }
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_max_triples(n: 5) == 1)
assert(get_max_triples(n: 6) == 4)
assert(get_max_triples(n: 10) == 36)
assert(get_max_triples(n: 100) == 53361)"
HumanEval_149,hau_Latn,swift,"
// Misali: // Kuna iya ɗauka cewa duk kalmomin zasu sami tsawon daidai. // Aikin ya kamata ya dawo da jerin jeri a cikin tsari. // Idan kalmomi biyu suna da tsawon lokaci, tsara jerin a cikin haruffa. // Ya kamata ya dawo da jerin da aka tsara ta wannan doka. // Tsarin tsari ya kamata ya hau ta tsawon kowace kalma, kuma ku // kuma yana iya ƙunsar duplicates. // Tsarin tsari ne na harsashi kuma ba jerin lambobi ba, // kuma ya dawo da sakamakon array tare da tsari mai tsari, // share da kirtani da cewa suna da m tsawo daga gare ta, // Rubuta wani aiki da ya yarda da wani tsararru na kirtani a matsayin siga, /// >>> sorted_list_sum(lst: [""aa"", ""a"", ""aaa""])
/// [""aa""]
/// >>> sorted_list_sum(lst: [""ab"", ""a"", ""aaa"", ""cd""])
/// [""ab"", ""cd""]
func sorted_list_sum(lst: [String]) -> [String] {
","func sorted_list_sum(lst: [String]) -> [String] {
    return lst.filter { $0.count % 2 == 0 }
              .sorted { 
                  if $0.count == $1.count {
                      return $0 < $1
                  }
                  return $0.count < $1.count
              }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sorted_list_sum(lst: [""aa"", ""a"", ""aaa""]) == [""aa""])
assert(sorted_list_sum(lst: [""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""])
assert(sorted_list_sum(lst: [""d"", ""b"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""])
assert(sorted_list_sum(lst: [""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""])
assert(sorted_list_sum(lst: [""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""aaaa"", ""bbbb"", ""dd"", ""cc""]) == [""cc"", ""dd"", ""aaaa"", ""bbbb""])"
HumanEval_150,hau_Latn,swift,"
// Misalai: // wani firamare da kuma ya kamata dawo da darajar y in ba haka ba. // A sauki shirin wanda ya kamata dawo da darajar x idan n ne /// >>> x_or_y(n: 7, x: 34, y: 12)
/// 34
/// >>> x_or_y(n: 15, x: 8, y: 5)
/// 5
func x_or_y(n: Int, x: Int, y: Int) -> Int {
","func x_or_y(n: Int, x: Int, y: Int) -> Int {
    func isPrime(_ number: Int) -> Bool {
        if number <= 1 { return false }
        if number <= 3 { return true }
        if number % 2 == 0 || number % 3 == 0 { return false }
        
        var i = 5
        while i * i <= number {
            if number % i == 0 || number % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    return isPrime(n) ? x : y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(x_or_y(n: 7, x: 34, y: 12) == 34)
assert(x_or_y(n: 15, x: 8, y: 5) == 5)
assert(x_or_y(n: 3, x: 33, y: 5212) == 33)
assert(x_or_y(n: 1259, x: 3, y: 52) == 3)
assert(x_or_y(n: 7919, x: -1, y: 12) == -1)
assert(x_or_y(n: 3609, x: 1245, y: 583) == 583)
assert(x_or_y(n: 91, x: 56, y: 129) == 129)
assert(x_or_y(n: 6, x: 34, y: 1234) == 1234)
assert(x_or_y(n: 1, x: 2, y: 0) == 0)
assert(x_or_y(n: 2, x: 2, y: 0) == 2)"
HumanEval_151,hau_Latn,swift,"
// a cikin tsararren da suke m. Ka yi watsi da lambobin da suke da mummunan ko ba integers. // An ba da jerin lambobi, dawo da adadin murabba'in lambobi /// >>> double_the_difference(lst: [1, 3, 2, 0])
/// 10
/// >>> double_the_difference(lst: [-1, -2, 0])
/// 0
/// >>> double_the_difference(lst: [9, -2])
/// 81
/// >>> double_the_difference(lst: [0])
/// 0
/// If the input array is empty, return 0.
func double_the_difference(lst: [Double]) -> Int {
","func double_the_difference(lst: [Double]) -> Int {
    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }
              .map { Int($0) * Int($0) }
              .reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(double_the_difference(lst: [] as [Double]) == 0)
assert(double_the_difference(lst: [5.0, 4.0]) == 25)
assert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)
assert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)
assert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)
assert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)
assert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"
HumanEval_152,hau_Latn,swift,"
// misali: // darajar ita ce 0, kuma idan ba haka ba, darajar ita ce ainihin bambanci tsakanin zato da ci. // Koma array na wannan tsawon nuna yadda nisa daga kowane tsammani ya. Idan sun tsammani daidai, // An ba ku matakai biyu na ƙididdiga da ƙididdiga na tsawon lokaci, inda kowane alamar ya nuna wasa. // Aikinku shine sanin idan mutum ya yi daidai da sakamakon wasannin da yawa. // Tabbas ya cancanci a lura da shi kuma a kwatanta shi. A ƙarshe an san abin da ke faruwa.// Ina ganin dukkanmu mun tuna da wannan jin dadi lokacin da sakamakon wani dogon-awaited /// >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])
/// [0, 0, 0, 0, 3, 3]
/// >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])
/// [4, 4, 1, 0, 0, 6]
func compare(game: [Int], guess: [Int]) -> [Int] {
","func compare(game: [Int], guess: [Int]) -> [Int] {
    var result: [Int] = []
    
    for i in 0..<game.count {
        let difference = abs(game[i] - guess[i])
        result.append(difference)
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])
assert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])
assert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])
assert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"
HumanEval_153,hau_Latn,swift,"
// Misali: // (ƙarfinsa shine -1). // dawo 'Slices.SERVINGSliCes' tun 'SERVINGSliCes' ne mafi karfi tsawo // kari: ['SERVINGSliCes', 'Cheese', 'StuFfed'] to ya kamata ka // Alal misali, idan ka ba ""Slices"" kamar yadda aji da kuma wani tsararru na // zabi wanda ya zo na farko a cikin tsararru. // Idan akwai biyu ko fiye da tsawo da wannan ƙarfi, ya kamata ka // Tsarin: ClassName.StrongestExtensionName. // Ya kamata ka sami mafi karfi tsawo da kuma dawo da wani kirtani a cikin wannan // a cikin sunan tsawo, an ba da ƙarfin ta hanyar kashi CAP - SM. // haruffa a cikin sunan tsawo, kuma bari SM ya zama adadin ƙananan haruffa // ƙarfin tsawo kamar haka: Bari CAP ya zama lambar babban harafi // The kari ne da za a yi amfani da su load ƙarin azuzuwan da aji.// Za a ba ku sunan aji (wani kirtani) da kuma jerin kari. /// >>> Strongest_Extension(class_name: ""my_class"", extensions: [""AA"", ""Be"", ""CC""])
/// ""my_class.AA""
func Strongest_Extension(class_name: String, extensions: [String]) -> String {
","func Strongest_Extension(class_name: String, extensions: [String]) -> String {
    var strongestExtension: String? = nil
    var maxStrength = Int.min
    
    for ext in extensions {
        let cap = ext.filter { $0.isUppercase }.count
        let sm = ext.filter { $0.isLowercase }.count
        let strength = cap - sm
        
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = ext
        }
    }
    
    if let strongestExt = strongestExtension {
        return ""\(class_name).\(strongestExt)""
    }
    
    return class_name
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(Strongest_Extension(class_name: ""Watashi"", extensions: [""tEN"", ""niNE"", ""eIGHt8OKe""]) == ""Watashi.eIGHt8OKe"")
assert(Strongest_Extension(class_name: ""Boku123"", extensions: [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]) == ""Boku123.YEs.WeCaNe"")
assert(Strongest_Extension(class_name: ""__YESIMHERE"", extensions: [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]) == ""__YESIMHERE.NuLl__"")
assert(Strongest_Extension(class_name: ""K"", extensions: [""Ta"", ""TAR"", ""t234An"", ""cosSo""]) == ""K.TAR"")
assert(Strongest_Extension(class_name: ""__HAHA"", extensions: [""Tab"", ""123"", ""781345"", ""-_-""]) == ""__HAHA.123"")
assert(Strongest_Extension(class_name: ""YameRore"", extensions: [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]) == ""YameRore.okIWILL123"")
assert(Strongest_Extension(class_name: ""finNNalLLly"", extensions: [""Die"", ""NowW"", ""Wow"", ""WoW""]) == ""finNNalLLly.WoW"")
assert(Strongest_Extension(class_name: ""_"", extensions: [""Bb"", ""91245""]) == ""_.Bb"")
assert(Strongest_Extension(class_name: ""Sp"", extensions: [""671235"", ""Bb""]) == ""Sp.671235"")"
HumanEval_154,hau_Latn,swift,"
// An ba ku kalmomi 2. Kuna buƙatar dawowa gaskiya idan kalma ta biyu ko kowane juyawa shine substring a cikin kalma ta farko /// >>> cycpattern_check(a: ""abcd"", b: ""abd"")
/// false
/// >>> cycpattern_check(a: ""hello"", b: ""ell"")
/// true
/// >>> cycpattern_check(a: ""whassup"", b: ""psus"")
/// false
/// >>> cycpattern_check(a: ""abab"", b: ""baa"")
/// true
/// >>> cycpattern_check(a: ""efef"", b: ""eeff"")
/// false
/// >>> cycpattern_check(a: ""himenss"", b: ""simen"")
/// true
func cycpattern_check(a: String, b: String) -> Bool {
","func cycpattern_check(a: String, b: String) -> Bool {
    guard !b.isEmpty else { return true }
    let bCombined = b + b
    for i in 0..<b.count {
        let rotation = String(bCombined.dropFirst(i).prefix(b.count))
        if a.contains(rotation) {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(cycpattern_check(a: ""xyzw"", b: ""xyw"") == false)
assert(cycpattern_check(a: ""yello"", b: ""ell"") == true)
assert(cycpattern_check(a: ""whattup"", b: ""ptut"") == false)
assert(cycpattern_check(a: ""efef"", b: ""fee"") == true)
assert(cycpattern_check(a: ""abab"", b: ""aabb"") == false)
assert(cycpattern_check(a: ""winemtt"", b: ""tinem"") == true)"
HumanEval_155,hau_Latn,swift,"
// Misali: // Ba da wani lamba. dawo da wani tuple cewa yana da yawan ma da m lambobi bi da bi. /// >>> even_odd_count(num: -12)
/// (1, 1)
/// >>> even_odd_count(num: 123)
/// (1, 2)
func even_odd_count(num: Int) -> (Int, Int) {
","func even_odd_count(num: Int) -> (Int, Int) {
    var countEvens = 0
    var countOdds = 0
    var number = abs(num) // Handle negative numbers by taking absolute value

    while number > 0 {
        let digit = number % 10
        if digit % 2 == 0 {
            countEvens += 1
        } else {
            countOdds += 1
        }
        number /= 10
    }
    return (countEvens, countOdds)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_count(num: 7) == (0, 1))
assert(even_odd_count(num: -78) == (1, 1))
assert(even_odd_count(num: 3452) == (2, 2))
assert(even_odd_count(num: 346211) == (3, 3))
assert(even_odd_count(num: -345821) == (3, 3))
assert(even_odd_count(num: -2) == (1, 0))
assert(even_odd_count(num: -45347) == (2, 3))
assert(even_odd_count(num: 0) == (1, 0))"
HumanEval_156,hau_Latn,swift,"
// Misalai: // Ƙuntatawa: 1 <= num <= 1000 // kuma dawo da shi a cikin ƙananan haruffa. // An ba da cikakkiyar lamba mai kyau, sami daidai da lambar Roman a matsayin kirtani, /// >>> int_to_mini_roman(number: 19)
/// ""xix""
/// >>> int_to_mini_roman(number: 152)
/// ""clii""
/// >>> int_to_mini_roman(number: 426)
/// ""cdxxvi""
func int_to_mini_roman(number: Int) -> String {
","func int_to_mini_roman(number: Int) -> String {
    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    let numerals = [""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""]
    
    var num = number
    var result = """"
    
    for (index, value) in values.enumerated() {
        while num >= value {
            result += numerals[index]
            num -= value
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(int_to_mini_roman(number: 19) == ""xix"")
assert(int_to_mini_roman(number: 152) == ""clii"")
assert(int_to_mini_roman(number: 251) == ""ccli"")
assert(int_to_mini_roman(number: 426) == ""cdxxvi"")
assert(int_to_mini_roman(number: 500) == ""d"")
assert(int_to_mini_roman(number: 1) == ""i"")
assert(int_to_mini_roman(number: 4) == ""iv"")
assert(int_to_mini_roman(number: 43) == ""xliii"")
assert(int_to_mini_roman(number: 90) == ""xc"")
assert(int_to_mini_roman(number: 94) == ""xciv"")
assert(int_to_mini_roman(number: 532) == ""dxxxii"")
assert(int_to_mini_roman(number: 900) == ""cm"")
assert(int_to_mini_roman(number: 994) == ""cmxciv"")
assert(int_to_mini_roman(number: 1000) == ""m"")"
HumanEval_157,hau_Latn,swift,"
// Misali: // 90 digiri. // A right-angled triangle ne mai triangle a cikin abin da daya daga cikin kusurwa ne dama kwana ko // bangarorin suna samar da alwatika mai kusurwa madaidaiciya, in ba haka ba ba gaskiya bane. // Ba da tsawon bangarorin uku na alwatika. Koma gaskiya idan uku /// >>> right_angle_triangle(a: 3, b: 4, c: 5)
/// true
/// >>> right_angle_triangle(a: 1, b: 2, c: 3)
/// false
func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
","func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
    let sides = [a, b, c].sorted()
    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(right_angle_triangle(a: 3, b: 4, c: 5) == true)
assert(right_angle_triangle(a: 1, b: 2, c: 3) == false)
assert(right_angle_triangle(a: 10, b: 6, c: 8) == true)
assert(right_angle_triangle(a: 2, b: 2, c: 2) == false)
assert(right_angle_triangle(a: 7, b: 24, c: 25) == true)
assert(right_angle_triangle(a: 10, b: 5, c: 7) == false)
assert(right_angle_triangle(a: 5, b: 12, c: 13) == true)
assert(right_angle_triangle(a: 15, b: 8, c: 17) == true)
assert(right_angle_triangle(a: 48, b: 55, c: 73) == true)
assert(right_angle_triangle(a: 1, b: 1, c: 1) == false)
assert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"
HumanEval_158,hau_Latn,swift,"
// haruffa, dawo da wanda ya zo na farko a cikin lexicographical tsari. Idan mahara kirtani da iyakar yawan musamman // Array ya ƙunshi kalmomi daban-daban. Koma kalmar da iyakar adadin // Rubuta wani aiki da ya yarda da wani tsararru na kirtani. /// >>> find_max(words: [""name"", ""of"", ""string""])
/// ""string""
/// >>> find_max(words: [""name"", ""enam"", ""game""])
/// ""enam""
/// >>> find_max(words: [""aaaaaaa"", ""bb"", ""cc""])
/// ""aaaaaaa""
func find_max(words: [String]) -> String {
","func find_max(words: [String]) -> String {
    func uniqueCharacterCount(in word: String) -> Int {
        return Set(word).count
    }
    
    return words.max { a, b in
        let uniqueCountA = uniqueCharacterCount(in: a)
        let uniqueCountB = uniqueCharacterCount(in: b)
        
        if uniqueCountA == uniqueCountB {
            return a > b
        }
        
        return uniqueCountA < uniqueCountB
    } ?? """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_max(words: [""name"", ""of"", ""string""]) == ""string"")
assert(find_max(words: [""name"", ""enam"", ""game""]) == ""enam"")
assert(find_max(words: [""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa"")
assert(find_max(words: [""abc"", ""cba""]) == ""abc"")
assert(find_max(words: [""play"", ""this"", ""game"", ""of"", ""footbott""]) == ""footbott"")
assert(find_max(words: [""we"", ""are"", ""gonna"", ""rock""]) == ""gonna"")
assert(find_max(words: [""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation"")
assert(find_max(words: [""this"", ""is"", ""a"", ""prrk""]) == ""this"")
assert(find_max(words: [""b""]) == ""b"")
assert(find_max(words: [""play"", ""play"", ""play""]) == ""play"")"
HumanEval_159,hau_Latn,swift,"
// Misali: // idan babu isasshen sauran karas, za ku ci duk sauran karas, amma har yanzu za ku ji yunwa. // yawan karas da suka rage bayan cin abincinku ] // ya kamata ka dawo da wani tsararru na [ jimlar adadin karas da aka ci bayan cin abincinku, // amma yanzu kana bukatar ka ci karin karas don kammala abincin rana. // Kai ne mai yunwa zomo, kuma ka riga ya ci wani adadin karas, /// >>> eat(number: 5, need: 6, remaining: 10)
/// [11, 4]
/// >>> eat(number: 4, need: 8, remaining: 9)
/// [12, 1]
/// >>> eat(number: 1, need: 10, remaining: 10)
/// [11, 0]
/// >>> eat(number: 2, need: 11, remaining: 5)
/// [7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
func eat(number: Int, need: Int, remaining: Int) -> [Int] {
","func eat(number: Int, need: Int, remaining: Int) -> [Int] {
    let totalNeeded = number + need
    let totalEaten = min(totalNeeded, number + remaining)
    let carrotsLeft = max(0, remaining - (totalEaten - number))
    return [totalEaten, carrotsLeft]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])
assert(eat(number: 4, need: 8, remaining: 9) == [12, 1])
assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])
assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])
assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])
assert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
HumanEval_160,hau_Latn,swift,"
// Operator array yana da aƙalla mai aiki ɗaya, kuma operand array yana da aƙalla operands biyu. // Operand ne mai tsararru na ba-korau integers. // A tsawon na sadarwarka tsararru ne daidai da tsawon operand tsararru debe daya. // Lura: // => sakamakon = 9 // sakamakon = 2 + 3 * 4 - 5 // array = [2, 3, 4, 5] // mai aiki ['+', '*', '-'] // Misali: // Ƙaddamarwa (**) // Rarraba bene ( // ) // Ƙara ( * ) // Ragewa ( - ) // Ƙari ( + ) // Ayyukan algebra na asali: // magana da kuma dawo da kimantawa na wannan magana. // na biyu tsararru ne tsararru na integers. Yi amfani da biyu da aka ba tsararru gina algebraic // An ba da mai aiki biyu, da kuma aiki. Mataki na farko yana da ayyukan algebra na asali, kuma func do_algebra(operator: [String], operand: [Int]) -> Int {
","func do_algebra(operator: [String], operand: [Int]) -> Int {
    var result = operand[0]
    let precedence: [String: Int] = [""+"": 1, ""-"": 1, ""*"": 2, ""//"": 2, ""**"": 3]
    
    var opStack: [String] = []
    var numStack: [Int] = [result]
    
    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {
        switch op {
        case ""+"":
            return a + b
        case ""-"":
            return a - b
        case ""*"":
            return a * b
        case ""//"":
            return a / b
        case ""**"":
            return Int(pow(Double(a), Double(b)))
        default:
            fatalError(""Unsupported operator: \(op)"")
        }
    }
    
    for i in 0..<operator.count {
        let currentOp = `operator`[i]
        let currentNum = operand[i + 1]
        
        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {
            opStack.removeLast()
            let b = numStack.removeLast()
            let a = numStack.removeLast()
            numStack.append(applyOperator(lastOp, b, a))
        }
        
        opStack.append(currentOp)
        numStack.append(currentNum)
    }
    
    while let lastOp = opStack.popLast() {
        let b = numStack.removeLast()
        let a = numStack.removeLast()
        numStack.append(applyOperator(lastOp, b, a))
    }
    
    return numStack.first!
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(do_algebra(operator: [""**"", ""*"", ""+""], operand: [2, 3, 4, 5]) == 37)
assert(do_algebra(operator: [""+"", ""*"", ""-""], operand: [2, 3, 4, 5]) == 9)
assert(do_algebra(operator: [""//"", ""*""], operand: [7, 3, 4]) == 8)"
HumanEval_161,hau_Latn,swift,"
// Misalai // Aikin ya kamata ya dawo da sakamakon kirtani. // Idan kirtani ba ya dauke da haruffa, jujjuya kirtani. // in ba haka ba kiyaye shi kamar yadda yake. // idan s [i] harafi ne, juya yanayin sa daga ƙasa zuwa sama ko kuma akasin haka, // An ba ku wani kirtani s. /// >>> solve(s: ""1234"")
/// ""4321""
/// >>> solve(s: ""ab"")
/// ""AB""
/// >>> solve(s: ""#a@C"")
/// ""#A@c""
func solve(s: String) -> String {
","func solve(s: String) -> String {
    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {
        return String(s.reversed())
    }
    
    var result = """"
    for char in s {
        if char.isLetter {
            if char.isLowercase {
                result.append(char.uppercased())
            } else {
                result.append(char.lowercased())
            }
        } else {
            result.append(char)
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: ""AsDf"") == ""aSdF"")
assert(solve(s: ""1234"") == ""4321"")
assert(solve(s: ""ab"") == ""AB"")
assert(solve(s: ""#a@C"") == ""#A@c"")
assert(solve(s: ""#AsdfW^45"") == ""#aSDFw^45"")
assert(solve(s: ""#6@2"") == ""2@6#"")
assert(solve(s: ""#$a^D"") == ""#$A^d"")
assert(solve(s: ""#ccc"") == ""#CCC"")"
HumanEval_162,hau_Latn,swift,"
// Idan 'rubutu' ne mai m kirtani, dawo da null. // An ba da kirtani 'rubutu', dawo da kirtani mai kama da md5. /// >>> string_to_md5(text: ""Hello world"")
/// ""3e25960a79dbc69b674cd4ec67a72c62""
func string_to_md5(text: String) -> String? {
","import Foundation
import CommonCrypto

func string_to_md5(text: String) -> String? {
    guard !text.isEmpty else { return nil }
    
    let length = Int(CC_MD5_DIGEST_LENGTH)
    let messageData = text.data(using: .utf8)!
    var digestData = Data(count: length)
    
    _ = digestData.withUnsafeMutableBytes { digestBytes in
        messageData.withUnsafeBytes { messageBytes in
            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)
        }
    }
    
    return digestData.map { String(format: ""%02hhx"", $0) }.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_to_md5(text: ""Hello world"") == ""3e25960a79dbc69b674cd4ec67a72c62"")
assert(string_to_md5(text: """") == nil)
assert(string_to_md5(text: ""A B C"") == ""0ef78513b0cb8cef12743f5aeb35f888"")
assert(string_to_md5(text: ""password"") == ""5f4dcc3b5aa765d61d8327deb882cf99"")"
HumanEval_163,hau_Latn,swift,"
// Misali: // da kuma b, a cikin tsari mai tasowa. // Ba biyu m integers a da b, dawo da ma lambobi tsakanin a /// >>> generate_integers(a: 2, b: 8)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 8, b: 2)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 10, b: 14)
/// [] as [Int]
func generate_integers(a: Int, b: Int) -> [Int] {
","func generate_integers(a: Int, b: Int) -> [Int] {
    let lower = min(a, b)
    let upper = max(a, b)
    var result = [Int]()
    
    for number in lower...upper {
        if number % 2 == 0 {
            result.append(number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])
assert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 17, b: 89) == [] as [Int])"
