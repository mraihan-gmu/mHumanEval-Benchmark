task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,sin_Sinh,swift,"
// ලබා දී ඇති සීමාව.// අංක මාලාවක අංක දෙකකට වඩා එකිනෙකට සමීපද කියලා බලන්න./// >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)
/// false
/// >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)
/// true
func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
","func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
    let sortedNumbers = numbers.sorted()
    for i in 0..<sortedNumbers.count - 1 {
        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"
HumanEval_1,sin_Sinh,swift,"
// ආදාන නූල තුල ඇති ඕනෑම අවකාශයක් නොසලකා හරින්න.// වෙනම කණ්ඩායම් සමබරයි (සෑම විවෘත ආධාරකයක්ම නිසි ලෙස වසා ඇත) සහ එකිනෙකා තුළ කූඩු නොවී // ඒ කණ්ඩායම් වෙන වෙනම string වලට වෙන් කරලා ඒ array එක ආපහු දෙන්න.// මෙම ශ් රිතයට ඇතුලත් කරන ලද අකුරු මාලාවක අන්තර්ගත වන්නේ බහු කණ්ඩායම් අතරින් කූඩු කර ඇති කුටි වලිනි. ඔබේ ඉලක්කය වන්නේ /// >>> separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"")
/// [""()"", ""(())"", ""(()())""]
func separate_paren_groups(paren_string: String) -> [String] {
","func separate_paren_groups(paren_string: String) -> [String] {
    var results = [String]()
    var currentGroup = """"
    var balance = 0

    for char in paren_string {
        // Ignore spaces
        if char == "" "" {
            continue
        }
        
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }

        currentGroup.append(char)

        if balance == 0 && !currentGroup.isEmpty {
            results.append(currentGroup)
            currentGroup = """"
        }
    }
    
    return results
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(separate_paren_groups(paren_string: ""(()()) ((())) () ((())()())"") == [""(()())"", ""((()))"", ""()"", ""((())()())""])
assert(separate_paren_groups(paren_string: ""() (()) ((())) (((())))"") == [""()"", ""(())"", ""((()))"", ""(((())))""])
assert(separate_paren_groups(paren_string: ""(()(())((())))"") == [""(()(())((())))""])
assert(separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"") == [""()"", ""(())"", ""(()())""])"
HumanEval_2,sin_Sinh,swift,"
// අංකයේ දශම කොටස නැවත ලබා දෙන්න.// (ඉතුරු කොටස හැමවිටම 1 ට වඩා කුඩායි.)// සහ සම්පූර්ණ සංඛ් යා කොටස (දී ඇති සංඛ් යාවට වඩා විශාලතම සම්පූර්ණ සංඛ් යාව) සහ දශම අංක ධනාත්මක පාවෙන අක්ෂාංකයක් ලබා දීලා, ඒක  බවට වෙන් කරන්න පුළුවන්./// >>> truncate_number(number: 3.5)
/// 0.5
func truncate_number(number: Double) -> Double {
","func truncate_number(number: Double) -> Double {
    return number - Double(Int(number))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(truncate_number(number: 3.5) == 0.5)
assert(truncate_number(number: 1.25) == 0.25)
assert(truncate_number(number: 123.0) == 0.0)"
HumanEval_3,sin_Sinh,swift,"
//එම අවස්ථාවෙහිදී function නැවත true ලබාදිය යුතුයි. එසේ නොමැතිනම් එය false ලබාදිය යුතුයි.ඔයාගේ කාර්යය තමයි ඕනම අවස්ථාවක ගිණුමේ ශේෂය ශුන් යයට වඩා පහළට වැටෙනවා නම් හොයාගන්න එක, සහ // ඔබට බැංකු ගිණුමක තැන්පතු සහ මුදල් ආපසු ගැනීමේ මෙහෙයුම් මාලාවක් ලබා දී ඇත /// >>> below_zero(operations: [1, 2, 3])
/// false
/// >>> below_zero(operations: [1, 2, -4, 5])
/// true
func below_zero(operations: [Int]) -> Bool {
","func below_zero(operations: [Int]) -> Bool {
    var balance = 0
    for operation in operations {
        balance += operation
        if balance < 0 {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_zero(operations: [] as [Int]) == false)
assert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)
assert(below_zero(operations: [1, 2, -4, 5, 6]) == true)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)
assert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"
HumanEval_4,sin_Sinh,swift,"
MAD = සාමාන් ය ∙ x - x_mean ∙// මූලද් රව් යයක් සහ කේන්ද් රයක් (මේ අවස්ථාවේදී මධ් ය අගය): // මධ් යම නිරපේක්ෂ අපගමනය යනු // මේ දත්ත කට්ටලයේ මධ් යම අගය වටා.// ලබා දී ඇති ආදාන සංඛ් යා සමූහයක් සඳහා, මධ් යම නිරපේක්ෂ අපගමනය ගණනය කරන්න./// >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])
/// 1.0
func mean_absolute_deviation(numbers: [Double]) -> Double {
","func mean_absolute_deviation(numbers: [Double]) -> Double {
    guard !numbers.isEmpty else { return 0.0 }
    
    let mean = numbers.reduce(0.0, +) / Double(numbers.count)
    let absoluteDifferences = numbers.map { abs($0 - mean) }
    let mad = absoluteDifferences.reduce(0.0, +) / Double(absoluteDifferences.count)
    
    return mad
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"
HumanEval_5,sin_Sinh,swift,"
// ඇතුලත් කිරීමේ අරාවෙහි සෑම අඛණ්ඩ අංග දෙකක් අතර 'අන්තය' අංකයක් ඇතුලත් කරන්න `numbers' /// >>> intersperse(numbers: [] as [Int], delimeter: 4)
/// [] as [Int]
/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)
/// [1, 4, 2, 4, 3]
func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
","func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
    guard !numbers.isEmpty else { return [] }
    
    var result: [Int] = []
    
    for number in numbers {
        result.append(number)
        result.append(delimeter)
    }
    
    // Remove the last added delimiter
    result.removeLast()
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])
assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])
assert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
HumanEval_6,sin_Sinh,swift,"
// උදාහරණයක් ලෙස (() (()) හි උපරිම වශයෙන් පැටවුන් බිහි කිරීමේ මට්ටම් දෙකක් ඇති අතර ((())) හි තුනක් ඇත. // කණ්ඩායමේ සෑම කෙනෙකුටම, කුටි වල ගැඹුරුම මට්ටමේ කුටිගත කිරීම ප් රතිදානය කරන්න.// මෙම ශ් රිතයට ආදානය වන්නේ අවකාශයන්ගෙන් වෙන් කර ඇති කුටිවල බහු කණ්ඩායම් නියෝජනය කරන නූල් ය./// >>> parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"")
/// [2, 3, 1, 3]
func parse_nested_parens(paren_string: String) -> [Int] {
","func parse_nested_parens(paren_string: String) -> [Int] {
    let groups = paren_string.split(separator: "" "")
    var depths: [Int] = []
    
    for group in groups {
        var maxDepth = 0
        var currentDepth = 0
        
        for char in group {
            if char == ""("" {
                currentDepth += 1
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == "")"" {
                currentDepth -= 1
            }
        }
        
        depths.append(maxDepth)
    }
    
    return depths
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"") == [2, 3, 1, 3])
assert(parse_nested_parens(paren_string: ""() (()) ((())) (((())))"") == [1, 2, 3, 4])
assert(parse_nested_parens(paren_string: ""(()(())((())))"") == [4])"
HumanEval_7,sin_Sinh,swift,"
// අක්ෂි මාලාවක් පෙරහන් කරන්න, ඒ සඳහා අක්ෂි මාලාවක් ඇතුලත් කරන්න./// >>> filter_by_substring(strings: [] as [String], substring: ""a"")
/// [] as [String]
/// >>> filter_by_substring(strings: [""abc"", ""bacd"", ""cde"", ""array""], substring: ""a"")
/// [""abc"", ""bacd"", ""array""]
func filter_by_substring(strings: [String], substring: String) -> [String] {
","func filter_by_substring(strings: [String], substring: String) -> [String] {
    return strings.filter { $0.contains(substring) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_substring(strings: [] as [String], substring: ""john"") == [] as [String])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xx"") == [""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""grunt"", ""trumpet"", ""prune"", ""gruesome""], substring: ""run"") == [""grunt"", ""prune""])"
HumanEval_8,sin_Sinh,swift,"
// හිස් එකතුව 0 ට සමාන විය යුතුයි සහ හිස් ගුණය 1 ට සමාන විය යුතුයි.// දී ඇති මුළු සංඛ් යා අරාවකට, අරාවක ඇති සියලුම මුළු සංඛ් යා වල එකතුවක් සහ ගුණයකින් සමන්විත ටුපල් එකක් ලබා දෙන්න./// >>> sum_product(numbers: [] as [Int])
/// (0, 1)
/// >>> sum_product(numbers: [1, 2, 3, 4])
/// (10, 24)
func sum_product(numbers: [Int]) -> (Int, Int) {
","func sum_product(numbers: [Int]) -> (Int, Int) {
    let sum = numbers.reduce(0, +)
    let product = numbers.reduce(1, *)
    return (sum, product)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_product(numbers: [] as [Int]) == (0, 1))
assert(sum_product(numbers: [1, 1, 1]) == (3, 1))
assert(sum_product(numbers: [100, 0]) == (100, 0))
assert(sum_product(numbers: [3, 5, 7]) == (15, 105))
assert(sum_product(numbers: [10]) == (10, 10))"
HumanEval_9,sin_Sinh,swift,"
// අනුක් රමිකව.// දී ඇති අංක මාලාවකින්, ලබා දී ඇති මොහොත දක්වා සොයාගත් උපරිම අංගයේ මාලාවක් ජනනය කරන්න./// >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])
/// [1, 2, 3, 3, 3, 4, 4]
func rolling_max(numbers: [Int]) -> [Int] {
","func rolling_max(numbers: [Int]) -> [Int] {
    var result = [Int]()
    var currentMax: Int? = nil
    for number in numbers {
        if let max = currentMax {
            currentMax = max > number ? max : number
        } else {
            currentMax = number
        }
        result.append(currentMax!)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rolling_max(numbers: [] as [Int]) == [] as [Int])
assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])
assert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
HumanEval_10,sin_Sinh,swift,"
// - palindromic suffix එකට කලින් එන string prefix එක string එකේ අවසානයට එකතු කරන්න. // - ලබා දී ඇති string එකේ දිගම postfix එක palindrome එකක් බව සොයා ගන්න. // ඇල්ගොරිතම අදහස සරලයි: // ලබා දී ඇති නූලකින් ආරම්භ වන කෙටිම පාලින්ඩ් රෝමය සොයා ගන්න. /// >>> make_palindrome(string: """")
/// """"
/// >>> make_palindrome(string: ""cat"")
/// ""catac""
/// >>> make_palindrome(string: ""cata"")
/// ""catac""
func make_palindrome(string: String) -> String {
","func make_palindrome(string: String) -> String {
    func isPalindrome(_ s: String) -> Bool {
        return s == String(s.reversed())
    }
    
    if string.isEmpty || isPalindrome(string) {
        return string
    }
    
    for i in stride(from: string.count, through: 0, by: -1) {
        let suffixIndex = string.index(string.startIndex, offsetBy: i)
        let suffix = String(string[suffixIndex..<string.endIndex])
        if isPalindrome(suffix) {
            let prefix = String(string[string.startIndex..<suffixIndex])
            return string + String(prefix.reversed())
        }
    }
    
    return string
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_palindrome(string: """") == """")
assert(make_palindrome(string: ""x"") == ""x"")
assert(make_palindrome(string: ""xyz"") == ""xyzyx"")
assert(make_palindrome(string: ""xyx"") == ""xyx"")
assert(make_palindrome(string: ""jerry"") == ""jerryrrej"")"
HumanEval_11,sin_Sinh,swift,"
// මෙම ආදාන මත ද්විමය XOR සිදුකර ප් රතිඵලය ද නූලක් ලෙස ලබා දෙන්න. // ආදානය 1 සහ 0 වලින් පමණක් සමන්විත a සහ b නූල් දෙකක්./// >>> string_xor(a: ""010"", b: ""110"")
/// ""100""
func string_xor(a: String, b: String) -> String {
","func string_xor(a: String, b: String) -> String {
    let charactersA = Array(a)
    let charactersB = Array(b)
    var result = """"

    for i in 0..<charactersA.count {
        let bitA = charactersA[i]
        let bitB = charactersB[i]
        
        if bitA != bitB {
            result.append(""1"")
        } else {
            result.append(""0"")
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: ""111000"", b: ""101010"") == ""010010"")
assert(string_xor(a: ""1"", b: ""1"") == ""0"")
assert(string_xor(a: ""0101"", b: ""0000"") == ""0101"")"
HumanEval_12,sin_Sinh,swift,"
// එකම දිගට string එකක්. input array එක හිස් නම් null නැවත දෙන්න.// string array එකකින් දිගම string එක දෙන්න./// >>> longest(strings: [] as [String])
/// nil
/// >>> longest(strings: [""a"", ""b"", ""c""])
/// ""a""
/// >>> longest(strings: [""a"", ""bb"", ""ccc""])
/// ""ccc""
func longest(strings: [String]) -> String? {
","func longest(strings: [String]) -> String? {
    guard !strings.isEmpty else { return nil }
    var longestString = strings[0]
    for string in strings {
        if string.count > longestString.count {
            longestString = string
        }
    }
    return longestString
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(longest(strings: [] as [String]) == nil)
assert(longest(strings: [""x"", ""y"", ""z""]) == ""x"")
assert(longest(strings: [""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]) == ""zzzz"")"
HumanEval_13,sin_Sinh,swift,"
// a සහ b යන පූර්ණ සංඛ් යා දෙකක විශාලතම පොදු බෙදන්නා ලබා දෙන්න /// >>> greatest_common_divisor(a: 3, b: 5)
/// 1
/// >>> greatest_common_divisor(a: 25, b: 15)
/// 5
func greatest_common_divisor(a: Int, b: Int) -> Int {
","func greatest_common_divisor(a: Int, b: Int) -> Int {
    if b == 0 {
        return a
    } else {
        return greatest_common_divisor(a: b, b: a % b)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(greatest_common_divisor(a: 3, b: 7) == 1)
assert(greatest_common_divisor(a: 10, b: 15) == 5)
assert(greatest_common_divisor(a: 49, b: 14) == 7)
assert(greatest_common_divisor(a: 144, b: 60) == 12)"
HumanEval_14,sin_Sinh,swift,"
// ආදාන නූලෙහි කෙටිම සිට දිගම දක්වා සියලුම පෙරනිමිති වල අරාව නැවත ලබා දෙන්න./// >>> all_prefixes(string: ""abc"")
/// [""a"", ""ab"", ""abc""]
func all_prefixes(string: String) -> [String] {
","func all_prefixes(string: String) -> [String] {
    var prefixes: [String] = []
    for i in 1...string.count {
        let prefix = String(string.prefix(i))
        prefixes.append(prefix)
    }
    return prefixes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(all_prefixes(string: """") == [] as [String])
assert(all_prefixes(string: ""asdfgh"") == [""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""])
assert(all_prefixes(string: ""WWW"") == [""W"", ""WW"", ""WWW""])"
HumanEval_15,sin_Sinh,swift,"
// 0 සිට n දක්වා අංක වලින් යුත් අංකයක් ලබා දෙන්න./// >>> string_sequence(n: 0)
/// ""0""
/// >>> string_sequence(n: 5)
/// ""0 1 2 3 4 5""
func string_sequence(n: Int) -> String {
","func string_sequence(n: Int) -> String {
    return (0...n).map { String($0) }.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_sequence(n: 0) == ""0"")
assert(string_sequence(n: 3) == ""0 1 2 3"")
assert(string_sequence(n: 10) == ""0 1 2 3 4 5 6 7 8 9 10"")"
HumanEval_16,sin_Sinh,swift,"
// string එකක් දීලා, ඒකෙ වෙන වෙනම අක්ෂර කීයක් තියෙනවද කියලා හොයාගන්න (අකුරු අකුරු නොතකා)/// >>> count_distinct_characters(string: ""xyzXYZ"")
/// 3
/// >>> count_distinct_characters(string: ""Jerry"")
/// 4
func count_distinct_characters(string: String) -> Int {
","func count_distinct_characters(string: String) -> Int {
    let lowercasedString = string.lowercased()
    let distinctCharacters = Set(lowercasedString)
    return distinctCharacters.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_distinct_characters(string: """") == 0)
assert(count_distinct_characters(string: ""abcde"") == 5)
assert(count_distinct_characters(string: ""abcdecadeCADE"") == 5)
assert(count_distinct_characters(string: ""aaaaAAAAaaaa"") == 1)
assert(count_distinct_characters(string: ""Jerry jERRY JeRRRY"") == 5)"
HumanEval_17,sin_Sinh,swift,"
- එක පහරක් විතරයි.// 'o "" 'ඉදිරියට' - අර්ධ නෝට්ටු, පහර දෙකක් පවතී // 'O' - සම්පූර්ණ නෝට්ටුවක්, පහර හතරක් පවතිනවා // මෙන්න මේකයි පුරාවෘත්තය: අන්තිමයා නෙවෙයි.// ඔයාගේ වැඩේ තමයි මේ string එක parse කරලා ඒකෙ තියෙන beat ගානට ගැලපෙන integers array එකක් ආපහු එවන්න.// මේ ෆන්ක්ශන් එකේ ආදානය තමයි සංගීත නෝට්ටු විශේෂ ASCII ආකෘතියකින් නියෝජනය කරන නූල්./// >>> parse_music(music_string: ""o o| .| o| o| .| .| .| .| o o"")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
","func parse_music(music_string: String) -> [Int] {
    let notes = music_string.split(separator: "" "")
    var beats: [Int] = []
    
    for note in notes {
        switch note {
        case ""o"":
            beats.append(4)
        case ""o|"":
            beats.append(2)
        case "".|"":
            beats.append(1)
        default:
            continue
        }
    }
    
    return beats
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: """") == [] as [Int])
assert(parse_music(music_string: ""o o o o"") == [4, 4, 4, 4])
assert(parse_music(music_string: "".| .| .| .|"") == [1, 1, 1, 1])
assert(parse_music(music_string: ""o| o| .| .| o o o o"") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: ""o| .| o| .| o o| o o|"") == [2, 1, 2, 1, 4, 2, 4, 2])"
HumanEval_18,sin_Sinh,swift,"
// මුල් නූලෙන් ලබා දී ඇති උප නූල කී වතාවක් සොයාගත හැකිදැයි සොයා ගන්න. /// >>> how_many_times(string: """", substring: ""a"")
/// 0
/// >>> how_many_times(string: ""aaa"", substring: ""a"")
/// 3
/// >>> how_many_times(string: ""aaaa"", substring: ""aa"")
/// 3
func how_many_times(string: String, substring: String) -> Int {
","func how_many_times(string: String, substring: String) -> Int {
    guard !substring.isEmpty else { return 0 }
    
    var count = 0
    var startIndex = string.startIndex
    
    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {
        count += 1
        startIndex = string.index(after: range.lowerBound)
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(how_many_times(string: """", substring: ""x"") == 0)
assert(how_many_times(string: ""xyxyxyx"", substring: ""x"") == 4)
assert(how_many_times(string: ""cacacacac"", substring: ""cac"") == 4)
assert(how_many_times(string: ""john doe"", substring: ""john"") == 1)"
HumanEval_19,sin_Sinh,swift,"
// අංක වලින් යුත් string එක කුඩාම අංකයෙන් විශාලම අංකයට වර්ග කර නැවත ලබා දෙන්න.// වලංගු විකල්පයන් වන්නේ '0', '1', '2', '3', '4', '5', '6', '7', '8' සහ '9' යන්නයි.// ආදානය යනු '0' සිට '9' දක්වා අංක වලින් යුත් අවකාශය සීමා වූ නූල් ය./// >>> sort_numbers(numbers: ""three one five"")
/// ""one three five""
func sort_numbers(numbers: String) -> String {
","func sort_numbers(numbers: String) -> String {
    // Mapping of word numbers to digits
    let numberWords: [String: Int] = [
        ""zero"": 0,
        ""one"": 1,
        ""two"": 2,
        ""three"": 3,
        ""four"": 4,
        ""five"": 5,
        ""six"": 6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"": 9
    ]

    // Split the input string into words
    let words = numbers.split(separator: "" "")

    // Sort the words based on their corresponding number values
    let sortedWords = words.sorted { 
        numberWords[String($0)]! < numberWords[String($1)]! 
    }

    // Join the sorted words back into a single string
    return sortedWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_numbers(numbers: """") == """")
assert(sort_numbers(numbers: ""three"") == ""three"")
assert(sort_numbers(numbers: ""three five nine"") == ""three five nine"")
assert(sort_numbers(numbers: ""five zero four seven nine eight"") == ""zero four five seven eight nine"")
assert(sort_numbers(numbers: ""six five four three two one zero"") == ""zero one two three four five six"")"
HumanEval_20,sin_Sinh,swift,"
// අනෙක් ඒවා පිළිවෙලට දෙන්න (කුඩා අංකය, විශාල අංකය).// ලබා දී ඇති අංක මාලාවකින් (අවම වශයෙන් දෙකක්) එක් එක් අංකයට ආසන්නතම අංක දෙක තෝරාගෙන නැවත ලබා දෙන්න./// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
func find_closest_elements(numbers: [Double]) -> (Double, Double) {
","func find_closest_elements(numbers: [Double]) -> (Double, Double) {
    // Sort the array to bring closest numbers next to each other
    let sortedNumbers = numbers.sorted()
    
    // Initialize variables to keep track of the smallest difference and the pair
    var minDifference = Double.greatestFiniteMagnitude
    var closestPair: (Double, Double) = (0.0, 0.0)
    
    // Iterate over the sorted numbers to find the smallest difference
    for i in 0..<sortedNumbers.count - 1 {
        let num1 = sortedNumbers[i]
        let num2 = sortedNumbers[i + 1]
        let difference = abs(num1 - num2)
        
        if difference < minDifference {
            minDifference = difference
            closestPair = (num1, num2)
        }
    }
    
    return closestPair
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))
assert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))
assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
HumanEval_21,sin_Sinh,swift,"
//එහෙම නම් පොඩිම අංකය 0 වෙනවා ලොකුම එක 1 වෙනවා // සංඛ් යා අරාව ලබා දී ඇති විට (අවම වශයෙන් මූලද් රව් ය දෙකක), එම අරාවට රේඛීය පරිවර්තනයක් යොදන්න, /// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])
/// [0.0, 0.25, 0.5, 0.75, 1.0]
func rescale_to_unit(numbers: [Double]) -> [Double] {
","func rescale_to_unit(numbers: [Double]) -> [Double] {
    guard numbers.count > 1 else { return numbers }
    
    let minValue = numbers.min()!
    let maxValue = numbers.max()!
    let range = maxValue - minValue
    
    guard range != 0 else {
        return numbers.map { _ in 0.0 }
    }
    
    return numbers.map { ($0 - minValue) / range }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])
assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])
assert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])
assert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])
assert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
HumanEval_22,sin_Sinh,swift,"
// ලබා දී ඇති අරාවෙ ඕනෑම swiftthon අගයක් ෆිල්ටර් කරන්න./// >>> filter_integers(values: [""a"", 3.14, 5])
/// [5]
/// >>> filter_integers(values: [1, 2, 3, ""abc"", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])
/// [1, 2, 3]
func filter_integers(values: [AnyHashable]) -> [Int] {
","func filter_integers(values: [AnyHashable]) -> [Int] {
    return values.compactMap { $0 as? Int }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])
assert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, ""adasd""]) == [4, 9])
assert(filter_integers(values: [3, ""c"", 3, 3, ""a"", ""b""]) == [3, 3, 3])"
HumanEval_23,sin_Sinh,swift,"
// ලබා දී ඇති string එකක දිග නැවත ලබා දෙන්න /// >>> strlen(string: """")
/// 0
/// >>> strlen(string: ""abc"")
/// 3
func strlen(string: String) -> Int {
","func strlen(string: String) -> Int {
    return string.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strlen(string: """") == 0)
assert(strlen(string: ""x"") == 1)
assert(strlen(string: ""asdasnakj"") == 9)"
HumanEval_24,sin_Sinh,swift,"
// ලබා දී ඇති n අංකයක් සඳහා, n ට වඩා කුඩා, n සමානව බෙදන විශාලතම අංකය සොයා ගන්න /// >>> largest_divisor(n: 15)
/// 5
func largest_divisor(n: Int) -> Int {
","func largest_divisor(n: Int) -> Int {
    for i in stride(from: n / 2, to: 0, by: -1) {
        if n % i == 0 {
            return i
        }
    }
    return 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_divisor(n: 3) == 1)
assert(largest_divisor(n: 7) == 1)
assert(largest_divisor(n: 10) == 5)
assert(largest_divisor(n: 100) == 50)
assert(largest_divisor(n: 49) == 7)"
HumanEval_25,sin_Sinh,swift,"
// ආදාන අංකය සියලුම සාධකවල ගුණයට සමාන විය යුතුයි // එක් එක් සාධකයන් සාධකකරණයේ කොපමණ වාරයක් පෙනී සිටිනවාද යන්නට අනුරූපව සැකසිය යුතුය.// ලබා දී ඇති සම්පූර්ණ සංඛ් යාවක ප් රථම සාධකවල අරාව කුඩාම සිට විශාලතම දක්වා පිළිවෙලට ලබා දෙන්න. /// >>> factorize(n: 8)
/// [2, 2, 2]
/// >>> factorize(n: 25)
/// [5, 5]
/// >>> factorize(n: 70)
/// [2, 5, 7]
func factorize(n: Int) -> [Int] {
","func factorize(n: Int) -> [Int] {
    guard n > 1 else { return [] }
    var number = n
    var factors: [Int] = []
    var divisor = 2
    
    while number >= divisor {
        while number % divisor == 0 {
            factors.append(divisor)
            number /= divisor
        }
        divisor += 1
    }
    
    return factors
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(factorize(n: 2) == [2])
assert(factorize(n: 4) == [2, 2])
assert(factorize(n: 8) == [2, 2, 2])
assert(factorize(n: 57) == [3, 19])
assert(factorize(n: 3249) == [3, 3, 19, 19])
assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])
assert(factorize(n: 20577) == [3, 19, 19, 19])
assert(factorize(n: 18) == [2, 3, 3])"
HumanEval_26,sin_Sinh,swift,"
// ඇතුලත් කරන ලද අංගයන්ගේ අනුපිළිවෙල එකම ලෙස තබා ගන්න.// සම්පූර්ණ සංඛ් යා අරාවකින්, එක වතාවකට වඩා ඇති සියලුම අංග ඉවත් කරන්න./// >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])
/// [1, 3, 4]
func remove_duplicates(numbers: [Int]) -> [Int] {
","func remove_duplicates(numbers: [Int]) -> [Int] {
    var elementCount = [Int: Int]()
    for number in numbers {
        elementCount[number, default: 0] += 1
    }
    return numbers.filter { elementCount[$0] == 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])
assert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
HumanEval_27,sin_Sinh,swift,"
// ලබා දී ඇති නූලකට, කුඩා අකුරු ලොකු අකුරු වලට සහ ලොකු අකුරු කුඩා අකුරු වලට හරවන්න. /// >>> flip_case(string: ""Hello"")
/// ""hELLO""
func flip_case(string: String) -> String {
","func flip_case(string: String) -> String {
    return String(string.map { character in
        if character.isLowercase {
            return character.uppercased()
        } else if character.isUppercase {
            return character.lowercased()
        } else {
            return String(character)
        }
    }.joined())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: """") == """")
assert(flip_case(string: ""Hello!"") == ""hELLO!"")
assert(flip_case(string: ""These violent delights have violent ends"") == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")"
HumanEval_28,sin_Sinh,swift,"
// string එකක එකතුවක් කරන්න /// >>> concatenate(strings: [] as [String])
/// """"
/// >>> concatenate(strings: [""a"", ""b"", ""c""])
/// ""abc""
func concatenate(strings: [String]) -> String {
","func concatenate(strings: [String]) -> String {
    return strings.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(concatenate(strings: [] as [String]) == """")
assert(concatenate(strings: [""x"", ""y"", ""z""]) == ""xyz"")
assert(concatenate(strings: [""x"", ""y"", ""z"", ""w"", ""k""]) == ""xyzwk"")"
HumanEval_29,sin_Sinh,swift,"
// අක්ෂර මාලාවක් පෙරහන් කරන්න, ඒ අනුව අක්ෂර මාලාව පෙරනිමිති වලින් පටන් ගන්නව./// >>> filter_by_prefix(strings: [] as [String], prefix: ""a"")
/// [] as [String]
/// >>> filter_by_prefix(strings: [""abc"", ""bcd"", ""cde"", ""array""], prefix: ""a"")
/// [""abc"", ""array""]
func filter_by_prefix(strings: [String], prefix: String) -> [String] {
","func filter_by_prefix(strings: [String], prefix: String) -> [String] {
    return strings.filter { $0.hasPrefix(prefix) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_prefix(strings: [] as [String], prefix: ""john"") == [] as [String])
assert(filter_by_prefix(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], prefix: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])"
HumanEval_30,sin_Sinh,swift,"
// අරාවෙ ධනාත්මක අංක විතරයි ආපහු දෙන්නේ./// >>> get_positive(l: [-1, 2, -4, 5, 6])
/// [2, 5, 6]
/// >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// [5, 3, 2, 3, 9, 123, 1]
func get_positive(l: [Int]) -> [Int] {
","func get_positive(l: [Int]) -> [Int] {
    return l.filter { $0 > 0 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])
assert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])
assert(get_positive(l: [-1, -2]) == [] as [Int])
assert(get_positive(l: [] as [Int]) == [] as [Int])"
HumanEval_31,sin_Sinh,swift,"
// ලබා දී ඇති අංකය ප් රයිම් නම් true නැවත ලබා දෙන්න, එසේ නොමැති නම් false. /// >>> is_prime(n: 6)
/// false
/// >>> is_prime(n: 101)
/// true
/// >>> is_prime(n: 11)
/// true
/// >>> is_prime(n: 13441)
/// true
/// >>> is_prime(n: 61)
/// true
/// >>> is_prime(n: 4)
/// false
/// >>> is_prime(n: 1)
/// false
func is_prime(n: Int) -> Bool {
","func is_prime(n: Int) -> Bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    var i = 5
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_prime(n: 6) == false)
assert(is_prime(n: 101) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 13441) == true)
assert(is_prime(n: 61) == true)
assert(is_prime(n: 4) == false)
assert(is_prime(n: 1) == false)
assert(is_prime(n: 5) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 17) == true)
assert(is_prime(n: 85) == false)
assert(is_prime(n: 77) == false)
assert(is_prime(n: 255379) == false)"
HumanEval_33,sin_Sinh,swift,"
// l හි අනුරූප දර්ශකවල අගයන් වෙත, නමුත් වර්ග කර ඇත. // l' සමාන වේ l සමග දර්ශකවල දී එය තුනෙන් බෙදිය නොහැකි අතර එහි අගයන් දර්ශකවල දී සමාන වේ // මේ function එක array එකක් ගන්නවා l සහ array එකක් දෙනවා l' එවැනි /// >>> sort_third(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])
/// [2, 6, 3, 4, 8, 9, 5]
func sort_third(l: [Int]) -> [Int] {
","func sort_third(l: [Int]) -> [Int] {
    // Collect indices and their values where index is divisible by 3
    var divisibleByThreeValues: [(index: Int, value: Int)] = []
    for (index, value) in l.enumerated() where index % 3 == 0 {
        divisibleByThreeValues.append((index, value))
    }
    
    // Sort the values that were at the indices divisible by 3
    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()
    
    // Create a mutable copy of original array to modify
    var result = l
    
    // Replace the sorted values back into their original indices
    for (i, sortedValue) in sortedValues.enumerated() {
        result[divisibleByThreeValues[i].index] = sortedValue
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])
assert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])
assert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"
HumanEval_34,sin_Sinh,swift,"
// අංකිත අංගයන් අරාවක නැවත ලබාදෙනවා /// >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [0, 2, 3, 5, 9, 123]
func unique(l: [Int]) -> [Int] {
","func unique(l: [Int]) -> [Int] {
    return Array(Set(l)).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"
HumanEval_35,sin_Sinh,swift,"
අරා වල උපරිම අංගය නැවත ලබාදෙනවා./// >>> max_element(l: [1, 2, 3])
/// 3
/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
func max_element(l: [Int]) -> Int {
","func max_element(l: [Int]) -> Int {
    guard let max = l.max() else {
        fatalError(""Array should not be empty"")
    }
    return max
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_element(l: [1, 2, 3]) == 3)
assert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
HumanEval_36,sin_Sinh,swift,"
// 11 හෝ 13 න් බෙදිය හැකි n ට අඩු නිඛිල සංඛ් යා වල 7 අංකය දිස්වන වාර ගණන නැවත ලබා දෙන්න. /// >>> fizz_buzz(n: 50)
/// 0
/// >>> fizz_buzz(n: 78)
/// 2
/// >>> fizz_buzz(n: 79)
/// 3
func fizz_buzz(n: Int) -> Int {
","func fizz_buzz(n: Int) -> Int {
    var count = 0
    for number in 0..<n {
        if number % 11 == 0 || number % 13 == 0 {
            var current = number
            while current > 0 {
                if current % 10 == 7 {
                    count += 1
                }
                current /= 10
            }
        }
    }
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fizz_buzz(n: 50) == 0)
assert(fizz_buzz(n: 78) == 2)
assert(fizz_buzz(n: 79) == 3)
assert(fizz_buzz(n: 100) == 3)
assert(fizz_buzz(n: 200) == 6)
assert(fizz_buzz(n: 4000) == 192)
assert(fizz_buzz(n: 10000) == 639)
assert(fizz_buzz(n: 100000) == 8026)"
HumanEval_37,sin_Sinh,swift,"
// l හි සම දර්ශකවල අගයන් වෙත, නමුත් වර්ග කර ඇත. // l' අමුතු දර්ශක වලදී l හා සමාන වන අතර, සම දර්ශක වලදී එහි අගයන් සමාන වේ // මේ function එක array එකක් ගන්නවා l සහ array එකක් දෙනවා l' එවැනි /// >>> sort_even(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_even(l: [5, 6, 3, 4])
/// [3, 6, 5, 4]
func sort_even(l: [Int]) -> [Int] {
","func sort_even(l: [Int]) -> [Int] {
    var evenIndicesValues = [Int]()
    
    // Collect values from even indices
    for (index, value) in l.enumerated() {
        if index % 2 == 0 {
            evenIndicesValues.append(value)
        }
    }
    
    // Sort the collected even indices values
    evenIndicesValues.sort()
    
    var result = l
    var evenIndex = 0
    
    // Replace even-indexed elements in result with sorted values
    for i in 0..<result.count {
        if i % 2 == 0 {
            result[i] = evenIndicesValues[evenIndex]
            evenIndex += 1
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])
assert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
HumanEval_39,sin_Sinh,swift,"
// prime_fib නැවත n- වන සංඛ් යාවක් ලබා දෙයි එය ෆිබොනාච්චි සංඛ් යාවක් වන අතර එය ප් රාථමික වේ. /// >>> prime_fib(n: 1)
/// 2
/// >>> prime_fib(n: 2)
/// 3
/// >>> prime_fib(n: 3)
/// 5
/// >>> prime_fib(n: 4)
/// 13
/// >>> prime_fib(n: 5)
/// 89
func prime_fib(n: Int) -> Int {
","func isPrime(_ num: Int) -> Bool {
    if num <= 1 { return false }
    if num <= 3 { return true }
    if num % 2 == 0 || num % 3 == 0 { return false }
    var i = 5
    while i * i <= num {
        if num % i == 0 || num % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}

func generateFibonacci(n: Int) -> [Int] {
    var fibs = [1, 2]
    var next = fibs[0] + fibs[1]
    while fibs.count < n || !isPrime(next) {
        fibs.append(next)
        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]
    }
    return fibs
}

func prime_fib(n: Int) -> Int {
    var count = 0
    var fibs = generateFibonacci(n: n)
    for fib in fibs {
        if isPrime(fib) {
            count += 1
            if count == n {
                return fib
            }
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_fib(n: 1) == 2)
assert(prime_fib(n: 2) == 3)
assert(prime_fib(n: 3) == 5)
assert(prime_fib(n: 4) == 13)
assert(prime_fib(n: 5) == 89)
assert(prime_fib(n: 6) == 233)
assert(prime_fib(n: 7) == 1597)
assert(prime_fib(n: 8) == 28657)
assert(prime_fib(n: 9) == 514229)
assert(prime_fib(n: 10) == 433494437)"
HumanEval_40,sin_Sinh,swift,"
//එකතුව 0 ට, අනෙක් ඒවා බොරු.// එය true නැවත ලබා දෙයි අරාවෙහි  වෙනම අංග තුනක් තිබේ නම්// triples_sum_to_zero එක පූර්ණ සංඛ් යා අරාවකට ආදානය කරනවා./// >>> triples_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(l: [1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(l: [1])
/// false
func triples_sum_to_zero(l: [Int]) -> Bool {
","func triples_sum_to_zero(l: [Int]) -> Bool {
    let count = l.count
    if count < 3 {
        return false
    }
    
    let sortedArray = l.sorted()
    
    for i in 0..<count - 2 {
        var left = i + 1
        var right = count - 1
        
        while left < right {
            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]
            if currentSum == 0 {
                return true
            } else if currentSum < 0 {
                left += 1
            } else {
                right -= 1
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)
assert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)
assert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)
assert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)
assert(triples_sum_to_zero(l: [1]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)
assert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"
HumanEval_41,sin_Sinh,swift,"
// මේ ක් රියාකාරීත්වය මගින් එවැනි ගැටීම් ගණන ප් රතිදානය කරනවා. // ඔවුන් ගැටී නැති වගෙ ඔවුන්ගේ ගමන් මග තුල. // කෙසේ වෙතත්, කාර් අනන්තය ශක්තිමත් සහ ශක්තිමත්; ප්රතිඵලයක් ලෙස, ඔවුන් දිගටම ගමන් // වමට දකුණට යන කාර් එකක් දකුණට වමට යන කාර් එකකට හැප්පෙනව.හැම කාර් එකක්ම එකම වේගයෙන් යනවා.වාහන දෙකේම ආරම්භය තියෙන්නේ ගොඩක් දුරින්.වාහන n ක් වමේ සිට දකුණට ධාවනය වෙනවා. එකවරම, වාහන n කින් සමන්විත වෙනස් කට්ටලයක්.// සිතන්න පාරක් කියලා ඒක සම්පූර්ණයෙන්ම කෙළින් අනන්ත දිග රේඛාවක් කියලා.func car_race_collision(n: Int) -> Int {
","func car_race_collision(n: Int) -> Int {
    return n
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(car_race_collision(n: 2) == 4)
assert(car_race_collision(n: 3) == 9)
assert(car_race_collision(n: 4) == 16)
assert(car_race_collision(n: 8) == 64)
assert(car_race_collision(n: 10) == 100)"
HumanEval_42,sin_Sinh,swift,"
// 1 කින් වැඩි කරන ලද අංග සහිත අරාව නැවත ලබා දෙන්න./// >>> incr_list(l: [1, 2, 3])
/// [2, 3, 4]
/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [6, 4, 6, 3, 4, 4, 10, 1, 124]
func incr_list(l: [Int]) -> [Int] {
","func incr_list(l: [Int]) -> [Int] {
    return l.map { $0 + 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(incr_list(l: [] as [Int]) == [] as [Int])
assert(incr_list(l: [3, 2, 1]) == [4, 3, 2])
assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
HumanEval_43,sin_Sinh,swift,"
//එකතුව 0 ට, අනෙක් ඒවා බොරු.// එය true නැවත ලබා දෙයි අරාවෙහි වෙනම අංග දෙකක් තිබේ නම් // pairs_sum_to_zero එක පූර්ණ සංඛ් යා අරාවක ආදානයක් ලෙස ගනී./// >>> pairs_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(l: [1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(l: [1])
/// false
func pairs_sum_to_zero(l: [Int]) -> Bool {
","func pairs_sum_to_zero(l: [Int]) -> Bool {
    var set = Set<Int>()
    for num in l {
        if set.contains(-num) {
            return true
        }
        set.insert(num)
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)
assert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)
assert(pairs_sum_to_zero(l: [1]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"
HumanEval_44,sin_Sinh,swift,"
// මූලික සංඛ් යා 10 ට වඩා අඩුයි. // පරිවර්තනයෙන් පසු string නියෝජනය නැවත ලබාදෙනවා.// x අංකය අංකයට වෙනස් කරන්න./// >>> change_base(x: 8, base: 3)
/// ""22""
/// >>> change_base(x: 8, base: 2)
/// ""1000""
/// >>> change_base(x: 7, base: 2)
/// ""111""
func change_base(x: Int, base: Int) -> String {
","func change_base(x: Int, base: Int) -> String {
    guard base > 1 && base < 10 else {
        return """"
    }
    
    var number = x
    var result = """"
    
    repeat {
        let remainder = number % base
        result = ""\(remainder)"" + result
        number /= base
    } while number > 0
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(change_base(x: 8, base: 3) == ""22"")
assert(change_base(x: 9, base: 3) == ""100"")
assert(change_base(x: 234, base: 2) == ""11101010"")
assert(change_base(x: 16, base: 2) == ""10000"")
assert(change_base(x: 8, base: 2) == ""1000"")
assert(change_base(x: 7, base: 2) == ""111"")
assert(change_base(x: 2, base: 3) == ""2"")
assert(change_base(x: 3, base: 4) == ""3"")
assert(change_base(x: 4, base: 5) == ""4"")
assert(change_base(x: 5, base: 6) == ""5"")
assert(change_base(x: 6, base: 7) == ""6"")
assert(change_base(x: 7, base: 8) == ""7"")"
HumanEval_45,sin_Sinh,swift,"
// ත් රිකෝණයක පැති වල දිග සහ ඉහළ ප් රදේශය ලබා දී ඇත./// >>> triangle_area(a: 5, h: 3)
/// 7.5
func triangle_area(a: Int, h: Int) -> Double {
","func triangle_area(a: Int, h: Int) -> Double {
    return 0.5 * Double(a) * Double(h)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 5, h: 3) == 7.5)
assert(triangle_area(a: 2, h: 2) == 2.0)
assert(triangle_area(a: 10, h: 8) == 40.0)"
HumanEval_46,sin_Sinh,swift,"
කරුණාකර fib4 අංක අනුක් රමයේ n වන අංගය කාර්යක්ෂමව ගණනය කිරීම සඳහා ශ් රිතයක් ලියන්න. පුනරාවර්තනය භාවිතා නොකරන්න.// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). // පීඩනය 4..3) -> 0 // පණ 4 න් 2 න් 2 න්// පීඩනය 4// ෆයිබර් 4 න් 0 ක් -> 0 // Fib4 අංක අනුක් රමය ෆිබොනාච්චි අනුක් රමය හා සමාන අනුක් රමයකි එය පහත පරිදි අර්ථ දක්වා ඇත: /// >>> fib4(n: 5)
/// 4
/// >>> fib4(n: 6)
/// 8
/// >>> fib4(n: 7)
/// 14
func fib4(n: Int) -> Int {
","func fib4(n: Int) -> Int {
    if n == 0 || n == 1 || n == 3 {
        return 0
    } else if n == 2 {
        return 2
    }
    
    var fibs = [0, 0, 2, 0]
    
    for i in 4...n {
        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]
        fibs.append(nextFib)
    }
    
    return fibs[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib4(n: 5) == 4)
assert(fib4(n: 8) == 28)
assert(fib4(n: 10) == 104)
assert(fib4(n: 12) == 386)"
HumanEval_47,sin_Sinh,swift,"
// අරාවෙහි ඇති මූලද් රව් යයන්ගේ මධ් යම අගය නැවත ලබා දෙන්න./// >>> median(l: [3, 1, 2, 4, 5])
/// 3
/// >>> median(l: [-10, 4, 6, 1000, 10, 20])
/// 15.0
func median(l: [Int]) -> Double {
","func median(l: [Int]) -> Double {
    let sorted = l.sorted()
    let count = sorted.count
    if count % 2 == 0 {
        return Double(sorted[count / 2 - 1] + sorted[count / 2]) / 2.0
    } else {
        return Double(sorted[count / 2])
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(median(l: [3, 1, 2, 4, 5]) == 3)
assert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)
assert(median(l: [5]) == 5)
assert(median(l: [6, 5]) == 5.5)
assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
HumanEval_48,sin_Sinh,swift,"
// ලබා දී ඇති string එක palindrome එකක්ද කියලා පරීක්ෂා කරනවා /// >>> is_palindrome(text: """")
/// true
/// >>> is_palindrome(text: ""aba"")
/// true
/// >>> is_palindrome(text: ""aaaaa"")
/// true
/// >>> is_palindrome(text: ""zbcd"")
/// false
func is_palindrome(text: String) -> Bool {
","func is_palindrome(text: String) -> Bool {
    return text == String(text.reversed())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: """") == true)
assert(is_palindrome(text: ""aba"") == true)
assert(is_palindrome(text: ""aaaaa"") == true)
assert(is_palindrome(text: ""zbcd"") == false)
assert(is_palindrome(text: ""xywyx"") == true)
assert(is_palindrome(text: ""xywyz"") == false)
assert(is_palindrome(text: ""xywzx"") == false)"
HumanEval_49,sin_Sinh,swift,"
// 2^n modulo p නැවත ලබා දෙන්න (අංක ගැන සැලකිලිමත් වන්න)./// >>> modp(n: 3, p: 5)
/// 3
/// >>> modp(n: 1101, p: 101)
/// 2
/// >>> modp(n: 0, p: 101)
/// 1
/// >>> modp(n: 3, p: 11)
/// 8
/// >>> modp(n: 100, p: 101)
/// 1
func modp(n: Int, p: Int) -> Int {
","func modp(n: Int, p: Int) -> Int {
    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(modp(n: 3, p: 5) == 3)
assert(modp(n: 1101, p: 101) == 2)
assert(modp(n: 0, p: 101) == 1)
assert(modp(n: 3, p: 11) == 8)
assert(modp(n: 100, p: 101) == 1)
assert(modp(n: 30, p: 5) == 4)
assert(modp(n: 31, p: 5) == 3)"
HumanEval_51,sin_Sinh,swift,"
// remove_vowels කියන්නේ ස්වර නැති string එකක් ගන්න, ඒවා නැති string එකක් ලබා දෙන function එකක්./// >>> remove_vowels(text: """")
/// """"
/// >>> remove_vowels(text: ""abcdef"")
/// ""bcdf""
/// >>> remove_vowels(text: ""aaaaa"")
/// """"
/// >>> remove_vowels(text: ""aaBAA"")
/// ""B""
/// >>> remove_vowels(text: ""zbcd"")
/// ""zbcd""
func remove_vowels(text: String) -> String {
","func remove_vowels(text: String) -> String {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    return String(text.filter { !vowels.contains($0) })
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_vowels(text: """") == """")
assert(remove_vowels(text: ""abcdef\nghijklm"") == ""bcdf\nghjklm"")
assert(remove_vowels(text: ""fedcba"") == ""fdcb"")
assert(remove_vowels(text: ""eeeee"") == """")
assert(remove_vowels(text: ""acBAA"") == ""cB"")
assert(remove_vowels(text: ""EcBOO"") == ""cB"")
assert(remove_vowels(text: ""ybcd"") == ""ybcd"")"
HumanEval_52,sin_Sinh,swift,"
// array එකේ සියලුම අංක threshold ට වඩා අඩු නම් true නැවත දෙන්න. /// >>> below_threshold(l: [1, 2, 4, 10], t: 100)
/// true
/// >>> below_threshold(l: [1, 20, 4, 10], t: 5)
/// false
func below_threshold(l: [Int], t: Int) -> Bool {
","func below_threshold(l: [Int], t: Int) -> Bool {
    for number in l {
        if number >= t {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)
assert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"
HumanEval_53,sin_Sinh,swift,"
// x සහ y අංක දෙක එකතු කරන්න /// >>> add(x: 2, y: 3)
/// 5
/// >>> add(x: 5, y: 7)
/// 12
func add(x: Int, y: Int) -> Int {
","func add(x: Int, y: Int) -> Int {
    return x + y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(x: 0, y: 1) == 1)
assert(add(x: 1, y: 0) == 1)
assert(add(x: 2, y: 3) == 5)
assert(add(x: 5, y: 7) == 12)
assert(add(x: 7, y: 5) == 12)"
HumanEval_54,sin_Sinh,swift,"
// වචන දෙකක අක්ෂර සමානද කියලා බලන්න./// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"")
/// true
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabc"")
/// true
/// >>> same_chars(s0: ""dddddddabc"", s1: ""abcd"")
/// true
/// >>> same_chars(s0: ""eabcd"", s1: ""dddddddabc"")
/// false
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabce"")
/// false
/// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"")
/// false
func same_chars(s0: String, s1: String) -> Bool {
","func same_chars(s0: String, s1: String) -> Bool {
    let set0 = Set(s0)
    let set1 = Set(s1)
    return set0 == set1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"") == true)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabc"") == true)
assert(same_chars(s0: ""dddddddabc"", s1: ""abcd"") == true)
assert(same_chars(s0: ""eabcd"", s1: ""dddddddabc"") == false)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabcf"") == false)
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"") == false)
assert(same_chars(s0: ""aabb"", s1: ""aaccc"") == false)"
HumanEval_55,sin_Sinh,swift,"
// n- වන ෆිබොනාච්චි අංකය ලබා දෙන්න. /// >>> fib(n: 10)
/// 55
/// >>> fib(n: 1)
/// 1
/// >>> fib(n: 8)
/// 21
func fib(n: Int) -> Int {
","func fib(n: Int) -> Int {
    if n <= 0 {
        return 0
    } else if n == 1 {
        return 1
    }
    
    var a = 0
    var b = 1
    for _ in 2...n {
        let temp = a + b
        a = b
        b = temp
    }
    return b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib(n: 10) == 55)
assert(fib(n: 1) == 1)
assert(fib(n: 8) == 21)
assert(fib(n: 11) == 89)
assert(fib(n: 12) == 144)"
HumanEval_56,sin_Sinh,swift,"
// සෑම විවෘත කිරීමේ කොටු සඳහාම අනුරූප වසා දැමීමේ කොටු තිබේ නම් true නැවත ලබා දෙන්න. // brackets කියන්නේ ""<"" සහ "">"" වලින් යුත් නූලක්./// >>> correct_bracketing(brackets: ""<"")
/// false
/// >>> correct_bracketing(brackets: ""<>"")
/// true
/// >>> correct_bracketing(brackets: ""<<><>>"")
/// true
/// >>> correct_bracketing(brackets: ""><<>"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    
    for bracket in brackets {
        if bracket == ""<"" {
            balance += 1
        } else if bracket == "">"" {
            balance -= 1
            if balance < 0 {
                return false
            }
        }
    }
    
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""<>"") == true)
assert(correct_bracketing(brackets: ""<<><>>"") == true)
assert(correct_bracketing(brackets: ""<><><<><>><>"") == true)
assert(correct_bracketing(brackets: ""<><><<<><><>><>><<><><<>>>"") == true)
assert(correct_bracketing(brackets: ""<<<><>>>>"") == false)
assert(correct_bracketing(brackets: ""><<>"") == false)
assert(correct_bracketing(brackets: ""<"") == false)
assert(correct_bracketing(brackets: ""<<<<"") == false)
assert(correct_bracketing(brackets: "">"") == false)
assert(correct_bracketing(brackets: ""<<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>><<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>>><>"") == false)"
HumanEval_57,sin_Sinh,swift,"
// true නැවත ලබාදෙන්නේ අරාවෙහි මූලද් රව් යයන් ඒකාකාරී ලෙස වැඩි වීම හෝ අඩු වීමයි./// >>> monotonic(l: [1, 2, 4, 20])
/// true
/// >>> monotonic(l: [1, 20, 4, 10])
/// false
/// >>> monotonic(l: [4, 1, 0, -10])
/// true
func monotonic(l: [Int]) -> Bool {
","func monotonic(l: [Int]) -> Bool {
    guard l.count > 1 else {
        return true
    }
    
    var increasing = true
    var decreasing = true
    
    for i in 1..<l.count {
        if l[i] > l[i - 1] {
            decreasing = false
        } else if l[i] < l[i - 1] {
            increasing = false
        }
    }
    
    return increasing || decreasing
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(monotonic(l: [1, 2, 4, 10]) == true)
assert(monotonic(l: [1, 2, 4, 20]) == true)
assert(monotonic(l: [1, 20, 4, 10]) == false)
assert(monotonic(l: [4, 1, 0, -10]) == true)
assert(monotonic(l: [4, 1, 1, 0]) == true)
assert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)
assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)
assert(monotonic(l: [9, 9, 9, 9]) == true)"
HumanEval_58,sin_Sinh,swift,"
// අරාවන් දෙකක් සඳහා වර්ග කළ අද්විතීය පොදු මූලද් රව් යයන් නැවත ලබා දෙන්න./// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])
/// [1, 5, 653]
/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])
/// [2, 3]
func common(l1: [Int], l2: [Int]) -> [Int] {
","func common(l1: [Int], l2: [Int]) -> [Int] {
    let set1 = Set(l1)
    let set2 = Set(l2)
    let commonElements = set1.intersection(set2)
    return Array(commonElements).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])
assert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])
assert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])
assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
HumanEval_59,sin_Sinh,swift,"
// n හි විශාලතම ප් රථම සාධකය ලබා දෙන්න. n > 1 යැයි උපකල්පනය කර ප් රථම අංකයක් නොවේ. /// >>> largest_prime_factor(n: 13195)
/// 29
/// >>> largest_prime_factor(n: 2048)
/// 2
func largest_prime_factor(n: Int) -> Int {
","func largest_prime_factor(n: Int) -> Int {
    var number = n
    var divisor = 2
    
    while number > 1 {
        if number % divisor == 0 {
            number /= divisor
        } else {
            divisor += 1
        }
    }
    
    return divisor
}

// Example usage:
// print(largest_prime_factor(n: 13195)) // Output: 29
// print(largest_prime_factor(n: 2048))  // Output: 2","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_prime_factor(n: 15) == 5)
assert(largest_prime_factor(n: 27) == 3)
assert(largest_prime_factor(n: 63) == 7)
assert(largest_prime_factor(n: 330) == 11)
assert(largest_prime_factor(n: 13195) == 29)"
HumanEval_60,sin_Sinh,swift,"
// sum_to_n කියන්නේ 1 සිට n දක්වා අංක එකතු කරන ශ් රිතයක්. /// >>> sum_to_n(n: 30)
/// 465
/// >>> sum_to_n(n: 100)
/// 5050
/// >>> sum_to_n(n: 5)
/// 15
/// >>> sum_to_n(n: 10)
/// 55
/// >>> sum_to_n(n: 1)
/// 1
func sum_to_n(n: Int) -> Int {
","func sum_to_n(n: Int) -> Int {
    return (n * (n + 1)) / 2
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_to_n(n: 1) == 1)
assert(sum_to_n(n: 6) == 21)
assert(sum_to_n(n: 11) == 66)
assert(sum_to_n(n: 30) == 465)
assert(sum_to_n(n: 100) == 5050)"
HumanEval_61,sin_Sinh,swift,"
// සෑම විවෘත කිරීමේ කොටු සඳහාම අනුරූප වසා දැමීමේ කොටු තිබේ නම් true නැවත ලබා දෙන්න. // brackets කියන්නේ ""("" සහ """") කියන string එක./// >>> correct_bracketing(brackets: ""("")
/// false
/// >>> correct_bracketing(brackets: ""()"")
/// true
/// >>> correct_bracketing(brackets: ""(()())"")
/// true
/// >>> correct_bracketing(brackets: "")(()"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    for char in brackets {
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""()"") == true)
assert(correct_bracketing(brackets: ""(()())"") == true)
assert(correct_bracketing(brackets: ""()()(()())()"") == true)
assert(correct_bracketing(brackets: ""()()((()()())())(()()(()))"") == true)
assert(correct_bracketing(brackets: ""((()())))"") == false)
assert(correct_bracketing(brackets: "")(()"") == false)
assert(correct_bracketing(brackets: ""("") == false)
assert(correct_bracketing(brackets: ""(((("") == false)
assert(correct_bracketing(brackets: "")"") == false)
assert(correct_bracketing(brackets: ""(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())())(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())()))()"") == false)"
HumanEval_62,sin_Sinh,swift,"
// මේ බහුපදයේ ඩිරයිවිට් එක එකම ආකාරයෙන් ලබා දෙන්න.// xs[0] + xs[1] * x + xs[2] * x^2 + .... // xs යනු බහුපදයක සංගුණකයන්. /// >>> derivative(xs: [3, 1, 2, 4, 5])
/// [1, 4, 12, 20]
/// >>> derivative(xs: [1, 2, 3])
/// [2, 6]
func derivative(xs: [Int]) -> [Int] {
","func derivative(xs: [Int]) -> [Int] {
    guard xs.count > 1 else { return [] }
    var result: [Int] = []
    for i in 1..<xs.count {
        result.append(xs[i] * i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])
assert(derivative(xs: [1, 2, 3]) == [2, 6])
assert(derivative(xs: [3, 2, 1]) == [2, 2])
assert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])
assert(derivative(xs: [1]) == [] as [Int])"
HumanEval_63,sin_Sinh,swift,"
// කරුණාකර fibfib අංක අනුක් රමයේ n වන අංගය කාර්යක්ෂමව ගණනය කිරීම සඳහා ශ් රිතයක් ලියන්න. // fib fib (n) == fib fib (n-1) + fib fib (n-2) + fib fib (n-3). // ෆිෆිෆිෆිෆිෆිෆිෆිෆිෆිෆිෆිෆි// ෆිෆිෆිෆිෆිෆිෆිෆිෆිෆිෆිෆිෆි// ෆිෆිෆිෆිෆිෆිෆිෆිෆිෆිෆි// FibFib අංක අනුක් රමය ෆිබොනාච්චි අනුක් රමය හා සමාන අනුක් රමයකි එය පහත පරිදි අර්ථ දක්වා ඇත: /// >>> fibfib(n: 1)
/// 0
/// >>> fibfib(n: 5)
/// 4
/// >>> fibfib(n: 8)
/// 24
func fibfib(n: Int) -> Int {
","func fibfib(n: Int) -> Int {
    if n == 0 || n == 1 {
        return 0
    }
    if n == 2 {
        return 1
    }
    
    var fibfibNums = [0, 0, 1]
    
    for i in 3...n {
        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]
        fibfibNums.append(nextFibFib)
    }
    
    return fibfibNums[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fibfib(n: 2) == 1)
assert(fibfib(n: 1) == 0)
assert(fibfib(n: 5) == 4)
assert(fibfib(n: 8) == 24)
assert(fibfib(n: 10) == 81)
assert(fibfib(n: 12) == 274)
assert(fibfib(n: 14) == 927)"
HumanEval_64,sin_Sinh,swift,"
// උදාහරණය: // ඒකාකාරී, නමුත් එය ලබා දී ඇති වචනයේ අවසානයේදී පමණි.// මෙහි ස්වරය 'a', 'e', 'i', 'o', 'u' මෙහි 'y' ද a // වචනයක් ආදානය කරලා ඒකේ තියෙන ස්වර ගණන ආපහු එවනවා.// vowels_count කියන ෆන්ක්ශන් එක ලියන්න. ඒකෙ  නියෝජනය කරන නූල /// >>> vowels_count(s: ""abcde"")
/// 2
/// >>> vowels_count(s: ""ACEDY"")
/// 3
func vowels_count(s: String) -> Int {
","func vowels_count(s: String) -> Int {
    guard !s.isEmpty else { return 0 }
    
    let vowels = Set(""aeiouAEIOU"")
    var count = 0
    let characters = Array(s)
    
    for i in 0..<characters.count {
        let char = characters[i]
        
        if vowels.contains(char) {
            count += 1
        } else if char == ""y"" || char == ""Y"" {
            if i == characters.count - 1 {
                count += 1
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(vowels_count(s: ""abcde"") == 2)
assert(vowels_count(s: ""Alone"") == 3)
assert(vowels_count(s: ""key"") == 2)
assert(vowels_count(s: ""bye"") == 1)
assert(vowels_count(s: ""keY"") == 2)
assert(vowels_count(s: ""bYe"") == 1)
assert(vowels_count(s: ""ACEDY"") == 3)"
HumanEval_65,sin_Sinh,swift,"
// shift > අංක ගණන නම්, ආපසු අංක ආපසු හරවනවා. // ප් රතිඵලය string එකක් විදියට දෙන්න.// සර්කියුලර් x හි ඉලක්කම් මාරු කරන්න, ඉලක්කම් මාරු කිරීමෙන් දකුණට මාරු කරන්න /// >>> circular_shift(x: 12, shift: 1)
/// ""21""
/// >>> circular_shift(x: 12, shift: 2)
/// ""12""
func circular_shift(x: Int, shift: Int) -> String {
","func circular_shift(x: Int, shift: Int) -> String {
    let digits = Array(String(x))
    let count = digits.count
    
    // If shift is greater than the number of digits, return the digits reversed
    if shift >= count {
        return String(digits.reversed())
    }
    
    // Calculate the actual shift needed by using modulo operation
    let actualShift = shift % count
    
    // Perform the circular shift to the right
    let splitIndex = count - actualShift
    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]
    
    return String(shiftedDigits)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(circular_shift(x: 100, shift: 2) == ""001"")
assert(circular_shift(x: 12, shift: 2) == ""12"")
assert(circular_shift(x: 97, shift: 8) == ""79"")
assert(circular_shift(x: 12, shift: 1) == ""21"")
assert(circular_shift(x: 11, shift: 101) == ""11"")"
HumanEval_66,sin_Sinh,swift,"
// උදාහරණ: // ASCII කේත. // ශ් රිතයක් ලියන්න ඒකෙන් string එකක් input කරලා උඩින් තියෙන අකුරු වල එකතුව විතරයි ආපහු එවන්නේ.- කාර්යය/// >>> digitSum(s: """")
/// 0
/// >>> digitSum(s: ""abAB"")
/// 131
/// >>> digitSum(s: ""abcCd"")
/// 67
/// >>> digitSum(s: ""helloE"")
/// 69
/// >>> digitSum(s: ""woArBld"")
/// 131
/// >>> digitSum(s: ""aAaaaXa"")
/// 153
func digitSum(s: String) -> Int {
","func digitSum(s: String) -> Int {
    var sum = 0
    for character in s {
        if character.isUppercase {
            sum += Int(character.asciiValue ?? 0)
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: """") == 0)
assert(digitSum(s: ""abAB"") == 131)
assert(digitSum(s: ""abcCd"") == 67)
assert(digitSum(s: ""helloE"") == 69)
assert(digitSum(s: ""woArBld"") == 131)
assert(digitSum(s: ""aAaaaXa"") == 153)
assert(digitSum(s: "" How are yOu?"") == 151)
assert(digitSum(s: ""You arE Very Smart"") == 327)"
HumanEval_67,sin_Sinh,swift,"
// විවරණය සඳහා: // කරත්තයේ තියෙන අඹ ගෙඩි ගණන නැවත ලබා දෙන්න.තැඹිලි සහ ඇපල් සහ ඵලවල මුළු සංඛ් යාව නියෝජනය කරන සම්පූර්ණ සංඛ් යාවක්.ඇපල්, තැඹිලි සහ මංගෝ පලතුරු.// මේ පලතුරු කූඩයට බෙදා හරිනවා. මේ කූඩයට පලතුරු තියෙනවා.// මේ වැඩේට ඔයාට ඇපල් සහ තැඹිලි ගණනාවක නියෝජනය කරන නූලක් ලැබෙනවා./// >>> fruit_distribution(s: ""5 apples and 6 oranges"", n: 19)
/// 8
/// >>> fruit_distribution(s: ""0 apples and 1 oranges"", n: 3)
/// 2
/// >>> fruit_distribution(s: ""2 apples and 3 oranges"", n: 100)
/// 95
/// >>> fruit_distribution(s: ""100 apples and 1 oranges"", n: 120)
/// 19
func fruit_distribution(s: String, n: Int) -> Int {
","func fruit_distribution(s: String, n: Int) -> Int {
    let components = s.components(separatedBy: "" "")
    var apples = 0
    var oranges = 0
    
    for (index, component) in components.enumerated() {
        if component == ""apples"" || component == ""apple"" {
            if let number = Int(components[index - 1]) {
                apples = number
            }
        } else if component == ""oranges"" || component == ""orange"" {
            if let number = Int(components[index - 1]) {
                oranges = number
            }
        }
    }
    
    let totalApplesOranges = apples + oranges
    let mangoes = n - totalApplesOranges
    return mangoes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 19) == 8)
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 21) == 10)
assert(fruit_distribution(s: ""0 apples and 1 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""1 apples and 0 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 100) == 95)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 5) == 0)
assert(fruit_distribution(s: ""1 apples and 100 oranges"", n: 120) == 19)"
HumanEval_68,sin_Sinh,swift,"
// උදාහරණය 1:// අගයන් සම නොවන විට හෝ ලබා දී ඇති අරාව හිස් නම්, නැවත [] ලබා දෙන්න. // අහුලන ලද නෝඩය අරාවකින් ආපසු ලබා දිය යුතුයි, [smallest_value, එහි දර්ශකය], // එකම කුඩාම අගය සහිත නෝඩ් කිහිපයක් සොයාගනු ලැබුවහොත් කුඩාම දර්ශකය සහිත නෝඩ් එක නැවත ලබා දෙන්න. // අහුලන ලද නෝඩය කුඩාම සම අගය සහිත නෝඩය විය යුතුයි.// ඔයාගේ වැඩේ තමයි එක නෝඩයක් අයින් කරලා ඒක ආපහු දමන්න.// ""නො-නොසෘජු පූර්ණ සංඛ් යා නෝඩ් ඇති ගසක ශාඛාවක් නියෝජනය කරන අරාව ලබා දී ඇත /// >>> pluck(arr: [4, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(arr: [1, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(arr: [] as [Int])
/// [] as [Int]
/// Example 4:
/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])
/// [0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
func pluck(arr: [Int]) -> [Int] {
","func pluck(arr: [Int]) -> [Int] {
    var smallestEvenValue: Int? = nil
    var smallestIndex: Int? = nil

    for (index, value) in arr.enumerated() {
        if value % 2 == 0 {
            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {
                smallestEvenValue = value
                smallestIndex = index
            }
        }
    }

    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {
        return [smallestEvenValue, smallestIndex]
    } else {
        return []
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pluck(arr: [4, 2, 3]) == [2, 1])
assert(pluck(arr: [1, 2, 3]) == [2, 1])
assert(pluck(arr: [] as [Int]) == [] as [Int])
assert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])
assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])
assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])
assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])
assert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
HumanEval_69,sin_Sinh,swift,"
// උදාහරණ: // එවැනි අගයක් නොමැති නම්, -1 නැවත ලබා දෙන්න.// පූර්ණ සංඛ් යාතයක සංඛ් යාතය යනු එය අරාව තුළ දිස්වන වාර ගණනයි.// ශුන් ය, සහ සංඛ් යාතය, සම්පූර්ණ සංඛ් යාතයේ අගයකට වඩා වැඩි හෝ සමාන වේ. ඔබට ධනාත්මක පූර්ණ සංඛ් යා වලින් සමන්විත හිස් නොවන අරාවක් ලබා දී ඇත.  ට වඩා විශාලතම පූර්ණ සංඛ් යාව නැවත ලබා දෙන්න./// >>> search(lst: [4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(lst: [5, 5, 4, 4, 4])
/// -1
func search(lst: [Int]) -> Int {
","func search(lst: [Int]) -> Int {
    var frequencyMap = [Int: Int]()
    
    // Count frequencies of each number in the list
    for number in lst {
        frequencyMap[number, default: 0] += 1
    }
    
    var result = -1
    
    // Iterate through the frequency map to find the greatest integer that satisfies the condition
    for (number, frequency) in frequencyMap {
        if frequency >= number {
            result = max(result, number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(search(lst: [5, 5, 5, 5, 1]) == 1)
assert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)
assert(search(lst: [3, 3]) == -1)
assert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)
assert(search(lst: [2, 3, 3, 2, 2]) == 2)
assert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)
assert(search(lst: [3, 2, 8, 2]) == 2)
assert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)
assert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)
assert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)
assert(search(lst: [1, 9, 10, 1, 3]) == 1)
assert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)
assert(search(lst: [1]) == 1)
assert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)
assert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)
assert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)
assert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)
assert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)
assert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)
assert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)
assert(search(lst: [10]) == -1)
assert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)
assert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)
assert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)
assert(search(lst: [3, 10, 10, 9, 2]) == -1)"
HumanEval_70,sin_Sinh,swift,"
// උදාහරණ: //ඉතිං ඉතුරු ඉලක්කම් වලින් උපරිම එක, ඊට පස්සේ අවම එක, ආදී වශයෙන්.// අමුතු වර්ග කිරීම, ඔබ අවම අගය සමග ආරම්භ විට, // සම්පූර්ණ සංඛ් යා අරාව ලබා දීලා, අමුතු පිළිවෙලකට අරාව නැවත ලබා දෙන්න./// >>> strange_sort_list(lst: [1, 2, 3, 4])
/// [1, 4, 2, 3]
/// >>> strange_sort_list(lst: [5, 5, 5, 5])
/// [5, 5, 5, 5]
/// >>> strange_sort_list(lst: [] as [Int])
/// [] as [Int]
func strange_sort_list(lst: [Int]) -> [Int] {
","func strange_sort_list(lst: [Int]) -> [Int] {
    var sortedList = lst.sorted()
    var result: [Int] = []
    
    while !sortedList.isEmpty {
        if let min = sortedList.first {
            result.append(min)
            sortedList.removeFirst()
        }
        
        if let max = sortedList.last {
            result.append(max)
            sortedList.removeLast()
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])
assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])
assert(strange_sort_list(lst: [] as [Int]) == [] as [Int])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])
assert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])
assert(strange_sort_list(lst: [111111]) == [111111])"
HumanEval_71,sin_Sinh,swift,"
// උදාහරණය: // තුන්වෙනි පැත්තට වඩා.// ඕනෑම දෙපැත්තක එකතුව වැඩි නම් ත් රිකෝණයක පැති තුනක් වලංගු වේ.// එහෙම නැත්නම් -1  කියලා දෙන්න// ත් රිකෝණය දශම අංක 2 ක් දක්වා වටකරයි, ත් රිකෝණයේ පැති තුනම ත් රිකෝණයක් නම්.ත් රිකෝණයක පැති තුනක දිග ලබා දීලා,                                 /// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
","func triangle_area(a: Int, b: Int, c: Int) -> Double {
    // Check if the sides form a valid triangle
    if a + b > c && a + c > b && b + c > a {
        // Calculate the semi-perimeter
        let s = Double(a + b + c) / 2.0
        // Calculate the area using Heron's formula
        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
        // Round to 2 decimal places
        return round(area * 100) / 100
    } else {
        return -1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)"
HumanEval_72,sin_Sinh,swift,"
// උදාහරණය: // q වස්තුව පියාඹනවා ඒක සමබර නම් (එය පැලින්ඩ් රෝමික් අරාවකි) සහ එහි මූලද් රව් යවල එකතුව උපරිම හැකි බර w ට වඩා අඩු හෝ සමාන නම්.// q වස්තුව පියාසර කරන්නේ නම් true සහ වෙනත් ආකාරයකින් false ලබා දෙන ශ් රිතයක් ලියන්න. /// >>> will_it_fly(q: [1, 2], w: 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(q: [3, 2, 3], w: 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(q: [3, 2, 3], w: 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(q: [3], w: 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q: [Int], w: Int) -> Bool {
","func will_it_fly(q: [Int], w: Int) -> Bool {
    func isPalindromic(_ array: [Int]) -> Bool {
        return array == array.reversed()
    }
    
    let sum = q.reduce(0, +)
    return isPalindromic(q) && sum <= w
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(will_it_fly(q: [3, 2, 3], w: 9) == true)
assert(will_it_fly(q: [1, 2], w: 5) == false)
assert(will_it_fly(q: [3], w: 5) == true)
assert(will_it_fly(q: [3, 2, 3], w: 1) == false)
assert(will_it_fly(q: [1, 2, 3], w: 6) == false)
assert(will_it_fly(q: [5], w: 5) == true)"
HumanEval_73,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// එක වෙනස් කිරීමකින්, ඔබට එක අංගයක් වෙනත් අංගයකට වෙනස් කළ හැකිය.// අරාව පැලින්ඩ් රෝමික් බවට පත් කිරීම සඳහා වෙනස් කළ යුතුය.// පූර්ණ සංඛ් යා arr ලබා දී ඇති විට, /// >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(arr: [1, 2, 3, 2, 1])
/// 0
func smallest_change(arr: [Int]) -> Int {
","func smallest_change(arr: [Int]) -> Int {
    var changes = 0
    let n = arr.count

    for i in 0..<(n / 2) {
        if arr[i] != arr[n - i - 1] {
            changes += 1
        }
    }

    return changes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)
assert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)
assert(smallest_change(arr: [1, 4, 2]) == 1)
assert(smallest_change(arr: [1, 4, 4, 2]) == 1)
assert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)
assert(smallest_change(arr: [3, 1, 1, 3]) == 0)
assert(smallest_change(arr: [1]) == 0)
assert(smallest_change(arr: [0, 1]) == 1)"
HumanEval_74,sin_Sinh,swift,"
// උදාහරණ // අරාවල අක්ෂර ගණන සමාන නම්, පළමු අරාව නැවත ලබා දෙන්න.// අරාවෙ තියෙන හැම string එකකම තියෙන chars වල මුළු ගණන අනිත් array එකට වඩා අඩුයි.// අක්ෂර මාලා දෙකක් පිළිගන්නා සහ  අක්ෂර මාලාව ලබාදෙන ශ් රිතයක් ලියන්න/// >>> total_match(lst1: [] as [String], lst2: [] as [String])
/// [] as [String]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""])
/// [""hI"", ""Hi""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""])
/// [""hi"", ""admin""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""])
/// [""hI"", ""hi"", ""hi""]
/// >>> total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""])
/// [""4""]
func total_match(lst1: [String], lst2: [String]) -> [String] {
","func total_match(lst1: [String], lst2: [String]) -> [String] {
    let totalChars1 = lst1.reduce(0) { $0 + $1.count }
    let totalChars2 = lst2.reduce(0) { $0 + $1.count }
    
    if totalChars1 < totalChars2 {
        return lst1
    } else if totalChars2 < totalChars1 {
        return lst2
    } else {
        return lst1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi""]) == [""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""]) == [""hi"", ""admin""])
assert(total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""]) == [""4""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""]) == [""hI"", ""Hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""]) == [""hI"", ""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hii""]) == [""hi"", ""admin""])
assert(total_match(lst1: [] as [String], lst2: [""this""]) == [] as [String])
assert(total_match(lst1: [""this""], lst2: [] as [String]) == [] as [String])"
HumanEval_75,sin_Sinh,swift,"
// උදාහරණය: // (a) 100 ට වඩා අඩු බව දැනගෙන. // ඒ වගේම වැරදි. // ලබා දී ඇති අංකය ප් රාථමික අංක 3 ක ගුණ කිරීමක් නම් true ලෙස ලබා දෙන ශ් රිතයක් ලියන්න /// >>> is_multiply_prime(a: 30)
/// true
/// 30 = 2 * 3 * 5
func is_multiply_prime(a: Int) -> Bool {
","func is_multiply_prime(a: Int) -> Bool {
    // Function to check if a number is prime
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Generate all prime numbers less than 100
    var primes = [Int]()
    for i in 2..<100 {
        if isPrime(i) {
            primes.append(i)
        }
    }
    
    // Check combinations of 3 primes
    let primeCount = primes.count
    for i in 0..<primeCount {
        for j in i..<primeCount {
            for k in j..<primeCount {
                if primes[i] * primes[j] * primes[k] == a {
                    return true
                }
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_multiply_prime(a: 5) == false)
assert(is_multiply_prime(a: 30) == true)
assert(is_multiply_prime(a: 8) == true)
assert(is_multiply_prime(a: 10) == false)
assert(is_multiply_prime(a: 125) == true)
assert(is_multiply_prime(a: 105) == true)
assert(is_multiply_prime(a: 126) == false)
assert(is_multiply_prime(a: 729) == false)
assert(is_multiply_prime(a: 891) == false)
assert(is_multiply_prime(a: 1001) == true)"
HumanEval_76,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// x යනු n හි සරල බලයකි n**int=x // n වල බලය සහ අනෙක් අවස්ථාවලදී අසත් ය වේ.// ඔයාගේ වැඩේ තමයි අංකයක් x සරල නම් true නැවත ලබා දෙන ශ් රිතයක් ලිවීම./// >>> is_simple_power(x: 1, n: 4)
/// true
/// >>> is_simple_power(x: 2, n: 2)
/// true
/// >>> is_simple_power(x: 8, n: 2)
/// true
/// >>> is_simple_power(x: 3, n: 2)
/// false
/// >>> is_simple_power(x: 3, n: 1)
/// false
/// >>> is_simple_power(x: 5, n: 3)
/// false
func is_simple_power(x: Int, n: Int) -> Bool {
","func is_simple_power(x: Int, n: Int) -> Bool {
    if x < 1 || n < 1 {
        return false
    }
    if x == 1 {
        return true // n**0 = 1
    }
    var power = 1
    while power < x {
        power *= n
    }
    return power == x
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_simple_power(x: 16, n: 2) == true)
assert(is_simple_power(x: 143214, n: 16) == false)
assert(is_simple_power(x: 4, n: 2) == true)
assert(is_simple_power(x: 9, n: 3) == true)
assert(is_simple_power(x: 16, n: 4) == true)
assert(is_simple_power(x: 24, n: 2) == false)
assert(is_simple_power(x: 128, n: 4) == false)
assert(is_simple_power(x: 12, n: 6) == false)
assert(is_simple_power(x: 1, n: 1) == true)
assert(is_simple_power(x: 1, n: 12) == true)"
HumanEval_77,sin_Sinh,swift,"
// උදාහරණ: // සටහන: ඔබ උපකල්පනය කල හැකියි ඇතුලත් කිරීම සැමවිටම වලංගු වේ.// මේ ඉංජර් එක යම්කිසි නිරපේක්ෂ සංඛ් යාවක ඝනකයක් නම්. // සම්පූර්ණ සංඛ් යාවක් ගන්නා සහ true නැවත ලබාදෙන ශ් රිතයක් ලියන්න./// >>> iscube(a: 1)
/// true
/// >>> iscube(a: 2)
/// false
/// >>> iscube(a: -1)
/// true
/// >>> iscube(a: 64)
/// true
/// >>> iscube(a: 0)
/// true
/// >>> iscube(a: 180)
/// false
func iscube(a: Int) -> Bool {
","func iscube(a: Int) -> Bool {
    if a == 0 { return true } // 0 is a cube (0^3)
    let absA = abs(a)
    let cubeRoot = Int(round(pow(Double(absA), 1.0/3.0)))
    return cubeRoot * cubeRoot * cubeRoot == absA
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(iscube(a: 1) == true)
assert(iscube(a: 2) == false)
assert(iscube(a: -1) == true)
assert(iscube(a: 64) == true)
assert(iscube(a: 180) == false)
assert(iscube(a: 1000) == true)
assert(iscube(a: 0) == true)
assert(iscube(a: 1729) == false)"
HumanEval_78,sin_Sinh,swift,"
// උදාහරණ: // ඒ වගේම A,B,C,D,E,F සංකේත හැමවෙලේම ලොකු අකුරින් ලියලා තියෙනවා.// සටහන: ඔබ උපකල්පනය කල හැකිය ආදානය සෑම විටම නිවැරදි හෝ හිස් නූල්, // බී (= දශම 11), ඩී (= දශම 13).// ඉතින් ඔයාලට පහත අංක වලින් එකක් හොයාගන්න වෙනවා: 2, 3, 5, 7, ප් රයිම් අංක 2, 3, 5, 7, 11, 13, 17...// හෙක්සඩෙසීමල් අංක 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. // 1 ට වඩා වැඩි නම් එය කුඩා ස්වාභාවික සංඛ් යා දෙකක ගුණයක් නොවේ).// ප් රයිම් අංක (ප් රයිම් අංකය, හෝ ප් රයිම්, ස්වභාවික අංකයක්)// හෙක්සඩෙසීමල් අංකයක් string එකක් විදියට ගණනය කරනවා හෙක්සඩෙසීමල් අංක ගණන // ඔබට ලැබුණු කාර්යය තමයි /// >>> hex_key(num: ""AB"")
/// 1
/// >>> hex_key(num: ""1077E"")
/// 2
/// >>> hex_key(num: ""ABED1A33"")
/// 4
/// >>> hex_key(num: ""123456789ABCDEF0"")
/// 6
/// >>> hex_key(num: ""2020"")
/// 2
func hex_key(num: String) -> Int {
","func hex_key(num: String) -> Int {
    // Define hexadecimal digits that are prime numbers
    let primeHexDigits: Set<Character> = [""2"", ""3"", ""5"", ""7"", ""B"", ""D""]
    
    // Initialize count
    var primeCount = 0
    
    // Iterate over each character in the string
    for char in num {
        // Check if the character is a prime hexadecimal digit
        if primeHexDigits.contains(char) {
            primeCount += 1
        }
    }
    
    return primeCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: ""AB"") == 1)
assert(hex_key(num: ""1077E"") == 2)
assert(hex_key(num: ""ABED1A33"") == 4)
assert(hex_key(num: ""2020"") == 2)
assert(hex_key(num: ""123456789ABCDEF0"") == 6)
assert(hex_key(num: ""112233445566778899AABBCCDDEEFF00"") == 12)"
HumanEval_79,sin_Sinh,swift,"
// උදාහරණ: // අතිරේක අක්ෂර ආකෘතියට උදව් කරන්න.// අක්ෂර මාලාවේ මුල සහ අවසානයේ අක්ෂර 'db' අකුරු දෙකක් එකතු වෙනවා.// අංකය. string එකේ හැම අක්ෂරයක්ම 0 හෝ 1 වෙයි.// ද්විමය ආකෘතිය. ශ් රිතය ද්විමය සංඛ් යාවක් නියෝජනය කරන සෑම අක්ෂරයක්ම සහිත නූලක් නැවත ලබා දිය යුතුය.// ඔබට දශම සංඛ් යාතයක් ලබා දෙනු ඇත ඔබේ කාර්යය එය  බවට පරිවර්තනය කිරීමයි/// >>> decimal_to_binary(decimal: 15)
/// ""db1111db""
/// >>> decimal_to_binary(decimal: 32)
/// ""db100000db""
func decimal_to_binary(decimal: Int) -> String {
","func decimal_to_binary(decimal: Int) -> String {
    let binaryString = String(decimal, radix: 2)
    return ""db"" + binaryString + ""db""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(decimal_to_binary(decimal: 0) == ""db0db"")
assert(decimal_to_binary(decimal: 32) == ""db100000db"")
assert(decimal_to_binary(decimal: 103) == ""db1100111db"")
assert(decimal_to_binary(decimal: 15) == ""db1111db"")"
HumanEval_80,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// අක්ෂර මාලාවක් හැප්ස්විෆ්ට් නම් එහි දිග අවම වශයෙන් 3 ක් නම් සහ සෑම අකුරු 3 ක්ම එකිනෙකට වෙනස් නම් // ඔයාගේ වැඩේ තමයි string එක hapswift ද නැද්ද කියලා පරීක්ෂා කරන එක.// ඔයාට string එකක් ලැබෙනවා./// >>> is_happy(s: ""a"")
/// false
/// >>> is_happy(s: ""aa"")
/// false
/// >>> is_happy(s: ""abcd"")
/// true
/// >>> is_happy(s: ""aabb"")
/// false
/// >>> is_happy(s: ""adb"")
/// true
/// >>> is_happy(s: ""xyy"")
/// false
func is_happy(s: String) -> Bool {
","func is_happy(s: String) -> Bool {
    let characters = Array(s)
    if characters.count < 3 {
        return false
    }
    
    for i in 0..<(characters.count - 2) {
        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_happy(s: ""a"") == false)
assert(is_happy(s: ""aa"") == false)
assert(is_happy(s: ""abcd"") == true)
assert(is_happy(s: ""aabb"") == false)
assert(is_happy(s: ""adb"") == true)
assert(is_happy(s: ""xyy"") == false)
assert(is_happy(s: ""iopaxpoi"") == true)
assert(is_happy(s: ""iopaxioi"") == false)"
HumanEval_81,sin_Sinh,swift,"
// උදාහරණය: // 0.0 E  කියලා// 0.0 D- // 0.7 ඩී // ඩී+ 1.3 සී- අංශක 1.7 ක්අංශක 2.0 ට වඩා වැඩි2.3 බී-// 2.7 B ට වඩා වැඩි// 3.0 B+ // 3.3 A- // 3.7 A // 4.0 A+ සාමාන් ය අකුරු ලකුණු.// පහත වගුව භාවිතා කරමින් අකුරු ශ් රේණි මාලාවක් ප් රතිදානය කළ හැකි ශ් රිතයක්: ඇය ඔයාට GPA එකතුවක් දුන්නා සමහර ශිෂ් යයන් වෙනුවෙන් ඔයාට ලියන්න වෙනවා.// එකම ප් රශ්නේ තමයි, එයාට අගය කරන්න පාවිච්චි කරපු කේතය නැති වෙලා.ගුරුවරයා තමන්ගේම ඇල්ගොරිතමයක් හදලා තියෙනවා ශ් රේණිගත කිරීම සඳහා.මේ සති අන්තයේ ගුරුවරයා ලකුණු දෙන්න ඕන./// >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])
/// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
func numerical_letter_grade(grades: [Double]) -> [String] {
","func numerical_letter_grade(grades: [Double]) -> [String] {
    return grades.map { gpa in
        switch gpa {
        case 4.0:
            return ""A+""
        case 3.7...4.0:
            return ""A""
        case 3.3..<3.7:
            return ""A-""
        case 3.0..<3.3:
            return ""B+""
        case 2.7..<3.0:
            return ""B""
        case 2.3..<2.7:
            return ""B-""
        case 2.0..<2.3:
            return ""C+""
        case 1.7..<2.0:
            return ""C""
        case 1.3..<1.7:
            return ""C-""
        case 1.0..<1.3:
            return ""D+""
        case 0.7..<1.0:
            return ""D""
        case 0.0..<0.7:
            return ""D-""
        default:
            return ""E""
        }
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [""A+"", ""B"", ""C-"", ""C"", ""A-""])
assert(numerical_letter_grade(grades: [1.2]) == [""D+""])
assert(numerical_letter_grade(grades: [0.5]) == [""D-""])
assert(numerical_letter_grade(grades: [0.0]) == [""E""])
assert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [""D"", ""D-"", ""C-"", ""B"", ""B+""])
assert(numerical_letter_grade(grades: [0.0, 0.7]) == [""E"", ""D-""])"
HumanEval_82,sin_Sinh,swift,"
// උදාහරණ // දිග ප් රථම සංඛ් යාවක් නම් හෝ වෙනත් ආකාරයකින් අසත් ය නම් // අක්ෂර මාලාවක් අරගෙන true නැවත ලබාදෙන function එකක් ලියන්න./// >>> prime_length(string: ""Hello"")
/// true
/// >>> prime_length(string: ""abcdcba"")
/// true
/// >>> prime_length(string: ""kittens"")
/// true
/// >>> prime_length(string: ""orange"")
/// false
func prime_length(string: String) -> Bool {
","func prime_length(string: String) -> Bool {
    let length = string.count
    
    guard length > 1 else {
        return false
    }
    
    for i in 2..<length {
        if length % i == 0 {
            return false
        }
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_length(string: ""Hello"") == true)
assert(prime_length(string: ""abcdcba"") == true)
assert(prime_length(string: ""kittens"") == true)
assert(prime_length(string: ""orange"") == false)
assert(prime_length(string: ""wow"") == true)
assert(prime_length(string: ""world"") == true)
assert(prime_length(string: ""MadaM"") == true)
assert(prime_length(string: ""Wow"") == true)
assert(prime_length(string: """") == false)
assert(prime_length(string: ""HI"") == true)
assert(prime_length(string: ""go"") == true)
assert(prime_length(string: ""gogo"") == false)
assert(prime_length(string: ""aaaaaaaaaaaaaaa"") == false)
assert(prime_length(string: ""Madam"") == true)
assert(prime_length(string: ""M"") == false)
assert(prime_length(string: ""0"") == false)"
HumanEval_83,sin_Sinh,swift,"
// ධනාත්මක සම්පූර්ණ සංඛ් යා 1 න් පටන් ගන්න හෝ අවසන් වෙන්න.// ධනාත්මක පූර්ණ සංඛ් යාවක් n ලබා දී, n-ඉලක්කම් සංඛ් යා ගණනය කරන්න func starts_one_ends(n: Int) -> Int {
","func starts_one_ends(n: Int) -> Int {
    if n == 1 {
        // For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.
        return 1
    }
    
    // Count of n-digit numbers starting with 1:
    // First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.
    let startWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Count of n-digit numbers ending with 1:
    // Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.
    // So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.
    let endWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Intersection of both sets is the numbers starting and ending with 1
    // which are of the form `1` followed by (n-2) digits and `1`, so:
    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))
    
    return startWithOne + endWithOne - startAndEndWithOne
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(starts_one_ends(n: 1) == 1)
assert(starts_one_ends(n: 2) == 18)
assert(starts_one_ends(n: 3) == 180)
assert(starts_one_ends(n: 4) == 1800)
assert(starts_one_ends(n: 5) == 18000)"
HumanEval_84,sin_Sinh,swift,"
// උදාහරණය // ධනාත්මක පූර්ණ සංඛ් යාවක් N ලබා දීලා, එහි අංකවල මුළු එකතුව ද්විමය අකුරෙන් ලබා දෙන්න. /// >>> solve(N: 1000)
/// ""1""
/// >>> solve(N: 150)
/// ""110""
/// >>> solve(N: 147)
/// ""1100""
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
func solve(N: Int) -> String {
","func solve(N: Int) -> String {
    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)
    return String(sumOfDigits, radix: 2)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(N: 1000) == ""1"")
assert(solve(N: 150) == ""110"")
assert(solve(N: 147) == ""1100"")
assert(solve(N: 333) == ""1001"")
assert(solve(N: 963) == ""10010"")"
HumanEval_85,sin_Sinh,swift,"
// උදාහරණ: // හිස් නොවන පූර්ණ සංඛ් යා අරාවක දීලා lst. අමු අංක වල තියෙන සම අංග එකතු කරන්න.. /// >>> add(lst: [4, 2, 6, 7])
/// 2
func add(lst: [Int]) -> Int {
","func add(lst: [Int]) -> Int {
    var sum = 0
    for i in stride(from: 1, to: lst.count, by: 2) {
        if lst[i] % 2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(lst: [4, 88]) == 88)
assert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)
assert(add(lst: [4, 0, 6, 7]) == 0)
assert(add(lst: [4, 4, 6, 8]) == 12)"
HumanEval_86,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// සටහන: ඔබ වාක්යයේ වචන සහ හිස් අවකාශයන් අනුපිළිවෙල තබා ගත යුතුය.// ASCII අගය මත පදනම්ව ඉහළ යන පිළිවෙල.// අළුත් වචනයක් මගින් ප් රතිස්ථාපනය වෙනවා.// නූල් වල අනුපිළිවෙල අනුව, සියලු වචන (අතුරු අවකාශයකින් වෙන්කර) // අක්ෂර මාලාවක් අරගෙන ඒකෙ පිළිවෙලට තියෙන අනුවාදයක් ලබා දෙන ශ් රිතයක් ලියන්න./// >>> anti_shuffle(s: ""Hi"")
/// ""Hi""
/// >>> anti_shuffle(s: ""hello"")
/// ""ehllo""
/// >>> anti_shuffle(s: ""Hello World!!!"")
/// ""Hello !!!Wdlor""
func anti_shuffle(s: String) -> String {
","func anti_shuffle(s: String) -> String {
    let words = s.components(separatedBy: .whitespaces)
    let orderedWords = words.map { String($0.sorted()) }
    var result = """"
    var wordIndex = 0
    
    for character in s {
        if character.isWhitespace {
            result.append(character)
        } else if wordIndex < orderedWords.count {
            if let currentWord = orderedWords[wordIndex].first {
                result.append(currentWord)
                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)
            }
        }
        
        if let lastCharacter = result.last {
            if lastCharacter.isWhitespace {
                wordIndex += 1
            }
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(anti_shuffle(s: ""Hi"") == ""Hi"")
assert(anti_shuffle(s: ""hello"") == ""ehllo"")
assert(anti_shuffle(s: ""number"") == ""bemnru"")
assert(anti_shuffle(s: ""abcd"") == ""abcd"")
assert(anti_shuffle(s: ""Hello World!!!"") == ""Hello !!!Wdlor"")
assert(anti_shuffle(s: """") == """")
assert(anti_shuffle(s: ""Hi. My name is Mister Robot. How are you?"") == "".Hi My aemn is Meirst .Rboot How aer ?ouy"")"
HumanEval_87,sin_Sinh,swift,"
// උදාහරණ: // ඒ වගේම පේළියේ ඛණ්ඩාංක තීරු අනුව පහළ යන පිළිවෙලට වර්ග කරන්න.// මුලින්ම අංශාංක පේළි වලින් වර්ධනය වන පිළිවෙලට වර්ග කරන්න.// සෑම ටුපල් එකකම ඛණ්ඩාංකයක් තියෙනවා - (පේළි, තීරු), 0 වලින් පටන් ගන්නවා. // සහ නැවත ලබාදෙනවා අරා ටියුප්ලස්, [(x1, y1), (x2, y2) ...] එවැනි // lst, සහ සම්පූර්ණ සංඛ් යාව x ලබා දීලා, අරාව තුල සම්පූර්ණ සංඛ් යාව x සොයාගන්න, // එක පේළියක පේළි ගණන වෙනස් වෙන්න පුළුවන්.// එය matrix වලට සමානයි, කෙසේ වෙතත්, matrix වලට වඩා වෙනස්, // ඔබට දෙමාන දත්ත ලබා දී ඇත, නයිට් කළ අරාවන් ලෙස, /// >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)
/// [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(lst: [] as [[Int]], x: 1)
/// [] as [(Int, Int)]
/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)
/// [(2, 2)]
func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
","func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
    var coordinates: [(Int, Int)] = []
    
    for (rowIndex, row) in lst.enumerated() {
        for (colIndex, value) in row.enumerated() {
            if value == x {
                coordinates.append((rowIndex, colIndex))
            }
        }
    }
    
    let sortedCoordinates = coordinates.sorted {
        if $0.0 == $1.0 {
            return $0.1 > $1.1
        } else {
            return $0.0 < $1.0
        }
    }
    
    return sortedCoordinates
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])
assert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])
assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])
assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
HumanEval_88,sin_Sinh,swift,"
// උදාහරණ: // * ලබා දී ඇති අරාව වෙනස් කරන්න එපා. // සටහන: // හෝ එය පහළ යන පිළිවෙලට වර්ග කරන්න, එකතුව නම් ((පළමු දර්ශක අගය, අවසාන දර්ශක අගය) සම වේ. // ඔබ ලබා දී ඇති අරාව වර්ධනය වන පිළිවෙලට වර්ග කරයි, එකතුව නම් ((පළමු දර්ශක අගය, අවසාන දර්ශක අගය) අමුතුයි, // ණ නොවන පූර්ණ සංඛ් යා සමූහයක් ලබා දී ඇත, වර්ග කිරීමෙන් පසු ලබා දී ඇති සමූහයේ coswift නැවත ලබා දෙන්න, /// >>> sort_array(array: [] as [Int])
/// [] as [Int]
/// >>> sort_array(array: [5])
/// [5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5])
/// [0, 1, 2, 3, 4, 5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])
/// [6, 5, 4, 3, 2, 1, 0]
func sort_array(array: [Int]) -> [Int] {
","func sort_array(array: [Int]) -> [Int] {
    guard let first = array.first, let last = array.last else {
        return array
    }
    let sum = first + last
    if sum % 2 == 0 {
        return array.sorted(by: >) // Descending order
    } else {
        return array.sorted() // Ascending order
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(array: [] as [Int]) == [] as [Int])
assert(sort_array(array: [5]) == [5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])
assert(sort_array(array: [2, 1]) == [1, 2])
assert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])
assert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"
HumanEval_89,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// පහලට යන්න 2 ගුණ කරන්න 2 තැන් වලට.// අක්ෂර මාලාව භ් රමණය විය යුත්තේ අකුරු // අක්ෂර මාලාව හරවා කේතනය කල නූලක් නැවත ලබා දෙයි.// අරමුණක් ලෙස string එකක් ගන්න function encrypt එකක් හදන්න සහ /// >>> encrypt(s: ""hi"")
/// ""lm""
/// >>> encrypt(s: ""asdfghjkl"")
/// ""ewhjklnop""
/// >>> encrypt(s: ""gf"")
/// ""kj""
/// >>> encrypt(s: ""et"")
/// ""ix""
func encrypt(s: String) -> String {
","func encrypt(s: String) -> String {
    let alphabet = Array(""abcdefghijklmnopqrstuvwxyz"")
    let shift = 2 * 2 // shift down by two multiplied by two places, i.e., 4
    var result = """"

    for character in s {
        if let index = alphabet.firstIndex(of: character) {
            let newIndex = (index + shift) % alphabet.count
            result.append(alphabet[newIndex])
        } else {
            result.append(character) // append non-alphabetic characters unchanged
        }
    }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: ""hi"") == ""lm"")
assert(encrypt(s: ""asdfghjkl"") == ""ewhjklnop"")
assert(encrypt(s: ""gf"") == ""kj"")
assert(encrypt(s: ""et"") == ""ix"")
assert(encrypt(s: ""faewfawefaewg"") == ""jeiajeaijeiak"")
assert(encrypt(s: ""hellomyfriend"") == ""lippsqcjvmirh"")
assert(encrypt(s: ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"") == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")
assert(encrypt(s: ""a"") == ""e"")"
HumanEval_90,sin_Sinh,swift,"
// එවැනි අංගයක් නොමැති නම් නිල් නැවත ලබා දෙන්න. // අරාවෙ දෙවෙනි කුඩාම අංගය ලබාදෙන next_smallest () ශ් රිතයක් ලියන්න.// ඔබට පූර්ණ සංඛ් යා අරාවක් ලබා දී ඇත./// >>> next_smallest(lst: [1, 2, 3, 4, 5])
/// 2
/// >>> next_smallest(lst: [5, 1, 4, 3, 2])
/// 2
/// >>> next_smallest(lst: [] as [Int])
/// nil
/// >>> next_smallest(lst: [1, 1])
/// nil
func next_smallest(lst: [Int]) -> Int? {
","func next_smallest(lst: [Int]) -> Int? {
    if lst.count < 2 {
        return nil
    }
    
    var uniqueSorted = Array(Set(lst)).sorted()
    
    if uniqueSorted.count < 2 {
        return nil
    }
    
    return uniqueSorted[1]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)
assert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)
assert(next_smallest(lst: [] as [Int]) == nil)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
HumanEval_91,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// වාක් ය සීමා වන්නේ '.', '?' හෝ '!'. කම්මැලි කම කියන්නෙ ""I"" කියන වචනයෙන් පටන් ගන්න වාක් යයක්.// ඔයාට වචන පෙළක් ලැබෙනවා, ඔයාගේ වැඩේ තමයි අංකය ගණන් කිරීම./// >>> is_bored(S: ""Hello world"")
/// 0
/// >>> is_bored(S: ""The sky is blue. The sun is shining. I love this weather"")
/// 1
func is_bored(S: String) -> Int {
","func is_bored(S: String) -> Int {
    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }
    var boredomCount = 0
    
    for sentence in sentences {
        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)
        if trimmedSentence.hasPrefix(""I"") {
            boredomCount += 1
        }
    }
    
    return boredomCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_bored(S: ""Hello world"") == 0)
assert(is_bored(S: ""Is the sky blue?"") == 0)
assert(is_bored(S: ""I love It !"") == 1)
assert(is_bored(S: ""bIt"") == 0)
assert(is_bored(S: ""I feel good today. I will be productive. will kill It"") == 2)
assert(is_bored(S: ""You and I are going for a walk"") == 0)"
HumanEval_92,sin_Sinh,swift,"
// උදාහරණ // අනෙක් ඕනෑම අවස්ථාවක false නැවත ලබා දෙයි. // අංක වලින් එකක් අනිත් දෙකේ එකතුවට සමාන නම් සහ සියලුම අංක පූර්ණ සංඛ් යා නම් true නැවත ලබා දෙයි. අංක 3ක් ගන්න පුලුවන් ෆන්ෂන් එකක් හදන්න./// >>> any_int(x: 5, y: 2, z: 7)
/// true
/// >>> any_int(x: 3, y: 2, z: 2)
/// false
/// >>> any_int(x: 3, y: -2, z: 1)
/// true
/// >>> any_int(x: 3.6, y: -2.2, z: 2)
/// false
func any_int(x: Double, y: Double, z: Double) -> Bool {
","func any_int(x: Double, y: Double, z: Double) -> Bool {
    guard x == floor(x), y == floor(y), z == floor(z) else {
        return false
    }
    
    let a = Int(x)
    let b = Int(y)
    let c = Int(z)
    
    return a == b + c || b == a + c || c == a + b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(any_int(x: 2, y: 3, z: 1) == true)
assert(any_int(x: 2.5, y: 2, z: 3) == false)
assert(any_int(x: 1.5, y: 5, z: 3.5) == false)
assert(any_int(x: 2, y: 6, z: 2) == false)
assert(any_int(x: 4, y: 2, z: 2) == true)
assert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)
assert(any_int(x: -4, y: 6, z: 2) == true)
assert(any_int(x: 2, y: 1, z: 1) == true)
assert(any_int(x: 3, y: 4, z: 7) == true)
assert(any_int(x: 3.0, y: 4, z: 7) == false)"
HumanEval_93,sin_Sinh,swift,"
// උදාහරණ: අකුරු විතරක් හිතන්න.// ඉංග් රීසි අක්ෂර මාලාවේ ස්වරයක්.// පණිවිඩය අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන් අකුරෙන්// ඒකෙන් හැම අකුරක්ම වෙනස් වෙනවා, හැම ස්වරයක්ම වෙනස් වෙනවා // පණිවිඩයක් අරගෙන එයින් කේතනය කරන ක් රියාකාරකමක් ලියන්න./// >>> encode(message: ""test"")
/// ""TGST""
/// >>> encode(message: ""This is a message"")
/// ""tHKS KS C MGSSCGG""
func encode(message: String) -> String {
","func encode(message: String) -> String {
    let vowels = ""aeiouAEIOU""
    let vowelReplacement = [
        ""a"": ""c"", ""e"": ""g"", ""i"": ""k"", ""o"": ""q"", ""u"": ""w"",
        ""A"": ""C"", ""E"": ""G"", ""I"": ""K"", ""O"": ""Q"", ""U"": ""W""
    ]
    
    var encodedMessage = """"
    
    for char in message {
        if vowels.contains(char) {
            if let replacement = vowelReplacement[String(char)] {
                encodedMessage.append(replacement)
            }
        } else {
            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())
            encodedMessage.append(swappedCase)
        }
    }
    
    return encodedMessage
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: ""TEST"") == ""tgst"")
assert(encode(message: ""Mudasir"") == ""mWDCSKR"")
assert(encode(message: ""YES"") == ""ygs"")
assert(encode(message: ""This is a message"") == ""tHKS KS C MGSSCGG"")
assert(encode(message: ""I DoNt KnOw WhAt tO WrItE"") == ""k dQnT kNqW wHcT Tq wRkTg"")"
HumanEval_94,sin_Sinh,swift,"
// උදාහරණ: // ඔබට අවශ් ය විශාලතම ප් රයිම් අගය සොයාගෙන එහි ඉලක්කම්වල එකතුව ලබා දෙන්න. // ඔබට පූර්ණ සංඛ් යා අරාවක් ලබා දී ඇත./// >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])
/// 7
func skjkasdkd(lst: [Int]) -> Int {
","func skjkasdkd(lst: [Int]) -> Int {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    var largestPrime: Int? = nil
    for number in lst {
        if isPrime(number) {
            if largestPrime == nil || number > largestPrime! {
                largestPrime = number
            }
        }
    }
    
    if let largestPrime = largestPrime {
        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)
    }
    
    return 0 // In case there are no prime numbers
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)
assert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)
assert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)
assert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)
assert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)
assert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)
assert(skjkasdkd(lst: [8191]) == 19)
assert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)
assert(skjkasdkd(lst: [127, 97, 8192]) == 10)"
HumanEval_96,sin_Sinh,swift,"
// උදාහරණයක් ලෙස: // ප් රාථමික සංඛ් යා සහ n ට වඩා අඩු සම්පූර්ණ සංඛ් යා. // ණ නොවන පූර්ණ සංඛ් යාවක් ගෙන පළමු n කින් සමන්විත අරාවක් ලබා දෙන ශ් රිතයක් ක් රියාත්මක කරන්න./// >>> count_up_to(n: 5)
/// [2, 3]
/// >>> count_up_to(n: 11)
/// [2, 3, 5, 7]
/// >>> count_up_to(n: 0)
/// [] as [Int]
/// >>> count_up_to(n: 20)
/// [2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(n: 1)
/// [] as [Int]
/// >>> count_up_to(n: 18)
/// [2, 3, 5, 7, 11, 13, 17]
func count_up_to(n: Int) -> [Int] {
","func count_up_to(n: Int) -> [Int] {
    guard n > 2 else { return [] }
    
    var primes: [Int] = [2]
    
    for number in 3..<n {
        var isPrime = true
        for prime in primes {
            if prime * prime > number {
                break
            }
            if number % prime == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            primes.append(number)
        }
    }
    
    return primes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_up_to(n: 5) == [2, 3])
assert(count_up_to(n: 6) == [2, 3, 5])
assert(count_up_to(n: 7) == [2, 3, 5])
assert(count_up_to(n: 10) == [2, 3, 5, 7])
assert(count_up_to(n: 0) == [] as [Int])
assert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])
assert(count_up_to(n: 1) == [] as [Int])
assert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])
assert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
assert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"
HumanEval_97,sin_Sinh,swift,"
// උදාහරණ: // ඇතුලත් කිරීම හැමවිටම වලංගුයි කියලා උපකල්පනය කරන්න.// ඒකක අංකවල ගුණය.// සම්පූර්ණ කරන්න ඉලක්කම් දෙකක් ගන්නා ක් රියාකාරකමක් සහ /// >>> multiply(a: 148, b: 412)
/// 16
/// >>> multiply(a: 19, b: 28)
/// 72
/// >>> multiply(a: 2020, b: 1851)
/// 0
/// >>> multiply(a: 14, b: -15)
/// 20
func multiply(a: Int, b: Int) -> Int {
","func multiply(a: Int, b: Int) -> Int {
    let unitDigitA = abs(a % 10)
    let unitDigitB = abs(b % 10)
    return unitDigitA * unitDigitB
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(multiply(a: 148, b: 412) == 16)
assert(multiply(a: 19, b: 28) == 72)
assert(multiply(a: 2020, b: 1851) == 0)
assert(multiply(a: 14, b: -15) == 20)
assert(multiply(a: 76, b: 67) == 42)
assert(multiply(a: 17, b: 27) == 49)
assert(multiply(a: 0, b: 1) == 0)
assert(multiply(a: 0, b: 0) == 0)"
HumanEval_98,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// S අකුරු පෙළක් දීලා, ඒකාකාර අකුරු වල ඇති ලොකු අකුරු වල ස්වර ගණන ගණන් කරන්න./// >>> count_upper(s: ""aBCdEf"")
/// 1
/// >>> count_upper(s: ""abcdefg"")
/// 0
/// >>> count_upper(s: ""dBBE"")
/// 0
func count_upper(s: String) -> Int {
","func count_upper(s: String) -> Int {
    let upperVowels = Set<Character>([""A"", ""E"", ""I"", ""O"", ""U""])
    var count = 0

    for (index, char) in s.enumerated() {
        if index % 2 == 0 && upperVowels.contains(char) {
            count += 1
        }
    }

    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_upper(s: ""aBCdEf"") == 1)
assert(count_upper(s: ""abcdefg"") == 0)
assert(count_upper(s: ""dBBE"") == 0)
assert(count_upper(s: ""B"") == 0)
assert(count_upper(s: ""U"") == 1)
assert(count_upper(s: """") == 0)
assert(count_upper(s: ""EEEE"") == 2)"
HumanEval_99,sin_Sinh,swift,"
// උදාහරණ // සම්පූර්ණ සංඛ් යා දෙකකින්, එය ශුන් යයෙන් ඉවතට වට කරන්න. // ඒ වගේම ඒකෙන් සමීපතම සම්පූර්ණ සංඛ් යාව ලබා දෙනවා.// අංකයක් නියෝජනය කරන අගයක් (string) ගන්නා ශ් රිතයක් නිර්මාණය කරන්න./// >>> closest_integer(value: ""10"")
/// 10
/// >>> closest_integer(value: ""15.3"")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value: String) -> Int {
","func closest_integer(value: String) -> Int {
    if let number = Double(value) {
        return Int(number.rounded(.awayFromZero))
    }
    return 0 // or handle error as needed
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: ""10"") == 10)
assert(closest_integer(value: ""14.5"") == 15)
assert(closest_integer(value: ""-15.5"") == -16)
assert(closest_integer(value: ""15.3"") == 15)
assert(closest_integer(value: ""0"") == 0)"
HumanEval_100,sin_Sinh,swift,"
// උදාහරණ: // i කියන්නෙ මට්ටමේ ගල් ගණන (i+1).// එක අරා එකක එක එක මට්ටමේ ගල් ගණන නැවත ලබා දෙනවා, එහිදී අගය // - ඊලඟ සම සංඛ් යාව n සම නම්. // - n අමුතු නම් ඊලඟ අමුතු අංකය. // ඊලඟ මට්ටමේ ගල් ගණන: // පලවෙනි මට්ටමේ ගල් n ක් තියෙනවා.// ධනාත්මක පූර්ණ සංඛ් යාවක් n ලබා දීලා, ඔයා ගල් මට්ටම් n කින් යුත් ගොඩක් හදන්න ඕනේ./// >>> make_a_pile(n: 3)
/// [3, 5, 7]
func make_a_pile(n: Int) -> [Int] {
","func make_a_pile(n: Int) -> [Int] {
    var pile = [Int]()
    var currentLevelStones = n
    
    for _ in 0..<n {
        pile.append(currentLevelStones)
        if n % 2 == 0 {
            currentLevelStones += 2
        } else {
            currentLevelStones += 2
        }
    }
    
    return pile
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_a_pile(n: 3) == [3, 5, 7])
assert(make_a_pile(n: 4) == [4, 6, 8, 10])
assert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])
assert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])
assert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"
HumanEval_101,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// වචන වලට string එක බෙදලා වචන වලින් array එකක් ලබා දෙන්න.// ඔබට කොමා හෝ අවකාශයන් මගින් වෙන් කරන ලද වචන පෙළක් ලබා දෙනු ඇත. ඔබේ කාර්යය වන්නේ /// >>> words_string(s: ""Hi, my name is John"")
/// [""Hi"", ""my"", ""name"", ""is"", ""John""]
/// >>> words_string(s: ""One, two, three, four, five, six"")
/// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
func words_string(s: String) -> [String] {
","func words_string(s: String) -> [String] {
    let separators = CharacterSet(charactersIn: "", "")
    return s.components(separatedBy: separators).filter { !$0.isEmpty }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_string(s: ""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""])
assert(words_string(s: ""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: ""Hi, my name"") == [""Hi"", ""my"", ""name""])
assert(words_string(s: ""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: """") == [] as [String])
assert(words_string(s: ""ahmed     , gamal"") == [""ahmed"", ""gamal""])"
HumanEval_102,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// එහෙම අංකයක් නෑ, එහෙනම් ෆන්ක්ශන් එක -1 ආපහු එවන්න ඕනේ.// විශාලතම සම පූර්ණ සංඛ් යාව [x, y] පරාසය ඇතුලත් වේ.// මෙම ශ් රිතය ධනාත්මක සංඛ් යා x සහ y දෙකක් ගෙන /// >>> choose_num(x: 12, y: 15)
/// 14
/// >>> choose_num(x: 13, y: 12)
/// -1
func choose_num(x: Int, y: Int) -> Int {
","func choose_num(x: Int, y: Int) -> Int {
    // Determine the starting and ending range values
    let start = min(x, y)
    let end = max(x, y)
    
    // Iterate from the end of the range to the start
    for num in (start...end).reversed() {
        // Check if the current number is even
        if num % 2 == 0 {
            return num
        }
    }
    
    // Return -1 if no even number is found
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(choose_num(x: 12, y: 15) == 14)
assert(choose_num(x: 13, y: 12) == -1)
assert(choose_num(x: 33, y: 12354) == 12354)
assert(choose_num(x: 5234, y: 5233) == -1)
assert(choose_num(x: 6, y: 29) == 28)
assert(choose_num(x: 27, y: 10) == -1)
assert(choose_num(x: 7, y: 7) == -1)
assert(choose_num(x: 546, y: 546) == 546)"
HumanEval_103,sin_Sinh,swift,"
extension Int: Error {}
        
// උදාහරණය: // n m ට වඩා වැඩි නම්, -1 නැවත ලබා දෙන්න.// ඊලගට තියෙන සම්පූර්ණ සංඛ් යාවට වට කරලා ඒක ද්විමය සංඛ් යාවට හරවන්න.// n සිට m දක්වා (n සහ m ඇතුළුව) සම්පූර්ණ සංඛ් යා වල සාමාන් යය.// ඔබට ධනාත්මක පූර්ණ සංඛ් යා n සහ m දෙකක් ලබා දී ඇත, ඔබේ කාර්යය වන්නේ /// >>> rounded_avg(n: 1, m: 5)
/// .success(""0b11"")
/// >>> rounded_avg(n: 7, m: 5)
/// .failure(-1)
/// >>> rounded_avg(n: 10, m: 20)
/// .success(""0b1111"")
/// >>> rounded_avg(n: 20, m: 33)
/// .success(""0b11010"")
func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
","func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
    if n > m {
        return .failure(-1)
    }
    
    let count = m - n + 1
    let sum = (n + m) * count / 2
    let average = Double(sum) / Double(count)
    let roundedAverage = Int(average.rounded())
    let binaryString = String(roundedAverage, radix: 2)
    
    return .success(""0b"" + binaryString)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rounded_avg(n: 1, m: 5) == .success(""0b11""))
assert(rounded_avg(n: 7, m: 13) == .success(""0b1010""))
assert(rounded_avg(n: 964, m: 977) == .success(""0b1111001010""))
assert(rounded_avg(n: 996, m: 997) == .success(""0b1111100100""))
assert(rounded_avg(n: 560, m: 851) == .success(""0b1011000010""))
assert(rounded_avg(n: 185, m: 546) == .success(""0b101101110""))
assert(rounded_avg(n: 362, m: 496) == .success(""0b110101101""))
assert(rounded_avg(n: 350, m: 902) == .success(""0b1001110010""))
assert(rounded_avg(n: 197, m: 233) == .success(""0b11010111""))
assert(rounded_avg(n: 7, m: 5) == .failure(-1))
assert(rounded_avg(n: 5, m: 1) == .failure(-1))
assert(rounded_avg(n: 5, m: 5) == .success(""0b101""))"
HumanEval_104,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// සටහන: නැවත ලබාදෙන අරාව වර්ධනය වන පිළිවෙලට වර්ග කළ යුතුය.// සංඛ් යාතයක් නැති අංගයක්.ධනාත්මක පූර්ණ සංඛ් යා x කින් සමන්විත අරාවක දීලා, සියලු /// >>> unique_digits(x: [15, 33, 1422, 1])
/// [1, 15, 33]
/// >>> unique_digits(x: [152, 323, 1422, 10])
/// [] as [Int]
func unique_digits(x: [Int]) -> [Int] {
","func unique_digits(x: [Int]) -> [Int] {
    return x.filter { number in
        var hasEvenDigit = false
        var num = number
        while num > 0 {
            if (num % 10) % 2 == 0 {
                hasEvenDigit = true
                break
            }
            num /= 10
        }
        return !hasEvenDigit
    }.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])
assert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])
assert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])
assert(unique_digits(x: [135, 103, 31]) == [31, 135])"
HumanEval_105,sin_Sinh,swift,"
උදාහරණයක් ලෙස:එකයි, දෙකයි, තුනයි, හතරයි, පහයි, හයයි, හතයි, අටයි, නවයි.// ප් රතිඵලයක් ලෙස ලැබෙන අරාව ආපසු හරවා, පසුව  සිට සෑම ඉලක්කමක්ම එහි අනුරූප නාමය මගින් ප් රතිස්ථාපනය කරන්න.// සම්පූර්ණ සංඛ් යා අරාව ලබා දීලා, 1 ත් 9 ත් අතර සම්පූර්ණ සංඛ් යා වර්ග කරන්න, /// >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])
/// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
/// If the array is empty, return an empty array:
/// >>> by_length(arr: [] as [Int])
/// [] as [String]
/// If the array has any strange number ignore it:
/// >>> by_length(arr: [1, -1, 55])
/// [""One""]
func by_length(arr: [Int]) -> [String] {
","func by_length(arr: [Int]) -> [String] {
    let numberNames: [Int: String] = [
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine""
    ]
    
    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }
                                           .sorted(by: >)
    
    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? """" }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""])
assert(by_length(arr: [] as [Int]) == [] as [String])
assert(by_length(arr: [1, -1, 55]) == [""One""])
assert(by_length(arr: [1, -1, 3, 2]) == [""Three"", ""Two"", ""One""])
assert(by_length(arr: [9, 4, 8]) == [""Nine"", ""Eight"", ""Four""])"
HumanEval_106,sin_Sinh,swift,"
// උදාහරණය: // i හි සාධක 1 සිට i දක්වා සංඛ් යා ගුණ කිරීමයි (1 * 2 * ... * i). // මම පටන් ගන්නේ 1 න්.// නැත්නම් 1 සිට i දක්වා අංකවල එකතුව.//අනුපාතය i හි අංගයේ අගය i හි සාධකයක් වන පරිදි, n ප් රමාණයේ අරාවක් ලබා දෙයි.// n පරාමිතිය ලෙස ගන්නා f ශ් රිතය ක් රියාත්මක කරන්න, /// >>> f(n: 5)
/// [1, 2, 6, 24, 15]
func f(n: Int) -> [Int] {
","func f(n: Int) -> [Int] {
    func factorial(_ x: Int) -> Int {
        guard x > 1 else { return 1 }
        return (1...x).reduce(1, *)
    }
    
    func sumTo(_ x: Int) -> Int {
        return (1...x).reduce(0, +)
    }
    
    var result = [Int]()
    for i in 1...n {
        if i % 2 == 0 {
            result.append(factorial(i))
        } else {
            result.append(sumTo(i))
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(f(n: 5) == [1, 2, 6, 24, 15])
assert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])
assert(f(n: 1) == [1])
assert(f(n: 3) == [1, 2, 6])"
HumanEval_107,sin_Sinh,swift,"
// උදාහරණය 1:// අංක පරාසය ඇතුලතට වැටෙන සම්පූර්ණ සංඛ් යා පාලින්ඩ් රෝම්// ධනාත්මක පූර්ණ සංඛ් යාවක් n ලබා දීලා, ෙපරිච්ඡේදය ෙපර සහ අමු ෙපරිච්ඡේද ෙලස ෙයන ෙයන ෙයන ෙයන ෙපරිච්ඡේදයක් ලබා දෙන්න /// >>> even_odd_palindrome(n: 3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(n: 12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n: Int) -> (Int, Int) {
","func even_odd_palindrome(n: Int) -> (Int, Int) {
    func isPalindrome(_ num: Int) -> Bool {
        let str = String(num)
        return str == String(str.reversed())
    }
    
    var evenCount = 0
    var oddCount = 0
    
    for i in 1...n {
        if isPalindrome(i) {
            if i % 2 == 0 {
                evenCount += 1
            } else {
                oddCount += 1
            }
        }
    }
    
    return (evenCount, oddCount)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_palindrome(n: 123) == (8, 13))
assert(even_odd_palindrome(n: 12) == (4, 6))
assert(even_odd_palindrome(n: 3) == (1, 2))
assert(even_odd_palindrome(n: 63) == (6, 8))
assert(even_odd_palindrome(n: 25) == (5, 6))
assert(even_odd_palindrome(n: 19) == (4, 6))
assert(even_odd_palindrome(n: 9) == (4, 5))
assert(even_odd_palindrome(n: 1) == (0, 1))"
HumanEval_108,sin_Sinh,swift,"
උදාහරණයක් ලෙස, -123 අංකය -1, 2, සහ 3 ලෙස අත්සන් කර ඇත.// සංඛ් යාවක් ණ නම්, එහි පළමු අත්සන් කළ ඉලක්කම් ණ වේ: // අංකවල එකතුව 0 ට වඩා වැඩි වන මූලද් රව් ය ගණන.// ගණන් කරන්න_අංක කියන ෆන්ෂන් එක ලියන්න ඒකෙන් ගන්නා අංක ගණනක් /// >>> count_nums(arr: [] as [Int])
/// 0
/// >>> count_nums(arr: [-1, 11, -11])
/// 1
/// >>> count_nums(arr: [1, 1, 2])
/// 3
func count_nums(arr: [Int]) -> Int {
","func count_nums(arr: [Int]) -> Int {
    return arr.filter { number in
        var n = number
        var sumOfDigits = 0

        while n != 0 {
            sumOfDigits += n % 10
            n /= 10
        }

        return sumOfDigits > 0
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_nums(arr: [] as [Int]) == 0)
assert(count_nums(arr: [-1, -2, 0]) == 0)
assert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)
assert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)
assert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)
assert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)
assert(count_nums(arr: [0, 1]) == 1)
assert(count_nums(arr: [1]) == 1)"
HumanEval_109,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// සටහන: ලබා දී ඇති අරාවෙහි අද්විතීය අංග ඇති බවට සහතික වේ.// ලබා දී ඇති අරාව හිස් නම් true නැවත ලබා දෙන්න. // එහෙනම් true නැවත දෙන්න, නැත්නම් false නැවත දෙන්න. // ඉහත ක් රියාව සිදු කිරීමෙන් වර්ග කළ අරාව ලබා ගත හැකි නම් // අරාවෙ ආරම්භක ස්ථානය, ඒ කියන්නේ 0 වන දර්ශකය.අරාවෙ අන්තිම අංගය ට මාරු වෙනවා// එක දකුණට මාරුවීමේ ක් රියාවලියක් කියන්නේ අරාවෙ සියලුම අංග එකකින් මාරු කිරීමක් // ඔබට ඕනෑම වාර ගණනක් දකුණට මාරුවීමේ මෙහෙයුම සිදු කිරීමට අවසර ඇත.// පහත දැක්වෙන මෙහෙයුම අරාව මත: // න් යාය ක් රියාව මගින් අනුපිළිවෙල අඩු නොවන ලෙසට අරා වර්ග කිරීමේ හැකියාව ඇත අංක අහඹු ලෙස පිළිවෙලට තබනවා.// අපට 'arr' අරා එකක් තියෙනවා N පූර්ණ සංඛ් යා arr[1], arr[2], ..., arr[N]./// >>> move_one_ball(arr: [3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given array.
/// >>> move_one_ball(arr: [3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// array by performing any number of right shift operations.
func move_one_ball(arr: [Int]) -> Bool {
","func move_one_ball(arr: [Int]) -> Bool {
    guard !arr.isEmpty else { return true }
    
    let n = arr.count
    var breakPointCount = 0
    
    // Find the number of break points where the array is decreasing
    for i in 0..<n {
        if arr[i] > arr[(i + 1) % n] {
            breakPointCount += 1
        }
    }
    
    // If there's at most one break point, the array can be right shifted
    return breakPointCount <= 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)
assert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)
assert(move_one_ball(arr: [4, 3, 1, 2]) == false)
assert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)
assert(move_one_ball(arr: [] as [Int]) == true)"
HumanEval_110,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// එහෙම නැත්නම්, ""NO"" කියලා දෙන්න.// lst1 හි සියලුම අංග සම නම්, ""YES"" නැවත දෙන්න.// lst1 සහ lst2 අතර අංග හුවමාරු කර ගැනීමට හැකි නම් // lst1 සහ lst2 අතර හුවමාරු වන මූලද් රව් ය ගණන සීමා නොවේ.// ඔවුන් අතර Lst1 එක සම සංඛ් යා පෙළක් බවට පත් කරන්න.// සහ ඒක තීරණය කරනවා ඒක කරන්න පුළුවන්ද කියලා  මූලද් රව් ය හුවමාරුවක් // මේ ප් රශ්නයේදී, ඔබ ක් රියාත්මක කරන්නේ සංඛ් යා අරා දෙකක් ගන්නා ක් රියාකාරකමක්, /// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])
/// ""YES""
/// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])
/// ""NO""
/// It is assumed that the input arrays will be non-empty.
func exchange(lst1: [Int], lst2: [Int]) -> String {
","func exchange(lst1: [Int], lst2: [Int]) -> String {
    var hasOddInLst1 = false
    var hasEvenInLst2 = false
    
    for num in lst1 {
        if num % 2 != 0 {
            hasOddInLst1 = true
            break
        }
    }
    
    for num in lst2 {
        if num % 2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasOddInLst1 {
        return ""YES""
    }
    
    if hasEvenInLst2 {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == ""YES"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == ""NO"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == ""NO"")
assert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == ""NO"")
assert(exchange(lst1: [100, 200], lst2: [200, 200]) == ""YES"")"
HumanEval_111,sin_Sinh,swift,"
// උදාහරණය: // අකුරු කිහිපයක් එකම ආකාරයෙන් ඇති නම්, ඒවා සියල්ලම නැවත ලබා දෙන්න.// අකුරෙන් අකුරක් නැවත නැවතත් කියවෙන අතර ඒ අකුරෙ අංකයත් ඇතුලත් වෙනවා.// අවකාශය වෙන් කරන ලද කුඩා අකුරු නියෝජනය කරන නූලක් ලබා දී ඇත, ශබ්ද කෝෂයක් ආපසු /// >>> histogram(test: ""a b c"")
/// [""a"" : 1, ""b"" : 1, ""c"" : 1]
/// >>> histogram(test: ""a b b a"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""a b c a b"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""b b b b a"")
/// [""b"" : 4]
/// >>> histogram(test: """")
/// [:] as [String : Int]
func histogram(test: String) -> [String : Int] {
","func histogram(test: String) -> [String : Int] {
    var letterCount: [String: Int] = [:]

    // Split the string into an array of letters
    let letters = test.split(separator: "" "").map { String($0) }

    // Count occurrences of each letter
    for letter in letters {
        letterCount[letter, default: 0] += 1
    }

    // Determine the maximum number of occurrences
    guard let maxCount = letterCount.values.max() else {
        return [:] as [String : Int]
    }

    // Filter the letterCount dictionary to only include letters with the max count
    let result = letterCount.filter { $0.value == maxCount }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(histogram(test: ""a b b a"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c a b"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c d g"") == [""a"" : 1, ""b"" : 1, ""c"" : 1, ""d"" : 1, ""g"" : 1])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: ""b b b b a"") == [""b"" : 4])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: """") == [:] as [String : Int])
assert(histogram(test: ""a"") == [""a"" : 1])"
HumanEval_112,sin_Sinh,swift,"
// උදාහරණය // ඔබ නැවත ලබා දිය යුත්තේ ප් රතිඵල අකුරු පෙළ සහ සත් ය/ අසත් ය යන අකුරු වලින් සමන්විත ටුපල් එකක්.// පේළියක් පැලින්ඩ් රෝම් එකක් ලෙස හැඳින්වෙන්නේ එය ඉදිරියට වගේම පසුපසටත් කියවිය හැකි නම්.//එතකොට බලන්න ප් රතිඵලයේ තියෙන string එක palindrome එකක්ද කියලා.අපිට S සහ C කියන නූල් දෙක ලැබෙනවා, ඔයා S වල තියෙන ඕනම අකුරක් C වල තියෙන ඕනම අකුරකට සමාන වෙන විදිහට මකලා දාන්න ඕනේ.- කාර්යය/// >>> reverse_delete(s: ""abcde"", c: ""ae"")
/// (""bcd"", false)
/// >>> reverse_delete(s: ""abcdef"", c: ""b"")
/// (""acdef"", false)
/// >>> reverse_delete(s: ""abcdedcba"", c: ""ab"")
/// (""cdedc"", true)
func reverse_delete(s: String, c: String) -> (String, Bool) {
","func reverse_delete(s: String, c: String) -> (String, Bool) {
    // Remove characters from s that are in c
    let filteredString = s.filter { !c.contains($0) }
    
    // Check if the resulting string is a palindrome
    let isPalindrome = filteredString == String(filteredString.reversed())
    
    // Return the resulting string and the palindrome check result
    return (filteredString, isPalindrome)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(reverse_delete(s: ""abcde"", c: ""ae"") == (""bcd"", false))
assert(reverse_delete(s: ""abcdef"", c: ""b"") == (""acdef"", false))
assert(reverse_delete(s: ""abcdedcba"", c: ""ab"") == (""cdedc"", true))
assert(reverse_delete(s: ""dwik"", c: ""w"") == (""dik"", false))
assert(reverse_delete(s: ""a"", c: ""a"") == ("""", true))
assert(reverse_delete(s: ""abcdedcba"", c: """") == (""abcdedcba"", true))
assert(reverse_delete(s: ""abcdedcba"", c: ""v"") == (""abcdedcba"", true))
assert(reverse_delete(s: ""vabba"", c: ""v"") == (""abba"", true))
assert(reverse_delete(s: ""mamma"", c: ""mia"") == ("""", true))"
HumanEval_113,sin_Sinh,swift,"
// අමුතු අංක වලින් i'th string එක ඇතුලත් කරන්න.// ආදාන අංකයේ i නූල. "" මෙහිදී සියලුම i අංක  මගින් ප් රතිස්ථාපනය කළ යුතුය.// output එකේ i කියන එකාට ""අනන් ය අංග ගණන"" වෙන්න ඕන.// අංක වලින් පමණක් සමන්විත අක්ෂර මාලාවක් ලබා දී, අංක මාලාවක් නැවත ලබා දෙන්න./// >>> odd_count(lst: [""1234567""])
/// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
/// >>> odd_count(lst: [""3"", ""11111111""])
/// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
func odd_count(lst: [String]) -> [String] {
","func odd_count(lst: [String]) -> [String] {
    return lst.map { str in
        let oddCount = str.filter { ""13579"".contains($0) }.count
        return ""the number of odd elements \(oddCount)n the str\(oddCount)ng \(oddCount) of the \(oddCount)nput.""
    }
}

// Example Usage
print(odd_count(lst: [""1234567""]))
print(odd_count(lst: [""3"", ""11111111""]))","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(odd_count(lst: [""1234567""]) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""])
assert(odd_count(lst: [""3"", ""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""])
assert(odd_count(lst: [""271"", ""137"", ""314""]) == [""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""])"
HumanEval_114,sin_Sinh,swift,"
// උදාහරණය // සංඛ් යා වල. // පූර්ණ සංඛ් යා අරා එකක් දීලා, හිස් නොවන උප අරා වල අවම එකතුව හොයාගන්න /// >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(nums: [-1, -2, -3])
/// -6
func minSubArraySum(nums: [Int]) -> Int {
","func minSubArraySum(nums: [Int]) -> Int {
    guard !nums.isEmpty else { return 0 }
    
    var currentMin = nums[0]
    var overallMin = nums[0]
    
    for i in 1..<nums.count {
        currentMin = min(nums[i], currentMin + nums[i])
        overallMin = min(overallMin, currentMin)
    }
    
    return overallMin
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)
assert(minSubArraySum(nums: [-1, -2, -3]) == -6)
assert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)
assert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)
assert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)
assert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)
assert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)
assert(minSubArraySum(nums: [-10]) == -10)
assert(minSubArraySum(nums: [7]) == 7)
assert(minSubArraySum(nums: [1, -1]) == -1)"
HumanEval_115,sin_Sinh,swift,"
// උදාහරණය 1:// බාල්දි පහලට දාන්න ඕන වාර ගණනක් දෙන්න.// ඔයාගේ වැඩේ තමයි ළිං හිස් කරන්න බාල්දි පාවිච්චි කරන එක.// ඒ වගේම හැම බාල්දියකම එකම ධාරිතාවක් තියෙනවා.// සෑම ළිඳකටම ජලය ලබා ගැනීමට භාවිතා කළ හැකි අනුරූප බාල්දියක් ඇත, // ඒ වගේම පේළියේ තියෙන 1 එකකට ජල ඒකකයක් නියෝජනය කරනවා.ඔබට ලැබෙන්නේ සිරස් කෝණයේ ළිං ජාලයක්./// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)
/// 6
/// Example 2:
/// >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)
/// 5
/// Example 3:
/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
func max_fill(grid: [[Int]], capacity: Int) -> Int {
","func max_fill(grid: [[Int]], capacity: Int) -> Int {
    var totalWater = 0
    for row in grid {
        for unit in row {
            if unit == 1 {
                totalWater += 1
            }
        }
    }
    return (totalWater + capacity - 1) / capacity
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)
assert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)
assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
HumanEval_116,sin_Sinh,swift,"
// ඒක ක් රියාත්මක කරන්න ඕන මේ විදියට: // සමාන අංකයක් තියෙන එකෙක්ට දශම අගය අනුව වර්ග කරන්න.// ඒකක ගණන ඒවායේ ද්විමය නිරූපණයේ ඉහළ යන පිළිවෙලට. // මේ කතාවේදී, ඔයා ණ නොවන සම්පූර්ණ සංඛ් යා අරාව වර්ග කරන්න ඕනේ  අනුව/// >>> sort_array(arr: [1, 5, 2, 3, 4])
/// [1, 2, 3, 4, 5]
/// >>> sort_array(arr: [-2, -3, -4, -5, -6])
/// [-6, -5, -4, -3, -2]
/// >>> sort_array(arr: [1, 0, 2, 3, 4])
/// [0, 1, 2, 3, 4]
func sort_array(arr: [Int]) -> [Int] {
","func sort_array(arr: [Int]) -> [Int] {
    return arr.sorted {
        let onesCount1 = $0.nonNegativeOnesCount()
        let onesCount2 = $1.nonNegativeOnesCount()
        return (onesCount1, $0) < (onesCount2, $1)
    }
}

extension Int {
    func nonNegativeOnesCount() -> Int {
        return self < 0 ? 0 : self.nonBitCount()
    }
    
    private func nonBitCount() -> Int {
        var count = 0
        var num = self
        while num > 0 {
            count += num & 1
            num >>= 1
        }
        return count
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])
assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])
assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])
assert(sort_array(arr: [] as [Int]) == [] as [Int])
assert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])
assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
HumanEval_117,sin_Sinh,swift,"
// උදාහරණ: // සටහන: ඔබ උපකල්පනය කල හැකිය ආදාන නූල අකුරු සහ අවකාශයන් පමණක් අඩංගු වේ.// s අකුරු පෙළ හිස් නම්, ක් රියාකාරීත්වය හිස් අරාව නැවත ලබා දිය යුතුය.// n ඛණ්ඩ, මෙම වචන පේළියේ ඇති පිළිවෙලට.// string s වලින් හරියටම  අර්ථය සහිතව සියලු වචන වලින් සමන්විත array එකක් ලබා දෙන function එකක්.// ලබා දී ඇති string s සහ ස්වාභාවික අංක n, ඔබට කාර්ය භාර දී ඇත /// >>> select_words(s: ""Mary had a little lamb"", n: 4)
/// [""little""]
/// >>> select_words(s: ""Mary had a little lamb"", n: 3)
/// [""Mary"", ""lamb""]
/// >>> select_words(s: ""simple white space"", n: 2)
/// [] as [String]
/// >>> select_words(s: ""Hello world"", n: 4)
/// [""world""]
/// >>> select_words(s: ""Uncle sam"", n: 3)
/// [""Uncle""]
func select_words(s: String, n: Int) -> [String] {
","func select_words(s: String, n: Int) -> [String] {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    let words = s.split(separator: "" "")
    var result: [String] = []
    
    for word in words {
        let consonantCount = word.filter { !vowels.contains($0) }.count
        if consonantCount == n {
            result.append(String(word))
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(select_words(s: ""Mary had a little lamb"", n: 4) == [""little""])
assert(select_words(s: ""Mary had a little lamb"", n: 3) == [""Mary"", ""lamb""])
assert(select_words(s: ""simple white space"", n: 2) == [] as [String])
assert(select_words(s: ""Hello world"", n: 4) == [""world""])
assert(select_words(s: ""Uncle sam"", n: 3) == [""Uncle""])
assert(select_words(s: """", n: 4) == [] as [String])
assert(select_words(s: ""a b c d e f"", n: 1) == [""b"", ""c"", ""d"", ""f""])"
HumanEval_118,sin_Sinh,swift,"
// උදාහරණය: // ඔයා හිතනව ඇති ඒ string එකේ තියෙන්නේ ඉංග් රීසි අකුරු විතරයි කියලා.// ඉහත කොන්දේසි වලට ගැලපෙන ඕනෑම ස්වරයක් සොයා ගන්න.// ආරම්භයේ සහ අවසානයේ ඇති ස්වර ගණන් ගන්නෙ නෑ.// වචනයේ දකුණු පැත්තෙන් අකුරු දෙකක් (අකුරු සංවේදී).ඔයාට වචනයක් දීලා තියෙනවා. ඔයාගේ වැඩේ තමයි  අතර තියෙන ලංවෙන ස්වරය හොයාගන්න එක./// >>> get_closest_vowel(word: ""yogurt"")
/// ""u""
/// >>> get_closest_vowel(word: ""FULL"")
/// ""U""
/// >>> get_closest_vowel(word: ""quick"")
/// """"
/// >>> get_closest_vowel(word: ""ab"")
/// """"
func get_closest_vowel(word: String) -> String {
","func get_closest_vowel(word: String) -> String {
    let vowels = Set(""aeiouAEIOU"")
    var foundVowel: Character? = nil
    
    for i in stride(from: word.count - 2, through: 1, by: -1) {
        let currentIndex = word.index(word.startIndex, offsetBy: i)
        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)
        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)
        
        if vowels.contains(word[currentIndex]) && 
            !vowels.contains(word[previousIndex]) && 
            !vowels.contains(word[nextIndex]) {
            foundVowel = word[currentIndex]
            break
        }
    }
    
    return foundVowel != nil ? String(foundVowel!) : """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: ""yogurt"") == ""u"")
assert(get_closest_vowel(word: ""full"") == ""u"")
assert(get_closest_vowel(word: ""easy"") == """")
assert(get_closest_vowel(word: ""eAsy"") == """")
assert(get_closest_vowel(word: ""ali"") == """")
assert(get_closest_vowel(word: ""bad"") == ""a"")
assert(get_closest_vowel(word: ""most"") == ""o"")
assert(get_closest_vowel(word: ""ab"") == """")
assert(get_closest_vowel(word: ""ba"") == """")
assert(get_closest_vowel(word: ""quick"") == """")
assert(get_closest_vowel(word: ""anime"") == ""i"")
assert(get_closest_vowel(word: ""Asia"") == """")
assert(get_closest_vowel(word: ""Above"") == ""o"")"
HumanEval_119,sin_Sinh,swift,"
// උදාහරණ: // හොඳ string එකක් හදන්න පුළුවන් නම් 'Yes' දෙන්න, නැතිනම් 'No' දෙන්න.// '()) ' එහෙම නෙවෙයි.// සමබරයි. උදාහරණයක් ලෙස: '(())))' නූල හොඳයි, // S හි ඇති සියලුම parentheses හොඳ නම් සහ හොඳ නම් පමණක් string S ලෙස සැලකේ.// යම්කිසි අනුපිළිවෙලක්, ඵලදායි නූල හොඳ වෙයි.// ඔයාගේ වැඩේ තමයි ත් රෙඩ් දෙක එකට සම්බන්ධ කරන්න පුළුවන්ද කියලා පරීක්ෂා කරන එක.// කුරුටු "" (_) "" හෝ කුරුටු "" (_) "" පමණක් වසා දමන්න.// ඔයාට string දෙකක් තියෙන array එකක් දෙනවා, string දෙකම open වලින් සමන්විතයි./// >>> match_parens(lst: [""()("", "")""])
/// ""Yes""
/// >>> match_parens(lst: ["")"", "")""])
/// ""No""
func match_parens(lst: [String]) -> String {
","func match_parens(lst: [String]) -> String {
    let combined1 = lst[0] + lst[1]
    let combined2 = lst[1] + lst[0]
    
    func isBalanced(_ s: String) -> Bool {
        var balance = 0
        for char in s {
            if char == ""("" {
                balance += 1
            } else if char == "")"" {
                balance -= 1
            }
            if balance < 0 {
                return false
            }
        }
        return balance == 0
    }
    
    if isBalanced(combined1) || isBalanced(combined2) {
        return ""Yes""
    } else {
        return ""No""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(match_parens(lst: [""()("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", "")""]) == ""No"")
assert(match_parens(lst: [""(()(())"", ""())())""]) == ""No"")
assert(match_parens(lst: ["")())"", ""(()()(""]) == ""Yes"")
assert(match_parens(lst: [""(())))"", ""(()())((""]) == ""Yes"")
assert(match_parens(lst: [""()"", ""())""]) == ""No"")
assert(match_parens(lst: [""(()("", ""()))()""]) == ""Yes"")
assert(match_parens(lst: [""(((("", ""((())""]) == ""No"")
assert(match_parens(lst: ["")(()"", ""(()(""]) == ""No"")
assert(match_parens(lst: ["")("", "")(""]) == ""No"")
assert(match_parens(lst: [""("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", ""(""]) == ""Yes"")"
HumanEval_120,sin_Sinh,swift,"
// උදාහරණය 1:// දිග k සහිත උපරිම k සංඛ් යා arr න්.// පූර්ණ සංඛ් යා arr සහ ධනාත්මක පූර්ණ සංඛ් යා k ලබා දී ඇති විට, ෙසිදු කළ අරාවක් ලබා දෙන්න /// >>> maximum(arr: [-3, -4, 5], k: 3)
/// [-4, -3, 5]
/// Example 2:
/// >>> maximum(arr: [4, -4, 4], k: 2)
/// [4, 4]
/// Example 3:
/// >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)
/// [2]
/// Note:
/// 1. The length of the array will be in the range of [1, 1000].
/// 2. The elements in the array will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
func maximum(arr: [Int], k: Int) -> [Int] {
","func maximum(arr: [Int], k: Int) -> [Int] {
    guard k > 0 else { return [] }
    let sortedArr = arr.sorted(by: >)
    let maxElements = Array(sortedArr.prefix(k))
    return maxElements.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])
assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])
assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])
assert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])
assert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])
assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])
assert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])
assert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])
assert(maximum(arr: [4, -4], k: 2) == [-4, 4])
assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])
assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
HumanEval_121,sin_Sinh,swift,"
// උදාහරණ // හිස් නොවන පූර්ණ සංඛ් යා අරාව ලබා දී ඇති විට, සම ස්ථානවල ඇති සියලුම අමුද් රව් යවල එකතුව නැවත ලබා දෙන්න. /// >>> solution(lst: [5, 8, 7, 1])
/// 12
/// >>> solution(lst: [3, 3, 3, 3, 3])
/// 9
/// >>> solution(lst: [30, 13, 24, 321])
/// 0
func solution(lst: [Int]) -> Int {
","func solution(lst: [Int]) -> Int {
    var sum = 0
    for (index, value) in lst.enumerated() {
        if index % 2 == 0 && value % 2 != 0 {
            sum += value
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solution(lst: [5, 8, 7, 1]) == 12)
assert(solution(lst: [3, 3, 3, 3, 3]) == 9)
assert(solution(lst: [30, 13, 24, 321]) == 0)
assert(solution(lst: [5, 9]) == 5)
assert(solution(lst: [2, 4, 8]) == 0)
assert(solution(lst: [30, 13, 23, 32]) == 23)
assert(solution(lst: [3, 13, 2, 9]) == 3)"
HumanEval_122,sin_Sinh,swift,"
// උදාහරණය: // arr හි පළමු k මූලද් රව් යයන්ගෙන් ඉහලම අංක දෙකකින් යුත් මූලද් රව් යයන්ගේ එකතුව. // හිස් නොවන arr සහ k සංඛ් යා සමස්ථ සංඛ් යා අරාව ලබා දී, return /// >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
func add_elements(arr: [Int], k: Int) -> Int {
","func add_elements(arr: [Int], k: Int) -> Int {
    var sum = 0
    for i in 0..<k {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)
assert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)
assert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)
assert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)
assert(add_elements(arr: [1], k: 1) == 1)"
HumanEval_123,sin_Sinh,swift,"
// get_odd_collatz(5) නැවත ලබා දෙන්නේ [1, 5] # 5 සඳහා වන collatz අනුක් රමය [5, 16, 8, 4, 2, 1], එබැවින් අමුතු සංඛ් යා වන්නේ 1 සහ 5 පමණි. උදාහරණයක් ලෙස:// 2. නැවත ලබා දුන් අරා වර්ධනය වන අනුපිළිවෙල අනුව වර්ග කර ඇත. // 1. Collatz(1) යනු [1] වේ.// සටහන: //term+1. අනුමානය නම් n හි අගය කුමක් වුවත්, අනුක් රමය සැමවිටම 1 දක්වා ළඟා වනු ඇත.// කලින් පදය. කලින් පදය අපරිමිත නම්, ඊලඟ පදය කලින් පදය මෙන් 3 ගුණයක් වේ.//පෙර පදය ඊලඟට: පෙර පදය සම නම්, ඊලඟ පදය න් බාගයක් වේ// පහත පරිදි: ඕනෑම ධනාත්මක පූර්ණ සංඛ් යාවක් n වලින් ආරම්භ කරන්න. එවිට සෑම පදයක්ම                                                           // කොලට්ස් අනුමානය යනු ගණිතයේ අනුමානයකි. එය අර්ථ දක්වා ඇති අනුක් රමයක් ගැන සැලකිලිමත් වේ.// ධනාත්මක පූර්ණ සංඛ් යාවක් n ලබා දී, අමු අංක කොලට්ස් අනුක් රමයේ ඇති වර්ග කළ අරාවක් නැවත ලබා දෙන්න. /// >>> get_odd_collatz(n: 5)
/// [1, 5]
func get_odd_collatz(n: Int) -> [Int] {
","func get_odd_collatz(n: Int) -> [Int] {
    var collatzSequence: [Int] = []
    var number = n

    while number != 1 {
        if number % 2 != 0 {
            collatzSequence.append(number)
        }
        if number % 2 == 0 {
            number /= 2
        } else {
            number = 3 * number + 1
        }
    }

    collatzSequence.append(1) // append 1 as the sequence ends at 1

    let sortedOdds = collatzSequence.sorted()
    
    return sortedOdds
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])
assert(get_odd_collatz(n: 5) == [1, 5])
assert(get_odd_collatz(n: 12) == [1, 3, 5])
assert(get_odd_collatz(n: 1) == [1])"
HumanEval_124,sin_Sinh,swift,"
දිනය විය යුත්තේ: mm-dd-yyyy මාසය 1 ට අඩු හෝ 12 ට වැඩි නොවිය යුතුයි.මාස 1,3,5,7,8,10,12 සඳහා දින ගණන 1 ට අඩු හෝ 31 ට වැඩි නොවන අතර මාස 4,6,9,11 සඳහා දින ගණන 1 ට අඩු හෝ 30 ට වැඩි නොවන අතර මාස 2 සඳහා දින ගණන 1 ට අඩු හෝ 29 ට වැඩි නොවේ.දිනය හිස් නැහැ.// පහත සඳහන් නීති සියල්ලම සපුරා ඇත්නම් දිනය වලංගු වේ: // දිනය වලංගු නම් true නැවත ලබාදෙනවා.// ඔයාලාට ලියන්න වෙනවා යම් දිනයක් වලංගු කරන ශ් රිතයක් සහ /// >>> valid_date(date: ""03-11-2000"")
/// true
/// >>> valid_date(date: ""15-01-2012"")
/// false
/// >>> valid_date(date: ""04-0-2040"")
/// false
/// >>> valid_date(date: ""06-04-2020"")
/// true
/// >>> valid_date(date: ""06/04/2020"")
/// false
func valid_date(date: String) -> Bool {
","func valid_date(date: String) -> Bool {
    // Check if the date is empty
    if date.isEmpty {
        return false
    }
    
    // Split the date into components using the ""-"" delimiter
    let components = date.split(separator: ""-"")
    
    // Ensure the date has exactly three components
    if components.count != 3 {
        return false
    }
    
    // Ensure the date components are integers
    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {
        return false
    }
    
    // Check if the month is within the valid range
    if month < 1 || month > 12 {
        return false
    }
    
    // Define the number of days in each month
    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    // Check the day range for each month
    if day < 1 || day > daysInMonth[month] {
        return false
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(valid_date(date: ""03-11-2000"") == true)
assert(valid_date(date: ""15-01-2012"") == false)
assert(valid_date(date: ""04-0-2040"") == false)
assert(valid_date(date: ""06-04-2020"") == true)
assert(valid_date(date: ""01-01-2007"") == true)
assert(valid_date(date: ""03-32-2011"") == false)
assert(valid_date(date: """") == false)
assert(valid_date(date: ""04-31-3000"") == false)
assert(valid_date(date: ""06-06-2005"") == true)
assert(valid_date(date: ""21-31-2000"") == false)
assert(valid_date(date: ""04-12-2003"") == true)
assert(valid_date(date: ""04122003"") == false)
assert(valid_date(date: ""20030412"") == false)
assert(valid_date(date: ""2003-04"") == false)
assert(valid_date(date: ""2003-04-12"") == false)
assert(valid_date(date: ""04-2003"") == false)"
HumanEval_125,sin_Sinh,swift,"
extension Int: Error {}
        
// උදාහරණ අක්ෂර වින් යාසය, අංකය = 0, අංකය = 1, අංකය = 25// කොමා වලින් බෙදිය යුතුයි ',' කොමා එකක් නැතිනම් ඔයා න් යාය පත් රයේ අමු අකුරු ගණන දෙන්න ඕනේ.// වචන පෙළක් ලබා දී, ඔබ තෝරාගත් පෙළෙහි කිසිදු හිස් අවකාශයක් නොමැති නම්, හිස් අවකාශය මත බෙදන ලද වචන මාලාවක් ආපසු ලබා දෙන්න./// >>> split_words(txt: ""Hello world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""Hello,world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""abcdef"")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
","func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains("" "") {
        let words = txt.split(separator: "" "").map { String($0) }
        return .success(words)
    } else if txt.contains("","") {
        let words = txt.split(separator: "","").map { String($0) }
        return .success(words)
    } else {
        let oddOrderedLowerCaseLetters = txt.filter { char in
            if let asciiValue = char.asciiValue {
                let order = asciiValue - Character(""a"").asciiValue!
                return order % 2 == 1
            }
            return false
        }
        return .failure(oddOrderedLowerCaseLetters.count)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: ""Hello world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello,world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello world,!"") == .success([""Hello"", ""world,!""]))
assert(split_words(txt: ""Hello,Hello,world !"") == .success([""Hello,Hello,world"", ""!""]))
assert(split_words(txt: ""abcdef"") == .failure(3))
assert(split_words(txt: ""aaabb"") == .failure(2))
assert(split_words(txt: ""aaaBb"") == .failure(1))
assert(split_words(txt: """") == .failure(0))"
HumanEval_126,sin_Sinh,swift,"
// උදාහරණ // අංකය, false නැවත ලබාදෙනවා. ණ අංක නොතිබුනා කියලා උපකල්පනය කරන්න.// අරා එකකට එකකට වඩා අනුපිටපත් තියෙනවා නම්// අංක මාලාවක් ලබා දීලා, ඒවා වර්ග කළත් නැතත්, නැවත ලබා දෙන්න./// >>> is_sorted(lst: [5])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])
/// false
func is_sorted(lst: [Int]) -> Bool {
","func is_sorted(lst: [Int]) -> Bool {
    guard !lst.isEmpty else { return true }

    var previous = lst[0]
    var duplicates = 0

    for i in 1..<lst.count {
        if lst[i] < previous {
            return false
        } else if lst[i] == previous {
            duplicates += 1
            if duplicates > 1 {
                return false
            }
        } else {
            duplicates = 0
        }
        previous = lst[i]
    }

    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_sorted(lst: [5]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)
assert(is_sorted(lst: [] as [Int]) == true)
assert(is_sorted(lst: [1]) == true)
assert(is_sorted(lst: [3, 2, 1]) == false)
assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)
assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
HumanEval_127,sin_Sinh,swift,"
// [ආදාන / ප්රතිදාන] සාම්පල: // පරතරයන් දෙක එකිනෙකට සමපාත නොවුනොත්, ""NO"" දෙන්න.// එහෙම නැත්නම්, ""NO"" කියලා දෙන්න.// හරස්පදය ප් රථම සංඛ් යාවක් නම්, ""YES"" නැවත දෙන්න, // එහි දිග 1 වන අතර එය ප් රථම සංඛ් යාවක් නොවේ. // උදාහරණය, පරතරයන්ගේ හරස්පදය (1, 3), (2, 4) (2, 3) // පරතරය ප් රථම අංකයක්. // ඔබේ කාර්යය තමයි මේ දෙකේ ඛණ්ඩනයක දිග // සෑම කාල පරිච්ඡේදයක් සඳහාම, එහි ආරම්භය එහි අවසානයට වඩා අඩු හෝ සමාන යැයි උපකල්පනය කෙරේ.// ආරම්භය සහ අවසානය දෙකම ඇතුළත් වේ.// ලබා දී ඇති කාල පරාසය වසා ඇත, එයින් අදහස් වන්නේ කාල පරාසය (ආරම්භය, අවසානය) // මෙහිදී සෑම පරතරයක්ම පූර්ණ සංඛ් යා යුගලයක් වේ. උදාහරණයක් ලෙස, පරතරය = (ආරම්භය, අවසානය) = (1, 2).// ඔබට කාල පරතර දෙකක් ලබා දී ඇත, /// >>> intersection(interval1: (1, 2), interval2: (2, 3))
/// ""NO""
/// >>> intersection(interval1: (-1, 1), interval2: (0, 4))
/// ""NO""
/// >>> intersection(interval1: (-3, -1), interval2: (-5, 5))
/// ""YES""
func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
","func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
    // Helper function to determine if a number is prime
    func isPrime(_ num: Int) -> Bool {
        if num <= 1 {
            return false
        }
        if num <= 3 {
            return true
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false
        }
        var i = 5
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Find the start and end of the intersection
    let intersectStart = max(interval1.0, interval2.0)
    let intersectEnd = min(interval1.1, interval2.1)
    
    // Calculate the length of the intersection
    let intersectionLength = intersectEnd - intersectStart

    // Check if intersection length is positive and prime
    if intersectionLength > 0 && isPrime(intersectionLength) {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersection(interval1: (1, 2), interval2: (2, 3)) == ""NO"")
assert(intersection(interval1: (-1, 1), interval2: (0, 4)) == ""NO"")
assert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == ""YES"")
assert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == ""YES"")
assert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (3, 5)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (1, 2)) == ""NO"")
assert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == ""NO"")"
HumanEval_128,sin_Sinh,swift,"
// උදාහරණය: // සටහන: හිස් arr සඳහා නිල් නැවත ලබා දෙන්න. // අරාවෙ තියෙන හැම අංකයක්ම, 1, -1 හෝ 0 මගින් නිරූපණය කරනවා.// සම්පූර්ණ සංඛ් යා වල ප් රමාණයන් එකතු කිරීම සියලු සංඥා වල ගුණනය // ඔබට පූර්ණ සංඛ් යා සමූහයක් ලබා දීලා තියෙනවා, ඔබ නැවත /// >>> prod_signs(arr: [1, 2, 2, -4])
/// 9
/// >>> prod_signs(arr: [0, 1])
/// 0
/// >>> prod_signs(arr: [] as [Int])
/// nil
func prod_signs(arr: [Int]) -> Int? {
","func prod_signs(arr: [Int]) -> Int? {
    // Return nil for empty array
    if arr.isEmpty {
        return nil
    }

    // Calculate the sum of magnitudes
    let sumOfMagnitudes = arr.reduce(0) { sum, num in
        return sum + abs(num)
    }

    // Calculate the product of all signs
    let productOfSigns = arr.reduce(1) { product, num in
        if num > 0 {
            return product * 1
        } else if num < 0 {
            return product * -1
        } else {
            return 0
        }
    }

    // Return the result of sum of magnitudes multiplied by product of signs
    return sumOfMagnitudes * productOfSigns
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prod_signs(arr: [1, 2, 2, -4]) == -9)
assert(prod_signs(arr: [0, 1]) == 0)
assert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)
assert(prod_signs(arr: [] as [Int]) == nil)
assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)
assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)
assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)
assert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
HumanEval_129,sin_Sinh,swift,"
// උදාහරණ: // අවම මාර්ගය හරහා යන සෛල වල අගයන්ගෙන් යුත් පිළිවෙලට සැකසූ අරාවක් නැවත ලබා දෙන්න. // පිළිතුර අද්විතීයයි කියලා සහතිකයි.// lst_A[j] = lst_B[j]  කියලා.// lst_A[i] < lst_B[i] සහ ඕනෑම j (1 <= j < i) සඳහා අපට // lst_B ට වඩා, වෙනත් වචනවලින් කියනවා නම්, i (1 <= i <= k)  කියලා සම්පූර්ණ සංඛ් යා දර්ශකයක් තියෙනවා.// හරහා (අපි ඒවාට lst_A සහ lst_B කියමු), lst_A වදන් මාලාවේ අඩුයි // A සහ B යන කොටස් වල අගයන් ඇණවුම් කළ අරා සෑදීමෙන් පසුව // A (k දිග) මාර්ගයක් B (k දිග) මාර්ගයකට වඩා කුඩා ලෙස සලකනු ලබන්නේ නම් // ඔයාට පද්ධතියෙන් පිට යන්න බෑ.අනිවාර්යයෙන්ම වෙනස්.// k දිගක් ඇති මාර්ගයක් යන්නෙන් අදහස් කරන්නේ හරියටම k සෛල වලට පිවිසීමයි (නැත // සෛල. // වෙනත් වචනවලින් කියනවා නම්, ඔයාට පුළුවන් සෛල වලට යන්න, ඒකේ කෙළවර ඔයා වගේම තමයි.// ඕනම සෛලයක ඉදන්, හැම පියවරකදිම ඔයාට පුළුවන් ඕනම අසල්වැසි සෛලයක් වෙත යන්න, // ඔයාලට හොයාගන්න වෙනවා පද්ධතියේ k දිගේ අවම මාර්ගය. ඔයාට පටන් ගන්න පුළුවන් // ඇතුලත් කිරීම හරියටම එක් වරක් දැල් කොටු වල ඇති සෛල මත දිස් වේ. // ජාලකයේ සෑම සෛලයකම අගයක් අඩංගු වේ. [1, N * N] පරාසයේ සෑම පූර්ණ සංඛ් යාවක්ම // N පේළි සහ N තීරු සහිත ජාලයක් ලබා දී ඇත (N >= 2) සහ ධනාත්මක පූර්ණ සංඛ් යාවක් k, /// >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)
/// [1, 2, 1]
/// >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)
/// [1]
func minPath(grid: [[Int]], k: Int) -> [Int] {
","func minPath(grid: [[Int]], k: Int) -> [Int] {
    let n = grid.count
    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    struct Path: Comparable {
        let cells: [Int]
        
        static func < (lhs: Path, rhs: Path) -> Bool {
            return lhs.cells.lexicographicallyPrecedes(rhs.cells)
        }
    }
    
    var minPath: Path? = nil
    
    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {
        var currentPath = currentPath
        currentPath.append(grid[x][y])
        
        if currentPath.count == k {
            let newPath = Path(cells: currentPath)
            if minPath == nil || newPath < minPath! {
                minPath = newPath
            }
            return
        }
        
        for direction in directions {
            let newX = x + direction.0
            let newY = y + direction.1
            if newX >= 0 && newX < n && newY >= 0 && newY < n {
                dfs(x: newX, y: newY, k: k, currentPath: currentPath)
            }
        }
    }
    
    for i in 0..<n {
        for j in 0..<n {
            dfs(x: i, y: j, k: k, currentPath: [])
        }
    }
    
    return minPath!.cells
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])
assert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])
assert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])
assert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])
assert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])
assert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])
assert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])
assert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])
assert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])
assert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])
assert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"
HumanEval_130,sin_Sinh,swift,"
// උදාහරණ: // ටිබ් රොනාච්චි අනුක් රමයේ පළමු n + 1 අංක. // ඔබට ණ නොවන පූර්ණ සංඛ් යාවක් n ලබා දී ඇත, ඔබට // = 2 + 3 + 3 = 8 // ත් රිත්වය = ත් රිත්වය + ත් රිත්වය + ත් රිත්වය// ත් රිත්වය 4) = 3 // tri(2) = 1 + (2 / 2) = 2 උදාහරණයක් ලෙස:// tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), n අමුතු නම්. // tri (n) = 1 + n / 2, n සම නම්. // ත් රිත්වය 1) = 3 // ට් රිබොනාච්චි අනුක් රමය නැවත ඇතිවීම මගින් නිර්වචනය වේ: ඒත් මිනිස්සු දන්නෙ නෑ ට් රිබොනාච්චි අනුක් රමය ගැන.// හැමෝම දන්නවා ෆිබොනාච්චි අනුක් රමය, එය ගැඹුරින් අධ් යයනය කරලා තියෙනවා ගණිතඥයන් විසින් /// >>> tri(n: 3)
/// [1, 3, 2, 8]
func tri(n: Int) -> [Int] {
","func tri(n: Int) -> [Int] {
    guard n >= 0 else { return [] }
    if n == 0 { return [1] }
    if n == 1 { return [1, 3] }
    if n == 2 { return [1, 3, 2] }
    
    var sequence = [1, 3, 2]
    
    for i in 3...n {
        if i % 2 == 0 {
            sequence.append(1 + i / 2)
        } else {
            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]
            sequence.append(nextVal)
        }
    }
    
    return sequence
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(tri(n: 3) == [1, 3, 2, 8])
assert(tri(n: 4) == [1, 3, 2, 8, 3])
assert(tri(n: 5) == [1, 3, 2, 8, 3, 15])
assert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])
assert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])
assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])
assert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])
assert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])
assert(tri(n: 0) == [1])
assert(tri(n: 1) == [1, 3])"
HumanEval_131,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// සියලුම ඉලක්කම් සම නම් 0 නැවත ලබා දෙන්න. // ධනාත්මක නිඛිල n ලබා දී, අමු ඉලක්කම් වල ගුණය ලබා දෙන්න. /// >>> digits(n: 1)
/// 1
/// >>> digits(n: 4)
/// 0
/// >>> digits(n: 235)
/// 15
func digits(n: Int) -> Int {
","func digits(n: Int) -> Int {
    var num = n
    var product = 1
    var hasOdd = false
    
    while num > 0 {
        let digit = num % 10
        if digit % 2 != 0 {
            hasOdd = true
            product *= digit
        }
        num /= 10
    }
    
    return hasOdd ? product : 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digits(n: 5) == 5)
assert(digits(n: 54) == 5)
assert(digits(n: 120) == 1)
assert(digits(n: 5014) == 5)
assert(digits(n: 98765) == 315)
assert(digits(n: 5576543) == 2625)
assert(digits(n: 2468) == 0)"
HumanEval_132,sin_Sinh,swift,"
// මෙහිදී අඩුම තරමින් උප අනුක් රමයේ එක් කොටුක කොටසක් වත් ඇතුලත් වේ.// අංකය true ලෙස ලබා දිය යුත්තේ, අංකය නිවැරදි නම් සහ අංකය නිවැරදි නම් පමණි.// චතුරස්රාකාර කොටු වලින් පමණක් සමන්විත නූලක් ආදානය ලෙස ගන්නා ශ් රිතයක් නිර්මාණය කරන්න./// >>> is_nested(string: ""[[]]"")
/// true
/// >>> is_nested(string: ""[]]]]]]][[[[[]"")
/// false
/// >>> is_nested(string: ""[][]"")
/// false
/// >>> is_nested(string: ""[]"")
/// false
/// >>> is_nested(string: ""[[][]]"")
/// true
/// >>> is_nested(string: ""[[]][["")
/// true
func is_nested(string: String) -> Bool {
","func is_nested(string: String) -> Bool {
    var stack: [Character] = []
    var nested = false

    for bracket in string {
        if bracket == ""["" {
            stack.append(bracket)
        } else if bracket == ""]"" {
            if let last = stack.last, last == ""["" {
                stack.removeLast()
                if !stack.isEmpty {
                    nested = true
                }
            } else {
                return false
            }
        }
    }
    return nested
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_nested(string: ""[[]]"") == true)
assert(is_nested(string: ""[]]]]]]][[[[[]"") == false)
assert(is_nested(string: ""[][]"") == false)
assert(is_nested(string: ""[]"") == false)
assert(is_nested(string: ""[[[[]]]]"") == true)
assert(is_nested(string: ""[]]]]]]]]]]"") == false)
assert(is_nested(string: ""[][][[]]"") == true)
assert(is_nested(string: ""[[]"") == false)
assert(is_nested(string: ""[]]"") == false)
assert(is_nested(string: ""[[]][["") == true)
assert(is_nested(string: ""[[][]]"") == true)
assert(is_nested(string: """") == false)
assert(is_nested(string: ""[[[[[[[["") == false)
assert(is_nested(string: ""]]]]]]]]"") == false)"
HumanEval_133,sin_Sinh,swift,"
// උදාහරණ: // අරාවෙ හැම අංගයක්ම ඉහලම ඉන්ටර්නෙට් එකට වට කරන්න.// අපිට අවශ් ය වෙනවා අරාවෙ ඇති දෙගුණ සංඛ් යා වල එකතුව ලබා දෙන්න, // ඔයාට අංක මාලාවක් ලැබෙනවා./// >>> sum_squares(lst: [1.0, 2.0, 3.0])
/// 14
/// >>> sum_squares(lst: [1.0, 4.0, 9.0])
/// 98
/// >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> sum_squares(lst: [1.4, 4.2, 0.0])
/// 29
/// >>> sum_squares(lst: [-2.4, 1.0, 1.0])
/// 6
func sum_squares(lst: [Double]) -> Int {
","func sum_squares(lst: [Double]) -> Int {
    return lst.map { ceil($0) } // Round each element to the upper int (Ceiling)
              .map { Int($0 * $0) } // Square each element
              .reduce(0, +) // Sum all squared elements
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)
assert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)
assert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)
assert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)
assert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)
assert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)
assert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)
assert(sum_squares(lst: [0.0]) == 0)
assert(sum_squares(lst: [-1.0]) == 1)
assert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"
HumanEval_134,sin_Sinh,swift,"
// උදාහරණ: // සටහන: ""වචනය"" යනු අවකාශය මගින් වෙන් කරන ලද අක්ෂර සමූහයකි.// වචනයක කොටසක්, අනෙක් පැත්තෙන් අසත් ය.// අක්ෂර මාලාවක අක්ෂර මාලාවක අක්ෂරයක් වන අතර එය  නොවේ// අන්තිම අක්ෂරය true නම් true නැවත ලබාදෙන ශ් රිතයක් නිර්මාණය කරන්න./// >>> check_if_last_char_is_a_letter(txt: ""apple pie"")
/// false
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e"")
/// true
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e "")
/// false
/// >>> check_if_last_char_is_a_letter(txt: """")
/// false
func check_if_last_char_is_a_letter(txt: String) -> Bool {
","func check_if_last_char_is_a_letter(txt: String) -> Bool {
    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {
        return false
    }
    
    if lastChar.isLetter {
        let words = txt.split(separator: "" "")
        if let lastWord = words.last {
            return lastWord.count == 1
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(check_if_last_char_is_a_letter(txt: ""apple"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e"") == true)
assert(check_if_last_char_is_a_letter(txt: ""eeeee"") == false)
assert(check_if_last_char_is_a_letter(txt: ""A"") == true)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie "") == false)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie 1"") == false)
assert(check_if_last_char_is_a_letter(txt: """") == false)
assert(check_if_last_char_is_a_letter(txt: ""eeeee e "") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pie"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e "") == false)"
HumanEval_135,sin_Sinh,swift,"
// උදාහරණ: // අගයන් දෙගුණ වෙනවා.// එවැනි අංගයක් නොමැති නම් නැවත -1. ලබා දී ඇති අරාවෙහි  අඩංගු නොවේ// එය වහාම පෙරට එන මූලද්රව්යයට වඩා වැඩි හෝ සමාන නොවේ.// න් යාය පත් රයකට අනුව න් යාය පත් රයකට අනුව න් යාය පත් රයකට අනුව න් යාය පත් රයකට අනුව න් යාය පත් රයකට අනුව/// >>> can_arrange(arr: [1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(arr: [1, 2, 3])
/// -1
func can_arrange(arr: [Int]) -> Int {
","func can_arrange(arr: [Int]) -> Int {
    for i in (1..<arr.count).reversed() {
        if arr[i] < arr[i - 1] {
            return i
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)
assert(can_arrange(arr: [1, 2, 4, 5]) == -1)
assert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)
assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)
assert(can_arrange(arr: [] as [Int]) == -1)"
HumanEval_136,sin_Sinh,swift,"
// උදාහරණ: // ණ හෝ ධනාත්මක නිඛිල සංඛ් යා නොමැති නම්, ඒවා nil ලෙස ලබා දෙන්න. ධනාත්මක පූර්ණ සංඛ් යා එකතුවක්.// ණ නිරන්තර සංඛ් යා අතරින් විශාලතම සංඛ් යාව, සහ 'b' කුඩාම සංඛ් යාව //අපි function එකක් හදමු ඒකෙන් අපිට ලැබෙන්නේ a,b කියන tuple එක, මෙතන 'a' කියන්නේ /// >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])
/// (nil, 1)
/// >>> largest_smallest_integers(lst: [] as [Int])
/// (nil, nil)
/// >>> largest_smallest_integers(lst: [0])
/// (nil, nil)
func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
","func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
    var largestNegative: Int? = nil
    var smallestPositive: Int? = nil

    for number in lst {
        if number < 0 {
            if largestNegative == nil || number > largestNegative! {
                largestNegative = number
            }
        } else if number > 0 {
            if smallestPositive == nil || number < smallestPositive! {
                smallestPositive = number
            }
        }
    }

    return (largestNegative, smallestPositive)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))
assert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))
assert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))
assert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))
assert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))
assert(largest_smallest_integers(lst: [0]) == (nil, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"
HumanEval_137,sin_Sinh,swift,"
enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
// සටහන: සැබෑ සංඛ් යාවක් නූලක් ලෙස නිරූපණය කර ඇත්නම්, පාවෙන ලක්ෂ් යය විය හැකිය . හෝ , // අගයන් සමාන නම් null නැවත ලබා දෙන්න. // තථ් ය සංඛ් යා, සහ එහි දී ඇති විචල් ය වර්ගයේ විශාල විචල් යය නැවත ලබා දෙයි. // සම්පූර්ණ සංඛ් යා, පාවෙන සංඛ් යා, හෝ නූල් නියෝජනය කරන ශ් රිතයක් ගන්න/// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue(""2,3""))
/// .stringValue(""2,3"")
/// >>> compare_one(a: .stringValue(""5,1""), b: .stringValue(""6""))
/// .stringValue(""6"")
/// >>> compare_one(a: .stringValue(""1""), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
","func compare_one(a: Value, b: Value) -> Value? {
    func convertToDouble(value: Value) -> Double? {
        switch value {
        case .intValue(let int):
            return Double(int)
        case .doubleValue(let double):
            return double
        case .stringValue(let string):
            let formatter = NumberFormatter()
            formatter.locale = Locale(identifier: ""en_US_POSIX"")
            if string.contains("","") {
                formatter.decimalSeparator = "",""
            } else {
                formatter.decimalSeparator = "".""
            }
            return formatter.number(from: string)?.doubleValue
        }
    }
    
    let aDouble = convertToDouble(value: a)
    let bDouble = convertToDouble(value: b)
    
    if let aDouble = aDouble, let bDouble = bDouble {
        if aDouble > bDouble {
            return a
        } else if bDouble > aDouble {
            return b
        }
    }
    
    return nil
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue(""2,3"")) == .stringValue(""2,3""))
assert(compare_one(a: .stringValue(""5,1""), b: .stringValue(""6"")) == .stringValue(""6""))
assert(compare_one(a: .stringValue(""1""), b: .stringValue(""2"")) == .stringValue(""2""))
assert(compare_one(a: .stringValue(""1""), b: .intValue(1)) == nil)"
HumanEval_138,sin_Sinh,swift,"
// උදාහරණය // ලබා දී ඇති n අංකය හරියටම ධනාත්මක සම සංඛ් යා 4 ක එකතුවක් ලෙස ලිවිය හැකිද යන්න තක්සේරු කරන්න /// >>> is_equal_to_sum_even(n: 4)
/// false
/// >>> is_equal_to_sum_even(n: 6)
/// false
/// >>> is_equal_to_sum_even(n: 8)
/// true
func is_equal_to_sum_even(n: Int) -> Bool {
","func is_equal_to_sum_even(n: Int) -> Bool {
    if n <= 8 {
        return false
    }
    return n % 2 == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_equal_to_sum_even(n: 4) == false)
assert(is_equal_to_sum_even(n: 6) == false)
assert(is_equal_to_sum_even(n: 8) == true)
assert(is_equal_to_sum_even(n: 10) == true)
assert(is_equal_to_sum_even(n: 11) == false)
assert(is_equal_to_sum_even(n: 12) == true)
assert(is_equal_to_sum_even(n: 13) == false)
assert(is_equal_to_sum_even(n: 16) == true)"
HumanEval_139,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// n > 0  කියලා// බ් රසීලියානු_පරිමාණිකය (n) = n! * (n-1)! * (n-2)! * ... * 1! // බ් රසීලියානු සාධකය ලෙස අර්ථ දැක්වෙන්නේ: /// >>> special_factorial(n: 4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
func special_factorial(n: Int) -> Int {
","func factorial(_ n: Int) -> Int {
    return n <= 1 ? 1 : n * factorial(n - 1)
}

func special_factorial(n: Int) -> Int {
    var result = 1
    for i in 1...n {
        result *= factorial(i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(special_factorial(n: 4) == 288)
assert(special_factorial(n: 5) == 34560)
assert(special_factorial(n: 7) == 125411328000)
assert(special_factorial(n: 1) == 1)"
HumanEval_140,sin_Sinh,swift,"
// ඊට පස්සේ හැම අකුරක්ම -  වලින් මාරු කරන්න// ඒ වගේම string එකක space 2කට වඩා තියෙනවා නම්, // පෙළ පේළියක් ලබා දීලා, එහි ඇති සියලුම අවකාශයන් යටින් ලකුණු වලින් ප් රතිස්ථාපනය කරන්න,/// >>> fix_spaces(text: "" Example"")
/// ""Example""
/// >>> fix_spaces(text: "" Example 1"")
/// ""Example_1""
/// >>> fix_spaces(text: "" Example 2"")
/// ""_Example_2""
/// >>> fix_spaces(text: "" Example 3"")
/// ""_Example-3""
func fix_spaces(text: String) -> String {
","func fix_spaces(text: String) -> String {
    var result = """"
    var spaceCount = 0
    
    for character in text {
        if character == "" "" {
            spaceCount += 1
        } else {
            if spaceCount == 1 {
                result.append(""_"")
            } else if spaceCount > 1 {
                result.append(""-"")
            }
            result.append(character)
            spaceCount = 0
        }
    }
    
    if spaceCount == 1 {
        result.append(""_"")
    } else if spaceCount > 1 {
        result.append(""-"")
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: ""Example"") == ""Example"")
assert(fix_spaces(text: ""Mudasir Hanif "") == ""Mudasir_Hanif_"")
assert(fix_spaces(text: ""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"")
assert(fix_spaces(text: ""Exa   mple"") == ""Exa-mple"")
assert(fix_spaces(text: ""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"")"
HumanEval_141,sin_Sinh,swift,"
// උදාහරණ: // - තිතෙන් පස්සේ තියෙන උප අකුරු මේවගෙන් එකක් වෙන්න ඕනේ: ['txt', 'exe', 'dll'] // ලතින් අක්ෂර මාලාව ('a'-'z' සහ 'A'-'Z').// - තිතට කලින් තියෙන උප අකුරු හිස් නොවිය යුතුයි, ඒවගේම ඒක පටන් ගන්නේ  අකුරකින්.// - ෆයිල් එකේ නමේ එක තිතක් තියෙනවා.// - ගොනුවේ නම අංක තුනකට වඩා වැඩි නොවිය යුතුය ('0'-'9'). // සපුරා ඇත: // ගොනුවක නම වලංගු යැයි සලකනු ලබන්නේ පහත සඳහන් කොන්දේසි සියල්ලම සපුරා ඇත්නම් පමණි.// 'ඔව්' නම් ගොනුවේ නම වලංගුයි, නැත්නම් 'නැහැ' නැවත ලබා දෙයි.// ෆයිල් එකක නමක් නියෝජනය කරන string එකක් අරගෙන /// >>> file_name_check(file_name: ""example.txt"")
/// ""Yes""
/// >>> file_name_check(file_name: ""1example.dll"")
/// ""No""
func file_name_check(file_name: String) -> String {
","func file_name_check(file_name: String) -> String {
    // Split by the dot.
    let components = file_name.split(separator: ""."", omittingEmptySubsequences: false)
    
    // Check if there's exactly one dot.
    guard components.count == 2 else {
        return ""No""
    }
    
    // Extract the prefix and suffix.
    let prefix = String(components[0])
    let suffix = String(components[1])
    
    // Check if the prefix is non-empty and starts with a letter.
    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {
        return ""No""
    }
    
    // Check if the suffix is one of the allowed types.
    let validSuffixes = [""txt"", ""exe"", ""dll""]
    guard validSuffixes.contains(suffix) else {
        return ""No""
    }
    
    // Count digits in the file name.
    let digitCount = file_name.filter { $0.isNumber }.count
    
    // Ensure that there are not more than 3 digits.
    guard digitCount <= 3 else {
        return ""No""
    }
    
    // If all checks pass, it's a valid file name.
    return ""Yes""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(file_name_check(file_name: ""example.txt"") == ""Yes"")
assert(file_name_check(file_name: ""1example.dll"") == ""No"")
assert(file_name_check(file_name: ""s1sdf3.asd"") == ""No"")
assert(file_name_check(file_name: ""K.dll"") == ""Yes"")
assert(file_name_check(file_name: ""MY16FILE3.exe"") == ""Yes"")
assert(file_name_check(file_name: ""His12FILE94.exe"") == ""No"")
assert(file_name_check(file_name: ""_Y.txt"") == ""No"")
assert(file_name_check(file_name: ""?aREYA.exe"") == ""No"")
assert(file_name_check(file_name: ""/this_is_valid.dll"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.wow"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.txt"") == ""Yes"")
assert(file_name_check(file_name: ""this_is_valid.txtexe"") == ""No"")
assert(file_name_check(file_name: ""#this2_i4s_5valid.ten"") == ""No"")
assert(file_name_check(file_name: ""@this1_is6_valid.exe"") == ""No"")
assert(file_name_check(file_name: ""this_is_12valid.6exe4.txt"") == ""No"")
assert(file_name_check(file_name: ""all.exe.txt"") == ""No"")
assert(file_name_check(file_name: ""I563_No.exe"") == ""Yes"")
assert(file_name_check(file_name: ""Is3youfault.txt"") == ""Yes"")
assert(file_name_check(file_name: ""no_one#knows.dll"") == ""Yes"")
assert(file_name_check(file_name: ""1I563_Yes3.exe"") == ""No"")
assert(file_name_check(file_name: ""I563_Yes3.txtt"") == ""No"")
assert(file_name_check(file_name: ""final..txt"") == ""No"")
assert(file_name_check(file_name: ""final132"") == ""No"")
assert(file_name_check(file_name: ""_f4indsartal132."") == ""No"")
assert(file_name_check(file_name: "".txt"") == ""No"")
assert(file_name_check(file_name: ""s."") == ""No"")"
HumanEval_143,sin_Sinh,swift,"
// උදාහරණය 1:// අළුත් string එකේ වචන වල අනුපිළිවෙල මුල් එක වගේම වෙන්න ඕනේ.// ප් රථම අංක වල දිග, // එතකොට ඔයා ආපහු දෙන්න ඕනේ මුල් වාක් යයේ වචන අඩංගු නූලක්, // වාක් යයේ ඇතැම් වචන අතර පරතරයක් ඇත, // ඔයාට වාක් යයක් නියෝජනය කරන නූලක් දෙනවා, /// >>> words_in_sentence(sentence: ""This is a test"")
/// ""is""
/// Example 2:
/// >>> words_in_sentence(sentence: ""lets go for swimming"")
/// ""go for""
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
func words_in_sentence(sentence: String) -> String {
","func words_in_sentence(sentence: String) -> String {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    let words = sentence.split(separator: "" "")
    let primeLengthWords = words.filter { isPrime($0.count) }
    return primeLengthWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_in_sentence(sentence: ""This is a test"") == ""is"")
assert(words_in_sentence(sentence: ""lets go for swimming"") == ""go for"")
assert(words_in_sentence(sentence: ""there is no place available here"") == ""there is no place"")
assert(words_in_sentence(sentence: ""Hi I am Hussein"") == ""Hi am Hussein"")
assert(words_in_sentence(sentence: ""go for it"") == ""go for it"")
assert(words_in_sentence(sentence: ""here"") == """")
assert(words_in_sentence(sentence: ""here is"") == ""is"")"
HumanEval_144,sin_Sinh,swift,"
// ඔබට උපකල්පනය කරන්න පුළුවන් x, සහ n වලංගු අංශු කියලා, සහ ශේෂකය ලෙස ශුන් ය නැහැ කියලා. //<සංකේතය>/<නාමකය> මෙහිදී අංකකය සහ නාමකය ධනාත්මක සම්පූර්ණ සංඛ් යා වේ.x සහ n යන දෙකම, අංශුවක නියෝජනය වන අතර, පහත දැක්වෙන ආකෘතිය ඇත,// x * n. x * n සම්පූර්ණ සංඛ් යාවක් ලෙස ගණනය කර false  ලෙස ගණනය කර ඇත්නම්, ක් රියාකාරකය true ලෙස ලබා දෙයි.// ඔබේ කාර්යය තමයි ක් රියාත්මක කිරීම ක් රියාවලිය ඒක සරල කරයි /// >>> simplify(x: ""1/5"", n: ""5/1"")
/// true
/// >>> simplify(x: ""1/6"", n: ""2/1"")
/// false
/// >>> simplify(x: ""7/10"", n: ""10/2"")
/// false
func simplify(x: String, n: String) -> Bool {
","func simplify(x: String, n: String) -> Bool {
    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {
        let parts = fraction.split(separator: ""/"").map { Int($0)! }
        return (numerator: parts[0], denominator: parts[1])
    }
    
    let (xNumerator, xDenominator) = parseFraction(fraction: x)
    let (nNumerator, nDenominator) = parseFraction(fraction: n)
    
    // Multiply the two fractions: (xNumerator * nNumerator) / (xDenominator * nDenominator)
    let resultNumerator = xNumerator * nNumerator
    let resultDenominator = xDenominator * nDenominator
    
    // Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator
    return resultNumerator % resultDenominator == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/6"", n: ""2/1"") == false)
assert(simplify(x: ""5/1"", n: ""3/1"") == true)
assert(simplify(x: ""7/10"", n: ""10/2"") == false)
assert(simplify(x: ""2/10"", n: ""50/10"") == true)
assert(simplify(x: ""7/2"", n: ""4/2"") == true)
assert(simplify(x: ""11/6"", n: ""6/1"") == true)
assert(simplify(x: ""2/3"", n: ""5/2"") == false)
assert(simplify(x: ""5/2"", n: ""3/5"") == false)
assert(simplify(x: ""2/4"", n: ""8/4"") == true)
assert(simplify(x: ""2/4"", n: ""4/2"") == true)
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/5"", n: ""1/5"") == false)"
HumanEval_145,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// මුල් අරා වල ඇති දර්ශකය අනුව ඒවා පිළිවෙලට තබන්න.// සටහන: අංක එකතුව සමාන වන අයිතම කිහිපයක් තිබේ නම්, // අංකවල එකතුව අනුව ඉහළ යන පිළිවෙලට.// දී ඇති සම්පූර්ණ සංඛ් යා අරාව වර්ග කරන ශ් රිතයක් ලියන්න /// >>> order_by_points(nums: [1, 11, -1, -11, -12])
/// [-1, -11, 1, -12, 11]
/// >>> order_by_points(nums: [] as [Int])
/// [] as [Int]
func order_by_points(nums: [Int]) -> [Int] {
","func order_by_points(nums: [Int]) -> [Int] {
    return nums.enumerated().sorted {
        let sum1 = digitSum($0.element)
        let sum2 = digitSum($1.element)
        if sum1 == sum2 {
            return $0.offset < $1.offset
        } else {
            return sum1 < sum2
        }
    }.map { $0.element }
}

func digitSum(_ number: Int) -> Int {
    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])
assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])
assert(order_by_points(nums: [] as [Int]) == [] as [Int])
assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])
assert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])
assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
HumanEval_146,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// අංකයක පළමු හා අවසාන ඉලක්කම් අමුතුයි (1, 3, 5, 7, 9).// අරාවෙ ඇති 10 ට වඩා වැඩි අංග ගණන සහ දෙකම // සංඛ් යා අරාව ආදානය ලෙස ගෙන නැවත ලබා දෙන ශ් රිතයක් ලියන්න /// >>> specialFilter(nums: [15, -73, 14, -15])
/// 1
/// >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])
/// 2
func specialFilter(nums: [Int]) -> Int {
","func specialFilter(nums: [Int]) -> Int {
    return nums.filter { num in
        let absNum = abs(num)
        
        guard absNum > 10 else {
            return false
        }
        
        let firstDigit = String(String(absNum).first!)
        let lastDigit = String(absNum % 10)
        
        let oddDigits: Set = [""1"", ""3"", ""5"", ""7"", ""9""]
        
        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(specialFilter(nums: [5, -2, 1, -5]) == 0)
assert(specialFilter(nums: [15, -73, 14, -15]) == 1)
assert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)
assert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)
assert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)
assert(specialFilter(nums: [1]) == 0)
assert(specialFilter(nums: [] as [Int]) == 0)"
HumanEval_147,sin_Sinh,swift,"
// උදාහරණය: // ඒ වගේම a[i] + a[j] + a[k] කියන්නෙ 3 ක ගුණයක්.// a හි ත් රිත්ව සංඛ් යාව (a[i], a[j], a[k]) නැවත ලබා දෙන්න i < j < k, // සෑම i (1 ≤ i ≤ n) සඳහාම, a[i] හි අගය = i * i - i + 1 වේ. // ඔබට ධනාත්මක පූර්ණ සංඛ් යාවක් n ලබා දී ඇත. ඔබට දිග n ක පූර්ණ සංඛ් යා අරාවක් නිර්මාණය කිරීමට සිදුවේ. /// >>> get_max_triples(n: 5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
func get_max_triples(n: Int) -> Int {
","func get_max_triples(n: Int) -> Int {
    // Create the array a based on the problem description
    var a = [Int](repeating: 0, count: n)
    for i in 1...n {
        a[i - 1] = i * i - i + 1
    }
    
    var count = 0
    // Check for all possible triples
    for i in 0..<n {
        for j in (i + 1)..<n {
            for k in (j + 1)..<n {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count += 1
                }
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_max_triples(n: 5) == 1)
assert(get_max_triples(n: 6) == 4)
assert(get_max_triples(n: 10) == 36)
assert(get_max_triples(n: 100) == 53361)"
HumanEval_149,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// ඔයා හිතන්න ඕන හැම වචනයක්ම එකම දිගයි කියලා.// ෆන්ක්ෂන් එක විසින් ඛණ්ඩගත කර ඇති නූල් මාලාවක් ලබා දිය යුතුයි.// වචන දෙකක දිග සමාන නම්, අක්ෂර වින් යාසය අනුව අරා වර්ග කරන්න.// අරාව ඒ නීතිය අනුව වර්ග කල යුතුයි.// අරාවෙ අනුපිළිවෙල හැම වචනයකම දිග අනුව ඉහළට යන්න ඕන, එතකොට ඔයා // ඒ වගේම ඒකෙ පිටපත් තියෙන්න පුළුවන්.// අරාව හැමවිටම string එකක අරාවක් මිසක සංඛ් යා වල අරාවක් නොවේ, // සහ ඵලදායි අරාව නැවත ලබා දෙයි, // අමුතු දිගකින් යුත් නූල් මකා දමයි, // අක්ෂර මාලාවක් පරාමිතියක් ලෙස පිළිගන්නා ශ් රිතයක් ලියන්න, /// >>> sorted_list_sum(lst: [""aa"", ""a"", ""aaa""])
/// [""aa""]
/// >>> sorted_list_sum(lst: [""ab"", ""a"", ""aaa"", ""cd""])
/// [""ab"", ""cd""]
func sorted_list_sum(lst: [String]) -> [String] {
","func sorted_list_sum(lst: [String]) -> [String] {
    return lst.filter { $0.count % 2 == 0 }
              .sorted { 
                  if $0.count == $1.count {
                      return $0 < $1
                  }
                  return $0.count < $1.count
              }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sorted_list_sum(lst: [""aa"", ""a"", ""aaa""]) == [""aa""])
assert(sorted_list_sum(lst: [""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""])
assert(sorted_list_sum(lst: [""d"", ""b"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""])
assert(sorted_list_sum(lst: [""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""])
assert(sorted_list_sum(lst: [""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""aaaa"", ""bbbb"", ""dd"", ""cc""]) == [""cc"", ""dd"", ""aaaa"", ""bbbb""])"
HumanEval_150,sin_Sinh,swift,"
// උදාහරණ: // ප් රයිම් අංකයක් වන අතර y හි අගය නැවත ලබා දිය යුතුය.// n නම් x වල අගය නැවත ලබාදිය යුතු සරල වැඩසටහනක් /// >>> x_or_y(n: 7, x: 34, y: 12)
/// 34
/// >>> x_or_y(n: 15, x: 8, y: 5)
/// 5
func x_or_y(n: Int, x: Int, y: Int) -> Int {
","func x_or_y(n: Int, x: Int, y: Int) -> Int {
    func isPrime(_ number: Int) -> Bool {
        if number <= 1 { return false }
        if number <= 3 { return true }
        if number % 2 == 0 || number % 3 == 0 { return false }
        
        var i = 5
        while i * i <= number {
            if number % i == 0 || number % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    return isPrime(n) ? x : y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(x_or_y(n: 7, x: 34, y: 12) == 34)
assert(x_or_y(n: 15, x: 8, y: 5) == 5)
assert(x_or_y(n: 3, x: 33, y: 5212) == 33)
assert(x_or_y(n: 1259, x: 3, y: 52) == 3)
assert(x_or_y(n: 7919, x: -1, y: 12) == -1)
assert(x_or_y(n: 3609, x: 1245, y: 583) == 583)
assert(x_or_y(n: 91, x: 56, y: 129) == 129)
assert(x_or_y(n: 6, x: 34, y: 1234) == 1234)
assert(x_or_y(n: 1, x: 2, y: 0) == 0)
assert(x_or_y(n: 2, x: 2, y: 0) == 2)"
HumanEval_151,sin_Sinh,swift,"
// අමුතු අංක තියෙන අරාවෙ. ණ අංක තියෙන අංක හෝ සම්පූර්ණ අංක නැති අංක නොසලකා හරින්න.// සංඛ් යා අරාව ලබා දීලා, සංඛ් යා වල වර්ගවල එකතුව ලබා දෙන්න./// >>> double_the_difference(lst: [1, 3, 2, 0])
/// 10
/// >>> double_the_difference(lst: [-1, -2, 0])
/// 0
/// >>> double_the_difference(lst: [9, -2])
/// 81
/// >>> double_the_difference(lst: [0])
/// 0
/// If the input array is empty, return 0.
func double_the_difference(lst: [Double]) -> Int {
","func double_the_difference(lst: [Double]) -> Int {
    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }
              .map { Int($0) * Int($0) }
              .reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(double_the_difference(lst: [] as [Double]) == 0)
assert(double_the_difference(lst: [5.0, 4.0]) == 25)
assert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)
assert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)
assert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)
assert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)
assert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"
HumanEval_152,sin_Sinh,swift,"
// උදාහරණය: // අගය 0 නම්, අගය නොතිබුනොත්, අගය කියන්නෙ අනුමානය සහ ලකුණු අතර පරතරය.//එකම දිගකින් යුත් අරාවක් නැවත ලබා දෙන්න.එය සෑම අනුමානයකින්ම කොපමණ දුරක් ඈත් වී ඇත්ද යන්න පෙන්නුම් කරයි.// ඔබට සමාන දිගින් යුත් ලකුණු සහ අනුමාන කිරීම් මාලා දෙකක් ලබා දී ඇත, එහිදී සෑම දර්ශකයක්ම ගැලපීමක් පෙන්වයි. // ඔයාගේ කාර්යය තමයි පුද්ගලයෙක් නිවැරදිව අනුමාන කළාද කියලා තීරණය කිරීම තරඟ ගණනාවක් වල ප් රතිඵල.// අනිවාර්යෙන්ම සටහන් කරලා සංසන්දනය කරන්න වටිනවා. අවසානයේදී සිදුවීම ගැන දැනගැනීමට හැකි වෙනවා.// මම හිතන්නේ අපි හැමෝටම මතකයි ඒ හැඟීම ∙∙∙කාලයක් තිස්සේ බලා සිටි ∙∙∙/// >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])
/// [0, 0, 0, 0, 3, 3]
/// >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])
/// [4, 4, 1, 0, 0, 6]
func compare(game: [Int], guess: [Int]) -> [Int] {
","func compare(game: [Int], guess: [Int]) -> [Int] {
    var result: [Int] = []
    
    for i in 0..<game.count {
        let difference = abs(game[i] - guess[i])
        result.append(difference)
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])
assert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])
assert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])
assert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"
HumanEval_153,sin_Sinh,swift,"
// උදාහරණය: // (එහි ශක්තිය -1 යි).// 'Slices.SERVINGSliCes' නැවත ලබාදෙන්නේ 'SERVINGSliCes' යනු වඩාත් ශක්තිමත්ම දිගුව නිසාය // දිගු: ['SERVINGSliCes', 'Cheese', 'StuFfed'] එවිට ඔබ කළ යුතු උදාහරණයක් විදියට, ඔයාට Slices කියන එක ලැබෙනවා නම්, ඒක class එකක් සහ array එකක් විදියට,// අරාවෙ මුලින්ම එන එක තෝරන්න.// එකම ශක්තියෙන් යුත් දිගු දෙකක් හෝ වැඩි ගණනක් තිබේ නම්, ඔබ // ආකෘතිය: ClassName.StrongestExtensionName. // ඔයා හොයාගන්න ඕනේ ශක්තිමත්ම දිගුව සහ මේකේ string එකක් // මෙම ව් යාප්තියේ නමෙහි, ශක්තිය ලබා දී ඇත්තේ CAP - SM අංශකය මගිනි.// අකුරු නම දීර්ඝ, සහ SM කුඩා අකුරු සංඛ්යාව විය යුතුයි // මෙම දිගුවෙහි ශක්තිය පහත පරිදි වේ: CAP යනු විශාල අකුරු වල අංකය වේවා // මෙම දිගු කිරීම් භාවිතා කරන්නේ අතිරේක පන්ති පටවා ගැනීමටයි.// ඔබට class එකක නම (string එකක්) සහ දිගු කිරීම් එකතුවක් ලබා දෙනු ඇත./// >>> Strongest_Extension(class_name: ""my_class"", extensions: [""AA"", ""Be"", ""CC""])
/// ""my_class.AA""
func Strongest_Extension(class_name: String, extensions: [String]) -> String {
","func Strongest_Extension(class_name: String, extensions: [String]) -> String {
    var strongestExtension: String? = nil
    var maxStrength = Int.min
    
    for ext in extensions {
        let cap = ext.filter { $0.isUppercase }.count
        let sm = ext.filter { $0.isLowercase }.count
        let strength = cap - sm
        
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = ext
        }
    }
    
    if let strongestExt = strongestExtension {
        return ""\(class_name).\(strongestExt)""
    }
    
    return class_name
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(Strongest_Extension(class_name: ""Watashi"", extensions: [""tEN"", ""niNE"", ""eIGHt8OKe""]) == ""Watashi.eIGHt8OKe"")
assert(Strongest_Extension(class_name: ""Boku123"", extensions: [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]) == ""Boku123.YEs.WeCaNe"")
assert(Strongest_Extension(class_name: ""__YESIMHERE"", extensions: [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]) == ""__YESIMHERE.NuLl__"")
assert(Strongest_Extension(class_name: ""K"", extensions: [""Ta"", ""TAR"", ""t234An"", ""cosSo""]) == ""K.TAR"")
assert(Strongest_Extension(class_name: ""__HAHA"", extensions: [""Tab"", ""123"", ""781345"", ""-_-""]) == ""__HAHA.123"")
assert(Strongest_Extension(class_name: ""YameRore"", extensions: [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]) == ""YameRore.okIWILL123"")
assert(Strongest_Extension(class_name: ""finNNalLLly"", extensions: [""Die"", ""NowW"", ""Wow"", ""WoW""]) == ""finNNalLLly.WoW"")
assert(Strongest_Extension(class_name: ""_"", extensions: [""Bb"", ""91245""]) == ""_.Bb"")
assert(Strongest_Extension(class_name: ""Sp"", extensions: [""671235"", ""Bb""]) == ""Sp.671235"")"
HumanEval_154,sin_Sinh,swift,"
// ඔයාට වචන දෙකක් දෙනවා. ඔයාට true ආපහු දෙන්න වෙනවා දෙවෙනි වචනය හරි ඒකේ ඕනම එකක් හරි පළමු වචනයේ උප අකුරක් නම්./// >>> cycpattern_check(a: ""abcd"", b: ""abd"")
/// false
/// >>> cycpattern_check(a: ""hello"", b: ""ell"")
/// true
/// >>> cycpattern_check(a: ""whassup"", b: ""psus"")
/// false
/// >>> cycpattern_check(a: ""abab"", b: ""baa"")
/// true
/// >>> cycpattern_check(a: ""efef"", b: ""eeff"")
/// false
/// >>> cycpattern_check(a: ""himenss"", b: ""simen"")
/// true
func cycpattern_check(a: String, b: String) -> Bool {
","func cycpattern_check(a: String, b: String) -> Bool {
    guard !b.isEmpty else { return true }
    let bCombined = b + b
    for i in 0..<b.count {
        let rotation = String(bCombined.dropFirst(i).prefix(b.count))
        if a.contains(rotation) {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(cycpattern_check(a: ""xyzw"", b: ""xyw"") == false)
assert(cycpattern_check(a: ""yello"", b: ""ell"") == true)
assert(cycpattern_check(a: ""whattup"", b: ""ptut"") == false)
assert(cycpattern_check(a: ""efef"", b: ""fee"") == true)
assert(cycpattern_check(a: ""abab"", b: ""aabb"") == false)
assert(cycpattern_check(a: ""winemtt"", b: ""tinem"") == true)"
HumanEval_155,sin_Sinh,swift,"
// උදාහරණය: // පූර්ණ සංඛ් යාවක් ලබා දී ඇත. පිළිවෙලින් සම සහ අංක සහිත සංඛ් යාවක් ඇති ටියුපල් එකක් නැවත ලබා දෙන්න. /// >>> even_odd_count(num: -12)
/// (1, 1)
/// >>> even_odd_count(num: 123)
/// (1, 2)
func even_odd_count(num: Int) -> (Int, Int) {
","func even_odd_count(num: Int) -> (Int, Int) {
    var countEvens = 0
    var countOdds = 0
    var number = abs(num) // Handle negative numbers by taking absolute value

    while number > 0 {
        let digit = number % 10
        if digit % 2 == 0 {
            countEvens += 1
        } else {
            countOdds += 1
        }
        number /= 10
    }
    return (countEvens, countOdds)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_count(num: 7) == (0, 1))
assert(even_odd_count(num: -78) == (1, 1))
assert(even_odd_count(num: 3452) == (2, 2))
assert(even_odd_count(num: 346211) == (3, 3))
assert(even_odd_count(num: -345821) == (3, 3))
assert(even_odd_count(num: -2) == (1, 0))
assert(even_odd_count(num: -45347) == (2, 3))
assert(even_odd_count(num: 0) == (1, 0))"
HumanEval_156,sin_Sinh,swift,"
// උදාහරණ: // සීමා කිරීම්: 1 <= අංකය <= 1000 // ඊට පස්සේ ඒක පොඩි අකුරෙන් දෙන්න.// ධනාත්මක පූර්ණ සංඛ් යාවක් ලබා දීලා, එහි රෝමානු සංඛ් යා සමාන අංකය ලබා ගන්න, /// >>> int_to_mini_roman(number: 19)
/// ""xix""
/// >>> int_to_mini_roman(number: 152)
/// ""clii""
/// >>> int_to_mini_roman(number: 426)
/// ""cdxxvi""
func int_to_mini_roman(number: Int) -> String {
","func int_to_mini_roman(number: Int) -> String {
    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    let numerals = [""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""]
    
    var num = number
    var result = """"
    
    for (index, value) in values.enumerated() {
        while num >= value {
            result += numerals[index]
            num -= value
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(int_to_mini_roman(number: 19) == ""xix"")
assert(int_to_mini_roman(number: 152) == ""clii"")
assert(int_to_mini_roman(number: 251) == ""ccli"")
assert(int_to_mini_roman(number: 426) == ""cdxxvi"")
assert(int_to_mini_roman(number: 500) == ""d"")
assert(int_to_mini_roman(number: 1) == ""i"")
assert(int_to_mini_roman(number: 4) == ""iv"")
assert(int_to_mini_roman(number: 43) == ""xliii"")
assert(int_to_mini_roman(number: 90) == ""xc"")
assert(int_to_mini_roman(number: 94) == ""xciv"")
assert(int_to_mini_roman(number: 532) == ""dxxxii"")
assert(int_to_mini_roman(number: 900) == ""cm"")
assert(int_to_mini_roman(number: 994) == ""cmxciv"")
assert(int_to_mini_roman(number: 1000) == ""m"")"
HumanEval_157,sin_Sinh,swift,"
// උදාහරණය: අංශක 90 යි.// හරි කෝණ ත් රිකෝණයක් කියන්නේ එක කෝණයක් හරි කෝණයක් තියෙන ත් රිකෝණයක්//පැහැදිලි කෝණ ත් රිකෝණයක් හැඩගස්වනවා, එහෙම නැත්නම් ඒක වැරදියි.ත් රිකෝණයක පැති තුනක දිග ලබා දීලා, ත් රිකෝණයේ ත් රිකෝණ තුන ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ ත් රිකෝණයේ/// >>> right_angle_triangle(a: 3, b: 4, c: 5)
/// true
/// >>> right_angle_triangle(a: 1, b: 2, c: 3)
/// false
func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
","func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
    let sides = [a, b, c].sorted()
    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(right_angle_triangle(a: 3, b: 4, c: 5) == true)
assert(right_angle_triangle(a: 1, b: 2, c: 3) == false)
assert(right_angle_triangle(a: 10, b: 6, c: 8) == true)
assert(right_angle_triangle(a: 2, b: 2, c: 2) == false)
assert(right_angle_triangle(a: 7, b: 24, c: 25) == true)
assert(right_angle_triangle(a: 10, b: 5, c: 7) == false)
assert(right_angle_triangle(a: 5, b: 12, c: 13) == true)
assert(right_angle_triangle(a: 15, b: 8, c: 17) == true)
assert(right_angle_triangle(a: 48, b: 55, c: 73) == true)
assert(right_angle_triangle(a: 1, b: 1, c: 1) == false)
assert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"
HumanEval_158,sin_Sinh,swift,"
// අක්ෂර, වදන් මාලාවේ පළමු අකුර නැවත ලබා දෙන්න.// අද්විතීය අක්ෂර ගණනක්.// අරාවෙ විවිධ වචන තියෙනවා. උපරිම අංකය සහිත වචනය නැවත ලබා දෙන්න.// අක්ෂර මාලාවක් පිළිගන්නා ශ් රිතයක් ලියන්න./// >>> find_max(words: [""name"", ""of"", ""string""])
/// ""string""
/// >>> find_max(words: [""name"", ""enam"", ""game""])
/// ""enam""
/// >>> find_max(words: [""aaaaaaa"", ""bb"", ""cc""])
/// ""aaaaaaa""
func find_max(words: [String]) -> String {
","func find_max(words: [String]) -> String {
    func uniqueCharacterCount(in word: String) -> Int {
        return Set(word).count
    }
    
    return words.max { a, b in
        let uniqueCountA = uniqueCharacterCount(in: a)
        let uniqueCountB = uniqueCharacterCount(in: b)
        
        if uniqueCountA == uniqueCountB {
            return a > b
        }
        
        return uniqueCountA < uniqueCountB
    } ?? """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_max(words: [""name"", ""of"", ""string""]) == ""string"")
assert(find_max(words: [""name"", ""enam"", ""game""]) == ""enam"")
assert(find_max(words: [""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa"")
assert(find_max(words: [""abc"", ""cba""]) == ""abc"")
assert(find_max(words: [""play"", ""this"", ""game"", ""of"", ""footbott""]) == ""footbott"")
assert(find_max(words: [""we"", ""are"", ""gonna"", ""rock""]) == ""gonna"")
assert(find_max(words: [""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation"")
assert(find_max(words: [""this"", ""is"", ""a"", ""prrk""]) == ""this"")
assert(find_max(words: [""b""]) == ""b"")
assert(find_max(words: [""play"", ""play"", ""play""]) == ""play"")"
HumanEval_159,sin_Sinh,swift,"
// උදාහරණය: // ඉතිරි කරගත් කැරට් ප් රමාණවත් නැතිනම්, ඔබ ඉතිරි කරගත් කැරට් සියල්ලම කනවා, නමුත් තවමත් බඩගිනි ඇතිවෙනවා.// ඔයාගේ කෑමෙන් පස්සේ ඉතුරු වෙන කැරට් ගාන ] // ඔයා ආපහු යන්න ඕන [ආහාරයෙන් පසු කාපු කැරට් ප් රමාණය, // ඒත් දැන් ඔයාට දවසෙ කෑම ඉවර කරන්න තව කැරට් කන්න වෙනවා.// ඔයා බඩගිනි හාවෙක්, ඔයා දැනටමත් කැරට් ටිකක් කාලා ඉවරයි, /// >>> eat(number: 5, need: 6, remaining: 10)
/// [11, 4]
/// >>> eat(number: 4, need: 8, remaining: 9)
/// [12, 1]
/// >>> eat(number: 1, need: 10, remaining: 10)
/// [11, 0]
/// >>> eat(number: 2, need: 11, remaining: 5)
/// [7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
func eat(number: Int, need: Int, remaining: Int) -> [Int] {
","func eat(number: Int, need: Int, remaining: Int) -> [Int] {
    let totalNeeded = number + need
    let totalEaten = min(totalNeeded, number + remaining)
    let carrotsLeft = max(0, remaining - (totalEaten - number))
    return [totalEaten, carrotsLeft]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])
assert(eat(number: 4, need: 8, remaining: 9) == [12, 1])
assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])
assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])
assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])
assert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
HumanEval_160,sin_Sinh,swift,"
// ඔපරේටර් අරාවෙ අඩුම තරමේ ඔපරේටර් එකක් තියෙනවා, ඔපරේන්ඩ් අරාවෙ අඩුම තරමේ ඔපරේන්ඩ් දෙකක් තියෙනවා.// ඔපරේන්ඩ් යනු ණ නොවන පූර්ණ සංඛ් යා සමූහයකි. // ඔපරේටර් අරාවෙහි දිග ඔපරේන්ඩ් අරාවෙහි දිගට සමානයි.// සටහන: // => ප් රතිඵලය = 9 // ප් රතිඵලය = 2 + 3 * 4 - 5 // අරාව = [2, 3, 4, 5] // ක් රියාකරු ['+', '*', '-'] // උදාහරණය: // තක්සේරු කිරීම (**) බිම් කොටස් (// ගුණ කිරීම (*) // අඩු කිරීම ( - ) // එකතු කිරීම (+) // මූලික ඇල්ජිබ් රා මෙහෙයුම්: // expression එක සහ මේ expression එකේ evaluation එක ලබා දෙන්න.දෙවෙනි අරාව සම්පූර්ණ සංඛ් යා අරාවක්. අරාවන් දෙකෙන් ඇල්ජිබ් රිකය හදන්න.// අරාවන් දෙකක ක් රියාකරු සහ ඔපරේන්ඩ් ලබා දී ඇත. පළමු අරාවෙහි මූලික ඇල්ජිබ් රා ක් රියාකාරකම් ඇත, සහ func do_algebra(operator: [String], operand: [Int]) -> Int {
","func do_algebra(operator: [String], operand: [Int]) -> Int {
    var result = operand[0]
    let precedence: [String: Int] = [""+"": 1, ""-"": 1, ""*"": 2, ""//"": 2, ""**"": 3]
    
    var opStack: [String] = []
    var numStack: [Int] = [result]
    
    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {
        switch op {
        case ""+"":
            return a + b
        case ""-"":
            return a - b
        case ""*"":
            return a * b
        case ""//"":
            return a / b
        case ""**"":
            return Int(pow(Double(a), Double(b)))
        default:
            fatalError(""Unsupported operator: \(op)"")
        }
    }
    
    for i in 0..<operator.count {
        let currentOp = `operator`[i]
        let currentNum = operand[i + 1]
        
        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {
            opStack.removeLast()
            let b = numStack.removeLast()
            let a = numStack.removeLast()
            numStack.append(applyOperator(lastOp, b, a))
        }
        
        opStack.append(currentOp)
        numStack.append(currentNum)
    }
    
    while let lastOp = opStack.popLast() {
        let b = numStack.removeLast()
        let a = numStack.removeLast()
        numStack.append(applyOperator(lastOp, b, a))
    }
    
    return numStack.first!
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(do_algebra(operator: [""**"", ""*"", ""+""], operand: [2, 3, 4, 5]) == 37)
assert(do_algebra(operator: [""+"", ""*"", ""-""], operand: [2, 3, 4, 5]) == 9)
assert(do_algebra(operator: [""//"", ""*""], operand: [7, 3, 4]) == 8)"
HumanEval_161,sin_Sinh,swift,"
// උදාහරණ // ෆන්ක්ෂන් එක ප් රතිඵලයේ තියෙන string එක ආපහු එවන්න ඕනේ.// අකුරු නැති string එක, string එක අනිත් පැත්තට හරවනවා.// එහෙම නැත්නම් ඒක මේ විදිහටම තියන්න. // s[i] අකුරක් නම්, එහි කේස් එක පහළ සිට ඉහළට හෝ අනෙක් අතට හරවන්න, // ඔයාට string එකක් ලැබෙනවා./// >>> solve(s: ""1234"")
/// ""4321""
/// >>> solve(s: ""ab"")
/// ""AB""
/// >>> solve(s: ""#a@C"")
/// ""#A@c""
func solve(s: String) -> String {
","func solve(s: String) -> String {
    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {
        return String(s.reversed())
    }
    
    var result = """"
    for char in s {
        if char.isLetter {
            if char.isLowercase {
                result.append(char.uppercased())
            } else {
                result.append(char.lowercased())
            }
        } else {
            result.append(char)
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: ""AsDf"") == ""aSdF"")
assert(solve(s: ""1234"") == ""4321"")
assert(solve(s: ""ab"") == ""AB"")
assert(solve(s: ""#a@C"") == ""#A@c"")
assert(solve(s: ""#AsdfW^45"") == ""#aSDFw^45"")
assert(solve(s: ""#6@2"") == ""2@6#"")
assert(solve(s: ""#$a^D"") == ""#$A^d"")
assert(solve(s: ""#ccc"") == ""#CCC"")"
HumanEval_162,sin_Sinh,swift,"
// 'text' හිස් නූලක් නම්, නිල් නැවත ලබා දෙන්න. // 'text' කියන string එකක් දුන්නොත්, ඒකෙ md5 hash සමාන string එක ආපහු දෙන්න./// >>> string_to_md5(text: ""Hello world"")
/// ""3e25960a79dbc69b674cd4ec67a72c62""
func string_to_md5(text: String) -> String? {
","import Foundation
import CommonCrypto

func string_to_md5(text: String) -> String? {
    guard !text.isEmpty else { return nil }
    
    let length = Int(CC_MD5_DIGEST_LENGTH)
    let messageData = text.data(using: .utf8)!
    var digestData = Data(count: length)
    
    _ = digestData.withUnsafeMutableBytes { digestBytes in
        messageData.withUnsafeBytes { messageBytes in
            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)
        }
    }
    
    return digestData.map { String(format: ""%02hhx"", $0) }.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_to_md5(text: ""Hello world"") == ""3e25960a79dbc69b674cd4ec67a72c62"")
assert(string_to_md5(text: """") == nil)
assert(string_to_md5(text: ""A B C"") == ""0ef78513b0cb8cef12743f5aeb35f888"")
assert(string_to_md5(text: ""password"") == ""5f4dcc3b5aa765d61d8327deb882cf99"")"
HumanEval_163,sin_Sinh,swift,"
උදාහරණයක් ලෙස:// සහ b, ඉහළ යන පිළිවෙලට. // ධනාත්මක පූර්ණ සංඛ් යා දෙකක් ලබා දී a සහ b, a  අතර ඇති සම අංකය ලබා දෙන්න/// >>> generate_integers(a: 2, b: 8)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 8, b: 2)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 10, b: 14)
/// [] as [Int]
func generate_integers(a: Int, b: Int) -> [Int] {
","func generate_integers(a: Int, b: Int) -> [Int] {
    let lower = min(a, b)
    let upper = max(a, b)
    var result = [Int]()
    
    for number in lower...upper {
        if number % 2 == 0 {
            result.append(number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])
assert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 17, b: 89) == [] as [Int])"
