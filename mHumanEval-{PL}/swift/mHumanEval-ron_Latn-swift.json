[{"task_id":"HumanEval_0","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ dat prag. \/\/ Verificaţi dacă în tabla dată de numere, sunt vreo două numere mai apropiate una de cealaltă decât \/\/\/ >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)\n\/\/\/ true\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n","canonical_solution":"func has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n    let sortedNumbers = numbers.sorted()\n    for i in 0..<sortedNumbers.count - 1 {\n        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"},{"task_id":"HumanEval_1","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Ignoră orice spații în șirul de intrare. \/\/ Grupurile separate sunt echilibrate (fiecare braț deschis este închis în mod corespunzător) și nu sunt cuibărită una în interiorul celeilalte.\/\/ separați aceste grupuri în șiruri separate și returnați matricea acestora. \/\/ Intrarea în această funcție este un șir care conține mai multe grupuri de paranteze încastrate.\/\/\/ >>> separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\")\n\/\/\/ [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string: String) -> [String] {\n","canonical_solution":"func separate_paren_groups(paren_string: String) -> [String] {\n    var results = [String]()\n    var currentGroup = \"\"\n    var balance = 0\n\n    for char in paren_string {\n        \/\/ Ignore spaces\n        if char == \" \" {\n            continue\n        }\n        \n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\n        currentGroup.append(char)\n\n        if balance == 0 && !currentGroup.isEmpty {\n            results.append(currentGroup)\n            currentGroup = \"\"\n        }\n    }\n    \n    return results\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"},{"task_id":"HumanEval_2","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează partea decimală a numărului. \/\/ (parte rămasă întotdeauna mai mică de 1). \/\/ și partea de număr întreg (cel mai mare număr întreg mai mic decât numărul dat) și zecimale \/\/ Având în vedere un număr pozitiv în virgulă plutitoare, poate fi descompus în \/\/\/ >>> truncate_number(number: 3.5)\n\/\/\/ 0.5\nfunc truncate_number(number: Double) -> Double {\n","canonical_solution":"func truncate_number(number: Double) -> Double {\n    return number - Double(Int(number))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"},{"task_id":"HumanEval_3","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ în acel moment funcția ar trebui să returneze true. În caz contrar ar trebui să returneze false. Sarcina ta este să detectezi dacă în orice moment soldul contului scade sub zero, şi \/\/ Ai o serie de operaţiuni de depozit şi retragere pe un cont bancar care începe cu \/\/\/ >>> below_zero(operations: [1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(operations: [1, 2, -4, 5])\n\/\/\/ true\nfunc below_zero(operations: [Int]) -> Bool {\n","canonical_solution":"func below_zero(operations: [Int]) -> Bool {\n    var balance = 0\n    for operation in operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_zero(operations: [] as [Int]) == false)\nassert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)\nassert(below_zero(operations: [1, 2, -4, 5, 6]) == true)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)\nassert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"},{"task_id":"HumanEval_4","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ MAD = medie. x - x_mean. \/\/ element și un punct central (media în acest caz): \/\/ Media abaterii absolute este media diferenței absolute între fiecare \/\/ în jurul valorii de media acestui set de date. \/\/ Pentru o serie dată de numere de intrare, calculați deviația absolută medie \/\/\/ >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n","canonical_solution":"func mean_absolute_deviation(numbers: [Double]) -> Double {\n    guard !numbers.isEmpty else { return 0.0 }\n    \n    let mean = numbers.reduce(0.0, +) \/ Double(numbers.count)\n    let absoluteDifferences = numbers.map { abs($0 - mean) }\n    let mad = absoluteDifferences.reduce(0.0, +) \/ Double(absoluteDifferences.count)\n    \n    return mad\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"},{"task_id":"HumanEval_5","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Introduceți un număr \"delimitator\" între fiecare două elemente consecutive ale matricei de intrare ∀numere\" \/\/\/ >>> intersperse(numbers: [] as [Int], delimeter: 4)\n\/\/\/ [] as [Int]\n\/\/\/ >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\/\/\/ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n","canonical_solution":"func intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    \n    var result: [Int] = []\n    \n    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n    }\n    \n    \/\/ Remove the last added delimiter\n    result.removeLast()\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"},{"task_id":"HumanEval_6","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ De exemplu, (() (()) are cel mult două niveluri de cuibare, în timp ce ((())) are trei. \/\/ Pentru fiecare grup, se înregistrează cel mai adânc nivel de plasare a parantezelor. \/\/ Intrarea în această funcție este un șir reprezentat de mai multe grupuri pentru paranteze cuibate separate prin spații. \/\/\/ >>> parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\")\n\/\/\/ [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n","canonical_solution":"func parse_nested_parens(paren_string: String) -> [Int] {\n    let groups = paren_string.split(separator: \" \")\n    var depths: [Int] = []\n    \n    for group in groups {\n        var maxDepth = 0\n        var currentDepth = 0\n        \n        for char in group {\n            if char == \"(\" {\n                currentDepth += 1\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == \")\" {\n                currentDepth -= 1\n            }\n        }\n        \n        depths.append(maxDepth)\n    }\n    \n    return depths\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])"},{"task_id":"HumanEval_7","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Filtrează o matrice de intrare de stringuri numai pentru cele care conțin un substring dat.\/\/\/ >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n\/\/\/ [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n","canonical_solution":"func filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter { $0.contains(substring) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"},{"task_id":"HumanEval_8","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Suma goală ar trebui să fie egală cu 0 şi produsul gol ar trebui să fie egal cu 1. \/\/ Pentru o serie dată de numere întregi, returnează un tupul format din suma și produsul tuturor numărilor întregi dintr-o serie. \/\/\/ >>> sum_product(numbers: [] as [Int])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(numbers: [1, 2, 3, 4])\n\/\/\/ (10, 24)\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n","canonical_solution":"func sum_product(numbers: [Int]) -> (Int, Int) {\n    let sum = numbers.reduce(0, +)\n    let product = numbers.reduce(1, *)\n    return (sum, product)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_product(numbers: [] as [Int]) == (0, 1))\nassert(sum_product(numbers: [1, 1, 1]) == (3, 1))\nassert(sum_product(numbers: [100, 0]) == (100, 0))\nassert(sum_product(numbers: [3, 5, 7]) == (15, 105))\nassert(sum_product(numbers: [10]) == (10, 10))"},{"task_id":"HumanEval_9","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ în secvenţă. \/\/ Dintr-o serie dată de numere întregi, generaţi o serie de elemente maxime găsite până la momentul dat.\/\/\/ >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])\n\/\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int]) -> [Int] {\n","canonical_solution":"func rolling_max(numbers: [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax: Int? = nil\n    for number in numbers {\n        if let max = currentMax {\n            currentMax = max > number ? max : number\n        } else {\n            currentMax = number\n        }\n        result.append(currentMax!)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"},{"task_id":"HumanEval_10","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ - Adăugați la sfârșitul stringului invers al unui prefix de string care vine înainte de sufixul palindromic. \/\/ - Găsiți cel mai lung postfix al șirului furnizat care este un palindrom. Ideea algoritmului e simplă:\/\/ Găsiți cel mai scurt palindrom care începe cu un șir furnizat. \/\/\/ >>> make_palindrome(string: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> make_palindrome(string: \"cat\")\n\/\/\/ \"catac\"\n\/\/\/ >>> make_palindrome(string: \"cata\")\n\/\/\/ \"catac\"\nfunc make_palindrome(string: String) -> String {\n","canonical_solution":"func make_palindrome(string: String) -> String {\n    func isPalindrome(_ s: String) -> Bool {\n        return s == String(s.reversed())\n    }\n    \n    if string.isEmpty || isPalindrome(string) {\n        return string\n    }\n    \n    for i in stride(from: string.count, through: 0, by: -1) {\n        let suffixIndex = string.index(string.startIndex, offsetBy: i)\n        let suffix = String(string[suffixIndex..<string.endIndex])\n        if isPalindrome(suffix) {\n            let prefix = String(string[string.startIndex..<suffixIndex])\n            return string + String(prefix.reversed())\n        }\n    }\n    \n    return string\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"},{"task_id":"HumanEval_11","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Efectuați XOR binar pe aceste intrări și returnați rezultatul ca un șir. \/\/ Intrarea sunt două șiruri a și b care constau doar din 1 și 0. \/\/\/ >>> string_xor(a: \"010\", b: \"110\")\n\/\/\/ \"100\"\nfunc string_xor(a: String, b: String) -> String {\n","canonical_solution":"func string_xor(a: String, b: String) -> String {\n    let charactersA = Array(a)\n    let charactersB = Array(b)\n    var result = \"\"\n\n    for i in 0..<charactersA.count {\n        let bitA = charactersA[i]\n        let bitB = charactersB[i]\n        \n        if bitA != bitB {\n            result.append(\"1\")\n        } else {\n            result.append(\"0\")\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"},{"task_id":"HumanEval_12","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ stringuri de aceeași lungime. Returnează null în cazul în care matricea de intrare este goală. \/\/ Dintr-o serie de stringuri, returnează cel mai lung.\/\/\/ >>> longest(strings: [] as [String])\n\/\/\/ nil\n\/\/\/ >>> longest(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"a\"\n\/\/\/ >>> longest(strings: [\"a\", \"bb\", \"ccc\"])\n\/\/\/ \"ccc\"\nfunc longest(strings: [String]) -> String? {\n","canonical_solution":"func longest(strings: [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n    for string in strings {\n        if string.count > longestString.count {\n            longestString = string\n        }\n    }\n    return longestString\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"},{"task_id":"HumanEval_13","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează cel mai mare divizor comun al a și b \/\/\/ >>> greatest_common_divisor(a: 3, b: 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(a: 25, b: 15)\n\/\/\/ 5\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n","canonical_solution":"func greatest_common_divisor(a: Int, b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return greatest_common_divisor(a: b, b: a % b)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(greatest_common_divisor(a: 3, b: 7) == 1)\nassert(greatest_common_divisor(a: 10, b: 15) == 5)\nassert(greatest_common_divisor(a: 49, b: 14) == 7)\nassert(greatest_common_divisor(a: 144, b: 60) == 12)"},{"task_id":"HumanEval_14","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează matricea cu toate prefixurile de la cel mai scurt la cel mai lung din stringul de intrare \/\/\/ >>> all_prefixes(string: \"abc\")\n\/\/\/ [\"a\", \"ab\", \"abc\"]\nfunc all_prefixes(string: String) -> [String] {\n","canonical_solution":"func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] = []\n    for i in 1...string.count {\n        let prefix = String(string.prefix(i))\n        prefixes.append(prefix)\n    }\n    return prefixes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"},{"task_id":"HumanEval_15","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează un șir care conține numere delimitate spațial începând de la 0 până la n inclusiv. \/\/\/ >>> string_sequence(n: 0)\n\/\/\/ \"0\"\n\/\/\/ >>> string_sequence(n: 5)\n\/\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n: Int) -> String {\n","canonical_solution":"func string_sequence(n: Int) -> String {\n    return (0...n).map { String($0) }.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_sequence(n: 0) == \"0\")\nassert(string_sequence(n: 3) == \"0 1 2 3\")\nassert(string_sequence(n: 10) == \"0 1 2 3 4 5 6 7 8 9 10\")"},{"task_id":"HumanEval_16","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Având în vedere un șir, află câte caractere distincte (indiferent de caz) este format din \/\/\/ >>> count_distinct_characters(string: \"xyzXYZ\")\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(string: \"Jerry\")\n\/\/\/ 4\nfunc count_distinct_characters(string: String) -> Int {\n","canonical_solution":"func count_distinct_characters(string: String) -> Int {\n    let lowercasedString = string.lowercased()\n    let distinctCharacters = Set(lowercasedString)\n    return distinctCharacters.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_distinct_characters(string: \"\") == 0)\nassert(count_distinct_characters(string: \"abcde\") == 5)\nassert(count_distinct_characters(string: \"abcdecadeCADE\") == 5)\nassert(count_distinct_characters(string: \"aaaaAAAAaaaa\") == 1)\nassert(count_distinct_characters(string: \"Jerry jERRY JeRRRY\") == 5)"},{"task_id":"HumanEval_17","nl":"ron_Latn","pl":"swift","prompt":"\n\"Doctrină\" - nota de patru, durează o bătaie.\"O\" - jumătate de notă, durează două bătăi.\/\/ 'O' - nota întreagă, durează patru batai Iată o legendă:Nu ultima.\/\/ Sarcina ta este de a analiza acest șir și de a returna o serie de numere întregi corespunzătoare numărului de bătăi pe care le face fiecare.\/\/ Intrarea în această funcţie este o coardă care reprezintă note muzicale într-un format special ASCII. \/\/\/ >>> parse_music(music_string: \"o o| .| o| o| .| .| .| .| o o\")\n\/\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string: String) -> [Int] {\n","canonical_solution":"func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.split(separator: \" \")\n    var beats: [Int] = []\n    \n    for note in notes {\n        switch note {\n        case \"o\":\n            beats.append(4)\n        case \"o|\":\n            beats.append(2)\n        case \".|\":\n            beats.append(1)\n        default:\n            continue\n        }\n    }\n    \n    return beats\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"},{"task_id":"HumanEval_18","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Găsește de câte ori un anumit substring poate fi găsit în șirul original.\/\/\/ >>> how_many_times(string: \"\", substring: \"a\")\n\/\/\/ 0\n\/\/\/ >>> how_many_times(string: \"aaa\", substring: \"a\")\n\/\/\/ 3\n\/\/\/ >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n\/\/\/ 3\nfunc how_many_times(string: String, substring: String) -> Int {\n","canonical_solution":"func how_many_times(string: String, substring: String) -> Int {\n    guard !substring.isEmpty else { return 0 }\n    \n    var count = 0\n    var startIndex = string.startIndex\n    \n    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {\n        count += 1\n        startIndex = string.index(after: range.lowerBound)\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"},{"task_id":"HumanEval_19","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează un șir cu numere ordonate de la cel mai mic la cel mai mare .\/\/ Opțiunile valabile sunt \"zero\", \"unu\", \"doi\", \"trei\", \"patru\", \"cinci\", \"șase\", \"șapte\", \"opt\" și \"nouă\". \/\/ Intrarea este un șir de numere delimitate spațial de la \"zero\" la \"nouă\". \/\/\/ >>> sort_numbers(numbers: \"three one five\")\n\/\/\/ \"one three five\"\nfunc sort_numbers(numbers: String) -> String {\n","canonical_solution":"func sort_numbers(numbers: String) -> String {\n    \/\/ Mapping of word numbers to digits\n    let numberWords: [String: Int] = [\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    ]\n\n    \/\/ Split the input string into words\n    let words = numbers.split(separator: \" \")\n\n    \/\/ Sort the words based on their corresponding number values\n    let sortedWords = words.sorted { \n        numberWords[String($0)]! < numberWords[String($1)]! \n    }\n\n    \/\/ Join the sorted words back into a single string\n    return sortedWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_numbers(numbers: \"\") == \"\")\nassert(sort_numbers(numbers: \"three\") == \"three\")\nassert(sort_numbers(numbers: \"three five nine\") == \"three five nine\")\nassert(sort_numbers(numbers: \"five zero four seven nine eight\") == \"zero four five seven eight nine\")\nassert(sort_numbers(numbers: \"six five four three two one zero\") == \"zero one two three four five six\")"},{"task_id":"HumanEval_20","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ alte și le returnează în ordine (număr mai mic, număr mai mare).\/\/ Dintr-o matrice de numere (de lungime de cel puțin două) selectați și returnați cele două care sunt cele mai apropiate de fiecare \/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n","canonical_solution":"func find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    \/\/ Sort the array to bring closest numbers next to each other\n    let sortedNumbers = numbers.sorted()\n    \n    \/\/ Initialize variables to keep track of the smallest difference and the pair\n    var minDifference = Double.greatestFiniteMagnitude\n    var closestPair: (Double, Double) = (0.0, 0.0)\n    \n    \/\/ Iterate over the sorted numbers to find the smallest difference\n    for i in 0..<sortedNumbers.count - 1 {\n        let num1 = sortedNumbers[i]\n        let num2 = sortedNumbers[i + 1]\n        let difference = abs(num1 - num2)\n        \n        if difference < minDifference {\n            minDifference = difference\n            closestPair = (num1, num2)\n        }\n    }\n    \n    return closestPair\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"},{"task_id":"HumanEval_21","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ astfel încât cel mai mic număr va deveni 0 şi cel mai mare va deveni 1 \/\/ Având în vedere matricea de numere (de cel puțin două elemente), aplicați o transformare liniară la acea matriță, \/\/\/ >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n","canonical_solution":"func rescale_to_unit(numbers: [Double]) -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    \n    let minValue = numbers.min()!\n    let maxValue = numbers.max()!\n    let range = maxValue - minValue\n    \n    guard range != 0 else {\n        return numbers.map { _ in 0.0 }\n    }\n    \n    return numbers.map { ($0 - minValue) \/ range }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"},{"task_id":"HumanEval_22","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Filtrează matricea dată a oricăror valori Swiftthon doar pentru numerele întregi.\/\/\/ >>> filter_integers(values: [\"a\", 3.14, 5])\n\/\/\/ [5]\n\/\/\/ >>> filter_integers(values: [1, 2, 3, \"abc\", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])\n\/\/\/ [1, 2, 3]\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n","canonical_solution":"func filter_integers(values: [AnyHashable]) -> [Int] {\n    return values.compactMap { $0 as? Int }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])\nassert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, \"adasd\"]) == [4, 9])\nassert(filter_integers(values: [3, \"c\", 3, 3, \"a\", \"b\"]) == [3, 3, 3])"},{"task_id":"HumanEval_23","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează lungimea stringului dat \/\/\/ >>> strlen(string: \"\")\n\/\/\/ 0\n\/\/\/ >>> strlen(string: \"abc\")\n\/\/\/ 3\nfunc strlen(string: String) -> Int {\n","canonical_solution":"func strlen(string: String) -> Int {\n    return string.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strlen(string: \"\") == 0)\nassert(strlen(string: \"x\") == 1)\nassert(strlen(string: \"asdasnakj\") == 9)"},{"task_id":"HumanEval_24","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Pentru un număr n dat, găsește cel mai mare număr care împartă n în mod egal, mai mic decât n \/\/\/ >>> largest_divisor(n: 15)\n\/\/\/ 5\nfunc largest_divisor(n: Int) -> Int {\n","canonical_solution":"func largest_divisor(n: Int) -> Int {\n    for i in stride(from: n \/ 2, to: 0, by: -1) {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_divisor(n: 3) == 1)\nassert(largest_divisor(n: 7) == 1)\nassert(largest_divisor(n: 10) == 5)\nassert(largest_divisor(n: 100) == 50)\nassert(largest_divisor(n: 49) == 7)"},{"task_id":"HumanEval_25","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Numărul de intrare ar trebui să fie egal cu produsul tuturor factorilor \/\/ Fiecare dintre factori ar trebui să fie aranjate de număr de ori corespunzătoare de câte ori apare în factorizare. \/\/ Returnează o serie de factori primi ai unui număr întreg dat, ordonat de la cel mai mic la cel mai mare. \/\/\/ >>> factorize(n: 8)\n\/\/\/ [2, 2, 2]\n\/\/\/ >>> factorize(n: 25)\n\/\/\/ [5, 5]\n\/\/\/ >>> factorize(n: 70)\n\/\/\/ [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n","canonical_solution":"func factorize(n: Int) -> [Int] {\n    guard n > 1 else { return [] }\n    var number = n\n    var factors: [Int] = []\n    var divisor = 2\n    \n    while number >= divisor {\n        while number % divisor == 0 {\n            factors.append(divisor)\n            number \/= divisor\n        }\n        divisor += 1\n    }\n    \n    return factors\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"},{"task_id":"HumanEval_26","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Păstrați ordinea elementelor stânga la fel ca în intrare. \/\/ Dintr-o matrice de numere întregi, eliminăm toate elementele care apar de mai multe ori. \/\/\/ >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])\n\/\/\/ [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n","canonical_solution":"func remove_duplicates(numbers: [Int]) -> [Int] {\n    var elementCount = [Int: Int]()\n    for number in numbers {\n        elementCount[number, default: 0] += 1\n    }\n    return numbers.filter { elementCount[$0] == 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"},{"task_id":"HumanEval_27","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Pentru un șir dat, întoarceți caractere minuscule în majuscule și majuscule în minuscule. \/\/\/ >>> flip_case(string: \"Hello\")\n\/\/\/ \"hELLO\"\nfunc flip_case(string: String) -> String {\n","canonical_solution":"func flip_case(string: String) -> String {\n    return String(string.map { character in\n        if character.isLowercase {\n            return character.uppercased()\n        } else if character.isUppercase {\n            return character.lowercased()\n        } else {\n            return String(character)\n        }\n    }.joined())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(flip_case(string: \"\") == \"\")\nassert(flip_case(string: \"Hello!\") == \"hELLO!\")\nassert(flip_case(string: \"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")"},{"task_id":"HumanEval_28","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Concatenate array de stringuri într-un singur șir \/\/\/ >>> concatenate(strings: [] as [String])\n\/\/\/ \"\"\n\/\/\/ >>> concatenate(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"abc\"\nfunc concatenate(strings: [String]) -> String {\n","canonical_solution":"func concatenate(strings: [String]) -> String {\n    return strings.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(concatenate(strings: [] as [String]) == \"\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\"]) == \"xyz\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\", \"w\", \"k\"]) == \"xyzwk\")"},{"task_id":"HumanEval_29","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Filtrează o matrice de intrare de stringuri numai pentru cele care încep cu un prefix dat. \/\/\/ >>> filter_by_prefix(strings: [] as [String], prefix: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_prefix(strings: [\"abc\", \"bcd\", \"cde\", \"array\"], prefix: \"a\")\n\/\/\/ [\"abc\", \"array\"]\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n","canonical_solution":"func filter_by_prefix(strings: [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"},{"task_id":"HumanEval_30","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează doar numerele pozitive din matrice. \/\/\/ >>> get_positive(l: [-1, 2, -4, 5, 6])\n\/\/\/ [2, 5, 6]\n\/\/\/ >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunc get_positive(l: [Int]) -> [Int] {\n","canonical_solution":"func get_positive(l: [Int]) -> [Int] {\n    return l.filter { $0 > 0 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])\nassert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\nassert(get_positive(l: [-1, -2]) == [] as [Int])\nassert(get_positive(l: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_31","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează adevărat dacă un număr dat este prim, și fals în caz contrar. \/\/\/ >>> is_prime(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 101)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 11)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 61)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 1)\n\/\/\/ false\nfunc is_prime(n: Int) -> Bool {\n","canonical_solution":"func is_prime(n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false\n    }\n    var i = 5\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_prime(n: 6) == false)\nassert(is_prime(n: 101) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 13441) == true)\nassert(is_prime(n: 61) == true)\nassert(is_prime(n: 4) == false)\nassert(is_prime(n: 1) == false)\nassert(is_prime(n: 5) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 17) == true)\nassert(is_prime(n: 85) == false)\nassert(is_prime(n: 77) == false)\nassert(is_prime(n: 255379) == false)"},{"task_id":"HumanEval_33","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ la valorile indicilor corespunzători ai lui l, dar sortate. \/\/ l' este identic cu l la indicii care nu sunt divizibili la trei, în timp ce valorile sale la indicii care sunt divizibile la trei sunt egale \/\/ Această funcție ia un tablou l și returnează un tablou l' astfel încât \/\/\/ >>> sort_third(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])\n\/\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunc sort_third(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_third(l: [Int]) -> [Int] {\n    \/\/ Collect indices and their values where index is divisible by 3\n    var divisibleByThreeValues: [(index: Int, value: Int)] = []\n    for (index, value) in l.enumerated() where index % 3 == 0 {\n        divisibleByThreeValues.append((index, value))\n    }\n    \n    \/\/ Sort the values that were at the indices divisible by 3\n    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()\n    \n    \/\/ Create a mutable copy of original array to modify\n    var result = l\n    \n    \/\/ Replace the sorted values back into their original indices\n    for (i, sortedValue) in sortedValues.enumerated() {\n        result[divisibleByThreeValues[i].index] = sortedValue\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])\nassert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])\nassert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])\nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"},{"task_id":"HumanEval_34","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează elementele unică sortate într-un tablou \/\/\/ >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [0, 2, 3, 5, 9, 123]\nfunc unique(l: [Int]) -> [Int] {\n","canonical_solution":"func unique(l: [Int]) -> [Int] {\n    return Array(Set(l)).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"},{"task_id":"HumanEval_35","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează elementul maxim din tablă. \/\/\/ >>> max_element(l: [1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfunc max_element(l: [Int]) -> Int {\n","canonical_solution":"func max_element(l: [Int]) -> Int {\n    guard let max = l.max() else {\n        fatalError(\"Array should not be empty\")\n    }\n    return max\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"},{"task_id":"HumanEval_36","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează numărul de ori cifrele 7 apar în numerele întregi mai mici de n care sunt divizibile cu 11 sau 13. \/\/\/ >>> fizz_buzz(n: 50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(n: 78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(n: 79)\n\/\/\/ 3\nfunc fizz_buzz(n: Int) -> Int {\n","canonical_solution":"func fizz_buzz(n: Int) -> Int {\n    var count = 0\n    for number in 0..<n {\n        if number % 11 == 0 || number % 13 == 0 {\n            var current = number\n            while current > 0 {\n                if current % 10 == 7 {\n                    count += 1\n                }\n                current \/= 10\n            }\n        }\n    }\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fizz_buzz(n: 50) == 0)\nassert(fizz_buzz(n: 78) == 2)\nassert(fizz_buzz(n: 79) == 3)\nassert(fizz_buzz(n: 100) == 3)\nassert(fizz_buzz(n: 200) == 6)\nassert(fizz_buzz(n: 4000) == 192)\nassert(fizz_buzz(n: 10000) == 639)\nassert(fizz_buzz(n: 100000) == 8026)"},{"task_id":"HumanEval_37","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ la valorile indicilor par de l, dar sortate. \/\/ l' este identic cu l la indicii impar, în timp ce valorile sale la indicii pereche sunt egale \/\/ Această funcție ia un tablou l și returnează un tablou l' astfel încât \/\/\/ >>> sort_even(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_even(l: [5, 6, 3, 4])\n\/\/\/ [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_even(l: [Int]) -> [Int] {\n    var evenIndicesValues = [Int]()\n    \n    \/\/ Collect values from even indices\n    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n            evenIndicesValues.append(value)\n        }\n    }\n    \n    \/\/ Sort the collected even indices values\n    evenIndicesValues.sort()\n    \n    var result = l\n    var evenIndex = 0\n    \n    \/\/ Replace even-indexed elements in result with sorted values\n    for i in 0..<result.count {\n        if i % 2 == 0 {\n            result[i] = evenIndicesValues[evenIndex]\n            evenIndex += 1\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"},{"task_id":"HumanEval_39","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ prime_fib returnează numărul n-lea care este un număr Fibonacci și este, de asemenea, prim. \/\/\/ >>> prime_fib(n: 1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(n: 2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(n: 3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(n: 4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(n: 5)\n\/\/\/ 89\nfunc prime_fib(n: Int) -> Int {\n","canonical_solution":"func isPrime(_ num: Int) -> Bool {\n    if num <= 1 { return false }\n    if num <= 3 { return true }\n    if num % 2 == 0 || num % 3 == 0 { return false }\n    var i = 5\n    while i * i <= num {\n        if num % i == 0 || num % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}\n\nfunc generateFibonacci(n: Int) -> [Int] {\n    var fibs = [1, 2]\n    var next = fibs[0] + fibs[1]\n    while fibs.count < n || !isPrime(next) {\n        fibs.append(next)\n        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]\n    }\n    return fibs\n}\n\nfunc prime_fib(n: Int) -> Int {\n    var count = 0\n    var fibs = generateFibonacci(n: n)\n    for fib in fibs {\n        if isPrime(fib) {\n            count += 1\n            if count == n {\n                return fib\n            }\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_fib(n: 1) == 2)\nassert(prime_fib(n: 2) == 3)\nassert(prime_fib(n: 3) == 5)\nassert(prime_fib(n: 4) == 13)\nassert(prime_fib(n: 5) == 89)\nassert(prime_fib(n: 6) == 233)\nassert(prime_fib(n: 7) == 1597)\nassert(prime_fib(n: 8) == 28657)\nassert(prime_fib(n: 9) == 514229)\nassert(prime_fib(n: 10) == 433494437)"},{"task_id":"HumanEval_40","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ suma la zero, și fals altfel. \/\/ se întoarce adevărat dacă există trei elemente distincte în matrice care \/\/ triples_sum_to_zero ia o serie de numere întregi ca intrare. \/\/\/ >>> triples_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1])\n\/\/\/ false\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func triples_sum_to_zero(l: [Int]) -> Bool {\n    let count = l.count\n    if count < 3 {\n        return false\n    }\n    \n    let sortedArray = l.sorted()\n    \n    for i in 0..<count - 2 {\n        var left = i + 1\n        var right = count - 1\n        \n        while left < right {\n            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]\n            if currentSum == 0 {\n                return true\n            } else if currentSum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)\nassert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)\nassert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)\nassert(triples_sum_to_zero(l: [1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)\nassert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"},{"task_id":"HumanEval_41","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Această funcție dă numărul de astfel de coliziuni. \/\/ în traiectoria lor ca și cum nu s-au ciocnit. \/\/ Cu toate acestea, mașinile sunt infinit robuste și puternice; ca urmare, acestea continuă să se miște \/\/ când o mașină care se deplasează din stânga spre dreapta lovește o mașină care se deplasează din dreapta spre stânga. Toate maşinile se mişcă cu aceeaşi viteză.Cele două perechi de maşini au pornit de la foarte departe.\/\/ n maşini se deplasează din stânga spre dreapta; simultan, un set diferit de n maşini \/\/ Imaginaţi-vă un drum care este o linie perfect dreaptă infinit de lungă. func car_race_collision(n: Int) -> Int {\n","canonical_solution":"func car_race_collision(n: Int) -> Int {\n    return n\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(car_race_collision(n: 2) == 4)\nassert(car_race_collision(n: 3) == 9)\nassert(car_race_collision(n: 4) == 16)\nassert(car_race_collision(n: 8) == 64)\nassert(car_race_collision(n: 10) == 100)"},{"task_id":"HumanEval_42","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează matricea cu elemente încrementate cu 1. \/\/\/ >>> incr_list(l: [1, 2, 3])\n\/\/\/ [2, 3, 4]\n\/\/\/ >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n","canonical_solution":"func incr_list(l: [Int]) -> [Int] {\n    return l.map { $0 + 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"},{"task_id":"HumanEval_43","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ suma la zero, și fals altfel. \/\/ se întoarce adevărat dacă există două elemente distincte în matrice care \/\/ pairs_sum_to_zero ia o serie de numere întregi ca intrare. \/\/\/ >>> pairs_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(l: [1])\n\/\/\/ false\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func pairs_sum_to_zero(l: [Int]) -> Bool {\n    var set = Set<Int>()\n    for num in l {\n        if set.contains(-num) {\n            return true\n        }\n        set.insert(num)\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)\nassert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)\nassert(pairs_sum_to_zero(l: [1]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"},{"task_id":"HumanEval_44","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Numerele de bază sunt mai mici de 10. \/\/ returnă reprezentarea string după conversie. \/\/ Schimbă baza numerică a numărului de intrare x la bază. \/\/\/ >>> change_base(x: 8, base: 3)\n\/\/\/ \"22\"\n\/\/\/ >>> change_base(x: 8, base: 2)\n\/\/\/ \"1000\"\n\/\/\/ >>> change_base(x: 7, base: 2)\n\/\/\/ \"111\"\nfunc change_base(x: Int, base: Int) -> String {\n","canonical_solution":"func change_base(x: Int, base: Int) -> String {\n    guard base > 1 && base < 10 else {\n        return \"\"\n    }\n    \n    var number = x\n    var result = \"\"\n    \n    repeat {\n        let remainder = number % base\n        result = \"\\(remainder)\" + result\n        number \/= base\n    } while number > 0\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(change_base(x: 8, base: 3) == \"22\")\nassert(change_base(x: 9, base: 3) == \"100\")\nassert(change_base(x: 234, base: 2) == \"11101010\")\nassert(change_base(x: 16, base: 2) == \"10000\")\nassert(change_base(x: 8, base: 2) == \"1000\")\nassert(change_base(x: 7, base: 2) == \"111\")\nassert(change_base(x: 2, base: 3) == \"2\")\nassert(change_base(x: 3, base: 4) == \"3\")\nassert(change_base(x: 4, base: 5) == \"4\")\nassert(change_base(x: 5, base: 6) == \"5\")\nassert(change_base(x: 6, base: 7) == \"6\")\nassert(change_base(x: 7, base: 8) == \"7\")"},{"task_id":"HumanEval_45","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Având în vedere lungimea unei laturi şi suprafaţa de întoarcere a unui triunghi. \/\/\/ >>> triangle_area(a: 5, h: 3)\n\/\/\/ 7.5\nfunc triangle_area(a: Int, h: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, h: Int) -> Double {\n    return 0.5 * Double(a) * Double(h)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 5, h: 3) == 7.5)\nassert(triangle_area(a: 2, h: 2) == 2.0)\nassert(triangle_area(a: 10, h: 8) == 40.0)"},{"task_id":"HumanEval_46","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Vă rugăm să scrieți o funcție pentru a calcula în mod eficient elementul n-lea al secvenței de numere fib4. Nu utilizați recursiunea. \/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \/\/ fib4(3) -> 0 - Nu, nu, nu.\/\/ fib4(1) -> 0 \/\/ fib4(0) -> 0 \/\/ Secvența numerică Fib4 este o secvență similară cu secvența Fibbonacci care este definită după cum urmează: \/\/\/ >>> fib4(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fib4(n: 6)\n\/\/\/ 8\n\/\/\/ >>> fib4(n: 7)\n\/\/\/ 14\nfunc fib4(n: Int) -> Int {\n","canonical_solution":"func fib4(n: Int) -> Int {\n    if n == 0 || n == 1 || n == 3 {\n        return 0\n    } else if n == 2 {\n        return 2\n    }\n    \n    var fibs = [0, 0, 2, 0]\n    \n    for i in 4...n {\n        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]\n        fibs.append(nextFib)\n    }\n    \n    return fibs[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib4(n: 5) == 4)\nassert(fib4(n: 8) == 28)\nassert(fib4(n: 10) == 104)\nassert(fib4(n: 12) == 386)"},{"task_id":"HumanEval_47","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează mediana elementelor din matricea l. \/\/\/ >>> median(l: [3, 1, 2, 4, 5])\n\/\/\/ 3\n\/\/\/ >>> median(l: [-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfunc median(l: [Int]) -> Double {\n","canonical_solution":"func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    let count = sorted.count\n    if count % 2 == 0 {\n        return Double(sorted[count \/ 2 - 1] + sorted[count \/ 2]) \/ 2.0\n    } else {\n        return Double(sorted[count \/ 2])\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"},{"task_id":"HumanEval_48","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Verifică dacă un șir dat este un palindrom \/\/\/ >>> is_palindrome(text: \"\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aba\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aaaaa\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"zbcd\")\n\/\/\/ false\nfunc is_palindrome(text: String) -> Bool {\n","canonical_solution":"func is_palindrome(text: String) -> Bool {\n    return text == String(text.reversed())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_palindrome(text: \"\") == true)\nassert(is_palindrome(text: \"aba\") == true)\nassert(is_palindrome(text: \"aaaaa\") == true)\nassert(is_palindrome(text: \"zbcd\") == false)\nassert(is_palindrome(text: \"xywyx\") == true)\nassert(is_palindrome(text: \"xywyz\") == false)\nassert(is_palindrome(text: \"xywzx\") == false)"},{"task_id":"HumanEval_49","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează 2 ^ n modul p (conștientizați-vă de cifre). \/\/\/ >>> modp(n: 3, p: 5)\n\/\/\/ 3\n\/\/\/ >>> modp(n: 1101, p: 101)\n\/\/\/ 2\n\/\/\/ >>> modp(n: 0, p: 101)\n\/\/\/ 1\n\/\/\/ >>> modp(n: 3, p: 11)\n\/\/\/ 8\n\/\/\/ >>> modp(n: 100, p: 101)\n\/\/\/ 1\nfunc modp(n: Int, p: Int) -> Int {\n","canonical_solution":"func modp(n: Int, p: Int) -> Int {\n    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"},{"task_id":"HumanEval_51","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ remove_vowels este o funcție care ia string și returnează string fără vocală. \/\/\/ >>> remove_vowels(text: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"abcdef\")\n\/\/\/ \"bcdf\"\n\/\/\/ >>> remove_vowels(text: \"aaaaa\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"aaBAA\")\n\/\/\/ \"B\"\n\/\/\/ >>> remove_vowels(text: \"zbcd\")\n\/\/\/ \"zbcd\"\nfunc remove_vowels(text: String) -> String {\n","canonical_solution":"func remove_vowels(text: String) -> String {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return String(text.filter { !vowels.contains($0) })\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_vowels(text: \"\") == \"\")\nassert(remove_vowels(text: \"abcdef\\nghijklm\") == \"bcdf\\nghjklm\")\nassert(remove_vowels(text: \"fedcba\") == \"fdcb\")\nassert(remove_vowels(text: \"eeeee\") == \"\")\nassert(remove_vowels(text: \"acBAA\") == \"cB\")\nassert(remove_vowels(text: \"EcBOO\") == \"cB\")\nassert(remove_vowels(text: \"ybcd\") == \"ybcd\")"},{"task_id":"HumanEval_52","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează true dacă toate numerele din matricea l sunt sub pragul t. \/\/\/ >>> below_threshold(l: [1, 2, 4, 10], t: 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(l: [1, 20, 4, 10], t: 5)\n\/\/\/ false\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n","canonical_solution":"func below_threshold(l: [Int], t: Int) -> Bool {\n    for number in l {\n        if number >= t {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)\nassert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"},{"task_id":"HumanEval_53","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Adăugați două numere x și y \/\/\/ >>> add(x: 2, y: 3)\n\/\/\/ 5\n\/\/\/ >>> add(x: 5, y: 7)\n\/\/\/ 12\nfunc add(x: Int, y: Int) -> Int {\n","canonical_solution":"func add(x: Int, y: Int) -> Int {\n    return x + y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(x: 0, y: 1) == 1)\nassert(add(x: 1, y: 0) == 1)\nassert(add(x: 2, y: 3) == 5)\nassert(add(x: 5, y: 7) == 12)\nassert(add(x: 7, y: 5) == 12)"},{"task_id":"HumanEval_54","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Verificaţi dacă două cuvinte au aceleaşi caractere. \/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"dddddddabc\", s1: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"eabcd\", s1: \"dddddddabc\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabce\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\")\n\/\/\/ false\nfunc same_chars(s0: String, s1: String) -> Bool {\n","canonical_solution":"func same_chars(s0: String, s1: String) -> Bool {\n    let set0 = Set(s0)\n    let set1 = Set(s1)\n    return set0 == set1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\") == true)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabc\") == true)\nassert(same_chars(s0: \"dddddddabc\", s1: \"abcd\") == true)\nassert(same_chars(s0: \"eabcd\", s1: \"dddddddabc\") == false)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabcf\") == false)\nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\") == false)\nassert(same_chars(s0: \"aabb\", s1: \"aaccc\") == false)"},{"task_id":"HumanEval_55","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează numărul n-lea Fibonacci. \/\/\/ >>> fib(n: 10)\n\/\/\/ 55\n\/\/\/ >>> fib(n: 1)\n\/\/\/ 1\n\/\/\/ >>> fib(n: 8)\n\/\/\/ 21\nfunc fib(n: Int) -> Int {\n","canonical_solution":"func fib(n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    }\n    \n    var a = 0\n    var b = 1\n    for _ in 2...n {\n        let temp = a + b\n        a = b\n        b = temp\n    }\n    return b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib(n: 10) == 55)\nassert(fib(n: 1) == 1)\nassert(fib(n: 8) == 21)\nassert(fib(n: 11) == 89)\nassert(fib(n: 12) == 144)"},{"task_id":"HumanEval_56","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ return true dacă fiecare paranteză de deschidere are o paranteză de închidere corespunzătoare. \/\/ paranteze este un șir de \"<\" și \">\". \/\/\/ >>> correct_bracketing(brackets: \"<\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"<>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"<<><>>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"><<>\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    \n    for bracket in brackets {\n        if bracket == \"<\" {\n            balance += 1\n        } else if bracket == \">\" {\n            balance -= 1\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    \n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)"},{"task_id":"HumanEval_57","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Return true este elementele matricei sunt monotonic crescând sau scăzând. \/\/\/ >>> monotonic(l: [1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(l: [1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(l: [4, 1, 0, -10])\n\/\/\/ true\nfunc monotonic(l: [Int]) -> Bool {\n","canonical_solution":"func monotonic(l: [Int]) -> Bool {\n    guard l.count > 1 else {\n        return true\n    }\n    \n    var increasing = true\n    var decreasing = true\n    \n    for i in 1..<l.count {\n        if l[i] > l[i - 1] {\n            decreasing = false\n        } else if l[i] < l[i - 1] {\n            increasing = false\n        }\n    }\n    \n    return increasing || decreasing\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"},{"task_id":"HumanEval_58","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează elemente comune sortate pentru două matrici. \/\/\/ >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n\/\/\/ [1, 5, 653]\n\/\/\/ >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n\/\/\/ [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n","canonical_solution":"func common(l1: [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let commonElements = set1.intersection(set2)\n    return Array(commonElements).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_59","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează cel mai mare factor prim al lui n. Presupunem că n > 1 și nu este un număr prim. \/\/\/ >>> largest_prime_factor(n: 13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(n: 2048)\n\/\/\/ 2\nfunc largest_prime_factor(n: Int) -> Int {\n","canonical_solution":"func largest_prime_factor(n: Int) -> Int {\n    var number = n\n    var divisor = 2\n    \n    while number > 1 {\n        if number % divisor == 0 {\n            number \/= divisor\n        } else {\n            divisor += 1\n        }\n    }\n    \n    return divisor\n}\n\n\/\/ Example usage:\n\/\/ print(largest_prime_factor(n: 13195)) \/\/ Output: 29\n\/\/ print(largest_prime_factor(n: 2048))  \/\/ Output: 2","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"},{"task_id":"HumanEval_60","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ sum_to_n este o funcţie care adaugă numere de la 1 la n. \/\/\/ >>> sum_to_n(n: 30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(n: 100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(n: 5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(n: 10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(n: 1)\n\/\/\/ 1\nfunc sum_to_n(n: Int) -> Int {\n","canonical_solution":"func sum_to_n(n: Int) -> Int {\n    return (n * (n + 1)) \/ 2\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_to_n(n: 1) == 1)\nassert(sum_to_n(n: 6) == 21)\nassert(sum_to_n(n: 11) == 66)\nassert(sum_to_n(n: 30) == 465)\nassert(sum_to_n(n: 100) == 5050)"},{"task_id":"HumanEval_61","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ return true dacă fiecare paranteză de deschidere are o paranteză de închidere corespunzătoare. \/\/ paranteze este un șir de \"(\" și \")\". \/\/\/ >>> correct_bracketing(brackets: \"(\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"()\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"(()())\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \")(()\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    for char in brackets {\n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)"},{"task_id":"HumanEval_62","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează derivația acestui polinom în aceeași formă. \/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/ x reprezintă coeficienții unui polinom. \/\/\/ >>> derivative(xs: [3, 1, 2, 4, 5])\n\/\/\/ [1, 4, 12, 20]\n\/\/\/ >>> derivative(xs: [1, 2, 3])\n\/\/\/ [2, 6]\nfunc derivative(xs: [Int]) -> [Int] {\n","canonical_solution":"func derivative(xs: [Int]) -> [Int] {\n    guard xs.count > 1 else { return [] }\n    var result: [Int] = []\n    for i in 1..<xs.count {\n        result.append(xs[i] * i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])\nassert(derivative(xs: [1, 2, 3]) == [2, 6])\nassert(derivative(xs: [3, 2, 1]) == [2, 2])\nassert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])\nassert(derivative(xs: [1]) == [] as [Int])"},{"task_id":"HumanEval_63","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Vă rugăm să scrieți o funcție pentru a calcula în mod eficient elementul n-lea al secvenței de numere fibfib. \/\/ fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). - Nu, nu, nu.- Nu, nu, nu.- Nu, nu, nu.\/\/ Secvența numerică FibFib este o secvență similară cu secvența Fibbonacci care este definită după cum urmează: \/\/\/ >>> fibfib(n: 1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(n: 8)\n\/\/\/ 24\nfunc fibfib(n: Int) -> Int {\n","canonical_solution":"func fibfib(n: Int) -> Int {\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    \n    var fibfibNums = [0, 0, 1]\n    \n    for i in 3...n {\n        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]\n        fibfibNums.append(nextFibFib)\n    }\n    \n    return fibfibNums[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fibfib(n: 2) == 1)\nassert(fibfib(n: 1) == 0)\nassert(fibfib(n: 5) == 4)\nassert(fibfib(n: 8) == 24)\nassert(fibfib(n: 10) == 81)\nassert(fibfib(n: 12) == 274)\nassert(fibfib(n: 14) == 927)"},{"task_id":"HumanEval_64","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ vocale, dar numai atunci când este la sfârșitul cuvântului dat.\/\/ Vocalele în acest caz sunt \"a\", \"e\", \"i\", \"o\", \"u\". Aici, \"y\" este de asemenea un \/\/ un cuvânt ca intrare şi returnează numărul de vocală din string. \/\/ Scrie o funcţie vowels_count care ia un şir care reprezintă \/\/\/ >>> vowels_count(s: \"abcde\")\n\/\/\/ 2\n\/\/\/ >>> vowels_count(s: \"ACEDY\")\n\/\/\/ 3\nfunc vowels_count(s: String) -> Int {\n","canonical_solution":"func vowels_count(s: String) -> Int {\n    guard !s.isEmpty else { return 0 }\n    \n    let vowels = Set(\"aeiouAEIOU\")\n    var count = 0\n    let characters = Array(s)\n    \n    for i in 0..<characters.count {\n        let char = characters[i]\n        \n        if vowels.contains(char) {\n            count += 1\n        } else if char == \"y\" || char == \"Y\" {\n            if i == characters.count - 1 {\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(vowels_count(s: \"abcde\") == 2)\nassert(vowels_count(s: \"Alone\") == 3)\nassert(vowels_count(s: \"key\") == 2)\nassert(vowels_count(s: \"bye\") == 1)\nassert(vowels_count(s: \"keY\") == 2)\nassert(vowels_count(s: \"bYe\") == 1)\nassert(vowels_count(s: \"ACEDY\") == 3)"},{"task_id":"HumanEval_65","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Dacă shift > numărul de cifre, returnăm cifrele inversate. \/\/ şi returnează rezultatul ca un șir. \/\/ Circular mutarea cifrelor de întreg x, mutarea cifrelor dreapta de mutare \/\/\/ >>> circular_shift(x: 12, shift: 1)\n\/\/\/ \"21\"\n\/\/\/ >>> circular_shift(x: 12, shift: 2)\n\/\/\/ \"12\"\nfunc circular_shift(x: Int, shift: Int) -> String {\n","canonical_solution":"func circular_shift(x: Int, shift: Int) -> String {\n    let digits = Array(String(x))\n    let count = digits.count\n    \n    \/\/ If shift is greater than the number of digits, return the digits reversed\n    if shift >= count {\n        return String(digits.reversed())\n    }\n    \n    \/\/ Calculate the actual shift needed by using modulo operation\n    let actualShift = shift % count\n    \n    \/\/ Perform the circular shift to the right\n    let splitIndex = count - actualShift\n    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]\n    \n    return String(shiftedDigits)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(circular_shift(x: 100, shift: 2) == \"001\")\nassert(circular_shift(x: 12, shift: 2) == \"12\")\nassert(circular_shift(x: 97, shift: 8) == \"79\")\nassert(circular_shift(x: 12, shift: 1) == \"21\")\nassert(circular_shift(x: 11, shift: 101) == \"11\")"},{"task_id":"HumanEval_66","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Coduri ASCII. \/\/ Scrie o funcție care ia un șir ca intrare și returnează suma doar a caractere superioare' \/\/ Sarcina \/\/\/ >>> digitSum(s: \"\")\n\/\/\/ 0\n\/\/\/ >>> digitSum(s: \"abAB\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"abcCd\")\n\/\/\/ 67\n\/\/\/ >>> digitSum(s: \"helloE\")\n\/\/\/ 69\n\/\/\/ >>> digitSum(s: \"woArBld\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"aAaaaXa\")\n\/\/\/ 153\nfunc digitSum(s: String) -> Int {\n","canonical_solution":"func digitSum(s: String) -> Int {\n    var sum = 0\n    for character in s {\n        if character.isUppercase {\n            sum += Int(character.asciiValue ?? 0)\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digitSum(s: \"\") == 0)\nassert(digitSum(s: \"abAB\") == 131)\nassert(digitSum(s: \"abcCd\") == 67)\nassert(digitSum(s: \"helloE\") == 69)\nassert(digitSum(s: \"woArBld\") == 131)\nassert(digitSum(s: \"aAaaaXa\") == 153)\nassert(digitSum(s: \" How are yOu?\") == 151)\nassert(digitSum(s: \"You arE Very Smart\") == 327)"},{"task_id":"HumanEval_67","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ pentru examble: \/\/ în coș returnează numărul de fructe de mango din coș. \/\/ portocalele şi merele şi un număr întreg care reprezintă numărul total de fructe \/\/ mere, portocale, şi fructe de mango. dat string care reprezintă numărul total de \/\/ care sunt distribuite într-un coș de fructe acest coș conține \/\/ În această sarcină, vi se va da un șir care reprezintă un număr de mere și portocale \/\/\/ >>> fruit_distribution(s: \"5 apples and 6 oranges\", n: 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(s: \"0 apples and 1 oranges\", n: 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(s: \"2 apples and 3 oranges\", n: 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(s: \"100 apples and 1 oranges\", n: 120)\n\/\/\/ 19\nfunc fruit_distribution(s: String, n: Int) -> Int {\n","canonical_solution":"func fruit_distribution(s: String, n: Int) -> Int {\n    let components = s.components(separatedBy: \" \")\n    var apples = 0\n    var oranges = 0\n    \n    for (index, component) in components.enumerated() {\n        if component == \"apples\" || component == \"apple\" {\n            if let number = Int(components[index - 1]) {\n                apples = number\n            }\n        } else if component == \"oranges\" || component == \"orange\" {\n            if let number = Int(components[index - 1]) {\n                oranges = number\n            }\n        }\n    }\n    \n    let totalApplesOranges = apples + oranges\n    let mangoes = n - totalApplesOranges\n    return mangoes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 19) == 8)\nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 21) == 10)\nassert(fruit_distribution(s: \"0 apples and 1 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"1 apples and 0 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 100) == 95)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 5) == 0)\nassert(fruit_distribution(s: \"1 apples and 100 oranges\", n: 120) == 19)"},{"task_id":"HumanEval_68","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu 1: \/\/ Dacă nu există valori pereche sau dacă tabla dată este goală, returnăm []. \/\/ Nodul cules trebuie returnat într-o matrice, [smallest_value, indexul său], \/\/ Dacă sunt găsite mai multe noduri cu aceeași valoare pară cea mai mică, returnează nodul cu cel mai mic indice. \/\/ Nodul cules ar trebui să fie nodul cu cea mai mică valoare par. \/\/ sarcina ta este de a smulge unul dintre noduri și să-l returneze. \/\/ \"Dată o matrice care reprezintă o ramură a unui copac care are noduri de număr întreg non-negativ \/\/\/ >>> pluck(arr: [4, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(arr: [1, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(arr: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\/\/\/ [0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfunc pluck(arr: [Int]) -> [Int] {\n","canonical_solution":"func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue: Int? = nil\n    var smallestIndex: Int? = nil\n\n    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {\n                smallestEvenValue = value\n                smallestIndex = index\n            }\n        }\n    }\n\n    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {\n        return [smallestEvenValue, smallestIndex]\n    } else {\n        return []\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"},{"task_id":"HumanEval_69","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Dacă nu există o astfel de valoare, returnăm -1. \/\/ Frecvența unui întreg este numărul de ori apare în tablă. \/\/ zero, și are o frecvență mai mare sau egală cu valoarea întregului în sine. \/\/ Ai o matrice de numere întregi pozitive, nu goală.\/\/\/ >>> search(lst: [4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(lst: [5, 5, 4, 4, 4])\n\/\/\/ -1\nfunc search(lst: [Int]) -> Int {\n","canonical_solution":"func search(lst: [Int]) -> Int {\n    var frequencyMap = [Int: Int]()\n    \n    \/\/ Count frequencies of each number in the list\n    for number in lst {\n        frequencyMap[number, default: 0] += 1\n    }\n    \n    var result = -1\n    \n    \/\/ Iterate through the frequency map to find the greatest integer that satisfies the condition\n    for (number, frequency) in frequencyMap {\n        if frequency >= number {\n            result = max(result, number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(lst: [5, 5, 5, 5, 1]) == 1)\nassert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)\nassert(search(lst: [3, 3]) == -1)\nassert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)\nassert(search(lst: [2, 3, 3, 2, 2]) == 2)\nassert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\nassert(search(lst: [3, 2, 8, 2]) == 2)\nassert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\nassert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)\nassert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\nassert(search(lst: [1, 9, 10, 1, 3]) == 1)\nassert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\nassert(search(lst: [1]) == 1)\nassert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\nassert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\nassert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\nassert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)\nassert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\nassert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\nassert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\nassert(search(lst: [10]) == -1)\nassert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\nassert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\nassert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\nassert(search(lst: [3, 10, 10, 9, 2]) == -1)"},{"task_id":"HumanEval_70","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ apoi maximul din restul de numere întregi, apoi minim și așa mai departe. \/\/ Sortajul ciudat, este atunci când începe cu valoarea minimă, \/\/ Având în vedere matricea de numere întregi, returnăm matricea în ordine ciudată.\/\/\/ >>> strange_sort_list(lst: [1, 2, 3, 4])\n\/\/\/ [1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(lst: [5, 5, 5, 5])\n\/\/\/ [5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(lst: [] as [Int])\n\/\/\/ [] as [Int]\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n","canonical_solution":"func strange_sort_list(lst: [Int]) -> [Int] {\n    var sortedList = lst.sorted()\n    var result: [Int] = []\n    \n    while !sortedList.isEmpty {\n        if let min = sortedList.first {\n            result.append(min)\n            sortedList.removeFirst()\n        }\n        \n        if let max = sortedList.last {\n            result.append(max)\n            sortedList.removeLast()\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"},{"task_id":"HumanEval_71","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ decât a treia parte. Trei laturi fac un triunghi valid atunci când suma oricăror două laturi este mai mare.\/\/ Altfel, returnăm -1 \/\/ triunghiul rotunjit la 2 zecimale dacă cele trei laturi formează un triunghi valid. \/\/ Dată lungimea celor trei laturi ale unui triunghi, exprimăm suprafaţa lui \/\/\/ >>> triangle_area(a: 3, b: 4, c: 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(a: 1, b: 2, c: 10)\n\/\/\/ -1\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, b: Int, c: Int) -> Double {\n    \/\/ Check if the sides form a valid triangle\n    if a + b > c && a + c > b && b + c > a {\n        \/\/ Calculate the semi-perimeter\n        let s = Double(a + b + c) \/ 2.0\n        \/\/ Calculate the area using Heron's formula\n        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))\n        \/\/ Round to 2 decimal places\n        return round(area * 100) \/ 100\n    } else {\n        return -1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 3, b: 4, c: 5) == 6.0)\nassert(triangle_area(a: 1, b: 2, c: 10) == -1)\nassert(triangle_area(a: 4, b: 8, c: 5) == 8.18)\nassert(triangle_area(a: 2, b: 2, c: 2) == 1.73)\nassert(triangle_area(a: 1, b: 2, c: 3) == -1)\nassert(triangle_area(a: 10, b: 5, c: 7) == 16.25)\nassert(triangle_area(a: 2, b: 6, c: 3) == -1)\nassert(triangle_area(a: 1, b: 1, c: 1) == 0.43)\nassert(triangle_area(a: 2, b: 2, c: 10) == -1)"},{"task_id":"HumanEval_72","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: Obiectul q va zbura dacă este echilibrat (este un matriciu palindromic) și suma elementelor sale este mai mică sau egală cu greutatea maximă posibilă w.\/\/ Scrieți o funcție care returnează adevărat dacă obiectul q va zbura, și fals în caz contrar. \/\/\/ >>> will_it_fly(q: [1, 2], w: 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(q: [3], w: 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int], w: Int) -> Bool {\n","canonical_solution":"func will_it_fly(q: [Int], w: Int) -> Bool {\n    func isPalindromic(_ array: [Int]) -> Bool {\n        return array == array.reversed()\n    }\n    \n    let sum = q.reduce(0, +)\n    return isPalindromic(q) && sum <= w\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"},{"task_id":"HumanEval_73","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ este citit la fel înainte şi înapoi. Într-o singură schimbare, poţi schimba un element în orice alt element.\/\/ trebuie schimbat pentru a face matrice palindrom.\/\/ Având în vedere o serie de numere întregi, găsiți numărul minim de elemente care \/\/\/ >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 2, 1])\n\/\/\/ 0\nfunc smallest_change(arr: [Int]) -> Int {\n","canonical_solution":"func smallest_change(arr: [Int]) -> Int {\n    var changes = 0\n    let n = arr.count\n\n    for i in 0..<(n \/ 2) {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1\n        }\n    }\n\n    return changes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)\nassert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)\nassert(smallest_change(arr: [3, 1, 1, 3]) == 0)\nassert(smallest_change(arr: [1]) == 0)\nassert(smallest_change(arr: [0, 1]) == 1)"},{"task_id":"HumanEval_74","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple \/\/ dacă cele două matrice au același număr de caractere, returnează prima matrice. \/\/ numărul total de caractere în toate șirurile de matricea mai puțin decât alte matricea. \/\/ Scrieți o funcție care acceptă două matrice de șiruri și returnează matricea care are \/\/\/ >>> total_match(lst1: [] as [String], lst2: [] as [String])\n\/\/\/ [] as [String]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"])\n\/\/\/ [\"hI\", \"Hi\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/\/ [\"hi\", \"admin\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"])\n\/\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/\/ >>> total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/\/ [\"4\"]\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n","canonical_solution":"func total_match(lst1: [String], lst2: [String]) -> [String] {\n    let totalChars1 = lst1.reduce(0) { $0 + $1.count }\n    let totalChars2 = lst2.reduce(0) { $0 + $1.count }\n    \n    if totalChars1 < totalChars2 {\n        return lst1\n    } else if totalChars2 < totalChars1 {\n        return lst2\n    } else {\n        return lst1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"]) == [\"4\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [] as [String], lst2: [\"this\"]) == [] as [String])\nassert(total_match(lst1: [\"this\"], lst2: [] as [String]) == [] as [String])"},{"task_id":"HumanEval_75","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ Știind că (a) este mai mic decât 100. \/\/ şi fals altfel. \/\/ Scrie o funcție care returnează adevărat dacă numărul dat este înmulțirea cu 3 numere prime \/\/\/ >>> is_multiply_prime(a: 30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a: Int) -> Bool {\n","canonical_solution":"func is_multiply_prime(a: Int) -> Bool {\n    \/\/ Function to check if a number is prime\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Generate all prime numbers less than 100\n    var primes = [Int]()\n    for i in 2..<100 {\n        if isPrime(i) {\n            primes.append(i)\n        }\n    }\n    \n    \/\/ Check combinations of 3 primes\n    let primeCount = primes.count\n    for i in 0..<primeCount {\n        for j in i..<primeCount {\n            for k in j..<primeCount {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_multiply_prime(a: 5) == false)\nassert(is_multiply_prime(a: 30) == true)\nassert(is_multiply_prime(a: 8) == true)\nassert(is_multiply_prime(a: 10) == false)\nassert(is_multiply_prime(a: 125) == true)\nassert(is_multiply_prime(a: 105) == true)\nassert(is_multiply_prime(a: 126) == false)\nassert(is_multiply_prime(a: 729) == false)\nassert(is_multiply_prime(a: 891) == false)\nassert(is_multiply_prime(a: 1001) == true)"},{"task_id":"HumanEval_76","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ x este o putere simplă a lui n dacă n**int=x \/\/ puterea lui n şi fals în alte cazuri. \/\/ Sarcina ta este de a scrie o funcție care returnează adevărat dacă un număr x este un simplu \/\/\/ >>> is_simple_power(x: 1, n: 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 2, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 8, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 3, n: 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 3, n: 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 5, n: 3)\n\/\/\/ false\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n","canonical_solution":"func is_simple_power(x: Int, n: Int) -> Bool {\n    if x < 1 || n < 1 {\n        return false\n    }\n    if x == 1 {\n        return true \/\/ n**0 = 1\n    }\n    var power = 1\n    while power < x {\n        power *= n\n    }\n    return power == x\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_simple_power(x: 16, n: 2) == true)\nassert(is_simple_power(x: 143214, n: 16) == false)\nassert(is_simple_power(x: 4, n: 2) == true)\nassert(is_simple_power(x: 9, n: 3) == true)\nassert(is_simple_power(x: 16, n: 4) == true)\nassert(is_simple_power(x: 24, n: 2) == false)\nassert(is_simple_power(x: 128, n: 4) == false)\nassert(is_simple_power(x: 12, n: 6) == false)\nassert(is_simple_power(x: 1, n: 1) == true)\nassert(is_simple_power(x: 1, n: 12) == true)"},{"task_id":"HumanEval_77","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Nota: se poate presupune că intrarea este întotdeauna valabilă. \/\/ dacă acest ingeger este un cub de un număr întreg. \/\/ Scrie o funcție care ia un întreg a și returnează true \/\/\/ >>> iscube(a: 1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 2)\n\/\/\/ false\n\/\/\/ >>> iscube(a: -1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 64)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 0)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 180)\n\/\/\/ false\nfunc iscube(a: Int) -> Bool {\n","canonical_solution":"func iscube(a: Int) -> Bool {\n    if a == 0 { return true } \/\/ 0 is a cube (0^3)\n    let absA = abs(a)\n    let cubeRoot = Int(round(pow(Double(absA), 1.0\/3.0)))\n    return cubeRoot * cubeRoot * cubeRoot == absA\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(iscube(a: 1) == true)\nassert(iscube(a: 2) == false)\nassert(iscube(a: -1) == true)\nassert(iscube(a: 64) == true)\nassert(iscube(a: 180) == false)\nassert(iscube(a: 1000) == true)\nassert(iscube(a: 0) == true)\nassert(iscube(a: 1729) == false)"},{"task_id":"HumanEval_78","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ şi simbolurile A,B,C,D,E,F sunt întotdeauna mari. \/\/ Nota: puteți presupune că intrarea este întotdeauna corectă sau șir gol, \/\/ B (= decimală 11), D (= decimală 13). \/\/ Deci trebuie să determinați un număr din următoarele cifre: 2, 3, 5, 7, \/\/ Numerele prime sunt 2, 3, 5, 7, 11, 13, 17,... \/\/ Cifrele hexadecimale sunt 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/\/ mai mare de 1 care nu este un produs al a doi numere naturale mai mici). \/\/ cifre care sunt prime (număr prim, sau un prim, este un număr natural \/\/ un număr hexadecimal ca un șir și numără numărul de hexadecimale \/\/ Ai fost însărcinat să scrii o funcţie care primeşte \/\/\/ >>> hex_key(num: \"AB\")\n\/\/\/ 1\n\/\/\/ >>> hex_key(num: \"1077E\")\n\/\/\/ 2\n\/\/\/ >>> hex_key(num: \"ABED1A33\")\n\/\/\/ 4\n\/\/\/ >>> hex_key(num: \"123456789ABCDEF0\")\n\/\/\/ 6\n\/\/\/ >>> hex_key(num: \"2020\")\n\/\/\/ 2\nfunc hex_key(num: String) -> Int {\n","canonical_solution":"func hex_key(num: String) -> Int {\n    \/\/ Define hexadecimal digits that are prime numbers\n    let primeHexDigits: Set<Character> = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    \n    \/\/ Initialize count\n    var primeCount = 0\n    \n    \/\/ Iterate over each character in the string\n    for char in num {\n        \/\/ Check if the character is a prime hexadecimal digit\n        if primeHexDigits.contains(char) {\n            primeCount += 1\n        }\n    }\n    \n    return primeCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"},{"task_id":"HumanEval_79","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Caracterele suplimentare sunt acolo pentru a ajuta cu formatul. \/\/ Va fi o pereche suplimentară de caractere \"db\" la începutul și la sfârșitul șirului. Fiecare caracter din string va fi \"0\" sau \"1\".Funcția ar trebui să returneze un șir, fiecare caracter reprezentând un număr binar.\/\/ Vi se va da un număr în formă decimală şi sarcina voastră este să-l convertiţi în \/\/\/ >>> decimal_to_binary(decimal: 15)\n\/\/\/ \"db1111db\"\n\/\/\/ >>> decimal_to_binary(decimal: 32)\n\/\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal: Int) -> String {\n","canonical_solution":"func decimal_to_binary(decimal: Int) -> String {\n    let binaryString = String(decimal, radix: 2)\n    return \"db\" + binaryString + \"db\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(decimal_to_binary(decimal: 0) == \"db0db\")\nassert(decimal_to_binary(decimal: 32) == \"db100000db\")\nassert(decimal_to_binary(decimal: 103) == \"db1100111db\")\nassert(decimal_to_binary(decimal: 15) == \"db1111db\")"},{"task_id":"HumanEval_80","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Un șir este rapid dacă lungimea lui este de cel puțin 3 și fiecare 3 litere consecutive sunt distincte \/\/ Sarcina ta este să verifici dacă stringul este hapswift sau nu. \/\/ Ai un șir de s. \/\/\/ >>> is_happy(s: \"a\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"aa\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"aabb\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"adb\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"xyy\")\n\/\/\/ false\nfunc is_happy(s: String) -> Bool {\n","canonical_solution":"func is_happy(s: String) -> Bool {\n    let characters = Array(s)\n    if characters.count < 3 {\n        return false\n    }\n    \n    for i in 0..<(characters.count - 2) {\n        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"},{"task_id":"HumanEval_81","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ 0.0 E \/\/ > 0,0 D- \/\/ > 0,7 D \/\/ > 1,0 D+ \/\/ > 1,3 C- \/\/ > 1,7 C \/\/ > 2,0 C+ \/\/ > 2.3 B- \/\/ > 2,7 B \/\/ > 3,0 B+ \/\/ > 3.3 A- \/\/ > 3,7 A \/\/ 4.0 A+ - GPA. - Nota literală.\/\/ o funcţie care poate da o serie de note de litere folosind următorul tabel: \/\/ Ea v-a dat o serie de GPA pentru unii elevi și trebuie să scrie Singura problemă e că a pierdut codul de evaluare.Învăţătoarea îşi creează propriul algoritm de evaluare.\/\/ Este ultima săptămână a semestrului şi profesorul trebuie să dea notele .\/\/\/ >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])\n\/\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n","canonical_solution":"func numerical_letter_grade(grades: [Double]) -> [String] {\n    return grades.map { gpa in\n        switch gpa {\n        case 4.0:\n            return \"A+\"\n        case 3.7...4.0:\n            return \"A\"\n        case 3.3..<3.7:\n            return \"A-\"\n        case 3.0..<3.3:\n            return \"B+\"\n        case 2.7..<3.0:\n            return \"B\"\n        case 2.3..<2.7:\n            return \"B-\"\n        case 2.0..<2.3:\n            return \"C+\"\n        case 1.7..<2.0:\n            return \"C\"\n        case 1.3..<1.7:\n            return \"C-\"\n        case 1.0..<1.3:\n            return \"D+\"\n        case 0.7..<1.0:\n            return \"D\"\n        case 0.0..<0.7:\n            return \"D-\"\n        default:\n            return \"E\"\n        }\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\nassert(numerical_letter_grade(grades: [1.2]) == [\"D+\"])\nassert(numerical_letter_grade(grades: [0.5]) == [\"D-\"])\nassert(numerical_letter_grade(grades: [0.0]) == [\"E\"])\nassert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\nassert(numerical_letter_grade(grades: [0.0, 0.7]) == [\"E\", \"D-\"])"},{"task_id":"HumanEval_82","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple \/\/ lungimea este un număr prim sau fals altfel \/\/ Scrie o funcție care ia un șir și returnează adevărat dacă șirul \/\/\/ >>> prime_length(string: \"Hello\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"abcdcba\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"kittens\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"orange\")\n\/\/\/ false\nfunc prime_length(string: String) -> Bool {\n","canonical_solution":"func prime_length(string: String) -> Bool {\n    let length = string.count\n    \n    guard length > 1 else {\n        return false\n    }\n    \n    for i in 2..<length {\n        if length % i == 0 {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_length(string: \"Hello\") == true)\nassert(prime_length(string: \"abcdcba\") == true)\nassert(prime_length(string: \"kittens\") == true)\nassert(prime_length(string: \"orange\") == false)\nassert(prime_length(string: \"wow\") == true)\nassert(prime_length(string: \"world\") == true)\nassert(prime_length(string: \"MadaM\") == true)\nassert(prime_length(string: \"Wow\") == true)\nassert(prime_length(string: \"\") == false)\nassert(prime_length(string: \"HI\") == true)\nassert(prime_length(string: \"go\") == true)\nassert(prime_length(string: \"gogo\") == false)\nassert(prime_length(string: \"aaaaaaaaaaaaaaa\") == false)\nassert(prime_length(string: \"Madam\") == true)\nassert(prime_length(string: \"M\") == false)\nassert(prime_length(string: \"0\") == false)"},{"task_id":"HumanEval_83","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ intregi pozitive care încep sau se încheie cu 1. \/\/ Având în vedere un întreg pozitiv n, returnează numărul de numere de n cifre func starts_one_ends(n: Int) -> Int {\n","canonical_solution":"func starts_one_ends(n: Int) -> Int {\n    if n == 1 {\n        \/\/ For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.\n        return 1\n    }\n    \n    \/\/ Count of n-digit numbers starting with 1:\n    \/\/ First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.\n    let startWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Count of n-digit numbers ending with 1:\n    \/\/ Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.\n    \/\/ So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.\n    let endWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Intersection of both sets is the numbers starting and ending with 1\n    \/\/ which are of the form `1` followed by (n-2) digits and `1`, so:\n    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))\n    \n    return startWithOne + endWithOne - startAndEndWithOne\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n: 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4) == 1800)\nassert(starts_one_ends(n: 5) == 18000)"},{"task_id":"HumanEval_84","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu \/\/ Având în vedere un întreg pozitiv N, returnează suma totală a cifrelor sale în binar. \/\/\/ >>> solve(N: 1000)\n\/\/\/ \"1\"\n\/\/\/ >>> solve(N: 150)\n\/\/\/ \"110\"\n\/\/\/ >>> solve(N: 147)\n\/\/\/ \"1100\"\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfunc solve(N: Int) -> String {\n","canonical_solution":"func solve(N: Int) -> String {\n    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    return String(sumOfDigits, radix: 2)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"},{"task_id":"HumanEval_85","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Având în vedere o serie de integeruri ne-goale, adăugăm elementele pereche care sunt la indici impar.\/\/\/ >>> add(lst: [4, 2, 6, 7])\n\/\/\/ 2\nfunc add(lst: [Int]) -> Int {\n","canonical_solution":"func add(lst: [Int]) -> Int {\n    var sum = 0\n    for i in stride(from: 1, to: lst.count, by: 2) {\n        if lst[i] % 2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(lst: [4, 88]) == 88)\nassert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)\nassert(add(lst: [4, 0, 6, 7]) == 0)\nassert(add(lst: [4, 4, 6, 8]) == 12)"},{"task_id":"HumanEval_86","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Nota: Trebuie să păstraţi ordinea cuvintelor şi spaţiul liber în propoziţie.\/\/ ordinea ascendentă bazată pe valoarea ASCII. \/\/ sunt înlocuite cu un cuvânt nou în care toate caractere aranjate în \/\/ Versiunea ordonată a stringului, este un string în care toate cuvintele (separate prin spațiu) \/\/ Scrieți o funcție care ia un șir și returnează o versiune ordonată a acestuia. \/\/\/ >>> anti_shuffle(s: \"Hi\")\n\/\/\/ \"Hi\"\n\/\/\/ >>> anti_shuffle(s: \"hello\")\n\/\/\/ \"ehllo\"\n\/\/\/ >>> anti_shuffle(s: \"Hello World!!!\")\n\/\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s: String) -> String {\n","canonical_solution":"func anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy: .whitespaces)\n    let orderedWords = words.map { String($0.sorted()) }\n    var result = \"\"\n    var wordIndex = 0\n    \n    for character in s {\n        if character.isWhitespace {\n            result.append(character)\n        } else if wordIndex < orderedWords.count {\n            if let currentWord = orderedWords[wordIndex].first {\n                result.append(currentWord)\n                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)\n            }\n        }\n        \n        if let lastCharacter = result.last {\n            if lastCharacter.isWhitespace {\n                wordIndex += 1\n            }\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"},{"task_id":"HumanEval_87","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ De asemenea, sorta coordonatele rândului de coloane în ordine descrescătoare. \/\/ Sortarea iniţială a coordonatelor în rânduri în ordine ascendentă. \/\/ fiecare tupul este o coordonată - (radă, coloane), începând cu 0. \/\/ și returnăm o serie de tuple, [(x1, y1), (x2, y2) ...] astfel încât \/\/ Având în vedere lst, și întreg x, găsiți numerele întregi x în matrice, \/\/ fiecare rând poate conține un număr diferit de coloane. \/\/ care este similar cu matricea, cu toate acestea, spre deosebire de matrici, \/\/ Vă sunt date date 2 dimensionale, ca o matrice nested, \/\/\/ >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n\/\/\/ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(lst: [] as [[Int]], x: 1)\n\/\/\/ [] as [(Int, Int)]\n\/\/\/ >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)\n\/\/\/ [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n","canonical_solution":"func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var coordinates: [(Int, Int)] = []\n    \n    for (rowIndex, row) in lst.enumerated() {\n        for (colIndex, value) in row.enumerated() {\n            if value == x {\n                coordinates.append((rowIndex, colIndex))\n            }\n        }\n    }\n    \n    let sortedCoordinates = coordinates.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n        } else {\n            return $0.0 < $1.0\n        }\n    }\n    \n    return sortedCoordinates\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"},{"task_id":"HumanEval_88","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ * nu schimbați matricea dată. \/\/ Nota: \/\/ sau sortați-l în ordine descrescătoare dacă suma ((prima valoare a indicelui, ultima valoare a indicelui) este par. \/\/ vei sorta matricea dată în ordine ascendentă dacă suma ((prima valoare a indicelui, ultima valoare a indicelui) este impară, \/\/ Având în vedere o serie de non-negative de numere întregi, returnează un coswift de serie dată după sortare, \/\/\/ >>> sort_array(array: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ >>> sort_array(array: [5])\n\/\/\/ [5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5])\n\/\/\/ [0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])\n\/\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunc sort_array(array: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(array: [Int]) -> [Int] {\n    guard let first = array.first, let last = array.last else {\n        return array\n    }\n    let sum = first + last\n    if sum % 2 == 0 {\n        return array.sorted(by: >) \/\/ Descending order\n    } else {\n        return array.sorted() \/\/ Ascending order\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(array: [] as [Int]) == [] as [Int])\nassert(sort_array(array: [5]) == [5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\nassert(sort_array(array: [2, 1]) == [1, 2])\nassert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\nassert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"},{"task_id":"HumanEval_89","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ se deplasează în jos de două ori la două locuri. \/\/ Alfabetul ar trebui rotit astfel încât literele \/\/ returnează un șir criptat cu rotirea alfabetului. \/\/ Crearea unei funcţii criptate care ia un şir ca argument şi \/\/\/ >>> encrypt(s: \"hi\")\n\/\/\/ \"lm\"\n\/\/\/ >>> encrypt(s: \"asdfghjkl\")\n\/\/\/ \"ewhjklnop\"\n\/\/\/ >>> encrypt(s: \"gf\")\n\/\/\/ \"kj\"\n\/\/\/ >>> encrypt(s: \"et\")\n\/\/\/ \"ix\"\nfunc encrypt(s: String) -> String {\n","canonical_solution":"func encrypt(s: String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let shift = 2 * 2 \/\/ shift down by two multiplied by two places, i.e., 4\n    var result = \"\"\n\n    for character in s {\n        if let index = alphabet.firstIndex(of: character) {\n            let newIndex = (index + shift) % alphabet.count\n            result.append(alphabet[newIndex])\n        } else {\n            result.append(character) \/\/ append non-alphabetic characters unchanged\n        }\n    }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") == \"e\")"},{"task_id":"HumanEval_90","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Returnează null dacă nu există un astfel de element. \/\/ Scrieți o funcție next_smallest (() care returnează al doilea element cel mai mic din matrice. \/\/ Ai o serie de numere întregi. \/\/\/ >>> next_smallest(lst: [1, 2, 3, 4, 5])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [] as [Int])\n\/\/\/ nil\n\/\/\/ >>> next_smallest(lst: [1, 1])\n\/\/\/ nil\nfunc next_smallest(lst: [Int]) -> Int? {\n","canonical_solution":"func next_smallest(lst: [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    \n    var uniqueSorted = Array(Set(lst)).sorted()\n    \n    if uniqueSorted.count < 2 {\n        return nil\n    }\n    \n    return uniqueSorted[1]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"},{"task_id":"HumanEval_91","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Frazele sunt delimitate de \"\", \"?\" sau \"!\"O plictiseală este o propoziţie care începe cu cuvântul \"eu\".\/\/ Vei primi un şir de cuvinte, şi sarcina ta este să numeri numărul.\/\/\/ >>> is_bored(S: \"Hello world\")\n\/\/\/ 0\n\/\/\/ >>> is_bored(S: \"The sky is blue. The sun is shining. I love this weather\")\n\/\/\/ 1\nfunc is_bored(S: String) -> Int {\n","canonical_solution":"func is_bored(S: String) -> Int {\n    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }\n    var boredomCount = 0\n    \n    for sentence in sentences {\n        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)\n        if trimmedSentence.hasPrefix(\"I\") {\n            boredomCount += 1\n        }\n    }\n    \n    return boredomCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_bored(S: \"Hello world\") == 0)\nassert(is_bored(S: \"Is the sky blue?\") == 0)\nassert(is_bored(S: \"I love It !\") == 1)\nassert(is_bored(S: \"bIt\") == 0)\nassert(is_bored(S: \"I feel good today. I will be productive. will kill It\") == 2)\nassert(is_bored(S: \"You and I are going for a walk\") == 0)"},{"task_id":"HumanEval_92","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple \/\/ Returnează fals în orice alte cazuri. \/\/ Returnează adevărat dacă unul dintre numere este egal cu suma celorlalte două, și toate numerele sunt numere întregi. \/\/ Creează o funcție care ia 3 numere. \/\/\/ >>> any_int(x: 5, y: 2, z: 7)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3, y: 2, z: 2)\n\/\/\/ false\n\/\/\/ >>> any_int(x: 3, y: -2, z: 1)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3.6, y: -2.2, z: 2)\n\/\/\/ false\nfunc any_int(x: Double, y: Double, z: Double) -> Bool {\n","canonical_solution":"func any_int(x: Double, y: Double, z: Double) -> Bool {\n    guard x == floor(x), y == floor(y), z == floor(z) else {\n        return false\n    }\n    \n    let a = Int(x)\n    let b = Int(y)\n    let c = Int(z)\n    \n    return a == b + c || b == a + c || c == a + b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(any_int(x: 2, y: 3, z: 1) == true)\nassert(any_int(x: 2.5, y: 2, z: 3) == false)\nassert(any_int(x: 1.5, y: 5, z: 3.5) == false)\nassert(any_int(x: 2, y: 6, z: 2) == false)\nassert(any_int(x: 4, y: 2, z: 2) == true)\nassert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)\nassert(any_int(x: -4, y: 6, z: 2) == true)\nassert(any_int(x: 2, y: 1, z: 1) == true)\nassert(any_int(x: 3, y: 4, z: 7) == true)\nassert(any_int(x: 3.0, y: 4, z: 7) == false)"},{"task_id":"HumanEval_93","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: - Presupun doar litere.\/\/ Vocale în alfabetul englez. \/\/ mesajul cu litera care apare cu 2 locuri înaintea lui \/\/ modul în care se schimbă caz de toate literele, înlocuiește toate vocale în \/\/ Scrie o funcție care ia un mesaj, și codifică într-o astfel de \/\/\/ >>> encode(message: \"test\")\n\/\/\/ \"TGST\"\n\/\/\/ >>> encode(message: \"This is a message\")\n\/\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n","canonical_solution":"func encode(message: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    let vowelReplacement = [\n        \"a\": \"c\", \"e\": \"g\", \"i\": \"k\", \"o\": \"q\", \"u\": \"w\",\n        \"A\": \"C\", \"E\": \"G\", \"I\": \"K\", \"O\": \"Q\", \"U\": \"W\"\n    ]\n    \n    var encodedMessage = \"\"\n    \n    for char in message {\n        if vowels.contains(char) {\n            if let replacement = vowelReplacement[String(char)] {\n                encodedMessage.append(replacement)\n            }\n        } else {\n            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())\n            encodedMessage.append(swappedCase)\n        }\n    }\n    \n    return encodedMessage\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"},{"task_id":"HumanEval_94","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Trebuie să găsești cea mai mare valoare primă și să returnezi suma cifrelor sale. \/\/ Ai o serie de numere întregi. \/\/\/ >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfunc skjkasdkd(lst: [Int]) -> Int {\n","canonical_solution":"func skjkasdkd(lst: [Int]) -> Int {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    var largestPrime: Int? = nil\n    for number in lst {\n        if isPrime(number) {\n            if largestPrime == nil || number > largestPrime! {\n                largestPrime = number\n            }\n        }\n    }\n    \n    if let largestPrime = largestPrime {\n        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    }\n    \n    return 0 \/\/ In case there are no prime numbers\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)\nassert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)\nassert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)\nassert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)\nassert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)\nassert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)\nassert(skjkasdkd(lst: [8191]) == 19)\nassert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)\nassert(skjkasdkd(lst: [127, 97, 8192]) == 10)"},{"task_id":"HumanEval_96","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ de exemplu: \/\/ numerele întregi care sunt numere prime şi mai mici de n. \/\/ Implementarea unei funcții care ia un întreg non-negativ și returnează o serie de primele n \/\/\/ >>> count_up_to(n: 5)\n\/\/\/ [2, 3]\n\/\/\/ >>> count_up_to(n: 11)\n\/\/\/ [2, 3, 5, 7]\n\/\/\/ >>> count_up_to(n: 0)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 20)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(n: 1)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 18)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunc count_up_to(n: Int) -> [Int] {\n","canonical_solution":"func count_up_to(n: Int) -> [Int] {\n    guard n > 2 else { return [] }\n    \n    var primes: [Int] = [2]\n    \n    for number in 3..<n {\n        var isPrime = true\n        for prime in primes {\n            if prime * prime > number {\n                break\n            }\n            if number % prime == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes.append(number)\n        }\n    }\n    \n    return primes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_up_to(n: 5) == [2, 3])\nassert(count_up_to(n: 6) == [2, 3, 5])\nassert(count_up_to(n: 7) == [2, 3, 5])\nassert(count_up_to(n: 10) == [2, 3, 5, 7])\nassert(count_up_to(n: 0) == [] as [Int])\nassert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])\nassert(count_up_to(n: 1) == [] as [Int])\nassert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])\nassert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\nassert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"},{"task_id":"HumanEval_97","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Presupunem că inputul este întotdeauna valid. \/\/ produsul cifrelor lor unitate. \/\/ Completează funcția care ia două numere întregi și returnează \/\/\/ >>> multiply(a: 148, b: 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(a: 19, b: 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(a: 2020, b: 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(a: 14, b: -15)\n\/\/\/ 20\nfunc multiply(a: Int, b: Int) -> Int {\n","canonical_solution":"func multiply(a: Int, b: Int) -> Int {\n    let unitDigitA = abs(a % 10)\n    let unitDigitB = abs(b % 10)\n    return unitDigitA * unitDigitB\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply(a: 148, b: 412) == 16)\nassert(multiply(a: 19, b: 28) == 72)\nassert(multiply(a: 2020, b: 1851) == 0)\nassert(multiply(a: 14, b: -15) == 20)\nassert(multiply(a: 76, b: 67) == 42)\nassert(multiply(a: 17, b: 27) == 49)\nassert(multiply(a: 0, b: 1) == 0)\nassert(multiply(a: 0, b: 0) == 0)"},{"task_id":"HumanEval_98","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Având în vedere un șir s, numără numărul de vocale mari în indici par. \/\/\/ >>> count_upper(s: \"aBCdEf\")\n\/\/\/ 1\n\/\/\/ >>> count_upper(s: \"abcdefg\")\n\/\/\/ 0\n\/\/\/ >>> count_upper(s: \"dBBE\")\n\/\/\/ 0\nfunc count_upper(s: String) -> Int {\n","canonical_solution":"func count_upper(s: String) -> Int {\n    let upperVowels = Set<Character>([\"A\", \"E\", \"I\", \"O\", \"U\"])\n    var count = 0\n\n    for (index, char) in s.enumerated() {\n        if index % 2 == 0 && upperVowels.contains(char) {\n            count += 1\n        }\n    }\n\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"},{"task_id":"HumanEval_99","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple \/\/ din două numere întregi, rotunjește-l departe de zero. \/\/ şi returnează cel mai apropiat număr întreg.\/\/ Crearea unei funcţii care ia o valoare (string) reprezentând un număr \/\/\/ >>> closest_integer(value: \"10\")\n\/\/\/ 10\n\/\/\/ >>> closest_integer(value: \"15.3\")\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n","canonical_solution":"func closest_integer(value: String) -> Int {\n    if let number = Double(value) {\n        return Int(number.rounded(.awayFromZero))\n    }\n    return 0 \/\/ or handle error as needed\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"},{"task_id":"HumanEval_100","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ i reprezintă numărul de pietre din nivel (i+1). \/\/ Returnează numărul de pietre în fiecare nivel într-o matrice, unde elementul la index \/\/ - următorul număr par dacă n este par. \/\/ - următorul număr impar dacă n este impar. \/\/ Numărul de pietre în următorul nivel este: \/\/ Primul nivel are n pietre. \/\/ Având un număr întreg pozitiv n, trebuie să faci o grămadă de n niveluri de pietre. \/\/\/ >>> make_a_pile(n: 3)\n\/\/\/ [3, 5, 7]\nfunc make_a_pile(n: Int) -> [Int] {\n","canonical_solution":"func make_a_pile(n: Int) -> [Int] {\n    var pile = [Int]()\n    var currentLevelStones = n\n    \n    for _ in 0..<n {\n        pile.append(currentLevelStones)\n        if n % 2 == 0 {\n            currentLevelStones += 2\n        } else {\n            currentLevelStones += 2\n        }\n    }\n    \n    return pile\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n: 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"},{"task_id":"HumanEval_101","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ pentru a împărți șirul în cuvinte și a returna o serie de cuvinte. \/\/ Va fi dat un șir de cuvinte separate cu virgule sau spații.\/\/\/ >>> words_string(s: \"Hi, my name is John\")\n\/\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/\/ >>> words_string(s: \"One, two, three, four, five, six\")\n\/\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunc words_string(s: String) -> [String] {\n","canonical_solution":"func words_string(s: String) -> [String] {\n    let separators = CharacterSet(charactersIn: \", \")\n    return s.components(separatedBy: separators).filter { !$0.isEmpty }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_string(s: \"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\nassert(words_string(s: \"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"Hi, my name\") == [\"Hi\", \"my\", \"name\"])\nassert(words_string(s: \"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"\") == [] as [String])\nassert(words_string(s: \"ahmed     , gamal\") == [\"ahmed\", \"gamal\"])"},{"task_id":"HumanEval_102","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ nu există un astfel de număr, atunci funcția ar trebui să returneze -1. \/\/ cel mai mare număr par care este în intervalul [x, y] inclusiv.\/\/ Această funcție ia două numere pozitive x și y și returnează \/\/\/ >>> choose_num(x: 12, y: 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(x: 13, y: 12)\n\/\/\/ -1\nfunc choose_num(x: Int, y: Int) -> Int {\n","canonical_solution":"func choose_num(x: Int, y: Int) -> Int {\n    \/\/ Determine the starting and ending range values\n    let start = min(x, y)\n    let end = max(x, y)\n    \n    \/\/ Iterate from the end of the range to the start\n    for num in (start...end).reversed() {\n        \/\/ Check if the current number is even\n        if num % 2 == 0 {\n            return num\n        }\n    }\n    \n    \/\/ Return -1 if no even number is found\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(choose_num(x: 12, y: 15) == 14)\nassert(choose_num(x: 13, y: 12) == -1)\nassert(choose_num(x: 33, y: 12354) == 12354)\nassert(choose_num(x: 5234, y: 5233) == -1)\nassert(choose_num(x: 6, y: 29) == 28)\nassert(choose_num(x: 27, y: 10) == -1)\nassert(choose_num(x: 7, y: 7) == -1)\nassert(choose_num(x: 546, y: 546) == 546)"},{"task_id":"HumanEval_103","nl":"ron_Latn","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ Exemplu: \/\/ Dacă n este mai mare decât m, returnăm -1. \/\/ rotunjeşte răspunsul la cel mai apropiat număr întreg şi convertează-l în binar. \/\/ media întregilor de la n la m (inclusiv n și m). \/\/ Ai două numere întregi pozitive n şi m, şi sarcina ta este să calculezi \/\/\/ >>> rounded_avg(n: 1, m: 5)\n\/\/\/ .success(\"0b11\")\n\/\/\/ >>> rounded_avg(n: 7, m: 5)\n\/\/\/ .failure(-1)\n\/\/\/ >>> rounded_avg(n: 10, m: 20)\n\/\/\/ .success(\"0b1111\")\n\/\/\/ >>> rounded_avg(n: 20, m: 33)\n\/\/\/ .success(\"0b11010\")\nfunc rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n","canonical_solution":"func rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n    if n > m {\n        return .failure(-1)\n    }\n    \n    let count = m - n + 1\n    let sum = (n + m) * count \/ 2\n    let average = Double(sum) \/ Double(count)\n    let roundedAverage = Int(average.rounded())\n    let binaryString = String(roundedAverage, radix: 2)\n    \n    return .success(\"0b\" + binaryString)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rounded_avg(n: 1, m: 5) == .success(\"0b11\"))\nassert(rounded_avg(n: 7, m: 13) == .success(\"0b1010\"))\nassert(rounded_avg(n: 964, m: 977) == .success(\"0b1111001010\"))\nassert(rounded_avg(n: 996, m: 997) == .success(\"0b1111100100\"))\nassert(rounded_avg(n: 560, m: 851) == .success(\"0b1011000010\"))\nassert(rounded_avg(n: 185, m: 546) == .success(\"0b101101110\"))\nassert(rounded_avg(n: 362, m: 496) == .success(\"0b110101101\"))\nassert(rounded_avg(n: 350, m: 902) == .success(\"0b1001110010\"))\nassert(rounded_avg(n: 197, m: 233) == .success(\"0b11010111\"))\nassert(rounded_avg(n: 7, m: 5) == .failure(-1))\nassert(rounded_avg(n: 5, m: 1) == .failure(-1))\nassert(rounded_avg(n: 5, m: 5) == .success(\"0b101\"))"},{"task_id":"HumanEval_104","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Nota: matricea returnată trebuie să fie sortată în ordine crescândă. \/\/ elemente care nu au nici o cifră par. \/\/ Având în vedere o serie de numere întregi pozitive x. returnează o serie sortată a tuturor numărului de numere întregi x.\/\/\/ >>> unique_digits(x: [15, 33, 1422, 1])\n\/\/\/ [1, 15, 33]\n\/\/\/ >>> unique_digits(x: [152, 323, 1422, 10])\n\/\/\/ [] as [Int]\nfunc unique_digits(x: [Int]) -> [Int] {\n","canonical_solution":"func unique_digits(x: [Int]) -> [Int] {\n    return x.filter { number in\n        var hasEvenDigit = false\n        var num = number\n        while num > 0 {\n            if (num % 10) % 2 == 0 {\n                hasEvenDigit = true\n                break\n            }\n            num \/= 10\n        }\n        return !hasEvenDigit\n    }.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])\nassert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])\nassert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])\nassert(unique_digits(x: [135, 103, 31]) == [31, 135])"},{"task_id":"HumanEval_105","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:Unu, doi, trei, patru, cinci, şase, şapte, opt, nouă.\/\/ inversează matricea rezultată, apoi înlocuiește fiecare cifră cu numele corespunzător din \/\/ Având în vedere o serie de numere întregi, sortați numerele întregi care sunt între 1 și 9 inclusiv, \/\/\/ >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/\/ If the array is empty, return an empty array:\n\/\/\/ >>> by_length(arr: [] as [Int])\n\/\/\/ [] as [String]\n\/\/\/ If the array has any strange number ignore it:\n\/\/\/ >>> by_length(arr: [1, -1, 55])\n\/\/\/ [\"One\"]\nfunc by_length(arr: [Int]) -> [String] {\n","canonical_solution":"func by_length(arr: [Int]) -> [String] {\n    let numberNames: [Int: String] = [\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    ]\n    \n    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }\n                                           .sorted(by: >)\n    \n    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? \"\" }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\nassert(by_length(arr: [] as [Int]) == [] as [String])\nassert(by_length(arr: [1, -1, 55]) == [\"One\"])\nassert(by_length(arr: [1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\nassert(by_length(arr: [9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])"},{"task_id":"HumanEval_106","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ factorialul lui i este multiplicarea numerelor de la 1 la i (1 * 2 * ... * i). \/\/ i începe de la 1. \/\/ sau suma numerelor de la 1 la i altfel. \/\/ și returnează un șir de dimensiune n, astfel încât valoarea elementului la indexul i este factorialul lui i dacă i este par.\/\/ Implementarea funcției f care ia n ca parametru, \/\/\/ >>> f(n: 5)\n\/\/\/ [1, 2, 6, 24, 15]\nfunc f(n: Int) -> [Int] {\n","canonical_solution":"func f(n: Int) -> [Int] {\n    func factorial(_ x: Int) -> Int {\n        guard x > 1 else { return 1 }\n        return (1...x).reduce(1, *)\n    }\n    \n    func sumTo(_ x: Int) -> Int {\n        return (1...x).reduce(0, +)\n    }\n    \n    var result = [Int]()\n    for i in 1...n {\n        if i % 2 == 0 {\n            result.append(factorial(i))\n        } else {\n            result.append(sumTo(i))\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 5) == [1, 2, 6, 24, 15])\nassert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])\nassert(f(n: 1) == [1])\nassert(f(n: 3) == [1, 2, 6])"},{"task_id":"HumanEval_107","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu 1: \/\/ palindromii întregi care se încadrează în intervalul ((1, n), inclusiv. \/\/ Având un întreg pozitiv n, returnăm un tuple care are numărul de impar și par \/\/\/ >>> even_odd_palindrome(n: 3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(n: 12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_palindrome(n: Int) -> (Int, Int) {\n    func isPalindrome(_ num: Int) -> Bool {\n        let str = String(num)\n        return str == String(str.reversed())\n    }\n    \n    var evenCount = 0\n    var oddCount = 0\n    \n    for i in 1...n {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n                evenCount += 1\n            } else {\n                oddCount += 1\n            }\n        }\n    }\n    \n    return (evenCount, oddCount)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_palindrome(n: 123) == (8, 13))\nassert(even_odd_palindrome(n: 12) == (4, 6))\nassert(even_odd_palindrome(n: 3) == (1, 2))\nassert(even_odd_palindrome(n: 63) == (6, 8))\nassert(even_odd_palindrome(n: 25) == (5, 6))\nassert(even_odd_palindrome(n: 19) == (4, 6))\nassert(even_odd_palindrome(n: 9) == (4, 5))\nassert(even_odd_palindrome(n: 1) == (0, 1))"},{"task_id":"HumanEval_108","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ de exemplu -123 are semnele cifrelor -1, 2 şi 3. \/\/ Dacă un număr este negativ, atunci prima sa cifră semnată va fi negativă: \/\/ numărul de elemente care au o sumă de cifre > 0. \/\/ Scrieți o funcție count_nums care ia o serie de numere întregi și returnează \/\/\/ >>> count_nums(arr: [] as [Int])\n\/\/\/ 0\n\/\/\/ >>> count_nums(arr: [-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(arr: [1, 1, 2])\n\/\/\/ 3\nfunc count_nums(arr: [Int]) -> Int {\n","canonical_solution":"func count_nums(arr: [Int]) -> Int {\n    return arr.filter { number in\n        var n = number\n        var sumOfDigits = 0\n\n        while n != 0 {\n            sumOfDigits += n % 10\n            n \/= 10\n        }\n\n        return sumOfDigits > 0\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_nums(arr: [] as [Int]) == 0)\nassert(count_nums(arr: [-1, -2, 0]) == 0)\nassert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)\nassert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)\nassert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)\nassert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)\nassert(count_nums(arr: [0, 1]) == 1)\nassert(count_nums(arr: [1]) == 1)"},{"task_id":"HumanEval_109","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ De exemplu: \/\/ Nota: Array-ul dat are garantat elemente unice. \/\/ Dacă tabla dată este goală, atunci returnăm true. \/\/ atunci returnează true altfel returnează false. \/\/ Dacă este posibil să obțineți matricea sortată prin efectuarea operațiunii de mai sus \/\/ poziția de început în matriță, adică indicele 0. Ultimul element al matricei va fi mutat la \/\/ O operaţie de deplasare la dreapta înseamnă deplasarea tuturor elementelor matricei cu unul.\/\/ Ai voie să efectuezi operaţia de deplasare la dreapta de orice număr de ori. \/\/ următoarea operaţiune pe matricea dată: \/\/ este posibil să obțineți o matrice sortată în ordine necurgătoare prin efectuarea \/\/ numerele din matrice vor fi ordonate aleatoriu.\/\/ Avem o matrice \"arr\" de N de numere întregi arr[1], arr[2], ..., arr[N].\/\/\/ >>> move_one_ball(arr: [3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given array.\n\/\/\/ >>> move_one_ball(arr: [3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ array by performing any number of right shift operations.\nfunc move_one_ball(arr: [Int]) -> Bool {\n","canonical_solution":"func move_one_ball(arr: [Int]) -> Bool {\n    guard !arr.isEmpty else { return true }\n    \n    let n = arr.count\n    var breakPointCount = 0\n    \n    \/\/ Find the number of break points where the array is decreasing\n    for i in 0..<n {\n        if arr[i] > arr[(i + 1) % n] {\n            breakPointCount += 1\n        }\n    }\n    \n    \/\/ If there's at most one break point, the array can be right shifted\n    return breakPointCount <= 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)\nassert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)\nassert(move_one_ball(arr: [4, 3, 1, 2]) == false)\nassert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)\nassert(move_one_ball(arr: [] as [Int]) == true)"},{"task_id":"HumanEval_110","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Altfel, returnează \"NO\". \/\/ toate elementele de lst1 să fie chiar, returnă \"DA\". \/\/ Dacă este posibil să schimbe elementele între lst1 și lst2 pentru a face \/\/ Nu există nicio limită pentru numărul de elemente schimbate între lst1 și lst2. \/\/ între ele pentru a face lst1 un matrice de numai numere pereche. \/\/ și determină dacă este posibil să se efectueze un schimb de elemente \/\/ În această problemă, vei implementa o funcție care ia două matrice de numere, \/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])\n\/\/\/ \"YES\"\n\/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])\n\/\/\/ \"NO\"\n\/\/\/ It is assumed that the input arrays will be non-empty.\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n","canonical_solution":"func exchange(lst1: [Int], lst2: [Int]) -> String {\n    var hasOddInLst1 = false\n    var hasEvenInLst2 = false\n    \n    for num in lst1 {\n        if num % 2 != 0 {\n            hasOddInLst1 = true\n            break\n        }\n    }\n    \n    for num in lst2 {\n        if num % 2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasOddInLst1 {\n        return \"YES\"\n    }\n    \n    if hasEvenInLst2 {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == \"YES\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == \"NO\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == \"NO\")\nassert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == \"NO\")\nassert(exchange(lst1: [100, 200], lst2: [200, 200]) == \"YES\")"},{"task_id":"HumanEval_111","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ Dacă mai multe litere au aceeași apariție, returnăm toate. \/\/ a literei cu cea mai mare repetare și care conține numărul corespunzător. \/\/ Având în vedere un șir care reprezintă un spațiu separat de litere minuscule, returnăm un dicționar \/\/\/ >>> histogram(test: \"a b c\")\n\/\/\/ [\"a\" : 1, \"b\" : 1, \"c\" : 1]\n\/\/\/ >>> histogram(test: \"a b b a\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"a b c a b\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"b b b b a\")\n\/\/\/ [\"b\" : 4]\n\/\/\/ >>> histogram(test: \"\")\n\/\/\/ [:] as [String : Int]\nfunc histogram(test: String) -> [String : Int] {\n","canonical_solution":"func histogram(test: String) -> [String : Int] {\n    var letterCount: [String: Int] = [:]\n\n    \/\/ Split the string into an array of letters\n    let letters = test.split(separator: \" \").map { String($0) }\n\n    \/\/ Count occurrences of each letter\n    for letter in letters {\n        letterCount[letter, default: 0] += 1\n    }\n\n    \/\/ Determine the maximum number of occurrences\n    guard let maxCount = letterCount.values.max() else {\n        return [:] as [String : Int]\n    }\n\n    \/\/ Filter the letterCount dictionary to only include letters with the max count\n    let result = letterCount.filter { $0.value == maxCount }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"},{"task_id":"HumanEval_112","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu \/\/ Ar trebui să returnezi un tupul care conține stringul de rezultat și true\/false pentru verificare. \/\/ Un șir este numit palindrom dacă se citește la fel înapoi ca înainte. \/\/ apoi verificați dacă stringul rezultat este palindrom. \/\/ Avem două șiruri de caracter s și c, trebuie să ștergem toate caractere din s care sunt egale cu orice caracter din c \/\/ Sarcina \/\/\/ >>> reverse_delete(s: \"abcde\", c: \"ae\")\n\/\/\/ (\"bcd\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdef\", c: \"b\")\n\/\/\/ (\"acdef\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdedcba\", c: \"ab\")\n\/\/\/ (\"cdedc\", true)\nfunc reverse_delete(s: String, c: String) -> (String, Bool) {\n","canonical_solution":"func reverse_delete(s: String, c: String) -> (String, Bool) {\n    \/\/ Remove characters from s that are in c\n    let filteredString = s.filter { !c.contains($0) }\n    \n    \/\/ Check if the resulting string is a palindrome\n    let isPalindrome = filteredString == String(filteredString.reversed())\n    \n    \/\/ Return the resulting string and the palindrome check result\n    return (filteredString, isPalindrome)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_delete(s: \"abcde\", c: \"ae\") == (\"bcd\", false))\nassert(reverse_delete(s: \"abcdef\", c: \"b\") == (\"acdef\", false))\nassert(reverse_delete(s: \"abcdedcba\", c: \"ab\") == (\"cdedc\", true))\nassert(reverse_delete(s: \"dwik\", c: \"w\") == (\"dik\", false))\nassert(reverse_delete(s: \"a\", c: \"a\") == (\"\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"v\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"vabba\", c: \"v\") == (\"abba\", true))\nassert(reverse_delete(s: \"mamma\", c: \"mia\") == (\"\", true))"},{"task_id":"HumanEval_113","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ de cifre impar în i'th string de intrare. \/\/ string i de intrare. \" unde toate i ar trebui să fie înlocuite cu numărul \/\/ Fiecare element i al rezultatului ar trebui să fie \"numărul de elemente impar în \/\/ Având în vedere o serie de stringuri, în care fiecare string este format doar din cifre, returnăm o serie. \/\/\/ >>> odd_count(lst: [\"1234567\"])\n\/\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/\/ >>> odd_count(lst: [\"3\", \"11111111\"])\n\/\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunc odd_count(lst: [String]) -> [String] {\n","canonical_solution":"func odd_count(lst: [String]) -> [String] {\n    return lst.map { str in\n        let oddCount = str.filter { \"13579\".contains($0) }.count\n        return \"the number of odd elements \\(oddCount)n the str\\(oddCount)ng \\(oddCount) of the \\(oddCount)nput.\"\n    }\n}\n\n\/\/ Example Usage\nprint(odd_count(lst: [\"1234567\"]))\nprint(odd_count(lst: [\"3\", \"11111111\"]))","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_count(lst: [\"1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\nassert(odd_count(lst: [\"3\", \"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\nassert(odd_count(lst: [\"271\", \"137\", \"314\"]) == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])"},{"task_id":"HumanEval_114","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu - De numere.\/\/ Având în vedere o serie de numere întregi, găsiți suma minimă a oricărei sub-mărgini ne-goale \/\/\/ >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(nums: [-1, -2, -3])\n\/\/\/ -6\nfunc minSubArraySum(nums: [Int]) -> Int {\n","canonical_solution":"func minSubArraySum(nums: [Int]) -> Int {\n    guard !nums.isEmpty else { return 0 }\n    \n    var currentMin = nums[0]\n    var overallMin = nums[0]\n    \n    for i in 1..<nums.count {\n        currentMin = min(nums[i], currentMin + nums[i])\n        overallMin = min(overallMin, currentMin)\n    }\n    \n    return overallMin\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)\nassert(minSubArraySum(nums: [-1, -2, -3]) == -6)\nassert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)\nassert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)\nassert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)\nassert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)\nassert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)\nassert(minSubArraySum(nums: [-10]) == -10)\nassert(minSubArraySum(nums: [7]) == 7)\nassert(minSubArraySum(nums: [1, -1]) == -1)"},{"task_id":"HumanEval_115","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu 1: \/\/ Exprimă numărul de ori trebuie să se scadă găleți. \/\/ Sarcina ta este de a folosi găleţile pentru a goli fântânile.\/\/ şi toate găleţile au aceeaşi capacitate. \/\/ Fiecare fântână are o găleată corespunzătoare care poate fi folosită pentru a extrage apă din ea, \/\/ şi fiecare 1 într-un rând reprezintă o singură unitate de apă. \/\/ Ai o grila dreptunghiulara de puturi. Fiecare rand reprezinta o singura put, \/\/\/ >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n","canonical_solution":"func max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var totalWater = 0\n    for row in grid {\n        for unit in row {\n            if unit == 1 {\n                totalWater += 1\n            }\n        }\n    }\n    return (totalWater + capacity - 1) \/ capacity\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"},{"task_id":"HumanEval_116","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Trebuie implementat astfel: \/\/ Pentru un număr similar de unu, sortaţi pe baza valorii decimale. \/\/ numărul de unu în reprezentarea lor binară în ordine ascendentă. \/\/ În acest Kata, trebuie să sortați o serie de numere întregi non-negative în funcție de \/\/\/ >>> sort_array(arr: [1, 5, 2, 3, 4])\n\/\/\/ [1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(arr: [-2, -3, -4, -5, -6])\n\/\/\/ [-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(arr: [1, 0, 2, 3, 4])\n\/\/\/ [0, 1, 2, 3, 4]\nfunc sort_array(arr: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted {\n        let onesCount1 = $0.nonNegativeOnesCount()\n        let onesCount2 = $1.nonNegativeOnesCount()\n        return (onesCount1, $0) < (onesCount2, $1)\n    }\n}\n\nextension Int {\n    func nonNegativeOnesCount() -> Int {\n        return self < 0 ? 0 : self.nonBitCount()\n    }\n    \n    private func nonBitCount() -> Int {\n        var count = 0\n        var num = self\n        while num > 0 {\n            count += num & 1\n            num >>= 1\n        }\n        return count\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"},{"task_id":"HumanEval_117","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Nota: se poate presupune că stringul de intrare conține numai litere și spații. \/\/ Dacă stringul s este gol, atunci funcția ar trebui să returneze o matrice goală. \/\/ n consoane, în ordinea în care aceste cuvinte apar în string s. \/\/ o funcție care returnează un șir de cuvinte din string s care conțin exact \/\/ Având în vedere un șir s și un număr natural n, ai fost însărcinat să implementeze \/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 4)\n\/\/\/ [\"little\"]\n\/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 3)\n\/\/\/ [\"Mary\", \"lamb\"]\n\/\/\/ >>> select_words(s: \"simple white space\", n: 2)\n\/\/\/ [] as [String]\n\/\/\/ >>> select_words(s: \"Hello world\", n: 4)\n\/\/\/ [\"world\"]\n\/\/\/ >>> select_words(s: \"Uncle sam\", n: 3)\n\/\/\/ [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n","canonical_solution":"func select_words(s: String, n: Int) -> [String] {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    let words = s.split(separator: \" \")\n    var result: [String] = []\n    \n    for word in words {\n        let consonantCount = word.filter { !vowels.contains($0) }.count\n        if consonantCount == n {\n            result.append(String(word))\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"},{"task_id":"HumanEval_118","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ Puteți presupune că șirul dat conține numai litera engleză. \/\/ găsi orice vocală îndeplinit condiția de mai sus. \/\/ Vocalele de la început şi de la sfârşit nu se numără.\/\/ două consoane din partea dreaptă a cuvântului (delimitate de majuscule).\/\/ Ai un cuvânt. sarcina ta este să găseşti cea mai apropiată vocală care stă între \/\/\/ >>> get_closest_vowel(word: \"yogurt\")\n\/\/\/ \"u\"\n\/\/\/ >>> get_closest_vowel(word: \"FULL\")\n\/\/\/ \"U\"\n\/\/\/ >>> get_closest_vowel(word: \"quick\")\n\/\/\/ \"\"\n\/\/\/ >>> get_closest_vowel(word: \"ab\")\n\/\/\/ \"\"\nfunc get_closest_vowel(word: String) -> String {\n","canonical_solution":"func get_closest_vowel(word: String) -> String {\n    let vowels = Set(\"aeiouAEIOU\")\n    var foundVowel: Character? = nil\n    \n    for i in stride(from: word.count - 2, through: 1, by: -1) {\n        let currentIndex = word.index(word.startIndex, offsetBy: i)\n        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)\n        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)\n        \n        if vowels.contains(word[currentIndex]) && \n            !vowels.contains(word[previousIndex]) && \n            !vowels.contains(word[nextIndex]) {\n            foundVowel = word[currentIndex]\n            break\n        }\n    }\n    \n    return foundVowel != nil ? String(foundVowel!) : \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"},{"task_id":"HumanEval_119","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Returnează \"Da\" dacă există o modalitate de a face un șir bun, și returnează \"Nu\" în caz contrar. \/\/ \"()) \" nu este. De exemplu: stringul \"(()))))) \" este bun, în timp ce stringul \/\/ Un șir S este considerat bun dacă și numai dacă toate parantezele din S \/\/ un anumit ordin, că rezultatul string va fi bun. \/\/ Treaba ta este să verifici dacă este posibil să concatenăm cele două șiruri în \/\/ numai parantezele \" ((\" sau parantezele de închidere \")) \". \/\/ Ai o matrice de două șiruri, ambele șiruri sunt deschise.\/\/\/ >>> match_parens(lst: [\"()(\", \")\"])\n\/\/\/ \"Yes\"\n\/\/\/ >>> match_parens(lst: [\")\", \")\"])\n\/\/\/ \"No\"\nfunc match_parens(lst: [String]) -> String {\n","canonical_solution":"func match_parens(lst: [String]) -> String {\n    let combined1 = lst[0] + lst[1]\n    let combined2 = lst[1] + lst[0]\n    \n    func isBalanced(_ s: String) -> Bool {\n        var balance = 0\n        for char in s {\n            if char == \"(\" {\n                balance += 1\n            } else if char == \")\" {\n                balance -= 1\n            }\n            if balance < 0 {\n                return false\n            }\n        }\n        return balance == 0\n    }\n    \n    if isBalanced(combined1) || isBalanced(combined2) {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")"},{"task_id":"HumanEval_120","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu 1: \/\/ de lungime k cu numărul maxim k în arr. \/\/ Având în vedere o serie de numere întregi arr și un număr întreg pozitiv k, returnează o serie sortată \/\/\/ >>> maximum(arr: [-3, -4, 5], k: 3)\n\/\/\/ [-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(arr: [4, -4, 4], k: 2)\n\/\/\/ [4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\n\/\/\/ [2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n","canonical_solution":"func maximum(arr: [Int], k: Int) -> [Int] {\n    guard k > 0 else { return [] }\n    let sortedArr = arr.sorted(by: >)\n    let maxElements = Array(sortedArr.prefix(k))\n    return maxElements.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"},{"task_id":"HumanEval_121","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple \/\/ Având în vedere o serie de integeruri ne-goale, returnăm suma tuturor elementelor impar care sunt în poziții pereche. \/\/\/ >>> solution(lst: [5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(lst: [3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(lst: [30, 13, 24, 321])\n\/\/\/ 0\nfunc solution(lst: [Int]) -> Int {\n","canonical_solution":"func solution(lst: [Int]) -> Int {\n    var sum = 0\n    for (index, value) in lst.enumerated() {\n        if index % 2 == 0 && value % 2 != 0 {\n            sum += value\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solution(lst: [5, 8, 7, 1]) == 12)\nassert(solution(lst: [3, 3, 3, 3, 3]) == 9)\nassert(solution(lst: [30, 13, 24, 321]) == 0)\nassert(solution(lst: [5, 9]) == 5)\nassert(solution(lst: [2, 4, 8]) == 0)\nassert(solution(lst: [30, 13, 23, 32]) == 23)\nassert(solution(lst: [3, 13, 2, 9]) == 3)"},{"task_id":"HumanEval_122","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ suma elementelor cu cel mult două cifre din primele k elemente ale lui arr. \/\/ Având în vedere o serie ne-goală de numere întregi arr și un număr întreg k, returnăm \/\/\/ >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr: [Int], k: Int) -> Int {\n","canonical_solution":"func add_elements(arr: [Int], k: Int) -> Int {\n    var sum = 0\n    for i in 0..<k {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)\nassert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)\nassert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)\nassert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)\nassert(add_elements(arr: [1], k: 1) == 1)"},{"task_id":"HumanEval_123","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ get_odd_collatz(5) returnează [1, 5] # Secvența collatz pentru 5 este [5, 16, 8, 4, 2, 1], deci numerele impar sunt doar 1 și 5. De exemplu:\/\/ 2. a returnat matricea sortată în ordine crescândă. \/\/ 1. Collatz(1) este [1]. \/\/ Nota: \/\/ termen plus 1. conjectura este că indiferent de ce valoare a lui n, secvența va ajunge întotdeauna la 1. Dacă termenul precedent este impar, termenul următor este de 3 ori cel anterior.\/\/ termenul precedent, după cum urmează: dacă termenul precedent este par, termenul următor este jumătate din \/\/ după cum urmează: începe cu orice număr întreg pozitiv n. Apoi fiecare termen este obținut din \/\/ Conjectura Collatz este o conjectură în matematică care se referă la o secvență definită \/\/ Având în vedere un întreg pozitiv n, returnează un tablou sortat care are numerele impar în secvența collatz. \/\/\/ >>> get_odd_collatz(n: 5)\n\/\/\/ [1, 5]\nfunc get_odd_collatz(n: Int) -> [Int] {\n","canonical_solution":"func get_odd_collatz(n: Int) -> [Int] {\n    var collatzSequence: [Int] = []\n    var number = n\n\n    while number != 1 {\n        if number % 2 != 0 {\n            collatzSequence.append(number)\n        }\n        if number % 2 == 0 {\n            number \/= 2\n        } else {\n            number = 3 * number + 1\n        }\n    }\n\n    collatzSequence.append(1) \/\/ append 1 as the sequence ends at 1\n\n    let sortedOdds = collatzSequence.sorted()\n    \n    return sortedOdds\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"},{"task_id":"HumanEval_124","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ 4. data trebuie să fie în formatul: mm-dd-aaaa \/\/ 3. lunile nu trebuie să fie mai mici de 1 sau mai mari de 12. Numărul de zile nu este mai mic de 1 sau mai mare de 31 de zile pentru lunile 1,3,5,7,8,10,12 şi numărul de zile nu este mai mic de 1 sau mai mare de 30 de zile pentru lunile 4,6,9,11.\/\/ 1. Stringul de date nu este gol. \/\/ Data este valabilă dacă sunt îndeplinite toate regulile următoare: \/\/ returnează adevărat dacă data este validă, în caz contrar falsă. \/\/ Trebuie să scrii o funcţie care validează un anumit şir de date şi \/\/\/ >>> valid_date(date: \"03-11-2000\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"15-01-2012\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"04-0-2040\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"06-04-2020\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"06\/04\/2020\")\n\/\/\/ false\nfunc valid_date(date: String) -> Bool {\n","canonical_solution":"func valid_date(date: String) -> Bool {\n    \/\/ Check if the date is empty\n    if date.isEmpty {\n        return false\n    }\n    \n    \/\/ Split the date into components using the \"-\" delimiter\n    let components = date.split(separator: \"-\")\n    \n    \/\/ Ensure the date has exactly three components\n    if components.count != 3 {\n        return false\n    }\n    \n    \/\/ Ensure the date components are integers\n    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {\n        return false\n    }\n    \n    \/\/ Check if the month is within the valid range\n    if month < 1 || month > 12 {\n        return false\n    }\n    \n    \/\/ Define the number of days in each month\n    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    \/\/ Check the day range for each month\n    if day < 1 || day > daysInMonth[month] {\n        return false\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(valid_date(date: \"03-11-2000\") == true)\nassert(valid_date(date: \"15-01-2012\") == false)\nassert(valid_date(date: \"04-0-2040\") == false)\nassert(valid_date(date: \"06-04-2020\") == true)\nassert(valid_date(date: \"01-01-2007\") == true)\nassert(valid_date(date: \"03-32-2011\") == false)\nassert(valid_date(date: \"\") == false)\nassert(valid_date(date: \"04-31-3000\") == false)\nassert(valid_date(date: \"06-06-2005\") == true)\nassert(valid_date(date: \"21-31-2000\") == false)\nassert(valid_date(date: \"04-12-2003\") == true)\nassert(valid_date(date: \"04122003\") == false)\nassert(valid_date(date: \"20030412\") == false)\nassert(valid_date(date: \"2003-04\") == false)\nassert(valid_date(date: \"2003-04-12\") == false)\nassert(valid_date(date: \"04-2003\") == false)"},{"task_id":"HumanEval_125","nl":"ron_Latn","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ Exemple \/\/ alfabetul, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 \/\/ ar trebui să fie împărțit pe virgule ',' dacă nu există virgule ar trebui să returneze numărul de litere mici cu ordine impar în \/\/ Având în vedere un șir de cuvinte, returnează o matrice de cuvinte împărțite pe spații libere, dacă nu există spații libere în textul pe care îl doriți.\/\/\/ >>> split_words(txt: \"Hello world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"Hello,world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"abcdef\")\n\/\/\/ .failure(3)\nfunc split_words(txt: String) -> Result<[String], Int> {\n","canonical_solution":"func split_words(txt: String) -> Result<[String], Int> {\n    if txt.contains(\" \") {\n        let words = txt.split(separator: \" \").map { String($0) }\n        return .success(words)\n    } else if txt.contains(\",\") {\n        let words = txt.split(separator: \",\").map { String($0) }\n        return .success(words)\n    } else {\n        let oddOrderedLowerCaseLetters = txt.filter { char in\n            if let asciiValue = char.asciiValue {\n                let order = asciiValue - Character(\"a\").asciiValue!\n                return order % 2 == 1\n            }\n            return false\n        }\n        return .failure(oddOrderedLowerCaseLetters.count)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"},{"task_id":"HumanEval_126","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple \/\/ număr, returnă false. Presupunem că nu există numere negative și doar numere întregi. Dacă matricea are mai mult de un duplicat al aceleiasi matrici, atunci ar trebui să fie în ordine crescândă.\/\/ Având în vedere o serie de numere, returnăm dacă sunt sortate sau nu.\/\/\/ >>> is_sorted(lst: [5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfunc is_sorted(lst: [Int]) -> Bool {\n","canonical_solution":"func is_sorted(lst: [Int]) -> Bool {\n    guard !lst.isEmpty else { return true }\n\n    var previous = lst[0]\n    var duplicates = 0\n\n    for i in 1..<lst.count {\n        if lst[i] < previous {\n            return false\n        } else if lst[i] == previous {\n            duplicates += 1\n            if duplicates > 1 {\n                return false\n            }\n        } else {\n            duplicates = 0\n        }\n        previous = lst[i]\n    }\n\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"},{"task_id":"HumanEval_127","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ [input\/output] mostre: \/\/ Dacă cele două intervale nu se intersectează, returnează \"NO\". \/\/ în caz contrar, returnăm \"NO\". \/\/ Dacă lungimea intersecției este un număr prim, returnează \"DA\", \/\/ care lungimea sa este 1, care nu este un numar prim. \/\/ Exemplu, intersecția intervalurilor (1, 3), (2, 4) este (2, 3) \/\/ intervalele este un număr prim. \/\/ Sarcina ta este de a determina dacă lungimea intersecției dintre aceste două \/\/ Pentru fiecare interval dat, se presupune că începutul său este mai mic sau egal cu sfârșitul său. \/\/ include atât începutul cât şi sfârşitul. \/\/ Intervalele date sunt închise, ceea ce înseamnă că intervalul (început, sfârșit) De exemplu, intervalul = (început, sfârșit) = (1, 2).\/\/ Ai două intervale, \/\/\/ >>> intersection(interval1: (1, 2), interval2: (2, 3))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-1, 1), interval2: (0, 4))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-3, -1), interval2: (-5, 5))\n\/\/\/ \"YES\"\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n","canonical_solution":"func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n    \/\/ Helper function to determine if a number is prime\n    func isPrime(_ num: Int) -> Bool {\n        if num <= 1 {\n            return false\n        }\n        if num <= 3 {\n            return true\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false\n        }\n        var i = 5\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Find the start and end of the intersection\n    let intersectStart = max(interval1.0, interval2.0)\n    let intersectEnd = min(interval1.1, interval2.1)\n    \n    \/\/ Calculate the length of the intersection\n    let intersectionLength = intersectEnd - intersectStart\n\n    \/\/ Check if intersection length is positive and prime\n    if intersectionLength > 0 && isPrime(intersectionLength) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersection(interval1: (1, 2), interval2: (2, 3)) == \"NO\")\nassert(intersection(interval1: (-1, 1), interval2: (0, 4)) == \"NO\")\nassert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == \"YES\")\nassert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == \"YES\")\nassert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (3, 5)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (1, 2)) == \"NO\")\nassert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == \"NO\")"},{"task_id":"HumanEval_128","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ Nota: return nil pentru ar ar gol. \/\/ de fiecare număr din matricea, reprezentat de 1, -1 sau 0. \/\/ Suma magnitudinilor intregilor multiplicata cu produsul tuturor semnelor \/\/ Ai o serie de numere întregi şi trebuie să returnezi \/\/\/ >>> prod_signs(arr: [1, 2, 2, -4])\n\/\/\/ 9\n\/\/\/ >>> prod_signs(arr: [0, 1])\n\/\/\/ 0\n\/\/\/ >>> prod_signs(arr: [] as [Int])\n\/\/\/ nil\nfunc prod_signs(arr: [Int]) -> Int? {\n","canonical_solution":"func prod_signs(arr: [Int]) -> Int? {\n    \/\/ Return nil for empty array\n    if arr.isEmpty {\n        return nil\n    }\n\n    \/\/ Calculate the sum of magnitudes\n    let sumOfMagnitudes = arr.reduce(0) { sum, num in\n        return sum + abs(num)\n    }\n\n    \/\/ Calculate the product of all signs\n    let productOfSigns = arr.reduce(1) { product, num in\n        if num > 0 {\n            return product * 1\n        } else if num < 0 {\n            return product * -1\n        } else {\n            return 0\n        }\n    }\n\n    \/\/ Return the result of sum of magnitudes multiplied by product of signs\n    return sumOfMagnitudes * productOfSigns\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"},{"task_id":"HumanEval_129","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Returnează o matrice ordonată a valorilor din celulele prin care trece calea minimă. \/\/ Este garantat că răspunsul este unic. \/\/ lst_A[j] = lst_B[j]. \/\/ astfel încât lst_A[i] < lst_B[i] și pentru orice j (1 <= j < i) avem \/\/ decât lst_B, cu alte cuvinte, există un indice întreg i (1 <= i <= k) \/\/ prin (să le numim lst_A și lst_B), lst_A este lexicografic mai puțin \/\/ după ce a făcut matricele ordonate ale valorilor pe celulele care A și B merge \/\/ O cale A (de lungime k) este considerată mai mică decât o cale B (de lungime k) dacă Nu poţi să scapi de reţea.\/\/ necesar distincte). \/\/ Vă rugăm să rețineți că o cale de lungime k înseamnă vizita exact a k celule (nu \/\/ celula. \/\/ cu alte cuvinte, puteți merge la celule care împărtășesc o margine cu tine curent \/\/ din orice celulă, și în fiecare pas vă puteți muta la oricare dintre celulele vecine, Trebuie să găseşti drumul minim de lungime k în reţea.\/\/ inclusiv apare exact o dată pe celulele de rețea. \/\/ fiecare celulă din reţea conţine o valoare.\/\/ Având în vedere o rețea cu N rânduri și N coloane (N >= 2) și un număr întreg pozitiv k, \/\/\/ >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)\n\/\/\/ [1, 2, 1]\n\/\/\/ >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)\n\/\/\/ [1]\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n","canonical_solution":"func minPath(grid: [[Int]], k: Int) -> [Int] {\n    let n = grid.count\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    struct Path: Comparable {\n        let cells: [Int]\n        \n        static func < (lhs: Path, rhs: Path) -> Bool {\n            return lhs.cells.lexicographicallyPrecedes(rhs.cells)\n        }\n    }\n    \n    var minPath: Path? = nil\n    \n    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {\n        var currentPath = currentPath\n        currentPath.append(grid[x][y])\n        \n        if currentPath.count == k {\n            let newPath = Path(cells: currentPath)\n            if minPath == nil || newPath < minPath! {\n                minPath = newPath\n            }\n            return\n        }\n        \n        for direction in directions {\n            let newX = x + direction.0\n            let newY = y + direction.1\n            if newX >= 0 && newX < n && newY >= 0 && newY < n {\n                dfs(x: newX, y: newY, k: k, currentPath: currentPath)\n            }\n        }\n    }\n    \n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(x: i, y: j, k: k, currentPath: [])\n        }\n    }\n    \n    return minPath!.cells\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])\nassert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])\nassert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])\nassert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])\nassert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])\nassert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\nassert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\nassert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])\nassert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])\nassert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\nassert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"},{"task_id":"HumanEval_130","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ primele n + 1 numere ale secvenței Tribonacci. \/\/ Ai un număr întreg n, trebuie să returnezi un tablou de - 2 + 3 + 3 = 8 .\/\/ tri(3) = tri(2) + tri(1) + tri(4) \/\/ tri(4) = 3 \/\/ tri(2) = 1 + (2 \/ 2) = 2 De exemplu:\/\/ tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), dacă n este impar. \/\/ tri (n) = 1 + n \/ 2, dacă n este par. \/\/ tri(1) = 3 \/\/ Secvența Tribonacci este definită de recurența: Totuşi, ceea ce oamenii nu ştiu este secvenţa Tribonacci.Toată lumea cunoaşte secvenţa Fibonacci, a fost studiată profund de matematicieni în anii '90.\/\/\/ >>> tri(n: 3)\n\/\/\/ [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n","canonical_solution":"func tri(n: Int) -> [Int] {\n    guard n >= 0 else { return [] }\n    if n == 0 { return [1] }\n    if n == 1 { return [1, 3] }\n    if n == 2 { return [1, 3, 2] }\n    \n    var sequence = [1, 3, 2]\n    \n    for i in 3...n {\n        if i % 2 == 0 {\n            sequence.append(1 + i \/ 2)\n        } else {\n            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]\n            sequence.append(nextVal)\n        }\n    }\n    \n    return sequence\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])"},{"task_id":"HumanEval_131","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Returnează 0 dacă toate cifrele sunt pereche. \/\/ Având în vedere un număr întreg pozitiv n, returnează produsul cifrelor impar. \/\/\/ >>> digits(n: 1)\n\/\/\/ 1\n\/\/\/ >>> digits(n: 4)\n\/\/\/ 0\n\/\/\/ >>> digits(n: 235)\n\/\/\/ 15\nfunc digits(n: Int) -> Int {\n","canonical_solution":"func digits(n: Int) -> Int {\n    var num = n\n    var product = 1\n    var hasOdd = false\n    \n    while num > 0 {\n        let digit = num % 10\n        if digit % 2 != 0 {\n            hasOdd = true\n            product *= digit\n        }\n        num \/= 10\n    }\n    \n    return hasOdd ? product : 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digits(n: 5) == 5)\nassert(digits(n: 54) == 5)\nassert(digits(n: 120) == 1)\nassert(digits(n: 5014) == 5)\nassert(digits(n: 98765) == 315)\nassert(digits(n: 5576543) == 2625)\nassert(digits(n: 2468) == 0)"},{"task_id":"HumanEval_132","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ unde cel puțin un suport din subsecvență este încastrat. \/\/ Funcția ar trebui să returneze true dacă și numai dacă există o subsecvență validă de paranteze \/\/ Crearea unei funcții care ia un șir ca intrare care conține doar paranteze pătrate. \/\/\/ >>> is_nested(string: \"[[]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[]]]]]]][[[[[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[][]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[[][]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[[]][[\")\n\/\/\/ true\nfunc is_nested(string: String) -> Bool {\n","canonical_solution":"func is_nested(string: String) -> Bool {\n    var stack: [Character] = []\n    var nested = false\n\n    for bracket in string {\n        if bracket == \"[\" {\n            stack.append(bracket)\n        } else if bracket == \"]\" {\n            if let last = stack.last, last == \"[\" {\n                stack.removeLast()\n                if !stack.isEmpty {\n                    nested = true\n                }\n            } else {\n                return false\n            }\n        }\n    }\n    return nested\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"},{"task_id":"HumanEval_133","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ rotunjește fiecare element din matrice la int (înălțimea) mai întâi.\/\/ Trebuie să returnezi suma numărilor la pătrat din tabla dată, \/\/ Ai o serie de numere. \/\/\/ >>> sum_squares(lst: [1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> sum_squares(lst: [1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> sum_squares(lst: [1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> sum_squares(lst: [-2.4, 1.0, 1.0])\n\/\/\/ 6\nfunc sum_squares(lst: [Double]) -> Int {\n","canonical_solution":"func sum_squares(lst: [Double]) -> Int {\n    return lst.map { ceil($0) } \/\/ Round each element to the upper int (Ceiling)\n              .map { Int($0 * $0) } \/\/ Square each element\n              .reduce(0, +) \/\/ Sum all squared elements\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)\nassert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)\nassert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)\nassert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)\nassert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)\nassert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)\nassert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)\nassert(sum_squares(lst: [0.0]) == 0)\nassert(sum_squares(lst: [-1.0]) == 1)\nassert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"},{"task_id":"HumanEval_134","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Nota: \"cuvânt\" este un grup de caractere separate de spațiu. \/\/ o parte a unui cuvânt, şi fals altfel. \/\/ a unui șir dat este un caracter alfabetic și nu este \/\/ Creează o funcţie care returnează true dacă ultimul caracter \/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pie\")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e\")\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e \")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"\")\n\/\/\/ false\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n","canonical_solution":"func check_if_last_char_is_a_letter(txt: String) -> Bool {\n    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {\n        return false\n    }\n    \n    if lastChar.isLetter {\n        let words = txt.split(separator: \" \")\n        if let lastWord = words.last {\n            return lastWord.count == 1\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_if_last_char_is_a_letter(txt: \"apple\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"A\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie 1\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee e \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pie\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e \") == false)"},{"task_id":"HumanEval_135","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ valori duplicate. \/\/ nu există un astfel de element atunci return -1.\/\/ nu este mai mare sau egal cu elementul imediat precedent.\/\/ Crearea unei funcții care returnează cel mai mare indice al unui element care \/\/\/ >>> can_arrange(arr: [1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(arr: [1, 2, 3])\n\/\/\/ -1\nfunc can_arrange(arr: [Int]) -> Int {\n","canonical_solution":"func can_arrange(arr: [Int]) -> Int {\n    for i in (1..<arr.count).reversed() {\n        if arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"},{"task_id":"HumanEval_136","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Dacă nu există nici un număr întreg negativ sau pozitiv, returnăm ca zero. \/\/ de numere întregi pozitive într-o matrice. \/\/ cel mai mare dintre numerele negative, iar \"b\" este cel mai mic \/\/ Creează o funcție care returnează un tupul (a, b), unde \"a\" este \/\/\/ >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])\n\/\/\/ (nil, 1)\n\/\/\/ >>> largest_smallest_integers(lst: [] as [Int])\n\/\/\/ (nil, nil)\n\/\/\/ >>> largest_smallest_integers(lst: [0])\n\/\/\/ (nil, nil)\nfunc largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n","canonical_solution":"func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n    var largestNegative: Int? = nil\n    var smallestPositive: Int? = nil\n\n    for number in lst {\n        if number < 0 {\n            if largestNegative == nil || number > largestNegative! {\n                largestNegative = number\n            }\n        } else if number > 0 {\n            if smallestPositive == nil || number < smallestPositive! {\n                smallestPositive = number\n            }\n        }\n    }\n\n    return (largestNegative, smallestPositive)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\nassert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"},{"task_id":"HumanEval_137","nl":"ron_Latn","pl":"swift","prompt":"\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n\/\/ Nota: Dacă un număr real este reprezentat ca un șir, punctul plutitor ar putea fi . sau , \/\/ Returnează null dacă valorile sunt egale. \/\/ numere reale, și returnează variabila mai mare în tipul său de variabilă dat. \/\/ Creează o funcție care ia numere întregi, float, sau șiruri care reprezintă \/\/\/ >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))\n\/\/\/ .doubleValue(2.5)\n\/\/\/ >>> compare_one(a: .intValue(1), b: .stringValue(\"2,3\"))\n\/\/\/ .stringValue(\"2,3\")\n\/\/\/ >>> compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n\/\/\/ .stringValue(\"6\")\n\/\/\/ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n\/\/\/ nil\nfunc compare_one(a: Value, b: Value) -> Value? {\n","canonical_solution":"func compare_one(a: Value, b: Value) -> Value? {\n    func convertToDouble(value: Value) -> Double? {\n        switch value {\n        case .intValue(let int):\n            return Double(int)\n        case .doubleValue(let double):\n            return double\n        case .stringValue(let string):\n            let formatter = NumberFormatter()\n            formatter.locale = Locale(identifier: \"en_US_POSIX\")\n            if string.contains(\",\") {\n                formatter.decimalSeparator = \",\"\n            } else {\n                formatter.decimalSeparator = \".\"\n            }\n            return formatter.number(from: string)?.doubleValue\n        }\n    }\n    \n    let aDouble = convertToDouble(value: a)\n    let bDouble = convertToDouble(value: b)\n    \n    if let aDouble = aDouble, let bDouble = bDouble {\n        if aDouble > bDouble {\n            return a\n        } else if bDouble > aDouble {\n            return b\n        }\n    }\n    \n    return nil\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)"},{"task_id":"HumanEval_138","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu \/\/ Evaluati daca numarul dat n poate fi scris ca suma a exact 4 numere pozitive pare \/\/\/ >>> is_equal_to_sum_even(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 8)\n\/\/\/ true\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n","canonical_solution":"func is_equal_to_sum_even(n: Int) -> Bool {\n    if n <= 8 {\n        return false\n    }\n    return n % 2 == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_equal_to_sum_even(n: 4) == false)\nassert(is_equal_to_sum_even(n: 6) == false)\nassert(is_equal_to_sum_even(n: 8) == true)\nassert(is_equal_to_sum_even(n: 10) == true)\nassert(is_equal_to_sum_even(n: 11) == false)\nassert(is_equal_to_sum_even(n: 12) == true)\nassert(is_equal_to_sum_even(n: 13) == false)\nassert(is_equal_to_sum_even(n: 16) == true)"},{"task_id":"HumanEval_139","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ unde n > 0 \/\/ brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/ Factorialul brazilian este definit ca: \/\/\/ >>> special_factorial(n: 4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfunc special_factorial(n: Int) -> Int {\n","canonical_solution":"func factorial(_ n: Int) -> Int {\n    return n <= 1 ? 1 : n * factorial(n - 1)\n}\n\nfunc special_factorial(n: Int) -> Int {\n    var result = 1\n    for i in 1...n {\n        result *= factorial(i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"},{"task_id":"HumanEval_140","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ apoi înlocuiţi toate spaţiile consecutive cu - \/\/ și dacă un șir are mai mult de 2 spații consecutive, \/\/ Având în vedere un text string, înlocuiți toate spațiile în ea cu sublinieri, \/\/\/ >>> fix_spaces(text: \" Example\")\n\/\/\/ \"Example\"\n\/\/\/ >>> fix_spaces(text: \" Example 1\")\n\/\/\/ \"Example_1\"\n\/\/\/ >>> fix_spaces(text: \" Example 2\")\n\/\/\/ \"_Example_2\"\n\/\/\/ >>> fix_spaces(text: \" Example 3\")\n\/\/\/ \"_Example-3\"\nfunc fix_spaces(text: String) -> String {\n","canonical_solution":"func fix_spaces(text: String) -> String {\n    var result = \"\"\n    var spaceCount = 0\n    \n    for character in text {\n        if character == \" \" {\n            spaceCount += 1\n        } else {\n            if spaceCount == 1 {\n                result.append(\"_\")\n            } else if spaceCount > 1 {\n                result.append(\"-\")\n            }\n            result.append(character)\n            spaceCount = 0\n        }\n    }\n    \n    if spaceCount == 1 {\n        result.append(\"_\")\n    } else if spaceCount > 1 {\n        result.append(\"-\")\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fix_spaces(text: \"Example\") == \"Example\")\nassert(fix_spaces(text: \"Mudasir Hanif \") == \"Mudasir_Hanif_\")\nassert(fix_spaces(text: \"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\")\nassert(fix_spaces(text: \"Exa   mple\") == \"Exa-mple\")\nassert(fix_spaces(text: \"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\")"},{"task_id":"HumanEval_141","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ - Substringul după punct ar trebui să fie unul dintre acestea: ['txt', 'exe', 'dll'] \/\/ alfabetul latin (\"a\" - \"z\" și \"A\" - \"Z\"). \/\/ - Substring înainte de punct nu ar trebui să fie gol, și începe cu o literă de la \/\/ - Numele fişierului conţine exact un punct '.' \/\/ - Numele fişierului nu trebuie să conţină mai mult de trei cifre (\"0\" - \"9\"). \/\/ sunt îndeplinite: \/\/ Un nume de fişier este considerat valid dacă şi numai dacă toate condiţiile următoare sunt îndeplinite.\/\/ 'Da' dacă numele fişierului este valid, şi returnează 'Nu' în caz contrar. \/\/ Creează o funcție care ia un șir care reprezintă numele unui fișier și returnează \/\/\/ >>> file_name_check(file_name: \"example.txt\")\n\/\/\/ \"Yes\"\n\/\/\/ >>> file_name_check(file_name: \"1example.dll\")\n\/\/\/ \"No\"\nfunc file_name_check(file_name: String) -> String {\n","canonical_solution":"func file_name_check(file_name: String) -> String {\n    \/\/ Split by the dot.\n    let components = file_name.split(separator: \".\", omittingEmptySubsequences: false)\n    \n    \/\/ Check if there's exactly one dot.\n    guard components.count == 2 else {\n        return \"No\"\n    }\n    \n    \/\/ Extract the prefix and suffix.\n    let prefix = String(components[0])\n    let suffix = String(components[1])\n    \n    \/\/ Check if the prefix is non-empty and starts with a letter.\n    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {\n        return \"No\"\n    }\n    \n    \/\/ Check if the suffix is one of the allowed types.\n    let validSuffixes = [\"txt\", \"exe\", \"dll\"]\n    guard validSuffixes.contains(suffix) else {\n        return \"No\"\n    }\n    \n    \/\/ Count digits in the file name.\n    let digitCount = file_name.filter { $0.isNumber }.count\n    \n    \/\/ Ensure that there are not more than 3 digits.\n    guard digitCount <= 3 else {\n        return \"No\"\n    }\n    \n    \/\/ If all checks pass, it's a valid file name.\n    return \"Yes\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(file_name_check(file_name: \"example.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"1example.dll\") == \"No\")\nassert(file_name_check(file_name: \"s1sdf3.asd\") == \"No\")\nassert(file_name_check(file_name: \"K.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"MY16FILE3.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"His12FILE94.exe\") == \"No\")\nassert(file_name_check(file_name: \"_Y.txt\") == \"No\")\nassert(file_name_check(file_name: \"?aREYA.exe\") == \"No\")\nassert(file_name_check(file_name: \"\/this_is_valid.dll\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.wow\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"this_is_valid.txtexe\") == \"No\")\nassert(file_name_check(file_name: \"#this2_i4s_5valid.ten\") == \"No\")\nassert(file_name_check(file_name: \"@this1_is6_valid.exe\") == \"No\")\nassert(file_name_check(file_name: \"this_is_12valid.6exe4.txt\") == \"No\")\nassert(file_name_check(file_name: \"all.exe.txt\") == \"No\")\nassert(file_name_check(file_name: \"I563_No.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"Is3youfault.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"no_one#knows.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"1I563_Yes3.exe\") == \"No\")\nassert(file_name_check(file_name: \"I563_Yes3.txtt\") == \"No\")\nassert(file_name_check(file_name: \"final..txt\") == \"No\")\nassert(file_name_check(file_name: \"final132\") == \"No\")\nassert(file_name_check(file_name: \"_f4indsartal132.\") == \"No\")\nassert(file_name_check(file_name: \".txt\") == \"No\")\nassert(file_name_check(file_name: \"s.\") == \"No\")"},{"task_id":"HumanEval_143","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu 1: \/\/ ordinea cuvintelor din noua string ar trebui sa fie aceeasi ca cea originala. \/\/ a căror lungime sunt numere prime, \/\/ și trebuie să returneze un șir care conține cuvintele din propoziția originală, \/\/ propoziţia conţine câteva cuvinte separate de un spaţiu, \/\/ Ai un șir care reprezintă o propoziție, \/\/\/ >>> words_in_sentence(sentence: \"This is a test\")\n\/\/\/ \"is\"\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(sentence: \"lets go for swimming\")\n\/\/\/ \"go for\"\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence: String) -> String {\n","canonical_solution":"func words_in_sentence(sentence: String) -> String {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    let words = sentence.split(separator: \" \")\n    let primeLengthWords = words.filter { isPrime($0.count) }\n    return primeLengthWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"},{"task_id":"HumanEval_144","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Poţi presupune că x şi n sunt fracţii valide şi nu au zero ca numitor. \/\/ <numerator>\/<denominator> unde atât numerarul cât și numitorul sunt numere întregi pozitive. \/\/ altfel. Ambele x și n, sunt reprezentare de string a unei fracțiuni, și au următorul format, \/\/ x * n. Funcția returnează adevărat dacă x * n se evaluează la un număr întreg și fals \/\/ Sarcina ta este să implementezi o funcţie care va simplifica expresia \/\/\/ >>> simplify(x: \"1\/5\", n: \"5\/1\")\n\/\/\/ true\n\/\/\/ >>> simplify(x: \"1\/6\", n: \"2\/1\")\n\/\/\/ false\n\/\/\/ >>> simplify(x: \"7\/10\", n: \"10\/2\")\n\/\/\/ false\nfunc simplify(x: String, n: String) -> Bool {\n","canonical_solution":"func simplify(x: String, n: String) -> Bool {\n    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {\n        let parts = fraction.split(separator: \"\/\").map { Int($0)! }\n        return (numerator: parts[0], denominator: parts[1])\n    }\n    \n    let (xNumerator, xDenominator) = parseFraction(fraction: x)\n    let (nNumerator, nDenominator) = parseFraction(fraction: n)\n    \n    \/\/ Multiply the two fractions: (xNumerator * nNumerator) \/ (xDenominator * nDenominator)\n    let resultNumerator = xNumerator * nNumerator\n    let resultDenominator = xDenominator * nDenominator\n    \n    \/\/ Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator\n    return resultNumerator % resultDenominator == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/6\", n: \"2\/1\") == false)\nassert(simplify(x: \"5\/1\", n: \"3\/1\") == true)\nassert(simplify(x: \"7\/10\", n: \"10\/2\") == false)\nassert(simplify(x: \"2\/10\", n: \"50\/10\") == true)\nassert(simplify(x: \"7\/2\", n: \"4\/2\") == true)\nassert(simplify(x: \"11\/6\", n: \"6\/1\") == true)\nassert(simplify(x: \"2\/3\", n: \"5\/2\") == false)\nassert(simplify(x: \"5\/2\", n: \"3\/5\") == false)\nassert(simplify(x: \"2\/4\", n: \"8\/4\") == true)\nassert(simplify(x: \"2\/4\", n: \"4\/2\") == true)\nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/5\", n: \"1\/5\") == false)"},{"task_id":"HumanEval_145","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ ordonarea lor pe baza indicelor lor în matricea originală. \/\/ Nota: dacă există mai multe elemente cu o sumă similară a cifrelor lor, \/\/ în ordine crescândă, în funcţie de suma cifrelor lor. \/\/ Scrie o funcţie care să sorteze matricea de numere întregi \/\/\/ >>> order_by_points(nums: [1, 11, -1, -11, -12])\n\/\/\/ [-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(nums: [] as [Int])\n\/\/\/ [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n","canonical_solution":"func order_by_points(nums: [Int]) -> [Int] {\n    return nums.enumerated().sorted {\n        let sum1 = digitSum($0.element)\n        let sum2 = digitSum($1.element)\n        if sum1 == sum2 {\n            return $0.offset < $1.offset\n        } else {\n            return sum1 < sum2\n        }\n    }.map { $0.element }\n}\n\nfunc digitSum(_ number: Int) -> Int {\n    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"},{"task_id":"HumanEval_146","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ prima şi ultima cifră a unui număr sunt impar (1, 3, 5, 7, 9). \/\/ numărul de elemente din matrice care sunt mai mari de 10 și ambele \/\/ Scrie o funcţie care ia o serie de numere ca intrare şi returnează \/\/\/ >>> specialFilter(nums: [15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfunc specialFilter(nums: [Int]) -> Int {\n","canonical_solution":"func specialFilter(nums: [Int]) -> Int {\n    return nums.filter { num in\n        let absNum = abs(num)\n        \n        guard absNum > 10 else {\n            return false\n        }\n        \n        let firstDigit = String(String(absNum).first!)\n        let lastDigit = String(absNum % 10)\n        \n        let oddDigits: Set = [\"1\", \"3\", \"5\", \"7\", \"9\"]\n        \n        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(specialFilter(nums: [5, -2, 1, -5]) == 0)\nassert(specialFilter(nums: [15, -73, 14, -15]) == 1)\nassert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)\nassert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)\nassert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)\nassert(specialFilter(nums: [1]) == 0)\nassert(specialFilter(nums: [] as [Int]) == 0)"},{"task_id":"HumanEval_147","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ și a[i] + a[j] + a[k] este un multiplu de 3. \/\/ Returnează numărul de triplu (a[i], a[j], a[k]) a unde i < j < k, \/\/ Pentru fiecare i (1 ≤ i ≤ n), valoarea a[i] = i * i - i + 1. \/\/ Ai un număr întreg pozitiv n. Trebuie să creezi o matrice a numărului întreg de lungime n. \/\/\/ >>> get_max_triples(n: 5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n: Int) -> Int {\n","canonical_solution":"func get_max_triples(n: Int) -> Int {\n    \/\/ Create the array a based on the problem description\n    var a = [Int](repeating: 0, count: n)\n    for i in 1...n {\n        a[i - 1] = i * i - i + 1\n    }\n    \n    var count = 0\n    \/\/ Check for all possible triples\n    for i in 0..<n {\n        for j in (i + 1)..<n {\n            for k in (j + 1)..<n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1\n                }\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_max_triples(n: 5) == 1)\nassert(get_max_triples(n: 6) == 4)\nassert(get_max_triples(n: 10) == 36)\nassert(get_max_triples(n: 100) == 53361)"},{"task_id":"HumanEval_149","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ Ai putea presupune că toate cuvintele vor avea aceeaşi lungime. \/\/ Funcția ar trebui să returneze o serie de șiruri în ordine ordonată. \/\/ Dacă două cuvinte au aceeași lungime, sortați matricea în ordine alfabetică. \/\/ ar trebui să returneze matricea sortată după această regulă. \/\/ Ordinea ariei ar trebui să fie ascendentă de lungimea fiecărui cuvânt, şi \/\/ şi poate conţine duplicate. \/\/ Array-ul este întotdeauna un array de stringuri și niciodată un array de numere, \/\/ și returnează matricea rezultată cu o ordine sortată, \/\/ șterge șirurile care au lungimi impar de la ea, \/\/ Scrieți o funcție care acceptă un set de șiruri ca parametru, \/\/\/ >>> sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"])\n\/\/\/ [\"aa\"]\n\/\/\/ >>> sorted_list_sum(lst: [\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/\/ [\"ab\", \"cd\"]\nfunc sorted_list_sum(lst: [String]) -> [String] {\n","canonical_solution":"func sorted_list_sum(lst: [String]) -> [String] {\n    return lst.filter { $0.count % 2 == 0 }\n              .sorted { \n                  if $0.count == $1.count {\n                      return $0 < $1\n                  }\n                  return $0.count < $1.count\n              }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"]) == [\"aa\"])\nassert(sorted_list_sum(lst: [\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"])\nassert(sorted_list_sum(lst: [\"d\", \"b\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\nassert(sorted_list_sum(lst: [\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\nassert(sorted_list_sum(lst: [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])"},{"task_id":"HumanEval_150","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ un număr prim și ar trebui să returneze valoarea lui y în caz contrar. \/\/ Un program simplu care ar trebui să returneze valoarea lui x dacă n este \/\/\/ >>> x_or_y(n: 7, x: 34, y: 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(n: 15, x: 8, y: 5)\n\/\/\/ 5\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n","canonical_solution":"func x_or_y(n: Int, x: Int, y: Int) -> Int {\n    func isPrime(_ number: Int) -> Bool {\n        if number <= 1 { return false }\n        if number <= 3 { return true }\n        if number % 2 == 0 || number % 3 == 0 { return false }\n        \n        var i = 5\n        while i * i <= number {\n            if number % i == 0 || number % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    return isPrime(n) ? x : y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(x_or_y(n: 7, x: 34, y: 12) == 34)\nassert(x_or_y(n: 15, x: 8, y: 5) == 5)\nassert(x_or_y(n: 3, x: 33, y: 5212) == 33)\nassert(x_or_y(n: 1259, x: 3, y: 52) == 3)\nassert(x_or_y(n: 7919, x: -1, y: 12) == -1)\nassert(x_or_y(n: 3609, x: 1245, y: 583) == 583)\nassert(x_or_y(n: 91, x: 56, y: 129) == 129)\nassert(x_or_y(n: 6, x: 34, y: 1234) == 1234)\nassert(x_or_y(n: 1, x: 2, y: 0) == 0)\nassert(x_or_y(n: 2, x: 2, y: 0) == 2)"},{"task_id":"HumanEval_151","nl":"ron_Latn","pl":"swift","prompt":"\nIgnorăm numerele care sunt negative sau nu sunt întreg.\/\/ Având în vedere o serie de numere, returnează suma pătratelor numărilor.\/\/\/ >>> double_the_difference(lst: [1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(lst: [-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(lst: [9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(lst: [0])\n\/\/\/ 0\n\/\/\/ If the input array is empty, return 0.\nfunc double_the_difference(lst: [Double]) -> Int {\n","canonical_solution":"func double_the_difference(lst: [Double]) -> Int {\n    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }\n              .map { Int($0) * Int($0) }\n              .reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(double_the_difference(lst: [] as [Double]) == 0)\nassert(double_the_difference(lst: [5.0, 4.0]) == 25)\nassert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)\nassert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)\nassert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)\nassert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)\nassert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"},{"task_id":"HumanEval_152","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ valoarea este 0, iar dacă nu, valoarea este diferența absolută dintre ghicit și scor. \/\/ Returnează un matrice de aceeași lungime, care indică cât de departe a fost fiecare ghicit.\/\/ Ai două matriţe de scoruri şi ghici de lungime egală, unde fiecare indice arată o potrivire. \/\/ Sarcina ta este de a determina dacă o persoană a ghicit corect rezultatele unui număr de meciuri. - Merită să fie notat şi comparat.Sentimentele şi gândurile pe care le ai în acel moment sunt cele care te fac să te simţi bine.Cred că ne amintim cu toţii de acel sentiment când rezultatul unei aşteptări îndelungate\/\/\/ >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])\n\/\/\/ [0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])\n\/\/\/ [4, 4, 1, 0, 0, 6]\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n","canonical_solution":"func compare(game: [Int], guess: [Int]) -> [Int] {\n    var result: [Int] = []\n    \n    for i in 0..<game.count {\n        let difference = abs(game[i] - guess[i])\n        result.append(difference)\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])\nassert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])\nassert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])\nassert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"},{"task_id":"HumanEval_153","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ (forţa lui este -1). \/\/ return 'Slices.SErviNGSliCes' deoarece 'SErviNGSliCes' este cea mai puternică extensie \/\/ extensii: ['SERVINGSliCes', 'Cheese', 'StuFfed'] atunci ar trebui să \/\/ De exemplu, dacă ai \"Slice\" ca clasă şi o serie de \/\/ alegeți cel care vine primul în tablă. \/\/ Dacă există două sau mai multe extensii cu aceeași putere, ar trebui să \/\/ format: ClassName.StrongestExtensionName. \/\/ Ar trebui să găsească cea mai puternică extensie și să returneze un șir în acest \/\/ în numele extensiunii, rezistența este dată de fracțiunea CAP - SM. \/\/ litere în numele extensie, și să fie SM numărul de litere minuscule \/\/ puterea extinderii este următoarea: Să fie CAP numărul de la majuscule \/\/ Extensiile sunt folosite pentru a încărca clase suplimentare la clasă.\/\/ Vei primi numele unei clase (un șir) și o serie de extensii. \/\/\/ >>> Strongest_Extension(class_name: \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n\/\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n","canonical_solution":"func Strongest_Extension(class_name: String, extensions: [String]) -> String {\n    var strongestExtension: String? = nil\n    var maxStrength = Int.min\n    \n    for ext in extensions {\n        let cap = ext.filter { $0.isUppercase }.count\n        let sm = ext.filter { $0.isLowercase }.count\n        let strength = cap - sm\n        \n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = ext\n        }\n    }\n    \n    if let strongestExt = strongestExtension {\n        return \"\\(class_name).\\(strongestExt)\"\n    }\n    \n    return class_name\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"},{"task_id":"HumanEval_154","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Ai 2 cuvinte. Trebuie să returnezi true dacă al doilea cuvânt sau oricare dintre rotațiile sale este un substring în primul cuvânt \/\/\/ >>> cycpattern_check(a: \"abcd\", b: \"abd\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"hello\", b: \"ell\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"whassup\", b: \"psus\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"abab\", b: \"baa\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"efef\", b: \"eeff\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"himenss\", b: \"simen\")\n\/\/\/ true\nfunc cycpattern_check(a: String, b: String) -> Bool {\n","canonical_solution":"func cycpattern_check(a: String, b: String) -> Bool {\n    guard !b.isEmpty else { return true }\n    let bCombined = b + b\n    for i in 0..<b.count {\n        let rotation = String(bCombined.dropFirst(i).prefix(b.count))\n        if a.contains(rotation) {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cycpattern_check(a: \"xyzw\", b: \"xyw\") == false)\nassert(cycpattern_check(a: \"yello\", b: \"ell\") == true)\nassert(cycpattern_check(a: \"whattup\", b: \"ptut\") == false)\nassert(cycpattern_check(a: \"efef\", b: \"fee\") == true)\nassert(cycpattern_check(a: \"abab\", b: \"aabb\") == false)\nassert(cycpattern_check(a: \"winemtt\", b: \"tinem\") == true)"},{"task_id":"HumanEval_155","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ Având în vedere un număr întreg. returnează un tupul care are numărul de cifre par și impar, respectiv. \/\/\/ >>> even_odd_count(num: -12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(num: 123)\n\/\/\/ (1, 2)\nfunc even_odd_count(num: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_count(num: Int) -> (Int, Int) {\n    var countEvens = 0\n    var countOdds = 0\n    var number = abs(num) \/\/ Handle negative numbers by taking absolute value\n\n    while number > 0 {\n        let digit = number % 10\n        if digit % 2 == 0 {\n            countEvens += 1\n        } else {\n            countOdds += 1\n        }\n        number \/= 10\n    }\n    return (countEvens, countOdds)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_count(num: 7) == (0, 1))\nassert(even_odd_count(num: -78) == (1, 1))\nassert(even_odd_count(num: 3452) == (2, 2))\nassert(even_odd_count(num: 346211) == (3, 3))\nassert(even_odd_count(num: -345821) == (3, 3))\nassert(even_odd_count(num: -2) == (1, 0))\nassert(even_odd_count(num: -45347) == (2, 3))\nassert(even_odd_count(num: 0) == (1, 0))"},{"task_id":"HumanEval_156","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple: \/\/ Restricții: 1 <= num <= 1000 \/\/ şi să-l returneze cu litere mici. \/\/ Având un întreg pozitiv, obțineți echivalentul său în cifre romane ca un șir, \/\/\/ >>> int_to_mini_roman(number: 19)\n\/\/\/ \"xix\"\n\/\/\/ >>> int_to_mini_roman(number: 152)\n\/\/\/ \"clii\"\n\/\/\/ >>> int_to_mini_roman(number: 426)\n\/\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number: Int) -> String {\n","canonical_solution":"func int_to_mini_roman(number: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    \n    var num = number\n    var result = \"\"\n    \n    for (index, value) in values.enumerated() {\n        while num >= value {\n            result += numerals[index]\n            num -= value\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"},{"task_id":"HumanEval_157","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ 90 de grade. Un triunghi dreptunghiular este un triunghi în care un unghi este dreptunghiular sau\/\/ laturile formează un triunghi dreptunghiular, fals altfel. \/\/ Dată lungimea celor trei laturi ale unui triunghi.\/\/\/ >>> right_angle_triangle(a: 3, b: 4, c: 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(a: 1, b: 2, c: 3)\n\/\/\/ false\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n","canonical_solution":"func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n    let sides = [a, b, c].sorted()\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(right_angle_triangle(a: 3, b: 4, c: 5) == true)\nassert(right_angle_triangle(a: 1, b: 2, c: 3) == false)\nassert(right_angle_triangle(a: 10, b: 6, c: 8) == true)\nassert(right_angle_triangle(a: 2, b: 2, c: 2) == false)\nassert(right_angle_triangle(a: 7, b: 24, c: 25) == true)\nassert(right_angle_triangle(a: 10, b: 5, c: 7) == false)\nassert(right_angle_triangle(a: 5, b: 12, c: 13) == true)\nassert(right_angle_triangle(a: 15, b: 8, c: 17) == true)\nassert(right_angle_triangle(a: 48, b: 55, c: 73) == true)\nassert(right_angle_triangle(a: 1, b: 1, c: 1) == false)\nassert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"},{"task_id":"HumanEval_158","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ caractere, returnarea celui care vine prima în ordinea lexicografică. Dacă mai multe șiruri au un număr maxim de caractere unice,\/\/ Matricea conţine cuvinte diferite. Returnează cuvântul cu numărul maxim de cuvinte.\/\/ Scrieți o funcție care acceptă o serie de șiruri. \/\/\/ >>> find_max(words: [\"name\", \"of\", \"string\"])\n\/\/\/ \"string\"\n\/\/\/ >>> find_max(words: [\"name\", \"enam\", \"game\"])\n\/\/\/ \"enam\"\n\/\/\/ >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/\/ \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n","canonical_solution":"func find_max(words: [String]) -> String {\n    func uniqueCharacterCount(in word: String) -> Int {\n        return Set(word).count\n    }\n    \n    return words.max { a, b in\n        let uniqueCountA = uniqueCharacterCount(in: a)\n        let uniqueCountB = uniqueCharacterCount(in: b)\n        \n        if uniqueCountA == uniqueCountB {\n            return a > b\n        }\n        \n        return uniqueCountA < uniqueCountB\n    } ?? \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"},{"task_id":"HumanEval_159","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemplu: \/\/ dacă nu sunt suficiente morcovi rămase, veți mânca toate morcovii rămase, dar va fi în continuare foame. Numărul de morcovi care au rămas după masă .\/\/ ar trebui să returneze o serie de [număr total de morcovi mâncați după mese, Dar acum trebuie să mănânci mai multe morcovi pentru a completa mesele zilei.Eşti un iepure înfometat şi ai mâncat deja un anumit număr de morcovi.\/\/\/ >>> eat(number: 5, need: 6, remaining: 10)\n\/\/\/ [11, 4]\n\/\/\/ >>> eat(number: 4, need: 8, remaining: 9)\n\/\/\/ [12, 1]\n\/\/\/ >>> eat(number: 1, need: 10, remaining: 10)\n\/\/\/ [11, 0]\n\/\/\/ >>> eat(number: 2, need: 11, remaining: 5)\n\/\/\/ [7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n","canonical_solution":"func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalNeeded = number + need\n    let totalEaten = min(totalNeeded, number + remaining)\n    let carrotsLeft = max(0, remaining - (totalEaten - number))\n    return [totalEaten, carrotsLeft]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"},{"task_id":"HumanEval_160","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Array-ul operator are cel puțin un operator, iar array-ul operand are cel puțin două operande. \/\/ Operand este o serie de integeruri non-negative. \/\/ Lungimea matricei operator este egală cu lungimea matricei operand minus unu. \/\/ Nota: \/\/ => rezultatul = 9 \/\/ rezultatul = 2 + 3 * 4 - 5 \/\/ matrice = [2, 3, 4, 5] \/\/ operatorul ['+', '*', '-'] \/\/ Exemplu: \/\/ Exponentiere (**) \/\/ Diviziunea de etaj ( \/\/ ) \/\/ Multiplicarea ( * ) \/\/ Subtracţie ( - ) \/\/ Adăugarea (+) Operaţiunile de bază ale algebrei:\/\/ expresie și returnă evaluarea acestei expresii. \/\/ a doua matrice este o matrice de numere întregi.Primul matrice are operaţii de bază de algebră, şi func do_algebra(operator: [String], operand: [Int]) -> Int {\n","canonical_solution":"func do_algebra(operator: [String], operand: [Int]) -> Int {\n    var result = operand[0]\n    let precedence: [String: Int] = [\"+\": 1, \"-\": 1, \"*\": 2, \"\/\/\": 2, \"**\": 3]\n    \n    var opStack: [String] = []\n    var numStack: [Int] = [result]\n    \n    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {\n        switch op {\n        case \"+\":\n            return a + b\n        case \"-\":\n            return a - b\n        case \"*\":\n            return a * b\n        case \"\/\/\":\n            return a \/ b\n        case \"**\":\n            return Int(pow(Double(a), Double(b)))\n        default:\n            fatalError(\"Unsupported operator: \\(op)\")\n        }\n    }\n    \n    for i in 0..<operator.count {\n        let currentOp = `operator`[i]\n        let currentNum = operand[i + 1]\n        \n        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {\n            opStack.removeLast()\n            let b = numStack.removeLast()\n            let a = numStack.removeLast()\n            numStack.append(applyOperator(lastOp, b, a))\n        }\n        \n        opStack.append(currentOp)\n        numStack.append(currentNum)\n    }\n    \n    while let lastOp = opStack.popLast() {\n        let b = numStack.removeLast()\n        let a = numStack.removeLast()\n        numStack.append(applyOperator(lastOp, b, a))\n    }\n    \n    return numStack.first!\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(do_algebra(operator: [\"**\", \"*\", \"+\"], operand: [2, 3, 4, 5]) == 37)\nassert(do_algebra(operator: [\"+\", \"*\", \"-\"], operand: [2, 3, 4, 5]) == 9)\nassert(do_algebra(operator: [\"\/\/\", \"*\"], operand: [7, 3, 4]) == 8)"},{"task_id":"HumanEval_161","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Exemple \/\/ Funcția ar trebui să returneze șirul rezultat. \/\/ Dacă stringul nu conţine nici o literă, inversă stringul. \/\/ altfel să-l păstreze așa cum este. \/\/ dacă s[i] este o literă, inversă cazul de la jos la sus sau viceversa, \/\/ Ai un șir de s. \/\/\/ >>> solve(s: \"1234\")\n\/\/\/ \"4321\"\n\/\/\/ >>> solve(s: \"ab\")\n\/\/\/ \"AB\"\n\/\/\/ >>> solve(s: \"#a@C\")\n\/\/\/ \"#A@c\"\nfunc solve(s: String) -> String {\n","canonical_solution":"func solve(s: String) -> String {\n    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n    \n    var result = \"\"\n    for char in s {\n        if char.isLetter {\n            if char.isLowercase {\n                result.append(char.uppercased())\n            } else {\n                result.append(char.lowercased())\n            }\n        } else {\n            result.append(char)\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"},{"task_id":"HumanEval_162","nl":"ron_Latn","pl":"swift","prompt":"\n\/\/ Dacă \"text\" este un șir gol, returnăm null. \/\/ Având în vedere un șir de 'text', returnăm șirul echivalent de hash md5. \/\/\/ >>> string_to_md5(text: \"Hello world\")\n\/\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunc string_to_md5(text: String) -> String? {\n","canonical_solution":"import Foundation\nimport CommonCrypto\n\nfunc string_to_md5(text: String) -> String? {\n    guard !text.isEmpty else { return nil }\n    \n    let length = Int(CC_MD5_DIGEST_LENGTH)\n    let messageData = text.data(using: .utf8)!\n    var digestData = Data(count: length)\n    \n    _ = digestData.withUnsafeMutableBytes { digestBytes in\n        messageData.withUnsafeBytes { messageBytes in\n            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)\n        }\n    }\n    \n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\nassert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\nassert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\")"},{"task_id":"HumanEval_163","nl":"ron_Latn","pl":"swift","prompt":"\nDe exemplu:\/\/ şi b, în ordine crescândă. \/\/ Având în vedere două numere întregi pozitive a și b, returnează cifrele pereche dintre a \/\/\/ >>> generate_integers(a: 2, b: 8)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 8, b: 2)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 10, b: 14)\n\/\/\/ [] as [Int]\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n","canonical_solution":"func generate_integers(a: Int, b: Int) -> [Int] {\n    let lower = min(a, b)\n    let upper = max(a, b)\n    var result = [Int]()\n    \n    for number in lower...upper {\n        if number % 2 == 0 {\n            result.append(number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])\nassert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 17, b: 89) == [] as [Int])"}]