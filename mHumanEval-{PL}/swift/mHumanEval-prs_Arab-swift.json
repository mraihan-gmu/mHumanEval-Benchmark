[{"task_id":"HumanEval_0","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ حد مشخص شده. \/\/ بررسی کنید که آیا در آرایه داده شده اعداد، هر دو عدد به یکدیگر نزدیک تر از \/\/\/ >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)\n\/\/\/ true\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n","canonical_solution":"func has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n    let sortedNumbers = numbers.sorted()\n    for i in 0..<sortedNumbers.count - 1 {\n        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"},{"task_id":"HumanEval_1","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ هر جای خالی در رشته ورودی را نادیده بگیرید. \/\/ گروه های جداگانه متعادل هستند (هر بند باز به درستی بسته شده است) و در درون یکدیگر قرار ندارند .\/\/ این گروه ها را به رشته های جداگانه جدا کنید و آرایه آن ها را برگردانید. \/\/ ورودی این تابع یک رشته است که شامل چندین گروه از قوس های آشیانه شده است. هدف شما این است که \/\/\/ >>> separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\")\n\/\/\/ [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string: String) -> [String] {\n","canonical_solution":"func separate_paren_groups(paren_string: String) -> [String] {\n    var results = [String]()\n    var currentGroup = \"\"\n    var balance = 0\n\n    for char in paren_string {\n        \/\/ Ignore spaces\n        if char == \" \" {\n            continue\n        }\n        \n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\n        currentGroup.append(char)\n\n        if balance == 0 && !currentGroup.isEmpty {\n            results.append(currentGroup)\n            currentGroup = \"\"\n        }\n    }\n    \n    return results\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"},{"task_id":"HumanEval_2","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ قسمت اعشاری عدد را باز می گرداند. \/\/ (باقی مانده همیشه کوچکتر از 1 است).\/\/ و بخش عدد صحیح (بزرگ ترین عدد صحیح کوچکتر از عدد داده شده) و اعشار \/\/ با توجه به یک عدد مثبت نقطه شناور، می توان آن را به  تجزیه کرد.\/\/\/ >>> truncate_number(number: 3.5)\n\/\/\/ 0.5\nfunc truncate_number(number: Double) -> Double {\n","canonical_solution":"func truncate_number(number: Double) -> Double {\n    return number - Double(Int(number))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"},{"task_id":"HumanEval_3","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ در این نقطه تابع باید true را برگرداند. در غیر این صورت باید false را برگرداند. \/\/ صفر توازن. وظیفه شما این است که تشخیص دهید که در هر نقطه توازن حساب زیر صفر می رود، و \/\/ شما یک سری از عملیات سپرده گذاری و برداشت را در یک حساب بانکی که با  شروع می شود داده می شوید.\/\/\/ >>> below_zero(operations: [1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(operations: [1, 2, -4, 5])\n\/\/\/ true\nfunc below_zero(operations: [Int]) -> Bool {\n","canonical_solution":"func below_zero(operations: [Int]) -> Bool {\n    var balance = 0\n    for operation in operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_zero(operations: [] as [Int]) == false)\nassert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)\nassert(below_zero(operations: [1, 2, -4, 5, 6]) == true)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)\nassert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"},{"task_id":"HumanEval_4","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ MAD = متوسط ∙ x - x_mean ∙ ∙\/\/ عنصر و یک نقطه مرکزی (در این مورد میانگین): \/\/ انحراف مطلق میانگین متوسط تفاوت مطلق بین هر \/\/ در حدود میانگین این مجموعه داده ها. \/\/ برای یک آرایه داده شده از اعداد ورودی، انحراف مطلق میانگین را محاسبه کنید \/\/\/ >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n","canonical_solution":"func mean_absolute_deviation(numbers: [Double]) -> Double {\n    guard !numbers.isEmpty else { return 0.0 }\n    \n    let mean = numbers.reduce(0.0, +) \/ Double(numbers.count)\n    let absoluteDifferences = numbers.map { abs($0 - mean) }\n    let mad = absoluteDifferences.reduce(0.0, +) \/ Double(absoluteDifferences.count)\n    \n    return mad\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"},{"task_id":"HumanEval_5","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ یک عدد \"محدود\" را بین هر دو عنصر متوالی آرایه ورودی `numbers'  وارد کنید\/\/\/ >>> intersperse(numbers: [] as [Int], delimeter: 4)\n\/\/\/ [] as [Int]\n\/\/\/ >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\/\/\/ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n","canonical_solution":"func intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    \n    var result: [Int] = []\n    \n    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n    }\n    \n    \/\/ Remove the last added delimiter\n    result.removeLast()\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"},{"task_id":"HumanEval_6","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ به عنوان مثال (() (()) حداکثر دو سطح لانه سازی دارد در حالیکه ((())) سه سطح دارد. \/\/ برای هر یک از گروه ها، عمیق ترین سطح آشیانه سازی قوس ها را تولید کنید. \/\/ ورودی این تابع یک رشته است که چندین گروه را برای قوس های آشیانه ای که با فضای جدا شده است نشان می دهد. \/\/\/ >>> parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\")\n\/\/\/ [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n","canonical_solution":"func parse_nested_parens(paren_string: String) -> [Int] {\n    let groups = paren_string.split(separator: \" \")\n    var depths: [Int] = []\n    \n    for group in groups {\n        var maxDepth = 0\n        var currentDepth = 0\n        \n        for char in group {\n            if char == \"(\" {\n                currentDepth += 1\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == \")\" {\n                currentDepth -= 1\n            }\n        }\n        \n        depths.append(maxDepth)\n    }\n    \n    return depths\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])"},{"task_id":"HumanEval_7","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ یک آرایه ورودی از رشته ها را فقط برای آنهایی که شامل زیر رشته داده شده هستند فیلتر کنید \/\/\/ >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n\/\/\/ [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n","canonical_solution":"func filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter { $0.contains(substring) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"},{"task_id":"HumanEval_8","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ جمع خالی باید برابر با 0 و حاصل خالی باید برابر با 1 باشد. \/\/ برای یک آرایه داده شده از اعداد صحیح، یک توپل را که شامل جمع و حاصل حاصل از تمام اعداد صحیح در یک آرایه است، برگردانید. \/\/\/ >>> sum_product(numbers: [] as [Int])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(numbers: [1, 2, 3, 4])\n\/\/\/ (10, 24)\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n","canonical_solution":"func sum_product(numbers: [Int]) -> (Int, Int) {\n    let sum = numbers.reduce(0, +)\n    let product = numbers.reduce(1, *)\n    return (sum, product)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_product(numbers: [] as [Int]) == (0, 1))\nassert(sum_product(numbers: [1, 1, 1]) == (3, 1))\nassert(sum_product(numbers: [100, 0]) == (100, 0))\nassert(sum_product(numbers: [3, 5, 7]) == (15, 105))\nassert(sum_product(numbers: [10]) == (10, 10))"},{"task_id":"HumanEval_9","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ در دنباله . \/\/ از یک آرایه داده شده از اعداد صحیح، یک آرایه از عناصر حداکثر رولینگ را که تا لحظه داده شده یافت می شود، تولید کنید.\/\/\/ >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])\n\/\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int]) -> [Int] {\n","canonical_solution":"func rolling_max(numbers: [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax: Int? = nil\n    for number in numbers {\n        if let max = currentMax {\n            currentMax = max > number ? max : number\n        } else {\n            currentMax = number\n        }\n        result.append(currentMax!)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"},{"task_id":"HumanEval_10","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ - به انتهای رشته معکوس یک پیشوند رشته ای که قبل از پسوند پالندروم می آید اضافه کنید. \/\/ - طولانی ترین پس فکس رشته ارائه شده را که یک پالندروم است پیدا کنید. \/\/ ایده الگوریتم ساده است: \/\/ کوتاه ترین پالندرم را پیدا کنید که با یک رشته ارائه شده شروع می شود. \/\/\/ >>> make_palindrome(string: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> make_palindrome(string: \"cat\")\n\/\/\/ \"catac\"\n\/\/\/ >>> make_palindrome(string: \"cata\")\n\/\/\/ \"catac\"\nfunc make_palindrome(string: String) -> String {\n","canonical_solution":"func make_palindrome(string: String) -> String {\n    func isPalindrome(_ s: String) -> Bool {\n        return s == String(s.reversed())\n    }\n    \n    if string.isEmpty || isPalindrome(string) {\n        return string\n    }\n    \n    for i in stride(from: string.count, through: 0, by: -1) {\n        let suffixIndex = string.index(string.startIndex, offsetBy: i)\n        let suffix = String(string[suffixIndex..<string.endIndex])\n        if isPalindrome(suffix) {\n            let prefix = String(string[string.startIndex..<suffixIndex])\n            return string + String(prefix.reversed())\n        }\n    }\n    \n    return string\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"},{"task_id":"HumanEval_11","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ XOR دوگانه را روی این ورودی ها اجرا کنید و نتیجه را نیز به عنوان یک رشته برگردانید. \/\/ ورودی دو رشته a و b است که فقط از 1 ها و 0 ها تشکیل شده است. \/\/\/ >>> string_xor(a: \"010\", b: \"110\")\n\/\/\/ \"100\"\nfunc string_xor(a: String, b: String) -> String {\n","canonical_solution":"func string_xor(a: String, b: String) -> String {\n    let charactersA = Array(a)\n    let charactersB = Array(b)\n    var result = \"\"\n\n    for i in 0..<charactersA.count {\n        let bitA = charactersA[i]\n        let bitB = charactersB[i]\n        \n        if bitA != bitB {\n            result.append(\"1\")\n        } else {\n            result.append(\"0\")\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"},{"task_id":"HumanEval_12","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ رشته های با طول یکسان. در صورت خالی بودن آرایه ورودی، null را باز می گرداند. \/\/ از آرایه رشته ها، طولانی ترین را برگردانید. در صورت چندگانه بودن، اولین را برگردانید.\/\/\/ >>> longest(strings: [] as [String])\n\/\/\/ nil\n\/\/\/ >>> longest(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"a\"\n\/\/\/ >>> longest(strings: [\"a\", \"bb\", \"ccc\"])\n\/\/\/ \"ccc\"\nfunc longest(strings: [String]) -> String? {\n","canonical_solution":"func longest(strings: [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n    for string in strings {\n        if string.count > longestString.count {\n            longestString = string\n        }\n    }\n    return longestString\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"},{"task_id":"HumanEval_13","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ بزرگترین تقسیم مشترک دو عدد صحیح a و b را بر می گرداند \/\/\/ >>> greatest_common_divisor(a: 3, b: 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(a: 25, b: 15)\n\/\/\/ 5\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n","canonical_solution":"func greatest_common_divisor(a: Int, b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return greatest_common_divisor(a: b, b: a % b)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(greatest_common_divisor(a: 3, b: 7) == 1)\nassert(greatest_common_divisor(a: 10, b: 15) == 5)\nassert(greatest_common_divisor(a: 49, b: 14) == 7)\nassert(greatest_common_divisor(a: 144, b: 60) == 12)"},{"task_id":"HumanEval_14","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ آرایه تمام پیشوند ها را از کوتاه ترین تا طولانی ترین رشته ورودی باز می گرداند \/\/\/ >>> all_prefixes(string: \"abc\")\n\/\/\/ [\"a\", \"ab\", \"abc\"]\nfunc all_prefixes(string: String) -> [String] {\n","canonical_solution":"func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] = []\n    for i in 1...string.count {\n        let prefix = String(string.prefix(i))\n        prefixes.append(prefix)\n    }\n    return prefixes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"},{"task_id":"HumanEval_15","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ یک رشته حاوی اعداد محدود به فضا را از 0 تا n شامل می کند. \/\/\/ >>> string_sequence(n: 0)\n\/\/\/ \"0\"\n\/\/\/ >>> string_sequence(n: 5)\n\/\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n: Int) -> String {\n","canonical_solution":"func string_sequence(n: Int) -> String {\n    return (0...n).map { String($0) }.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_sequence(n: 0) == \"0\")\nassert(string_sequence(n: 3) == \"0 1 2 3\")\nassert(string_sequence(n: 10) == \"0 1 2 3 4 5 6 7 8 9 10\")"},{"task_id":"HumanEval_16","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ یک رشته داده شده، تعداد کاراکتر های متمایز (بغیر توجه به مورد) را پیدا کنید که از آن تشکیل شده است.\/\/\/ >>> count_distinct_characters(string: \"xyzXYZ\")\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(string: \"Jerry\")\n\/\/\/ 4\nfunc count_distinct_characters(string: String) -> Int {\n","canonical_solution":"func count_distinct_characters(string: String) -> Int {\n    let lowercasedString = string.lowercased()\n    let distinctCharacters = Set(lowercasedString)\n    return distinctCharacters.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_distinct_characters(string: \"\") == 0)\nassert(count_distinct_characters(string: \"abcde\") == 5)\nassert(count_distinct_characters(string: \"abcdecadeCADE\") == 5)\nassert(count_distinct_characters(string: \"aaaaAAAAaaaa\") == 1)\nassert(count_distinct_characters(string: \"Jerry jERRY JeRRRY\") == 5)"},{"task_id":"HumanEval_17","nl":"prs_Arab","pl":"swift","prompt":"\n\" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \" \"\"او\" می گوید: \"دو ضرب می زند\"\/\/ 'o' - تمام نوت، چهار ضرب طول می کشد \/\/ اینجا یک افسانه است: \/\/ نه آخرین ها\/\/ وظیفه شما تجزیه این رشته است و ارقام صحیح را که با تعداد ضربات هر کدام مطابقت دارد را باز می گرداند \/\/ ورودی این تابع یک رشته است که نمایانگر یادداشت های موسیقی در یک فرمت خاص ASCII است. \/\/\/ >>> parse_music(music_string: \"o o| .| o| o| .| .| .| .| o o\")\n\/\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string: String) -> [Int] {\n","canonical_solution":"func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.split(separator: \" \")\n    var beats: [Int] = []\n    \n    for note in notes {\n        switch note {\n        case \"o\":\n            beats.append(4)\n        case \"o|\":\n            beats.append(2)\n        case \".|\":\n            beats.append(1)\n        default:\n            continue\n        }\n    }\n    \n    return beats\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"},{"task_id":"HumanEval_18","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ تعداد بار هایی که یک زیر رشته داده شده در رشته اصلی یافت می شود را پیدا کنید. موارد همپوشانی را بشمارید. \/\/\/ >>> how_many_times(string: \"\", substring: \"a\")\n\/\/\/ 0\n\/\/\/ >>> how_many_times(string: \"aaa\", substring: \"a\")\n\/\/\/ 3\n\/\/\/ >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n\/\/\/ 3\nfunc how_many_times(string: String, substring: String) -> Int {\n","canonical_solution":"func how_many_times(string: String, substring: String) -> Int {\n    guard !substring.isEmpty else { return 0 }\n    \n    var count = 0\n    var startIndex = string.startIndex\n    \n    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {\n        count += 1\n        startIndex = string.index(after: range.lowerBound)\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"},{"task_id":"HumanEval_19","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ رشته ای را با اعداد مرتب شده از کوچک ترین تا بزرگ ترین برگرداند \/\/ گزینه های معتبر عبارتند از: صفر، یک، دو، سه، چهار، پنج، شش، هفت، هشت و نه. \/\/ ورودی یک رشته عددی از صفر تا نه است که با فضا محدود شده است. \/\/\/ >>> sort_numbers(numbers: \"three one five\")\n\/\/\/ \"one three five\"\nfunc sort_numbers(numbers: String) -> String {\n","canonical_solution":"func sort_numbers(numbers: String) -> String {\n    \/\/ Mapping of word numbers to digits\n    let numberWords: [String: Int] = [\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    ]\n\n    \/\/ Split the input string into words\n    let words = numbers.split(separator: \" \")\n\n    \/\/ Sort the words based on their corresponding number values\n    let sortedWords = words.sorted { \n        numberWords[String($0)]! < numberWords[String($1)]! \n    }\n\n    \/\/ Join the sorted words back into a single string\n    return sortedWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_numbers(numbers: \"\") == \"\")\nassert(sort_numbers(numbers: \"three\") == \"three\")\nassert(sort_numbers(numbers: \"three five nine\") == \"three five nine\")\nassert(sort_numbers(numbers: \"five zero four seven nine eight\") == \"zero four five seven eight nine\")\nassert(sort_numbers(numbers: \"six five four three two one zero\") == \"zero one two three four five six\")"},{"task_id":"HumanEval_20","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ دیگر و آنها را به ترتیب (تعداد کوچکتر، تعداد بزرگتر) بازگردانید.\/\/ از یک آرایه ارقام ارائه شده (حداقل دو عدد) دو عدد را که به هر یک نزدیک ترین هستند انتخاب کنید و برگردانید \/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n","canonical_solution":"func find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    \/\/ Sort the array to bring closest numbers next to each other\n    let sortedNumbers = numbers.sorted()\n    \n    \/\/ Initialize variables to keep track of the smallest difference and the pair\n    var minDifference = Double.greatestFiniteMagnitude\n    var closestPair: (Double, Double) = (0.0, 0.0)\n    \n    \/\/ Iterate over the sorted numbers to find the smallest difference\n    for i in 0..<sortedNumbers.count - 1 {\n        let num1 = sortedNumbers[i]\n        let num2 = sortedNumbers[i + 1]\n        let difference = abs(num1 - num2)\n        \n        if difference < minDifference {\n            minDifference = difference\n            closestPair = (num1, num2)\n        }\n    }\n    \n    return closestPair\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"},{"task_id":"HumanEval_21","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ به طوری که کوچک ترین عدد به صفر و بزرگ ترین عدد به یک تبدیل شود \/\/ با توجه به آرایه اعداد (حداقل دو عنصر) ، یک تبدیل خطی را به آن آرایه اعمال کنید، \/\/\/ >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n","canonical_solution":"func rescale_to_unit(numbers: [Double]) -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    \n    let minValue = numbers.min()!\n    let maxValue = numbers.max()!\n    let range = maxValue - minValue\n    \n    guard range != 0 else {\n        return numbers.map { _ in 0.0 }\n    }\n    \n    return numbers.map { ($0 - minValue) \/ range }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"},{"task_id":"HumanEval_22","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ فلتر کردن آرایه داده شده از هر مقدار swiftthon فقط برای عدد های صحیح \/\/\/ >>> filter_integers(values: [\"a\", 3.14, 5])\n\/\/\/ [5]\n\/\/\/ >>> filter_integers(values: [1, 2, 3, \"abc\", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])\n\/\/\/ [1, 2, 3]\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n","canonical_solution":"func filter_integers(values: [AnyHashable]) -> [Int] {\n    return values.compactMap { $0 as? Int }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])\nassert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, \"adasd\"]) == [4, 9])\nassert(filter_integers(values: [3, \"c\", 3, 3, \"a\", \"b\"]) == [3, 3, 3])"},{"task_id":"HumanEval_23","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ طول رشته داده شده را باز می گرداند \/\/\/ >>> strlen(string: \"\")\n\/\/\/ 0\n\/\/\/ >>> strlen(string: \"abc\")\n\/\/\/ 3\nfunc strlen(string: String) -> Int {\n","canonical_solution":"func strlen(string: String) -> Int {\n    return string.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strlen(string: \"\") == 0)\nassert(strlen(string: \"x\") == 1)\nassert(strlen(string: \"asdasnakj\") == 9)"},{"task_id":"HumanEval_24","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای یک عدد n داده شده، بزرگترین عدد را که n را به طور مساوی تقسیم می کند، کوچکتر از n را پیدا کنید \/\/\/ >>> largest_divisor(n: 15)\n\/\/\/ 5\nfunc largest_divisor(n: Int) -> Int {\n","canonical_solution":"func largest_divisor(n: Int) -> Int {\n    for i in stride(from: n \/ 2, to: 0, by: -1) {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_divisor(n: 3) == 1)\nassert(largest_divisor(n: 7) == 1)\nassert(largest_divisor(n: 10) == 5)\nassert(largest_divisor(n: 100) == 50)\nassert(largest_divisor(n: 49) == 7)"},{"task_id":"HumanEval_25","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ عدد ورودی باید برابر با حاصل حاصل از تمام عوامل باشد \/\/ هر یک از فاکتورها باید به تعداد بار های مربوط به تعداد بار هایی که در فاکتورسازی ظاهر می شود، مرتب شود. \/\/ آرایه عوامل اول عدد صحیح داده شده را از کوچک ترین تا بزرگ ترین به ترتیب باز می گرداند. \/\/\/ >>> factorize(n: 8)\n\/\/\/ [2, 2, 2]\n\/\/\/ >>> factorize(n: 25)\n\/\/\/ [5, 5]\n\/\/\/ >>> factorize(n: 70)\n\/\/\/ [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n","canonical_solution":"func factorize(n: Int) -> [Int] {\n    guard n > 1 else { return [] }\n    var number = n\n    var factors: [Int] = []\n    var divisor = 2\n    \n    while number >= divisor {\n        while number % divisor == 0 {\n            factors.append(divisor)\n            number \/= divisor\n        }\n        divisor += 1\n    }\n    \n    return factors\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"},{"task_id":"HumanEval_26","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ ترتیب عناصر را مانند در ورودی باقی می گذارد. \/\/ از یک آرایه از اعداد صحیح، تمام عناصر را که بیش از یک بار رخ می دهند حذف کنید. \/\/\/ >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])\n\/\/\/ [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n","canonical_solution":"func remove_duplicates(numbers: [Int]) -> [Int] {\n    var elementCount = [Int: Int]()\n    for number in numbers {\n        elementCount[number, default: 0] += 1\n    }\n    return numbers.filter { elementCount[$0] == 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"},{"task_id":"HumanEval_27","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای یک رشته داده شده، کاراکترهای کوچک را به بزرگ و بزرگ به کوچک تبدیل کنید. \/\/\/ >>> flip_case(string: \"Hello\")\n\/\/\/ \"hELLO\"\nfunc flip_case(string: String) -> String {\n","canonical_solution":"func flip_case(string: String) -> String {\n    return String(string.map { character in\n        if character.isLowercase {\n            return character.uppercased()\n        } else if character.isUppercase {\n            return character.lowercased()\n        } else {\n            return String(character)\n        }\n    }.joined())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(flip_case(string: \"\") == \"\")\nassert(flip_case(string: \"Hello!\") == \"hELLO!\")\nassert(flip_case(string: \"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")"},{"task_id":"HumanEval_28","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ رشته های رشته ای را به یک رشته واحد متصل کنید \/\/\/ >>> concatenate(strings: [] as [String])\n\/\/\/ \"\"\n\/\/\/ >>> concatenate(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"abc\"\nfunc concatenate(strings: [String]) -> String {\n","canonical_solution":"func concatenate(strings: [String]) -> String {\n    return strings.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(concatenate(strings: [] as [String]) == \"\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\"]) == \"xyz\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\", \"w\", \"k\"]) == \"xyzwk\")"},{"task_id":"HumanEval_29","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ یک آرایه ورودی از رشته ها را فقط برای رشته هایی که با یک پیشوند داده شده شروع می شوند، فیلتر کنید. \/\/\/ >>> filter_by_prefix(strings: [] as [String], prefix: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_prefix(strings: [\"abc\", \"bcd\", \"cde\", \"array\"], prefix: \"a\")\n\/\/\/ [\"abc\", \"array\"]\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n","canonical_solution":"func filter_by_prefix(strings: [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"},{"task_id":"HumanEval_30","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ فقط اعداد مثبت را در آرایه باز می گرداند. \/\/\/ >>> get_positive(l: [-1, 2, -4, 5, 6])\n\/\/\/ [2, 5, 6]\n\/\/\/ >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunc get_positive(l: [Int]) -> [Int] {\n","canonical_solution":"func get_positive(l: [Int]) -> [Int] {\n    return l.filter { $0 > 0 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])\nassert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\nassert(get_positive(l: [-1, -2]) == [] as [Int])\nassert(get_positive(l: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_31","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اگر یک عدد داده شده اول باشد راست را باز می گرداند و در غیر این صورت غلط را. \/\/\/ >>> is_prime(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 101)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 11)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 61)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 1)\n\/\/\/ false\nfunc is_prime(n: Int) -> Bool {\n","canonical_solution":"func is_prime(n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false\n    }\n    var i = 5\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_prime(n: 6) == false)\nassert(is_prime(n: 101) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 13441) == true)\nassert(is_prime(n: 61) == true)\nassert(is_prime(n: 4) == false)\nassert(is_prime(n: 1) == false)\nassert(is_prime(n: 5) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 17) == true)\nassert(is_prime(n: 85) == false)\nassert(is_prime(n: 77) == false)\nassert(is_prime(n: 255379) == false)"},{"task_id":"HumanEval_33","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ به ارزش های شاخص های مربوطه l، اما مرتب شده است. \/\/ l' با l در شاخص هایی که به سه تقسیم نمی شوند یکسان است، در حالی که مقادیر آن در شاخص هایی که به سه تقسیم می شوند برابر است \/\/ این تابع یک آرایه l را می گیرد و یک آرایه l را باز می گرداند که \/\/\/ >>> sort_third(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])\n\/\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunc sort_third(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_third(l: [Int]) -> [Int] {\n    \/\/ Collect indices and their values where index is divisible by 3\n    var divisibleByThreeValues: [(index: Int, value: Int)] = []\n    for (index, value) in l.enumerated() where index % 3 == 0 {\n        divisibleByThreeValues.append((index, value))\n    }\n    \n    \/\/ Sort the values that were at the indices divisible by 3\n    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()\n    \n    \/\/ Create a mutable copy of original array to modify\n    var result = l\n    \n    \/\/ Replace the sorted values back into their original indices\n    for (i, sortedValue) in sortedValues.enumerated() {\n        result[divisibleByThreeValues[i].index] = sortedValue\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])\nassert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])\nassert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])\nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"},{"task_id":"HumanEval_34","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ عناصر منحصر به فرد مرتب شده را در یک آرایه باز می گرداند \/\/\/ >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [0, 2, 3, 5, 9, 123]\nfunc unique(l: [Int]) -> [Int] {\n","canonical_solution":"func unique(l: [Int]) -> [Int] {\n    return Array(Set(l)).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"},{"task_id":"HumanEval_35","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ حداکثر عنصر در آرایه را باز می گرداند. \/\/\/ >>> max_element(l: [1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfunc max_element(l: [Int]) -> Int {\n","canonical_solution":"func max_element(l: [Int]) -> Int {\n    guard let max = l.max() else {\n        fatalError(\"Array should not be empty\")\n    }\n    return max\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"},{"task_id":"HumanEval_36","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ تعداد دفعات که رقم 7 در عدد های کامل کمتر از n که قابل تقسیم با 11 یا 13 است ظاهر می شود را برگرداند. \/\/\/ >>> fizz_buzz(n: 50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(n: 78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(n: 79)\n\/\/\/ 3\nfunc fizz_buzz(n: Int) -> Int {\n","canonical_solution":"func fizz_buzz(n: Int) -> Int {\n    var count = 0\n    for number in 0..<n {\n        if number % 11 == 0 || number % 13 == 0 {\n            var current = number\n            while current > 0 {\n                if current % 10 == 7 {\n                    count += 1\n                }\n                current \/= 10\n            }\n        }\n    }\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fizz_buzz(n: 50) == 0)\nassert(fizz_buzz(n: 78) == 2)\nassert(fizz_buzz(n: 79) == 3)\nassert(fizz_buzz(n: 100) == 3)\nassert(fizz_buzz(n: 200) == 6)\nassert(fizz_buzz(n: 4000) == 192)\nassert(fizz_buzz(n: 10000) == 639)\nassert(fizz_buzz(n: 100000) == 8026)"},{"task_id":"HumanEval_37","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ به ارزش های شاخص های جفت l، اما مرتب شده است. \/\/ l' با l در شاخص های عجیب یکسان است، در حالی که مقادیر آن در شاخص های جفت برابر است \/\/ این تابع یک آرایه l را می گیرد و یک آرایه l را باز می گرداند که \/\/\/ >>> sort_even(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_even(l: [5, 6, 3, 4])\n\/\/\/ [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_even(l: [Int]) -> [Int] {\n    var evenIndicesValues = [Int]()\n    \n    \/\/ Collect values from even indices\n    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n            evenIndicesValues.append(value)\n        }\n    }\n    \n    \/\/ Sort the collected even indices values\n    evenIndicesValues.sort()\n    \n    var result = l\n    var evenIndex = 0\n    \n    \/\/ Replace even-indexed elements in result with sorted values\n    for i in 0..<result.count {\n        if i % 2 == 0 {\n            result[i] = evenIndicesValues[evenIndex]\n            evenIndex += 1\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"},{"task_id":"HumanEval_39","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ prime_fib عدد n-م را که یک عدد فیبوناچی است و همچنان عدد اول است را باز می گرداند. \/\/\/ >>> prime_fib(n: 1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(n: 2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(n: 3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(n: 4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(n: 5)\n\/\/\/ 89\nfunc prime_fib(n: Int) -> Int {\n","canonical_solution":"func isPrime(_ num: Int) -> Bool {\n    if num <= 1 { return false }\n    if num <= 3 { return true }\n    if num % 2 == 0 || num % 3 == 0 { return false }\n    var i = 5\n    while i * i <= num {\n        if num % i == 0 || num % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}\n\nfunc generateFibonacci(n: Int) -> [Int] {\n    var fibs = [1, 2]\n    var next = fibs[0] + fibs[1]\n    while fibs.count < n || !isPrime(next) {\n        fibs.append(next)\n        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]\n    }\n    return fibs\n}\n\nfunc prime_fib(n: Int) -> Int {\n    var count = 0\n    var fibs = generateFibonacci(n: n)\n    for fib in fibs {\n        if isPrime(fib) {\n            count += 1\n            if count == n {\n                return fib\n            }\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_fib(n: 1) == 2)\nassert(prime_fib(n: 2) == 3)\nassert(prime_fib(n: 3) == 5)\nassert(prime_fib(n: 4) == 13)\nassert(prime_fib(n: 5) == 89)\nassert(prime_fib(n: 6) == 233)\nassert(prime_fib(n: 7) == 1597)\nassert(prime_fib(n: 8) == 28657)\nassert(prime_fib(n: 9) == 514229)\nassert(prime_fib(n: 10) == 433494437)"},{"task_id":"HumanEval_40","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ جمع به صفر و در غیر اینصورت غلط است. \/\/ اگر سه عنصر متمایز در آرایه وجود داشته باشد که \/\/ triple_sum_to_zero یک آرایه از اعداد صحیح را به عنوان یک ورودی می گیرد. \/\/\/ >>> triples_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1])\n\/\/\/ false\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func triples_sum_to_zero(l: [Int]) -> Bool {\n    let count = l.count\n    if count < 3 {\n        return false\n    }\n    \n    let sortedArray = l.sorted()\n    \n    for i in 0..<count - 2 {\n        var left = i + 1\n        var right = count - 1\n        \n        while left < right {\n            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]\n            if currentSum == 0 {\n                return true\n            } else if currentSum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)\nassert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)\nassert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)\nassert(triples_sum_to_zero(l: [1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)\nassert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"},{"task_id":"HumanEval_41","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ این تابع تعداد چنین برخورد هایی را به دست می دهد. \/\/ در مسیر حرکت شان انگار که با هم برخورد نکرده اند. با این حال، ماشین ها به طور نامحدود محکم و قوی هستند؛ در نتیجه، آنها به حرکت خود ادامه می دهند.\/\/ وقتی که یک ماشین که از چپ به راست حرکت می کند با ماشین دیگری که از راست به چپ حرکت می کند برخورد می کند. همه ماشین ها با سرعت یکسان حرکت می کنند. دو ماشین با هم برخورد می کنند.دو جفت ماشین از راه دور شروع می کنند\/\/ n ماشین از چپ به راست رانندگی می کنند؛ همزمان، یک مجموعه متفاوت از n ماشین \/\/ تصور کنید یک جاده یک خط بی نهایت طولانی و کاملاً مستقیم باشد. func car_race_collision(n: Int) -> Int {\n","canonical_solution":"func car_race_collision(n: Int) -> Int {\n    return n\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(car_race_collision(n: 2) == 4)\nassert(car_race_collision(n: 3) == 9)\nassert(car_race_collision(n: 4) == 16)\nassert(car_race_collision(n: 8) == 64)\nassert(car_race_collision(n: 10) == 100)"},{"task_id":"HumanEval_42","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ آرایه ای با عناصر افزایش یافته به 1 را باز می گرداند. \/\/\/ >>> incr_list(l: [1, 2, 3])\n\/\/\/ [2, 3, 4]\n\/\/\/ >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n","canonical_solution":"func incr_list(l: [Int]) -> [Int] {\n    return l.map { $0 + 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"},{"task_id":"HumanEval_43","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ جمع به صفر و در غیر اینصورت غلط است. \/\/ اگر دو عنصر متمایز در آرایه وجود داشته باشد که \/\/ pairs_sum_to_zero یک آرایه از اعداد صحیح را به عنوان یک ورودی می گیرد. \/\/\/ >>> pairs_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(l: [1])\n\/\/\/ false\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func pairs_sum_to_zero(l: [Int]) -> Bool {\n    var set = Set<Int>()\n    for num in l {\n        if set.contains(-num) {\n            return true\n        }\n        set.insert(num)\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)\nassert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)\nassert(pairs_sum_to_zero(l: [1]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"},{"task_id":"HumanEval_44","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اعداد پایه کمتر از 10 هستند. \/\/ نمایش رشته را پس از تبدیل باز می گرداند. \/\/ پایه عددی عدد x ورودی را به پایه تغییر دهید. \/\/\/ >>> change_base(x: 8, base: 3)\n\/\/\/ \"22\"\n\/\/\/ >>> change_base(x: 8, base: 2)\n\/\/\/ \"1000\"\n\/\/\/ >>> change_base(x: 7, base: 2)\n\/\/\/ \"111\"\nfunc change_base(x: Int, base: Int) -> String {\n","canonical_solution":"func change_base(x: Int, base: Int) -> String {\n    guard base > 1 && base < 10 else {\n        return \"\"\n    }\n    \n    var number = x\n    var result = \"\"\n    \n    repeat {\n        let remainder = number % base\n        result = \"\\(remainder)\" + result\n        number \/= base\n    } while number > 0\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(change_base(x: 8, base: 3) == \"22\")\nassert(change_base(x: 9, base: 3) == \"100\")\nassert(change_base(x: 234, base: 2) == \"11101010\")\nassert(change_base(x: 16, base: 2) == \"10000\")\nassert(change_base(x: 8, base: 2) == \"1000\")\nassert(change_base(x: 7, base: 2) == \"111\")\nassert(change_base(x: 2, base: 3) == \"2\")\nassert(change_base(x: 3, base: 4) == \"3\")\nassert(change_base(x: 4, base: 5) == \"4\")\nassert(change_base(x: 5, base: 6) == \"5\")\nassert(change_base(x: 6, base: 7) == \"6\")\nassert(change_base(x: 7, base: 8) == \"7\")"},{"task_id":"HumanEval_45","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ طول یک طرف و سطح بازگشت بالا برای یک مثلث را داده است. \/\/\/ >>> triangle_area(a: 5, h: 3)\n\/\/\/ 7.5\nfunc triangle_area(a: Int, h: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, h: Int) -> Double {\n    return 0.5 * Double(a) * Double(h)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 5, h: 3) == 7.5)\nassert(triangle_area(a: 2, h: 2) == 2.0)\nassert(triangle_area(a: 10, h: 8) == 40.0)"},{"task_id":"HumanEval_46","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ لطفاً یک تابع برای محاسبه موثر عنصر n-مترتبه دنباله اعداد fib4 بنویسید. از تکرار استفاده نکنید. \/\/ فابریکه ((n) -> فابریکه ((n-1) + فابریکه ((n-2) + فابریکه ((n-3) + فابریکه ((n-4) \/\/ فیب 4 ((3) -> 0 \/\/ فیب 4 ((2) -> 2 \/\/ fib4(1) -> 0 \/\/ فیب 4 ((0) -> 0 \/\/ دنباله اعداد Fib4 یک دنباله مشابه به دنباله فیبوناچی است که به شرح زیر تعریف شده است: \/\/\/ >>> fib4(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fib4(n: 6)\n\/\/\/ 8\n\/\/\/ >>> fib4(n: 7)\n\/\/\/ 14\nfunc fib4(n: Int) -> Int {\n","canonical_solution":"func fib4(n: Int) -> Int {\n    if n == 0 || n == 1 || n == 3 {\n        return 0\n    } else if n == 2 {\n        return 2\n    }\n    \n    var fibs = [0, 0, 2, 0]\n    \n    for i in 4...n {\n        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]\n        fibs.append(nextFib)\n    }\n    \n    return fibs[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib4(n: 5) == 4)\nassert(fib4(n: 8) == 28)\nassert(fib4(n: 10) == 104)\nassert(fib4(n: 12) == 386)"},{"task_id":"HumanEval_47","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ میانه عناصر در آرایه l را باز می گرداند. \/\/\/ >>> median(l: [3, 1, 2, 4, 5])\n\/\/\/ 3\n\/\/\/ >>> median(l: [-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfunc median(l: [Int]) -> Double {\n","canonical_solution":"func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    let count = sorted.count\n    if count % 2 == 0 {\n        return Double(sorted[count \/ 2 - 1] + sorted[count \/ 2]) \/ 2.0\n    } else {\n        return Double(sorted[count \/ 2])\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"},{"task_id":"HumanEval_48","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ بررسی می کند که رشته داده شده یک پالندروم است \/\/\/ >>> is_palindrome(text: \"\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aba\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aaaaa\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"zbcd\")\n\/\/\/ false\nfunc is_palindrome(text: String) -> Bool {\n","canonical_solution":"func is_palindrome(text: String) -> Bool {\n    return text == String(text.reversed())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_palindrome(text: \"\") == true)\nassert(is_palindrome(text: \"aba\") == true)\nassert(is_palindrome(text: \"aaaaa\") == true)\nassert(is_palindrome(text: \"zbcd\") == false)\nassert(is_palindrome(text: \"xywyx\") == true)\nassert(is_palindrome(text: \"xywyz\") == false)\nassert(is_palindrome(text: \"xywzx\") == false)"},{"task_id":"HumanEval_49","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ 2^n مودولو p را باز می گرداند (به اعداد توجه کنید). \/\/\/ >>> modp(n: 3, p: 5)\n\/\/\/ 3\n\/\/\/ >>> modp(n: 1101, p: 101)\n\/\/\/ 2\n\/\/\/ >>> modp(n: 0, p: 101)\n\/\/\/ 1\n\/\/\/ >>> modp(n: 3, p: 11)\n\/\/\/ 8\n\/\/\/ >>> modp(n: 100, p: 101)\n\/\/\/ 1\nfunc modp(n: Int, p: Int) -> Int {\n","canonical_solution":"func modp(n: Int, p: Int) -> Int {\n    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"},{"task_id":"HumanEval_51","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ remove_vowels یک تابع است که رشته را می گیرد و رشته بدون حرف های صوتی را باز می گرداند. \/\/\/ >>> remove_vowels(text: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"abcdef\")\n\/\/\/ \"bcdf\"\n\/\/\/ >>> remove_vowels(text: \"aaaaa\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"aaBAA\")\n\/\/\/ \"B\"\n\/\/\/ >>> remove_vowels(text: \"zbcd\")\n\/\/\/ \"zbcd\"\nfunc remove_vowels(text: String) -> String {\n","canonical_solution":"func remove_vowels(text: String) -> String {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return String(text.filter { !vowels.contains($0) })\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_vowels(text: \"\") == \"\")\nassert(remove_vowels(text: \"abcdef\\nghijklm\") == \"bcdf\\nghjklm\")\nassert(remove_vowels(text: \"fedcba\") == \"fdcb\")\nassert(remove_vowels(text: \"eeeee\") == \"\")\nassert(remove_vowels(text: \"acBAA\") == \"cB\")\nassert(remove_vowels(text: \"EcBOO\") == \"cB\")\nassert(remove_vowels(text: \"ybcd\") == \"ybcd\")"},{"task_id":"HumanEval_52","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اگر تمام اعداد در آرایه l زیر آستانه t باشند، درست را باز می گرداند. \/\/\/ >>> below_threshold(l: [1, 2, 4, 10], t: 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(l: [1, 20, 4, 10], t: 5)\n\/\/\/ false\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n","canonical_solution":"func below_threshold(l: [Int], t: Int) -> Bool {\n    for number in l {\n        if number >= t {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)\nassert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"},{"task_id":"HumanEval_53","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ دو عدد x و y را جمع کنید \/\/\/ >>> add(x: 2, y: 3)\n\/\/\/ 5\n\/\/\/ >>> add(x: 5, y: 7)\n\/\/\/ 12\nfunc add(x: Int, y: Int) -> Int {\n","canonical_solution":"func add(x: Int, y: Int) -> Int {\n    return x + y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(x: 0, y: 1) == 1)\nassert(add(x: 1, y: 0) == 1)\nassert(add(x: 2, y: 3) == 5)\nassert(add(x: 5, y: 7) == 12)\nassert(add(x: 7, y: 5) == 12)"},{"task_id":"HumanEval_54","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ بررسی کنید که آیا دو کلمه دارای کاراکتر های مشابه هستند. \/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"dddddddabc\", s1: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"eabcd\", s1: \"dddddddabc\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabce\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\")\n\/\/\/ false\nfunc same_chars(s0: String, s1: String) -> Bool {\n","canonical_solution":"func same_chars(s0: String, s1: String) -> Bool {\n    let set0 = Set(s0)\n    let set1 = Set(s1)\n    return set0 == set1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\") == true)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabc\") == true)\nassert(same_chars(s0: \"dddddddabc\", s1: \"abcd\") == true)\nassert(same_chars(s0: \"eabcd\", s1: \"dddddddabc\") == false)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabcf\") == false)\nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\") == false)\nassert(same_chars(s0: \"aabb\", s1: \"aaccc\") == false)"},{"task_id":"HumanEval_55","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ عدد n-م فبوناچی را بازگردانید. \/\/\/ >>> fib(n: 10)\n\/\/\/ 55\n\/\/\/ >>> fib(n: 1)\n\/\/\/ 1\n\/\/\/ >>> fib(n: 8)\n\/\/\/ 21\nfunc fib(n: Int) -> Int {\n","canonical_solution":"func fib(n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    }\n    \n    var a = 0\n    var b = 1\n    for _ in 2...n {\n        let temp = a + b\n        a = b\n        b = temp\n    }\n    return b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib(n: 10) == 55)\nassert(fib(n: 1) == 1)\nassert(fib(n: 8) == 21)\nassert(fib(n: 11) == 89)\nassert(fib(n: 12) == 144)"},{"task_id":"HumanEval_56","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اگر هر قوس باز کردن دارای قوس بسته کننده باشد، true را باز می گرداند. \/\/ قوس ها یک رشته از \"<\" و \">\" است. \/\/\/ >>> correct_bracketing(brackets: \"<\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"<>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"<<><>>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"><<>\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    \n    for bracket in brackets {\n        if bracket == \"<\" {\n            balance += 1\n        } else if bracket == \">\" {\n            balance -= 1\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    \n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)"},{"task_id":"HumanEval_57","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ Return true این است که عناصر آرایه به طور یکنواخت افزایش یا کاهش می یابند. \/\/\/ >>> monotonic(l: [1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(l: [1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(l: [4, 1, 0, -10])\n\/\/\/ true\nfunc monotonic(l: [Int]) -> Bool {\n","canonical_solution":"func monotonic(l: [Int]) -> Bool {\n    guard l.count > 1 else {\n        return true\n    }\n    \n    var increasing = true\n    var decreasing = true\n    \n    for i in 1..<l.count {\n        if l[i] > l[i - 1] {\n            decreasing = false\n        } else if l[i] < l[i - 1] {\n            increasing = false\n        }\n    }\n    \n    return increasing || decreasing\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"},{"task_id":"HumanEval_58","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ عناصر مشترک منحصر به فرد مرتب شده را برای دو آرایه باز می گرداند. \/\/\/ >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n\/\/\/ [1, 5, 653]\n\/\/\/ >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n\/\/\/ [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n","canonical_solution":"func common(l1: [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let commonElements = set1.intersection(set2)\n    return Array(commonElements).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_59","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ بزرگترین عامل اول n را برگردانید. فرض کنید n > 1 و یک عدد اول نیست. \/\/\/ >>> largest_prime_factor(n: 13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(n: 2048)\n\/\/\/ 2\nfunc largest_prime_factor(n: Int) -> Int {\n","canonical_solution":"func largest_prime_factor(n: Int) -> Int {\n    var number = n\n    var divisor = 2\n    \n    while number > 1 {\n        if number % divisor == 0 {\n            number \/= divisor\n        } else {\n            divisor += 1\n        }\n    }\n    \n    return divisor\n}\n\n\/\/ Example usage:\n\/\/ print(largest_prime_factor(n: 13195)) \/\/ Output: 29\n\/\/ print(largest_prime_factor(n: 2048))  \/\/ Output: 2","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"},{"task_id":"HumanEval_60","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ sum_to_n یک تابع است که اعداد را از 1 تا n جمع می کند. \/\/\/ >>> sum_to_n(n: 30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(n: 100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(n: 5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(n: 10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(n: 1)\n\/\/\/ 1\nfunc sum_to_n(n: Int) -> Int {\n","canonical_solution":"func sum_to_n(n: Int) -> Int {\n    return (n * (n + 1)) \/ 2\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_to_n(n: 1) == 1)\nassert(sum_to_n(n: 6) == 21)\nassert(sum_to_n(n: 11) == 66)\nassert(sum_to_n(n: 30) == 465)\nassert(sum_to_n(n: 100) == 5050)"},{"task_id":"HumanEval_61","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اگر هر قوس باز کردن دارای قوس بسته کننده باشد، true را باز می گرداند. \/\/ قوس ها یک رشته از \"(\" و \"\") است.\/\/\/ >>> correct_bracketing(brackets: \"(\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"()\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"(()())\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \")(()\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    for char in brackets {\n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)"},{"task_id":"HumanEval_62","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مشتق این چند اصطلاح را به شکل مشابه برگرداند. \/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/ x ها معادل یک چند اصطلاح را نشان می دهند. \/\/\/ >>> derivative(xs: [3, 1, 2, 4, 5])\n\/\/\/ [1, 4, 12, 20]\n\/\/\/ >>> derivative(xs: [1, 2, 3])\n\/\/\/ [2, 6]\nfunc derivative(xs: [Int]) -> [Int] {\n","canonical_solution":"func derivative(xs: [Int]) -> [Int] {\n    guard xs.count > 1 else { return [] }\n    var result: [Int] = []\n    for i in 1..<xs.count {\n        result.append(xs[i] * i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])\nassert(derivative(xs: [1, 2, 3]) == [2, 6])\nassert(derivative(xs: [3, 2, 1]) == [2, 2])\nassert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])\nassert(derivative(xs: [1]) == [] as [Int])"},{"task_id":"HumanEval_63","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ لطفاً یک تابع برای محاسبه موثر عنصر n-مترتبه دنباله اعداد fibfib بنویسید. \/\/ فیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیبوفیب.\/\/ فیب فیب (۲) == ۱ \/\/ فبفب (۱) == 0 \/\/ فیب فیب (۰) == 0 \/\/ دنباله اعداد فیب فیب یک دنباله مشابه به دنباله فیبوناچی است که به شرح زیر تعریف شده است: \/\/\/ >>> fibfib(n: 1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(n: 8)\n\/\/\/ 24\nfunc fibfib(n: Int) -> Int {\n","canonical_solution":"func fibfib(n: Int) -> Int {\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    \n    var fibfibNums = [0, 0, 1]\n    \n    for i in 3...n {\n        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]\n        fibfibNums.append(nextFibFib)\n    }\n    \n    return fibfibNums[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fibfib(n: 2) == 1)\nassert(fibfib(n: 1) == 0)\nassert(fibfib(n: 5) == 4)\nassert(fibfib(n: 8) == 24)\nassert(fibfib(n: 10) == 81)\nassert(fibfib(n: 12) == 274)\nassert(fibfib(n: 14) == 927)"},{"task_id":"HumanEval_64","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ حرف صوتی، اما فقط وقتی که در پایان کلمه داده شده باشد. \/\/ حرف های صوتی در این مورد عبارتند از \"a\"، \"e\"، \"i\"، \"o\"، \"u\". در اینجا، \"y\" نیز یک \/\/ یک کلمه را به عنوان ورودی می گیرد و تعداد حروف صوتی را در رشته باز می گرداند. \/\/ یک تابع vowels_count بنویسید که یک رشته را نشان می دهد \/\/\/ >>> vowels_count(s: \"abcde\")\n\/\/\/ 2\n\/\/\/ >>> vowels_count(s: \"ACEDY\")\n\/\/\/ 3\nfunc vowels_count(s: String) -> Int {\n","canonical_solution":"func vowels_count(s: String) -> Int {\n    guard !s.isEmpty else { return 0 }\n    \n    let vowels = Set(\"aeiouAEIOU\")\n    var count = 0\n    let characters = Array(s)\n    \n    for i in 0..<characters.count {\n        let char = characters[i]\n        \n        if vowels.contains(char) {\n            count += 1\n        } else if char == \"y\" || char == \"Y\" {\n            if i == characters.count - 1 {\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(vowels_count(s: \"abcde\") == 2)\nassert(vowels_count(s: \"Alone\") == 3)\nassert(vowels_count(s: \"key\") == 2)\nassert(vowels_count(s: \"bye\") == 1)\nassert(vowels_count(s: \"keY\") == 2)\nassert(vowels_count(s: \"bYe\") == 1)\nassert(vowels_count(s: \"ACEDY\") == 3)"},{"task_id":"HumanEval_65","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اگر shift > عدد رقم ها باشد، رقم های برگشت معکوس شده است. \/\/ و نتیجه را به شکل یک رشته بازگردانید. \/\/ رقم های دایره ای عدد صحیح x را تغییر دهید، رقم ها را به سمت راست تغییر دهید \/\/\/ >>> circular_shift(x: 12, shift: 1)\n\/\/\/ \"21\"\n\/\/\/ >>> circular_shift(x: 12, shift: 2)\n\/\/\/ \"12\"\nfunc circular_shift(x: Int, shift: Int) -> String {\n","canonical_solution":"func circular_shift(x: Int, shift: Int) -> String {\n    let digits = Array(String(x))\n    let count = digits.count\n    \n    \/\/ If shift is greater than the number of digits, return the digits reversed\n    if shift >= count {\n        return String(digits.reversed())\n    }\n    \n    \/\/ Calculate the actual shift needed by using modulo operation\n    let actualShift = shift % count\n    \n    \/\/ Perform the circular shift to the right\n    let splitIndex = count - actualShift\n    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]\n    \n    return String(shiftedDigits)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(circular_shift(x: 100, shift: 2) == \"001\")\nassert(circular_shift(x: 12, shift: 2) == \"12\")\nassert(circular_shift(x: 97, shift: 8) == \"79\")\nassert(circular_shift(x: 12, shift: 1) == \"21\")\nassert(circular_shift(x: 11, shift: 101) == \"11\")"},{"task_id":"HumanEval_66","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ کدهای ASCII. \/\/ یک تابع بنویسید که یک رشته را به عنوان ورودی می گیرد و فقط مجموع کاراکترهای بالای آن را باز می گرداند' \/\/ وظیفه \/\/\/ >>> digitSum(s: \"\")\n\/\/\/ 0\n\/\/\/ >>> digitSum(s: \"abAB\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"abcCd\")\n\/\/\/ 67\n\/\/\/ >>> digitSum(s: \"helloE\")\n\/\/\/ 69\n\/\/\/ >>> digitSum(s: \"woArBld\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"aAaaaXa\")\n\/\/\/ 153\nfunc digitSum(s: String) -> Int {\n","canonical_solution":"func digitSum(s: String) -> Int {\n    var sum = 0\n    for character in s {\n        if character.isUppercase {\n            sum += Int(character.asciiValue ?? 0)\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digitSum(s: \"\") == 0)\nassert(digitSum(s: \"abAB\") == 131)\nassert(digitSum(s: \"abcCd\") == 67)\nassert(digitSum(s: \"helloE\") == 69)\nassert(digitSum(s: \"woArBld\") == 131)\nassert(digitSum(s: \"aAaaaXa\") == 153)\nassert(digitSum(s: \" How are yOu?\") == 151)\nassert(digitSum(s: \"You arE Very Smart\") == 327)"},{"task_id":"HumanEval_67","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ در سبد عدد میوه های مانگو را در سبد باز می گرداند. \/\/ پرتقال ها و سیب ها و یک عدد صحیح که تعداد کل میوه ها را نشان می دهد \/\/ سیب، پرتقال و میوه های مانگو. با توجه به رشته ای که تعداد کل \/\/ که در یک سبد میوه توزیع شده اند این سبد شامل \/\/ در این کار، یک رشته به شما داده می شود که نشان دهنده تعداد سیب و پرتقال است \/\/\/ >>> fruit_distribution(s: \"5 apples and 6 oranges\", n: 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(s: \"0 apples and 1 oranges\", n: 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(s: \"2 apples and 3 oranges\", n: 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(s: \"100 apples and 1 oranges\", n: 120)\n\/\/\/ 19\nfunc fruit_distribution(s: String, n: Int) -> Int {\n","canonical_solution":"func fruit_distribution(s: String, n: Int) -> Int {\n    let components = s.components(separatedBy: \" \")\n    var apples = 0\n    var oranges = 0\n    \n    for (index, component) in components.enumerated() {\n        if component == \"apples\" || component == \"apple\" {\n            if let number = Int(components[index - 1]) {\n                apples = number\n            }\n        } else if component == \"oranges\" || component == \"orange\" {\n            if let number = Int(components[index - 1]) {\n                oranges = number\n            }\n        }\n    }\n    \n    let totalApplesOranges = apples + oranges\n    let mangoes = n - totalApplesOranges\n    return mangoes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 19) == 8)\nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 21) == 10)\nassert(fruit_distribution(s: \"0 apples and 1 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"1 apples and 0 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 100) == 95)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 5) == 0)\nassert(fruit_distribution(s: \"1 apples and 100 oranges\", n: 120) == 19)"},{"task_id":"HumanEval_68","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال 1: \/\/ اگر هیچ مقدار جفتی وجود نداشته باشد یا آرایه داده شده خالی باشد، return [] را برگردانید. \/\/ گره های انتخاب شده باید در یک آرایه، [smallest_value، index آن]، \/\/ اگر چندین گره با کوچک ترین مقدار جفت یافت شود گره ای را که کوچک ترین شاخص دارد را بازگردانید. \/\/ گره ای که از آن جدا شده باید گره ای با کوچک ترین مقدار جفت باشد. \/\/ وظیفه شما این است که یکی از گره ها را از بین ببرید و آن را برگردانید. \/\/ \"در صورت داشتن یک آرایه که یک شاخه از یک درخت را نشان می دهد که دارای گره های عدد صحیح غیر منفی است \/\/\/ >>> pluck(arr: [4, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(arr: [1, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(arr: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\/\/\/ [0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfunc pluck(arr: [Int]) -> [Int] {\n","canonical_solution":"func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue: Int? = nil\n    var smallestIndex: Int? = nil\n\n    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {\n                smallestEvenValue = value\n                smallestIndex = index\n            }\n        }\n    }\n\n    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {\n        return [smallestEvenValue, smallestIndex]\n    } else {\n        return []\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"},{"task_id":"HumanEval_69","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ اگر چنین ارزشی وجود نداشته باشد، -1 را بازگردانید. \/\/ فرکانس یک عدد صحیح تعداد بار هایی است که در آرایه ظاهر می شود. \/\/ صفر است و دارای فرکانس بزرگتر یا برابر با ارزش عدد صحیح است. \/\/ شما یک آرایه خالی از اعداد صحیح مثبت داده شده است. بزرگترین عدد صحیح را که بزرگتر از  است، برگردانید.\/\/\/ >>> search(lst: [4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(lst: [5, 5, 4, 4, 4])\n\/\/\/ -1\nfunc search(lst: [Int]) -> Int {\n","canonical_solution":"func search(lst: [Int]) -> Int {\n    var frequencyMap = [Int: Int]()\n    \n    \/\/ Count frequencies of each number in the list\n    for number in lst {\n        frequencyMap[number, default: 0] += 1\n    }\n    \n    var result = -1\n    \n    \/\/ Iterate through the frequency map to find the greatest integer that satisfies the condition\n    for (number, frequency) in frequencyMap {\n        if frequency >= number {\n            result = max(result, number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(lst: [5, 5, 5, 5, 1]) == 1)\nassert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)\nassert(search(lst: [3, 3]) == -1)\nassert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)\nassert(search(lst: [2, 3, 3, 2, 2]) == 2)\nassert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\nassert(search(lst: [3, 2, 8, 2]) == 2)\nassert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\nassert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)\nassert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\nassert(search(lst: [1, 9, 10, 1, 3]) == 1)\nassert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\nassert(search(lst: [1]) == 1)\nassert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\nassert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\nassert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\nassert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)\nassert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\nassert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\nassert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\nassert(search(lst: [10]) == -1)\nassert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\nassert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\nassert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\nassert(search(lst: [3, 10, 10, 9, 2]) == -1)"},{"task_id":"HumanEval_70","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ بعد حداکثر عدد های باقیمانده، بعد حداقل و غیره. \/\/ مرتب سازی عجیب، زمانی است که شما با حداقل مقدار شروع می کنید، \/\/ با توجه به آرایه اعداد صحیح، آرایه را در ترتیب عجیب بازگردانید. \/\/\/ >>> strange_sort_list(lst: [1, 2, 3, 4])\n\/\/\/ [1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(lst: [5, 5, 5, 5])\n\/\/\/ [5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(lst: [] as [Int])\n\/\/\/ [] as [Int]\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n","canonical_solution":"func strange_sort_list(lst: [Int]) -> [Int] {\n    var sortedList = lst.sorted()\n    var result: [Int] = []\n    \n    while !sortedList.isEmpty {\n        if let min = sortedList.first {\n            result.append(min)\n            sortedList.removeFirst()\n        }\n        \n        if let max = sortedList.last {\n            result.append(max)\n            sortedList.removeLast()\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"},{"task_id":"HumanEval_71","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ از طرف سوم. \/\/ سه طرف یک مثلث معتبر را تشکیل میدهند وقتی که مجموع هر دو طرف بزرگتر باشد \/\/ در غیر اینصورت -1 را باز می گرداند\/\/ مثلث به دو نقطه اعشار اگر سه طرف یک مثلث معتبر را تشکیل دهند. \/\/ طول های سه طرف مثلث را داده شده. مساحت  را برگردانید.\/\/\/ >>> triangle_area(a: 3, b: 4, c: 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(a: 1, b: 2, c: 10)\n\/\/\/ -1\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, b: Int, c: Int) -> Double {\n    \/\/ Check if the sides form a valid triangle\n    if a + b > c && a + c > b && b + c > a {\n        \/\/ Calculate the semi-perimeter\n        let s = Double(a + b + c) \/ 2.0\n        \/\/ Calculate the area using Heron's formula\n        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))\n        \/\/ Round to 2 decimal places\n        return round(area * 100) \/ 100\n    } else {\n        return -1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 3, b: 4, c: 5) == 6.0)\nassert(triangle_area(a: 1, b: 2, c: 10) == -1)\nassert(triangle_area(a: 4, b: 8, c: 5) == 8.18)\nassert(triangle_area(a: 2, b: 2, c: 2) == 1.73)\nassert(triangle_area(a: 1, b: 2, c: 3) == -1)\nassert(triangle_area(a: 10, b: 5, c: 7) == 16.25)\nassert(triangle_area(a: 2, b: 6, c: 3) == -1)\nassert(triangle_area(a: 1, b: 1, c: 1) == 0.43)\nassert(triangle_area(a: 2, b: 2, c: 10) == -1)"},{"task_id":"HumanEval_72","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ اگر شیء q متعادل باشد (این یک آرایه پالندروم است) و مجموع عناصر آن کمتر از یا برابر با حداکثر وزن ممکن w باشد پرواز خواهد کرد. \/\/ یک تابع بنویسید که اگر شیء q پرواز کند درست و در غیر این صورت غلط را باز می گرداند. \/\/\/ >>> will_it_fly(q: [1, 2], w: 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(q: [3], w: 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int], w: Int) -> Bool {\n","canonical_solution":"func will_it_fly(q: [Int], w: Int) -> Bool {\n    func isPalindromic(_ array: [Int]) -> Bool {\n        return array == array.reversed()\n    }\n    \n    let sum = q.reduce(0, +)\n    return isPalindromic(q) && sum <= w\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"},{"task_id":"HumanEval_73","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ به همان شکل به جلو و عقب خوانده می شود. در یک تغییر، شما می توانید یک عنصر را به هر عنصر دیگر تغییر دهید. \/\/ برای ایجاد آرایه پالندروم باید تغییر کند. یک آرایه پالندروم یک آرایه است که \/\/ با توجه به یک آرایه ار از اعداد صحیح، حداقل تعداد عناصر را پیدا کنید که \/\/\/ >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 2, 1])\n\/\/\/ 0\nfunc smallest_change(arr: [Int]) -> Int {\n","canonical_solution":"func smallest_change(arr: [Int]) -> Int {\n    var changes = 0\n    let n = arr.count\n\n    for i in 0..<(n \/ 2) {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1\n        }\n    }\n\n    return changes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)\nassert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)\nassert(smallest_change(arr: [3, 1, 1, 3]) == 0)\nassert(smallest_change(arr: [1]) == 0)\nassert(smallest_change(arr: [0, 1]) == 1)"},{"task_id":"HumanEval_74","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها \/\/ اگر دو آرایه دارای تعداد کاراکتر یکسان باشند، اولین آرایه را بازگردانید. \/\/ تعداد کل کار ها در تمام رشته های آرایه کمتر از آرایه دیگر است. \/\/ یک تابع بنویسید که دو آرایه رشته را قبول کند و آرایه ای را که دارای \/\/\/ >>> total_match(lst1: [] as [String], lst2: [] as [String])\n\/\/\/ [] as [String]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"])\n\/\/\/ [\"hI\", \"Hi\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/\/ [\"hi\", \"admin\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"])\n\/\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/\/ >>> total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/\/ [\"4\"]\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n","canonical_solution":"func total_match(lst1: [String], lst2: [String]) -> [String] {\n    let totalChars1 = lst1.reduce(0) { $0 + $1.count }\n    let totalChars2 = lst2.reduce(0) { $0 + $1.count }\n    \n    if totalChars1 < totalChars2 {\n        return lst1\n    } else if totalChars2 < totalChars1 {\n        return lst2\n    } else {\n        return lst1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"]) == [\"4\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [] as [String], lst2: [\"this\"]) == [] as [String])\nassert(total_match(lst1: [\"this\"], lst2: [] as [String]) == [] as [String])"},{"task_id":"HumanEval_75","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ با دانستن اینکه (a) کمتر از 100 است. \/\/ و در غیر اینصورت غلط است. \/\/ یک تابع بنویسید که اگر عدد داده شده ضرب 3 عدد اول باشد درست را باز می گرداند \/\/\/ >>> is_multiply_prime(a: 30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a: Int) -> Bool {\n","canonical_solution":"func is_multiply_prime(a: Int) -> Bool {\n    \/\/ Function to check if a number is prime\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Generate all prime numbers less than 100\n    var primes = [Int]()\n    for i in 2..<100 {\n        if isPrime(i) {\n            primes.append(i)\n        }\n    }\n    \n    \/\/ Check combinations of 3 primes\n    let primeCount = primes.count\n    for i in 0..<primeCount {\n        for j in i..<primeCount {\n            for k in j..<primeCount {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_multiply_prime(a: 5) == false)\nassert(is_multiply_prime(a: 30) == true)\nassert(is_multiply_prime(a: 8) == true)\nassert(is_multiply_prime(a: 10) == false)\nassert(is_multiply_prime(a: 125) == true)\nassert(is_multiply_prime(a: 105) == true)\nassert(is_multiply_prime(a: 126) == false)\nassert(is_multiply_prime(a: 729) == false)\nassert(is_multiply_prime(a: 891) == false)\nassert(is_multiply_prime(a: 1001) == true)"},{"task_id":"HumanEval_76","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ x یک توان ساده از n است اگر n**int=x \/\/ قدرت n و در موارد دیگر غلط است. \/\/ وظیفه شما این است که یک تابع بنویسید که اگر یک عدد x یک عدد ساده باشد راست را باز می گرداند.\/\/\/ >>> is_simple_power(x: 1, n: 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 2, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 8, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 3, n: 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 3, n: 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 5, n: 3)\n\/\/\/ false\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n","canonical_solution":"func is_simple_power(x: Int, n: Int) -> Bool {\n    if x < 1 || n < 1 {\n        return false\n    }\n    if x == 1 {\n        return true \/\/ n**0 = 1\n    }\n    var power = 1\n    while power < x {\n        power *= n\n    }\n    return power == x\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_simple_power(x: 16, n: 2) == true)\nassert(is_simple_power(x: 143214, n: 16) == false)\nassert(is_simple_power(x: 4, n: 2) == true)\nassert(is_simple_power(x: 9, n: 3) == true)\nassert(is_simple_power(x: 16, n: 4) == true)\nassert(is_simple_power(x: 24, n: 2) == false)\nassert(is_simple_power(x: 128, n: 4) == false)\nassert(is_simple_power(x: 12, n: 6) == false)\nassert(is_simple_power(x: 1, n: 1) == true)\nassert(is_simple_power(x: 1, n: 12) == true)"},{"task_id":"HumanEval_77","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ توجه: شما ممکن است فرض کنید که ورودی همیشه معتبر است. \/\/ اگر این عدد یک مکعب از یک عدد صحیح باشد. \/\/ یک تابع بنویسید که یک عدد صحیح a را می گیرد و true را باز می گرداند \/\/\/ >>> iscube(a: 1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 2)\n\/\/\/ false\n\/\/\/ >>> iscube(a: -1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 64)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 0)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 180)\n\/\/\/ false\nfunc iscube(a: Int) -> Bool {\n","canonical_solution":"func iscube(a: Int) -> Bool {\n    if a == 0 { return true } \/\/ 0 is a cube (0^3)\n    let absA = abs(a)\n    let cubeRoot = Int(round(pow(Double(absA), 1.0\/3.0)))\n    return cubeRoot * cubeRoot * cubeRoot == absA\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(iscube(a: 1) == true)\nassert(iscube(a: 2) == false)\nassert(iscube(a: -1) == true)\nassert(iscube(a: 64) == true)\nassert(iscube(a: 180) == false)\nassert(iscube(a: 1000) == true)\nassert(iscube(a: 0) == true)\nassert(iscube(a: 1729) == false)"},{"task_id":"HumanEval_78","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ و نمادها A،B،C،D،E،F همیشه بزرگ هستند. \/\/ توجه: شما ممکن است فرض کنید که ورودی همیشه صحیح یا خالی است رشته, \/\/ B (= دهمی 11) ، D (= دهمی 13) \/\/ پس شما باید یک عدد از رقم های زیر را تعیین کنید: 2, 3, 5, 7, \/\/ اعداد اول عبارتند از 2، 3، 5، 7، 11، 13، 17، ...\/\/ رقم های هگزادسیمال 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، A، B، C، D، E، F هستند. \/\/ بزرگتر از 1 که محصول دو عدد طبیعی کوچکتر نیست).\/\/ عددی که اعداد اولی هستند (عدد اولی یا یک عدد اول یک عدد طبیعی است \/\/ یک عدد هگزادسیمال به عنوان یک رشته و تعداد هگزادسیمال ها را می شمارد \/\/ شما وظیفه دارید تا یک تابع را بنویسید که دریافت کننده باشد \/\/\/ >>> hex_key(num: \"AB\")\n\/\/\/ 1\n\/\/\/ >>> hex_key(num: \"1077E\")\n\/\/\/ 2\n\/\/\/ >>> hex_key(num: \"ABED1A33\")\n\/\/\/ 4\n\/\/\/ >>> hex_key(num: \"123456789ABCDEF0\")\n\/\/\/ 6\n\/\/\/ >>> hex_key(num: \"2020\")\n\/\/\/ 2\nfunc hex_key(num: String) -> Int {\n","canonical_solution":"func hex_key(num: String) -> Int {\n    \/\/ Define hexadecimal digits that are prime numbers\n    let primeHexDigits: Set<Character> = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    \n    \/\/ Initialize count\n    var primeCount = 0\n    \n    \/\/ Iterate over each character in the string\n    for char in num {\n        \/\/ Check if the character is a prime hexadecimal digit\n        if primeHexDigits.contains(char) {\n            primeCount += 1\n        }\n    }\n    \n    return primeCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"},{"task_id":"HumanEval_79","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ حروف اضافی برای کمک به شکل بندی وجود دارد. \/\/ یک جفت کاراکتر اضافی \"db\" در آغاز و پایان رشته وجود خواهد داشت. \/\/ عدد. هر کاراکتر در رشته \"۰\" یا \"۱\" خواهد بود. \/\/ فرمت باینری. تابع باید یک رشته را برگرداند، که هر کاراکتر یک باینری را نشان می دهد \/\/ شما یک عدد در شکل اعشاری داده می شود و وظیفه شما تبدیل آن به \/\/\/ >>> decimal_to_binary(decimal: 15)\n\/\/\/ \"db1111db\"\n\/\/\/ >>> decimal_to_binary(decimal: 32)\n\/\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal: Int) -> String {\n","canonical_solution":"func decimal_to_binary(decimal: Int) -> String {\n    let binaryString = String(decimal, radix: 2)\n    return \"db\" + binaryString + \"db\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(decimal_to_binary(decimal: 0) == \"db0db\")\nassert(decimal_to_binary(decimal: 32) == \"db100000db\")\nassert(decimal_to_binary(decimal: 103) == \"db1100111db\")\nassert(decimal_to_binary(decimal: 15) == \"db1111db\")"},{"task_id":"HumanEval_80","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ یک رشته اگر حداقل 3 طول داشته باشد و هر 3 حرف متوالی متمایز باشد ، سریع است .\/\/ وظیفه شما این است که بررسی کنید که رشته ها سریع هستند یا نه. \/\/ شما یک رشته s داده شده است. \/\/\/ >>> is_happy(s: \"a\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"aa\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"aabb\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"adb\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"xyy\")\n\/\/\/ false\nfunc is_happy(s: String) -> Bool {\n","canonical_solution":"func is_happy(s: String) -> Bool {\n    let characters = Array(s)\n    if characters.count < 3 {\n        return false\n    }\n    \n    for i in 0..<(characters.count - 2) {\n        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"},{"task_id":"HumanEval_81","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ 0.0 E \/\/ > 0.0 D- \/\/ > 0.7 D \/\/ > 1.0 D+ \/\/ > 1.3 C- \/\/ > 1.7 سانتی گراد \/\/ > 2.0 سانتی گراد+ \/\/ > 2.3 B- \/\/ > 2.7 B \/\/ > 3.0 B+ \/\/ > 3.3 A- \/\/ > 3.7 A \/\/ 4.0 A+ نمره متوسط. درجه های حرفی\/\/ یک تابع که می تواند یک آرایه از درجه های حروف را با استفاده از جدول زیر تولید کند: \/\/ اون برای بعضی از دانش آموزان به شما مجموعه ای از نمرات داده است و شما باید بنویسید تنها مشکل اینه که، اون کد مورد استفاده اش برای نمره گذاری را گم کرده است.\/\/ به دانش آموزان. معلم الگوریتم خود را برای رتبه بندی ایجاد کرده است. \/\/ این هفته آخر ترم است و معلم باید نمرات را بدهد \/\/\/ >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])\n\/\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n","canonical_solution":"func numerical_letter_grade(grades: [Double]) -> [String] {\n    return grades.map { gpa in\n        switch gpa {\n        case 4.0:\n            return \"A+\"\n        case 3.7...4.0:\n            return \"A\"\n        case 3.3..<3.7:\n            return \"A-\"\n        case 3.0..<3.3:\n            return \"B+\"\n        case 2.7..<3.0:\n            return \"B\"\n        case 2.3..<2.7:\n            return \"B-\"\n        case 2.0..<2.3:\n            return \"C+\"\n        case 1.7..<2.0:\n            return \"C\"\n        case 1.3..<1.7:\n            return \"C-\"\n        case 1.0..<1.3:\n            return \"D+\"\n        case 0.7..<1.0:\n            return \"D\"\n        case 0.0..<0.7:\n            return \"D-\"\n        default:\n            return \"E\"\n        }\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\nassert(numerical_letter_grade(grades: [1.2]) == [\"D+\"])\nassert(numerical_letter_grade(grades: [0.5]) == [\"D-\"])\nassert(numerical_letter_grade(grades: [0.0]) == [\"E\"])\nassert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\nassert(numerical_letter_grade(grades: [0.0, 0.7]) == [\"E\", \"D-\"])"},{"task_id":"HumanEval_82","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها \/\/ طول یک عدد اول است و در غیر اینصورت غلط است \/\/ یک تابع بنویسید که یک رشته را می گیرد و اگر رشته \/\/\/ >>> prime_length(string: \"Hello\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"abcdcba\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"kittens\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"orange\")\n\/\/\/ false\nfunc prime_length(string: String) -> Bool {\n","canonical_solution":"func prime_length(string: String) -> Bool {\n    let length = string.count\n    \n    guard length > 1 else {\n        return false\n    }\n    \n    for i in 2..<length {\n        if length % i == 0 {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_length(string: \"Hello\") == true)\nassert(prime_length(string: \"abcdcba\") == true)\nassert(prime_length(string: \"kittens\") == true)\nassert(prime_length(string: \"orange\") == false)\nassert(prime_length(string: \"wow\") == true)\nassert(prime_length(string: \"world\") == true)\nassert(prime_length(string: \"MadaM\") == true)\nassert(prime_length(string: \"Wow\") == true)\nassert(prime_length(string: \"\") == false)\nassert(prime_length(string: \"HI\") == true)\nassert(prime_length(string: \"go\") == true)\nassert(prime_length(string: \"gogo\") == false)\nassert(prime_length(string: \"aaaaaaaaaaaaaaa\") == false)\nassert(prime_length(string: \"Madam\") == true)\nassert(prime_length(string: \"M\") == false)\nassert(prime_length(string: \"0\") == false)"},{"task_id":"HumanEval_83","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ عدد های صحیح مثبت که با 1 شروع یا به پایان می رسند. \/\/ با یک عدد صحیح مثبت n، تعداد اعداد n-عددی را برگردانید func starts_one_ends(n: Int) -> Int {\n","canonical_solution":"func starts_one_ends(n: Int) -> Int {\n    if n == 1 {\n        \/\/ For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.\n        return 1\n    }\n    \n    \/\/ Count of n-digit numbers starting with 1:\n    \/\/ First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.\n    let startWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Count of n-digit numbers ending with 1:\n    \/\/ Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.\n    \/\/ So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.\n    let endWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Intersection of both sets is the numbers starting and ending with 1\n    \/\/ which are of the form `1` followed by (n-2) digits and `1`, so:\n    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))\n    \n    return startWithOne + endWithOne - startAndEndWithOne\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n: 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4) == 1800)\nassert(starts_one_ends(n: 5) == 18000)"},{"task_id":"HumanEval_84","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال \/\/ با یک عدد صحیح مثبت N، مجموع رقم های آن را در دوگانه بازگردانید. \/\/\/ >>> solve(N: 1000)\n\/\/\/ \"1\"\n\/\/\/ >>> solve(N: 150)\n\/\/\/ \"110\"\n\/\/\/ >>> solve(N: 147)\n\/\/\/ \"1100\"\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfunc solve(N: Int) -> String {\n","canonical_solution":"func solve(N: Int) -> String {\n    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    return String(sumOfDigits, radix: 2)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"},{"task_id":"HumanEval_85","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ با توجه به یک آرایه غیر خالی از اعداد صحیح lst. عناصر جفت را که در شاخص های عجیب هستند اضافه کنید .. \/\/\/ >>> add(lst: [4, 2, 6, 7])\n\/\/\/ 2\nfunc add(lst: [Int]) -> Int {\n","canonical_solution":"func add(lst: [Int]) -> Int {\n    var sum = 0\n    for i in stride(from: 1, to: lst.count, by: 2) {\n        if lst[i] % 2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(lst: [4, 88]) == 88)\nassert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)\nassert(add(lst: [4, 0, 6, 7]) == 0)\nassert(add(lst: [4, 4, 6, 8]) == 12)"},{"task_id":"HumanEval_86","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ توجه: شما باید ترتیب کلمات و فضای خالی را در جمله حفظ کنید. \/\/ ترتیب صعودی بر اساس ارزش ascii. \/\/ با یک کلمه جدید جایگزین می شوند که در آن تمام کاراکترها در  ترتیب داده شده اند\/\/ نسخه مرتب شده رشته، یک رشته است که در آن تمام کلمات (با فضای جدا شده) \/\/ یک تابع بنویسید که یک رشته را می گیرد و یک نسخه مرتب شده از آن را باز می گرداند. \/\/\/ >>> anti_shuffle(s: \"Hi\")\n\/\/\/ \"Hi\"\n\/\/\/ >>> anti_shuffle(s: \"hello\")\n\/\/\/ \"ehllo\"\n\/\/\/ >>> anti_shuffle(s: \"Hello World!!!\")\n\/\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s: String) -> String {\n","canonical_solution":"func anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy: .whitespaces)\n    let orderedWords = words.map { String($0.sorted()) }\n    var result = \"\"\n    var wordIndex = 0\n    \n    for character in s {\n        if character.isWhitespace {\n            result.append(character)\n        } else if wordIndex < orderedWords.count {\n            if let currentWord = orderedWords[wordIndex].first {\n                result.append(currentWord)\n                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)\n            }\n        }\n        \n        if let lastCharacter = result.last {\n            if lastCharacter.isWhitespace {\n                wordIndex += 1\n            }\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"},{"task_id":"HumanEval_87","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ همچنین، مختصات ردیف را به ترتیب ستون ها در ترتیب نزولی مرتب کنید. \/\/ مختصات را در ابتدا به ترتیب بالا رفتن در ردیف ها مرتب کنید. \/\/ هر توپل یک مختصات است - (صف، ستون) ، با 0 شروع می شود. \/\/ و آرایه tuples را برگرداند، [(x1، y1، (x2، y2) ...] طوری که \/\/ با توجه به lst، و عدد صحیح x، عدد های صحیح x را در آرایه پیدا کنید، \/\/ هر ردیف ممکن است شامل تعداد ستون های مختلف باشد. \/\/ که شبیه به ماتریس است، اما برخلاف ماتریس ها، \/\/ شما یک داده دو بعدی به عنوان یک آرایه ی آشیانه ای داده می شوید، \/\/\/ >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n\/\/\/ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(lst: [] as [[Int]], x: 1)\n\/\/\/ [] as [(Int, Int)]\n\/\/\/ >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)\n\/\/\/ [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n","canonical_solution":"func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var coordinates: [(Int, Int)] = []\n    \n    for (rowIndex, row) in lst.enumerated() {\n        for (colIndex, value) in row.enumerated() {\n            if value == x {\n                coordinates.append((rowIndex, colIndex))\n            }\n        }\n    }\n    \n    let sortedCoordinates = coordinates.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n        } else {\n            return $0.0 < $1.0\n        }\n    }\n    \n    return sortedCoordinates\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"},{"task_id":"HumanEval_88","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ * آرایه داده شده را تغییر ندهید. \/\/ یادداشت: \/\/ یا آن را به ترتیب رو به پایین اگر مجموع ((قیمت شاخص اول، ارزش شاخص آخر) حتی باشد. \/\/ شما آرایه داده شده را به ترتیب رو به افزایش مرتب خواهید کرد اگر مجموع ((قیمت شاخص اول، ارزش شاخص آخر) عجیب باشد، \/\/ با یک آرایه از اعداد صحیح غیر منفی، یک coswift از آرایه داده شده را پس از مرتب سازی، \/\/\/ >>> sort_array(array: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ >>> sort_array(array: [5])\n\/\/\/ [5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5])\n\/\/\/ [0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])\n\/\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunc sort_array(array: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(array: [Int]) -> [Int] {\n    guard let first = array.first, let last = array.last else {\n        return array\n    }\n    let sum = first + last\n    if sum % 2 == 0 {\n        return array.sorted(by: >) \/\/ Descending order\n    } else {\n        return array.sorted() \/\/ Ascending order\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(array: [] as [Int]) == [] as [Int])\nassert(sort_array(array: [5]) == [5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\nassert(sort_array(array: [2, 1]) == [1, 2])\nassert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\nassert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"},{"task_id":"HumanEval_89","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ دو برابر دو تا به دو مکان پایین حرکت می کند. \/\/ الفبای باید به گونه ای چرخش یابد که حروف \/\/ یک رشته رمزگذاری شده را با چرخش الفبا باز می گرداند. \/\/ یک تابع رمزگذاری ایجاد کنید که یک رشته را به عنوان یک استدلال می گیرد و \/\/\/ >>> encrypt(s: \"hi\")\n\/\/\/ \"lm\"\n\/\/\/ >>> encrypt(s: \"asdfghjkl\")\n\/\/\/ \"ewhjklnop\"\n\/\/\/ >>> encrypt(s: \"gf\")\n\/\/\/ \"kj\"\n\/\/\/ >>> encrypt(s: \"et\")\n\/\/\/ \"ix\"\nfunc encrypt(s: String) -> String {\n","canonical_solution":"func encrypt(s: String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let shift = 2 * 2 \/\/ shift down by two multiplied by two places, i.e., 4\n    var result = \"\"\n\n    for character in s {\n        if let index = alphabet.firstIndex(of: character) {\n            let newIndex = (index + shift) % alphabet.count\n            result.append(alphabet[newIndex])\n        } else {\n            result.append(character) \/\/ append non-alphabetic characters unchanged\n        }\n    }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") == \"e\")"},{"task_id":"HumanEval_90","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اگر چنین عنصر وجود نداشته باشد، null را باز می گرداند. \/\/ یک تابع next_smallest (() بنویسید که کوچک ترین عنصر دوم آرایه را باز می گرداند. \/\/ شما یک آرایه از اعداد صحیح داده شده است. \/\/\/ >>> next_smallest(lst: [1, 2, 3, 4, 5])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [] as [Int])\n\/\/\/ nil\n\/\/\/ >>> next_smallest(lst: [1, 1])\n\/\/\/ nil\nfunc next_smallest(lst: [Int]) -> Int? {\n","canonical_solution":"func next_smallest(lst: [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    \n    var uniqueSorted = Array(Set(lst)).sorted()\n    \n    if uniqueSorted.count < 2 {\n        return nil\n    }\n    \n    return uniqueSorted[1]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"},{"task_id":"HumanEval_91","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ جملات با \" \" ، \" \" یا \" \" محدود می شوند.یک حوصله بی حوصله یک جمله است که با کلمه \"من\" شروع می شود.\/\/ شما یک رشته از کلمات به شما داده می شود، و وظیفه شما شمارش اعداد است \/\/\/ >>> is_bored(S: \"Hello world\")\n\/\/\/ 0\n\/\/\/ >>> is_bored(S: \"The sky is blue. The sun is shining. I love this weather\")\n\/\/\/ 1\nfunc is_bored(S: String) -> Int {\n","canonical_solution":"func is_bored(S: String) -> Int {\n    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }\n    var boredomCount = 0\n    \n    for sentence in sentences {\n        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)\n        if trimmedSentence.hasPrefix(\"I\") {\n            boredomCount += 1\n        }\n    }\n    \n    return boredomCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_bored(S: \"Hello world\") == 0)\nassert(is_bored(S: \"Is the sky blue?\") == 0)\nassert(is_bored(S: \"I love It !\") == 1)\nassert(is_bored(S: \"bIt\") == 0)\nassert(is_bored(S: \"I feel good today. I will be productive. will kill It\") == 2)\nassert(is_bored(S: \"You and I are going for a walk\") == 0)"},{"task_id":"HumanEval_92","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها \/\/ در هر مورد دیگر false را باز می گرداند. \/\/ اگر یکی از اعداد برابر با مجموع دو عدد دیگر باشد و تمام اعداد اعداد صحیح باشند، درست را باز می گرداند. \/\/ یک تابع ایجاد کنید که 3 عدد را می گیرد. \/\/\/ >>> any_int(x: 5, y: 2, z: 7)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3, y: 2, z: 2)\n\/\/\/ false\n\/\/\/ >>> any_int(x: 3, y: -2, z: 1)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3.6, y: -2.2, z: 2)\n\/\/\/ false\nfunc any_int(x: Double, y: Double, z: Double) -> Bool {\n","canonical_solution":"func any_int(x: Double, y: Double, z: Double) -> Bool {\n    guard x == floor(x), y == floor(y), z == floor(z) else {\n        return false\n    }\n    \n    let a = Int(x)\n    let b = Int(y)\n    let c = Int(z)\n    \n    return a == b + c || b == a + c || c == a + b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(any_int(x: 2, y: 3, z: 1) == true)\nassert(any_int(x: 2.5, y: 2, z: 3) == false)\nassert(any_int(x: 1.5, y: 5, z: 3.5) == false)\nassert(any_int(x: 2, y: 6, z: 2) == false)\nassert(any_int(x: 4, y: 2, z: 2) == true)\nassert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)\nassert(any_int(x: -4, y: 6, z: 2) == true)\nassert(any_int(x: 2, y: 1, z: 1) == true)\nassert(any_int(x: 3, y: 4, z: 7) == true)\nassert(any_int(x: 3.0, y: 4, z: 7) == false)"},{"task_id":"HumanEval_93","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ فقط حروف را فرض کنید. \/\/ یک حرف در الفبای انگلیسی است. \/\/ پیام با حروف که دو جای قبل از آن ظاهر می شود \/\/ به طوری که همه حروف را عوض می کند و همه حروف صوتی را در \/\/ یک تابع بنویسید که یک پیام را دریافت کند و آن را در چنین \/\/\/ >>> encode(message: \"test\")\n\/\/\/ \"TGST\"\n\/\/\/ >>> encode(message: \"This is a message\")\n\/\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n","canonical_solution":"func encode(message: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    let vowelReplacement = [\n        \"a\": \"c\", \"e\": \"g\", \"i\": \"k\", \"o\": \"q\", \"u\": \"w\",\n        \"A\": \"C\", \"E\": \"G\", \"I\": \"K\", \"O\": \"Q\", \"U\": \"W\"\n    ]\n    \n    var encodedMessage = \"\"\n    \n    for char in message {\n        if vowels.contains(char) {\n            if let replacement = vowelReplacement[String(char)] {\n                encodedMessage.append(replacement)\n            }\n        } else {\n            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())\n            encodedMessage.append(swappedCase)\n        }\n    }\n    \n    return encodedMessage\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"},{"task_id":"HumanEval_94","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ شما باید بزرگترین مقدار اول را پیدا کنید و جمع رقم های آن را برگردانید. \/\/ شما یک آرایه از اعداد صحیح داده شده است. \/\/\/ >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfunc skjkasdkd(lst: [Int]) -> Int {\n","canonical_solution":"func skjkasdkd(lst: [Int]) -> Int {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    var largestPrime: Int? = nil\n    for number in lst {\n        if isPrime(number) {\n            if largestPrime == nil || number > largestPrime! {\n                largestPrime = number\n            }\n        }\n    }\n    \n    if let largestPrime = largestPrime {\n        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    }\n    \n    return 0 \/\/ In case there are no prime numbers\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)\nassert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)\nassert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)\nassert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)\nassert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)\nassert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)\nassert(skjkasdkd(lst: [8191]) == 19)\nassert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)\nassert(skjkasdkd(lst: [127, 97, 8192]) == 10)"},{"task_id":"HumanEval_96","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ عدد های صحیح که اعداد اول هستند و کمتر از n هستند. \/\/ یک تابع را اجرا کنید که یک عدد صحیح غیر منفی را می گیرد و یک آرایه از n اول را باز می گرداند .\/\/\/ >>> count_up_to(n: 5)\n\/\/\/ [2, 3]\n\/\/\/ >>> count_up_to(n: 11)\n\/\/\/ [2, 3, 5, 7]\n\/\/\/ >>> count_up_to(n: 0)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 20)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(n: 1)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 18)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunc count_up_to(n: Int) -> [Int] {\n","canonical_solution":"func count_up_to(n: Int) -> [Int] {\n    guard n > 2 else { return [] }\n    \n    var primes: [Int] = [2]\n    \n    for number in 3..<n {\n        var isPrime = true\n        for prime in primes {\n            if prime * prime > number {\n                break\n            }\n            if number % prime == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes.append(number)\n        }\n    }\n    \n    return primes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_up_to(n: 5) == [2, 3])\nassert(count_up_to(n: 6) == [2, 3, 5])\nassert(count_up_to(n: 7) == [2, 3, 5])\nassert(count_up_to(n: 10) == [2, 3, 5, 7])\nassert(count_up_to(n: 0) == [] as [Int])\nassert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])\nassert(count_up_to(n: 1) == [] as [Int])\nassert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])\nassert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\nassert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"},{"task_id":"HumanEval_97","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ فرض کنید که ورودی همیشه معتبر است. \/\/ ضرب ارقام واحد آنها. \/\/ تابع را که دو عدد صحیح را می گیرد تکمیل کنید و  را برگردانید\/\/\/ >>> multiply(a: 148, b: 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(a: 19, b: 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(a: 2020, b: 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(a: 14, b: -15)\n\/\/\/ 20\nfunc multiply(a: Int, b: Int) -> Int {\n","canonical_solution":"func multiply(a: Int, b: Int) -> Int {\n    let unitDigitA = abs(a % 10)\n    let unitDigitB = abs(b % 10)\n    return unitDigitA * unitDigitB\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply(a: 148, b: 412) == 16)\nassert(multiply(a: 19, b: 28) == 72)\nassert(multiply(a: 2020, b: 1851) == 0)\nassert(multiply(a: 14, b: -15) == 20)\nassert(multiply(a: 76, b: 67) == 42)\nassert(multiply(a: 17, b: 27) == 49)\nassert(multiply(a: 0, b: 1) == 0)\nassert(multiply(a: 0, b: 0) == 0)"},{"task_id":"HumanEval_98","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ با توجه به یک رشته s، تعداد حروف بلند بزرگ را در شاخص های جفت بشمارید. \/\/\/ >>> count_upper(s: \"aBCdEf\")\n\/\/\/ 1\n\/\/\/ >>> count_upper(s: \"abcdefg\")\n\/\/\/ 0\n\/\/\/ >>> count_upper(s: \"dBBE\")\n\/\/\/ 0\nfunc count_upper(s: String) -> Int {\n","canonical_solution":"func count_upper(s: String) -> Int {\n    let upperVowels = Set<Character>([\"A\", \"E\", \"I\", \"O\", \"U\"])\n    var count = 0\n\n    for (index, char) in s.enumerated() {\n        if index % 2 == 0 && upperVowels.contains(char) {\n            count += 1\n        }\n    }\n\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"},{"task_id":"HumanEval_99","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها \/\/ از دو عدد کامل، آن را دور از صفر گرد کنیم. \/\/ و نزدیک ترین عدد صحیح را به آن باز می گرداند. اگر عدد مساوی با فاصله باشد \/\/ یک تابع ایجاد کنید که یک مقدار (سلسله) را که یک عدد را نشان می دهد را می گیرد \/\/\/ >>> closest_integer(value: \"10\")\n\/\/\/ 10\n\/\/\/ >>> closest_integer(value: \"15.3\")\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n","canonical_solution":"func closest_integer(value: String) -> Int {\n    if let number = Double(value) {\n        return Int(number.rounded(.awayFromZero))\n    }\n    return 0 \/\/ or handle error as needed\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"},{"task_id":"HumanEval_100","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ i نشان دهنده تعداد سنگ ها در سطح (i+1) است. \/\/ تعداد سنگ ها را در هر سطح در یک آرایه، که عنصر در شاخص \/\/ - عدد بعدی اگر n عدد جفت باشد. \/\/ - عدد بعدی اگر n عدد عجیب باشد. \/\/ تعداد سنگ ها در سطح بعدی: \/\/ سطح اول دارای n سنگ است. \/\/ با یک عدد صحیح مثبت n، شما باید یک انبار از n سطح سنگ بسازید. \/\/\/ >>> make_a_pile(n: 3)\n\/\/\/ [3, 5, 7]\nfunc make_a_pile(n: Int) -> [Int] {\n","canonical_solution":"func make_a_pile(n: Int) -> [Int] {\n    var pile = [Int]()\n    var currentLevelStones = n\n    \n    for _ in 0..<n {\n        pile.append(currentLevelStones)\n        if n % 2 == 0 {\n            currentLevelStones += 2\n        } else {\n            currentLevelStones += 2\n        }\n    }\n    \n    return pile\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n: 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"},{"task_id":"HumanEval_101","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ برای تقسیم رشته به کلمات و بازگشت یک آرایه از کلمات. \/\/ شما یک رشته از کلمات با کاما یا فاصله جدا شده خواهید داشت. وظیفه شما این است که \/\/\/ >>> words_string(s: \"Hi, my name is John\")\n\/\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/\/ >>> words_string(s: \"One, two, three, four, five, six\")\n\/\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunc words_string(s: String) -> [String] {\n","canonical_solution":"func words_string(s: String) -> [String] {\n    let separators = CharacterSet(charactersIn: \", \")\n    return s.components(separatedBy: separators).filter { !$0.isEmpty }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_string(s: \"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\nassert(words_string(s: \"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"Hi, my name\") == [\"Hi\", \"my\", \"name\"])\nassert(words_string(s: \"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"\") == [] as [String])\nassert(words_string(s: \"ahmed     , gamal\") == [\"ahmed\", \"gamal\"])"},{"task_id":"HumanEval_102","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ این عدد وجود ندارد، پس تابع باید -1 را برگرداند. \/\/ بزرگترین عدد صحیح جفت که در محدوده [x، y] شامل باشد. اگر \/\/ این تابع دو عدد مثبت x و y را می گیرد و  را باز می گرداند\/\/\/ >>> choose_num(x: 12, y: 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(x: 13, y: 12)\n\/\/\/ -1\nfunc choose_num(x: Int, y: Int) -> Int {\n","canonical_solution":"func choose_num(x: Int, y: Int) -> Int {\n    \/\/ Determine the starting and ending range values\n    let start = min(x, y)\n    let end = max(x, y)\n    \n    \/\/ Iterate from the end of the range to the start\n    for num in (start...end).reversed() {\n        \/\/ Check if the current number is even\n        if num % 2 == 0 {\n            return num\n        }\n    }\n    \n    \/\/ Return -1 if no even number is found\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(choose_num(x: 12, y: 15) == 14)\nassert(choose_num(x: 13, y: 12) == -1)\nassert(choose_num(x: 33, y: 12354) == 12354)\nassert(choose_num(x: 5234, y: 5233) == -1)\nassert(choose_num(x: 6, y: 29) == 28)\nassert(choose_num(x: 27, y: 10) == -1)\nassert(choose_num(x: 7, y: 7) == -1)\nassert(choose_num(x: 546, y: 546) == 546)"},{"task_id":"HumanEval_103","nl":"prs_Arab","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ مثال: \/\/ اگر n بزرگتر از m باشد، -1 را بازگردانید. \/\/ پاسخ را به نزدیک ترین عدد صحیح گرد کنید و آن را به عدد دوگانه تبدیل کنید. \/\/ میانگین اعداد صحیح از n تا m (از جمله n و m). \/\/ شما دو عدد صحیح مثبت n و m داده شده اید، و وظیفه شما محاسبه \/\/\/ >>> rounded_avg(n: 1, m: 5)\n\/\/\/ .success(\"0b11\")\n\/\/\/ >>> rounded_avg(n: 7, m: 5)\n\/\/\/ .failure(-1)\n\/\/\/ >>> rounded_avg(n: 10, m: 20)\n\/\/\/ .success(\"0b1111\")\n\/\/\/ >>> rounded_avg(n: 20, m: 33)\n\/\/\/ .success(\"0b11010\")\nfunc rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n","canonical_solution":"func rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n    if n > m {\n        return .failure(-1)\n    }\n    \n    let count = m - n + 1\n    let sum = (n + m) * count \/ 2\n    let average = Double(sum) \/ Double(count)\n    let roundedAverage = Int(average.rounded())\n    let binaryString = String(roundedAverage, radix: 2)\n    \n    return .success(\"0b\" + binaryString)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rounded_avg(n: 1, m: 5) == .success(\"0b11\"))\nassert(rounded_avg(n: 7, m: 13) == .success(\"0b1010\"))\nassert(rounded_avg(n: 964, m: 977) == .success(\"0b1111001010\"))\nassert(rounded_avg(n: 996, m: 997) == .success(\"0b1111100100\"))\nassert(rounded_avg(n: 560, m: 851) == .success(\"0b1011000010\"))\nassert(rounded_avg(n: 185, m: 546) == .success(\"0b101101110\"))\nassert(rounded_avg(n: 362, m: 496) == .success(\"0b110101101\"))\nassert(rounded_avg(n: 350, m: 902) == .success(\"0b1001110010\"))\nassert(rounded_avg(n: 197, m: 233) == .success(\"0b11010111\"))\nassert(rounded_avg(n: 7, m: 5) == .failure(-1))\nassert(rounded_avg(n: 5, m: 1) == .failure(-1))\nassert(rounded_avg(n: 5, m: 5) == .success(\"0b101\"))"},{"task_id":"HumanEval_104","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ توجه: آرایه برگشت شده باید در ترتیب افزایش یافته مرتب شود. \/\/ عناصر که هیچ رقم جفتی ندارند. \/\/ با یک آرایه از اعداد صحیح مثبت x. یک آرایه مرتب شده از تمام \/\/\/ >>> unique_digits(x: [15, 33, 1422, 1])\n\/\/\/ [1, 15, 33]\n\/\/\/ >>> unique_digits(x: [152, 323, 1422, 10])\n\/\/\/ [] as [Int]\nfunc unique_digits(x: [Int]) -> [Int] {\n","canonical_solution":"func unique_digits(x: [Int]) -> [Int] {\n    return x.filter { number in\n        var hasEvenDigit = false\n        var num = number\n        while num > 0 {\n            if (num % 10) % 2 == 0 {\n                hasEvenDigit = true\n                break\n            }\n            num \/= 10\n        }\n        return !hasEvenDigit\n    }.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])\nassert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])\nassert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])\nassert(unique_digits(x: [135, 103, 31]) == [31, 135])"},{"task_id":"HumanEval_105","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ \"یک\" ، \"دو\" ، \"سه\" ، \"چهار\" ، \"پنج\" ، \"ششم\" ، \"هفت\" ، \"هشت\" ، \"نه\" \/\/ آرایه حاصل را معکوس کنید، و سپس هر رقم را با نام مربوطه اش از  جایگزین کنید.\/\/ با توجه به یک آرایه از اعداد صحیح، اعداد صحیح را که بین 1 تا 9 شامل می شود، مرتب کنید، \/\/\/ >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/\/ If the array is empty, return an empty array:\n\/\/\/ >>> by_length(arr: [] as [Int])\n\/\/\/ [] as [String]\n\/\/\/ If the array has any strange number ignore it:\n\/\/\/ >>> by_length(arr: [1, -1, 55])\n\/\/\/ [\"One\"]\nfunc by_length(arr: [Int]) -> [String] {\n","canonical_solution":"func by_length(arr: [Int]) -> [String] {\n    let numberNames: [Int: String] = [\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    ]\n    \n    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }\n                                           .sorted(by: >)\n    \n    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? \"\" }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\nassert(by_length(arr: [] as [Int]) == [] as [String])\nassert(by_length(arr: [1, -1, 55]) == [\"One\"])\nassert(by_length(arr: [1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\nassert(by_length(arr: [9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])"},{"task_id":"HumanEval_106","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ فاکتوریل i ضرب اعداد از 1 تا i است (1 * 2 * ... * i). \/\/ من از 1 شروع می کنم. \/\/ یا مجموع اعداد از 1 تا i در غیر این صورت. \/\/ و یک آرایه اندازه n را باز می گرداند، طوری که ارزش عنصر در شاخص i فاکتورال i باشد اگر i جفت باشد \/\/ تابع f را که n را به عنوان پارامتر می گیرد، اجرا کنید، \/\/\/ >>> f(n: 5)\n\/\/\/ [1, 2, 6, 24, 15]\nfunc f(n: Int) -> [Int] {\n","canonical_solution":"func f(n: Int) -> [Int] {\n    func factorial(_ x: Int) -> Int {\n        guard x > 1 else { return 1 }\n        return (1...x).reduce(1, *)\n    }\n    \n    func sumTo(_ x: Int) -> Int {\n        return (1...x).reduce(0, +)\n    }\n    \n    var result = [Int]()\n    for i in 1...n {\n        if i % 2 == 0 {\n            result.append(factorial(i))\n        } else {\n            result.append(sumTo(i))\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 5) == [1, 2, 6, 24, 15])\nassert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])\nassert(f(n: 1) == [1])\nassert(f(n: 3) == [1, 2, 6])"},{"task_id":"HumanEval_107","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال 1: \/\/ palindromes عدد صحیح که در محدوده ((۱، n) شامل می شوند. \/\/ با یک عدد صحیح مثبت n، یک توپل را که دارای تعداد اعداد جفت و عجیب است، برگردانید \/\/\/ >>> even_odd_palindrome(n: 3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(n: 12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_palindrome(n: Int) -> (Int, Int) {\n    func isPalindrome(_ num: Int) -> Bool {\n        let str = String(num)\n        return str == String(str.reversed())\n    }\n    \n    var evenCount = 0\n    var oddCount = 0\n    \n    for i in 1...n {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n                evenCount += 1\n            } else {\n                oddCount += 1\n            }\n        }\n    }\n    \n    return (evenCount, oddCount)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_palindrome(n: 123) == (8, 13))\nassert(even_odd_palindrome(n: 12) == (4, 6))\nassert(even_odd_palindrome(n: 3) == (1, 2))\nassert(even_odd_palindrome(n: 63) == (6, 8))\nassert(even_odd_palindrome(n: 25) == (5, 6))\nassert(even_odd_palindrome(n: 19) == (4, 6))\nassert(even_odd_palindrome(n: 9) == (4, 5))\nassert(even_odd_palindrome(n: 1) == (0, 1))"},{"task_id":"HumanEval_108","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ به عنوان مثال -123 دارای رقم های -1, 2 و 3 است. \/\/ اگر یک عدد منفی باشد، اولین رقم امضا شده اش منفی خواهد بود: \/\/ تعداد عناصر که جمع رقم های آن > 0 است. \/\/ یک تابع count_nums بنویسید که یک آرایه از اعداد صحیح را می گیرد و باز می گرداند \/\/\/ >>> count_nums(arr: [] as [Int])\n\/\/\/ 0\n\/\/\/ >>> count_nums(arr: [-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(arr: [1, 1, 2])\n\/\/\/ 3\nfunc count_nums(arr: [Int]) -> Int {\n","canonical_solution":"func count_nums(arr: [Int]) -> Int {\n    return arr.filter { number in\n        var n = number\n        var sumOfDigits = 0\n\n        while n != 0 {\n            sumOfDigits += n % 10\n            n \/= 10\n        }\n\n        return sumOfDigits > 0\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_nums(arr: [] as [Int]) == 0)\nassert(count_nums(arr: [-1, -2, 0]) == 0)\nassert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)\nassert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)\nassert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)\nassert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)\nassert(count_nums(arr: [0, 1]) == 1)\nassert(count_nums(arr: [1]) == 1)"},{"task_id":"HumanEval_109","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ توجه: تضمین شده است که آرایه داده شده دارای عناصر منحصر به فرد باشد. \/\/ اگر آرایه داده شده خالی باشد پس true را باز می گرداند. \/\/ سپس درست را بازگردانید وگرنه غلط را بازگردانید. \/\/ اگر ممکن باشد که با انجام عملیات بالا آرایه مرتب شده را بدست آوریم \/\/ موقعیت شروع در آرایه یعنی شاخص صفر. \/\/ موقعیت در جهت درست. آخرین عنصر آرایه به  منتقل خواهد شد\/\/ یک عمل تغییر سمت راست به معنی تغییر همه عناصر آرایه به یک است \/\/ شما اجازه دارید که هر تعداد بار عملیات تغییر سمت راست را انجام دهید. \/\/ عمل زیر روی آرایه داده شده انجام می شود: \/\/ ممکن است یک آرایه را در ترتیب غیر کاهش یافته با انجام \/\/ اعداد در آرایه به طور تصادفی ترتیب داده می شوند. وظیفه شما این است که تعیین کنید که آیا \/\/ ما یک آرایه 'arr' از N عدد صحیح arr[1], arr[2]، ..., arr[N] داریم. \/\/\/ >>> move_one_ball(arr: [3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given array.\n\/\/\/ >>> move_one_ball(arr: [3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ array by performing any number of right shift operations.\nfunc move_one_ball(arr: [Int]) -> Bool {\n","canonical_solution":"func move_one_ball(arr: [Int]) -> Bool {\n    guard !arr.isEmpty else { return true }\n    \n    let n = arr.count\n    var breakPointCount = 0\n    \n    \/\/ Find the number of break points where the array is decreasing\n    for i in 0..<n {\n        if arr[i] > arr[(i + 1) % n] {\n            breakPointCount += 1\n        }\n    }\n    \n    \/\/ If there's at most one break point, the array can be right shifted\n    return breakPointCount <= 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)\nassert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)\nassert(move_one_ball(arr: [4, 3, 1, 2]) == false)\nassert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)\nassert(move_one_ball(arr: [] as [Int]) == true)"},{"task_id":"HumanEval_110","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ در غیر اینصورت \"نه\" را برگردانید. \/\/ تمام عناصر lst1 را جفت کنید، \"YES\" را برگردانید. \/\/ اگر امکان مبادله عناصر بین lst1 و lst2 وجود داشته باشد برای ایجاد \/\/ هیچ محدودیتی برای تعداد عناصر مبادله شده بین lst1 و lst2 وجود ندارد. \/\/ بین آنها برای ساختن یک آرایه از lst1 فقط اعداد جفت. \/\/ و تعیین می کند که آیا امکان انجام یک تبادل عناصر وجود دارد \/\/ در این مسئله، شما یک تابع را اجرا خواهید کرد که دو آرایه از اعداد را می گیرد، \/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])\n\/\/\/ \"YES\"\n\/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])\n\/\/\/ \"NO\"\n\/\/\/ It is assumed that the input arrays will be non-empty.\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n","canonical_solution":"func exchange(lst1: [Int], lst2: [Int]) -> String {\n    var hasOddInLst1 = false\n    var hasEvenInLst2 = false\n    \n    for num in lst1 {\n        if num % 2 != 0 {\n            hasOddInLst1 = true\n            break\n        }\n    }\n    \n    for num in lst2 {\n        if num % 2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasOddInLst1 {\n        return \"YES\"\n    }\n    \n    if hasEvenInLst2 {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == \"YES\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == \"NO\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == \"NO\")\nassert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == \"NO\")\nassert(exchange(lst1: [100, 200], lst2: [200, 200]) == \"YES\")"},{"task_id":"HumanEval_111","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ اگر چندین حرف یک اتفاق مشابه داشته باشند، همه آنها را برگردانید. \/\/ از حرف با تکرار بیشتر و حاوی تعداد مربوطه. \/\/ با توجه به یک رشته که یک حروف کوچک جدا شده توسط فضای را نشان می دهد، یک دیکشنری را بازگردانید \/\/\/ >>> histogram(test: \"a b c\")\n\/\/\/ [\"a\" : 1, \"b\" : 1, \"c\" : 1]\n\/\/\/ >>> histogram(test: \"a b b a\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"a b c a b\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"b b b b a\")\n\/\/\/ [\"b\" : 4]\n\/\/\/ >>> histogram(test: \"\")\n\/\/\/ [:] as [String : Int]\nfunc histogram(test: String) -> [String : Int] {\n","canonical_solution":"func histogram(test: String) -> [String : Int] {\n    var letterCount: [String: Int] = [:]\n\n    \/\/ Split the string into an array of letters\n    let letters = test.split(separator: \" \").map { String($0) }\n\n    \/\/ Count occurrences of each letter\n    for letter in letters {\n        letterCount[letter, default: 0] += 1\n    }\n\n    \/\/ Determine the maximum number of occurrences\n    guard let maxCount = letterCount.values.max() else {\n        return [:] as [String : Int]\n    }\n\n    \/\/ Filter the letterCount dictionary to only include letters with the max count\n    let result = letterCount.filter { $0.value == maxCount }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"},{"task_id":"HumanEval_112","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال \/\/ شما باید یک توپل حاوی رشته نتیجه و true\/false برای چک را برگردانید. \/\/ یک رشته به اصطلاح پالندروم نامیده می شود اگر به همان اندازه که به جلو خوانده می شود به عقب هم خوانده شود. \/\/ سپس بررسی کنید که رشته نتیجه ای پالندروم است یا نه. \/\/ ما دو رشته s و c داده شده است، شما باید تمام کاراکترهای s را که برابر با هر کاراکتر در c است حذف کنید.\/\/ وظیفه \/\/\/ >>> reverse_delete(s: \"abcde\", c: \"ae\")\n\/\/\/ (\"bcd\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdef\", c: \"b\")\n\/\/\/ (\"acdef\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdedcba\", c: \"ab\")\n\/\/\/ (\"cdedc\", true)\nfunc reverse_delete(s: String, c: String) -> (String, Bool) {\n","canonical_solution":"func reverse_delete(s: String, c: String) -> (String, Bool) {\n    \/\/ Remove characters from s that are in c\n    let filteredString = s.filter { !c.contains($0) }\n    \n    \/\/ Check if the resulting string is a palindrome\n    let isPalindrome = filteredString == String(filteredString.reversed())\n    \n    \/\/ Return the resulting string and the palindrome check result\n    return (filteredString, isPalindrome)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_delete(s: \"abcde\", c: \"ae\") == (\"bcd\", false))\nassert(reverse_delete(s: \"abcdef\", c: \"b\") == (\"acdef\", false))\nassert(reverse_delete(s: \"abcdedcba\", c: \"ab\") == (\"cdedc\", true))\nassert(reverse_delete(s: \"dwik\", c: \"w\") == (\"dik\", false))\nassert(reverse_delete(s: \"a\", c: \"a\") == (\"\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"v\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"vabba\", c: \"v\") == (\"abba\", true))\nassert(reverse_delete(s: \"mamma\", c: \"mia\") == (\"\", true))"},{"task_id":"HumanEval_113","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ از رقم های عجیب در رشته i'th ورودی. \/\/ رشته i از ورودی. \" که در آن تمام i ها باید با عدد  جایگزین شوند.\/\/ هر عنصر i از خروجی باید \"تعداد عناصر عجیب در \/\/ با یک آرایه از رشته ها که هر رشته فقط از ارقام تشکیل شده است، یک آرایه را بازگردانید. \/\/\/ >>> odd_count(lst: [\"1234567\"])\n\/\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/\/ >>> odd_count(lst: [\"3\", \"11111111\"])\n\/\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunc odd_count(lst: [String]) -> [String] {\n","canonical_solution":"func odd_count(lst: [String]) -> [String] {\n    return lst.map { str in\n        let oddCount = str.filter { \"13579\".contains($0) }.count\n        return \"the number of odd elements \\(oddCount)n the str\\(oddCount)ng \\(oddCount) of the \\(oddCount)nput.\"\n    }\n}\n\n\/\/ Example Usage\nprint(odd_count(lst: [\"1234567\"]))\nprint(odd_count(lst: [\"3\", \"11111111\"]))","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_count(lst: [\"1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\nassert(odd_count(lst: [\"3\", \"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\nassert(odd_count(lst: [\"271\", \"137\", \"314\"]) == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])"},{"task_id":"HumanEval_114","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال \/\/ از اعداد \/\/ با توجه به یک آرایه از اعداد صحیح n، حداقل مجموع هر زیر آرایه غیر خالی را پیدا کنید \/\/\/ >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(nums: [-1, -2, -3])\n\/\/\/ -6\nfunc minSubArraySum(nums: [Int]) -> Int {\n","canonical_solution":"func minSubArraySum(nums: [Int]) -> Int {\n    guard !nums.isEmpty else { return 0 }\n    \n    var currentMin = nums[0]\n    var overallMin = nums[0]\n    \n    for i in 1..<nums.count {\n        currentMin = min(nums[i], currentMin + nums[i])\n        overallMin = min(overallMin, currentMin)\n    }\n    \n    return overallMin\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)\nassert(minSubArraySum(nums: [-1, -2, -3]) == -6)\nassert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)\nassert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)\nassert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)\nassert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)\nassert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)\nassert(minSubArraySum(nums: [-10]) == -10)\nassert(minSubArraySum(nums: [7]) == 7)\nassert(minSubArraySum(nums: [1, -1]) == -1)"},{"task_id":"HumanEval_115","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال 1: \/\/ تعداد بار هایی که نیاز دارید تا سطل ها را پایین بیاورید را وارد کنید. \/\/ وظیفه شما این است که از سطل ها برای خالی کردن چاه ها استفاده کنید. \/\/ و تمام سطل ها دارای ظرفیت یکسان هستند. \/\/ هر چاه دارای یک سطل مناسب است که می تواند برای استخراج آب از آن استفاده شود، \/\/ و هر یک از 1 ها در یک ردیف یک واحد آب را نشان می دهد. \/\/ یک شبکه مستطیل از چاه ها به شما داده می شود. هر ردیف یک چاه را نشان می دهد، \/\/\/ >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n","canonical_solution":"func max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var totalWater = 0\n    for row in grid {\n        for unit in row {\n            if unit == 1 {\n                totalWater += 1\n            }\n        }\n    }\n    return (totalWater + capacity - 1) \/ capacity\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"},{"task_id":"HumanEval_116","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ باید اینطوری اجرا شود: \/\/ برای تعداد مشابه یک ها، بر اساس مقدار اعشاری مرتب کنید. \/\/ تعداد یک ها در نمایش دوگانه آنها به ترتیب بالا رفتن. \/\/ در این کاتا، شما باید یک آرایه از اعداد صحیح غیر منفی را مطابق با \/\/\/ >>> sort_array(arr: [1, 5, 2, 3, 4])\n\/\/\/ [1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(arr: [-2, -3, -4, -5, -6])\n\/\/\/ [-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(arr: [1, 0, 2, 3, 4])\n\/\/\/ [0, 1, 2, 3, 4]\nfunc sort_array(arr: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted {\n        let onesCount1 = $0.nonNegativeOnesCount()\n        let onesCount2 = $1.nonNegativeOnesCount()\n        return (onesCount1, $0) < (onesCount2, $1)\n    }\n}\n\nextension Int {\n    func nonNegativeOnesCount() -> Int {\n        return self < 0 ? 0 : self.nonBitCount()\n    }\n    \n    private func nonBitCount() -> Int {\n        var count = 0\n        var num = self\n        while num > 0 {\n            count += num & 1\n            num >>= 1\n        }\n        return count\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"},{"task_id":"HumanEval_117","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ توجه: شما ممکن است فرض کنید که رشته ورودی فقط شامل حروف و فاصله ها است. \/\/ اگر رشته s خالی باشد، تابع باید یک آرایه خالی را بازگردانده باشد. \/\/ n ضمایر، به ترتیب این کلمات در رشته s ظاهر می شوند. \/\/ یک تابع که یک آرایه از تمام کلمات را از رشته s که دقیقا شامل \/\/ با توجه به یک رشته s و یک عدد طبیعی n، شما وظیفه دارید که \/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 4)\n\/\/\/ [\"little\"]\n\/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 3)\n\/\/\/ [\"Mary\", \"lamb\"]\n\/\/\/ >>> select_words(s: \"simple white space\", n: 2)\n\/\/\/ [] as [String]\n\/\/\/ >>> select_words(s: \"Hello world\", n: 4)\n\/\/\/ [\"world\"]\n\/\/\/ >>> select_words(s: \"Uncle sam\", n: 3)\n\/\/\/ [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n","canonical_solution":"func select_words(s: String, n: Int) -> [String] {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    let words = s.split(separator: \" \")\n    var result: [String] = []\n    \n    for word in words {\n        let consonantCount = word.filter { !vowels.contains($0) }.count\n        if consonantCount == n {\n            result.append(String(word))\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"},{"task_id":"HumanEval_118","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ شما ممکن است فرض کنید که رشته داده شده شامل حرف های انگلیسی است. \/\/ هر یک از حروف صوتی را که شرایط بالا را برآورده می کند پیدا کنید. \/\/ حروف صوتی در آغاز و پایان شمارش نمی شود. اگر این کار را نکرده اید، رشته خالی را بازگردانید \/\/ دو تا از ضمائر سمت راست کلمه (حساس به حروف کوچک و بزرگ)\/\/ یک کلمه به شما داده می شود. وظیفه شما پیدا کردن نزدیک ترین حرف صوتی است که بین آن قرار دارد \/\/\/ >>> get_closest_vowel(word: \"yogurt\")\n\/\/\/ \"u\"\n\/\/\/ >>> get_closest_vowel(word: \"FULL\")\n\/\/\/ \"U\"\n\/\/\/ >>> get_closest_vowel(word: \"quick\")\n\/\/\/ \"\"\n\/\/\/ >>> get_closest_vowel(word: \"ab\")\n\/\/\/ \"\"\nfunc get_closest_vowel(word: String) -> String {\n","canonical_solution":"func get_closest_vowel(word: String) -> String {\n    let vowels = Set(\"aeiouAEIOU\")\n    var foundVowel: Character? = nil\n    \n    for i in stride(from: word.count - 2, through: 1, by: -1) {\n        let currentIndex = word.index(word.startIndex, offsetBy: i)\n        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)\n        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)\n        \n        if vowels.contains(word[currentIndex]) && \n            !vowels.contains(word[previousIndex]) && \n            !vowels.contains(word[nextIndex]) {\n            foundVowel = word[currentIndex]\n            break\n        }\n    }\n    \n    return foundVowel != nil ? String(foundVowel!) : \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"},{"task_id":"HumanEval_119","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ اگر راهی برای ساختن یک رشته خوب وجود داشته باشد \"بله\" را باز می گرداند و در غیر این صورت \"نه\" را باز می گرداند. \/\/ \" ((()) \" این طور نیست. \/\/ متوازن هستند. برای مثال: رشته '(()))) خوب است، در حالی که رشته \/\/ یک رشته S خوب در نظر گرفته می شود اگر و تنها اگر تمام قوس های S \/\/ بعضی از دستورات، که رشته نتیجه خوب خواهد بود. \/\/ کار شما این است که بررسی کنید که آیا امکان اتصال دو رشته در \/\/ فقط در قوس های \" ((\" یا قوس های نزدیک \")) \"\/\/ شما یک آرایه از دو رشته داده شده است، هر دو رشته شامل باز \/\/\/ >>> match_parens(lst: [\"()(\", \")\"])\n\/\/\/ \"Yes\"\n\/\/\/ >>> match_parens(lst: [\")\", \")\"])\n\/\/\/ \"No\"\nfunc match_parens(lst: [String]) -> String {\n","canonical_solution":"func match_parens(lst: [String]) -> String {\n    let combined1 = lst[0] + lst[1]\n    let combined2 = lst[1] + lst[0]\n    \n    func isBalanced(_ s: String) -> Bool {\n        var balance = 0\n        for char in s {\n            if char == \"(\" {\n                balance += 1\n            } else if char == \")\" {\n                balance -= 1\n            }\n            if balance < 0 {\n                return false\n            }\n        }\n        return balance == 0\n    }\n    \n    if isBalanced(combined1) || isBalanced(combined2) {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")"},{"task_id":"HumanEval_120","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال 1: \/\/ با حداکثر تعداد k عدد در arr.\/\/ با یک آرایه ار از اعداد صحیح و یک عدد صحیح مثبت k، یک آرایه مرتب شده را بازگردانید \/\/\/ >>> maximum(arr: [-3, -4, 5], k: 3)\n\/\/\/ [-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(arr: [4, -4, 4], k: 2)\n\/\/\/ [4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\n\/\/\/ [2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n","canonical_solution":"func maximum(arr: [Int], k: Int) -> [Int] {\n    guard k > 0 else { return [] }\n    let sortedArr = arr.sorted(by: >)\n    let maxElements = Array(sortedArr.prefix(k))\n    return maxElements.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"},{"task_id":"HumanEval_121","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها \/\/ با توجه به یک آرایه غیر خالی از اعداد صحیح، جمع تمام عناصر عجیب را که در موقعیت های حتی هستند، برگردانید. \/\/\/ >>> solution(lst: [5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(lst: [3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(lst: [30, 13, 24, 321])\n\/\/\/ 0\nfunc solution(lst: [Int]) -> Int {\n","canonical_solution":"func solution(lst: [Int]) -> Int {\n    var sum = 0\n    for (index, value) in lst.enumerated() {\n        if index % 2 == 0 && value % 2 != 0 {\n            sum += value\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solution(lst: [5, 8, 7, 1]) == 12)\nassert(solution(lst: [3, 3, 3, 3, 3]) == 9)\nassert(solution(lst: [30, 13, 24, 321]) == 0)\nassert(solution(lst: [5, 9]) == 5)\nassert(solution(lst: [2, 4, 8]) == 0)\nassert(solution(lst: [30, 13, 23, 32]) == 23)\nassert(solution(lst: [3, 13, 2, 9]) == 3)"},{"task_id":"HumanEval_122","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ مجموع عناصر با حداکثر دو رقم از k عنصر اول arr است. \/\/ با یک آرایه غیرخالی از اعداد صحیح arr و یک عدد صحیح k، return \/\/\/ >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr: [Int], k: Int) -> Int {\n","canonical_solution":"func add_elements(arr: [Int], k: Int) -> Int {\n    var sum = 0\n    for i in 0..<k {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)\nassert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)\nassert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)\nassert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)\nassert(add_elements(arr: [1], k: 1) == 1)"},{"task_id":"HumanEval_123","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ get_odd_collatz(5) [1, 5] را باز می گرداند # دنباله collatz برای 5 [5, 16, 8, 4, 2, 1] است، بنابراین اعداد عجیب فقط 1 و 5 هستند. \/\/ برای مثال: \/\/ 2. آرایه برگشت شده مرتب شده در ترتیب افزایش یافته. \/\/ 1. Collatz ((1)) است [1]. \/\/ یادداشت: \/\/ اصطلاح به علاوه 1 حدس این است که مهم نیست که ارزش n چیست، دنباله همیشه به 1 خواهد رسید. \/\/ اصطلاح قبلی. اگر اصطلاح قبلی عجیب باشد، اصطلاح بعدی 3 برابر اصطلاح قبلی است.\/\/ اصطلاح قبلی به شرح زیر: اگر اصطلاح قبلی جفت باشد، اصطلاح بعدی نصف  است.\/\/ به شرح زیر: با هر عدد صحیح مثبت n شروع کنید. سپس هر اصطلاح از  بدست می آید.\/\/ حدس کولاتز یک حدس در ریاضیات است که مربوط به یک دنباله تعریف شده است \/\/ با یک عدد صحیح مثبت n، یک آرایه مرتب شده را که دارای اعداد عجیب در دنباله collatz است، بازگردانید. \/\/\/ >>> get_odd_collatz(n: 5)\n\/\/\/ [1, 5]\nfunc get_odd_collatz(n: Int) -> [Int] {\n","canonical_solution":"func get_odd_collatz(n: Int) -> [Int] {\n    var collatzSequence: [Int] = []\n    var number = n\n\n    while number != 1 {\n        if number % 2 != 0 {\n            collatzSequence.append(number)\n        }\n        if number % 2 == 0 {\n            number \/= 2\n        } else {\n            number = 3 * number + 1\n        }\n    }\n\n    collatzSequence.append(1) \/\/ append 1 as the sequence ends at 1\n\n    let sortedOdds = collatzSequence.sorted()\n    \n    return sortedOdds\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"},{"task_id":"HumanEval_124","nl":"prs_Arab","pl":"swift","prompt":"\nتاریخ باید در قالب: mm-dd-yyyy باشد\/\/ 3 ماه ها نباید کمتر از 1 یا بیشتر از 12 باشد.\/\/ 2. تعداد روزها برای ماه های 1,3,5,7,8,10,12 کمتر از 1 یا بیشتر از 31 روز نیست و تعداد روزها برای ماه های 4,6,9,11 کمتر از 1 یا بیشتر از 30 روز نیست و تعداد روزها برای ماه 2 کمتر از 1 یا بیشتر از 29 روز نیست. \/\/ 1. رشته تاریخ خالی نیست. \/\/ تاریخ معتبر است اگر تمام قواعد زیر برآورده شود: \/\/ اگر تاریخ معتبر باشد راست را باز می گرداند در غیر این صورت غلط است. \/\/ شما باید یک تابع بنویسید که یک رشته تاریخ داده شده را تایید کند و \/\/\/ >>> valid_date(date: \"03-11-2000\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"15-01-2012\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"04-0-2040\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"06-04-2020\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"06\/04\/2020\")\n\/\/\/ false\nfunc valid_date(date: String) -> Bool {\n","canonical_solution":"func valid_date(date: String) -> Bool {\n    \/\/ Check if the date is empty\n    if date.isEmpty {\n        return false\n    }\n    \n    \/\/ Split the date into components using the \"-\" delimiter\n    let components = date.split(separator: \"-\")\n    \n    \/\/ Ensure the date has exactly three components\n    if components.count != 3 {\n        return false\n    }\n    \n    \/\/ Ensure the date components are integers\n    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {\n        return false\n    }\n    \n    \/\/ Check if the month is within the valid range\n    if month < 1 || month > 12 {\n        return false\n    }\n    \n    \/\/ Define the number of days in each month\n    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    \/\/ Check the day range for each month\n    if day < 1 || day > daysInMonth[month] {\n        return false\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(valid_date(date: \"03-11-2000\") == true)\nassert(valid_date(date: \"15-01-2012\") == false)\nassert(valid_date(date: \"04-0-2040\") == false)\nassert(valid_date(date: \"06-04-2020\") == true)\nassert(valid_date(date: \"01-01-2007\") == true)\nassert(valid_date(date: \"03-32-2011\") == false)\nassert(valid_date(date: \"\") == false)\nassert(valid_date(date: \"04-31-3000\") == false)\nassert(valid_date(date: \"06-06-2005\") == true)\nassert(valid_date(date: \"21-31-2000\") == false)\nassert(valid_date(date: \"04-12-2003\") == true)\nassert(valid_date(date: \"04122003\") == false)\nassert(valid_date(date: \"20030412\") == false)\nassert(valid_date(date: \"2003-04\") == false)\nassert(valid_date(date: \"2003-04-12\") == false)\nassert(valid_date(date: \"04-2003\") == false)"},{"task_id":"HumanEval_125","nl":"prs_Arab","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ مثال ها \/\/ الفبا، ord ((('a') = 0، ord ((('b') = 1، ... ord ((('z') = 25 \/\/ باید با کمیک تقسیم شود ',' اگر هیچ کمیک وجود نداشته باشد باید تعداد حروف کوچک را با ترتیب عجیب در \/\/ با توجه به یک رشته کلمات، یک آرایه از کلمات تقسیم شده بر روی فضای خالی را بازگردانید، اگر هیچ فضای خالی در متن شما وجود نداشته باشد.\/\/\/ >>> split_words(txt: \"Hello world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"Hello,world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"abcdef\")\n\/\/\/ .failure(3)\nfunc split_words(txt: String) -> Result<[String], Int> {\n","canonical_solution":"func split_words(txt: String) -> Result<[String], Int> {\n    if txt.contains(\" \") {\n        let words = txt.split(separator: \" \").map { String($0) }\n        return .success(words)\n    } else if txt.contains(\",\") {\n        let words = txt.split(separator: \",\").map { String($0) }\n        return .success(words)\n    } else {\n        let oddOrderedLowerCaseLetters = txt.filter { char in\n            if let asciiValue = char.asciiValue {\n                let order = asciiValue - Character(\"a\").asciiValue!\n                return order % 2 == 1\n            }\n            return false\n        }\n        return .failure(oddOrderedLowerCaseLetters.count)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"},{"task_id":"HumanEval_126","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها \/\/ عدد، false را باز می گرداند. فرض کنید هیچ عدد منفی و فقط اعداد صحیح وجود ندارد. \/\/ در ترتیب رو به افزایش. اگر آرایه دارای بیش از یک کپی از همان باشد \/\/ با توجه به یک آرایه از اعداد، آنها را مرتب کنید یا نه.\/\/\/ >>> is_sorted(lst: [5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfunc is_sorted(lst: [Int]) -> Bool {\n","canonical_solution":"func is_sorted(lst: [Int]) -> Bool {\n    guard !lst.isEmpty else { return true }\n\n    var previous = lst[0]\n    var duplicates = 0\n\n    for i in 1..<lst.count {\n        if lst[i] < previous {\n            return false\n        } else if lst[i] == previous {\n            duplicates += 1\n            if duplicates > 1 {\n                return false\n            }\n        } else {\n            duplicates = 0\n        }\n        previous = lst[i]\n    }\n\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"},{"task_id":"HumanEval_127","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ [رود و خروجی] نمونه ها: \/\/ اگر دو فاصله با هم تقاطع نکنند، \"NO\" را بازگردانید. \/\/ در غیر اینصورت \"NO\" را بازگردانید. \/\/ اگر طول تقاطع یک عدد اول باشد، \"YES\" را بازگردانید، \/\/ که طول آن 1 است که یک عدد اول نیست. \/\/ مثال، تقاطع فاصله های (1, 3), (2, 4) (2, 3) است.\/\/ فاصله ها یک عدد اول است. \/\/ وظیفه شما این است که تعیین کنید که آیا طول تقاطع این دو \/\/ برای هر فاصله داده شده، فرض می شود که شروع آن کمتر یا برابر با پایان آن است. \/\/ شامل شروع و پایان است. \/\/ فواصل داده شده بسته هستند که به این معنی است که فواصل (ابتدا، پایان) \/\/ که هر فاصله یک جفت عدد صحیح است. به عنوان مثال، فاصله = (آغاز، پایان) = (1, 2). \/\/ شما دو فاصله داده شده است، \/\/\/ >>> intersection(interval1: (1, 2), interval2: (2, 3))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-1, 1), interval2: (0, 4))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-3, -1), interval2: (-5, 5))\n\/\/\/ \"YES\"\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n","canonical_solution":"func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n    \/\/ Helper function to determine if a number is prime\n    func isPrime(_ num: Int) -> Bool {\n        if num <= 1 {\n            return false\n        }\n        if num <= 3 {\n            return true\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false\n        }\n        var i = 5\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Find the start and end of the intersection\n    let intersectStart = max(interval1.0, interval2.0)\n    let intersectEnd = min(interval1.1, interval2.1)\n    \n    \/\/ Calculate the length of the intersection\n    let intersectionLength = intersectEnd - intersectStart\n\n    \/\/ Check if intersection length is positive and prime\n    if intersectionLength > 0 && isPrime(intersectionLength) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersection(interval1: (1, 2), interval2: (2, 3)) == \"NO\")\nassert(intersection(interval1: (-1, 1), interval2: (0, 4)) == \"NO\")\nassert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == \"YES\")\nassert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == \"YES\")\nassert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (3, 5)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (1, 2)) == \"NO\")\nassert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == \"NO\")"},{"task_id":"HumanEval_128","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ یادداشت: برای آرر خالی null را بازگردانید. \/\/ از هر عدد در آرایه، که توسط 1، -1 یا 0 نشان داده شده است. \/\/ جمع مقدار اعداد کامل ضرب ضرب تمام علامت ها \/\/ شما یک آرایه ار از اعداد صحیح داده شده و باید آن را برگردانید \/\/\/ >>> prod_signs(arr: [1, 2, 2, -4])\n\/\/\/ 9\n\/\/\/ >>> prod_signs(arr: [0, 1])\n\/\/\/ 0\n\/\/\/ >>> prod_signs(arr: [] as [Int])\n\/\/\/ nil\nfunc prod_signs(arr: [Int]) -> Int? {\n","canonical_solution":"func prod_signs(arr: [Int]) -> Int? {\n    \/\/ Return nil for empty array\n    if arr.isEmpty {\n        return nil\n    }\n\n    \/\/ Calculate the sum of magnitudes\n    let sumOfMagnitudes = arr.reduce(0) { sum, num in\n        return sum + abs(num)\n    }\n\n    \/\/ Calculate the product of all signs\n    let productOfSigns = arr.reduce(1) { product, num in\n        if num > 0 {\n            return product * 1\n        } else if num < 0 {\n            return product * -1\n        } else {\n            return 0\n        }\n    }\n\n    \/\/ Return the result of sum of magnitudes multiplied by product of signs\n    return sumOfMagnitudes * productOfSigns\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"},{"task_id":"HumanEval_129","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ یک آرایه مرتب شده از مقادیر را در سلول هایی که حداقل مسیر از آن عبور می کند، باز می گرداند. \/\/ تضمین شده است که پاسخ منحصر به فرد باشد. \/\/ lst_A[j] = lst_B[j] .\/\/ طوری که lst_A[i] < lst_B[i] و برای هر j (1 <= j < i) ما \/\/ از lst_B، به عبارت دیگر، یک شاخص عدد صحیح وجود دارد i (1 <= i <= k) \/\/ از طریق (بگذارید آنها را lst_A و lst_B بنامیم) ، lst_A از نظر لغت شناسی کمتر است \/\/ بعد از ایجاد آرایه های مرتب شده از مقادیر در سلول هایی که A و B به آن ها می روند \/\/ یک مسیر A (طول k) کمتر از یک مسیر B (طول k) در نظر گرفته می شود اگر \/\/ نمیتونی از شبکه خارج بشی. \/\/ لزوماً متمایز می شود).\/\/ لطفاً توجه داشته باشید که یک مسیر با طول k به معنی بازدید دقیقاً از k سلول (نه \/\/ حجره \/\/ به عبارت دیگر، شما می توانید به سلول هایی که یک لبه با شما دارند بروید \/\/ از هر سلول، و در هر مرحله شما می توانید به هر یک از سلول های همسایه حرکت کنید، \/\/ شما باید حداقل مسیر طول k را در شبکه پیدا کنید. شما می توانید شروع کنید \/\/ شامل یکبار در سلول های شبکه ظاهر می شود. \/\/ هر سلول شبکه دارای یک مقدار است. هر عدد صحیح در محدوده [1, N * N] \/\/ با یک شبکه با N ردیف و N ستون (N >= 2) و یک عدد صحیح مثبت k، \/\/\/ >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)\n\/\/\/ [1, 2, 1]\n\/\/\/ >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)\n\/\/\/ [1]\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n","canonical_solution":"func minPath(grid: [[Int]], k: Int) -> [Int] {\n    let n = grid.count\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    struct Path: Comparable {\n        let cells: [Int]\n        \n        static func < (lhs: Path, rhs: Path) -> Bool {\n            return lhs.cells.lexicographicallyPrecedes(rhs.cells)\n        }\n    }\n    \n    var minPath: Path? = nil\n    \n    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {\n        var currentPath = currentPath\n        currentPath.append(grid[x][y])\n        \n        if currentPath.count == k {\n            let newPath = Path(cells: currentPath)\n            if minPath == nil || newPath < minPath! {\n                minPath = newPath\n            }\n            return\n        }\n        \n        for direction in directions {\n            let newX = x + direction.0\n            let newY = y + direction.1\n            if newX >= 0 && newX < n && newY >= 0 && newY < n {\n                dfs(x: newX, y: newY, k: k, currentPath: currentPath)\n            }\n        }\n    }\n    \n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(x: i, y: j, k: k, currentPath: [])\n        }\n    }\n    \n    return minPath!.cells\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])\nassert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])\nassert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])\nassert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])\nassert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])\nassert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\nassert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\nassert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])\nassert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])\nassert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\nassert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"},{"task_id":"HumanEval_130","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ اولین n + 1 عدد از دنباله تریبوناکچی. \/\/ شما یک عدد صحیح غیر منفی n داده شده است، شما باید یک آرایه از  را برگردانید.\/\/ = 2 + 3 + 3 = 8 \/\/ تری تری (3) = تری تری (2) + تری تری (1) + تری تری (4)\/\/ تری ((4) = 3 \/\/ tri(2) = 1 + (2 \/ 2) = 2 \/\/ برای مثال: \/\/ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، اگر n یک عدد عجیب باشد. \/\/ tri ((n) = 1 + n \/ 2، اگر n یک عدد جفت باشد. \/\/ تری ((1) = 3 \/\/ دنباله تریبوناکچی با تکرار تعریف شده است: با این حال، چیزی که مردم نمی دانند دنباله تریبوناچی است.\/\/ همه دنباله فیبوناچی را می شناسند، این توسط ریاضیدانان در سال ۰۲۰۰ مطالعه شد.\/\/\/ >>> tri(n: 3)\n\/\/\/ [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n","canonical_solution":"func tri(n: Int) -> [Int] {\n    guard n >= 0 else { return [] }\n    if n == 0 { return [1] }\n    if n == 1 { return [1, 3] }\n    if n == 2 { return [1, 3, 2] }\n    \n    var sequence = [1, 3, 2]\n    \n    for i in 3...n {\n        if i % 2 == 0 {\n            sequence.append(1 + i \/ 2)\n        } else {\n            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]\n            sequence.append(nextVal)\n        }\n    }\n    \n    return sequence\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])"},{"task_id":"HumanEval_131","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ اگر تمام رقم ها جفت باشند 0 را بازگردانید. \/\/ با یک عدد صحیح مثبت n، حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل حاصل\/\/\/ >>> digits(n: 1)\n\/\/\/ 1\n\/\/\/ >>> digits(n: 4)\n\/\/\/ 0\n\/\/\/ >>> digits(n: 235)\n\/\/\/ 15\nfunc digits(n: Int) -> Int {\n","canonical_solution":"func digits(n: Int) -> Int {\n    var num = n\n    var product = 1\n    var hasOdd = false\n    \n    while num > 0 {\n        let digit = num % 10\n        if digit % 2 != 0 {\n            hasOdd = true\n            product *= digit\n        }\n        num \/= 10\n    }\n    \n    return hasOdd ? product : 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digits(n: 5) == 5)\nassert(digits(n: 54) == 5)\nassert(digits(n: 120) == 1)\nassert(digits(n: 5014) == 5)\nassert(digits(n: 98765) == 315)\nassert(digits(n: 5576543) == 2625)\nassert(digits(n: 2468) == 0)"},{"task_id":"HumanEval_132","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ جایی که حداقل یک براکت در زیرسلسلۀ موجود باشد. \/\/ تابع باید درست را برگرداند اگر و فقط اگر یک زیرنویس معتبر از براکت ها وجود داشته باشد \/\/ یک تابع ایجاد کنید که یک رشته را به عنوان ورودی می گیرد که فقط شامل قوس های مربع است. \/\/\/ >>> is_nested(string: \"[[]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[]]]]]]][[[[[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[][]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[[][]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[[]][[\")\n\/\/\/ true\nfunc is_nested(string: String) -> Bool {\n","canonical_solution":"func is_nested(string: String) -> Bool {\n    var stack: [Character] = []\n    var nested = false\n\n    for bracket in string {\n        if bracket == \"[\" {\n            stack.append(bracket)\n        } else if bracket == \"]\" {\n            if let last = stack.last, last == \"[\" {\n                stack.removeLast()\n                if !stack.isEmpty {\n                    nested = true\n                }\n            } else {\n                return false\n            }\n        }\n    }\n    return nested\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"},{"task_id":"HumanEval_133","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ هر عنصر در آرایه را به سمت بالا جمع کنید.\/\/ شما باید جمع اعداد مربع شده در آرایه داده شده را برگردانید، \/\/ شما یک آرایه از اعداد داده شده است. \/\/\/ >>> sum_squares(lst: [1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> sum_squares(lst: [1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> sum_squares(lst: [1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> sum_squares(lst: [-2.4, 1.0, 1.0])\n\/\/\/ 6\nfunc sum_squares(lst: [Double]) -> Int {\n","canonical_solution":"func sum_squares(lst: [Double]) -> Int {\n    return lst.map { ceil($0) } \/\/ Round each element to the upper int (Ceiling)\n              .map { Int($0 * $0) } \/\/ Square each element\n              .reduce(0, +) \/\/ Sum all squared elements\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)\nassert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)\nassert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)\nassert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)\nassert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)\nassert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)\nassert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)\nassert(sum_squares(lst: [0.0]) == 0)\nassert(sum_squares(lst: [-1.0]) == 1)\nassert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"},{"task_id":"HumanEval_134","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ توجه: \"کلمه\" یک گروه از کاراکترها است که توسط فضا جدا شده اند. \/\/ یک بخش از یک کلمه و در غیر این صورت غلط است. \/\/ یک رشته داده شده یک کاراکتر الفبایی است و  نیست.\/\/ یک تابع ایجاد کنید که اگر آخرین کاراکتر \/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pie\")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e\")\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e \")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"\")\n\/\/\/ false\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n","canonical_solution":"func check_if_last_char_is_a_letter(txt: String) -> Bool {\n    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {\n        return false\n    }\n    \n    if lastChar.isLetter {\n        let words = txt.split(separator: \" \")\n        if let lastWord = words.last {\n            return lastWord.count == 1\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_if_last_char_is_a_letter(txt: \"apple\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"A\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie 1\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee e \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pie\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e \") == false)"},{"task_id":"HumanEval_135","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ ارزش های تکراری. \/\/ هیچ عنصر وجود ندارد پس -1 را باز می گرداند. آرایه داده شده شامل  نمی شود.\/\/ بزرگتر یا برابر با عنصر قبل از آن نیست. اگر \/\/ یک تابع ایجاد کنید که بزرگترین شاخص یک عنصر را که \/\/\/ >>> can_arrange(arr: [1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(arr: [1, 2, 3])\n\/\/\/ -1\nfunc can_arrange(arr: [Int]) -> Int {\n","canonical_solution":"func can_arrange(arr: [Int]) -> Int {\n    for i in (1..<arr.count).reversed() {\n        if arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"},{"task_id":"HumanEval_136","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ اگر هیچ عدد منفی یا مثبت وجود نداشته باشد، آن ها را به عنوان nil بازگردانید. \/\/ از اعداد صحیح مثبت در یک آرایه. \/\/ بزرگتر از تمام اعداد منفی است و 'b' کوچک ترین عدد است \/\/ یک تابع ایجاد کنید که یک توپل (a، b) را باز می گرداند، جایی که 'a' \/\/\/ >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])\n\/\/\/ (nil, 1)\n\/\/\/ >>> largest_smallest_integers(lst: [] as [Int])\n\/\/\/ (nil, nil)\n\/\/\/ >>> largest_smallest_integers(lst: [0])\n\/\/\/ (nil, nil)\nfunc largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n","canonical_solution":"func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n    var largestNegative: Int? = nil\n    var smallestPositive: Int? = nil\n\n    for number in lst {\n        if number < 0 {\n            if largestNegative == nil || number > largestNegative! {\n                largestNegative = number\n            }\n        } else if number > 0 {\n            if smallestPositive == nil || number < smallestPositive! {\n                smallestPositive = number\n            }\n        }\n    }\n\n    return (largestNegative, smallestPositive)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\nassert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"},{"task_id":"HumanEval_137","nl":"prs_Arab","pl":"swift","prompt":"\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n\/\/ توجه: اگر یک عدد واقعی به عنوان یک رشته نمایش داده شود، نقطه شناور ممکن است . یا ،  باشد.\/\/ اگر مقادیر برابر باشند، null را باز می گرداند. \/\/ اعداد واقعی، و متغیر بزرگتر را در نوع متغیر داده شده اش باز می گرداند. \/\/ یک تابع ایجاد کنید که اعداد صحیح، floats یا رشته های نشان دهنده  را می گیرد.\/\/\/ >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))\n\/\/\/ .doubleValue(2.5)\n\/\/\/ >>> compare_one(a: .intValue(1), b: .stringValue(\"2,3\"))\n\/\/\/ .stringValue(\"2,3\")\n\/\/\/ >>> compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n\/\/\/ .stringValue(\"6\")\n\/\/\/ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n\/\/\/ nil\nfunc compare_one(a: Value, b: Value) -> Value? {\n","canonical_solution":"func compare_one(a: Value, b: Value) -> Value? {\n    func convertToDouble(value: Value) -> Double? {\n        switch value {\n        case .intValue(let int):\n            return Double(int)\n        case .doubleValue(let double):\n            return double\n        case .stringValue(let string):\n            let formatter = NumberFormatter()\n            formatter.locale = Locale(identifier: \"en_US_POSIX\")\n            if string.contains(\",\") {\n                formatter.decimalSeparator = \",\"\n            } else {\n                formatter.decimalSeparator = \".\"\n            }\n            return formatter.number(from: string)?.doubleValue\n        }\n    }\n    \n    let aDouble = convertToDouble(value: a)\n    let bDouble = convertToDouble(value: b)\n    \n    if let aDouble = aDouble, let bDouble = bDouble {\n        if aDouble > bDouble {\n            return a\n        } else if bDouble > aDouble {\n            return b\n        }\n    }\n    \n    return nil\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)"},{"task_id":"HumanEval_138","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال \/\/ ارزیابی کنید که آیا عدد n داده شده را می توان به عنوان مجموع 4 عدد مثبت جفت به طور دقیق نوشت \/\/\/ >>> is_equal_to_sum_even(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 8)\n\/\/\/ true\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n","canonical_solution":"func is_equal_to_sum_even(n: Int) -> Bool {\n    if n <= 8 {\n        return false\n    }\n    return n % 2 == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_equal_to_sum_even(n: 4) == false)\nassert(is_equal_to_sum_even(n: 6) == false)\nassert(is_equal_to_sum_even(n: 8) == true)\nassert(is_equal_to_sum_even(n: 10) == true)\nassert(is_equal_to_sum_even(n: 11) == false)\nassert(is_equal_to_sum_even(n: 12) == true)\nassert(is_equal_to_sum_even(n: 13) == false)\nassert(is_equal_to_sum_even(n: 16) == true)"},{"task_id":"HumanEval_139","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ جاییکه n > 0 \/\/ برازیلی_فاکتورال ((n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/ فاکتورال برزیلی به این شکل تعریف شده است: \/\/\/ >>> special_factorial(n: 4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfunc special_factorial(n: Int) -> Int {\n","canonical_solution":"func factorial(_ n: Int) -> Int {\n    return n <= 1 ? 1 : n * factorial(n - 1)\n}\n\nfunc special_factorial(n: Int) -> Int {\n    var result = 1\n    for i in 1...n {\n        result *= factorial(i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"},{"task_id":"HumanEval_140","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ سپس تمام فضای های متوالی را با -  جایگزین کنید\/\/ و اگر یک رشته دارای بیش از 2 فضای متوالی باشد، \/\/ با توجه به یک رشته متن، تمام فضای موجود در آن را با زیرنویس ها جایگزین کنید، \/\/\/ >>> fix_spaces(text: \" Example\")\n\/\/\/ \"Example\"\n\/\/\/ >>> fix_spaces(text: \" Example 1\")\n\/\/\/ \"Example_1\"\n\/\/\/ >>> fix_spaces(text: \" Example 2\")\n\/\/\/ \"_Example_2\"\n\/\/\/ >>> fix_spaces(text: \" Example 3\")\n\/\/\/ \"_Example-3\"\nfunc fix_spaces(text: String) -> String {\n","canonical_solution":"func fix_spaces(text: String) -> String {\n    var result = \"\"\n    var spaceCount = 0\n    \n    for character in text {\n        if character == \" \" {\n            spaceCount += 1\n        } else {\n            if spaceCount == 1 {\n                result.append(\"_\")\n            } else if spaceCount > 1 {\n                result.append(\"-\")\n            }\n            result.append(character)\n            spaceCount = 0\n        }\n    }\n    \n    if spaceCount == 1 {\n        result.append(\"_\")\n    } else if spaceCount > 1 {\n        result.append(\"-\")\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fix_spaces(text: \"Example\") == \"Example\")\nassert(fix_spaces(text: \"Mudasir Hanif \") == \"Mudasir_Hanif_\")\nassert(fix_spaces(text: \"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\")\nassert(fix_spaces(text: \"Exa   mple\") == \"Exa-mple\")\nassert(fix_spaces(text: \"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\")"},{"task_id":"HumanEval_141","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ - رشته زیر بعد از نقطه باید یکی از این ها باشد: ['txt'، 'exe'، 'dll'] \/\/ الفبای لاتین ('a'-'z' و 'A'-'Z'). \/\/ - زیر رشته قبل از نقطه نباید خالی باشد و با حرف از  شروع می شود\/\/ - نام فایل دقیقاً یک نقطه دارد '.' \/\/ - نام فایل نباید بیش از سه رقم ('0'-'9') داشته باشد. \/\/ برآورده شده اند: \/\/ یک نام فایل در صورتی معتبر است که تمام شرایط زیر را برآورده کند \/\/ اگر نام فایل معتبر باشد \" بله \" را نشان می دهد و در غیر این صورت \" نه \" را باز می گرداند. \/\/ یک تابع ایجاد کنید که یک رشته را که نام یک فایل را نشان می دهد، می گیرد و  را باز می گرداند.\/\/\/ >>> file_name_check(file_name: \"example.txt\")\n\/\/\/ \"Yes\"\n\/\/\/ >>> file_name_check(file_name: \"1example.dll\")\n\/\/\/ \"No\"\nfunc file_name_check(file_name: String) -> String {\n","canonical_solution":"func file_name_check(file_name: String) -> String {\n    \/\/ Split by the dot.\n    let components = file_name.split(separator: \".\", omittingEmptySubsequences: false)\n    \n    \/\/ Check if there's exactly one dot.\n    guard components.count == 2 else {\n        return \"No\"\n    }\n    \n    \/\/ Extract the prefix and suffix.\n    let prefix = String(components[0])\n    let suffix = String(components[1])\n    \n    \/\/ Check if the prefix is non-empty and starts with a letter.\n    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {\n        return \"No\"\n    }\n    \n    \/\/ Check if the suffix is one of the allowed types.\n    let validSuffixes = [\"txt\", \"exe\", \"dll\"]\n    guard validSuffixes.contains(suffix) else {\n        return \"No\"\n    }\n    \n    \/\/ Count digits in the file name.\n    let digitCount = file_name.filter { $0.isNumber }.count\n    \n    \/\/ Ensure that there are not more than 3 digits.\n    guard digitCount <= 3 else {\n        return \"No\"\n    }\n    \n    \/\/ If all checks pass, it's a valid file name.\n    return \"Yes\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(file_name_check(file_name: \"example.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"1example.dll\") == \"No\")\nassert(file_name_check(file_name: \"s1sdf3.asd\") == \"No\")\nassert(file_name_check(file_name: \"K.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"MY16FILE3.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"His12FILE94.exe\") == \"No\")\nassert(file_name_check(file_name: \"_Y.txt\") == \"No\")\nassert(file_name_check(file_name: \"?aREYA.exe\") == \"No\")\nassert(file_name_check(file_name: \"\/this_is_valid.dll\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.wow\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"this_is_valid.txtexe\") == \"No\")\nassert(file_name_check(file_name: \"#this2_i4s_5valid.ten\") == \"No\")\nassert(file_name_check(file_name: \"@this1_is6_valid.exe\") == \"No\")\nassert(file_name_check(file_name: \"this_is_12valid.6exe4.txt\") == \"No\")\nassert(file_name_check(file_name: \"all.exe.txt\") == \"No\")\nassert(file_name_check(file_name: \"I563_No.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"Is3youfault.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"no_one#knows.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"1I563_Yes3.exe\") == \"No\")\nassert(file_name_check(file_name: \"I563_Yes3.txtt\") == \"No\")\nassert(file_name_check(file_name: \"final..txt\") == \"No\")\nassert(file_name_check(file_name: \"final132\") == \"No\")\nassert(file_name_check(file_name: \"_f4indsartal132.\") == \"No\")\nassert(file_name_check(file_name: \".txt\") == \"No\")\nassert(file_name_check(file_name: \"s.\") == \"No\")"},{"task_id":"HumanEval_143","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال 1: \/\/ ترتیب کلمات در رشته جدید باید همان کلمه اصلی باشد. \/\/ که طول آن ها اعداد اول هستند، \/\/ و شما باید یک رشته را که شامل کلمات از جمله اصلی است، \/\/ جمله شامل بعضی از کلمات است که با یک فضای خالی جدا شده اند، \/\/ یک رشته برای بیان یک جمله به شما داده می شود، \/\/\/ >>> words_in_sentence(sentence: \"This is a test\")\n\/\/\/ \"is\"\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(sentence: \"lets go for swimming\")\n\/\/\/ \"go for\"\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence: String) -> String {\n","canonical_solution":"func words_in_sentence(sentence: String) -> String {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    let words = sentence.split(separator: \" \")\n    let primeLengthWords = words.filter { isPrime($0.count) }\n    return primeLengthWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"},{"task_id":"HumanEval_144","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ شما می توانید فرض کنید که x و n کسری های معتبر هستند و صفر را به عنوان ممیز ندارند. \/\/ <عدد>\/<معادل> که هم عدد و هم معادل اعداد کامل مثبت هستند. \/\/ در غیر این صورت. هر دو x و n، نمایش رشته ای از کسری هستند و دارای فرمت زیر هستند، \/\/ x * n. تابع اگر x * n به یک عدد کامل و false  ارجاع دهد درست است.\/\/ وظیفه شما این است که یک تابع را پیاده سازی کنید که عبارت را ساده کند \/\/\/ >>> simplify(x: \"1\/5\", n: \"5\/1\")\n\/\/\/ true\n\/\/\/ >>> simplify(x: \"1\/6\", n: \"2\/1\")\n\/\/\/ false\n\/\/\/ >>> simplify(x: \"7\/10\", n: \"10\/2\")\n\/\/\/ false\nfunc simplify(x: String, n: String) -> Bool {\n","canonical_solution":"func simplify(x: String, n: String) -> Bool {\n    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {\n        let parts = fraction.split(separator: \"\/\").map { Int($0)! }\n        return (numerator: parts[0], denominator: parts[1])\n    }\n    \n    let (xNumerator, xDenominator) = parseFraction(fraction: x)\n    let (nNumerator, nDenominator) = parseFraction(fraction: n)\n    \n    \/\/ Multiply the two fractions: (xNumerator * nNumerator) \/ (xDenominator * nDenominator)\n    let resultNumerator = xNumerator * nNumerator\n    let resultDenominator = xDenominator * nDenominator\n    \n    \/\/ Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator\n    return resultNumerator % resultDenominator == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/6\", n: \"2\/1\") == false)\nassert(simplify(x: \"5\/1\", n: \"3\/1\") == true)\nassert(simplify(x: \"7\/10\", n: \"10\/2\") == false)\nassert(simplify(x: \"2\/10\", n: \"50\/10\") == true)\nassert(simplify(x: \"7\/2\", n: \"4\/2\") == true)\nassert(simplify(x: \"11\/6\", n: \"6\/1\") == true)\nassert(simplify(x: \"2\/3\", n: \"5\/2\") == false)\nassert(simplify(x: \"5\/2\", n: \"3\/5\") == false)\nassert(simplify(x: \"2\/4\", n: \"8\/4\") == true)\nassert(simplify(x: \"2\/4\", n: \"4\/2\") == true)\nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/5\", n: \"1\/5\") == false)"},{"task_id":"HumanEval_145","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ آنها را بر اساس شاخص آنها در آرایه اصلی مرتب کنید. \/\/ توجه: اگر چندین آیتم با جمع مشابه رقم های آنها وجود داشته باشد، \/\/ در ترتیب رو به بالا بر اساس جمع رقم های آن ها. \/\/ یک تابع بنویسید که آرایه داده شده از اعداد صحیح را مرتب کند \/\/\/ >>> order_by_points(nums: [1, 11, -1, -11, -12])\n\/\/\/ [-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(nums: [] as [Int])\n\/\/\/ [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n","canonical_solution":"func order_by_points(nums: [Int]) -> [Int] {\n    return nums.enumerated().sorted {\n        let sum1 = digitSum($0.element)\n        let sum2 = digitSum($1.element)\n        if sum1 == sum2 {\n            return $0.offset < $1.offset\n        } else {\n            return sum1 < sum2\n        }\n    }.map { $0.element }\n}\n\nfunc digitSum(_ number: Int) -> Int {\n    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"},{"task_id":"HumanEval_146","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ رقم های اول و آخر یک عدد عجیب هستند (1, 3, 5, 7, 9). \/\/ تعداد عناصر در آرایه که بزرگتر از 10 و هر دو است \/\/ یک تابع بنویسید که یک آرایه از اعداد را به عنوان ورودی و بازدهی می گیرد \/\/\/ >>> specialFilter(nums: [15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfunc specialFilter(nums: [Int]) -> Int {\n","canonical_solution":"func specialFilter(nums: [Int]) -> Int {\n    return nums.filter { num in\n        let absNum = abs(num)\n        \n        guard absNum > 10 else {\n            return false\n        }\n        \n        let firstDigit = String(String(absNum).first!)\n        let lastDigit = String(absNum % 10)\n        \n        let oddDigits: Set = [\"1\", \"3\", \"5\", \"7\", \"9\"]\n        \n        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(specialFilter(nums: [5, -2, 1, -5]) == 0)\nassert(specialFilter(nums: [15, -73, 14, -15]) == 1)\nassert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)\nassert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)\nassert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)\nassert(specialFilter(nums: [1]) == 0)\nassert(specialFilter(nums: [] as [Int]) == 0)"},{"task_id":"HumanEval_147","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ و a[i] + a[j] + a[k] یک ضرب از 3 است. \/\/ تعداد سه گانه (a[i]، a[j]، a[k]) را از a که در آن i < j < k، \/\/ برای هر i (1 ≤ i ≤ n) ، ارزش a[i] = i * i - i + 1 است. \/\/ شما یک عدد صحیح مثبت n داده شده است. شما باید یک آرایه عدد صحیح a با طول n ایجاد کنید. \/\/\/ >>> get_max_triples(n: 5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n: Int) -> Int {\n","canonical_solution":"func get_max_triples(n: Int) -> Int {\n    \/\/ Create the array a based on the problem description\n    var a = [Int](repeating: 0, count: n)\n    for i in 1...n {\n        a[i - 1] = i * i - i + 1\n    }\n    \n    var count = 0\n    \/\/ Check for all possible triples\n    for i in 0..<n {\n        for j in (i + 1)..<n {\n            for k in (j + 1)..<n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1\n                }\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_max_triples(n: 5) == 1)\nassert(get_max_triples(n: 6) == 4)\nassert(get_max_triples(n: 10) == 36)\nassert(get_max_triples(n: 100) == 53361)"},{"task_id":"HumanEval_149","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ شما ممکن است فرض کنید که تمام کلمات طول یکسانی دارند. \/\/ تابع باید یک آرایه از رشته ها را در ترتیب مرتب برگرداند. \/\/ اگر دو کلمه دارای طول یکسان باشند، آرایه را به ترتیب الفبایی مرتب کنید. \/\/ باید آرایه را که با این قاعده مرتب شده است، بازگردانده شود. \/\/ ترتیب آرایه باید با طول هر کلمه بالا رود، و شما \/\/ و ممکن است حاوی نسخه های تکراری باشد. \/\/ آرایه همیشه یک آرایه از رشته ها است و هرگز یک آرایه از اعداد نیست، \/\/ و آرایه حاصل را با یک ترتیب مرتب شده باز می گرداند، \/\/ رشته هایی را که طول های عجیب دارند حذف می کند، \/\/ یک تابع بنویسید که یک آرایه از رشته ها را به عنوان پارامتر قبول کند، \/\/\/ >>> sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"])\n\/\/\/ [\"aa\"]\n\/\/\/ >>> sorted_list_sum(lst: [\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/\/ [\"ab\", \"cd\"]\nfunc sorted_list_sum(lst: [String]) -> [String] {\n","canonical_solution":"func sorted_list_sum(lst: [String]) -> [String] {\n    return lst.filter { $0.count % 2 == 0 }\n              .sorted { \n                  if $0.count == $1.count {\n                      return $0 < $1\n                  }\n                  return $0.count < $1.count\n              }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"]) == [\"aa\"])\nassert(sorted_list_sum(lst: [\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"])\nassert(sorted_list_sum(lst: [\"d\", \"b\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\nassert(sorted_list_sum(lst: [\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\nassert(sorted_list_sum(lst: [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])"},{"task_id":"HumanEval_150","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ یک عدد اول است و باید مقدار y را در غیر این صورت بازگردانده شود. \/\/ یک برنامه ساده که باید ارزش x را اگر n  باشد بازگردانده باشد\/\/\/ >>> x_or_y(n: 7, x: 34, y: 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(n: 15, x: 8, y: 5)\n\/\/\/ 5\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n","canonical_solution":"func x_or_y(n: Int, x: Int, y: Int) -> Int {\n    func isPrime(_ number: Int) -> Bool {\n        if number <= 1 { return false }\n        if number <= 3 { return true }\n        if number % 2 == 0 || number % 3 == 0 { return false }\n        \n        var i = 5\n        while i * i <= number {\n            if number % i == 0 || number % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    return isPrime(n) ? x : y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(x_or_y(n: 7, x: 34, y: 12) == 34)\nassert(x_or_y(n: 15, x: 8, y: 5) == 5)\nassert(x_or_y(n: 3, x: 33, y: 5212) == 33)\nassert(x_or_y(n: 1259, x: 3, y: 52) == 3)\nassert(x_or_y(n: 7919, x: -1, y: 12) == -1)\nassert(x_or_y(n: 3609, x: 1245, y: 583) == 583)\nassert(x_or_y(n: 91, x: 56, y: 129) == 129)\nassert(x_or_y(n: 6, x: 34, y: 1234) == 1234)\nassert(x_or_y(n: 1, x: 2, y: 0) == 0)\nassert(x_or_y(n: 2, x: 2, y: 0) == 2)"},{"task_id":"HumanEval_151","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ در آرایه ای که عجیب هستند. اعداد منفی یا غیر عدد را نادیده بگیرید. \/\/ با دادن یک آرایه از اعداد، جمع مربع های اعداد را برگردانید \/\/\/ >>> double_the_difference(lst: [1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(lst: [-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(lst: [9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(lst: [0])\n\/\/\/ 0\n\/\/\/ If the input array is empty, return 0.\nfunc double_the_difference(lst: [Double]) -> Int {\n","canonical_solution":"func double_the_difference(lst: [Double]) -> Int {\n    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }\n              .map { Int($0) * Int($0) }\n              .reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(double_the_difference(lst: [] as [Double]) == 0)\nassert(double_the_difference(lst: [5.0, 4.0]) == 25)\nassert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)\nassert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)\nassert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)\nassert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)\nassert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"},{"task_id":"HumanEval_152","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ ارزش 0 است و اگر نه، ارزش تفاوت مطلق بین حدس و امتیاز است. \/\/ یک آرایه با همان طول را نشان می دهد که هر حدس چقدر دور است. اگر آنها درست حدس زده اند، \/\/ شما دو آرایه از امتیازات و حدس های با طول مساوی داده می شوید، که هر شاخص یک مطابقت را نشان می دهد. \/\/ وظیفه شما این است که تعیین کنید که آیا یک شخص نتایج یک تعداد از بازی ها را به درستی حدس زده است. \/\/ قطعاً ارزش یادداشت کردن و مقایسه کردن را دارد. \/\/ بالاخره اتفاق مشخص می شود. احساسات و افکار شما در آن لحظه \/\/ فکر کنم همه ما این حس را به یاد داریم وقتی نتیجه یک انتظار طولانی\/\/\/ >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])\n\/\/\/ [0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])\n\/\/\/ [4, 4, 1, 0, 0, 6]\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n","canonical_solution":"func compare(game: [Int], guess: [Int]) -> [Int] {\n    var result: [Int] = []\n    \n    for i in 0..<game.count {\n        let difference = abs(game[i] - guess[i])\n        result.append(difference)\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])\nassert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])\nassert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])\nassert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"},{"task_id":"HumanEval_153","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ (قدرت آن -1 است) \/\/ به عنوان \"Slices.SERVINGSliCes\" را باز می گرداند زیرا \"SERVINGSliCes\" قوی ترین تمدید است \/\/ پس از آن شما باید \/\/ برای مثال، اگر به شما \"Slices\" به عنوان کلاس و یک آرایه از \/\/ یکی از اولین ها را در آرایه انتخاب کنید. \/\/ اگر دو یا چند تمدید با همان قدرت وجود داشته باشد، باید \/\/ فرمت: ClassName.StrongestExtensionName. \/\/ باید قوی ترین تمدید را پیدا کنید و یک رشته را در این \/\/ در نام این افزونه، قدرت با کسری CAP - SM داده می شود. \/\/ حروف در نام افزونه، و SM را به عنوان تعداد حروف کوچک \/\/ قدرت این افزونه به شرح زیر است: بگذارید CAP عدد بزرگ باشد \/\/ از افزونه ها برای بارگذاری کلاس های اضافی به کلاس استفاده می شود.\/\/ شما نام یک کلاس (یک رشته) و یک آرایه از افزونه ها را دریافت خواهید کرد. \/\/\/ >>> Strongest_Extension(class_name: \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n\/\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n","canonical_solution":"func Strongest_Extension(class_name: String, extensions: [String]) -> String {\n    var strongestExtension: String? = nil\n    var maxStrength = Int.min\n    \n    for ext in extensions {\n        let cap = ext.filter { $0.isUppercase }.count\n        let sm = ext.filter { $0.isLowercase }.count\n        let strength = cap - sm\n        \n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = ext\n        }\n    }\n    \n    if let strongestExt = strongestExtension {\n        return \"\\(class_name).\\(strongestExt)\"\n    }\n    \n    return class_name\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"},{"task_id":"HumanEval_154","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ شما دو کلمه داده شده است. شما باید راست را برگردانید اگر کلمه دوم یا هر یک از چرخش های آن یک زیر رشته در کلمه اول باشد.\/\/\/ >>> cycpattern_check(a: \"abcd\", b: \"abd\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"hello\", b: \"ell\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"whassup\", b: \"psus\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"abab\", b: \"baa\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"efef\", b: \"eeff\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"himenss\", b: \"simen\")\n\/\/\/ true\nfunc cycpattern_check(a: String, b: String) -> Bool {\n","canonical_solution":"func cycpattern_check(a: String, b: String) -> Bool {\n    guard !b.isEmpty else { return true }\n    let bCombined = b + b\n    for i in 0..<b.count {\n        let rotation = String(bCombined.dropFirst(i).prefix(b.count))\n        if a.contains(rotation) {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cycpattern_check(a: \"xyzw\", b: \"xyw\") == false)\nassert(cycpattern_check(a: \"yello\", b: \"ell\") == true)\nassert(cycpattern_check(a: \"whattup\", b: \"ptut\") == false)\nassert(cycpattern_check(a: \"efef\", b: \"fee\") == true)\nassert(cycpattern_check(a: \"abab\", b: \"aabb\") == false)\nassert(cycpattern_check(a: \"winemtt\", b: \"tinem\") == true)"},{"task_id":"HumanEval_155","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ با دادن یک عدد صحیح. یک توپل را که به ترتیب دارای عدد اعداد جفت و عجیب است، بازگردانید. \/\/\/ >>> even_odd_count(num: -12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(num: 123)\n\/\/\/ (1, 2)\nfunc even_odd_count(num: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_count(num: Int) -> (Int, Int) {\n    var countEvens = 0\n    var countOdds = 0\n    var number = abs(num) \/\/ Handle negative numbers by taking absolute value\n\n    while number > 0 {\n        let digit = number % 10\n        if digit % 2 == 0 {\n            countEvens += 1\n        } else {\n            countOdds += 1\n        }\n        number \/= 10\n    }\n    return (countEvens, countOdds)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_count(num: 7) == (0, 1))\nassert(even_odd_count(num: -78) == (1, 1))\nassert(even_odd_count(num: 3452) == (2, 2))\nassert(even_odd_count(num: 346211) == (3, 3))\nassert(even_odd_count(num: -345821) == (3, 3))\nassert(even_odd_count(num: -2) == (1, 0))\nassert(even_odd_count(num: -45347) == (2, 3))\nassert(even_odd_count(num: 0) == (1, 0))"},{"task_id":"HumanEval_156","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها: \/\/ محدودیت ها: 1 <= num <= 1000 \/\/ و آنرا با حروف کوچک برگردانید. \/\/ با دادن یک عدد صحیح مثبت، معادل آن را به شکل یک رشته در اعداد رومی بدست آورید، \/\/\/ >>> int_to_mini_roman(number: 19)\n\/\/\/ \"xix\"\n\/\/\/ >>> int_to_mini_roman(number: 152)\n\/\/\/ \"clii\"\n\/\/\/ >>> int_to_mini_roman(number: 426)\n\/\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number: Int) -> String {\n","canonical_solution":"func int_to_mini_roman(number: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    \n    var num = number\n    var result = \"\"\n    \n    for (index, value) in values.enumerated() {\n        while num >= value {\n            result += numerals[index]\n            num -= value\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"},{"task_id":"HumanEval_157","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ 90 درجه. \/\/ مثلث با زاویه راست مثلثی است که در آن یک زاویه درست است یا \/\/ طرف ها یک مثلث با زاویه راست را تشکیل می دهند، در غیر این صورت غلط است. \/\/ طول های سه طرف مثلث را داده است. اگر سه \/\/\/ >>> right_angle_triangle(a: 3, b: 4, c: 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(a: 1, b: 2, c: 3)\n\/\/\/ false\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n","canonical_solution":"func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n    let sides = [a, b, c].sorted()\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(right_angle_triangle(a: 3, b: 4, c: 5) == true)\nassert(right_angle_triangle(a: 1, b: 2, c: 3) == false)\nassert(right_angle_triangle(a: 10, b: 6, c: 8) == true)\nassert(right_angle_triangle(a: 2, b: 2, c: 2) == false)\nassert(right_angle_triangle(a: 7, b: 24, c: 25) == true)\nassert(right_angle_triangle(a: 10, b: 5, c: 7) == false)\nassert(right_angle_triangle(a: 5, b: 12, c: 13) == true)\nassert(right_angle_triangle(a: 15, b: 8, c: 17) == true)\nassert(right_angle_triangle(a: 48, b: 55, c: 73) == true)\nassert(right_angle_triangle(a: 1, b: 1, c: 1) == false)\nassert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"},{"task_id":"HumanEval_158","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ کاراکتر ها، کاراکتر را که در ترتیب لغت شناسی اول می آید، باز می گرداند. \/\/ از کاراکتر های منحصر به فرد. اگر چندین رشته دارای حداکثر تعداد کاراکتر های منحصر به فرد باشد \/\/ آرایه شامل کلمات مختلف است. کلمه را با حداکثر تعداد \/\/ یک تابع بنویسید که یک آرایه از رشته ها را قبول کند. \/\/\/ >>> find_max(words: [\"name\", \"of\", \"string\"])\n\/\/\/ \"string\"\n\/\/\/ >>> find_max(words: [\"name\", \"enam\", \"game\"])\n\/\/\/ \"enam\"\n\/\/\/ >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/\/ \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n","canonical_solution":"func find_max(words: [String]) -> String {\n    func uniqueCharacterCount(in word: String) -> Int {\n        return Set(word).count\n    }\n    \n    return words.max { a, b in\n        let uniqueCountA = uniqueCharacterCount(in: a)\n        let uniqueCountB = uniqueCharacterCount(in: b)\n        \n        if uniqueCountA == uniqueCountB {\n            return a > b\n        }\n        \n        return uniqueCountA < uniqueCountB\n    } ?? \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"},{"task_id":"HumanEval_159","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال: \/\/ اگر به اندازه کافی هویج باقی نمانده باشد، شما تمام هویج باقی مانده را می خورید، اما همچنان گرسنه خواهید بود. \/\/ تعداد هویج های باقی مانده بعد از غذا خوردن شما ] \/\/ شما باید یک آرایه از [ تعداد کل هویج های خورده شده بعد از غذا را برگردانید، اما حالا باید هویج بیشتری بخورید تا وعده های غذایی روز کامل شود\/\/ شما یک خرگوش گرسنه هستید، و شما قبلاً تعداد مشخصی هویج خورده اید، \/\/\/ >>> eat(number: 5, need: 6, remaining: 10)\n\/\/\/ [11, 4]\n\/\/\/ >>> eat(number: 4, need: 8, remaining: 9)\n\/\/\/ [12, 1]\n\/\/\/ >>> eat(number: 1, need: 10, remaining: 10)\n\/\/\/ [11, 0]\n\/\/\/ >>> eat(number: 2, need: 11, remaining: 5)\n\/\/\/ [7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n","canonical_solution":"func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalNeeded = number + need\n    let totalEaten = min(totalNeeded, number + remaining)\n    let carrotsLeft = max(0, remaining - (totalEaten - number))\n    return [totalEaten, carrotsLeft]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"},{"task_id":"HumanEval_160","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ آرایه عامل حداقل یک عامل دارد و آرایه عامل حداقل دو عامل دارد. \/\/ آپراند یک آرایه از اعداد صحیح غیر منفی است. \/\/ طول آرایه عامل برابر با طول آرایه آپراند منفی یک است. \/\/ یادداشت: \/\/ => نتیجه = 9 \/\/ نتیجه = 2 + 3 * 4 - 5 \/\/ آرایه = [2, 3, 4, 5] \/\/ عامل['+'، '*'، '-'] \/\/ مثال: \/\/ ضرب (**) \/\/ تقسیم طبقه ( \/\/ ) \/\/ ضرب (* ) \/\/ تخفیف ( - ) \/\/ جمع (+) \/\/ عملیات های بنیادی الجبر: \/\/ عبارت و ارزیابی این عبارت را بازگردانید. \/\/ آرایه دوم یک آرایه از اعداد صحیح است. از دو آرایه داده شده برای ساختن الجبر استفاده کنید \/\/ دو عامل آرایه و یک عامل داده شده. آرایه اول دارای عملیات الجبر اساسی است و func do_algebra(operator: [String], operand: [Int]) -> Int {\n","canonical_solution":"func do_algebra(operator: [String], operand: [Int]) -> Int {\n    var result = operand[0]\n    let precedence: [String: Int] = [\"+\": 1, \"-\": 1, \"*\": 2, \"\/\/\": 2, \"**\": 3]\n    \n    var opStack: [String] = []\n    var numStack: [Int] = [result]\n    \n    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {\n        switch op {\n        case \"+\":\n            return a + b\n        case \"-\":\n            return a - b\n        case \"*\":\n            return a * b\n        case \"\/\/\":\n            return a \/ b\n        case \"**\":\n            return Int(pow(Double(a), Double(b)))\n        default:\n            fatalError(\"Unsupported operator: \\(op)\")\n        }\n    }\n    \n    for i in 0..<operator.count {\n        let currentOp = `operator`[i]\n        let currentNum = operand[i + 1]\n        \n        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {\n            opStack.removeLast()\n            let b = numStack.removeLast()\n            let a = numStack.removeLast()\n            numStack.append(applyOperator(lastOp, b, a))\n        }\n        \n        opStack.append(currentOp)\n        numStack.append(currentNum)\n    }\n    \n    while let lastOp = opStack.popLast() {\n        let b = numStack.removeLast()\n        let a = numStack.removeLast()\n        numStack.append(applyOperator(lastOp, b, a))\n    }\n    \n    return numStack.first!\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(do_algebra(operator: [\"**\", \"*\", \"+\"], operand: [2, 3, 4, 5]) == 37)\nassert(do_algebra(operator: [\"+\", \"*\", \"-\"], operand: [2, 3, 4, 5]) == 9)\nassert(do_algebra(operator: [\"\/\/\", \"*\"], operand: [7, 3, 4]) == 8)"},{"task_id":"HumanEval_161","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ مثال ها \/\/ تابع باید رشته نتیجه را برگرداند. \/\/ اگر رشته هیچ حرفی نداشته باشد، رشته را معکوس کنید. \/\/ در غیر اینصورت اینجوری نگهش دارید. \/\/ اگر s[i] یک حرف باشد، حالت آن را از پایین به بالا یا برعکس، \/\/ شما یک رشته s داده شده است. \/\/\/ >>> solve(s: \"1234\")\n\/\/\/ \"4321\"\n\/\/\/ >>> solve(s: \"ab\")\n\/\/\/ \"AB\"\n\/\/\/ >>> solve(s: \"#a@C\")\n\/\/\/ \"#A@c\"\nfunc solve(s: String) -> String {\n","canonical_solution":"func solve(s: String) -> String {\n    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n    \n    var result = \"\"\n    for char in s {\n        if char.isLetter {\n            if char.isLowercase {\n                result.append(char.uppercased())\n            } else {\n                result.append(char.lowercased())\n            }\n        } else {\n            result.append(char)\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"},{"task_id":"HumanEval_162","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ اگر 'متن' یک رشته خالی باشد، null را بازگردانید. \/\/ با توجه به یک رشته 'text' ، رشته معادل هش md5 آن را برگردانید. \/\/\/ >>> string_to_md5(text: \"Hello world\")\n\/\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunc string_to_md5(text: String) -> String? {\n","canonical_solution":"import Foundation\nimport CommonCrypto\n\nfunc string_to_md5(text: String) -> String? {\n    guard !text.isEmpty else { return nil }\n    \n    let length = Int(CC_MD5_DIGEST_LENGTH)\n    let messageData = text.data(using: .utf8)!\n    var digestData = Data(count: length)\n    \n    _ = digestData.withUnsafeMutableBytes { digestBytes in\n        messageData.withUnsafeBytes { messageBytes in\n            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)\n        }\n    }\n    \n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\nassert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\nassert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\")"},{"task_id":"HumanEval_163","nl":"prs_Arab","pl":"swift","prompt":"\n\/\/ برای مثال: \/\/ و b، به ترتیب بالا رفتن. \/\/ با توجه به دو عدد صحیح مثبت a و b، رقم های جفت بین a را برگردانید \/\/\/ >>> generate_integers(a: 2, b: 8)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 8, b: 2)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 10, b: 14)\n\/\/\/ [] as [Int]\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n","canonical_solution":"func generate_integers(a: Int, b: Int) -> [Int] {\n    let lower = min(a, b)\n    let upper = max(a, b)\n    var result = [Int]()\n    \n    for number in lower...upper {\n        if number % 2 == 0 {\n            result.append(number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])\nassert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 17, b: 89) == [] as [Int])"}]