task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,shn_Mymr,swift,"
// ပၼ်ဝႆႉၶွပ်ႇ။ // တူၺ်းတူၺ်းဝႃႈ တီႈၼႂ်း တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉ တူဝ်ၼပ်ႉဢၼ်မီးတီႈၸမ်ၵၼ်တင်းသွင်ဢၼ်ၼၼ်ႉ မီးၼမ်လိူဝ်သေ /// >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)
/// false
/// >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)
/// true
func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
","func has_close_elements(numbers: [Double], threshold: Double) -> Bool {
    let sortedNumbers = numbers.sorted()
    for i in 0..<sortedNumbers.count - 1 {
        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)
assert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)
assert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)
assert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"
HumanEval_1,shn_Mymr,swift,"
// ဢမ်ႇလႆႈဢဝ်လွင်ႈတၢင်းဢၼ်မီးတီႈၼႂ်း သဵၼ်ႈမၢႆၶေႃႈၶဝ်ႈ// ၸုမ်းဢၼ်ၽၢတ်ႇၵၼ်ၼၼ်ႉ ၽဵင်ႇပဵင်းၵၼ် (ၵွၵ်းဢၼ်ပိုတ်ႇဝႆႉဢၼ်လႂ်ဢၼ်ၼၼ်ႉ လႆႈထုၵ်ႇပိၵ်ႉဝႆႉလီလီ) လႄႈ ဢမ်ႇလႆႈၶွၼ်ႈၵၼ်ဝႆႉၼ်ႂးၵၼ်ၼၼ်ႉယဝ်ႉ။// ၸႅၵ်ႇဢွၵ်ႇ ၸုမ်းၸိူဝ်းၼၼ်ႉ ႁႂ်ႈပဵၼ် သဵၼ်ႈမၢႆဢၼ်ပႅၵ်ႇပိူင်ႈၵၼ်သေ ၶိုၼ်းဢဝ် array ၶွင်ၸိူဝ်းၼၼ်ႉ လၢႆႈပၼ်။// Input to this function is a string containing multiple groups of nested parentheses. ယိူင်းဢၢၼ်းၸဝ်ႈၵဝ်ႇၼႆႉပဵၼ်တႃႇ /// >>> separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"")
/// [""()"", ""(())"", ""(()())""]
func separate_paren_groups(paren_string: String) -> [String] {
","func separate_paren_groups(paren_string: String) -> [String] {
    var results = [String]()
    var currentGroup = """"
    var balance = 0

    for char in paren_string {
        // Ignore spaces
        if char == "" "" {
            continue
        }
        
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }

        currentGroup.append(char)

        if balance == 0 && !currentGroup.isEmpty {
            results.append(currentGroup)
            currentGroup = """"
        }
    }
    
    return results
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(separate_paren_groups(paren_string: ""(()()) ((())) () ((())()())"") == [""(()())"", ""((()))"", ""()"", ""((())()())""])
assert(separate_paren_groups(paren_string: ""() (()) ((())) (((())))"") == [""()"", ""(())"", ""((()))"", ""(((())))""])
assert(separate_paren_groups(paren_string: ""(()(())((())))"") == [""(()(())((())))""])
assert(separate_paren_groups(paren_string: ""( ) (( )) (( )( ))"") == [""()"", ""(())"", ""(()())""])"
HumanEval_2,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉသႅၼ်မႄႈလိၵ်ႈ ဢၼ်ဢွၵ်ႇမႃးတီႈ တူဝ်ၼပ်ႉၼၼ်ႉမႃး။ (တွၼ်ႈဢၼ်ၵိုတ်းဝႆႉၼၼ်ႉ ၵႆႉၵႆႉလဵၵ်ႉလိူဝ်သေ 1) ။// လႄႈ တူဝ်ၼပ်ႉတဵမ် (တူဝ်ၼပ်ႉတဵမ် ဢၼ်ယႂ်ႇသုတ်း ဢၼ်လဵၵ်ႉလိူဝ်သေ တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉ) လႄႈ တူဝ်ၼပ်ႉၸုတ်ႉ // ပေႃးဝႃႈပၼ်ဝႆႉ တူဝ်ၼပ်ႉ floating point ဢၼ်လီၼႆၸိုင် မၼ်းတေၸႅၵ်ႇဢွၵ်ႇလႆႈပဵၼ် /// >>> truncate_number(number: 3.5)
/// 0.5
func truncate_number(number: Double) -> Double {
","func truncate_number(number: Double) -> Double {
    return number - Double(Int(number))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(truncate_number(number: 3.5) == 0.5)
assert(truncate_number(number: 1.25) == 0.25)
assert(truncate_number(number: 123.0) == 0.0)"
HumanEval_3,shn_Mymr,swift,"
ပေႃးဢမ်ႇၼၼ် မၼ်းတေၶိုၼ်းမႃး falseၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉ ပဵၼ်တႃႇတေသွၵ်ႈႁႃဝႃႈ တီႈၶၵ်ႉတွၼ်ႈလႂ်သေဢမ်ႇဝႃႈ လွင်ႈၵိုတ်းယိုဝ်းၶွင်ငိုၼ်းတွင်းၼၼ်ႉ တူၵ်းလူင်းတႂ်ႈ သုၼ်မႃးၼႆလႄႈ// သူတေလႆႈပၼ်ဝႆႉ လွင်ႈၸႅၵ်ႇၽႄ ၵၢၼ်သႂ်ႇငိုၼ်း လႄႈ ၵၢၼ်ထွၼ်ငိုၼ်း တီႈၼႂ်းမၢႆတွင်းပၢၼ်ႇၵၢတ်ႉ ဢၼ်တႄႇလူၺ်ႈ /// >>> below_zero(operations: [1, 2, 3])
/// false
/// >>> below_zero(operations: [1, 2, -4, 5])
/// true
func below_zero(operations: [Int]) -> Bool {
","func below_zero(operations: [Int]) -> Bool {
    var balance = 0
    for operation in operations {
        balance += operation
        if balance < 0 {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_zero(operations: [] as [Int]) == false)
assert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)
assert(below_zero(operations: [1, 2, -4, 5, 6]) == true)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)
assert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)
assert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"
HumanEval_4,shn_Mymr,swift,"
MAD = average  ၶၼ် - ၶၼ်ၵၢင် // elements လႄႈ centerpoint (ဢၼ်ၼႆႉပဵၼ်ဢၼ်မီးတီႈပွင်ႇ)// Mean Absolute Deviation ၼႆႉပဵၼ် လၢႆႊၵႃႊဢၼ်ပႅၵ်ႇပိူင်ႈၵၼ် ၼႂ်းၵႄႈ // လဵပ်ႈႁဵၼ်းတူၺ်း ၶေႃႈမုၼ်းဢၼ်ၼႆႉ။// တွၼ်ႈတႃႇ တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉဢၼ်ပဵၼ် ၶႅပ်းႁၢင်ႈ၊ ထတ်းသၢင်ႈ Mean Absolute Deviation /// >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])
/// 1.0
func mean_absolute_deviation(numbers: [Double]) -> Double {
","func mean_absolute_deviation(numbers: [Double]) -> Double {
    guard !numbers.isEmpty else { return 0.0 }
    
    let mean = numbers.reduce(0.0, +) / Double(numbers.count)
    let absoluteDifferences = numbers.map { abs($0 - mean) }
    let mad = absoluteDifferences.reduce(0.0, +) / Double(absoluteDifferences.count)
    
    return mad
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)
assert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"
HumanEval_5,shn_Mymr,swift,"
// သႂ်ႇတူဝ်ၼပ်ႉ 'delimeter' ၼႂ်းၵႄႈ တူဝ်ၼပ်ႉဢၼ်ထႅဝ်ၵၼ်သွင်ဢၼ် ၶွင် input array ∀numbers' /// >>> intersperse(numbers: [] as [Int], delimeter: 4)
/// [] as [Int]
/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)
/// [1, 4, 2, 4, 3]
func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
","func intersperse(numbers: [Int], delimeter: Int) -> [Int] {
    guard !numbers.isEmpty else { return [] }
    
    var result: [Int] = []
    
    for number in numbers {
        result.append(number)
        result.append(delimeter)
    }
    
    // Remove the last added delimiter
    result.removeLast()
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])
assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])
assert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
HumanEval_6,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း (() (()) ၼႆႉ မီးဝႆႉ ၸၼ်ႉဢၼ်ႁဵတ်းႁၢင်ႇဝႆႉသွင်ဢၼ်သေတႃႉ ((())) ၼႆႉ မီးဝႆႉ သၢမ်ဢၼ်ယဝ်ႉ။// တွၼ်ႈတႃႇၸုမ်းလႂ်ၸုမ်းၼၼ်ႉ၊ ဢွၵ်ႇပၼ် ထၢၼ်ႈဢၼ်လိုၵ်ႉသုတ်းၶွင် လွင်ႈဢဝ်ပႅတ်ႇၵႅၼ်ႇဢၼ်မီးတီႈၼႂ်းၵႄႈၼၼ်ႉ။// Input to this function is a string represented multiple groups for nested parentheses separated by spaces. // ဢၼ်ၶဝ်ႈၸူးၼႂ်းၾွၼ်ႉၼႆႉ ပဵၼ် သဵၼ်ႈမၢႆ ဢၼ်တႅၼ်းတၢင်ဝႆႉ လၢႆလၢႆၸုမ်း တွၼ်ႈတႃႇ ၶႅပ်းႁႆႇၵွင် ဢၼ်ၸႅၵ်ႇဝႆႉလူၺ်ႈ လွင်ႈပႅၵ်ႇပိူင်ႈ။/// >>> parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"")
/// [2, 3, 1, 3]
func parse_nested_parens(paren_string: String) -> [Int] {
","func parse_nested_parens(paren_string: String) -> [Int] {
    let groups = paren_string.split(separator: "" "")
    var depths: [Int] = []
    
    for group in groups {
        var maxDepth = 0
        var currentDepth = 0
        
        for char in group {
            if char == ""("" {
                currentDepth += 1
                if currentDepth > maxDepth {
                    maxDepth = currentDepth
                }
            } else if char == "")"" {
                currentDepth -= 1
            }
        }
        
        depths.append(maxDepth)
    }
    
    return depths
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_nested_parens(paren_string: ""(()()) ((())) () ((())()())"") == [2, 3, 1, 3])
assert(parse_nested_parens(paren_string: ""() (()) ((())) (((())))"") == [1, 2, 3, 4])
assert(parse_nested_parens(paren_string: ""(()(())((())))"") == [4])"
HumanEval_7,shn_Mymr,swift,"
// ၸၢၵ်ႈၸႅၵ်ႉထရီႇ ဢၼ်ၶဝ်ႈဝႆႉ သဵၼ်ႈသၢႆမၢႆ ဢၼ်ပႃးဝႆႉ သဵၼ်ႈသၢႆမၢႆဢၼ်ပၼ်ဝႆႉၼၼ်ႉၵူၺ်း/// >>> filter_by_substring(strings: [] as [String], substring: ""a"")
/// [] as [String]
/// >>> filter_by_substring(strings: [""abc"", ""bacd"", ""cde"", ""array""], substring: ""a"")
/// [""abc"", ""bacd"", ""array""]
func filter_by_substring(strings: [String], substring: String) -> [String] {
","func filter_by_substring(strings: [String], substring: String) -> [String] {
    return strings.filter { $0.contains(substring) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_substring(strings: [] as [String], substring: ""john"") == [] as [String])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], substring: ""xx"") == [""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""])
assert(filter_by_substring(strings: [""grunt"", ""trumpet"", ""prune"", ""gruesome""], substring: ""run"") == [""grunt"", ""prune""])"
HumanEval_8,shn_Mymr,swift,"
// တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီးတူဝ်ၼၼ်ႉ တေလႆႈပဵၼ် 0 လႄႈ တူဝ်ၵုၼ်းဢၼ်ဢမ်ႇမီးတူဝ်ၼၼ်ႉ တေလႆႈပဵၼ် 1// တွၼ်ႈတႃႇ တူဝ်ၼပ်ႉတဵမ်ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ပႃးဝႆႉ တူဝ်ၼပ်ႉဢၼ်ႁူမ်ႈၵၼ် လႄႈ တူဝ်ၵုၼ်း တူဝ်ၼပ်ႉတဵမ်တင်းမူတ်း ၼႂ်းတူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉသေ ၶိုၼ်းဢဝ်မႃး။/// >>> sum_product(numbers: [] as [Int])
/// (0, 1)
/// >>> sum_product(numbers: [1, 2, 3, 4])
/// (10, 24)
func sum_product(numbers: [Int]) -> (Int, Int) {
","func sum_product(numbers: [Int]) -> (Int, Int) {
    let sum = numbers.reduce(0, +)
    let product = numbers.reduce(1, *)
    return (sum, product)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_product(numbers: [] as [Int]) == (0, 1))
assert(sum_product(numbers: [1, 1, 1]) == (3, 1))
assert(sum_product(numbers: [100, 0]) == (100, 0))
assert(sum_product(numbers: [3, 5, 7]) == (15, 105))
assert(sum_product(numbers: [10]) == (10, 10))"
HumanEval_9,shn_Mymr,swift,"
// ၼႂ်းလွင်ႈၶပ်ႉၶိုင်။ // လုၵ်ႉတီႈ တူဝ်ၼပ်ႉတဵမ်ဢၼ်ပၼ်ဝႆႉၼၼ်ႉသေ ႁဵတ်းဢွၵ်ႇမႃး တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉ ဢၼ်လႆႈႁၼ် တေႃႇထိုင် ၶၢဝ်းယၢမ်းဢၼ်ပၼ်ဝႆႉၼၼ်ႉ/// >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])
/// [1, 2, 3, 3, 3, 4, 4]
func rolling_max(numbers: [Int]) -> [Int] {
","func rolling_max(numbers: [Int]) -> [Int] {
    var result = [Int]()
    var currentMax: Int? = nil
    for number in numbers {
        if let max = currentMax {
            currentMax = max > number ? max : number
        } else {
            currentMax = number
        }
        result.append(currentMax!)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rolling_max(numbers: [] as [Int]) == [] as [Int])
assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])
assert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
HumanEval_10,shn_Mymr,swift,"
// - ထႅမ်သႂ်ႇပၼ် တီႈသုတ်းၶွင် string ဢၼ်ၽိတ်းပိူင်ႈၶွင် string prefix ဢၼ်မႃးၼႃႈ palindromic suffix ၼၼ်ႉ။ // - သွၵ်ႈႁႃ postfix ဢၼ်ယၢဝ်းသေပိူၼ်ႈ ၼႂ်းသဵၼ်ႈမၢႆဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ဢၼ်ပဵၼ် palindrome (လွင်ႈတႅၵ်ႈဢၼ်တႅၵ်ႈၵၼ်) // ပၢႆးဝူၼ်ႉ ဢႄႇလ်ၵေႃးရီႇထမ်ႇၼႆႉ ငၢႆႈၼႃႇ: // သွၵ်ႈႁႃ palindrome ဢၼ်တိုၵ်ႉသုတ်း ဢၼ်တႄႇလူၺ်ႈ သဵၼ်ႈဢၼ်ပၼ်ဝႆႉၼၼ်ႉ။ /// >>> make_palindrome(string: """")
/// """"
/// >>> make_palindrome(string: ""cat"")
/// ""catac""
/// >>> make_palindrome(string: ""cata"")
/// ""catac""
func make_palindrome(string: String) -> String {
","func make_palindrome(string: String) -> String {
    func isPalindrome(_ s: String) -> Bool {
        return s == String(s.reversed())
    }
    
    if string.isEmpty || isPalindrome(string) {
        return string
    }
    
    for i in stride(from: string.count, through: 0, by: -1) {
        let suffixIndex = string.index(string.startIndex, offsetBy: i)
        let suffix = String(string[suffixIndex..<string.endIndex])
        if isPalindrome(suffix) {
            let prefix = String(string[string.startIndex..<suffixIndex])
            return string + String(prefix.reversed())
        }
    }
    
    return string
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_palindrome(string: """") == """")
assert(make_palindrome(string: ""x"") == ""x"")
assert(make_palindrome(string: ""xyz"") == ""xyzyx"")
assert(make_palindrome(string: ""xyx"") == ""xyx"")
assert(make_palindrome(string: ""jerry"") == ""jerryrrej"")"
HumanEval_11,shn_Mymr,swift,"
// ႁဵတ်းသၢင်ႈ binary XOR တီႈၼိူဝ် inputs ၸိူဝ်းၼႆႉသေ ၶိုၼ်းဢဝ် ၶေႃႈတွပ်ႇမၼ်းမႃးၶိုၼ်း မိူၼ်ၼင်ႇ string ၼၼ်ႉယူႇ။// Input ၼႆႉပဵၼ် သွင်တူဝ်ဢၼ်ပဵၼ် a လႄႈ b ဢၼ်ပႃးဝႆႉ တူဝ် 1 လႄႈ 0 ၵူၺ်း။ /// >>> string_xor(a: ""010"", b: ""110"")
/// ""100""
func string_xor(a: String, b: String) -> String {
","func string_xor(a: String, b: String) -> String {
    let charactersA = Array(a)
    let charactersB = Array(b)
    var result = """"

    for i in 0..<charactersA.count {
        let bitA = charactersA[i]
        let bitB = charactersB[i]
        
        if bitA != bitB {
            result.append(""1"")
        } else {
            result.append(""0"")
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_xor(a: ""111000"", b: ""101010"") == ""010010"")
assert(string_xor(a: ""1"", b: ""1"") == ""0"")
assert(string_xor(a: ""0101"", b: ""0000"") == ""0101"")"
HumanEval_12,shn_Mymr,swift,"
// သဵၼ်ႈသၢႆဢၼ်မီးတၢင်းယၢဝ်းမိူၼ်ၵၼ်ၼၼ်ႉ သင်ဝႃႈ သဵၼ်ႈသၢႆဢၼ်ၶဝ်ႈမႃးၼၼ်ႉ ဢမ်ႇမီးၼႆ ၶိုၼ်းဢဝ် null ၼၼ်ႉၶိုၼ်း// ၼႂ်း array of strings ၼၼ်ႉ ၶိုၼ်းဢဝ်ဢၼ်ယၢဝ်းသေပိူၼ်ႈၼၼ်ႉ ၶိုၼ်းဢဝ်ဢၼ်ဢွၼ်တၢင်းသုတ်းၼၼ်ႉၶိုၼ်း ပေႃးပဵၼ်ဢၼ်ၼမ်လိူဝ်ၼၼ်ႉ/// >>> longest(strings: [] as [String])
/// nil
/// >>> longest(strings: [""a"", ""b"", ""c""])
/// ""a""
/// >>> longest(strings: [""a"", ""bb"", ""ccc""])
/// ""ccc""
func longest(strings: [String]) -> String? {
","func longest(strings: [String]) -> String? {
    guard !strings.isEmpty else { return nil }
    var longestString = strings[0]
    for string in strings {
        if string.count > longestString.count {
            longestString = string
        }
    }
    return longestString
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(longest(strings: [] as [String]) == nil)
assert(longest(strings: [""x"", ""y"", ""z""]) == ""x"")
assert(longest(strings: [""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]) == ""zzzz"")"
HumanEval_13,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ၸႅၵ်ႇၽႄလႆႈ ဢၼ်ယႂ်ႇသေပိူၼ်ႈ ၶွင်တူဝ်ၼပ်ႉတဵမ် a လႄႈ b သွင်တူဝ်ၼၼ်ႉမႃး/// >>> greatest_common_divisor(a: 3, b: 5)
/// 1
/// >>> greatest_common_divisor(a: 25, b: 15)
/// 5
func greatest_common_divisor(a: Int, b: Int) -> Int {
","func greatest_common_divisor(a: Int, b: Int) -> Int {
    if b == 0 {
        return a
    } else {
        return greatest_common_divisor(a: b, b: a % b)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(greatest_common_divisor(a: 3, b: 7) == 1)
assert(greatest_common_divisor(a: 10, b: 15) == 5)
assert(greatest_common_divisor(a: 49, b: 14) == 7)
assert(greatest_common_divisor(a: 144, b: 60) == 12)"
HumanEval_14,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် array prefixes တင်းမူတ်း ဢၼ်ၵႅပ်ႈသုတ်း တေႃႇထိုင် ဢၼ်ယၢဝ်းသုတ်း ၶွင် input string ၼၼ်ႉၶိုၼ်းမႃး/// >>> all_prefixes(string: ""abc"")
/// [""a"", ""ab"", ""abc""]
func all_prefixes(string: String) -> [String] {
","func all_prefixes(string: String) -> [String] {
    var prefixes: [String] = []
    for i in 1...string.count {
        let prefix = String(string.prefix(i))
        prefixes.append(prefix)
    }
    return prefixes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(all_prefixes(string: """") == [] as [String])
assert(all_prefixes(string: ""asdfgh"") == [""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""])
assert(all_prefixes(string: ""WWW"") == [""W"", ""WW"", ""WWW""])"
HumanEval_15,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် string ဢၼ်ပႃး တူဝ်ၼပ်ႉဢၼ်မီးတီႈပွင်ႇတီႈၼွၵ်ႈသေ 0 တေႃႇထိုင် n ႁူမ်ႈပႃးၼၼ်ႉမႃး/// >>> string_sequence(n: 0)
/// ""0""
/// >>> string_sequence(n: 5)
/// ""0 1 2 3 4 5""
func string_sequence(n: Int) -> String {
","func string_sequence(n: Int) -> String {
    return (0...n).map { String($0) }.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_sequence(n: 0) == ""0"")
assert(string_sequence(n: 3) == ""0 1 2 3"")
assert(string_sequence(n: 10) == ""0 1 2 3 4 5 6 7 8 9 10"")"
HumanEval_16,shn_Mymr,swift,"
// ပၼ်ဝႆႉ သတၢႆႇဢၼ်ၼိူင်ႈ၊ သွၵ်ႈႁႃဝႃႈ မၼ်းမီးတူဝ်လိၵ်ႈဢၼ်ပႅၵ်ႇပိူင်ႈတၢင်းၼမ် (ဢမ်ႇဝႃႈတူဝ်ယႂ်ႇလႄႈတူဝ်လဵၵ်ႉ) လၢႆလၢႆဢၼ်ၼၼ်ႉ။/// >>> count_distinct_characters(string: ""xyzXYZ"")
/// 3
/// >>> count_distinct_characters(string: ""Jerry"")
/// 4
func count_distinct_characters(string: String) -> Int {
","func count_distinct_characters(string: String) -> Int {
    let lowercasedString = string.lowercased()
    let distinctCharacters = Set(lowercasedString)
    return distinctCharacters.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_distinct_characters(string: """") == 0)
assert(count_distinct_characters(string: ""abcde"") == 5)
assert(count_distinct_characters(string: ""abcdecadeCADE"") == 5)
assert(count_distinct_characters(string: ""aaaaAAAAaaaa"") == 1)
assert(count_distinct_characters(string: ""Jerry jERRY JeRRRY"") == 5)"
HumanEval_17,shn_Mymr,swift,"
// '. sandhi' - quater note, lasts one beat  ၸိူင်းဢၼ်ပႃးၵွင်ႈၵၢင်ႇဢၼ်မီးႁိမ်းႁွမ်းၼၼ်ႉ// 'oidiyeji' - ၶိုင်ႈၼူၵ်ႉ၊ ၶၢဝ်းတၢင်းသွင်ၵမ်း // 'o' - ပဵၼ်ၶေႃႈၵႂၢမ်းဢၼ်တဵမ်ထူၼ်ႈ၊ ၸူဝ်ႈၶၢဝ်း 4 သဵင်။// မီးဝႆႉ သၢႆပိုၼ်းဢၼ်ၼိုင်ႈ: // ဢမ်ႇပဵၼ်ၵမ်းလိုၼ်းသုတ်း။ // ၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉ ပဵၼ်တႃႇၸႅၵ်ႇထႅဝ်လိၵ်ႈဢၼ်ၼႆႉသေ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်ၵွင်ႉၵၢႆႇၵၼ်တၢင်း တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈဢၼ်ၼၼ်ႉ လႅၵ်ႈလၢႆႈပၼ် // Input to this function is a string representing musical notes in a special ASCII format. // ဢၼ်ၶဝ်ႈၸူးၼႂ်းၽွၼ်ႉၼႆႉ ပဵၼ် သဵၼ်ႈမၢႆ ဢၼ်တႅၼ်းတၢင် ၼေႃႇတႃႇၽဵင်းၵႂၢမ်း ၼႂ်းပိူင်ၾၢင် ASCII ဢၼ်ၶိုၵ်ႉတွၼ်း။/// >>> parse_music(music_string: ""o o| .| o| o| .| .| .| .| o o"")
/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
func parse_music(music_string: String) -> [Int] {
","func parse_music(music_string: String) -> [Int] {
    let notes = music_string.split(separator: "" "")
    var beats: [Int] = []
    
    for note in notes {
        switch note {
        case ""o"":
            beats.append(4)
        case ""o|"":
            beats.append(2)
        case "".|"":
            beats.append(1)
        default:
            continue
        }
    }
    
    return beats
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(parse_music(music_string: """") == [] as [Int])
assert(parse_music(music_string: ""o o o o"") == [4, 4, 4, 4])
assert(parse_music(music_string: "".| .| .| .|"") == [1, 1, 1, 1])
assert(parse_music(music_string: ""o| o| .| .| o o o o"") == [2, 2, 1, 1, 4, 4, 4, 4])
assert(parse_music(music_string: ""o| .| o| .| o o| o o|"") == [2, 1, 2, 1, 4, 2, 4, 2])"
HumanEval_18,shn_Mymr,swift,"
// သွၵ်ႈႁႃဝႃႈ ၸႅၵ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉ တေၸၢင်ႈႁၼ်လႆႈလၢႆၵမ်း ၼႂ်းၸႅၵ်ႉငဝ်ႈမၼ်း။ မၢႆတွင်းလွင်ႈဢၼ်ၶပ်ႉၶိုင်ဝႆႉ။ /// >>> how_many_times(string: """", substring: ""a"")
/// 0
/// >>> how_many_times(string: ""aaa"", substring: ""a"")
/// 3
/// >>> how_many_times(string: ""aaaa"", substring: ""aa"")
/// 3
func how_many_times(string: String, substring: String) -> Int {
","func how_many_times(string: String, substring: String) -> Int {
    guard !substring.isEmpty else { return 0 }
    
    var count = 0
    var startIndex = string.startIndex
    
    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {
        count += 1
        startIndex = string.index(after: range.lowerBound)
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(how_many_times(string: """", substring: ""x"") == 0)
assert(how_many_times(string: ""xyxyxyx"", substring: ""x"") == 4)
assert(how_many_times(string: ""cacacacac"", substring: ""cac"") == 4)
assert(how_many_times(string: ""john doe"", substring: ""john"") == 1)"
HumanEval_19,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ၸႅၵ်ႇဝႆႉတီႈလဵၵ်ႉသုတ်း တေႃႇထိုင် ဢၼ်ယႂ်ႇသုတ်းၼၼ်ႉသေ ၶိုၼ်းဢဝ်မႃးၶိုၼ်း// လွင်ႈလိူၵ်ႈဢၼ်ထုၵ်ႇမႅၼ်ႈတႄႉပဵၼ် 'သုၼ်'၊ 'ၼိုင်ႈ'၊ 'သွင်'၊ 'သၢမ်'၊ 'သီႇ'၊ 'ႁႃႈ'၊ 'ႁူၵ်း'၊ 'ၸဵတ်း'၊ 'ဢဵတ်း' လႄႈ 'သိပ်း' ၸိူဝ်းၼႆႉယဝ်ႉ။// Input ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်မီးတီႈပွင်ႇတီႈၼွၵ်ႈ ဢၼ်ၸႅၵ်ႇဝႆႉတီႈၵၢင်မၼ်း တႄႇတီႈ 'သုၼ်' တေႃႇထိုင် 'ဢဵတ်း' ၼၼ်ႉယဝ်ႉ။/// >>> sort_numbers(numbers: ""three one five"")
/// ""one three five""
func sort_numbers(numbers: String) -> String {
","func sort_numbers(numbers: String) -> String {
    // Mapping of word numbers to digits
    let numberWords: [String: Int] = [
        ""zero"": 0,
        ""one"": 1,
        ""two"": 2,
        ""three"": 3,
        ""four"": 4,
        ""five"": 5,
        ""six"": 6,
        ""seven"": 7,
        ""eight"": 8,
        ""nine"": 9
    ]

    // Split the input string into words
    let words = numbers.split(separator: "" "")

    // Sort the words based on their corresponding number values
    let sortedWords = words.sorted { 
        numberWords[String($0)]! < numberWords[String($1)]! 
    }

    // Join the sorted words back into a single string
    return sortedWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_numbers(numbers: """") == """")
assert(sort_numbers(numbers: ""three"") == ""three"")
assert(sort_numbers(numbers: ""three five nine"") == ""three five nine"")
assert(sort_numbers(numbers: ""five zero four seven nine eight"") == ""zero four five seven eight nine"")
assert(sort_numbers(numbers: ""six five four three two one zero"") == ""zero one two three four five six"")"
HumanEval_20,shn_Mymr,swift,"
// တၢင်ႇဢၼ်သေ ၶိုၼ်းဢဝ်မႃးၸွမ်းၼင်ႇပိူင်မၼ်း (တူဝ်ၼပ်ႉလဵၵ်ႉ၊ တူဝ်ၼပ်ႉယႂ်ႇ)// တီႈၼႂ်းတူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉ (တၢင်းယၢဝ်းမၼ်းဢမ်ႇယွမ်း 2 တူဝ်) လိူၵ်ႈဢဝ်သေ ၶိုၼ်းဢဝ်မႃးၶိုၼ်း ဢၼ်ၸမ်သုတ်းတင်းတူဝ်ၼပ်ႉဢၼ်လႂ်ဢၼ်ၼိုင်ႈ /// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
func find_closest_elements(numbers: [Double]) -> (Double, Double) {
","func find_closest_elements(numbers: [Double]) -> (Double, Double) {
    // Sort the array to bring closest numbers next to each other
    let sortedNumbers = numbers.sorted()
    
    // Initialize variables to keep track of the smallest difference and the pair
    var minDifference = Double.greatestFiniteMagnitude
    var closestPair: (Double, Double) = (0.0, 0.0)
    
    // Iterate over the sorted numbers to find the smallest difference
    for i in 0..<sortedNumbers.count - 1 {
        let num1 = sortedNumbers[i]
        let num2 = sortedNumbers[i + 1]
        let difference = abs(num1 - num2)
        
        if difference < minDifference {
            minDifference = difference
            closestPair = (num1, num2)
        }
    }
    
    return closestPair
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))
assert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))
assert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))
assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
HumanEval_21,shn_Mymr,swift,"
// ၼင်ႇႁိုဝ် တူဝ်ၼပ်ႉဢၼ်လဵၵ်ႉသုတ်းၼၼ်ႉ တေပဵၼ် 0 လႄႈ တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇသုတ်းၼၼ်ႉ တေပဵၼ် 1// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉ (ဢၼ်မီးဝႆႉ တူဝ်ၼပ်ႉ တီႈဢေႇသုတ်းသွင်တူဝ်) ၼၼ်ႉသေ ဢဝ်လွင်ႈလႅၵ်ႈလၢႆႈ linear မႃးၸႂ်ႉတီႈ တူဝ်ၼပ်ႉၼၼ်ႉ၊/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])
/// [0.0, 0.25, 0.5, 0.75, 1.0]
func rescale_to_unit(numbers: [Double]) -> [Double] {
","func rescale_to_unit(numbers: [Double]) -> [Double] {
    guard numbers.count > 1 else { return numbers }
    
    let minValue = numbers.min()!
    let maxValue = numbers.max()!
    let range = maxValue - minValue
    
    guard range != 0 else {
        return numbers.map { _ in 0.0 }
    }
    
    return numbers.map { ($0 - minValue) / range }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])
assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])
assert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])
assert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])
assert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
HumanEval_22,shn_Mymr,swift,"
// ၸၢၵ်ႈၸၢၵ်ႈၸႅတ်ႈတူၺ်း ဢၼ်ပၼ်ဝႆႉ လွင်ႈၸႅၼ်ႇဝႆႉ ၶွင် swiftthon ဢၼ်လႂ်သေဢမ်ႇဝႃႈ တွၼ်ႈတႃႇ တူဝ်ၼပ်ႉတဵမ်ၵူၺ်း/// >>> filter_integers(values: [""a"", 3.14, 5])
/// [5]
/// >>> filter_integers(values: [1, 2, 3, ""abc"", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])
/// [1, 2, 3]
func filter_integers(values: [AnyHashable]) -> [Int] {
","func filter_integers(values: [AnyHashable]) -> [Int] {
    return values.compactMap { $0 as? Int }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])
assert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, ""adasd""]) == [4, 9])
assert(filter_integers(values: [3, ""c"", 3, 3, ""a"", ""b""]) == [3, 3, 3])"
HumanEval_23,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ်တၢင်းယၢဝ်း string ဢၼ်ပၼ်ဝႆႉၼၼ်ႉမႃး/// >>> strlen(string: """")
/// 0
/// >>> strlen(string: ""abc"")
/// 3
func strlen(string: String) -> Int {
","func strlen(string: String) -> Int {
    return string.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strlen(string: """") == 0)
assert(strlen(string: ""x"") == 1)
assert(strlen(string: ""asdasnakj"") == 9)"
HumanEval_24,shn_Mymr,swift,"
// တွၼ်ႈတႃႇ တူဝ်ၼပ်ႉ n ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ၊ႁႃ တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇသေပိူၼ်ႈ ဢၼ်ၸႅၵ်ႇ n ႁ်ႂႈပဵၼ်ဢၼ်ၽဵင်ႇပဵင်းၼၼ်ႉ၊ ဢၼ်လဵၵ်ႉလိူဝ် n ၼၼ်ႉ။/// >>> largest_divisor(n: 15)
/// 5
func largest_divisor(n: Int) -> Int {
","func largest_divisor(n: Int) -> Int {
    for i in stride(from: n / 2, to: 0, by: -1) {
        if n % i == 0 {
            return i
        }
    }
    return 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_divisor(n: 3) == 1)
assert(largest_divisor(n: 7) == 1)
assert(largest_divisor(n: 10) == 5)
assert(largest_divisor(n: 100) == 50)
assert(largest_divisor(n: 49) == 7)"
HumanEval_25,shn_Mymr,swift,"
// တူဝ်ၼပ်ႉဢၼ်ၶဝ်ႈၼႆႉ တေလႆႈၽဵင်ႇပဵင်းၵၼ်တၢင်း တူဝ်ၵုၼ်းၶွင် တူဝ်ၼပ်ႉတင်းမူတ်း // တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈဢၼ်ၼႆႉ ထုၵ်ႇလီၸႅၵ်ႇဝႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ ဢၼ်ၵွင်ႉၵၢႆႇၵၼ်တၢင်း တူဝ်ၼပ်ႉဢၼ်ပဵၼ်မႃး ၼႂ်းလွင်ႈၸႅၵ်ႇတူဝ်ၼပ်ႉၼၼ်ႉယဝ်ႉ။// ၶိုၼ်းဢဝ် array ၶွင် prime factors ၶွင် integer ဢၼ်ပၼ်ဝႆႉၼၼ်ႉမႃးၸွမ်းၼင်ႇဢၼ်လဵၵ်ႉသေပိူၼ်ႈ တေႃႇထိုင် ဢၼ်ယႂ်ႇသေပိူၼ်ႈၼၼ်ႉယဝ်ႉ။/// >>> factorize(n: 8)
/// [2, 2, 2]
/// >>> factorize(n: 25)
/// [5, 5]
/// >>> factorize(n: 70)
/// [2, 5, 7]
func factorize(n: Int) -> [Int] {
","func factorize(n: Int) -> [Int] {
    guard n > 1 else { return [] }
    var number = n
    var factors: [Int] = []
    var divisor = 2
    
    while number >= divisor {
        while number % divisor == 0 {
            factors.append(divisor)
            number /= divisor
        }
        divisor += 1
    }
    
    return factors
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(factorize(n: 2) == [2])
assert(factorize(n: 4) == [2, 2])
assert(factorize(n: 8) == [2, 2, 2])
assert(factorize(n: 57) == [3, 19])
assert(factorize(n: 3249) == [3, 3, 19, 19])
assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])
assert(factorize(n: 20577) == [3, 19, 19, 19])
assert(factorize(n: 18) == [2, 3, 3])"
HumanEval_26,shn_Mymr,swift,"
// ႁႂ်ႈဝႆႉပိူင်ထၢၼ်ႈၶွင် ၶူဝ်းၶွင်ၸိူဝ်းဢၼ်ၵိုတ်းဝႆႉၼၼ်ႉ မိူၼ်ၵၼ်တင်း ဢၼ်ၶဝ်ႈဝႆႉၼၼ်ႉ။// လုၵ်ႉတီႈ တူဝ်ၼပ်ႉတဵမ်ဢၼ်ပဵၼ် array ၼၼ်ႉသေ ထွၼ်ဢွၵ်ႇ တူဝ်ၼပ်ႉဢၼ်မီးမႃး ၼမ်လိူဝ်သေပွၵ်ႈၼိူင်ႈၼၼ်ႉယဝ်ႉ။/// >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])
/// [1, 3, 4]
func remove_duplicates(numbers: [Int]) -> [Int] {
","func remove_duplicates(numbers: [Int]) -> [Int] {
    var elementCount = [Int: Int]()
    for number in numbers {
        elementCount[number, default: 0] += 1
    }
    return numbers.filter { elementCount[$0] == 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])
assert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])
assert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
HumanEval_27,shn_Mymr,swift,"
// တွၼ်ႈတႃႇ သဵၼ်ႈမၢႆဢၼ်ပၼ်ဝႆႉၼၼ်ႉ၊ ဢဝ်တူဝ်လိၵ်ႈတူဝ်လဵၵ်ႉသေ လႅၵ်ႈပဵၼ် တူဝ်ယႂ်ႇသေ လႅၵ်ႈပဵၼ်တူဝ်လဵၵ်ႉ။/// >>> flip_case(string: ""Hello"")
/// ""hELLO""
func flip_case(string: String) -> String {
","func flip_case(string: String) -> String {
    return String(string.map { character in
        if character.isLowercase {
            return character.uppercased()
        } else if character.isUppercase {
            return character.lowercased()
        } else {
            return String(character)
        }
    }.joined())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(flip_case(string: """") == """")
assert(flip_case(string: ""Hello!"") == ""hELLO!"")
assert(flip_case(string: ""These violent delights have violent ends"") == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")"
HumanEval_28,shn_Mymr,swift,"
// သႂ်ႇ string ၵူႊဢၼ်ပဵၼ် string ဢၼ်လဵဝ်ၵၼ်/// >>> concatenate(strings: [] as [String])
/// """"
/// >>> concatenate(strings: [""a"", ""b"", ""c""])
/// ""abc""
func concatenate(strings: [String]) -> String {
","func concatenate(strings: [String]) -> String {
    return strings.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(concatenate(strings: [] as [String]) == """")
assert(concatenate(strings: [""x"", ""y"", ""z""]) == ""xyz"")
assert(concatenate(strings: [""x"", ""y"", ""z"", ""w"", ""k""]) == ""xyzwk"")"
HumanEval_29,shn_Mymr,swift,"
// ၸၢၵ်ႈၸႅၵ်ႉထ် ဢၼ်တေၶဝ်ႈၸူးၼႂ်း သဵၼ်ႈသၢႆမၢႆၼၼ်ႉ တေၸႅၵ်ႉထ် ဢၼ်တေတႄႇလူၺ်ႈ တူဝ်ၸီႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉၵူၺ်း။/// >>> filter_by_prefix(strings: [] as [String], prefix: ""a"")
/// [] as [String]
/// >>> filter_by_prefix(strings: [""abc"", ""bcd"", ""cde"", ""array""], prefix: ""a"")
/// [""abc"", ""array""]
func filter_by_prefix(strings: [String], prefix: String) -> [String] {
","func filter_by_prefix(strings: [String], prefix: String) -> [String] {
    return strings.filter { $0.hasPrefix(prefix) }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(filter_by_prefix(strings: [] as [String], prefix: ""john"") == [] as [String])
assert(filter_by_prefix(strings: [""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], prefix: ""xxx"") == [""xxx"", ""xxxAAA"", ""xxx""])"
HumanEval_30,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်မီးလွင်ႈသၢင်ႇထုၵ်ႇၼႂ်း array ၼၼ်ႉၵူၺ်း။ /// >>> get_positive(l: [-1, 2, -4, 5, 6])
/// [2, 5, 6]
/// >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// [5, 3, 2, 3, 9, 123, 1]
func get_positive(l: [Int]) -> [Int] {
","func get_positive(l: [Int]) -> [Int] {
    return l.filter { $0 > 0 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])
assert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])
assert(get_positive(l: [-1, -2]) == [] as [Int])
assert(get_positive(l: [] as [Int]) == [] as [Int])"
HumanEval_31,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် true မႃးၶိုၼ်း သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပဵၼ် တူဝ်ၼပ်ႉၶမ်ႇပိုၼ်ႉ လႄႈ false ပေႃးဢမ်ႇၼၼ်။ /// >>> is_prime(n: 6)
/// false
/// >>> is_prime(n: 101)
/// true
/// >>> is_prime(n: 11)
/// true
/// >>> is_prime(n: 13441)
/// true
/// >>> is_prime(n: 61)
/// true
/// >>> is_prime(n: 4)
/// false
/// >>> is_prime(n: 1)
/// false
func is_prime(n: Int) -> Bool {
","func is_prime(n: Int) -> Bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    var i = 5
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_prime(n: 6) == false)
assert(is_prime(n: 101) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 13441) == true)
assert(is_prime(n: 61) == true)
assert(is_prime(n: 4) == false)
assert(is_prime(n: 1) == false)
assert(is_prime(n: 5) == true)
assert(is_prime(n: 11) == true)
assert(is_prime(n: 17) == true)
assert(is_prime(n: 85) == false)
assert(is_prime(n: 77) == false)
assert(is_prime(n: 255379) == false)"
HumanEval_33,shn_Mymr,swift,"
// ၵႃႈၶၼ်ၶွင် index ဢၼ်ၵွင်ႉၵၢႆႇၵၼ်တင်း l ၼၼ်ႉယဝ်ႉ၊ ၵူၺ်းၵႃႈ ၸႅၵ်ႇဝႆႉ။// l' ၼႆႉမိူၼ်ၵၼ်တၢင်း l တီႈၼႂ်းတူဝ်ၼပ်ႉဢၼ်ဢမ်ႇၸႅၵ်ႇလႆႈ သၢမ်ဢၼ်ၼၼ်ႉသေ ၵႃႈၶၼ်မၼ်းတီႈတူဝ်ၼပ်ႉဢၼ်ၸႅၵ်ႇလႆႈ သၢမ်ဢၼ်ၼၼ်ႉၵေႃႈ မိူၼ်ၵၼ်ယူႇယဝ်ႉ။// တူဝ်ဢိင်ဢၼ်ၼႆႉ ဢဝ်ဝႆႉ array l လႄႈ ၶိုၼ်းပၼ် array l' မိူၼ်ၼင်ႇၼင်ႇၼႆ /// >>> sort_third(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])
/// [2, 6, 3, 4, 8, 9, 5]
func sort_third(l: [Int]) -> [Int] {
","func sort_third(l: [Int]) -> [Int] {
    // Collect indices and their values where index is divisible by 3
    var divisibleByThreeValues: [(index: Int, value: Int)] = []
    for (index, value) in l.enumerated() where index % 3 == 0 {
        divisibleByThreeValues.append((index, value))
    }
    
    // Sort the values that were at the indices divisible by 3
    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()
    
    // Create a mutable copy of original array to modify
    var result = l
    
    // Replace the sorted values back into their original indices
    for (i, sortedValue) in sortedValues.enumerated() {
        result[divisibleByThreeValues[i].index] = sortedValue
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])
assert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])
assert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])
assert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"
HumanEval_34,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ဢၼ်ၸႅၵ်ႇဝႆႉတီႈၼႂ်း မေႃႇထၢၼ်ႇၼၼ်ႉ ၶိုၼ်းဢဝ်မႃးၶိုၼ်း/// >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [0, 2, 3, 5, 9, 123]
func unique(l: [Int]) -> [Int] {
","func unique(l: [Int]) -> [Int] {
    return Array(Set(l)).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"
HumanEval_35,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇသုတ်း ၼႂ်း array ၼၼ်ႉမႃး။ /// >>> max_element(l: [1, 2, 3])
/// 3
/// >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
func max_element(l: [Int]) -> Int {
","func max_element(l: [Int]) -> Int {
    guard let max = l.max() else {
        fatalError(""Array should not be empty"")
    }
    return max
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_element(l: [1, 2, 3]) == 3)
assert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"
HumanEval_36,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉ 7 မႃးၶိုၼ်း ၼႂ်းတူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢေႇလိူဝ် n ဢၼ်ၸႅၵ်ႇလႆႈ 11 ဢမ်ႇၼၼ် 13 ၼၼ်ႉ/// >>> fizz_buzz(n: 50)
/// 0
/// >>> fizz_buzz(n: 78)
/// 2
/// >>> fizz_buzz(n: 79)
/// 3
func fizz_buzz(n: Int) -> Int {
","func fizz_buzz(n: Int) -> Int {
    var count = 0
    for number in 0..<n {
        if number % 11 == 0 || number % 13 == 0 {
            var current = number
            while current > 0 {
                if current % 10 == 7 {
                    count += 1
                }
                current /= 10
            }
        }
    }
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fizz_buzz(n: 50) == 0)
assert(fizz_buzz(n: 78) == 2)
assert(fizz_buzz(n: 79) == 3)
assert(fizz_buzz(n: 100) == 3)
assert(fizz_buzz(n: 200) == 6)
assert(fizz_buzz(n: 4000) == 192)
assert(fizz_buzz(n: 10000) == 639)
assert(fizz_buzz(n: 100000) == 8026)"
HumanEval_37,shn_Mymr,swift,"
// ၵႃႈၶၼ်ၶွင် တူဝ်ၼပ်ႉဢၼ်ပဵၼ်ၸဵင်ႇပဵင်းၶွင် l ၼၼ်ႉယဝ်ႉ၊ ၵူၺ်းၵႃႈ ၸႅၵ်ႇဝႆႉယဝ်ႉ။// l' ၼႆႉမိူၼ်ၵၼ်တၢင်း l တီႈၼႂ်းတူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉယဝ်ႉ၊ ၵူၺ်းၵႃႈ ၵႃႈၶၼ်မၼ်းတီႈတူဝ်ၼပ်ႉဢၼ်မိူၼ်ၵၼ်ၼၼ်ႉၵေႃႈ မိူၼ်ၵၼ်ယူႇယဝ်ႉ။// တူဝ်ဢိင်ဢၼ်ၼႆႉ ဢဝ်ဝႆႉ array l လႄႈ ၶိုၼ်းပၼ် array l' မိူၼ်ၼင်ႇၼင်ႇၼႆ /// >>> sort_even(l: [1, 2, 3])
/// [1, 2, 3]
/// >>> sort_even(l: [5, 6, 3, 4])
/// [3, 6, 5, 4]
func sort_even(l: [Int]) -> [Int] {
","func sort_even(l: [Int]) -> [Int] {
    var evenIndicesValues = [Int]()
    
    // Collect values from even indices
    for (index, value) in l.enumerated() {
        if index % 2 == 0 {
            evenIndicesValues.append(value)
        }
    }
    
    // Sort the collected even indices values
    evenIndicesValues.sort()
    
    var result = l
    var evenIndex = 0
    
    // Replace even-indexed elements in result with sorted values
    for i in 0..<result.count {
        if i % 2 == 0 {
            result[i] = evenIndicesValues[evenIndex]
            evenIndex += 1
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_even(l: [1, 2, 3]) == [1, 2, 3])
assert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
assert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"
HumanEval_39,shn_Mymr,swift,"
prime_fib ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉ n-th ဢၼ်ပဵၼ် တူဝ်ၼပ်ႉ Fibonacci လႄႈ မၼ်းပဵၼ် prime ၵေႃႈလႆႈ/// >>> prime_fib(n: 1)
/// 2
/// >>> prime_fib(n: 2)
/// 3
/// >>> prime_fib(n: 3)
/// 5
/// >>> prime_fib(n: 4)
/// 13
/// >>> prime_fib(n: 5)
/// 89
func prime_fib(n: Int) -> Int {
","func isPrime(_ num: Int) -> Bool {
    if num <= 1 { return false }
    if num <= 3 { return true }
    if num % 2 == 0 || num % 3 == 0 { return false }
    var i = 5
    while i * i <= num {
        if num % i == 0 || num % (i + 2) == 0 {
            return false
        }
        i += 6
    }
    return true
}

func generateFibonacci(n: Int) -> [Int] {
    var fibs = [1, 2]
    var next = fibs[0] + fibs[1]
    while fibs.count < n || !isPrime(next) {
        fibs.append(next)
        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]
    }
    return fibs
}

func prime_fib(n: Int) -> Int {
    var count = 0
    var fibs = generateFibonacci(n: n)
    for fib in fibs {
        if isPrime(fib) {
            count += 1
            if count == n {
                return fib
            }
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_fib(n: 1) == 2)
assert(prime_fib(n: 2) == 3)
assert(prime_fib(n: 3) == 5)
assert(prime_fib(n: 4) == 13)
assert(prime_fib(n: 5) == 89)
assert(prime_fib(n: 6) == 233)
assert(prime_fib(n: 7) == 1597)
assert(prime_fib(n: 8) == 28657)
assert(prime_fib(n: 9) == 514229)
assert(prime_fib(n: 10) == 433494437)"
HumanEval_40,shn_Mymr,swift,"
// ၵဵပ်းႁွမ်တွမ်ပဵၼ်သုၼ်၊ လႄႈ ၽိတ်း ပေႃးဢမ်ႇၼၼ်။ // မၼ်းၶိုၼ်းမႃး true သင်ၸိူဝ်ႉဝႃႈ မီးတူဝ်ၼပ်ႉဢၼ်ပႅၵ်ႇပိူင်ႈၵၼ် 3 ဢၼ် ၼႂ်း array ဢၼ် // triple_sum_to_zero ဢဝ်တူဝ်ၼပ်ႉတဵမ်တင်းၼမ်ပဵၼ်ၶေႃႈၶဝ်ႈ/// >>> triples_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(l: [1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(l: [1])
/// false
func triples_sum_to_zero(l: [Int]) -> Bool {
","func triples_sum_to_zero(l: [Int]) -> Bool {
    let count = l.count
    if count < 3 {
        return false
    }
    
    let sortedArray = l.sorted()
    
    for i in 0..<count - 2 {
        var left = i + 1
        var right = count - 1
        
        while left < right {
            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]
            if currentSum == 0 {
                return true
            } else if currentSum < 0 {
                left += 1
            } else {
                right -= 1
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)
assert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)
assert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)
assert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)
assert(triples_sum_to_zero(l: [1]) == false)
assert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)
assert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"
HumanEval_41,shn_Mymr,swift,"
// Function ၼႆႉ ဢွၵ်ႇမႃး တူဝ်ၼပ်ႉ လွင်ႈတုမ်ႉတိူဝ်ႉၸိူင်ႉၼၼ်။ // ၼႂ်းသဵၼ်ႈတၢင်းၶဝ် မိူၼ်ၼင်ႇဝႃႈ ၶဝ်ဢမ်ႇလႆႈတုမ်ႉတိူဝ်ႉၵၼ်။ ၵူၺ်းၵႃႈ လူတ်ႉၵႃးၼႆႉ မီးႁႅင်းလႄႈ ႁႅင်းယႂ်ႇတႄႉတႄႉ၊ ယွၼ်ႉၼၼ်လႄႈ ၶဝ်တိုၵ်ႉၶၢႆႉယူႇတိၵ်းတိၵ်းယဝ်ႉ။// မိူဝ်ႈၵႃးဢၼ်ၶၢႆႉၵႂႃႇၽၢႆႇသၢႆႉၸူး ၽၢႆႇၶႂႃၼၼ်ႉ ႁေႃႈၽႃႇၺႃးၵႃးဢၼ်ၶၢႆႉၵႂႃႇၽၢႆႇသၢႆႉၸူး ၽၢႆႇၶႂႃၼၼ်ႉၵႃးၵူႈလမ်း ၶီႇတၢင်းဝႆးလဵဝ်ၵၼ် ၵႃးသွင်လမ်းၼႆႉ လၢတ်ႈဝႃႈ ၶီႇၵၼ်ၼႆယဝ်ႉ။ၵႃးသွင်လမ်းၼႆႉ တႄႇၵႂႃႇတၢင်းၵႆၵႆၵႃး n လမ်းၼႆႉ ၶီႇၵႂႃႇၽၢႆႇသၢႆႉၸူး ၽၢႆႇၶႂႃ၊ မိူဝ်ႈလဵဝ်ၵၼ် ၵႃး n လမ်းၵေႃႈ ၶီႇၵႂႃႇၸွမ်းၵၼ်။// ထၢင်ႇဝႃႈ သဵၼ်ႈတၢင်းဢၼ်တဵမ်ထူၼ်ႈၼၼ်ႉ ပဵၼ်သၢႆဢၼ်သိုဝ်ႈဢၼ်ဢမ်ႇမီးတီႈသုတ်း။ func car_race_collision(n: Int) -> Int {
","func car_race_collision(n: Int) -> Int {
    return n
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(car_race_collision(n: 2) == 4)
assert(car_race_collision(n: 3) == 9)
assert(car_race_collision(n: 4) == 16)
assert(car_race_collision(n: 8) == 64)
assert(car_race_collision(n: 10) == 100)"
HumanEval_42,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်တိူဝ်းလိူဝ်မႃး 1 ၼၼ်ႉ ၶိုၼ်းဢဝ်မႃးပဵၼ် တူဝ်ၼပ်ႉဢၼ်တိူဝ်းလိူဝ်မႃးထႅင်ႈ 1 ၼၼ်ႉ။/// >>> incr_list(l: [1, 2, 3])
/// [2, 3, 4]
/// >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])
/// [6, 4, 6, 3, 4, 4, 10, 1, 124]
func incr_list(l: [Int]) -> [Int] {
","func incr_list(l: [Int]) -> [Int] {
    return l.map { $0 + 1 }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(incr_list(l: [] as [Int]) == [] as [Int])
assert(incr_list(l: [3, 2, 1]) == [4, 3, 2])
assert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"
HumanEval_43,shn_Mymr,swift,"
// ၵဵပ်းႁွမ်တွမ်ပဵၼ်သုၼ်၊ လႄႈ ၽိတ်း ပေႃးဢမ်ႇၼၼ်။ // မၼ်းၶိုၼ်းမႃး true သင်ၸိူဝ်ႉဝႃႈ မီးတူဝ်ၼပ်ႉဢၼ်ပႅၵ်ႇပိူင်ႈၵၼ်သွင်ဢၼ် ၼႂ်း array ဢၼ် // pairs_sum_to_zero ဢဝ်တူဝ်ၼပ်ႉတဵမ်တင်းၼမ်ပဵၼ်ၶေႃႈၶဝ်ႈ/// >>> pairs_sum_to_zero(l: [1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(l: [1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(l: [1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(l: [1])
/// false
func pairs_sum_to_zero(l: [Int]) -> Bool {
","func pairs_sum_to_zero(l: [Int]) -> Bool {
    var set = Set<Int>()
    for num in l {
        if set.contains(-num) {
            return true
        }
        set.insert(num)
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)
assert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)
assert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)
assert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)
assert(pairs_sum_to_zero(l: [1]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)
assert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"
HumanEval_44,shn_Mymr,swift,"
// တူဝ်ၼပ်ႉငဝ်ႈမၼ်းၼႆႉ ဢေႇလိူဝ်သေ 10 ယဝ်ႉ။ // ၶိုၼ်းဢဝ် string ဢၼ်တၢင်တူဝ်မၼ်း ဝၢႆးသေလႅၵ်ႈလၢႆႈဝႆႉၼၼ်ႉမႃး။// လႅၵ်ႈလၢႆႈ တူဝ်ၼပ်ႉငဝ်ႈတႄႇ တူဝ်ၼပ်ႉ x ဢၼ်ၶဝ်ႈၸူး တီႈငဝ်ႈတႄႇ။ /// >>> change_base(x: 8, base: 3)
/// ""22""
/// >>> change_base(x: 8, base: 2)
/// ""1000""
/// >>> change_base(x: 7, base: 2)
/// ""111""
func change_base(x: Int, base: Int) -> String {
","func change_base(x: Int, base: Int) -> String {
    guard base > 1 && base < 10 else {
        return """"
    }
    
    var number = x
    var result = """"
    
    repeat {
        let remainder = number % base
        result = ""\(remainder)"" + result
        number /= base
    } while number > 0
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(change_base(x: 8, base: 3) == ""22"")
assert(change_base(x: 9, base: 3) == ""100"")
assert(change_base(x: 234, base: 2) == ""11101010"")
assert(change_base(x: 16, base: 2) == ""10000"")
assert(change_base(x: 8, base: 2) == ""1000"")
assert(change_base(x: 7, base: 2) == ""111"")
assert(change_base(x: 2, base: 3) == ""2"")
assert(change_base(x: 3, base: 4) == ""3"")
assert(change_base(x: 4, base: 5) == ""4"")
assert(change_base(x: 5, base: 6) == ""5"")
assert(change_base(x: 6, base: 7) == ""6"")
assert(change_base(x: 7, base: 8) == ""7"")"
HumanEval_45,shn_Mymr,swift,"
// ပၼ်တၢင်းယၢဝ်းၽၢႆႇလႄႈ ၼႃႈလိၼ်ဢၼ်လႆႈၶိုၼ်းသုင်သုတ်း တွၼ်ႈတႃႇသၢမ်ၸဵင်ႇဢၼ်ၼိူင်ႈ။ /// >>> triangle_area(a: 5, h: 3)
/// 7.5
func triangle_area(a: Int, h: Int) -> Double {
","func triangle_area(a: Int, h: Int) -> Double {
    return 0.5 * Double(a) * Double(h)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 5, h: 3) == 7.5)
assert(triangle_area(a: 2, h: 2) == 2.0)
assert(triangle_area(a: 10, h: 8) == 40.0)"
HumanEval_46,shn_Mymr,swift,"
// ၶႅၼ်းတေႃႈ တႅမ်ႈပၼ် တူဝ်ဢိင် တႃႇတေၼပ်ႉသွၼ်ႇ တူဝ်ၼပ်ႉ n-th ၶွင် တူဝ်ၼပ်ႉ fib4 ၼၼ်ႉၵမ်းလဵဝ်။ ယႃႇပေၸႂ်ႉတိုဝ်း လွင်ႈၶိုၼ်းတႄႇ။ // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)// fib4(3) -> 0 // fib4(2) -> 2 // fib4(1) -> 0 // fib4(0) -> 0 // တူဝ်ၼပ်ႉ Fib4 ၼႆႉ မၼ်းမိူၼ်ၵၼ်တင်း တူဝ်ၼပ်ႉ Fibbonacci ဢၼ်မၵ်းမၼ်ႈဝႆႉ ၼင်ႇပႃႈတႂ်ႈၼႆႉ/// >>> fib4(n: 5)
/// 4
/// >>> fib4(n: 6)
/// 8
/// >>> fib4(n: 7)
/// 14
func fib4(n: Int) -> Int {
","func fib4(n: Int) -> Int {
    if n == 0 || n == 1 || n == 3 {
        return 0
    } else if n == 2 {
        return 2
    }
    
    var fibs = [0, 0, 2, 0]
    
    for i in 4...n {
        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]
        fibs.append(nextFib)
    }
    
    return fibs[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib4(n: 5) == 4)
assert(fib4(n: 8) == 28)
assert(fib4(n: 10) == 104)
assert(fib4(n: 12) == 386)"
HumanEval_47,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်မီးတီႈၼႂ်း မေႃႇရီႇ l ၼၼ်ႉ ၶိုၼ်းမႃးတႅၵ်ႈၶိုၼ်း။ /// >>> median(l: [3, 1, 2, 4, 5])
/// 3
/// >>> median(l: [-10, 4, 6, 1000, 10, 20])
/// 15.0
func median(l: [Int]) -> Double {
","func median(l: [Int]) -> Double {
    let sorted = l.sorted()
    let count = sorted.count
    if count % 2 == 0 {
        return Double(sorted[count / 2 - 1] + sorted[count / 2]) / 2.0
    } else {
        return Double(sorted[count / 2])
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(median(l: [3, 1, 2, 4, 5]) == 3)
assert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)
assert(median(l: [5]) == 5)
assert(median(l: [6, 5]) == 5.5)
assert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"
HumanEval_48,shn_Mymr,swift,"
// ၸႅတ်ႈတူၺ်းဝႃႈ သတၢႆႇဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပဵၼ် palindrome ႁိုဝ်ၼႆ/// >>> is_palindrome(text: """")
/// true
/// >>> is_palindrome(text: ""aba"")
/// true
/// >>> is_palindrome(text: ""aaaaa"")
/// true
/// >>> is_palindrome(text: ""zbcd"")
/// false
func is_palindrome(text: String) -> Bool {
","func is_palindrome(text: String) -> Bool {
    return text == String(text.reversed())
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_palindrome(text: """") == true)
assert(is_palindrome(text: ""aba"") == true)
assert(is_palindrome(text: ""aaaaa"") == true)
assert(is_palindrome(text: ""zbcd"") == false)
assert(is_palindrome(text: ""xywyx"") == true)
assert(is_palindrome(text: ""xywyz"") == false)
assert(is_palindrome(text: ""xywzx"") == false)"
HumanEval_49,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် 2^n modulo p (ဝႆႉၸႂ်ၼိူဝ် တူဝ်ၼပ်ႉ)/// >>> modp(n: 3, p: 5)
/// 3
/// >>> modp(n: 1101, p: 101)
/// 2
/// >>> modp(n: 0, p: 101)
/// 1
/// >>> modp(n: 3, p: 11)
/// 8
/// >>> modp(n: 100, p: 101)
/// 1
func modp(n: Int, p: Int) -> Int {
","func modp(n: Int, p: Int) -> Int {
    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(modp(n: 3, p: 5) == 3)
assert(modp(n: 1101, p: 101) == 2)
assert(modp(n: 0, p: 101) == 1)
assert(modp(n: 3, p: 11) == 8)
assert(modp(n: 100, p: 101) == 1)
assert(modp(n: 30, p: 5) == 4)
assert(modp(n: 31, p: 5) == 3)"
HumanEval_51,shn_Mymr,swift,"
// remove_vowels ၼႆႉပဵၼ် တူဝ်ဢိင် ဢၼ်ဢဝ် string သေ ၶိုၼ်းဢဝ် string ဢၼ်ဢမ်ႇမီး တူဝ်မႄႈလိၵ်ႈမႃးၼၼ်ႉယဝ်ႉ။/// >>> remove_vowels(text: """")
/// """"
/// >>> remove_vowels(text: ""abcdef"")
/// ""bcdf""
/// >>> remove_vowels(text: ""aaaaa"")
/// """"
/// >>> remove_vowels(text: ""aaBAA"")
/// ""B""
/// >>> remove_vowels(text: ""zbcd"")
/// ""zbcd""
func remove_vowels(text: String) -> String {
","func remove_vowels(text: String) -> String {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    return String(text.filter { !vowels.contains($0) })
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(remove_vowels(text: """") == """")
assert(remove_vowels(text: ""abcdef\nghijklm"") == ""bcdf\nghjklm"")
assert(remove_vowels(text: ""fedcba"") == ""fdcb"")
assert(remove_vowels(text: ""eeeee"") == """")
assert(remove_vowels(text: ""acBAA"") == ""cB"")
assert(remove_vowels(text: ""EcBOO"") == ""cB"")
assert(remove_vowels(text: ""ybcd"") == ""ybcd"")"
HumanEval_52,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် true မႃးၶိုၼ်း သင်ဝႃႈ တူဝ်ၼပ်ႉတင်းမူတ်း ၼႂ်း array l ၼႆႉ မီးတႂ်ႈ threshold t ၼၼ်ႉၼႆ။ /// >>> below_threshold(l: [1, 2, 4, 10], t: 100)
/// true
/// >>> below_threshold(l: [1, 20, 4, 10], t: 5)
/// false
func below_threshold(l: [Int], t: Int) -> Bool {
","func below_threshold(l: [Int], t: Int) -> Bool {
    for number in l {
        if number >= t {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)
assert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)
assert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)
assert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"
HumanEval_53,shn_Mymr,swift,"
// ထႅမ်တူဝ်ၼပ်ႉသွင်တူဝ် x လႄႈ y/// >>> add(x: 2, y: 3)
/// 5
/// >>> add(x: 5, y: 7)
/// 12
func add(x: Int, y: Int) -> Int {
","func add(x: Int, y: Int) -> Int {
    return x + y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(x: 0, y: 1) == 1)
assert(add(x: 1, y: 0) == 1)
assert(add(x: 2, y: 3) == 5)
assert(add(x: 5, y: 7) == 12)
assert(add(x: 7, y: 5) == 12)"
HumanEval_54,shn_Mymr,swift,"
// တူၺ်းဝႃႈ ၶေႃႈၵႂၢမ်းသွင်ၶေႃႈၼႆႉ မီးတူဝ်လိၵ်ႈမိူၼ်ၵၼ်ႁိုဝ်ၼႆ။ /// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"")
/// true
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabc"")
/// true
/// >>> same_chars(s0: ""dddddddabc"", s1: ""abcd"")
/// true
/// >>> same_chars(s0: ""eabcd"", s1: ""dddddddabc"")
/// false
/// >>> same_chars(s0: ""abcd"", s1: ""dddddddabce"")
/// false
/// >>> same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"")
/// false
func same_chars(s0: String, s1: String) -> Bool {
","func same_chars(s0: String, s1: String) -> Bool {
    let set0 = Set(s0)
    let set1 = Set(s1)
    return set0 == set1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddeddabc"") == true)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabc"") == true)
assert(same_chars(s0: ""dddddddabc"", s1: ""abcd"") == true)
assert(same_chars(s0: ""eabcd"", s1: ""dddddddabc"") == false)
assert(same_chars(s0: ""abcd"", s1: ""dddddddabcf"") == false)
assert(same_chars(s0: ""eabcdzzzz"", s1: ""dddzzzzzzzddddabc"") == false)
assert(same_chars(s0: ""aabb"", s1: ""aaccc"") == false)"
HumanEval_55,shn_Mymr,swift,"
// ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉ Fibonacci ဢၼ်ၼိူင်ႈ။ /// >>> fib(n: 10)
/// 55
/// >>> fib(n: 1)
/// 1
/// >>> fib(n: 8)
/// 21
func fib(n: Int) -> Int {
","func fib(n: Int) -> Int {
    if n <= 0 {
        return 0
    } else if n == 1 {
        return 1
    }
    
    var a = 0
    var b = 1
    for _ in 2...n {
        let temp = a + b
        a = b
        b = temp
    }
    return b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fib(n: 10) == 55)
assert(fib(n: 1) == 1)
assert(fib(n: 8) == 21)
assert(fib(n: 11) == 89)
assert(fib(n: 12) == 144)"
HumanEval_56,shn_Mymr,swift,"
// ပွၵ်ႈမိူဝ်း true သင်ဝႃႈ သဵၼ်ႈမၢႆဢၼ်ပိုတ်ႇဝႆႉၼၼ်ႉ မီးဝႆႉ သဵၼ်ႈမၢႆဢၼ်ဢိုတ်းဝႆႉဢၼ်ၽဵင်ႇပဵင်းၵၼ်ၼၼ်ႉယဝ်ႉ။// brackets ၼႆႉပဵၼ် string ဢၼ်ပႃးဝႆႉ ""<"" လႄႈ "">"" ၼၼ်ႉၶႃႈ။/// >>> correct_bracketing(brackets: ""<"")
/// false
/// >>> correct_bracketing(brackets: ""<>"")
/// true
/// >>> correct_bracketing(brackets: ""<<><>>"")
/// true
/// >>> correct_bracketing(brackets: ""><<>"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    
    for bracket in brackets {
        if bracket == ""<"" {
            balance += 1
        } else if bracket == "">"" {
            balance -= 1
            if balance < 0 {
                return false
            }
        }
    }
    
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""<>"") == true)
assert(correct_bracketing(brackets: ""<<><>>"") == true)
assert(correct_bracketing(brackets: ""<><><<><>><>"") == true)
assert(correct_bracketing(brackets: ""<><><<<><><>><>><<><><<>>>"") == true)
assert(correct_bracketing(brackets: ""<<<><>>>>"") == false)
assert(correct_bracketing(brackets: ""><<>"") == false)
assert(correct_bracketing(brackets: ""<"") == false)
assert(correct_bracketing(brackets: ""<<<<"") == false)
assert(correct_bracketing(brackets: "">"") == false)
assert(correct_bracketing(brackets: ""<<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>><<>"") == false)
assert(correct_bracketing(brackets: ""<><><<><>><>>><>"") == false)"
HumanEval_57,shn_Mymr,swift,"
// Return true ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်တိူဝ်းလိူဝ် ဢမ်ႇၼၼ် လူတ်းယွမ်းမႃး လူၺ်ႈဢမ်ႇမီးလွင်ႈမၵ်းၶၢၼ်း။/// >>> monotonic(l: [1, 2, 4, 20])
/// true
/// >>> monotonic(l: [1, 20, 4, 10])
/// false
/// >>> monotonic(l: [4, 1, 0, -10])
/// true
func monotonic(l: [Int]) -> Bool {
","func monotonic(l: [Int]) -> Bool {
    guard l.count > 1 else {
        return true
    }
    
    var increasing = true
    var decreasing = true
    
    for i in 1..<l.count {
        if l[i] > l[i - 1] {
            decreasing = false
        } else if l[i] < l[i - 1] {
            increasing = false
        }
    }
    
    return increasing || decreasing
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(monotonic(l: [1, 2, 4, 10]) == true)
assert(monotonic(l: [1, 2, 4, 20]) == true)
assert(monotonic(l: [1, 20, 4, 10]) == false)
assert(monotonic(l: [4, 1, 0, -10]) == true)
assert(monotonic(l: [4, 1, 1, 0]) == true)
assert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)
assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)
assert(monotonic(l: [9, 9, 9, 9]) == true)"
HumanEval_58,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်မိူၼ်ၵၼ် ဢၼ်ၸႅၵ်ႇဝႆႉပၼ်ဝႆႉ တႃႇတူဝ်ၼပ်ႉဢၼ်မိူၼ်ၵၼ် တႃႇတူဝ်ၼပ်ႉဢၼ်ၸႅၵ်ႇဝႆႉ သွင်ဢၼ်ၼၼ်ႉ။/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])
/// [1, 5, 653]
/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])
/// [2, 3]
func common(l1: [Int], l2: [Int]) -> [Int] {
","func common(l1: [Int], l2: [Int]) -> [Int] {
    let set1 = Set(l1)
    let set2 = Set(l2)
    let commonElements = set1.intersection(set2)
    return Array(commonElements).sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])
assert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])
assert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])
assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
HumanEval_59,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇသုတ်း ဢၼ်ပဵၼ် တူဝ်ၼပ်ႉ prime ၶွင် n ၼၼ်ႉမႃး/// >>> largest_prime_factor(n: 13195)
/// 29
/// >>> largest_prime_factor(n: 2048)
/// 2
func largest_prime_factor(n: Int) -> Int {
","func largest_prime_factor(n: Int) -> Int {
    var number = n
    var divisor = 2
    
    while number > 1 {
        if number % divisor == 0 {
            number /= divisor
        } else {
            divisor += 1
        }
    }
    
    return divisor
}

// Example usage:
// print(largest_prime_factor(n: 13195)) // Output: 29
// print(largest_prime_factor(n: 2048))  // Output: 2","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_prime_factor(n: 15) == 5)
assert(largest_prime_factor(n: 27) == 3)
assert(largest_prime_factor(n: 63) == 7)
assert(largest_prime_factor(n: 330) == 11)
assert(largest_prime_factor(n: 13195) == 29)"
HumanEval_60,shn_Mymr,swift,"
// sum_to_n ၼႆႉပဵၼ် တူဝ်ဢိင် ဢၼ်ၵဵပ်းတူဝ်ၼပ်ႉ 1 တေႃႇထိုင် n ၼၼ်ႉၶႃႈ။ /// >>> sum_to_n(n: 30)
/// 465
/// >>> sum_to_n(n: 100)
/// 5050
/// >>> sum_to_n(n: 5)
/// 15
/// >>> sum_to_n(n: 10)
/// 55
/// >>> sum_to_n(n: 1)
/// 1
func sum_to_n(n: Int) -> Int {
","func sum_to_n(n: Int) -> Int {
    return (n * (n + 1)) / 2
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_to_n(n: 1) == 1)
assert(sum_to_n(n: 6) == 21)
assert(sum_to_n(n: 11) == 66)
assert(sum_to_n(n: 30) == 465)
assert(sum_to_n(n: 100) == 5050)"
HumanEval_61,shn_Mymr,swift,"
// ပွၵ်ႈမိူဝ်း true သင်ဝႃႈ သဵၼ်ႈမၢႆဢၼ်ပိုတ်ႇဝႆႉၼၼ်ႉ မီးဝႆႉ သဵၼ်ႈမၢႆဢၼ်ဢိုတ်းဝႆႉဢၼ်ၽဵင်ႇပဵင်းၵၼ်ၼၼ်ႉယဝ်ႉ။// brackets ၼႆႉပဵၼ် string ဢၼ်ပႃးတူဝ် ""("" လႄႈ """") ၼၼ်ႉယဝ်ႉ။/// >>> correct_bracketing(brackets: ""("")
/// false
/// >>> correct_bracketing(brackets: ""()"")
/// true
/// >>> correct_bracketing(brackets: ""(()())"")
/// true
/// >>> correct_bracketing(brackets: "")(()"")
/// false
func correct_bracketing(brackets: String) -> Bool {
","func correct_bracketing(brackets: String) -> Bool {
    var balance = 0
    for char in brackets {
        if char == ""("" {
            balance += 1
        } else if char == "")"" {
            balance -= 1
        }
        if balance < 0 {
            return false
        }
    }
    return balance == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(correct_bracketing(brackets: ""()"") == true)
assert(correct_bracketing(brackets: ""(()())"") == true)
assert(correct_bracketing(brackets: ""()()(()())()"") == true)
assert(correct_bracketing(brackets: ""()()((()()())())(()()(()))"") == true)
assert(correct_bracketing(brackets: ""((()())))"") == false)
assert(correct_bracketing(brackets: "")(()"") == false)
assert(correct_bracketing(brackets: ""("") == false)
assert(correct_bracketing(brackets: ""(((("") == false)
assert(correct_bracketing(brackets: "")"") == false)
assert(correct_bracketing(brackets: ""(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())())(()"") == false)
assert(correct_bracketing(brackets: ""()()(()())()))()"") == false)"
HumanEval_62,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် တူဝ်ဢၼ်မႃးတီႈ polynomial ဢၼ်ၼႆႉမႃးၶိုၼ်း ၼႂ်းပိူင်မိူၼ်ၵၼ်။ xs[0] + xs[1] * x + xs[2] * x^2 + .... // xs ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်းတင်း တူဝ်ၼပ်ႉဢၼ်မီးတူဝ်ၼပ်ႉၼမ်တဵမ်ၼၼ်ႉယဝ်ႉ။/// >>> derivative(xs: [3, 1, 2, 4, 5])
/// [1, 4, 12, 20]
/// >>> derivative(xs: [1, 2, 3])
/// [2, 6]
func derivative(xs: [Int]) -> [Int] {
","func derivative(xs: [Int]) -> [Int] {
    guard xs.count > 1 else { return [] }
    var result: [Int] = []
    for i in 1..<xs.count {
        result.append(xs[i] * i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])
assert(derivative(xs: [1, 2, 3]) == [2, 6])
assert(derivative(xs: [3, 2, 1]) == [2, 2])
assert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])
assert(derivative(xs: [1]) == [] as [Int])"
HumanEval_63,shn_Mymr,swift,"
// ၶႅၼ်းတေႃႈ တႅမ်ႈပၼ် တူဝ်ဢိင် တႃႇတေၼပ်ႉသွၼ်ႇ တူဝ်ၼပ်ႉ n-th ၶွင် တူဝ်ၼပ်ႉ fibfib ဢၼ်ၸွမ်းၵၼ်ဝႆႉၼၼ်ႉ။ // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) ။// fib fib (((2) == 1 // fib fib (((1) == 0 // fib fib (((0) == 0 // တူဝ်ၼပ်ႉ FibFib sequence ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်မိူၼ်ၵၼ်တၢင်း တူဝ်ၼပ်ႉ Fibbonacci sequence ဢၼ်မၵ်းမၼ်ႈဝႆႉမိူၼ်ၼင်ႇတႂ်ႈၼႆႉ: /// >>> fibfib(n: 1)
/// 0
/// >>> fibfib(n: 5)
/// 4
/// >>> fibfib(n: 8)
/// 24
func fibfib(n: Int) -> Int {
","func fibfib(n: Int) -> Int {
    if n == 0 || n == 1 {
        return 0
    }
    if n == 2 {
        return 1
    }
    
    var fibfibNums = [0, 0, 1]
    
    for i in 3...n {
        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]
        fibfibNums.append(nextFibFib)
    }
    
    return fibfibNums[n]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fibfib(n: 2) == 1)
assert(fibfib(n: 1) == 0)
assert(fibfib(n: 5) == 4)
assert(fibfib(n: 8) == 24)
assert(fibfib(n: 10) == 81)
assert(fibfib(n: 12) == 274)
assert(fibfib(n: 14) == 927)"
HumanEval_64,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // သဵင်သဵင်မေႃး၊ ၵူၺ်းၵႃႈ ပဵၼ်တီႈသုတ်းၶေႃႈၵႂၢမ်းဢၼ်ပၼ်ဝႆႉၼၼ်ႉၵူၺ်း။ // တူဝ်လိၵ်ႈတူဝ်မႄႈလိၵ်ႈ ၼႂ်းလွင်ႈၼႆႉပဵၼ် 'a', 'e', 'i', 'o', 'u'။ တီႈၼႆႈ 'y' ၵေႃႈပဵၼ် a // ၶေႃႈၵႂၢမ်းဢၼ်ၶဝ်ႈမႃး လႄႈ မိူဝ်းၶိုၼ်း တူဝ်မႄႈလိၵ်ႈတူဝ်ထႅဝ် ၼႂ်းသဵၼ်ႈမၢႆတူဝ်ထႅဝ်။// တႅမ်ႈပၼ် တူဝ်လိၵ်ႈတူဝ်မႄႈလိၵ်ႈတူဝ်ထႅဝ် ဢၼ်ဢဝ် တူဝ်လိၵ်ႈတူဝ်ၼပ်ႉဢၼ်တႅၼ်းတၢင် /// >>> vowels_count(s: ""abcde"")
/// 2
/// >>> vowels_count(s: ""ACEDY"")
/// 3
func vowels_count(s: String) -> Int {
","func vowels_count(s: String) -> Int {
    guard !s.isEmpty else { return 0 }
    
    let vowels = Set(""aeiouAEIOU"")
    var count = 0
    let characters = Array(s)
    
    for i in 0..<characters.count {
        let char = characters[i]
        
        if vowels.contains(char) {
            count += 1
        } else if char == ""y"" || char == ""Y"" {
            if i == characters.count - 1 {
                count += 1
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(vowels_count(s: ""abcde"") == 2)
assert(vowels_count(s: ""Alone"") == 3)
assert(vowels_count(s: ""key"") == 2)
assert(vowels_count(s: ""bye"") == 1)
assert(vowels_count(s: ""keY"") == 2)
assert(vowels_count(s: ""bYe"") == 1)
assert(vowels_count(s: ""ACEDY"") == 3)"
HumanEval_65,shn_Mymr,swift,"
// သင် shift > တူဝ်ၼပ်ႉတူဝ်ၼပ်ႉဢၼ်ၶိုၼ်းမႃးၼၼ်ႉ ၶိုၼ်းပိၼ်ႇဝၢႆႇၵႂႃႇ။// လႄႈ ၶိုၼ်းဢဝ် ၶေႃႈတွပ်ႇမၼ်းပဵၼ် သတၢႆႇ (string) ꧦ။// လဵပ်ႈႁဵၼ်းၶၢႆႉတူဝ်ၼပ်ႉတူဝ်ၼပ်ႉတဵမ် x၊ ၶၢႆႉတူဝ်ၼပ်ႉၽၢႆႇၶႂႃ လူၺ်ႈလွင်ႈၶၢႆႉ။/// >>> circular_shift(x: 12, shift: 1)
/// ""21""
/// >>> circular_shift(x: 12, shift: 2)
/// ""12""
func circular_shift(x: Int, shift: Int) -> String {
","func circular_shift(x: Int, shift: Int) -> String {
    let digits = Array(String(x))
    let count = digits.count
    
    // If shift is greater than the number of digits, return the digits reversed
    if shift >= count {
        return String(digits.reversed())
    }
    
    // Calculate the actual shift needed by using modulo operation
    let actualShift = shift % count
    
    // Perform the circular shift to the right
    let splitIndex = count - actualShift
    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]
    
    return String(shiftedDigits)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(circular_shift(x: 100, shift: 2) == ""001"")
assert(circular_shift(x: 12, shift: 2) == ""12"")
assert(circular_shift(x: 97, shift: 8) == ""79"")
assert(circular_shift(x: 12, shift: 1) == ""21"")
assert(circular_shift(x: 11, shift: 101) == ""11"")"
HumanEval_66,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// မၢႆလပ်ႉ ASCII // တႅမ်ႈပၼ် function ဢၼ်ဢဝ် string ပဵၼ် input သေ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉၽၢႆႇၼိူဝ်ၼၼ်ႉၵူၺ်း' ၼႃႈၵၢၼ်/// >>> digitSum(s: """")
/// 0
/// >>> digitSum(s: ""abAB"")
/// 131
/// >>> digitSum(s: ""abcCd"")
/// 67
/// >>> digitSum(s: ""helloE"")
/// 69
/// >>> digitSum(s: ""woArBld"")
/// 131
/// >>> digitSum(s: ""aAaaaXa"")
/// 153
func digitSum(s: String) -> Int {
","func digitSum(s: String) -> Int {
    var sum = 0
    for character in s {
        if character.isUppercase {
            sum += Int(character.asciiValue ?? 0)
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digitSum(s: """") == 0)
assert(digitSum(s: ""abAB"") == 131)
assert(digitSum(s: ""abcCd"") == 67)
assert(digitSum(s: ""helloE"") == 69)
assert(digitSum(s: ""woArBld"") == 131)
assert(digitSum(s: ""aAaaaXa"") == 153)
assert(digitSum(s: "" How are yOu?"") == 151)
assert(digitSum(s: ""You arE Very Smart"") == 327)"
HumanEval_67,shn_Mymr,swift,"
// တွၼ်ႈတႃႇ examble: // ၼႂ်းၵွၵ်းၼၼ်ႉ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉ မၢၵ်ႇဢူမ် ဢၼ်မီးၼႂ်းၵွၵ်းၼၼ်ႉ။// မၢၵ်ႇၶိူဝ်သူမ်ႈလႄႈ မၢၵ်ႇဢႅပ်ႇပႃႇ လႄႈ တူဝ်ၼပ်ႉတဵမ် ဢၼ်တၢင်တူဝ် တူဝ်ၼပ်ႉတင်းမူတ်းၶွင် မၢၵ်ႇဢႅပ်ႇပႃႇ apples, oranges, and mango fruits. ပၼ် string ဢၼ်တၢင်တူဝ် တူဝ်ၼပ်ႉတင်းမူတ်း // ၸိူဝ်းဢၼ်ၸႅၵ်ႇၽႄဝႆႉၼႂ်း ၵၢတ်ႇၼမ်ႉ ဢၼ်ၵၢတ်ႇၼမ်ႉဢၼ်ၼႆႉပႃးဝႆႉ ၼႂ်းၵၢၼ်ၼႆႉ ၸဝ်ႈၵဝ်ႇတေလႆႈပၼ် string ဢၼ်တၢင်တူဝ် တူဝ်ၼပ်ႉ apples လႄႈ oranges /// >>> fruit_distribution(s: ""5 apples and 6 oranges"", n: 19)
/// 8
/// >>> fruit_distribution(s: ""0 apples and 1 oranges"", n: 3)
/// 2
/// >>> fruit_distribution(s: ""2 apples and 3 oranges"", n: 100)
/// 95
/// >>> fruit_distribution(s: ""100 apples and 1 oranges"", n: 120)
/// 19
func fruit_distribution(s: String, n: Int) -> Int {
","func fruit_distribution(s: String, n: Int) -> Int {
    let components = s.components(separatedBy: "" "")
    var apples = 0
    var oranges = 0
    
    for (index, component) in components.enumerated() {
        if component == ""apples"" || component == ""apple"" {
            if let number = Int(components[index - 1]) {
                apples = number
            }
        } else if component == ""oranges"" || component == ""orange"" {
            if let number = Int(components[index - 1]) {
                oranges = number
            }
        }
    }
    
    let totalApplesOranges = apples + oranges
    let mangoes = n - totalApplesOranges
    return mangoes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 19) == 8)
assert(fruit_distribution(s: ""5 apples and 6 oranges"", n: 21) == 10)
assert(fruit_distribution(s: ""0 apples and 1 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""1 apples and 0 oranges"", n: 3) == 2)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 100) == 95)
assert(fruit_distribution(s: ""2 apples and 3 oranges"", n: 5) == 0)
assert(fruit_distribution(s: ""1 apples and 100 oranges"", n: 120) == 19)"
HumanEval_68,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ 1: // သင်ဝႃႈ ဢမ်ႇမီးၵႃႈၶၼ်ဢၼ်ပဵၼ်တူဝ်ၼပ်ႉၸႅၵ်ႈ ဢမ်ႇၼၼ် တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပဵၼ်ဢၼ်ဢမ်ႇမီးတီႈယူႇၼႆ ၶိုၼ်းဢဝ် [] ၼၼ်ႉမႃး။// ထႅဝ်ဢၼ်လႆႈဢဝ်မႃးၼၼ်ႉ ထုၵ်ႇလီၶိုၼ်းဢဝ်မႃးၼႂ်း array, [smallest_value, its index], // သင်ဝႃႈ လႆႈႁၼ် ၼေႃႇတႅၼ်းတင်းၼမ် ဢၼ်မီး ၵႃႈၶၼ်ဢၼ်လဵၵ်ႉသုတ်းဢၼ်မိူၼ်ၵၼ်ၼႆ ၶိုၼ်းဢဝ် ၼေႃႇတႅၼ်းဢၼ်မီး ထႅဝ်ဢၼ်လဵၵ်ႉသုတ်းၼၼ်ႉ လွၵ်ႈမႃးၶိုၼ်းယဝ်ႉ။// ထႅဝ်ဢၼ်လႆႈထုၵ်ႇထွၼ်ၼၼ်ႉ ထုၵ်ႇလီပဵၼ် ထႅဝ်ဢၼ်မီးၵႃႈၶၼ်ဢၼ်လဵၵ်ႉသုတ်းၼၼ်ႉယဝ်ႉ။ၼႃႈၵၢၼ်ၶွင်သူၼႆႉ ပဵၼ်တႃႇတေဢဝ် ၼူၵ်ႉဢၼ်ၼိူင်ႈသေ ၶိုၼ်းဢဝ်မႃးၶိုၼ်းယဝ်ႉ။// ""ပၼ်ဝႆႉ လွင်ႈၸႅၼ်ႇဢၼ်တၢင်တူဝ် ၵိင်ႇၽႄၶွင် တူၼ်ႈမႆႉ ဢၼ်မီး တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇမီး တူဝ်ထွၼ်ၼၼ်ႉယဝ်ႉ/// >>> pluck(arr: [4, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(arr: [1, 2, 3])
/// [2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(arr: [] as [Int])
/// [] as [Int]
/// Example 4:
/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])
/// [0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
func pluck(arr: [Int]) -> [Int] {
","func pluck(arr: [Int]) -> [Int] {
    var smallestEvenValue: Int? = nil
    var smallestIndex: Int? = nil

    for (index, value) in arr.enumerated() {
        if value % 2 == 0 {
            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {
                smallestEvenValue = value
                smallestIndex = index
            }
        }
    }

    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {
        return [smallestEvenValue, smallestIndex]
    } else {
        return []
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(pluck(arr: [4, 2, 3]) == [2, 1])
assert(pluck(arr: [1, 2, 3]) == [2, 1])
assert(pluck(arr: [] as [Int]) == [] as [Int])
assert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])
assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])
assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])
assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])
assert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
HumanEval_69,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// သင်ၸိူဝ်ႉဝႃႈ ဢမ်ႇမီးၵႃႈၶၼ်ဢၼ်ၼႆႉၼႆ ၶိုၼ်းဢဝ် - 1// လွင်ႈၵႆႉပဵၼ်ၶွင် တူဝ်ၼပ်ႉတဵမ်ၼႆႉ ပဵၼ်တူဝ်ၼပ်ႉ ဢၼ်မၼ်းဢွၵ်ႇမႃး ၼႂ်း array ၼၼ်ႉ။// သုၼ် လႄႈ မီးလွင်ႈၵႆႉၼမ်လိူဝ် ဢမ်ႇၼၼ် မိူၼ်ၵၼ်တၢင်းၵႃႈၶၼ် တူဝ်ၼပ်ႉတဵမ်ၼၼ်ႉႁင်းမၼ်း။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီးတူဝ်ၼပ်ႉၼၼ်ႉသေ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်ယႂ်ႇသေပိူၼ်ႈ ဢၼ်ယႂ်ႇလိူဝ်သေ /// >>> search(lst: [4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(lst: [5, 5, 4, 4, 4])
/// -1
func search(lst: [Int]) -> Int {
","func search(lst: [Int]) -> Int {
    var frequencyMap = [Int: Int]()
    
    // Count frequencies of each number in the list
    for number in lst {
        frequencyMap[number, default: 0] += 1
    }
    
    var result = -1
    
    // Iterate through the frequency map to find the greatest integer that satisfies the condition
    for (number, frequency) in frequencyMap {
        if frequency >= number {
            result = max(result, number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(search(lst: [5, 5, 5, 5, 1]) == 1)
assert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)
assert(search(lst: [3, 3]) == -1)
assert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)
assert(search(lst: [2, 3, 3, 2, 2]) == 2)
assert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)
assert(search(lst: [3, 2, 8, 2]) == 2)
assert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)
assert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)
assert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)
assert(search(lst: [1, 9, 10, 1, 3]) == 1)
assert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)
assert(search(lst: [1]) == 1)
assert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)
assert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)
assert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)
assert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)
assert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)
assert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)
assert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)
assert(search(lst: [10]) == -1)
assert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)
assert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)
assert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)
assert(search(lst: [3, 10, 10, 9, 2]) == -1)"
HumanEval_70,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ယဝ်ႉၵေႃႈ တူဝ်ၼပ်ႉတဵမ် ဢၼ်ၵိုတ်းဝႆႉၼၼ်ႉ ၼမ်သုတ်း၊ ယဝ်ႉၵေႃႈ တီႈဢေႇသုတ်း လႄႈ တၢင်ႇၸိူဝ်း။ // လွင်ႈၸႅၵ်ႇၽႄဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼႆႉ ပဵၼ်မိူဝ်ႈႁဝ်းတႄႇဢဝ် ၵႃႈၶၼ်ဢၼ်ဢေႇသုတ်းၼၼ်ႉ၊ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် array ၼၼ်ႉ၊ ၶိုၼ်းဢဝ် array ၼၼ်ႉမႃးၸွမ်းၼင်ႇပိူင်ဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉယဝ်ႉ။/// >>> strange_sort_list(lst: [1, 2, 3, 4])
/// [1, 4, 2, 3]
/// >>> strange_sort_list(lst: [5, 5, 5, 5])
/// [5, 5, 5, 5]
/// >>> strange_sort_list(lst: [] as [Int])
/// [] as [Int]
func strange_sort_list(lst: [Int]) -> [Int] {
","func strange_sort_list(lst: [Int]) -> [Int] {
    var sortedList = lst.sorted()
    var result: [Int] = []
    
    while !sortedList.isEmpty {
        if let min = sortedList.first {
            result.append(min)
            sortedList.removeFirst()
        }
        
        if let max = sortedList.last {
            result.append(max)
            sortedList.removeLast()
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])
assert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])
assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])
assert(strange_sort_list(lst: [] as [Int]) == [] as [Int])
assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])
assert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])
assert(strange_sort_list(lst: [111111]) == [111111])"
HumanEval_71,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // လိူဝ်သေၽၢႆႇထူၼ်ႈသၢမ်ၼၼ်ႉ။ // သၢမ်ၽၢႆႇၼႆႉ ပဵၼ်သၢမ်ၸဵင်ႇဢၼ်ထုၵ်ႇမႅၼ်ႈယူႇ ပေႃးဝႃႈ သွင်ၽၢႆႇဢၼ်လႂ်ၼႆႉ ႁူမ်ႈၵၼ်ၼမ်လိူဝ်သေၵၼ်ၼၼ်ႉယဝ်ႉ// ပေႃးဢမ်ႇၼၼ် ၶိုၼ်းပၼ် -1 // သၢမ်ၸဵင်ႇဢၼ်ၸီႉသင်ႇဝႆႉတီႈ 2 တူဝ်ၼပ်ႉၸုတ်ႇ ပေႃးသၢမ်ၽၢႆႇမၼ်းပဵၼ်သၢမ်ၸဵင်ႇဢၼ်မၢၼ်ႇမႅၼ်ႈၼႆယဝ်ႉ။// ပေႃးႁဝ်းတူၺ်း တၢင်းယၢဝ်းသၢမ်ၽၢႆႇၶွင် သၢမ်ၸဵင်ႇၼႆ ၶိုၼ်းပၼ် ၼႃႈလိၼ်ၶွင် /// >>> triangle_area(a: 3, b: 4, c: 5)
/// 6.0
/// >>> triangle_area(a: 1, b: 2, c: 10)
/// -1
func triangle_area(a: Int, b: Int, c: Int) -> Double {
","func triangle_area(a: Int, b: Int, c: Int) -> Double {
    // Check if the sides form a valid triangle
    if a + b > c && a + c > b && b + c > a {
        // Calculate the semi-perimeter
        let s = Double(a + b + c) / 2.0
        // Calculate the area using Heron's formula
        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))
        // Round to 2 decimal places
        return round(area * 100) / 100
    } else {
        return -1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(triangle_area(a: 3, b: 4, c: 5) == 6.0)
assert(triangle_area(a: 1, b: 2, c: 10) == -1)
assert(triangle_area(a: 4, b: 8, c: 5) == 8.18)
assert(triangle_area(a: 2, b: 2, c: 2) == 1.73)
assert(triangle_area(a: 1, b: 2, c: 3) == -1)
assert(triangle_area(a: 10, b: 5, c: 7) == 16.25)
assert(triangle_area(a: 2, b: 6, c: 3) == -1)
assert(triangle_area(a: 1, b: 1, c: 1) == 0.43)
assert(triangle_area(a: 2, b: 2, c: 10) == -1)"
HumanEval_72,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // ၶူဝ်းၶွင် q တေပၢႆႈၵႂႃႇ သင်ဝႃႈမၼ်းၽဵင်ႇပဵင်း (မၼ်းပဵၼ် palindromic array) လႄႈ လွင်ႈႁူမ်ႈၶွင်ၶူဝ်းၶွင်မၼ်းၼၼ်ႉ ယွမ်းလူင်းလိူဝ် ဢမ်ႇၼၼ် မိူၼ်ၵၼ်တၢင်းတၢင်းၼမ်သုတ်းဢၼ်ပဵၼ်လႆႈ w။ // တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်တေၶိုၼ်းပၼ် true သင်ၸိူဝ်ႉဝႃႈ ၶူဝ်းၶွင် q တေပၢႆႈၵႂႃႇ၊ လႄႈ false သင်ဢမ်ႇပၢႆႈၵႂႃႇ။ /// >>> will_it_fly(q: [1, 2], w: 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(q: [3, 2, 3], w: 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(q: [3, 2, 3], w: 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(q: [3], w: 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
func will_it_fly(q: [Int], w: Int) -> Bool {
","func will_it_fly(q: [Int], w: Int) -> Bool {
    func isPalindromic(_ array: [Int]) -> Bool {
        return array == array.reversed()
    }
    
    let sum = q.reduce(0, +)
    return isPalindromic(q) && sum <= w
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(will_it_fly(q: [3, 2, 3], w: 9) == true)
assert(will_it_fly(q: [1, 2], w: 5) == false)
assert(will_it_fly(q: [3], w: 5) == true)
assert(will_it_fly(q: [3, 2, 3], w: 1) == false)
assert(will_it_fly(q: [1, 2, 3], w: 6) == false)
assert(will_it_fly(q: [5], w: 5) == true)"
HumanEval_73,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-ပေႃးဝႃႈႁဝ်းလႅၵ်ႈလၢႆႈယဝ်ႉၼႆ ႁဝ်းတေလႅၵ်ႈလၢႆႈလႆႈ ၶူဝ်းၶွင်ဢၼ်ၼိုင်ႈသေ ၶူဝ်းၶွင်တၢင်ႇဢၼ်။// လူဝ်ႇလႆႈလႅၵ်ႈလၢႆႈ တွၼ်ႈတႃႇတေႁဵတ်းႁႂ်ႈ array ပဵၼ် palindromic array ပဵၼ် array ဢၼ် // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် array ၼၼ်ႉႁႃ တူဝ်ၼပ်ႉဢၼ်ဢေႇသုတ်းၶွင် တူဝ်ၼပ်ႉဢၼ် /// >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(arr: [1, 2, 3, 2, 1])
/// 0
func smallest_change(arr: [Int]) -> Int {
","func smallest_change(arr: [Int]) -> Int {
    var changes = 0
    let n = arr.count

    for i in 0..<(n / 2) {
        if arr[i] != arr[n - i - 1] {
            changes += 1
        }
    }

    return changes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)
assert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)
assert(smallest_change(arr: [1, 4, 2]) == 1)
assert(smallest_change(arr: [1, 4, 4, 2]) == 1)
assert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)
assert(smallest_change(arr: [3, 1, 1, 3]) == 0)
assert(smallest_change(arr: [1]) == 0)
assert(smallest_change(arr: [0, 1]) == 1)"
HumanEval_74,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢၼ်မိူၼ်ၵၼ်တင်းသွင်ဢၼ်ၼၼ်ႉၼႆ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢွၼ်တၢင်းသုတ်းၼၼ်ႉၶိုၼ်းမႃး// တူဝ်ၼပ်ႉဢၼ်မီးတီႈ တူဝ်ၸႅၼ်ႇတူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈၼၼ်ႉ မၼ်းဢေႇလိူဝ် တူဝ်ၸႅၼ်ႇတူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈၼၼ်ႉယဝ်ႉ။// တႅမ်ႈပၼ် function ဢၼ်ႁပ်ႉဢဝ် string arrays သွင်ဢၼ်သေ ၶိုၼ်းပၼ် array ဢၼ်မီး /// >>> total_match(lst1: [] as [String], lst2: [] as [String])
/// [] as [String]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""])
/// [""hI"", ""Hi""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""])
/// [""hi"", ""admin""]
/// >>> total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""])
/// [""hI"", ""hi"", ""hi""]
/// >>> total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""])
/// [""4""]
func total_match(lst1: [String], lst2: [String]) -> [String] {
","func total_match(lst1: [String], lst2: [String]) -> [String] {
    let totalChars1 = lst1.reduce(0) { $0 + $1.count }
    let totalChars2 = lst2.reduce(0) { $0 + $1.count }
    
    if totalChars1 < totalChars2 {
        return lst1
    } else if totalChars2 < totalChars1 {
        return lst2
    } else {
        return lst1
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi""]) == [""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hi"", ""hi"", ""admin"", ""project""]) == [""hi"", ""admin""])
assert(total_match(lst1: [""4""], lst2: [""1"", ""2"", ""3"", ""4"", ""5""]) == [""4""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""Hi""]) == [""hI"", ""Hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hi""]) == [""hI"", ""hi"", ""hi""])
assert(total_match(lst1: [""hi"", ""admin""], lst2: [""hI"", ""hi"", ""hii""]) == [""hi"", ""admin""])
assert(total_match(lst1: [] as [String], lst2: [""this""]) == [] as [String])
assert(total_match(lst1: [""this""], lst2: [] as [String]) == [] as [String])"
HumanEval_75,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // ႁူႉဝႃႈ (a) ၼႆႉဢေႇလိူဝ် 100 ၼႆယူႇယဝ်ႉ။// လႄႈ ဢၼ်ၽိတ်း ဢၼ်ဢမ်ႇၸႂ်ႈ။ // တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ၶိုၼ်းမၵ်းမၼ်ႈဝႃႈ ပဵၼ်လွင်ႈမၢၼ်ႇမႅၼ်ႈယူႇ သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပဵၼ်လွင်ႈၵုၼ်း တူဝ်ၼပ်ႉၶမ်ႇပိုၼ်ႉ 3 တူဝ်ၼႆယဝ်ႉ။/// >>> is_multiply_prime(a: 30)
/// true
/// 30 = 2 * 3 * 5
func is_multiply_prime(a: Int) -> Bool {
","func is_multiply_prime(a: Int) -> Bool {
    // Function to check if a number is prime
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Generate all prime numbers less than 100
    var primes = [Int]()
    for i in 2..<100 {
        if isPrime(i) {
            primes.append(i)
        }
    }
    
    // Check combinations of 3 primes
    let primeCount = primes.count
    for i in 0..<primeCount {
        for j in i..<primeCount {
            for k in j..<primeCount {
                if primes[i] * primes[j] * primes[k] == a {
                    return true
                }
            }
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_multiply_prime(a: 5) == false)
assert(is_multiply_prime(a: 30) == true)
assert(is_multiply_prime(a: 8) == true)
assert(is_multiply_prime(a: 10) == false)
assert(is_multiply_prime(a: 125) == true)
assert(is_multiply_prime(a: 105) == true)
assert(is_multiply_prime(a: 126) == false)
assert(is_multiply_prime(a: 729) == false)
assert(is_multiply_prime(a: 891) == false)
assert(is_multiply_prime(a: 1001) == true)"
HumanEval_76,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// x ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈဢၼ်ပဵၼ် တူဝ်ၼမ် ႁင်း n ပေႃး n**int=x ၼႆ// ႁႅင်းၶွင် n လႄႈ false ၼႂ်းလွင်ႈတၢင်ႇဢၼ်။ // ၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉပဵၼ်တႃႇတႅမ်ႈ function ဢၼ်ၶိုၼ်းမႃး true သင်တူဝ်ၼပ်ႉ x ပဵၼ်တူဝ်ၼပ်ႉဢၼ်ငၢႆႈ /// >>> is_simple_power(x: 1, n: 4)
/// true
/// >>> is_simple_power(x: 2, n: 2)
/// true
/// >>> is_simple_power(x: 8, n: 2)
/// true
/// >>> is_simple_power(x: 3, n: 2)
/// false
/// >>> is_simple_power(x: 3, n: 1)
/// false
/// >>> is_simple_power(x: 5, n: 3)
/// false
func is_simple_power(x: Int, n: Int) -> Bool {
","func is_simple_power(x: Int, n: Int) -> Bool {
    if x < 1 || n < 1 {
        return false
    }
    if x == 1 {
        return true // n**0 = 1
    }
    var power = 1
    while power < x {
        power *= n
    }
    return power == x
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_simple_power(x: 16, n: 2) == true)
assert(is_simple_power(x: 143214, n: 16) == false)
assert(is_simple_power(x: 4, n: 2) == true)
assert(is_simple_power(x: 9, n: 3) == true)
assert(is_simple_power(x: 16, n: 4) == true)
assert(is_simple_power(x: 24, n: 2) == false)
assert(is_simple_power(x: 128, n: 4) == false)
assert(is_simple_power(x: 12, n: 6) == false)
assert(is_simple_power(x: 1, n: 1) == true)
assert(is_simple_power(x: 1, n: 12) == true)"
HumanEval_77,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// မၢႆတွင်း: သူတေၸၢင်ႈဝူၼ်ႉဝႃႈ ၶေႃႈၶဝ်ႈၼႆႉ မၼ်းထုၵ်ႇမႅၼ်ႈယူႇတႃႇသေႇ။// သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ၼႆႉ ပဵၼ်တူဝ်ၼပ်ႉတဵမ်ဢၼ်ၼိူင်ႈ ဢၼ်တဵမ်ထူၼ်ႈၼၼ်ႉယဝ်ႉ။// တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ဢဝ် တူဝ်ၼပ်ႉတဵမ် a သေ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉ true/// >>> iscube(a: 1)
/// true
/// >>> iscube(a: 2)
/// false
/// >>> iscube(a: -1)
/// true
/// >>> iscube(a: 64)
/// true
/// >>> iscube(a: 0)
/// true
/// >>> iscube(a: 180)
/// false
func iscube(a: Int) -> Bool {
","func iscube(a: Int) -> Bool {
    if a == 0 { return true } // 0 is a cube (0^3)
    let absA = abs(a)
    let cubeRoot = Int(round(pow(Double(absA), 1.0/3.0)))
    return cubeRoot * cubeRoot * cubeRoot == absA
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(iscube(a: 1) == true)
assert(iscube(a: 2) == false)
assert(iscube(a: -1) == true)
assert(iscube(a: 64) == true)
assert(iscube(a: 180) == false)
assert(iscube(a: 1000) == true)
assert(iscube(a: 0) == true)
assert(iscube(a: 1729) == false)"
HumanEval_78,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:တူဝ်လိၵ်ႈ A,B,C,D,E,F ၼႆႉ ပဵၼ်တူဝ်လိၵ်ႈယႂ်ႇသေပိူၼ်ႈယဝ်ႉ။// မၢႆတွင်း: သူတေၸၢင်ႈဝူၼ်ႉဝႃႈ ၶေႃႈၶဝ်ႈၼႆႉ မၢၼ်ႇမႅၼ်ႈယူႇတႃႇသေႇ ဢမ်ႇၼၼ် ပဵၼ် string ဢၼ်ဢမ်ႇမီးတူဝ်၊ B (= သဵၼ်ႈမၢႆသိပ်းလပ်း 11), D (= သဵၼ်ႈမၢႆသိပ်းလပ်း 13) ။// ၵွပ်ႈၼၼ်လႄႈ တေလႆႈမၵ်းမၼ်ႈ တူဝ်ၼပ်ႉဢၼ်မီးယူႇတီႈတႂ်ႈၼႆႉ 2, 3, 5, 7, တူဝ်ၼပ်ႉၸႅတ်ႈၸၢင်ႇၼႆႉပဵၼ် 2, 3, 5, 7, 11, 13, 17,...// တူဝ်ၼပ်ႉသႅၼ်တူဝ်ၼႆႉပဵၼ် 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. // ဢၼ်ယႂ်ႇလိူဝ် 1 ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၵုၼ်း တူဝ်ၼပ်ႉသၽႃႇဝ ဢၼ်လဵၵ်ႉလိူဝ်သွင်တူဝ်) ။// တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ (တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ ဢမ်ႇၼၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈၼႆႉ ပဵၼ် တူဝ်ၼပ်ႉသၽႃႇဝ // တူဝ်ၼပ်ႉ hexadecimal ဢၼ်ၼိူင်ႈ မိူၼ်ၼင်ႇ သဵၼ်ႈသၢႆမၢႆ လႄႈ မၢႆၼပ်ႉ တူဝ်ၼပ်ႉ hexadecimal // သူထုၵ်ႇလႆႈတႅမ်ႈပၼ် function ဢၼ်ႁပ်ႉဢဝ် /// >>> hex_key(num: ""AB"")
/// 1
/// >>> hex_key(num: ""1077E"")
/// 2
/// >>> hex_key(num: ""ABED1A33"")
/// 4
/// >>> hex_key(num: ""123456789ABCDEF0"")
/// 6
/// >>> hex_key(num: ""2020"")
/// 2
func hex_key(num: String) -> Int {
","func hex_key(num: String) -> Int {
    // Define hexadecimal digits that are prime numbers
    let primeHexDigits: Set<Character> = [""2"", ""3"", ""5"", ""7"", ""B"", ""D""]
    
    // Initialize count
    var primeCount = 0
    
    // Iterate over each character in the string
    for char in num {
        // Check if the character is a prime hexadecimal digit
        if primeHexDigits.contains(char) {
            primeCount += 1
        }
    }
    
    return primeCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(hex_key(num: ""AB"") == 1)
assert(hex_key(num: ""1077E"") == 2)
assert(hex_key(num: ""ABED1A33"") == 4)
assert(hex_key(num: ""2020"") == 2)
assert(hex_key(num: ""123456789ABCDEF0"") == 6)
assert(hex_key(num: ""112233445566778899AABBCCDDEEFF00"") == 12)"
HumanEval_79,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// တူဝ်လိၵ်ႈဢၼ်လိူဝ်ၼႆႉ ပဵၼ်တႃႇၸွႆႈထႅမ် ပိူင်ၾၢင်မၼ်းယဝ်ႉ။// တေမီးတူဝ်လိၵ်ႈထႅင်ႈသွင်တူဝ် 'db' တီႈတႄႇလႄႈ တီႈသုတ်းၶွင် string ၼၼ်ႉယူႇယဝ်ႉ။တူဝ်လိၵ်ႈၵူႈတူဝ် ၼႂ်းသတၢႆႇၼႆႉ တေပဵၼ် ""0"" ဢမ်ႇၼၼ် ""1""တူဝ်လိၵ်ႈဢၼ်ၼိူင်ႈဢၼ်ၼႆႉ ပဵၼ်တူဝ်ၼပ်ႉ သွင်တူဝ် (binary) ဢၼ်ၼိူင်ႈယဝ်ႉ။// သူတေလႆႈပၼ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉႁူဝ်သိပ်း လႄႈ ၼႃႈၵၢၼ်သူတေလႆႈလႅၵ်ႈလၢႆႈမၼ်းပဵၼ် /// >>> decimal_to_binary(decimal: 15)
/// ""db1111db""
/// >>> decimal_to_binary(decimal: 32)
/// ""db100000db""
func decimal_to_binary(decimal: Int) -> String {
","func decimal_to_binary(decimal: Int) -> String {
    let binaryString = String(decimal, radix: 2)
    return ""db"" + binaryString + ""db""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(decimal_to_binary(decimal: 0) == ""db0db"")
assert(decimal_to_binary(decimal: 32) == ""db100000db"")
assert(decimal_to_binary(decimal: 103) == ""db1100111db"")
assert(decimal_to_binary(decimal: 15) == ""db1111db"")"
HumanEval_80,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// သဵၼ်ဢၼ်ၼိူင်ႈၼႆႉ ပေႃးဝႃႈ တၢင်းယၢဝ်းမၼ်းမီး 3 တူဝ် လႄႈ တူဝ်လိၵ်ႈ 3 တူဝ်ဢၼ်သိုပ်ႇၵၼ်ၼၼ်ႉ မီးလွင်ႈပႅၵ်ႇပိူင်ႈၵၼ်ၼႆ မၼ်းပဵၼ်သဵၼ်ဢၼ်လႅတ်းဝႆးၼၼ်ႉယဝ်ႉ။// ၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉတေႉတေႉဝႃႈဝႃႈဝႃႈ string ၼႆႉပဵၼ် hapswift ႁိုဝ်ဢမ်ႇၸႂ်ႈ။// လႆႈပၼ် string s. /// >>> is_happy(s: ""a"")
/// false
/// >>> is_happy(s: ""aa"")
/// false
/// >>> is_happy(s: ""abcd"")
/// true
/// >>> is_happy(s: ""aabb"")
/// false
/// >>> is_happy(s: ""adb"")
/// true
/// >>> is_happy(s: ""xyy"")
/// false
func is_happy(s: String) -> Bool {
","func is_happy(s: String) -> Bool {
    let characters = Array(s)
    if characters.count < 3 {
        return false
    }
    
    for i in 0..<(characters.count - 2) {
        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {
            return false
        }
    }
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_happy(s: ""a"") == false)
assert(is_happy(s: ""aa"") == false)
assert(is_happy(s: ""abcd"") == true)
assert(is_happy(s: ""aabb"") == false)
assert(is_happy(s: ""adb"") == true)
assert(is_happy(s: ""xyy"") == false)
assert(is_happy(s: ""iopaxpoi"") == true)
assert(is_happy(s: ""iopaxioi"") == false)"
HumanEval_81,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // 0.0 E // > 0.0 D- // > 0.7 D // > 1.0 D+ // > 1.3 C- // > 1.7 C // > 2.0 C+ // > 2.3 B- // > 2.7 B // > 3.0 B+ // > 3.3 A- // > 3.7 A // 4.0 A+ GPA  လဵပ်ႈႁဵၼ်းလိၵ်ႈလၢႆး // တူဝ်ဢိင်ဢၼ်ၼိူင်ႈ ဢၼ်ၸၢင်ႈဢွၵ်ႇမႃး တူဝ်လိၵ်ႈဢၼ်ၼိူင်ႈ ဢၼ်ၸႂ်ႉတိုဝ်း ထႅဝ်လိၵ်ႈဢၼ်ၼႆႉ: မၼ်းၼၢင်းပၼ်ဝႆႉ GPA တႃႇလုၵ်ႈႁဵၼ်းၵမ်ႈၽွင်ႈလႄႈ တေလႆႈတႅမ်ႈလိၵ်ႈ။ပၼ်ႁႃဢၼ်လဵဝ်ၵူၺ်းတႄႉ မၼ်းၼၢင်းလႆႈလူႉလႅဝ် ပၵ်းပိူင်ဢၼ်မၼ်းၼၢင်းၸႂ်ႉတိုဝ်းတွၼ်ႈတႃႇ မၵ်းမၼ်ႈၼၼ်ႉယဝ်ႉ။ၶူးသွၼ်ၶဝ် လႆႈႁဵတ်းဢွၵ်ႇမႃး လွၵ်းလၢႆးမၼ်း တႃႇတေပၼ်လႆႈ မၢႆမီႈ။// ပဵၼ်ဝူင်ႈလိုၼ်းသုတ်း ၼႂ်းသႅပ်ႇထႅမ်ႇပႃႇလႄႈ ၶူးသွၼ်တေလႆႈပၼ် မၢႆၶပ်ႉၶိုင် ꧦ/// >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])
/// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
func numerical_letter_grade(grades: [Double]) -> [String] {
","func numerical_letter_grade(grades: [Double]) -> [String] {
    return grades.map { gpa in
        switch gpa {
        case 4.0:
            return ""A+""
        case 3.7...4.0:
            return ""A""
        case 3.3..<3.7:
            return ""A-""
        case 3.0..<3.3:
            return ""B+""
        case 2.7..<3.0:
            return ""B""
        case 2.3..<2.7:
            return ""B-""
        case 2.0..<2.3:
            return ""C+""
        case 1.7..<2.0:
            return ""C""
        case 1.3..<1.7:
            return ""C-""
        case 1.0..<1.3:
            return ""D+""
        case 0.7..<1.0:
            return ""D""
        case 0.0..<0.7:
            return ""D-""
        default:
            return ""E""
        }
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [""A+"", ""B"", ""C-"", ""C"", ""A-""])
assert(numerical_letter_grade(grades: [1.2]) == [""D+""])
assert(numerical_letter_grade(grades: [0.5]) == [""D-""])
assert(numerical_letter_grade(grades: [0.0]) == [""E""])
assert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [""D"", ""D-"", ""C-"", ""B"", ""B+""])
assert(numerical_letter_grade(grades: [0.0, 0.7]) == [""E"", ""D-""])"
HumanEval_82,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // တၢင်းယၢဝ်းမၼ်းပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ ဢမ်ႇၼၼ် ဢမ်ႇမၢၼ်ႇမႅၼ်ႈ ပေႃးဢမ်ႇၼၼ် // တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ဢဝ် သတၢႆႇသေ ၶိုၼ်းပၼ် true သင်ဝႃႈ သတၢႆႇၼၼ်ႉ /// >>> prime_length(string: ""Hello"")
/// true
/// >>> prime_length(string: ""abcdcba"")
/// true
/// >>> prime_length(string: ""kittens"")
/// true
/// >>> prime_length(string: ""orange"")
/// false
func prime_length(string: String) -> Bool {
","func prime_length(string: String) -> Bool {
    let length = string.count
    
    guard length > 1 else {
        return false
    }
    
    for i in 2..<length {
        if length % i == 0 {
            return false
        }
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prime_length(string: ""Hello"") == true)
assert(prime_length(string: ""abcdcba"") == true)
assert(prime_length(string: ""kittens"") == true)
assert(prime_length(string: ""orange"") == false)
assert(prime_length(string: ""wow"") == true)
assert(prime_length(string: ""world"") == true)
assert(prime_length(string: ""MadaM"") == true)
assert(prime_length(string: ""Wow"") == true)
assert(prime_length(string: """") == false)
assert(prime_length(string: ""HI"") == true)
assert(prime_length(string: ""go"") == true)
assert(prime_length(string: ""gogo"") == false)
assert(prime_length(string: ""aaaaaaaaaaaaaaa"") == false)
assert(prime_length(string: ""Madam"") == true)
assert(prime_length(string: ""M"") == false)
assert(prime_length(string: ""0"") == false)"
HumanEval_83,shn_Mymr,swift,"
// တူဝ်ၼပ်ႉတဵမ် ဢၼ်တႄႇ ဢမ်ႇၼၼ် သုတ်းတီႈ 1 ၼၼ်ႉ။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်သၢင်ႇထုၵ်ႇ n ၼၼ်ႉ၊ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်မီးတူဝ်ၼပ်ႉ n ၼၼ်ႉfunc starts_one_ends(n: Int) -> Int {
","func starts_one_ends(n: Int) -> Int {
    if n == 1 {
        // For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.
        return 1
    }
    
    // Count of n-digit numbers starting with 1:
    // First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.
    let startWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Count of n-digit numbers ending with 1:
    // Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.
    // So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.
    let endWithOne = Int(pow(10.0, Double(n - 1)))
    
    // Intersection of both sets is the numbers starting and ending with 1
    // which are of the form `1` followed by (n-2) digits and `1`, so:
    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))
    
    return startWithOne + endWithOne - startAndEndWithOne
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(starts_one_ends(n: 1) == 1)
assert(starts_one_ends(n: 2) == 18)
assert(starts_one_ends(n: 3) == 180)
assert(starts_one_ends(n: 4) == 1800)
assert(starts_one_ends(n: 5) == 18000)"
HumanEval_84,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်သၢင်ႇထုၵ်ႇ N ၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉသွင်တူဝ်မၼ်းမႃးႁူမ်ႈၵၼ်။ /// >>> solve(N: 1000)
/// ""1""
/// >>> solve(N: 150)
/// ""110""
/// >>> solve(N: 147)
/// ""1100""
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
func solve(N: Int) -> String {
","func solve(N: Int) -> String {
    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)
    return String(sumOfDigits, radix: 2)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(N: 1000) == ""1"")
assert(solve(N: 150) == ""110"")
assert(solve(N: 147) == ""1100"")
assert(solve(N: 333) == ""1001"")
assert(solve(N: 963) == ""10010"")"
HumanEval_85,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီးတီႈသုတ်းၼၼ်ႉ ထႅမ်သႂ်ႇ တူဝ်ၼပ်ႉဢၼ်ပဵၼ်ၸဵင်ႇၵၼ် ဢၼ်မီးတီႈ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉ။/// >>> add(lst: [4, 2, 6, 7])
/// 2
func add(lst: [Int]) -> Int {
","func add(lst: [Int]) -> Int {
    var sum = 0
    for i in stride(from: 1, to: lst.count, by: 2) {
        if lst[i] % 2 == 0 {
            sum += lst[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add(lst: [4, 88]) == 88)
assert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)
assert(add(lst: [4, 0, 6, 7]) == 0)
assert(add(lst: [4, 4, 6, 8]) == 12)"
HumanEval_86,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// မၢႆတွင်း: သူတေလႆႈထိင်းသိမ်းဝႆႉ လွင်ႈၶပ်ႉၶိုင်ၶွင် ၶေႃႈၵႂၢမ်းလႄႈ လွင်ႈဢၼ်ဢမ်ႇမီးတီႈပွင်ႇ ၼႂ်းၶေႃႈၵႂၢမ်းၼၼ်ႉ။// ၶၵ်ႉတွၼ်ႈၶိုၼ်ႈၼိူဝ် ဢၼ်ဢိင်ၼိူဝ် ၵႃႈၶၼ် ascii။ // လႆႈထုၵ်ႇဢဝ်မႃးတႅၼ်းတီႈ ၶေႃႈၵႂၢမ်းမႂ်ႇ တီႈဢၼ်တူဝ်လိၵ်ႈတင်းမူတ်း လႆႈထုၵ်ႇၶပ်ႉဝႆႉတီႈ // Ordered version of string, ပဵၼ် string တီႈဢၼ်ၶေႃႈၵႂၢမ်းတင်းမူတ်း (ဢၼ်ၽႄဝႆႉလူၺ်ႈႁွင်ႈ) // တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ဢဝ် တူဝ်ၸၼ်းသေ ၶိုၼ်းပၼ် တူဝ်ၸၼ်းဢၼ်မီးဝႆႉပိူင်ထၢၼ်ႈမၼ်းၼၼ်ႉ။/// >>> anti_shuffle(s: ""Hi"")
/// ""Hi""
/// >>> anti_shuffle(s: ""hello"")
/// ""ehllo""
/// >>> anti_shuffle(s: ""Hello World!!!"")
/// ""Hello !!!Wdlor""
func anti_shuffle(s: String) -> String {
","func anti_shuffle(s: String) -> String {
    let words = s.components(separatedBy: .whitespaces)
    let orderedWords = words.map { String($0.sorted()) }
    var result = """"
    var wordIndex = 0
    
    for character in s {
        if character.isWhitespace {
            result.append(character)
        } else if wordIndex < orderedWords.count {
            if let currentWord = orderedWords[wordIndex].first {
                result.append(currentWord)
                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)
            }
        }
        
        if let lastCharacter = result.last {
            if lastCharacter.isWhitespace {
                wordIndex += 1
            }
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(anti_shuffle(s: ""Hi"") == ""Hi"")
assert(anti_shuffle(s: ""hello"") == ""ehllo"")
assert(anti_shuffle(s: ""number"") == ""bemnru"")
assert(anti_shuffle(s: ""abcd"") == ""abcd"")
assert(anti_shuffle(s: ""Hello World!!!"") == ""Hello !!!Wdlor"")
assert(anti_shuffle(s: """") == """")
assert(anti_shuffle(s: ""Hi. My name is Mister Robot. How are you?"") == "".Hi My aemn is Meirst .Rboot How aer ?ouy"")"
HumanEval_87,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ယဝ်ႉၵေႃႈ ၸႅၵ်ႇမႅင်ႇ coordinates ၶွင် row ၸွမ်း column ၸွမ်းၼင်ႇ ၶၵ်ႉတွၼ်ႈ ဢၼ်ယွမ်းလူင်းမႃးၼၼ်ႉယဝ်ႉ။// ၸႅၵ်ႇမႅင်ႇ coordinates ၸွမ်းၼင်ႇ ထႅဝ်ဢၼ်ၶိုၼ်ႈမႃးၼၼ်ႉယဝ်ႉ။// သၢႆမၢႆဢၼ်ပဵၼ်ၸဵင်ႇဢၼ်ၼိူင်ႈဢၼ်ၼႆႉ ပဵၼ် coordinate - (ထႅဝ်၊ ၵူဝ်ႇလမ်ႇ) ၊ တႄႇတီႈ 0 ၼၼ်ႉယဝ်ႉ။// လႄႈ ၶိုၼ်းဢဝ် array ၶွင် tuples, [(x1, y1), (x2, y2) ...] ၼင်ႇၼၼ် // ပၼ် lst လႄႈ တူဝ်ၼပ်ႉတဵမ် x၊ သွၵ်ႈႁႃ တူဝ်ၼပ်ႉတဵမ် x တီႈၼႂ်း array ၼၼ်ႉ၊ // သဵၼ်ႈၵူႈဢၼ်ၼႆႉ တေၸၢင်ႈမီးဝႆႉ တူဝ်ၼပ်ႉဢၼ်ပႅၵ်ႇပိူင်ႈၵၼ် ၶွင်ၵႅၼ်။// ဢၼ်ငၢႆးၵၼ်တင်း matrix ၵူၺ်းဢမ်ႇမိူၼ်ၵၼ်တင်း matrix၊ // လႆႈပၼ်ၶေႃႈမုၼ်း 2 ထတ်း၊ မိူၼ်ၼင်ႇ ၶႅပ်းႁၢင်ႈဢၼ်မီးႁိမ်းႁွမ်းၵၼ်၊ /// >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)
/// [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(lst: [] as [[Int]], x: 1)
/// [] as [(Int, Int)]
/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)
/// [(2, 2)]
func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
","func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {
    var coordinates: [(Int, Int)] = []
    
    for (rowIndex, row) in lst.enumerated() {
        for (colIndex, value) in row.enumerated() {
            if value == x {
                coordinates.append((rowIndex, colIndex))
            }
        }
    }
    
    let sortedCoordinates = coordinates.sorted {
        if $0.0 == $1.0 {
            return $0.1 > $1.1
        } else {
            return $0.0 < $1.0
        }
    }
    
    return sortedCoordinates
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])
assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])
assert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])
assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])
assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
HumanEval_88,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// * ယႃႇပေလႅၵ်ႈလၢႆႈပၼ် array ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ။ // မၢႆတွင်း: // ဢမ်ႇၼၼ် ၸႅၵ်ႇမၼ်းၸွမ်းၼင်ႇ လွင်ႈၶၢႆႉယႆမၼ်း သင်ဝႃႈ တူဝ်လေႃး ((ၵႃႈၶၼ် index ဢွၼ်တၢင်းသုတ်း၊ ၵႃႈၶၼ် index လိုၼ်းသုတ်း) ၼႆႉပဵၼ် even ၼႆယူႇယဝ်ႉ။ // သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ႁူမ်ႈၵၼ် ((ၵႃႈၶၼ် index ဢွၼ်တၢင်းသုတ်း၊ ၵႃႈၶၼ် index လိုၼ်းသုတ်း) ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼႆၸိုင် တေၸႅၵ်ႇၽႄပၼ် array ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ လူၺ်ႈလွင်ႈၶၢႆႉလၢႆႈၶိုၼ်ႈမႃး၊ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ထွၼ်ၼၼ်ႉ၊ ၶိုၼ်းဢဝ် coswift ၶွင် တူဝ်ၼပ်ႉတဵမ်ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ဝၢႆးသေ ၸႅၵ်ႇၽႄယဝ်ႉၼၼ်ႉ၊ /// >>> sort_array(array: [] as [Int])
/// [] as [Int]
/// >>> sort_array(array: [5])
/// [5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5])
/// [0, 1, 2, 3, 4, 5]
/// >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])
/// [6, 5, 4, 3, 2, 1, 0]
func sort_array(array: [Int]) -> [Int] {
","func sort_array(array: [Int]) -> [Int] {
    guard let first = array.first, let last = array.last else {
        return array
    }
    let sum = first + last
    if sum % 2 == 0 {
        return array.sorted(by: >) // Descending order
    } else {
        return array.sorted() // Ascending order
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(array: [] as [Int]) == [] as [Int])
assert(sort_array(array: [5]) == [5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])
assert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])
assert(sort_array(array: [2, 1]) == [1, 2])
assert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])
assert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"
HumanEval_89,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ၶၢႆႉလူင်းၵႂႃႇ 2 ပွၵ်ႈ ပွၵ်ႈသွင်။ // တူဝ်လိၵ်ႈၼႆႉ ထုၵ်ႇလီလႅၵ်ႈလၢႆႈ ႁႂ်ႈပဵၼ် တူဝ်လိၵ်ႈဢၼ်ၼိူင်ႈ// ၶိုၼ်းဢဝ် တူဝ်လိၵ်ႈဢၼ်ပဵၼ် တူဝ်လိၵ်ႈလပ်ႉ ဢၼ်လႆႈပိၼ်ႇဝႆႉၼၼ်ႉ ၶိုၼ်းပၼ်ၶိုၼ်း// ႁဵတ်းသၢင်ႈ encrypt function ဢၼ်ဢဝ် string ပဵၼ် arguments လႄႈ /// >>> encrypt(s: ""hi"")
/// ""lm""
/// >>> encrypt(s: ""asdfghjkl"")
/// ""ewhjklnop""
/// >>> encrypt(s: ""gf"")
/// ""kj""
/// >>> encrypt(s: ""et"")
/// ""ix""
func encrypt(s: String) -> String {
","func encrypt(s: String) -> String {
    let alphabet = Array(""abcdefghijklmnopqrstuvwxyz"")
    let shift = 2 * 2 // shift down by two multiplied by two places, i.e., 4
    var result = """"

    for character in s {
        if let index = alphabet.firstIndex(of: character) {
            let newIndex = (index + shift) % alphabet.count
            result.append(alphabet[newIndex])
        } else {
            result.append(character) // append non-alphabetic characters unchanged
        }
    }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encrypt(s: ""hi"") == ""lm"")
assert(encrypt(s: ""asdfghjkl"") == ""ewhjklnop"")
assert(encrypt(s: ""gf"") == ""kj"")
assert(encrypt(s: ""et"") == ""ix"")
assert(encrypt(s: ""faewfawefaewg"") == ""jeiajeaijeiak"")
assert(encrypt(s: ""hellomyfriend"") == ""lippsqcjvmirh"")
assert(encrypt(s: ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"") == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")
assert(encrypt(s: ""a"") == ""e"")"
HumanEval_90,shn_Mymr,swift,"
// ၶိုၼ်းဢဝ် nil မႃးၶိုၼ်း သင်ၸိူဝ်ႉဝႃႈ ဢမ်ႇမီး တူဝ်ထပ်ႈႁူဝ်ၼႆယဝ်ႉ။// တႅမ်ႈပၼ် function next_smallest ((() ဢၼ်တေၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်လဵၵ်ႉသုတ်းထူၼ်ႈသွင် ၶွင် array ၼၼ်ႉ။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ်တင်းၼမ်။/// >>> next_smallest(lst: [1, 2, 3, 4, 5])
/// 2
/// >>> next_smallest(lst: [5, 1, 4, 3, 2])
/// 2
/// >>> next_smallest(lst: [] as [Int])
/// nil
/// >>> next_smallest(lst: [1, 1])
/// nil
func next_smallest(lst: [Int]) -> Int? {
","func next_smallest(lst: [Int]) -> Int? {
    if lst.count < 2 {
        return nil
    }
    
    var uniqueSorted = Array(Set(lst)).sorted()
    
    if uniqueSorted.count < 2 {
        return nil
    }
    
    return uniqueSorted[1]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)
assert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)
assert(next_smallest(lst: [] as [Int]) == nil)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)
assert(next_smallest(lst: [1, 1]) == nil)
assert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
HumanEval_91,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ၶေႃႈၵႂၢမ်းဢၼ်ၵိုတ်းဝႆႉၼၼ်ႉ ဢဝ် '.', '?' ဢမ်ႇၼၼ် '!' သေၵႄႈလိတ်ႈ။လွင်ႈဢၼ်ဢမ်ႇမီးလွင်ႈၶၢၼ်ႉၸႂ်ၼႆႉ ပဵၼ်ၶေႃႈၵႂၢမ်းဢၼ်တႄႇတီႈ ""ၵဝ်"" ၼၼ်ႉယဝ်ႉ။// သူတေလႆႈပၼ်ၶေႃႈၵႂၢမ်းဢၼ်ၼိူင်ႈသေ ၼႃႈၵၢၼ်သူတေလႆႈၼပ်ႉသွၼ်ႇ တူဝ်ၼပ်ႉမၼ်း /// >>> is_bored(S: ""Hello world"")
/// 0
/// >>> is_bored(S: ""The sky is blue. The sun is shining. I love this weather"")
/// 1
func is_bored(S: String) -> Int {
","func is_bored(S: String) -> Int {
    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }
    var boredomCount = 0
    
    for sentence in sentences {
        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)
        if trimmedSentence.hasPrefix(""I"") {
            boredomCount += 1
        }
    }
    
    return boredomCount
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_bored(S: ""Hello world"") == 0)
assert(is_bored(S: ""Is the sky blue?"") == 0)
assert(is_bored(S: ""I love It !"") == 1)
assert(is_bored(S: ""bIt"") == 0)
assert(is_bored(S: ""I feel good today. I will be productive. will kill It"") == 2)
assert(is_bored(S: ""You and I are going for a walk"") == 0)"
HumanEval_92,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // မႄးၶိုၼ်း false တီႈၼႂ်းလွင်ႈတၢင်းတၢင်ႇဢၼ်။ // မိူဝ်းၶိုၼ်း true သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈၼႆႉ ပဵၼ်မိူၼ်ၵၼ်တၢင်း တူဝ်ၼပ်ႉသွင်ဢၼ်ၼၼ်ႉ လႄႈ တူဝ်ၼပ်ႉတင်းမူတ်းၼႆႉ ပဵၼ်တူဝ်ၼပ်ႉတဵမ်ၼႆယဝ်ႉ။ // ႁဵတ်းပၼ် တူဝ်ဢိင်ဢၼ်ၸ်ႂႉတူဝ်ၼပ်ႉ 3 တူဝ်/// >>> any_int(x: 5, y: 2, z: 7)
/// true
/// >>> any_int(x: 3, y: 2, z: 2)
/// false
/// >>> any_int(x: 3, y: -2, z: 1)
/// true
/// >>> any_int(x: 3.6, y: -2.2, z: 2)
/// false
func any_int(x: Double, y: Double, z: Double) -> Bool {
","func any_int(x: Double, y: Double, z: Double) -> Bool {
    guard x == floor(x), y == floor(y), z == floor(z) else {
        return false
    }
    
    let a = Int(x)
    let b = Int(y)
    let c = Int(z)
    
    return a == b + c || b == a + c || c == a + b
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(any_int(x: 2, y: 3, z: 1) == true)
assert(any_int(x: 2.5, y: 2, z: 3) == false)
assert(any_int(x: 1.5, y: 5, z: 3.5) == false)
assert(any_int(x: 2, y: 6, z: 2) == false)
assert(any_int(x: 4, y: 2, z: 2) == true)
assert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)
assert(any_int(x: -4, y: 6, z: 2) == true)
assert(any_int(x: 2, y: 1, z: 1) == true)
assert(any_int(x: 3, y: 4, z: 7) == true)
assert(any_int(x: 3.0, y: 4, z: 7) == false)"
HumanEval_93,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ထၢင်ႇဝႃႈပဵၼ် တူဝ်လိၵ်ႈၵူၺ်း။ // သဵင်ၼၵ်းၼႂ်း တူဝ်လိၵ်ႈဢင်းၵိတ်း။ // ၶေႃႈၵႂၢမ်းဢၼ်ပႃးတူဝ်လိၵ်ႈ ဢၼ်ဢွၵ်ႇမႃး 2 တီႈၼႃႈၼၼ်ႉ// လၢႆးမၼ်းၼႆႉ မၼ်းလႅၵ်ႈလၢႆႈ တူဝ်လိၵ်ႈၵူႈတူဝ်၊ သႂ်ႇတူဝ်လိၵ်ႈတူဝ်မႄႈလိၵ်ႈၵူႈတူဝ် ၼႂ်း // တႅမ်ႈပၼ် function ဢၼ်ဢဝ်ၶေႃႈၶၢဝ်ႇသေ သႂ်ႇဝႆႉၼႂ်း /// >>> encode(message: ""test"")
/// ""TGST""
/// >>> encode(message: ""This is a message"")
/// ""tHKS KS C MGSSCGG""
func encode(message: String) -> String {
","func encode(message: String) -> String {
    let vowels = ""aeiouAEIOU""
    let vowelReplacement = [
        ""a"": ""c"", ""e"": ""g"", ""i"": ""k"", ""o"": ""q"", ""u"": ""w"",
        ""A"": ""C"", ""E"": ""G"", ""I"": ""K"", ""O"": ""Q"", ""U"": ""W""
    ]
    
    var encodedMessage = """"
    
    for char in message {
        if vowels.contains(char) {
            if let replacement = vowelReplacement[String(char)] {
                encodedMessage.append(replacement)
            }
        } else {
            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())
            encodedMessage.append(swappedCase)
        }
    }
    
    return encodedMessage
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(encode(message: ""TEST"") == ""tgst"")
assert(encode(message: ""Mudasir"") == ""mWDCSKR"")
assert(encode(message: ""YES"") == ""ygs"")
assert(encode(message: ""This is a message"") == ""tHKS KS C MGSSCGG"")
assert(encode(message: ""I DoNt KnOw WhAt tO WrItE"") == ""k dQnT kNqW wHcT Tq wRkTg"")"
HumanEval_94,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// တေလႆႈႁႃ တူဝ်ၼပ်ႉ prime ဢၼ်ယႂ်ႇသေပိူၼ်ႈသေ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉတူဝ်ၼပ်ႉမၼ်းၼၼ်ႉၶိုၼ်း// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ်တင်းၼမ်။/// >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])
/// 7
func skjkasdkd(lst: [Int]) -> Int {
","func skjkasdkd(lst: [Int]) -> Int {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    var largestPrime: Int? = nil
    for number in lst {
        if isPrime(number) {
            if largestPrime == nil || number > largestPrime! {
                largestPrime = number
            }
        }
    }
    
    if let largestPrime = largestPrime {
        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)
    }
    
    return 0 // In case there are no prime numbers
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)
assert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)
assert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)
assert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)
assert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)
assert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)
assert(skjkasdkd(lst: [8191]) == 19)
assert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)
assert(skjkasdkd(lst: [127, 97, 8192]) == 10)"
HumanEval_96,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇမၼ်း: // တူဝ်ၼပ်ႉတဵမ် ဢၼ်ပဵၼ် တူဝ်ၼပ်ႉၸႅတ်ႈၸၢင်ႇ လႄႈ ဢေႇလိူဝ် n ၼၼ်ႉ။ // ႁဵတ်းသၢင်ႈၼႃႈၵၢၼ် ဢၼ်ဢဝ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉထွၼ်သေ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉ n ဢၼ်ဢွၼ်တၢင်းသုတ်းၼၼ်ႉမႃး/// >>> count_up_to(n: 5)
/// [2, 3]
/// >>> count_up_to(n: 11)
/// [2, 3, 5, 7]
/// >>> count_up_to(n: 0)
/// [] as [Int]
/// >>> count_up_to(n: 20)
/// [2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(n: 1)
/// [] as [Int]
/// >>> count_up_to(n: 18)
/// [2, 3, 5, 7, 11, 13, 17]
func count_up_to(n: Int) -> [Int] {
","func count_up_to(n: Int) -> [Int] {
    guard n > 2 else { return [] }
    
    var primes: [Int] = [2]
    
    for number in 3..<n {
        var isPrime = true
        for prime in primes {
            if prime * prime > number {
                break
            }
            if number % prime == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            primes.append(number)
        }
    }
    
    return primes
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_up_to(n: 5) == [2, 3])
assert(count_up_to(n: 6) == [2, 3, 5])
assert(count_up_to(n: 7) == [2, 3, 5])
assert(count_up_to(n: 10) == [2, 3, 5, 7])
assert(count_up_to(n: 0) == [] as [Int])
assert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])
assert(count_up_to(n: 1) == [] as [Int])
assert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])
assert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])
assert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"
HumanEval_97,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ထၢင်ႇဝႃႈ ၶေႃႈၶဝ်ႈၼႆႉ မၼ်းထုၵ်ႇမႅၼ်ႈယူႇတႃႇသေႇ။// တူဝ်ၵုၼ်း တူဝ်ၼပ်ႉဢၼ်ပဵၼ် ယူင်ႉၶွင်ၶဝ်ၼၼ်ႉယဝ်ႉ။// ယဝ်ႉတူဝ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ဢဝ် တူဝ်ၼပ်ႉတဵမ်သွင်တူဝ်သေ ၶိုၼ်းပၼ်မႃး /// >>> multiply(a: 148, b: 412)
/// 16
/// >>> multiply(a: 19, b: 28)
/// 72
/// >>> multiply(a: 2020, b: 1851)
/// 0
/// >>> multiply(a: 14, b: -15)
/// 20
func multiply(a: Int, b: Int) -> Int {
","func multiply(a: Int, b: Int) -> Int {
    let unitDigitA = abs(a % 10)
    let unitDigitB = abs(b % 10)
    return unitDigitA * unitDigitB
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(multiply(a: 148, b: 412) == 16)
assert(multiply(a: 19, b: 28) == 72)
assert(multiply(a: 2020, b: 1851) == 0)
assert(multiply(a: 14, b: -15) == 20)
assert(multiply(a: 76, b: 67) == 42)
assert(multiply(a: 17, b: 27) == 49)
assert(multiply(a: 0, b: 1) == 0)
assert(multiply(a: 0, b: 0) == 0)"
HumanEval_98,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ပေႃးဝႃႈပၼ် string s ၼႆၸိုင် ၵဵပ်းဢဝ် တူဝ်လိၵ်ႈတူဝ်မႄႈလိၵ်ႈတူဝ်ယႂ်ႇ ဢၼ်ပႃး တူဝ်ၼပ်ႉၸႅၼ်ႇတူဝ်ၼၼ်ႉသေ ၼပ်ႉတူၺ်း/// >>> count_upper(s: ""aBCdEf"")
/// 1
/// >>> count_upper(s: ""abcdefg"")
/// 0
/// >>> count_upper(s: ""dBBE"")
/// 0
func count_upper(s: String) -> Int {
","func count_upper(s: String) -> Int {
    let upperVowels = Set<Character>([""A"", ""E"", ""I"", ""O"", ""U""])
    var count = 0

    for (index, char) in s.enumerated() {
        if index % 2 == 0 && upperVowels.contains(char) {
            count += 1
        }
    }

    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_upper(s: ""aBCdEf"") == 1)
assert(count_upper(s: ""abcdefg"") == 0)
assert(count_upper(s: ""dBBE"") == 0)
assert(count_upper(s: ""B"") == 0)
assert(count_upper(s: ""U"") == 1)
assert(count_upper(s: """") == 0)
assert(count_upper(s: ""EEEE"") == 2)"
HumanEval_99,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // လုၵ်ႉတီႈ တူဝ်ၼပ်ႉတဵမ်သွင်တူဝ်ၼၼ်ႉသေ ဢဝ်မၼ်းၸုၵ်းၵႂႃႇတီႈ သုၼ်ၼၼ်ႉ။ // လႄႈ ၶိုၼ်းပၼ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်ၸမ်သုတ်းမၼ်း သင်ဝႃႈ တူဝ်ၼပ်ႉၼၼ်ႉ မီးတၢင်းၵႆၽဵင်ႇၵၼ်// ႁဵတ်းပၼ် function ဢၼ်ဢဝ် ၵႃႈၶၼ် (string) ဢၼ်တၢင်တူဝ် တူဝ်ၼပ်ႉ /// >>> closest_integer(value: ""10"")
/// 10
/// >>> closest_integer(value: ""15.3"")
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
func closest_integer(value: String) -> Int {
","func closest_integer(value: String) -> Int {
    if let number = Double(value) {
        return Int(number.rounded(.awayFromZero))
    }
    return 0 // or handle error as needed
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(closest_integer(value: ""10"") == 10)
assert(closest_integer(value: ""14.5"") == 15)
assert(closest_integer(value: ""-15.5"") == -16)
assert(closest_integer(value: ""15.3"") == 15)
assert(closest_integer(value: ""0"") == 0)"
HumanEval_100,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// i ၼႆႉပဵၼ် တူဝ်တႅၼ်း တူဝ်ၼပ်ႉႁိၼ် ဢၼ်မီးတီႈၸၼ်ႉ (i+1) ၼၼ်ႉယဝ်ႉ။// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉႁိၼ် တီႈၸၼ်ႉလႂ်ၸၼ်ႉၼၼ်ႉ ၶိုၼ်းမႃးပၼ် တီႈၼႂ်း array, တီႈဢၼ် element at index // - တူဝ်ၼပ်ႉၸႅၵ်ႈဢၼ်မႃးၸွမ်းလင် သင်ၸိူဝ်ႉဝႃႈ n ၼႆႉပဵၼ်ၸႅၵ်ႈၼႆယဝ်ႉ။ // - တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ဢၼ်မႃးၸွမ်းလင် သင်ၸိူဝ်ႉဝႃႈ n ၼႆႉပဵၼ်တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼႆယဝ်ႉ။ // သဵၼ်ႈမၢႆမၢၵ်ႇႁိၼ် တီႈၸၼ်ႉထၢၼ်ႈဢၼ်မႃးၼႆႉပဵၼ်: // သဵၼ်ႈတၢင်းဢွၼ်တၢင်းသုတ်းၼႆႉ မီးမၢၵ်ႇႁိၼ် n ။// ပေႃးဝႃႈႁဝ်းပၼ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်သၢင်ႇထုၵ်ႇ n ၼႆၸိုင် ႁဝ်းတေလႆႈႁဵတ်းႁုပ်ႈႁုင်မၢၵ်ႇႁိၼ် n ၸၼ်ႉ။/// >>> make_a_pile(n: 3)
/// [3, 5, 7]
func make_a_pile(n: Int) -> [Int] {
","func make_a_pile(n: Int) -> [Int] {
    var pile = [Int]()
    var currentLevelStones = n
    
    for _ in 0..<n {
        pile.append(currentLevelStones)
        if n % 2 == 0 {
            currentLevelStones += 2
        } else {
            currentLevelStones += 2
        }
    }
    
    return pile
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(make_a_pile(n: 3) == [3, 5, 7])
assert(make_a_pile(n: 4) == [4, 6, 8, 10])
assert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])
assert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])
assert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"
HumanEval_101,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// တႃႇၸႅၵ်ႇထႅဝ်လိၵ်ႈပဵၼ် ၶေႃႈၵႂၢမ်း လႄႈ ၶိုၼ်းဢဝ် ၶေႃႈၵႂၢမ်းဢၼ်ပဵၼ် ၶႅပ်းႁၢင်ႈၼၼ်ႉ ၶိုၼ်းမႃး။// သူတေလႆႈပၼ်ၶေႃႈၵႂၢမ်းဢၼ်ၸႅၵ်ႇဝႆႉလူၺ်ႈ ၶမ်း (comma) ဢမ်ႇၼၼ် သဵပ်ႇ (space) ၼၼ်ႉယူႇယဝ်ႉ။ ၼႃႈၵၢၼ်သူတေပဵၼ် /// >>> words_string(s: ""Hi, my name is John"")
/// [""Hi"", ""my"", ""name"", ""is"", ""John""]
/// >>> words_string(s: ""One, two, three, four, five, six"")
/// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
func words_string(s: String) -> [String] {
","func words_string(s: String) -> [String] {
    let separators = CharacterSet(charactersIn: "", "")
    return s.components(separatedBy: separators).filter { !$0.isEmpty }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_string(s: ""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""])
assert(words_string(s: ""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: ""Hi, my name"") == [""Hi"", ""my"", ""name""])
assert(words_string(s: ""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""])
assert(words_string(s: """") == [] as [String])
assert(words_string(s: ""ahmed     , gamal"") == [""ahmed"", ""gamal""])"
HumanEval_102,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ဢမ်ႇမီး တူဝ်ၼပ်ႉၸိူင်ႉၼၼ်၊ ပေႃးၼၼ် တူဝ်ဢိင်ၼႆႉ တေလႆႈၶိုၼ်းပၼ် - 1// တူဝ်ၼပ်ႉတဵမ်ဢၼ်ယႂ်ႇသေပိူၼ်ႈ ဢၼ်ပႃးၼႂ်းၵႄႈ [x, y] ပႃးၸဵမ်ၸိူဝ်းၼႆႉ သင်ဝႃႈ // Function ၼႆႉ ဢဝ်တူဝ်ၼပ်ႉသုတ်ႉ x လႄႈ y သွင်တူဝ်သေ ၶိုၼ်းပၼ်တူဝ်ၼပ်ႉ /// >>> choose_num(x: 12, y: 15)
/// 14
/// >>> choose_num(x: 13, y: 12)
/// -1
func choose_num(x: Int, y: Int) -> Int {
","func choose_num(x: Int, y: Int) -> Int {
    // Determine the starting and ending range values
    let start = min(x, y)
    let end = max(x, y)
    
    // Iterate from the end of the range to the start
    for num in (start...end).reversed() {
        // Check if the current number is even
        if num % 2 == 0 {
            return num
        }
    }
    
    // Return -1 if no even number is found
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(choose_num(x: 12, y: 15) == 14)
assert(choose_num(x: 13, y: 12) == -1)
assert(choose_num(x: 33, y: 12354) == 12354)
assert(choose_num(x: 5234, y: 5233) == -1)
assert(choose_num(x: 6, y: 29) == 28)
assert(choose_num(x: 27, y: 10) == -1)
assert(choose_num(x: 7, y: 7) == -1)
assert(choose_num(x: 546, y: 546) == 546)"
HumanEval_103,shn_Mymr,swift,"
extension Int: Error {}
        
// တူဝ်ယၢင်ႇ: // သင်ၸိူဝ်ႉဝႃႈ n ၼႆႉယႂ်ႇလိူဝ်သေ m ၼႆၸိုင် ၶိုၼ်းဢဝ် - 1 မႃးၶိုၼ်း// ဢဝ်ၶေႃႈတွပ်ႇၼၼ်ႉ ၶွပ်ႇဝၢႆႇၸူး တူဝ်ၼပ်ႉတဵမ် ဢၼ်ၸမ်သုတ်းသေ လႅၵ်ႈလၢႆႈပဵၼ် တူဝ်ၼပ်ႉသွင်တူဝ်။ // average of the integers from n တေႃႇထိုင် m (ပႃး n လႄႈ m) ။// ပၼ်တူဝ်ၼပ်ႉတဵမ် ဢၼ်သၢင်ႇထုၵ်ႇ n လႄႈ m သွင်တူဝ်လႄႈ ၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉပဵၼ်တႃႇၼပ်ႉသွၼ်ႇ တူဝ်ၼပ်ႉဢၼ်သၢင်ႇထုၵ်ႇ /// >>> rounded_avg(n: 1, m: 5)
/// .success(""0b11"")
/// >>> rounded_avg(n: 7, m: 5)
/// .failure(-1)
/// >>> rounded_avg(n: 10, m: 20)
/// .success(""0b1111"")
/// >>> rounded_avg(n: 20, m: 33)
/// .success(""0b11010"")
func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
","func rounded_avg(n: Int, m: Int) -> Result<String, Int> {
    if n > m {
        return .failure(-1)
    }
    
    let count = m - n + 1
    let sum = (n + m) * count / 2
    let average = Double(sum) / Double(count)
    let roundedAverage = Int(average.rounded())
    let binaryString = String(roundedAverage, radix: 2)
    
    return .success(""0b"" + binaryString)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(rounded_avg(n: 1, m: 5) == .success(""0b11""))
assert(rounded_avg(n: 7, m: 13) == .success(""0b1010""))
assert(rounded_avg(n: 964, m: 977) == .success(""0b1111001010""))
assert(rounded_avg(n: 996, m: 997) == .success(""0b1111100100""))
assert(rounded_avg(n: 560, m: 851) == .success(""0b1011000010""))
assert(rounded_avg(n: 185, m: 546) == .success(""0b101101110""))
assert(rounded_avg(n: 362, m: 496) == .success(""0b110101101""))
assert(rounded_avg(n: 350, m: 902) == .success(""0b1001110010""))
assert(rounded_avg(n: 197, m: 233) == .success(""0b11010111""))
assert(rounded_avg(n: 7, m: 5) == .failure(-1))
assert(rounded_avg(n: 5, m: 1) == .failure(-1))
assert(rounded_avg(n: 5, m: 5) == .success(""0b101""))"
HumanEval_104,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// မၢႆတွင်း: တူဝ်ၼပ်ႉဢၼ်ၶိုၼ်းမႃးၼၼ်ႉ ထုၵ်ႇလီၸႅၵ်ႇဝႆႉၸွမ်းၼင်ႇ လွင်ႈတိူဝ်းၼမ်မႃးၼၼ်ႉယဝ်ႉ။// elements ဢၼ်ဢမ်ႇမီး တူဝ်ၼပ်ႉဢၼ်ပဵၼ်ၸဵင်ႇၵၼ်။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ်တူဝ်မႄႈလိၵ်ႈ ဢၼ်တဵမ်ထူၼ်ႈ x ၼၼ်ႉသေ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉတဵမ်တူဝ်မႄႈလိၵ်ႈ ဢၼ်ၸႅၵ်ႇဝႆႉၼၼ်ႉ ၶိုၼ်းဢဝ်မႃးၶိုၼ်း/// >>> unique_digits(x: [15, 33, 1422, 1])
/// [1, 15, 33]
/// >>> unique_digits(x: [152, 323, 1422, 10])
/// [] as [Int]
func unique_digits(x: [Int]) -> [Int] {
","func unique_digits(x: [Int]) -> [Int] {
    return x.filter { number in
        var hasEvenDigit = false
        var num = number
        while num > 0 {
            if (num % 10) % 2 == 0 {
                hasEvenDigit = true
                break
            }
            num /= 10
        }
        return !hasEvenDigit
    }.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])
assert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])
assert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])
assert(unique_digits(x: [135, 103, 31]) == [31, 135])"
HumanEval_105,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ""ၼိုင်ႈ"" ""သွင်"" ""သၢမ်"" ""သီႇ"" ""ႁႃႈ"" ""ႁူၵ်း"" ""ၸဵတ်း"" ""ဢဵတ်း"" ""ႁူၵ်း"" ""ႁူၵ်း""// ၶိုၼ်းပိၼ်ႇဝၢႆႇၶိုၼ်း တူဝ်ၼပ်ႉဢၼ်ဢွၵ်ႇမႃးၼၼ်ႉသေ ၶိုၼ်းဢဝ်တူဝ်ၼပ်ႉဢၼ်လႂ်ဢၼ်ၼၼ်ႉ လႅၵ်ႈလၢႆႈပဵၼ် ၸိုဝ်ႈဢၼ်ၵွင်ႉၵၢႆႇၵၼ်တင်း // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် array ဢၼ်ၼိူင်ႈ၊ ၸႅၵ်ႇၽႄ တူဝ်ၼပ်ႉတဵမ် ဢၼ်မီးၼႂ်းၵႄႈ 1 လႄႈ 9 ပႃးၸဵမ်၊ /// >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])
/// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
/// If the array is empty, return an empty array:
/// >>> by_length(arr: [] as [Int])
/// [] as [String]
/// If the array has any strange number ignore it:
/// >>> by_length(arr: [1, -1, 55])
/// [""One""]
func by_length(arr: [Int]) -> [String] {
","func by_length(arr: [Int]) -> [String] {
    let numberNames: [Int: String] = [
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine""
    ]
    
    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }
                                           .sorted(by: >)
    
    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? """" }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""])
assert(by_length(arr: [] as [Int]) == [] as [String])
assert(by_length(arr: [1, -1, 55]) == [""One""])
assert(by_length(arr: [1, -1, 3, 2]) == [""Three"", ""Two"", ""One""])
assert(by_length(arr: [9, 4, 8]) == [""Nine"", ""Eight"", ""Four""])"
HumanEval_106,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // တူဝ်ၼပ်ႉဢၼ်ပဵၼ်တူဝ်ၼပ်ႉဢၼ်တဵမ်ထူၼ်ႈၶွင် i ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်တဵမ်ထူၼ်ႈၶွင် တူဝ်ၼပ်ႉဢၼ်လုၵ်ႉတီႈ 1 တေႃႇထိုင် i (1 * 2 * ... * i) ၼၼ်ႉယဝ်ႉ။// i တႄႇတီႈ 1. // ဢမ်ႇၼၼ် တူဝ်ၼပ်ႉဢၼ်တဵမ် 1 တေႃႇထိုင် i ပေႃးဢမ်ႇၼၼ်။ // လႄႈ ၶိုၼ်းဢဝ် array တၢင်းယႂ်ႇ n ၼၼ်ႉမႃး၊ မိူၼ်ၼင်ႇဝႃႈ ၵႃႈၶၼ်ၶွင် တူဝ်ဢိင်ဢၼ်မီးတီႈ index i ၼၼ်ႉ ပဵၼ် factorial ၶွင် i သင်ဝႃႈ i ၼႆႉပဵၼ် တူဝ်ၸႅၵ်ႈၼႆယဝ်ႉ။// ႁဵတ်းသၢင်ႈၼႃႈၵၢၼ် f ဢၼ်ဢဝ် n ပဵၼ်တူဝ်ၼပ်ႉဢၼ်တႅၵ်ႈ၊ /// >>> f(n: 5)
/// [1, 2, 6, 24, 15]
func f(n: Int) -> [Int] {
","func f(n: Int) -> [Int] {
    func factorial(_ x: Int) -> Int {
        guard x > 1 else { return 1 }
        return (1...x).reduce(1, *)
    }
    
    func sumTo(_ x: Int) -> Int {
        return (1...x).reduce(0, +)
    }
    
    var result = [Int]()
    for i in 1...n {
        if i % 2 == 0 {
            result.append(factorial(i))
        } else {
            result.append(sumTo(i))
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(f(n: 5) == [1, 2, 6, 24, 15])
assert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])
assert(f(n: 1) == [1])
assert(f(n: 3) == [1, 2, 6])"
HumanEval_107,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ 1: // တူဝ်ၼပ်ႉတဵမ် palindromes ဢၼ်ၶဝ်ႈပႃးၼႂ်း တၢင်းၵႂၢင်ႈပဵင်း ((1, n) ။// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်သၢင်ႇထုၵ်ႇ n ၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်မီး တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၸိူင်း လႄႈ တူဝ်ဢၼ်ဢမ်ႇပဵၼ် တူဝ်ၸိူင်းၼၼ်ႉမႃး/// >>> even_odd_palindrome(n: 3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(n: 12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
func even_odd_palindrome(n: Int) -> (Int, Int) {
","func even_odd_palindrome(n: Int) -> (Int, Int) {
    func isPalindrome(_ num: Int) -> Bool {
        let str = String(num)
        return str == String(str.reversed())
    }
    
    var evenCount = 0
    var oddCount = 0
    
    for i in 1...n {
        if isPalindrome(i) {
            if i % 2 == 0 {
                evenCount += 1
            } else {
                oddCount += 1
            }
        }
    }
    
    return (evenCount, oddCount)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_palindrome(n: 123) == (8, 13))
assert(even_odd_palindrome(n: 12) == (4, 6))
assert(even_odd_palindrome(n: 3) == (1, 2))
assert(even_odd_palindrome(n: 63) == (6, 8))
assert(even_odd_palindrome(n: 25) == (5, 6))
assert(even_odd_palindrome(n: 19) == (4, 6))
assert(even_odd_palindrome(n: 9) == (4, 5))
assert(even_odd_palindrome(n: 1) == (0, 1))"
HumanEval_108,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း -123 ၼႆႉ မီးတူဝ်ၼပ်ႉ -1, 2, လႄႈ 3 ယဝ်ႉ။// သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈပဵၼ် တူဝ်ထွၼ်ၼႆ တူဝ်ၼပ်ႉဢၼ်မီးမၢႆမီႈဢွၼ်တၢင်းသုတ်းမၼ်းတေပဵၼ် တူဝ်ထွၼ်: // တူဝ်ၼပ်ႉဢၼ်မီး တူဝ်ၼပ်ႉဢၼ်ႁူမ်ႈၵၼ်ဝႆႉၼၼ်ႉ မီးၼမ်လိူဝ် 0 ယဝ်ႉ။// တႅမ်ႈပၼ် တူဝ်ၼပ်ႉၼပ်ႉတဵမ် count_nums ဢၼ်ဢဝ် တူဝ်ၼပ်ႉတဵမ်သေ ၶိုၼ်းပၼ်မႃး /// >>> count_nums(arr: [] as [Int])
/// 0
/// >>> count_nums(arr: [-1, 11, -11])
/// 1
/// >>> count_nums(arr: [1, 1, 2])
/// 3
func count_nums(arr: [Int]) -> Int {
","func count_nums(arr: [Int]) -> Int {
    return arr.filter { number in
        var n = number
        var sumOfDigits = 0

        while n != 0 {
            sumOfDigits += n % 10
            n /= 10
        }

        return sumOfDigits > 0
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(count_nums(arr: [] as [Int]) == 0)
assert(count_nums(arr: [-1, -2, 0]) == 0)
assert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)
assert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)
assert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)
assert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)
assert(count_nums(arr: [0, 1]) == 1)
assert(count_nums(arr: [1]) == 1)"
HumanEval_109,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// မၢႆတွင်း: မေႃႇထႅဝ်ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ မၼ်းတေမီးဝႆႉ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉယဝ်ႉ။// သင်ဝႃႈ array ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပဵၼ်ဢၼ်ဢမ်ႇမီးၼၼ်ႉ ၶိုၼ်းဢဝ် true မႃး။// ပေႃးၼၼ် ၶိုၼ်းဢဝ် true ဢမ်ႇၼၼ် ၶိုၼ်းဢဝ် false။ // သင်ဝႃႈမၼ်းပဵၼ်လႆႈ တႃႇတေလႆႈ လွင်ႈၸႅၵ်ႇမဵဝ်းဢၼ်ၸႅၵ်ႇဝႆႉ လူၺ်ႈႁဵတ်းသၢင်ႈ တၢင်းၼိူဝ်ၼၼ်ႉၼႆ // တီႈတႄႇမၼ်း ၼႂ်း array ဢၼ်ဝႃႈၼၼ်ႉပဵၼ် 0th index။ လွင်ႈတတ်းမၵ်း တူဝ်ၼပ်ႉဢၼ်သုတ်းၶွင် array ၼၼ်ႉ တေၶၢႆႉၵႂႃႇၸူး // လွင်ႈႁဵတ်းသၢင်ႈဢၼ်ၼိုင်ႈဢၼ်ၶၢႆႉၵႂႃႇၽၢႆႇၶႂႃၼႆႉ ပွင်ႇဝႃႈ ၶၢႆႉတူဝ်ၼပ်ႉတင်းမူတ်းၶွင် array လူၺ်ႈဢၼ်ၼိုင်ႈ// သူတေလႆႈႁဵတ်းၵၢၼ် shift တၢင်းၶႂႃလႆႈလၢႆၵမ်းယူႇ// လွင်ႈႁဵတ်းသၢင်ႈဢၼ်ပၼ်ဝႆႉၼိူဝ် array ၼၼ်ႉ: // မၼ်းတေပဵၼ်လႆႈတႃႇတေလႆႈ လွင်ႈၸႅၵ်ႇမဵဝ်းဢၼ်ဢမ်ႇယွမ်းလူင်း လူၺ်ႈႁဵတ်းသၢင်ႈ တူဝ်ၼပ်ႉၼႂ်း array တေထုၵ်ႇၸႅၵ်ႇဝႆႉၸွမ်းလွင်ႈဢမ်ႇပဵၼ်။ ၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉ ပဵၼ်တႃႇတေတႅပ်းတတ်းဝႃႈ // ႁဝ်းမီး array 'arr' ၶွင်တူဝ်ၼပ်ႉတဵမ် N ဢၼ် arr[1], arr[2], ..., arr[N]။ /// >>> move_one_ball(arr: [3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given array.
/// >>> move_one_ball(arr: [3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// array by performing any number of right shift operations.
func move_one_ball(arr: [Int]) -> Bool {
","func move_one_ball(arr: [Int]) -> Bool {
    guard !arr.isEmpty else { return true }
    
    let n = arr.count
    var breakPointCount = 0
    
    // Find the number of break points where the array is decreasing
    for i in 0..<n {
        if arr[i] > arr[(i + 1) % n] {
            breakPointCount += 1
        }
    }
    
    // If there's at most one break point, the array can be right shifted
    return breakPointCount <= 1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)
assert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)
assert(move_one_ball(arr: [4, 3, 1, 2]) == false)
assert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)
assert(move_one_ball(arr: [] as [Int]) == true)"
HumanEval_110,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ပေႃးဢမ်ႇၼၼ် ၶိုၼ်းပၼ် ""NO""// တူဝ်ၼပ်ႉ lst1 တင်းမူတ်းၼႆႉ ပဵၼ်တူဝ်ၼပ်ႉဢၼ်ၽဵင်ႇပဵင်းၵၼ်၊ ၶိုၼ်းပၼ် ""YES""// သင်ဝႃႈမၼ်းပဵၼ်လႆႈ တႃႇလႅၵ်ႈလၢႆႈ elements ၼႂ်းၵႄႈ lst1 လႄႈ lst2 တႃႇႁဵတ်း // ဢမ်ႇမီးလွင်ႈမၵ်းမၼ်ႈၼိူဝ် တူဝ်ၼပ်ႉၶွင် ဢၼ်လႅၵ်ႈလၢႆႈၵၼ်ၼ်ႂးၵႄႈ lst1 လႄႈ lst2 ၼၼ်ႉ။// ၵႄႈၶဝ် ႁႂ်ႈပဵၼ် lst1 ဢၼ်ပဵၼ် array ဢၼ်ပႃး တူဝ်ၼပ်ႉၸႅၵ်ႈၵူၺ်း// လႄႈ တႅပ်းတတ်းဝႃႈ မၼ်းပဵၼ်လႆႈတႃႇတေႁဵတ်း လွင်ႈလႅၵ်ႈလၢႆႈၶွင် ၶူဝ်းၶွင် // ၼႂ်းပုစ္ဆာၼႆႉ ၸဝ်ႈၵဝ်ႇတေႁဵတ်းသၢင်ႈပၼ် တူဝ်ဢိင်ဢၼ်ဢဝ် တူဝ်ၼပ်ႉ 2 တူဝ်ၼပ်ႉ၊/// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])
/// ""YES""
/// >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])
/// ""NO""
/// It is assumed that the input arrays will be non-empty.
func exchange(lst1: [Int], lst2: [Int]) -> String {
","func exchange(lst1: [Int], lst2: [Int]) -> String {
    var hasOddInLst1 = false
    var hasEvenInLst2 = false
    
    for num in lst1 {
        if num % 2 != 0 {
            hasOddInLst1 = true
            break
        }
    }
    
    for num in lst2 {
        if num % 2 == 0 {
            hasEvenInLst2 = true
            break
        }
    }
    
    if !hasOddInLst1 {
        return ""YES""
    }
    
    if hasEvenInLst2 {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == ""YES"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == ""NO"")
assert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == ""YES"")
assert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == ""NO"")
assert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == ""NO"")
assert(exchange(lst1: [100, 200], lst2: [200, 200]) == ""YES"")"
HumanEval_111,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // သင်ဝႃႈ တူဝ်လိၵ်ႈ လၢႆတူဝ်မီးလွင်ႈပဵၼ်မိူၼ်ၵၼ်ၼႆ ၶိုၼ်းဢဝ်တင်းမူတ်းၶိုၼ်း// တူဝ်လိၵ်ႈဢၼ်မီးလွင်ႈၽိုၼ်မိူၼ်ၼမ်သေပိူၼ်ႈလႄႈ ဢၼ်ပႃးဝႆႉ တူဝ်ၼပ်ႉဢၼ်ၵွင်ႉၵၢႆႇၵၼ်ၼၼ်ႉယဝ်ႉ။// ပေႃးဝႃႈလႆႈပၼ် string ဢၼ်တႅၼ်းတၢင် တူဝ်လိၵ်ႈလဵၵ်ႉလဵၵ်ႉ ဢၼ်ၽႄဝႆႉႁင်းမၼ်း၊ ၶိုၼ်းဢဝ် ပွင်ႈၵႂၢမ်းဢၼ်ၼိုင်ႈမႃးၶိုၼ်း/// >>> histogram(test: ""a b c"")
/// [""a"" : 1, ""b"" : 1, ""c"" : 1]
/// >>> histogram(test: ""a b b a"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""a b c a b"")
/// [""a"" : 2, ""b"" : 2]
/// >>> histogram(test: ""b b b b a"")
/// [""b"" : 4]
/// >>> histogram(test: """")
/// [:] as [String : Int]
func histogram(test: String) -> [String : Int] {
","func histogram(test: String) -> [String : Int] {
    var letterCount: [String: Int] = [:]

    // Split the string into an array of letters
    let letters = test.split(separator: "" "").map { String($0) }

    // Count occurrences of each letter
    for letter in letters {
        letterCount[letter, default: 0] += 1
    }

    // Determine the maximum number of occurrences
    guard let maxCount = letterCount.values.max() else {
        return [:] as [String : Int]
    }

    // Filter the letterCount dictionary to only include letters with the max count
    let result = letterCount.filter { $0.value == maxCount }

    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(histogram(test: ""a b b a"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c a b"") == [""a"" : 2, ""b"" : 2])
assert(histogram(test: ""a b c d g"") == [""a"" : 1, ""b"" : 1, ""c"" : 1, ""d"" : 1, ""g"" : 1])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: ""b b b b a"") == [""b"" : 4])
assert(histogram(test: ""r t g"") == [""r"" : 1, ""t"" : 1, ""g"" : 1])
assert(histogram(test: """") == [:] as [String : Int])
assert(histogram(test: ""a"") == [""a"" : 1])"
HumanEval_112,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // တေလႆႈၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်ပႃး တူဝ်ၼပ်ႉသဵၼ်ႈ ဢၼ်လႆႈမႃး လႄႈ true/false တွၼ်ႈတႃႇ လွင်ႈထတ်းသၢင်ႈ။ // သတၢႆႇဢၼ်ၼိူင်ႈၼႆႉ ႁွင်ႉဝႃႈ palindrome သင်ဝႃႈ မၼ်းလႆႈလူဢၢၼ်ႇၵႂႃႇၽၢႆႇလင်မိူၼ်ၵၼ်တင်း ၽၢႆႇၼႃႈၼၼ်ႉယဝ်ႉ။// ယဝ်ႉၵေႃႈ တူၺ်းဝႃႈ တူဝ်ၵိုတ်းမၼ်းပဵၼ် palindrome ႁိုဝ်းၼႆ။ // ႁဝ်းလႆႈပၼ် သွင်တူဝ်ထႅဝ် s လႄႈ c ႁဝ်းတေလႆႈမွတ်ႇပႅတ်ႈ တူဝ်လိၵ်ႈတင်းသဵင်ႈ ၼႂ်း s ဢၼ်ၽဵင်ႇပဵင်းၵၼ်တင်း တူဝ်လိၵ်ႈၼႂ်း cၼႃႈၵၢၼ်/// >>> reverse_delete(s: ""abcde"", c: ""ae"")
/// (""bcd"", false)
/// >>> reverse_delete(s: ""abcdef"", c: ""b"")
/// (""acdef"", false)
/// >>> reverse_delete(s: ""abcdedcba"", c: ""ab"")
/// (""cdedc"", true)
func reverse_delete(s: String, c: String) -> (String, Bool) {
","func reverse_delete(s: String, c: String) -> (String, Bool) {
    // Remove characters from s that are in c
    let filteredString = s.filter { !c.contains($0) }
    
    // Check if the resulting string is a palindrome
    let isPalindrome = filteredString == String(filteredString.reversed())
    
    // Return the resulting string and the palindrome check result
    return (filteredString, isPalindrome)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(reverse_delete(s: ""abcde"", c: ""ae"") == (""bcd"", false))
assert(reverse_delete(s: ""abcdef"", c: ""b"") == (""acdef"", false))
assert(reverse_delete(s: ""abcdedcba"", c: ""ab"") == (""cdedc"", true))
assert(reverse_delete(s: ""dwik"", c: ""w"") == (""dik"", false))
assert(reverse_delete(s: ""a"", c: ""a"") == ("""", true))
assert(reverse_delete(s: ""abcdedcba"", c: """") == (""abcdedcba"", true))
assert(reverse_delete(s: ""abcdedcba"", c: ""v"") == (""abcdedcba"", true))
assert(reverse_delete(s: ""vabba"", c: ""v"") == (""abba"", true))
assert(reverse_delete(s: ""mamma"", c: ""mia"") == ("""", true))"
HumanEval_113,shn_Mymr,swift,"
// တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် တီႈၼႂ်း i'th string ၶွင်ၶေႃႈၶဝ်ႈ// string i ၶွင် input ၼၼ်ႉ"" တီႈဢၼ် i တင်းသဵင်ႈၼၼ်ႉ ထုၵ်ႇလီဢဝ် တူဝ်ၼပ်ႉ  ၼၼ်ႉ သႂ်ႇပၼ်// တူဝ်ထႅဝ်ဢၼ်လႂ်ဢၼ် i ၶွင် output ၼၼ်ႉ တေလႆႈပဵၼ် "" တူဝ်ၼပ်ႉ တူဝ်ထႅဝ်ဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ၼႂ်း // ပေႃးဝႃႈႁဝ်းပၼ်ဝႆႉ string array ဢၼ် string မၼ်းမီးတူဝ်ၼပ်ႉၵူၺ်းၼႆ ႁဝ်းတေၶိုၼ်းပၼ် array array ဢၼ်ၼိူင်ႈ/// >>> odd_count(lst: [""1234567""])
/// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
/// >>> odd_count(lst: [""3"", ""11111111""])
/// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
func odd_count(lst: [String]) -> [String] {
","func odd_count(lst: [String]) -> [String] {
    return lst.map { str in
        let oddCount = str.filter { ""13579"".contains($0) }.count
        return ""the number of odd elements \(oddCount)n the str\(oddCount)ng \(oddCount) of the \(oddCount)nput.""
    }
}

// Example Usage
print(odd_count(lst: [""1234567""]))
print(odd_count(lst: [""3"", ""11111111""]))","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(odd_count(lst: [""1234567""]) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""])
assert(odd_count(lst: [""3"", ""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""])
assert(odd_count(lst: [""271"", ""137"", ""314""]) == [""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""])"
HumanEval_114,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီးတူဝ်ၼပ်ႉ။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် nums ဢၼ်ၼိူင်ႈ၊ သွၵ်ႈႁႃ တူဝ်ၼပ်ႉဢၼ်ဢေႇသုတ်း ၶွင် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇပဵၼ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီးတူဝ်ၼပ်ႉၼၼ်ႉ။/// >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(nums: [-1, -2, -3])
/// -6
func minSubArraySum(nums: [Int]) -> Int {
","func minSubArraySum(nums: [Int]) -> Int {
    guard !nums.isEmpty else { return 0 }
    
    var currentMin = nums[0]
    var overallMin = nums[0]
    
    for i in 1..<nums.count {
        currentMin = min(nums[i], currentMin + nums[i])
        overallMin = min(overallMin, currentMin)
    }
    
    return overallMin
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)
assert(minSubArraySum(nums: [-1, -2, -3]) == -6)
assert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)
assert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)
assert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)
assert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)
assert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)
assert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)
assert(minSubArraySum(nums: [-10]) == -10)
assert(minSubArraySum(nums: [7]) == 7)
assert(minSubArraySum(nums: [1, -1]) == -1)"
HumanEval_115,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ 1: // ဢွၵ်ႇမႃး တူဝ်ၼပ်ႉဢၼ်လူဝ်ႇ တႃႇတေဢဝ် buckets ၼၼ်ႉ// ၼႃႈၵၢၼ်သူၼႆႉ ပဵၼ်တႃႇၸႂ်ႉ buckets တႃႇၽုတ်းဢွၵ်ႇၼမ်ႉႁူး။// လႄႈ ၵူႊဢၼ်ၼႆႉ မီးၼမ်ႉၵတ်ႉဢၼ်လဵဝ်ၵၼ်ယဝ်ႉ။// ၼမ်ႉတွင်းၵူႈဢၼ်ၼႆႉ မီးဝႆႉ ၵွၵ်းဢၼ်ၵဵဝ်ႇၵၼ် ဢၼ်ၸႂ်ႉတိုဝ်းတႃႇဢဝ်ၼမ်ႉဢွၵ်ႇ၊ // လႄႈ 1 ၵူႈဢၼ်ဢၼ်ၼႆႉ ပဵၼ်တူဝ်တႅၼ်းၶွင် ၼမ်ႉဢၼ်လဵဝ်ၵူၺ်း။// လႆႈပၼ်ဝႆႉ ႁူးၼမ်ႉဢၼ်မီးသီႇၸဵင်ႇႁွင်ႇ။ သဵၼ်ႈၼိုင်ႈဢၼ်ၼႆႉ ၼႄႁူးၼမ်ႉဢၼ်လဵဝ်၊ /// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)
/// 6
/// Example 2:
/// >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)
/// 5
/// Example 3:
/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
func max_fill(grid: [[Int]], capacity: Int) -> Int {
","func max_fill(grid: [[Int]], capacity: Int) -> Int {
    var totalWater = 0
    for row in grid {
        for unit in row {
            if unit == 1 {
                totalWater += 1
            }
        }
    }
    return (totalWater + capacity - 1) / capacity
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)
assert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)
assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)
assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
HumanEval_116,shn_Mymr,swift,"
// မၼ်းတေလႆႈႁဵတ်းသၢင်ႈၵႂႃႇမိူၼ်ၼင်ႇၼႆ: // တွၼ်ႈတႃႇ တူဝ်ၼပ်ႉဢၼ်မိူၼ်ၵၼ်ၶွင် တူဝ်ၼပ်ႉ 1 ၼၼ်ႉ၊ ၸႅၵ်ႇၽႄၸွမ်း ၵႃႈၶၼ်တူဝ်ၼပ်ႉႁူဝ်သိပ်းၼၼ်ႉယဝ်ႉ။// တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်တႅၼ်းတူဝ်ၼပ်ႉသွင် ဢၼ်တိူဝ်းၶိုၼ်ႈမႃးၼၼ်ႉယဝ်ႉ။// ၼႂ်း Kata ၼႆႉ ႁဝ်းတေလႆႈၸႅၵ်ႇဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ထွၼ် ၸွမ်းၼင်ႇ /// >>> sort_array(arr: [1, 5, 2, 3, 4])
/// [1, 2, 3, 4, 5]
/// >>> sort_array(arr: [-2, -3, -4, -5, -6])
/// [-6, -5, -4, -3, -2]
/// >>> sort_array(arr: [1, 0, 2, 3, 4])
/// [0, 1, 2, 3, 4]
func sort_array(arr: [Int]) -> [Int] {
","func sort_array(arr: [Int]) -> [Int] {
    return arr.sorted {
        let onesCount1 = $0.nonNegativeOnesCount()
        let onesCount2 = $1.nonNegativeOnesCount()
        return (onesCount1, $0) < (onesCount2, $1)
    }
}

extension Int {
    func nonNegativeOnesCount() -> Int {
        return self < 0 ? 0 : self.nonBitCount()
    }
    
    private func nonBitCount() -> Int {
        var count = 0
        var num = self
        while num > 0 {
            count += num & 1
            num >>= 1
        }
        return count
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])
assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])
assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])
assert(sort_array(arr: [] as [Int]) == [] as [Int])
assert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])
assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])
assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
HumanEval_117,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// မၢႆတွင်း: သူတေၸၢင်ႈဝူၼ်ႉဝႃႈ သဵၼ်ႈမၢႆၶေႃႈမုၼ်းဢၼ်ၶဝ်ႈဝႆႉၼၼ်ႉ ပႃးတူဝ်လိၵ်ႈလႄႈ လွင်ႈပဵင်းၵၼ်ၵူၺ်း။// သင်ဝႃႈ သတၢႆႇ s ၼႆႉ လပ်ႉဝႆႉၼႆ ၽွၼ်ႉၸေႃႇၵျီႇၼႆႉ တေလႆႈၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီး တူဝ်ၼပ်ႉၼၼ်ႉယူႇယဝ်ႉ။// သဵင်ၼၵ်း n တူဝ်၊ ပေႃးဢဝ်ပိူင်ထၢၼ်ႈမၼ်းဝႃႈ တေဢွၵ်ႇမႃးတီႈ သရ string s ၼၼ်ႉ။ // တူဝ်ဢိင်ဢၼ်ၼိူင်ႈ ဢၼ်ၶိုၼ်းပၼ်မႃး တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ ဢၼ်ပႃးဝႆႉ ၶေႃႈၵႂၢမ်းတင်းသဵင်ႈ တီႈၼႂ်း သဵၼ်ႈမၢႆ s ဢၼ်ပႃးဝႆႉ ၶေႃႈၵႂၢမ်းဢၼ်ၼိူင်ႈၼၼ်ႉ // ပၼ်ဝႆႉ string s လႄႈ တူဝ်ၼပ်ႉသၽႃႇဝ n ၼၼ်ႉယဝ်ႉ၊ သူထုၵ်ႇလႆႈပၼ်ပုၼ်ႈၽွၼ်း တႃႇတေႁဵတ်းသၢင်ႈ /// >>> select_words(s: ""Mary had a little lamb"", n: 4)
/// [""little""]
/// >>> select_words(s: ""Mary had a little lamb"", n: 3)
/// [""Mary"", ""lamb""]
/// >>> select_words(s: ""simple white space"", n: 2)
/// [] as [String]
/// >>> select_words(s: ""Hello world"", n: 4)
/// [""world""]
/// >>> select_words(s: ""Uncle sam"", n: 3)
/// [""Uncle""]
func select_words(s: String, n: Int) -> [String] {
","func select_words(s: String, n: Int) -> [String] {
    let vowels: Set<Character> = [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]
    let words = s.split(separator: "" "")
    var result: [String] = []
    
    for word in words {
        let consonantCount = word.filter { !vowels.contains($0) }.count
        if consonantCount == n {
            result.append(String(word))
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(select_words(s: ""Mary had a little lamb"", n: 4) == [""little""])
assert(select_words(s: ""Mary had a little lamb"", n: 3) == [""Mary"", ""lamb""])
assert(select_words(s: ""simple white space"", n: 2) == [] as [String])
assert(select_words(s: ""Hello world"", n: 4) == [""world""])
assert(select_words(s: ""Uncle sam"", n: 3) == [""Uncle""])
assert(select_words(s: """", n: 4) == [] as [String])
assert(select_words(s: ""a b c d e f"", n: 1) == [""b"", ""c"", ""d"", ""f""])"
HumanEval_118,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // သူတေၸၢင်ႈထၢင်ႇဝႃႈ သဵၼ်ႈမၢႆဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပႃးတူဝ်လိၵ်ႈ ဢင်းၵိတ်ႉၵူၺ်း။ // ႁႃတူဝ်မႄႈသဵင် ဢၼ်လႆႈထုၵ်ႇမႅၼ်ႈၸွမ်း ၶေႃႈမၵ်းမၼ်ႈတၢင်းၼိူဝ်။ // တူဝ်ၸီႉဢၼ်မီးတီႈတႄႇလႄႈ တီႈသုတ်းၼၼ်ႉ ဢမ်ႇၼပ်ႉသွၼ်ႇ သင်ဢမ်ႇၼပ်ႉသွၼ်ႇၼႆ ၶိုၼ်းဢဝ် string ဢၼ်ဢမ်ႇမီးတူဝ်ၼၼ်ႉ လၢႆႈပၼ်// သွင်တူဝ်လိၵ်ႈ သဵင်မိူၼ်တူၼ်ႈထႅဝ်ပႅၵ်ႇ ဢၼ်လုၵ်ႉတီႈၽၢႆႇၶႂႃ ၶေႃႈၵႂၢမ်း ( case sensitive) ၼၼ်ႉမႃး။// သူတေလႆႈပၼ်ၶေႃႈၵႂၢမ်းဢၼ်ၼိုင်ႈ။ ၼႃႈၵၢၼ်သူတေလႆႈႁႃ တူဝ်ၸီႉဢၼ်ၸမ်သုတ်း ဢၼ်ယူႇၼႂ်းၵႄႈ /// >>> get_closest_vowel(word: ""yogurt"")
/// ""u""
/// >>> get_closest_vowel(word: ""FULL"")
/// ""U""
/// >>> get_closest_vowel(word: ""quick"")
/// """"
/// >>> get_closest_vowel(word: ""ab"")
/// """"
func get_closest_vowel(word: String) -> String {
","func get_closest_vowel(word: String) -> String {
    let vowels = Set(""aeiouAEIOU"")
    var foundVowel: Character? = nil
    
    for i in stride(from: word.count - 2, through: 1, by: -1) {
        let currentIndex = word.index(word.startIndex, offsetBy: i)
        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)
        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)
        
        if vowels.contains(word[currentIndex]) && 
            !vowels.contains(word[previousIndex]) && 
            !vowels.contains(word[nextIndex]) {
            foundVowel = word[currentIndex]
            break
        }
    }
    
    return foundVowel != nil ? String(foundVowel!) : """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_closest_vowel(word: ""yogurt"") == ""u"")
assert(get_closest_vowel(word: ""full"") == ""u"")
assert(get_closest_vowel(word: ""easy"") == """")
assert(get_closest_vowel(word: ""eAsy"") == """")
assert(get_closest_vowel(word: ""ali"") == """")
assert(get_closest_vowel(word: ""bad"") == ""a"")
assert(get_closest_vowel(word: ""most"") == ""o"")
assert(get_closest_vowel(word: ""ab"") == """")
assert(get_closest_vowel(word: ""ba"") == """")
assert(get_closest_vowel(word: ""quick"") == """")
assert(get_closest_vowel(word: ""anime"") == ""i"")
assert(get_closest_vowel(word: ""Asia"") == """")
assert(get_closest_vowel(word: ""Above"") == ""o"")"
HumanEval_119,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ၶိုၼ်းပၼ် 'Yes' သင်ဝႃႈမီးလၢႆးႁဵတ်း သ်ႂႇဢၼ်လီ လႄႈ ၶိုၼ်းပၼ် 'No' သင်ဢမ်ႇၼၼ်။ // '()) ' ၼႆႉဢမ်ႇၸႂ်ႈ။တူဝ်ယၢင်ႇမၼ်း မိူၼ်ၼင်ႇ string '(())))' ၼႆႉ လီဝႆႉ၊ string  ၼႆႉသမ်ႉ လီဝႆႉ၊ string  ၼႆႉတႄႉ လီဝႆႉ၊ string  ၼႆႉတႄႉ လီဝႆႉ၊ string  ၼႆႉတႄႉ လီဝႆႉ၊ string  ၼႆႉတႄႉ လီဝႆႉ၊ string  ၼႆႉတႄႉ လီဝႆႉ၊ string  ၼႆႉတႄႉ လီဝႆႉ၊// သဵၼ်ႈသၢႆ S ၼႆႉ ပေႃးဝႃႈ မၼ်းပဵၼ်ဢၼ်လီၼႆၸိုင် သင်ဝႃႈ သဵၼ်ႈသၢႆ S  ၼႆႉ မီးဝႆႉ တူဝ်ၸုၵ်းၸွမ်တင်းမူတ်းၼႆၸိုင်// မၢင်ဢၼ်ၵေႃႈတေလႆႈပဵၼ်ဝႆႉ၊ ပေႃးၼၼ် တူဝ်လိၵ်ႈဢၼ်ဢွၵ်ႇမႃးၼၼ်ႉ တေပဵၼ်ဢၼ်လီယူႇယဝ်ႉ။// ၼႃႈၵၢၼ်သူၼႆႉတေႉတေႉဝႃႈဝႃႈဝႃႈ မၼ်းပဵၼ်လႆႈတႃႇတေၵွင်ႉၵၢႆႇ သွင်သဵၼ်ႈသၢႆဢၼ်မီးၼႂ်း // ႁၢင်ႈႁိင်ႈ ""("" ဢမ်ႇၼၼ် ႁၢင်ႈႁိင်ႈဢၼ်ၸမ်ႁိမ်းႁွမ်း ') 'ၵူၺ်း။// လႆႈပၼ်ဝႆႉ သႅၼ်းၶွင် သွင်ဢၼ်၊ သႅၼ်းတင်းသွင်ဢၼ်ၼႆႉ ပဵၼ် open /// >>> match_parens(lst: [""()("", "")""])
/// ""Yes""
/// >>> match_parens(lst: ["")"", "")""])
/// ""No""
func match_parens(lst: [String]) -> String {
","func match_parens(lst: [String]) -> String {
    let combined1 = lst[0] + lst[1]
    let combined2 = lst[1] + lst[0]
    
    func isBalanced(_ s: String) -> Bool {
        var balance = 0
        for char in s {
            if char == ""("" {
                balance += 1
            } else if char == "")"" {
                balance -= 1
            }
            if balance < 0 {
                return false
            }
        }
        return balance == 0
    }
    
    if isBalanced(combined1) || isBalanced(combined2) {
        return ""Yes""
    } else {
        return ""No""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(match_parens(lst: [""()("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", "")""]) == ""No"")
assert(match_parens(lst: [""(()(())"", ""())())""]) == ""No"")
assert(match_parens(lst: ["")())"", ""(()()(""]) == ""Yes"")
assert(match_parens(lst: [""(())))"", ""(()())((""]) == ""Yes"")
assert(match_parens(lst: [""()"", ""())""]) == ""No"")
assert(match_parens(lst: [""(()("", ""()))()""]) == ""Yes"")
assert(match_parens(lst: [""(((("", ""((())""]) == ""No"")
assert(match_parens(lst: ["")(()"", ""(()(""]) == ""No"")
assert(match_parens(lst: ["")("", "")(""]) == ""No"")
assert(match_parens(lst: [""("", "")""]) == ""Yes"")
assert(match_parens(lst: ["")"", ""(""]) == ""Yes"")"
HumanEval_120,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ 1: // တၢင်းယၢဝ်း k ဢၼ်ပႃး တူဝ်ၼပ်ႉ k ဢၼ်ၼမ်သုတ်း ၼႂ်း arr။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် array လႄႈ တူဝ်ၼပ်ႉတဵမ် k ဢၼ်သၢင်ႇထုၵ်ႇၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉတဵမ်ဢၼ်ၸႅၵ်ႇဝႆႉၼၼ်ႉၶိုၼ်း /// >>> maximum(arr: [-3, -4, 5], k: 3)
/// [-4, -3, 5]
/// Example 2:
/// >>> maximum(arr: [4, -4, 4], k: 2)
/// [4, 4]
/// Example 3:
/// >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)
/// [2]
/// Note:
/// 1. The length of the array will be in the range of [1, 1000].
/// 2. The elements in the array will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
func maximum(arr: [Int], k: Int) -> [Int] {
","func maximum(arr: [Int], k: Int) -> [Int] {
    guard k > 0 else { return [] }
    let sortedArr = arr.sorted(by: >)
    let maxElements = Array(sortedArr.prefix(k))
    return maxElements.sorted()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])
assert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])
assert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])
assert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])
assert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])
assert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])
assert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])
assert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])
assert(maximum(arr: [4, -4], k: 2) == [-4, 4])
assert(maximum(arr: [-10, 10], k: 2) == [-10, 10])
assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
HumanEval_121,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမီးတီႈသုတ်းၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ဢၼ်မီးတီႈယူႇၽဵင်ႇပဵင်းၼၼ်ႉ ၶိုၼ်းမႃးပၼ်။ /// >>> solution(lst: [5, 8, 7, 1])
/// 12
/// >>> solution(lst: [3, 3, 3, 3, 3])
/// 9
/// >>> solution(lst: [30, 13, 24, 321])
/// 0
func solution(lst: [Int]) -> Int {
","func solution(lst: [Int]) -> Int {
    var sum = 0
    for (index, value) in lst.enumerated() {
        if index % 2 == 0 && value % 2 != 0 {
            sum += value
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solution(lst: [5, 8, 7, 1]) == 12)
assert(solution(lst: [3, 3, 3, 3, 3]) == 9)
assert(solution(lst: [30, 13, 24, 321]) == 0)
assert(solution(lst: [5, 9]) == 5)
assert(solution(lst: [2, 4, 8]) == 0)
assert(solution(lst: [30, 13, 23, 32]) == 23)
assert(solution(lst: [3, 13, 2, 9]) == 3)"
HumanEval_122,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // တူဝ်ၼပ်ႉဢၼ်မီးတူဝ်ၼပ်ႉသွင်တူဝ် တီႈသုတ်း ဢၼ်လုၵ်ႉတီႈ တူဝ်ၼပ်ႉ k ဢၼ်ဢွၼ်တၢင်းသုတ်းၶွင် arr ၼၼ်ႉမႃးၼၼ်ႉယဝ်ႉ။// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ်ဢၼ်ဢမ်ႇၸႂ်ႈတူဝ်ဢၼ်ဢမ်ႇမီးတူဝ်ၼၼ်ႉလႄႈ တူဝ်ၼပ်ႉတဵမ် k, ၶိုၼ်းဢဝ် /// >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
func add_elements(arr: [Int], k: Int) -> Int {
","func add_elements(arr: [Int], k: Int) -> Int {
    var sum = 0
    for i in 0..<k {
        if arr[i] >= -99 && arr[i] <= 99 {
            sum += arr[i]
        }
    }
    return sum
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)
assert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)
assert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)
assert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)
assert(add_elements(arr: [1], k: 1) == 1)"
HumanEval_123,shn_Mymr,swift,"
// get_odd_collatz(5) ၶိုၼ်းပၼ် [1, 5] # လွင်ႈၶပ်ႉၸႅၼ်ႇ collatz တွၼ်ႈတႃႇ 5 ၼႆႉပဵၼ် [5, 16, 8, 4, 2, 1], ၵွပ်ႈၼၼ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉပဵၼ် 1 လႄႈ 5 ၵူၺ်းယဝ်ႉ။ တူဝ်ယၢင်ႇမၼ်း-// 2. ၶိုၼ်းဢဝ် array ဢၼ်ၸႅၵ်ႇဝႆႉၸွမ်း လွင်ႈတိူဝ်းၼမ်မႃးၼၼ်ႉ။ // 1. Collatz(1) ၼႆႉပဵၼ် [1]. // မၢႆတွင်း: // ထႅမ်းပလဵၵ်ႉ ဢၼ်ထႅမ်သႂ်ႇ 1. လွင်ႈလၢမ်းၶၢတ်ႈမၼ်းတႄႉ ပဵၼ်ဝႃႈ ဢမ်ႇဝႃႈ ၵႃႈၶၼ်ၶွင် n ၼႆႉပဵၼ်ၵႃႈႁိုဝ်ၵေႃႈယဝ်ႉ လွင်ႈၶပ်ႉၸႅၼ်ႇမၼ်းတေႁွတ်ႈထိုင် 1 တႃႇသေႇယဝ်ႉ။// ထႅမ်းပလဵၵ်ႉဢၼ်ပူၼ်ႉမႃးၼၼ်ႉ သင်ဝႃႈ ထႅမ်းပလဵၵ်ႉဢၼ်ပူၼ်ႉမႃးၼၼ်ႉ ပဵၼ်ဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼႆ ထႅမ်းပလဵၵ်ႉဢၼ်မႃးထႅင်ႈၼၼ်ႉ ပဵၼ် 3 ပွၵ်ႈထႅမ်းပလဵၵ်ႉဢၼ်ပူၼ်ႉမႃးၼၼ်ႉ// ထႅမ်းပလဵၵ်ႉဢၼ်ပူၼ်ႉမႃး မိူၼ်ၼင်ႇတႂ်ႈၼႆႉ ပေႃးထႅမ်းပလဵၵ်ႉဢၼ်ပူၼ်ႉမႃးၼၼ်ႉ ပဵၼ်ဢၼ်ၽဵင်ႇပဵင်းၼႆ ထႅမ်းပလဵၵ်ႉဢၼ်မႃးၸွမ်းၼၼ်ႉ ပဵၼ်ၶိုင်ႈၼိူင်ႈ ၶွင် // မိူၼ်ၼင်ႇတႂ်ႈၼႆႉ တႄႇဢဝ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်မၼ်ႈသေဢၼ်ဢၼ် n ယဝ်ႉၵေႃႈ ထႅမ်းပလဵၵ်ႉၵူႈဢၼ်ၼႆႉ လႆႈမႃးတီႈ // လွင်ႈလၢမ်းၶၢတ်ႈ Collatz ၼႆႉ ပဵၼ်လွင်ႈလၢမ်းၶၢတ်ႈ ၼႂ်းပၢႆးၼပ်ႉ ဢၼ်ၵဵဝ်ႇလူၺ်ႈ လွင်ႈမၵ်းမၼ်ႈဝႆႉ လွင်ႈၶပ်ႉၶိုင်ဝႆႉၼၼ်ႉယူႇယဝ်ႉ။// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်တဵမ်ထူၼ်ႈ n ၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ဢၼ်မီးတီႈၼႂ်း လွင်ႈၶပ်ႉၸႅၼ်ႇ collatz ၼၼ်ႉသေ ၶိုၼ်းဢဝ်မႃး။/// >>> get_odd_collatz(n: 5)
/// [1, 5]
func get_odd_collatz(n: Int) -> [Int] {
","func get_odd_collatz(n: Int) -> [Int] {
    var collatzSequence: [Int] = []
    var number = n

    while number != 1 {
        if number % 2 != 0 {
            collatzSequence.append(number)
        }
        if number % 2 == 0 {
            number /= 2
        } else {
            number = 3 * number + 1
        }
    }

    collatzSequence.append(1) // append 1 as the sequence ends at 1

    let sortedOdds = collatzSequence.sorted()
    
    return sortedOdds
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])
assert(get_odd_collatz(n: 5) == [1, 5])
assert(get_odd_collatz(n: 12) == [1, 3, 5])
assert(get_odd_collatz(n: 1) == [1])"
HumanEval_124,shn_Mymr,swift,"
ဝၼ်းတေႇပဵၼ်ၼႂ်းပိူင်ၾၢင်: mm-dd-yyyy လိူၼ်ဢၼ်ဢမ်ႇထုၵ်ႇလီပဵၼ်ဢေႇလိူဝ် 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 12ဝၼ်းဢၼ်ဢမ်ႇယွမ်း 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 31 ဝၼ်း တွၼ်ႈတႃႇလိူၼ် 1,3,5,7,8,10,12 လႄႈ ဝၼ်းဢၼ်ဢမ်ႇယွမ်း 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 30 ဝၼ်း တွၼ်ႈတႃႇလိူၼ် 4,6,9,11 လႄႈ ဝၼ်းဢၼ်ဢမ်ႇယွမ်း 1 ဢမ်ႇၼၼ် ၼမ်လိူဝ် 29 တွၼ်ႈတႃႇလိူၼ် 2။// 1. သဵၼ်ႈမၢႆဝၼ်းထီႉၼႆႉ ဢမ်ႇလႆႈဢိုတ်းဝႆႉ။ // ဝၼ်းၼၼ်ႉ မၢၼ်ႇမႅၼ်ႈယူႇ သင်ဝႃႈ ပၵ်းပိူင်ဢၼ်ၸွမ်းမႃးတင်းသဵင်ႈၼႆႉ လႆႈထုၵ်ႇၸွမ်းၸွမ်းယူႇၼႆ: // သင်ဝႃႈ ဝၼ်းမၼ်းမၢၼ်ႇမႅၼ်ႈၼႆ ၶိုၼ်းဢဝ် true မႃးၶိုၼ်း ပေႃးဢမ်ႇၼၼ် false။ // တေလႆႈတႅမ်ႈ function ဢၼ်တေမၵ်းမၼ်ႈပၼ်ဝႆႉ ဝၼ်းထီႉ လႄႈ /// >>> valid_date(date: ""03-11-2000"")
/// true
/// >>> valid_date(date: ""15-01-2012"")
/// false
/// >>> valid_date(date: ""04-0-2040"")
/// false
/// >>> valid_date(date: ""06-04-2020"")
/// true
/// >>> valid_date(date: ""06/04/2020"")
/// false
func valid_date(date: String) -> Bool {
","func valid_date(date: String) -> Bool {
    // Check if the date is empty
    if date.isEmpty {
        return false
    }
    
    // Split the date into components using the ""-"" delimiter
    let components = date.split(separator: ""-"")
    
    // Ensure the date has exactly three components
    if components.count != 3 {
        return false
    }
    
    // Ensure the date components are integers
    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {
        return false
    }
    
    // Check if the month is within the valid range
    if month < 1 || month > 12 {
        return false
    }
    
    // Define the number of days in each month
    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    // Check the day range for each month
    if day < 1 || day > daysInMonth[month] {
        return false
    }
    
    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(valid_date(date: ""03-11-2000"") == true)
assert(valid_date(date: ""15-01-2012"") == false)
assert(valid_date(date: ""04-0-2040"") == false)
assert(valid_date(date: ""06-04-2020"") == true)
assert(valid_date(date: ""01-01-2007"") == true)
assert(valid_date(date: ""03-32-2011"") == false)
assert(valid_date(date: """") == false)
assert(valid_date(date: ""04-31-3000"") == false)
assert(valid_date(date: ""06-06-2005"") == true)
assert(valid_date(date: ""21-31-2000"") == false)
assert(valid_date(date: ""04-12-2003"") == true)
assert(valid_date(date: ""04122003"") == false)
assert(valid_date(date: ""20030412"") == false)
assert(valid_date(date: ""2003-04"") == false)
assert(valid_date(date: ""2003-04-12"") == false)
assert(valid_date(date: ""04-2003"") == false)"
HumanEval_125,shn_Mymr,swift,"
extension Int: Error {}
        
// တူဝ်ယၢင်ႇ // တူဝ်လိၵ်ႈ၊ ord (a) = 0, ord (b) = 1, ... ord (z) = 25 // တေလႆႈၸႅၵ်ႇဝႆႉပဵၼ် ၶမ်း ',' သင်ဢမ်ႇမီး ၶမ်းၼႆ တေလႆႈၶိုၼ်းပၼ် တူဝ်လိၵ်ႈတူဝ်လဵၵ်ႉ ဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ၼႂ်းတူဝ်လိၵ်ႈ // ပေႃးဝႃႈႁဝ်းလႆႈပၼ်ၶေႃႈၵႂၢမ်းတင်းၼမ်ၼႆ သင်ဝႃႈဢမ်ႇမီးၶေႃႈၵႂၢမ်းဢၼ်ပႃးဝႆႉတီႈၼႂ်းလိၵ်ႈၼႆ ၶိုၼ်းဢဝ်ၶေႃႈၵႂၢမ်းဢၼ်ပႃးဝႆႉတီႈၼႂ်း ၶႅပ်းႁၢင်ႈသေ ၸႅၵ်ႇပၼ်ၶိုၼ်း/// >>> split_words(txt: ""Hello world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""Hello,world!"")
/// .success([""Hello"", ""world!""])
/// >>> split_words(txt: ""abcdef"")
/// .failure(3)
func split_words(txt: String) -> Result<[String], Int> {
","func split_words(txt: String) -> Result<[String], Int> {
    if txt.contains("" "") {
        let words = txt.split(separator: "" "").map { String($0) }
        return .success(words)
    } else if txt.contains("","") {
        let words = txt.split(separator: "","").map { String($0) }
        return .success(words)
    } else {
        let oddOrderedLowerCaseLetters = txt.filter { char in
            if let asciiValue = char.asciiValue {
                let order = asciiValue - Character(""a"").asciiValue!
                return order % 2 == 1
            }
            return false
        }
        return .failure(oddOrderedLowerCaseLetters.count)
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(split_words(txt: ""Hello world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello,world!"") == .success([""Hello"", ""world!""]))
assert(split_words(txt: ""Hello world,!"") == .success([""Hello"", ""world,!""]))
assert(split_words(txt: ""Hello,Hello,world !"") == .success([""Hello,Hello,world"", ""!""]))
assert(split_words(txt: ""abcdef"") == .failure(3))
assert(split_words(txt: ""aaabb"") == .failure(2))
assert(split_words(txt: ""aaaBb"") == .failure(1))
assert(split_words(txt: """") == .failure(0))"
HumanEval_126,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // တူဝ်ၼပ်ႉ၊ ၶိုၼ်းမိူဝ်း false. မၵ်းမၼ်ႈဝႃႈ ဢမ်ႇမီး တူဝ်ၼပ်ႉထွၼ် လႄႈ တူဝ်ၼပ်ႉတဵမ်ၵူၺ်း။ပေႃးဝႃႈ array မီးၼမ်လိူဝ် 1 ဢၼ်ၼႆၸိုင်// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ၊ ၶိုၼ်းဢဝ်မႃးၶိုၼ်းဝႃႈ ၶဝ်ၸႅၵ်ႇဝႆႉႁိုဝ် ဢမ်ႇၸႅၵ်ႇဝႆႉႁိုဝ်ၼႆယဝ်ႉ။/// >>> is_sorted(lst: [5])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])
/// false
func is_sorted(lst: [Int]) -> Bool {
","func is_sorted(lst: [Int]) -> Bool {
    guard !lst.isEmpty else { return true }

    var previous = lst[0]
    var duplicates = 0

    for i in 1..<lst.count {
        if lst[i] < previous {
            return false
        } else if lst[i] == previous {
            duplicates += 1
            if duplicates > 1 {
                return false
            }
        } else {
            duplicates = 0
        }
        previous = lst[i]
    }

    return true
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_sorted(lst: [5]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)
assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)
assert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)
assert(is_sorted(lst: [] as [Int]) == true)
assert(is_sorted(lst: [1]) == true)
assert(is_sorted(lst: [3, 2, 1]) == false)
assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)
assert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)
assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
HumanEval_127,shn_Mymr,swift,"
// [input/output] samples:  ၸၢမ်းတူၺ်းတူၺ်း တူဝ်ယၢင်ႇ ဢၼ်ဢွၵ်ႇမႃး// သင်ဝႃႈ သွင်ဢၼ်ၼႆႉ ဢမ်ႇၶွပ်ႇၵၼ်ၼႆ ၶိုၼ်းပၼ် ""NO""// ပေႃးဢမ်ႇၼၼ် ၶိုၼ်းပၼ် ""NO""// သင်ဝႃႈ တၢင်းယၢဝ်းၶွင် လွင်ႈၶွပ်ႇၵၼ်ၼၼ်ႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်လမ်ႇလွင်ႈၼႆ ၶိုၼ်းဢဝ် ""YES"" ၼၼ်ႉၶိုၼ်း၊// ဢၼ်တၢင်းယၢဝ်းမၼ်းပဵၼ် 1 ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉၶမ်ႇပိုၼ်ႉ။ တူဝ်ယၢင်ႇမၼ်း လွင်ႈၸတ်းတွၼ်ႈၶွင် ၶၢဝ်းယၢမ်း (1,3) ၊ (2,4) ၼႆႉပဵၼ် (2,3)// intervals ၼႆႉပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈယဝ်ႉ။// ၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉ ပဵၼ်တႃႇတေတႅပ်းတတ်းဝႃႈ တၢင်းယၢဝ်းဢၼ်ၶွပ်ႇၵၼ်သွင်ဢၼ်ၼႆႉ // တွၼ်ႈတႃႇ ၶၢဝ်းယၢမ်းဢၼ်ပၼ်ဝႆႉဢၼ်လႂ်သေဢမ်ႇဝႃႈ မၼ်းထုၵ်ႇလီဝူၼ်ႉဝႃႈ လွင်ႈတႄႇမၼ်းၼႆႉ လဵၵ်ႉလိူဝ် ဢမ်ႇၼၼ် မိူၼ်ၵၼ်တၢင်းသုတ်းမၼ်းၼႆယဝ်ႉ။// ပႃးဝႆႉ လွင်ႈတႄႇလႄႈ လွင်ႈသုတ်း။ // ၶၢဝ်းယၢမ်းဢၼ်ပၼ်ဝႆႉၼၼ်ႉ လႆႈဢိုတ်းဝႆႉသေ ပွင်ႇဝႃႈ ၶၢဝ်းယၢမ်း (တႄႇ၊ သုတ်း) တီႈဢၼ် ၶၢဝ်းယၢမ်းဢၼ်လႂ်ဢၼ်ၼၼ်ႉ ပဵၼ်တူဝ်ၼပ်ႉတဵမ်ဢၼ်ၼိူင်ႈဢၼ်ၼၼ်ႉယဝ်ႉ။ တူဝ်ယၢင်ႇမၼ်း ၶၢဝ်းယၢမ်း = (တႄႇ၊ သုတ်း) = (1, 2)// လႆႈပၼ်ဝႆႉ သွင်ဢၼ်၊ /// >>> intersection(interval1: (1, 2), interval2: (2, 3))
/// ""NO""
/// >>> intersection(interval1: (-1, 1), interval2: (0, 4))
/// ""NO""
/// >>> intersection(interval1: (-3, -1), interval2: (-5, 5))
/// ""YES""
func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
","func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {
    // Helper function to determine if a number is prime
    func isPrime(_ num: Int) -> Bool {
        if num <= 1 {
            return false
        }
        if num <= 3 {
            return true
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false
        }
        var i = 5
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    // Find the start and end of the intersection
    let intersectStart = max(interval1.0, interval2.0)
    let intersectEnd = min(interval1.1, interval2.1)
    
    // Calculate the length of the intersection
    let intersectionLength = intersectEnd - intersectStart

    // Check if intersection length is positive and prime
    if intersectionLength > 0 && isPrime(intersectionLength) {
        return ""YES""
    } else {
        return ""NO""
    }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(intersection(interval1: (1, 2), interval2: (2, 3)) == ""NO"")
assert(intersection(interval1: (-1, 1), interval2: (0, 4)) == ""NO"")
assert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == ""YES"")
assert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == ""YES"")
assert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (3, 5)) == ""NO"")
assert(intersection(interval1: (1, 2), interval2: (1, 2)) == ""NO"")
assert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == ""NO"")"
HumanEval_128,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // မၢႆတွင်း: ၶိုၼ်းဢဝ် nil တွၼ်ႈတႃႇ empty arr. // တူဝ်ၼပ်ႉၵူႈဢၼ် ၼႂ်း array ဢၼ်တႅၼ်းတၢင်ပဵၼ် 1, -1 ဢမ်ႇၼၼ် 0 // တူဝ်ၼပ်ႉတဵမ် ဢၼ်ၵုၼ်းၵၼ်တင်း တူဝ်ၼပ်ႉဢၼ်ႁဵတ်းဢွၵ်ႇမႃးတီႈ တူဝ်ယၢင်ႇတင်းမူတ်းၼၼ်ႉ// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ်ဢၼ်ပဵၼ် array ယဝ်ႉၵေႃႈ တေလႆႈၶိုၼ်းပၼ် /// >>> prod_signs(arr: [1, 2, 2, -4])
/// 9
/// >>> prod_signs(arr: [0, 1])
/// 0
/// >>> prod_signs(arr: [] as [Int])
/// nil
func prod_signs(arr: [Int]) -> Int? {
","func prod_signs(arr: [Int]) -> Int? {
    // Return nil for empty array
    if arr.isEmpty {
        return nil
    }

    // Calculate the sum of magnitudes
    let sumOfMagnitudes = arr.reduce(0) { sum, num in
        return sum + abs(num)
    }

    // Calculate the product of all signs
    let productOfSigns = arr.reduce(1) { product, num in
        if num > 0 {
            return product * 1
        } else if num < 0 {
            return product * -1
        } else {
            return 0
        }
    }

    // Return the result of sum of magnitudes multiplied by product of signs
    return sumOfMagnitudes * productOfSigns
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(prod_signs(arr: [1, 2, 2, -4]) == -9)
assert(prod_signs(arr: [0, 1]) == 0)
assert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)
assert(prod_signs(arr: [] as [Int]) == nil)
assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)
assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)
assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)
assert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
HumanEval_129,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ၶပ်ႉဝႆႉတီႈၼိူဝ် သႄး (လ်) ဢၼ်သဵၼ်ႈတၢင်းဢၼ်ဢေႇသုတ်းမၼ်း လတ်းမႃးၼၼ်ႉသေ ၶိုၼ်းပၼ်။ // မၼ်းတေလႆႈႁပ်ႉႁွင်းဝႃႈ ၶေႃႈတွပ်ႇမၼ်းတေဢမ်ႇမိူၼ်ၵၼ်။// lst_A[j] = lst_B[j]။// ၼင်ႇႁိုဝ် lst_A[i] < lst_B[i] လႄႈ တွၼ်ႈတႃႇ j (1 <= j < i) သေဢၼ်ဢၼ်ၼၼ်ႉ ႁဝ်းမီး // လိူဝ်သေ lst_B၊ ပေႃးဢဝ်ၶေႃႈၵႂၢမ်းတၢင်ႇဢၼ်ဝႃႈ မၼ်းမီးဝႆႉ တူဝ်ၼပ်ႉတဵမ်ဢၼ်ပဵၼ် index i (1 <= i <= k) // (ႁဝ်းႁွင်ႉၶဝ်ဝႃႈ lst_A လႄႈ lst_B) ၊ lst_A ၼႆႉ ပဵၼ်ၶေႃႈၵႂၢမ်းဢၼ်ဢေႇလိူဝ်ပိူၼ်ႈ။// ဝၢႆးသေႁဵတ်းဝႆႉ လွင်ႈၸႅၼ်ႇထႅဝ်ဢၼ်မီးပိူင်ဝႆႉ ၶွင်ၵႃႈၶၼ်ၼိူဝ် သႄး (လ်) ဢၼ် A လႄႈ B ၵႂႃႇၼၼ်ႉယဝ်ႉ// သဵၼ်ႈတၢင်း A (တၢင်းယၢဝ်း k) ၼႆႉ ပေႃးဝႃႈ // သူဢမ်ႇၸၢင်ႈဢွၵ်ႇၵႂႃႇတီႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈၵႂၢင်ႈ// ဢမ်ႇလူဝ်ႇပႅၵ်ႇပိူင်ႈၵၼ်) ။// ၶႅၼ်းတေႃႈမၢႆတွင်းဝႃႈ သဵၼ်ႈတၢင်းတၢင်းဢၼ်ယၢဝ်း k ၼၼ်ႉ ပွင်ႇဝႃႈ လႅၵ်ႈလၢႆႈတီႈ သႄးလ် k (ဢမ်ႇၸႂ်ႈ // သႄး (လ်) ꧦ// ပေႃးလၢတ်ႈထႅင်ႈလၢႆးၼိုင်ႈ၊ သူတေၵႂႃႇတီႈ သႄး (လ်) ဢၼ်ၽႄၶွပ်ႇဢၼ်လဵဝ်ၵၼ်တင်း သူၼၼ်ႉယူႇ// လုၵ်ႉတီႈ သႄးလ်လႂ်သေဢမ်ႇဝႃႈ၊ လႄႈ တီႈသႄးလ်ဢၼ်လႂ်သေဢမ်ႇဝႃႈၼႆႉ ၸဝ်ႈၵဝ်ႇ ၸၢင်ႈၶၢႆႉၵႂႃႇၸူး သႄးလ်ဢၼ်မီးႁိမ်းႁွမ်းၼၼ်ႉသေဢမ်ႇဝႃႈ၊// တေလႆႈႁႃ သဵၼ်ႈတၢင်းဢၼ်လဵၵ်ႉသုတ်း ဢၼ်မီးတၢင်းယၢဝ်း k ၼႂ်းၵရဵၵ်ႉၼၼ်ႉ။// inclusive ၼႆႉ တေဢွၵ်ႇမႃးၵမ်းလဵဝ် တီႈၼႂ်းၶွပ်ႇၶွင် grid ၼၼ်ႉ။ // သႄး (လ်) ၵူႈဢၼ် ၼႂ်းၵွင်ႉၼၼ်ႉ မၼ်းမီးဝႆႉ ၵႃႈၶၼ် ဢၼ်ၼိူင်ႈ ဢၼ်ၼိူင်ႈ ဢၼ်ၼိူင်ႈ ၼႂ်းၵႄႈ [1, N * N]// ပၼ်ဝႆႉ grid ဢၼ်ၼိူင်ႈဢၼ်မီး ထႅဝ် N လႄႈ ၵူဝ်ႇလမ်ႇ N (N >= 2) လႄႈ တူဝ်ၼပ်ႉတဵမ် k ဢၼ်တဵမ်ထူၼ်ႈ၊ /// >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)
/// [1, 2, 1]
/// >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)
/// [1]
func minPath(grid: [[Int]], k: Int) -> [Int] {
","func minPath(grid: [[Int]], k: Int) -> [Int] {
    let n = grid.count
    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    struct Path: Comparable {
        let cells: [Int]
        
        static func < (lhs: Path, rhs: Path) -> Bool {
            return lhs.cells.lexicographicallyPrecedes(rhs.cells)
        }
    }
    
    var minPath: Path? = nil
    
    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {
        var currentPath = currentPath
        currentPath.append(grid[x][y])
        
        if currentPath.count == k {
            let newPath = Path(cells: currentPath)
            if minPath == nil || newPath < minPath! {
                minPath = newPath
            }
            return
        }
        
        for direction in directions {
            let newX = x + direction.0
            let newY = y + direction.1
            if newX >= 0 && newX < n && newY >= 0 && newY < n {
                dfs(x: newX, y: newY, k: k, currentPath: currentPath)
            }
        }
    }
    
    for i in 0..<n {
        for j in 0..<n {
            dfs(x: i, y: j, k: k, currentPath: [])
        }
    }
    
    return minPath!.cells
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])
assert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])
assert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])
assert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])
assert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])
assert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])
assert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])
assert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])
assert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])
assert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])
assert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"
HumanEval_130,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// တူဝ်ၼပ်ႉ n + 1 ဢၼ်ဢွၼ်တၢင်းသုတ်း ၶွင် ထရီႇပေႃးၼႅၵ်ႉၶီႇ (Tribonacci) ။ // သင်ဝႃႈႁဝ်းလႆႈပၼ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉၶိုၵ်ႉ n ၼႆ ႁဝ်းတေလႆႈၶိုၼ်းပၼ် array ၶွင် တူဝ်ၼပ်ႉ // = 2 + 3 + 3 = 8 // သၢမ်သၢမ်သၢမ် (3) = သၢမ်သၢမ်သၢမ် (2) + သၢမ်သၢမ်သၢမ် (1) + သၢမ်သၢမ်သၢမ် (4)// tri(4) = 3 // tri(2) = 1 + (2 / 2) = 2 တူဝ်ယၢင်ႇမၼ်း-// tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) သင်ၸိူဝ်ႉဝႃႈ n ၼႆႉပဵၼ်တူဝ်ၼိူင်ႈၼႆယဝ်ႉ။// tri (n) = 1 + n / 2 သင်ၸိူဝ်ႉဝႃႈ n ၼႆႉပဵၼ်တူဝ်ၸႅၵ်ႈၼႆယဝ်ႉ။// tri(1) = 3 // လွင်ႈၸႅၵ်ႇၽႄၸႆႉႁေႇ Tribonacci ၼႆႉ မၵ်းမၼ်ႈလူၺ်ႈ လွင်ႈၶိုၼ်းပဵၼ်မႃး: ၵူၺ်းၵႃႈ ဢၼ်ၵူၼ်းႁဝ်းဢမ်ႇႁူႉၼၼ်ႉတႄႉ ပဵၼ်လွင်ႈၸႅၵ်ႇမႅင်ႇ Tribonacci sequence ၼၼ်ႉယဝ်ႉ။ၵူၼ်းၵူႈၵေႃႉႁူႉၸၵ်း Fibonacci sequence မၼ်းလႆႈထုၵ်ႇလဵပ်ႈႁဵၼ်းဝႆႉႁၢဝ်ႈႁႅင်း လူၺ်ႈ mathematicians ၼႂ်း /// >>> tri(n: 3)
/// [1, 3, 2, 8]
func tri(n: Int) -> [Int] {
","func tri(n: Int) -> [Int] {
    guard n >= 0 else { return [] }
    if n == 0 { return [1] }
    if n == 1 { return [1, 3] }
    if n == 2 { return [1, 3, 2] }
    
    var sequence = [1, 3, 2]
    
    for i in 3...n {
        if i % 2 == 0 {
            sequence.append(1 + i / 2)
        } else {
            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]
            sequence.append(nextVal)
        }
    }
    
    return sequence
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(tri(n: 3) == [1, 3, 2, 8])
assert(tri(n: 4) == [1, 3, 2, 8, 3])
assert(tri(n: 5) == [1, 3, 2, 8, 3, 15])
assert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])
assert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])
assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])
assert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])
assert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])
assert(tri(n: 0) == [1])
assert(tri(n: 1) == [1, 3])"
HumanEval_131,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ၶိုၼ်းပၼ် 0 သင်ဝႃႈ တူဝ်ၼပ်ႉတင်းမူတ်းပဵၼ်တူဝ်ၸႅၵ်ႇၵၼ်ၼႆ။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်သၢင်ႇထုၵ်ႇ n ၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉ ပၼ်ႇၵၼ်ၶိုၼ်း။/// >>> digits(n: 1)
/// 1
/// >>> digits(n: 4)
/// 0
/// >>> digits(n: 235)
/// 15
func digits(n: Int) -> Int {
","func digits(n: Int) -> Int {
    var num = n
    var product = 1
    var hasOdd = false
    
    while num > 0 {
        let digit = num % 10
        if digit % 2 != 0 {
            hasOdd = true
            product *= digit
        }
        num /= 10
    }
    
    return hasOdd ? product : 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(digits(n: 5) == 5)
assert(digits(n: 54) == 5)
assert(digits(n: 120) == 1)
assert(digits(n: 5014) == 5)
assert(digits(n: 98765) == 315)
assert(digits(n: 5576543) == 2625)
assert(digits(n: 2468) == 0)"
HumanEval_132,shn_Mymr,swift,"
// တီႈဢေႇသုတ်းမၼ်း သဵၼ်ႈမၢႆဢၼ်ၼိုင်ႈ ၼႂ်း subsequence ၼႆႉ လႆႈထုၵ်ႇသႂ်ႇဝႆႉယူႇယဝ်ႉ။// Function ၼႆႉ တေလႆႈၶိုၼ်း true သင်ၸိူဝ်ႉဝႃႈ မၼ်းမီးဝႆႉ brackets ဢၼ်ထုၵ်ႇမႅၼ်ႈၼႆၵူၺ်း// ႁဵတ်းပၼ် function ဢၼ်ဢဝ် string ဢၼ်ပႃး square brackets ၼၼ်ႉသေ သႂ်ႇပၼ်။/// >>> is_nested(string: ""[[]]"")
/// true
/// >>> is_nested(string: ""[]]]]]]][[[[[]"")
/// false
/// >>> is_nested(string: ""[][]"")
/// false
/// >>> is_nested(string: ""[]"")
/// false
/// >>> is_nested(string: ""[[][]]"")
/// true
/// >>> is_nested(string: ""[[]][["")
/// true
func is_nested(string: String) -> Bool {
","func is_nested(string: String) -> Bool {
    var stack: [Character] = []
    var nested = false

    for bracket in string {
        if bracket == ""["" {
            stack.append(bracket)
        } else if bracket == ""]"" {
            if let last = stack.last, last == ""["" {
                stack.removeLast()
                if !stack.isEmpty {
                    nested = true
                }
            } else {
                return false
            }
        }
    }
    return nested
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_nested(string: ""[[]]"") == true)
assert(is_nested(string: ""[]]]]]]][[[[[]"") == false)
assert(is_nested(string: ""[][]"") == false)
assert(is_nested(string: ""[]"") == false)
assert(is_nested(string: ""[[[[]]]]"") == true)
assert(is_nested(string: ""[]]]]]]]]]]"") == false)
assert(is_nested(string: ""[][][[]]"") == true)
assert(is_nested(string: ""[[]"") == false)
assert(is_nested(string: ""[]]"") == false)
assert(is_nested(string: ""[[]][["") == true)
assert(is_nested(string: ""[[][]]"") == true)
assert(is_nested(string: """") == false)
assert(is_nested(string: ""[[[[[[[["") == false)
assert(is_nested(string: ""]]]]]]]]"") == false)"
HumanEval_133,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ဢဝ်တူဝ်ၼပ်ႉဢၼ်မီးၼႂ်း array ၼၼ်ႉ သႂ်ႇတီႈၼိူဝ်သုတ်း int ((ceiling)) ဢွၼ်တၢင်းသုတ်း။// ႁဝ်းလူဝ်ႇၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်တဵမ်ထူၼ်ႈသွင် တီႈၼႂ်း array ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ၊ // လႆႈပၼ်ဝႆႉ တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈဢၼ်ၼိူင်ႈၼၼ်ႉယဝ်ႉ။/// >>> sum_squares(lst: [1.0, 2.0, 3.0])
/// 14
/// >>> sum_squares(lst: [1.0, 4.0, 9.0])
/// 98
/// >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> sum_squares(lst: [1.4, 4.2, 0.0])
/// 29
/// >>> sum_squares(lst: [-2.4, 1.0, 1.0])
/// 6
func sum_squares(lst: [Double]) -> Int {
","func sum_squares(lst: [Double]) -> Int {
    return lst.map { ceil($0) } // Round each element to the upper int (Ceiling)
              .map { Int($0 * $0) } // Square each element
              .reduce(0, +) // Sum all squared elements
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)
assert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)
assert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)
assert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)
assert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)
assert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)
assert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)
assert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)
assert(sum_squares(lst: [0.0]) == 0)
assert(sum_squares(lst: [-1.0]) == 1)
assert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"
HumanEval_134,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// မၢႆတွင်း: ""ၶေႃႈၵႂၢမ်း"" ၼႆႉပဵၼ် ၸုမ်းတူဝ်လိၵ်ႈ ဢၼ်ၸႅၵ်ႇဝႆႉလူၺ်ႈ လွင်ႈပႅၵ်ႇပိူင်ႈ။// ၶေႃႈၵႂၢမ်းဢၼ်ၼိုင်ႈလႄႈ ၶေႃႈၵႂၢမ်းဢၼ်ဢမ်ႇၸႂ်ႈ။// ၶွင် string ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ပဵၼ်တူဝ်လိၵ်ႈ တူဝ်လိၵ်ႈ လႄႈ ဢမ်ႇၸႂ်ႈ // ႁဵတ်းပၼ် function ဢၼ်ၶိုၼ်းပၼ် true သင်ဝႃႈ တူဝ်လိၵ်ႈလိုၼ်းသုတ်း /// >>> check_if_last_char_is_a_letter(txt: ""apple pie"")
/// false
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e"")
/// true
/// >>> check_if_last_char_is_a_letter(txt: ""apple pi e "")
/// false
/// >>> check_if_last_char_is_a_letter(txt: """")
/// false
func check_if_last_char_is_a_letter(txt: String) -> Bool {
","func check_if_last_char_is_a_letter(txt: String) -> Bool {
    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {
        return false
    }
    
    if lastChar.isLetter {
        let words = txt.split(separator: "" "")
        if let lastWord = words.last {
            return lastWord.count == 1
        }
    }
    
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(check_if_last_char_is_a_letter(txt: ""apple"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e"") == true)
assert(check_if_last_char_is_a_letter(txt: ""eeeee"") == false)
assert(check_if_last_char_is_a_letter(txt: ""A"") == true)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie "") == false)
assert(check_if_last_char_is_a_letter(txt: ""Pumpkin pie 1"") == false)
assert(check_if_last_char_is_a_letter(txt: """") == false)
assert(check_if_last_char_is_a_letter(txt: ""eeeee e "") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pie"") == false)
assert(check_if_last_char_is_a_letter(txt: ""apple pi e "") == false)"
HumanEval_135,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// ၵႃႈၶၼ်ဢၼ်မိူၼ်ၵၼ်။ // ပေႃးဢမ်ႇမီး တူဝ်ထပ်ႈႁူဝ်ၼႆ ၶိုၼ်းဢဝ် -1 မႃးၶိုၼ်း။ တူဝ်ၼပ်ႉဢၼ်ပၼ်ဝႆႉၼၼ်ႉ တေဢမ်ႇပႃး // ဢမ်ႇယႂ်ႇလိူဝ် ဢမ်ႇၼၼ် ဢမ်ႇၽဵင်ႇပဵင်းၵၼ်တင်း တူဝ်ၼပ်ႉဢၼ်မီးဝႆႉၸမ်မၼ်းၼၼ်ႉ သင်ဝႃႈ// ႁဵတ်းပၼ် function ဢၼ်ၶိုၼ်းပၼ် index ဢၼ်ယႂ်ႇသုတ်းၶွင် ၶူဝ်းၶွင်ဢၼ်ၼိူင်ႈ ဢၼ် /// >>> can_arrange(arr: [1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(arr: [1, 2, 3])
/// -1
func can_arrange(arr: [Int]) -> Int {
","func can_arrange(arr: [Int]) -> Int {
    for i in (1..<arr.count).reversed() {
        if arr[i] < arr[i - 1] {
            return i
        }
    }
    return -1
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)
assert(can_arrange(arr: [1, 2, 4, 5]) == -1)
assert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)
assert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)
assert(can_arrange(arr: [] as [Int]) == -1)"
HumanEval_136,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// သင်ဢမ်ႇမီး တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇမီးလွင်ႈထွၼ် ဢမ်ႇၼၼ် ဢၼ်မီးလွင်ႈထွၼ်ၼႆ ၶိုၼ်းဢဝ်ပဵၼ် nil။ // တူဝ်ၼပ်ႉတဵမ် ဢၼ်တဵမ်ထူၼ်ႈ တီႈၼႂ်း array ၼၼ်ႉ။ // တူဝ်ၼပ်ႉတဵမ် ဢၼ်ယႂ်ႇသေပိူၼ်ႈ ၼႂ်းတူဝ်ၼပ်ႉ ဢၼ်ဢမ်ႇတဵမ်ၼၼ်ႉ လႄႈ 'b' ၼႆႉ ပဵၼ်တူဝ်ၼပ်ႉဢၼ်လဵၵ်ႉသေပိူၼ်ႈ// ႁဵတ်းပၼ် function ဢၼ်ၶိုၼ်းပၼ် tuple (a, b) တီႈဢၼ် 'a' ပဵၼ် /// >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])
/// (nil, 1)
/// >>> largest_smallest_integers(lst: [] as [Int])
/// (nil, nil)
/// >>> largest_smallest_integers(lst: [0])
/// (nil, nil)
func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
","func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {
    var largestNegative: Int? = nil
    var smallestPositive: Int? = nil

    for number in lst {
        if number < 0 {
            if largestNegative == nil || number > largestNegative! {
                largestNegative = number
            }
        } else if number > 0 {
            if smallestPositive == nil || number < smallestPositive! {
                smallestPositive = number
            }
        }
    }

    return (largestNegative, smallestPositive)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))
assert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))
assert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))
assert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))
assert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))
assert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))
assert(largest_smallest_integers(lst: [0]) == (nil, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))
assert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))
assert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"
HumanEval_137,shn_Mymr,swift,"
enum Value: Equatable, Hashable {
    case intValue(Int)
    case doubleValue(Double)
    case stringValue(String)
}

            
// မၢႆတွင်း: သင်ဝႃႈ တူဝ်ၼပ်ႉဢၼ်ၸႅတ်ႈၸၢင်ႇၼၼ်ႉ ၼႄႁၢင်ႊမိူၼ်ၼင်ႇ သဵၼ်ႈသၢႆၼႆ တူဝ်ဢၼ်လႅၵ်ႈလၢႆႈလႆႈၼၼ်ႉ တေပဵၼ် . ဢမ်ႇၼၼ် , // ၶိုၼ်းဢဝ် nil မႃးၶိုၼ်း သင်ဝႃႈ ၵႃႈၶၼ်မၼ်းမိူၼ်ၵၼ်ၼႆ။ // တူဝ်ၼပ်ႉတႄႉ လႄႈ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇသေပိူၼ်ႈ ဢၼ်လႆႈပၼ်ဝႆႉ တီႈတူဝ်ၼပ်ႉဢၼ်လႅၵ်ႈလၢႆႈလႆႈၼၼ်ႉမႃး// ႁဵတ်းပၼ် တူဝ်ဢိင် ဢၼ်ဢဝ် တူဝ်ၼပ်ႉတဵမ်၊ floats ဢမ်ႇၼၼ် တူဝ်ၼပ်ႉဢၼ်တၢင်တူဝ် တူဝ်ထႅဝ် /// >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))
/// .doubleValue(2.5)
/// >>> compare_one(a: .intValue(1), b: .stringValue(""2,3""))
/// .stringValue(""2,3"")
/// >>> compare_one(a: .stringValue(""5,1""), b: .stringValue(""6""))
/// .stringValue(""6"")
/// >>> compare_one(a: .stringValue(""1""), b: .intValue(1))
/// nil
func compare_one(a: Value, b: Value) -> Value? {
","func compare_one(a: Value, b: Value) -> Value? {
    func convertToDouble(value: Value) -> Double? {
        switch value {
        case .intValue(let int):
            return Double(int)
        case .doubleValue(let double):
            return double
        case .stringValue(let string):
            let formatter = NumberFormatter()
            formatter.locale = Locale(identifier: ""en_US_POSIX"")
            if string.contains("","") {
                formatter.decimalSeparator = "",""
            } else {
                formatter.decimalSeparator = "".""
            }
            return formatter.number(from: string)?.doubleValue
        }
    }
    
    let aDouble = convertToDouble(value: a)
    let bDouble = convertToDouble(value: b)
    
    if let aDouble = aDouble, let bDouble = bDouble {
        if aDouble > bDouble {
            return a
        } else if bDouble > aDouble {
            return b
        }
    }
    
    return nil
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))
assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))
assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))
assert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))
assert(compare_one(a: .intValue(1), b: .stringValue(""2,3"")) == .stringValue(""2,3""))
assert(compare_one(a: .stringValue(""5,1""), b: .stringValue(""6"")) == .stringValue(""6""))
assert(compare_one(a: .stringValue(""1""), b: .stringValue(""2"")) == .stringValue(""2""))
assert(compare_one(a: .stringValue(""1""), b: .intValue(1)) == nil)"
HumanEval_138,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // ထတ်းသၢင်ႈဝႃႈ တူဝ်ၼပ်ႉ n ဢၼ်ပၼ်ဝႆႉၼၼ်ႉ ၸွင်ႇတေတႅမ်ႈလႆႈမိူၼ်ၼင်ႇ တူဝ်ၼပ်ႉဢၼ်ႁူမ်ႈၵၼ်ဝႆႉ 4 တူဝ်ၼၼ်ႉယူႇႁႃႉၼႆယူႇ/// >>> is_equal_to_sum_even(n: 4)
/// false
/// >>> is_equal_to_sum_even(n: 6)
/// false
/// >>> is_equal_to_sum_even(n: 8)
/// true
func is_equal_to_sum_even(n: Int) -> Bool {
","func is_equal_to_sum_even(n: Int) -> Bool {
    if n <= 8 {
        return false
    }
    return n % 2 == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(is_equal_to_sum_even(n: 4) == false)
assert(is_equal_to_sum_even(n: 6) == false)
assert(is_equal_to_sum_even(n: 8) == true)
assert(is_equal_to_sum_even(n: 10) == true)
assert(is_equal_to_sum_even(n: 11) == false)
assert(is_equal_to_sum_even(n: 12) == true)
assert(is_equal_to_sum_even(n: 13) == false)
assert(is_equal_to_sum_even(n: 16) == true)"
HumanEval_139,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-တီႈဢၼ် n > 0 // brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! // တူဝ်ၼပ်ႉဢၼ်ပဵၼ် factorial ၶွင် Brazil ၼၼ်ႉ မၵ်းမၼ်ႈဝႆႉမိူၼ်ၼင်ႇ: /// >>> special_factorial(n: 4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
func special_factorial(n: Int) -> Int {
","func factorial(_ n: Int) -> Int {
    return n <= 1 ? 1 : n * factorial(n - 1)
}

func special_factorial(n: Int) -> Int {
    var result = 1
    for i in 1...n {
        result *= factorial(i)
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(special_factorial(n: 4) == 288)
assert(special_factorial(n: 5) == 34560)
assert(special_factorial(n: 7) == 125411328000)
assert(special_factorial(n: 1) == 1)"
HumanEval_140,shn_Mymr,swift,"
// ယဝ်ႉၵေႃႈ ဢဝ်တူဝ်လိၵ်ႈဢၼ်ၵိုတ်းဝႆႉၸွမ်းၵၼ်ၼၼ်ႉ လႅၵ်ႈလၢႆႈပဵၼ် - // လႄႈ သင်ဝႃႈ သဵၼ်ႈမၢႆမၼ်းမီးဝႆႉ တူဝ်ဢၼ်ဢမ်ႇၵိုတ်းၵၼ် 2 တူဝ်လိူဝ်ၼႆၸိုင်// ပေႃးဝႃႈႁဝ်းပၼ်ဝႆႉ တူဝ်လိၵ်ႈ string ၼႆ ဢဝ် တူဝ်လိၵ်ႈဢၼ်ၸီႉဝႆႉတႂ်ႈသုတ်းသေ တႅၼ်းတီႈ တူဝ်လိၵ်ႈဢၼ်ဢမ်ႇၸီႉဝႆႉၼၼ်ႉ၊/// >>> fix_spaces(text: "" Example"")
/// ""Example""
/// >>> fix_spaces(text: "" Example 1"")
/// ""Example_1""
/// >>> fix_spaces(text: "" Example 2"")
/// ""_Example_2""
/// >>> fix_spaces(text: "" Example 3"")
/// ""_Example-3""
func fix_spaces(text: String) -> String {
","func fix_spaces(text: String) -> String {
    var result = """"
    var spaceCount = 0
    
    for character in text {
        if character == "" "" {
            spaceCount += 1
        } else {
            if spaceCount == 1 {
                result.append(""_"")
            } else if spaceCount > 1 {
                result.append(""-"")
            }
            result.append(character)
            spaceCount = 0
        }
    }
    
    if spaceCount == 1 {
        result.append(""_"")
    } else if spaceCount > 1 {
        result.append(""-"")
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(fix_spaces(text: ""Example"") == ""Example"")
assert(fix_spaces(text: ""Mudasir Hanif "") == ""Mudasir_Hanif_"")
assert(fix_spaces(text: ""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"")
assert(fix_spaces(text: ""Exa   mple"") == ""Exa-mple"")
assert(fix_spaces(text: ""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"")"
HumanEval_141,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// - သၢႆထႅဝ်ဢၼ်ယူႇၽၢႆႇလင် dot ၼၼ်ႉ ထုၵ်ႇလီပဵၼ်ဢၼ်ၼိူင်ႈၼႂ်းဢၼ်ၼႆႉ: ['txt', 'exe', 'dll'] တူဝ်လိၵ်ႈ လႅတ်ႇတိၼ်ႇ (a-z လႄႈ A-z) ။// - တူဝ်ထႅဝ်ဢၼ်မီးၼႃႈတႃတႃတႃၼၼ်ႉ ဢမ်ႇထုၵ်ႇလီပဵၼ် တူဝ်ဢၼ်ဢမ်ႇမီးတီႈသုတ်း လႄႈ မၼ်းတေတႄႇလူၺ်ႈ တူဝ်လိၵ်ႈဢၼ်လုၵ်ႉတီႈ // - ၸိုဝ်ႈၾၢႆႇဢၼ်ပႃးဝႆႉ တူၺ်းတီႈၼိူင်ႈဢၼ် '.' - ၸိုဝ်ႈၾၢႆႇဢၼ်တေလႆႈမီးယူႇသၢမ်တူဝ် (0-9) ။// လႆႈႁူပ်ႉထူပ်းၵၼ်: // ၸိုဝ်ႈၾၢႆႇဢၼ်ၼိုင်ႈၼႆႉ တေလႆႈဝႃႈပဵၼ်ၸိုဝ်ႈဢၼ်ထုၵ်ႇမႅၼ်ႈယူႇ သင်ဝႃႈ မၼ်းမီးလွင်ႈတၢင်းတၢင်းဢၼ်ပၼ်ဝႆႉၽၢႆႇတႂ်ႈၼႆႉယဝ်ႉ // 'Yes' သင်ဝႃႈ ၸိုဝ်ႈၾၢႆႇဢၼ်ထုၵ်ႇမႅၼ်ႈၼႆလႄႈ သင်ဢမ်ႇထုၵ်ႇမႅၼ်ႈၼႆ ၶိုၼ်းပၼ်ၶေႃႈတွပ်ႇ 'No'// ႁဵတ်းပၼ် function ဢၼ်ဢဝ် string ဢၼ်တၢင်တူဝ်ၸိုဝ်ႈ file သေ ၶိုၼ်းပၼ်ၶိုၼ်း /// >>> file_name_check(file_name: ""example.txt"")
/// ""Yes""
/// >>> file_name_check(file_name: ""1example.dll"")
/// ""No""
func file_name_check(file_name: String) -> String {
","func file_name_check(file_name: String) -> String {
    // Split by the dot.
    let components = file_name.split(separator: ""."", omittingEmptySubsequences: false)
    
    // Check if there's exactly one dot.
    guard components.count == 2 else {
        return ""No""
    }
    
    // Extract the prefix and suffix.
    let prefix = String(components[0])
    let suffix = String(components[1])
    
    // Check if the prefix is non-empty and starts with a letter.
    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {
        return ""No""
    }
    
    // Check if the suffix is one of the allowed types.
    let validSuffixes = [""txt"", ""exe"", ""dll""]
    guard validSuffixes.contains(suffix) else {
        return ""No""
    }
    
    // Count digits in the file name.
    let digitCount = file_name.filter { $0.isNumber }.count
    
    // Ensure that there are not more than 3 digits.
    guard digitCount <= 3 else {
        return ""No""
    }
    
    // If all checks pass, it's a valid file name.
    return ""Yes""
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(file_name_check(file_name: ""example.txt"") == ""Yes"")
assert(file_name_check(file_name: ""1example.dll"") == ""No"")
assert(file_name_check(file_name: ""s1sdf3.asd"") == ""No"")
assert(file_name_check(file_name: ""K.dll"") == ""Yes"")
assert(file_name_check(file_name: ""MY16FILE3.exe"") == ""Yes"")
assert(file_name_check(file_name: ""His12FILE94.exe"") == ""No"")
assert(file_name_check(file_name: ""_Y.txt"") == ""No"")
assert(file_name_check(file_name: ""?aREYA.exe"") == ""No"")
assert(file_name_check(file_name: ""/this_is_valid.dll"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.wow"") == ""No"")
assert(file_name_check(file_name: ""this_is_valid.txt"") == ""Yes"")
assert(file_name_check(file_name: ""this_is_valid.txtexe"") == ""No"")
assert(file_name_check(file_name: ""#this2_i4s_5valid.ten"") == ""No"")
assert(file_name_check(file_name: ""@this1_is6_valid.exe"") == ""No"")
assert(file_name_check(file_name: ""this_is_12valid.6exe4.txt"") == ""No"")
assert(file_name_check(file_name: ""all.exe.txt"") == ""No"")
assert(file_name_check(file_name: ""I563_No.exe"") == ""Yes"")
assert(file_name_check(file_name: ""Is3youfault.txt"") == ""Yes"")
assert(file_name_check(file_name: ""no_one#knows.dll"") == ""Yes"")
assert(file_name_check(file_name: ""1I563_Yes3.exe"") == ""No"")
assert(file_name_check(file_name: ""I563_Yes3.txtt"") == ""No"")
assert(file_name_check(file_name: ""final..txt"") == ""No"")
assert(file_name_check(file_name: ""final132"") == ""No"")
assert(file_name_check(file_name: ""_f4indsartal132."") == ""No"")
assert(file_name_check(file_name: "".txt"") == ""No"")
assert(file_name_check(file_name: ""s."") == ""No"")"
HumanEval_143,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ 1: // ၶေႃႈၵႂၢမ်းဢၼ်မီးတီႈၼႂ်း သဵင်မႂ်ႇၼၼ်ႉ ထုၵ်ႇလီမိူၼ်ၵၼ်တင်း ၶေႃႈၵႂၢမ်းငဝ်ႈမၼ်း// တၢင်းယၢဝ်းမၼ်းပဵၼ် တူဝ်ၼပ်ႉၶမ်ႇပိုၼ်ႉ၊ // လႄႈ တေလႆႈၶိုၼ်းပၼ် string ဢၼ်ပႃးၶေႃႈၵႂၢမ်း တီႈၼႂ်းၶေႃႈၵႂၢမ်းငဝ်ႈမၼ်း၊ // ၼႂ်းၶေႃႈၵႂၢမ်းၼၼ်ႉ မီးဝႆႉ ၶေႃႈၵႂၢမ်းဢၼ်ၽႄဝႆႉ လူၺ်ႈႁၢင်ႁၢင်၊ // လႆႈပၼ် string ဢၼ်တႅၼ်းတၢင်ၶေႃႈၵႂၢမ်း၊ /// >>> words_in_sentence(sentence: ""This is a test"")
/// ""is""
/// Example 2:
/// >>> words_in_sentence(sentence: ""lets go for swimming"")
/// ""go for""
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
func words_in_sentence(sentence: String) -> String {
","func words_in_sentence(sentence: String) -> String {
    func isPrime(_ n: Int) -> Bool {
        if n <= 1 { return false }
        if n <= 3 { return true }
        if n % 2 == 0 || n % 3 == 0 { return false }
        var i = 5
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 { return false }
            i += 6
        }
        return true
    }
    
    let words = sentence.split(separator: "" "")
    let primeLengthWords = words.filter { isPrime($0.count) }
    return primeLengthWords.joined(separator: "" "")
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(words_in_sentence(sentence: ""This is a test"") == ""is"")
assert(words_in_sentence(sentence: ""lets go for swimming"") == ""go for"")
assert(words_in_sentence(sentence: ""there is no place available here"") == ""there is no place"")
assert(words_in_sentence(sentence: ""Hi I am Hussein"") == ""Hi am Hussein"")
assert(words_in_sentence(sentence: ""go for it"") == ""go for it"")
assert(words_in_sentence(sentence: ""here"") == """")
assert(words_in_sentence(sentence: ""here is"") == ""is"")"
HumanEval_144,shn_Mymr,swift,"
// ႁဝ်းၸၢင်ႈဝူၼ်ႉဝႃႈ x, လႄႈ n ၼႆႉပဵၼ် တူဝ်ၼပ်ႉပုၼ်ႈဢၼ်ထုၵ်ႇမႅၼ်ႈ လႄႈ ဢမ်ႇမီးသုၼ်ပဵၼ် တူဝ်ၼပ်ႉၸႅၵ်ႇ။ တီႈဢၼ် တူဝ်ၼပ်ႉလႄႈ တူဝ်ၼပ်ႉဢၼ်ပႃး တူဝ်ၼပ်ႉတဵမ် ဢၼ်တဵမ်ဝႆႉၼၼ်ႉ ပဵၼ်တူဝ်ၼပ်ႉတဵမ် ဢၼ်တဵမ်ဝႆႉၼၼ်ႉယဝ်ႉ။x လႄႈ n ၼႆႉ ပဵၼ်တူဝ်တႅၼ်း တူဝ်ၼပ်ႉသွၼ်ႇ ၶွင် တူဝ်ၼပ်ႉပုၼ်ႈ လႄႈ မီးပိူင်ၾၢင် ၼင်ႇတႂ်ႈၼႆႉ// x * n ၼႆႉ မၼ်းတေၶိုၼ်းပၼ် true သင်ၸိူဝ်ႉဝႃႈ x * n ၼႆႉပဵၼ် တူဝ်ၼပ်ႉတဵမ် လႄႈ false // ၼႃႈၵၢၼ်ၶွင်ႁဝ်းၼႆႉ ပဵၼ်တႃႇႁဵတ်းသၢင်ႈ တူဝ်ဢိင်ဢၼ်တေႁဵတ်းႁႂ်ႈ လွင်ႈလၢတ်ႈဢွၵ်ႇၼၼ်ႉ ငၢႆႈငၢႆႈ /// >>> simplify(x: ""1/5"", n: ""5/1"")
/// true
/// >>> simplify(x: ""1/6"", n: ""2/1"")
/// false
/// >>> simplify(x: ""7/10"", n: ""10/2"")
/// false
func simplify(x: String, n: String) -> Bool {
","func simplify(x: String, n: String) -> Bool {
    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {
        let parts = fraction.split(separator: ""/"").map { Int($0)! }
        return (numerator: parts[0], denominator: parts[1])
    }
    
    let (xNumerator, xDenominator) = parseFraction(fraction: x)
    let (nNumerator, nDenominator) = parseFraction(fraction: n)
    
    // Multiply the two fractions: (xNumerator * nNumerator) / (xDenominator * nDenominator)
    let resultNumerator = xNumerator * nNumerator
    let resultDenominator = xDenominator * nDenominator
    
    // Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator
    return resultNumerator % resultDenominator == 0
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/6"", n: ""2/1"") == false)
assert(simplify(x: ""5/1"", n: ""3/1"") == true)
assert(simplify(x: ""7/10"", n: ""10/2"") == false)
assert(simplify(x: ""2/10"", n: ""50/10"") == true)
assert(simplify(x: ""7/2"", n: ""4/2"") == true)
assert(simplify(x: ""11/6"", n: ""6/1"") == true)
assert(simplify(x: ""2/3"", n: ""5/2"") == false)
assert(simplify(x: ""5/2"", n: ""3/5"") == false)
assert(simplify(x: ""2/4"", n: ""8/4"") == true)
assert(simplify(x: ""2/4"", n: ""4/2"") == true)
assert(simplify(x: ""1/5"", n: ""5/1"") == true)
assert(simplify(x: ""1/5"", n: ""1/5"") == false)"
HumanEval_145,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// ၸႅၵ်ႇမႅင်ႇၶဝ်ၸွမ်း index ၶဝ် တီႈၼႂ်း array ဢၼ်ၵဝ်ႇၼၼ်ႉ။ // မၢႆတွင်း: သင်မီးဝႆႉ ၶူဝ်းၶွင်တၢင်းၼမ် ဢၼ်မီး တူဝ်ၼပ်ႉဢၼ်မိူၼ်ၵၼ်ၼၼ်ႉ // ၸွမ်းၼင်ႇ လွင်ႈၶပ်ႉၶိုင် ဢၼ်တိူဝ်းလိူဝ်မႃး ၸွမ်းၼင်ႇ တူဝ်ၼပ်ႉတူဝ်ၼပ်ႉၶဝ်ၼၼ်ႉယဝ်ႉ။// တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ၸႅၵ်ႇပၼ် လွင်ႈၸႅၼ်ႇတူဝ်ၼပ်ႉတဵမ်တင်းၼမ် /// >>> order_by_points(nums: [1, 11, -1, -11, -12])
/// [-1, -11, 1, -12, 11]
/// >>> order_by_points(nums: [] as [Int])
/// [] as [Int]
func order_by_points(nums: [Int]) -> [Int] {
","func order_by_points(nums: [Int]) -> [Int] {
    return nums.enumerated().sorted {
        let sum1 = digitSum($0.element)
        let sum2 = digitSum($1.element)
        if sum1 == sum2 {
            return $0.offset < $1.offset
        } else {
            return sum1 < sum2
        }
    }.map { $0.element }
}

func digitSum(_ number: Int) -> Int {
    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])
assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])
assert(order_by_points(nums: [] as [Int]) == [] as [Int])
assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])
assert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])
assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
HumanEval_146,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢွၼ်တၢင်းသုတ်းလႄႈ တူဝ်ၼပ်ႉလိုၼ်းသုတ်း ၶွင်တူဝ်ၼပ်ႉၼၼ်ႉ ပဵၼ်တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် (1, 3, 5, 7, 9) ။// တူဝ်ၼပ်ႉၶွင် တူဝ်ၼပ်ႉဢၼ်ယႂ်ႇလိူဝ် 10 လႄႈ တင်းသွင်ဢၼ် // တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ဢဝ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် array ၼၼ်ႉပဵၼ် input လႄႈ return /// >>> specialFilter(nums: [15, -73, 14, -15])
/// 1
/// >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])
/// 2
func specialFilter(nums: [Int]) -> Int {
","func specialFilter(nums: [Int]) -> Int {
    return nums.filter { num in
        let absNum = abs(num)
        
        guard absNum > 10 else {
            return false
        }
        
        let firstDigit = String(String(absNum).first!)
        let lastDigit = String(absNum % 10)
        
        let oddDigits: Set = [""1"", ""3"", ""5"", ""7"", ""9""]
        
        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)
    }.count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(specialFilter(nums: [5, -2, 1, -5]) == 0)
assert(specialFilter(nums: [15, -73, 14, -15]) == 1)
assert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)
assert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)
assert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)
assert(specialFilter(nums: [1]) == 0)
assert(specialFilter(nums: [] as [Int]) == 0)"
HumanEval_147,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// လႄႈ a[i] + a[j] + a[k] ၼႆႉပဵၼ်တူဝ်ၼပ်ႉ ဢၼ်ၵုၼ်းၵၼ်တင်း 3 ယဝ်ႉ။// ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် သၢမ်တူဝ် (a[i], a[j], a[k]) ၶွင် a တီႈ i < j < k, // တွၼ်ႈတႃႇ i ၵူႈဢၼ် (1 ≤ i ≤ n) ၼၼ်ႉ ၵႃႈၶၼ်ၶွင် a[i] = i * i - i + 1 ၼၼ်ႉၼႆယဝ်ႉ။// ပၼ်တူဝ်ၼပ်ႉတဵမ်တူဝ်ၼပ်ႉသုတ်ႉ n ယဝ်ႉၵေႃႈ တေလႆႈႁဵတ်းပဵၼ် တူဝ်ၼပ်ႉတဵမ်တူဝ်ၼပ်ႉ a ဢၼ်တၢင်းယၢဝ်းမၼ်းပဵၼ် n ၼၼ်ႉယူႇယဝ်ႉ/// >>> get_max_triples(n: 5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
func get_max_triples(n: Int) -> Int {
","func get_max_triples(n: Int) -> Int {
    // Create the array a based on the problem description
    var a = [Int](repeating: 0, count: n)
    for i in 1...n {
        a[i - 1] = i * i - i + 1
    }
    
    var count = 0
    // Check for all possible triples
    for i in 0..<n {
        for j in (i + 1)..<n {
            for k in (j + 1)..<n {
                if (a[i] + a[j] + a[k]) % 3 == 0 {
                    count += 1
                }
            }
        }
    }
    
    return count
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(get_max_triples(n: 5) == 1)
assert(get_max_triples(n: 6) == 4)
assert(get_max_triples(n: 10) == 36)
assert(get_max_triples(n: 100) == 53361)"
HumanEval_149,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// သူတေၸၢင်ႈထၢင်ႇဝႃႈ ၶေႃႈၵႂၢမ်းတင်းမူတ်း တေမီးတၢင်းယၢဝ်းမိူၼ်ၵၼ်ယူႇၼႆယဝ်ႉ။// တူဝ်ဢိင်ၼႆႉ တေလႆႈၶိုၼ်းပၼ် တူဝ်ၼပ်ႉဢၼ်ၸႅၼ်ႇဝႆႉၸွမ်းပိူင်မၼ်း။// သင်ဝႃႈ ၶေႃႈၵႂၢမ်းသွင်ၶေႃႈ မီးတၢင်းယၢဝ်းမိူၼ်ၵၼ်ၼႆ ၸႅၵ်ႇမႅင်ႇပၼ် တူဝ်လိၵ်ႈၸွမ်းပိူင်တူဝ်လိၵ်ႈ။// တေလႆႈၶိုၼ်းပၼ် array ဢၼ်ၸႅၵ်ႇဝႆႉၸွမ်းပိူင်ၼၼ်ႉ။ // လွင်ႈၸႅၼ်ႇၸႅၼ်ႇမၼ်းၼႆႉ ထုၵ်ႇလီၶိုၼ်ႈမႃး ၸွမ်းၼင်ႇ တၢင်းယၢဝ်းၶေႃႈၵႂၢမ်းဢၼ်လႂ်ဢၼ်ၼၼ်ႉလႄႈ သူတေလႆႈ// လႄႈ မၼ်းတေပႃးဝႆႉ duplicates ၼၼ်ႉယူႇယဝ်ႉ။// array ၼႆႉ ပဵၼ် array ၶွင် string လႄႈ ဢမ်ႇတွၼ်ႉပဵၼ် array ၶွင် တူဝ်ၼပ်ႉ၊// လႄႈ ၶိုၼ်းဢဝ် array ဢၼ်လႆႈမႃးၼၼ်ႉ ၶိုၼ်းဢဝ်မႃးၸွမ်းၼင်ႇပိူင်ဢၼ်ၸႅၵ်ႇဝႆႉၼၼ်ႉ၊// ထွၼ်ဢွၵ်ႇ string ဢၼ်ဢမ်ႇမိူၼ်ၵၼ်တၢင်းၵႂၢင်ႈမၼ်း၊ // တႅမ်ႈပၼ် function ဢၼ်ႁပ်ႉဢဝ် array of strings မိူၼ်ၼင်ႇ ပႃႇရႃႇမီႇတႃႇ၊/// >>> sorted_list_sum(lst: [""aa"", ""a"", ""aaa""])
/// [""aa""]
/// >>> sorted_list_sum(lst: [""ab"", ""a"", ""aaa"", ""cd""])
/// [""ab"", ""cd""]
func sorted_list_sum(lst: [String]) -> [String] {
","func sorted_list_sum(lst: [String]) -> [String] {
    return lst.filter { $0.count % 2 == 0 }
              .sorted { 
                  if $0.count == $1.count {
                      return $0 < $1
                  }
                  return $0.count < $1.count
              }
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(sorted_list_sum(lst: [""aa"", ""a"", ""aaa""]) == [""aa""])
assert(sorted_list_sum(lst: [""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""])
assert(sorted_list_sum(lst: [""d"", ""b"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""])
assert(sorted_list_sum(lst: [""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""])
assert(sorted_list_sum(lst: [""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == [] as [String])
assert(sorted_list_sum(lst: [""aaaa"", ""bbbb"", ""dd"", ""cc""]) == [""cc"", ""dd"", ""aaaa"", ""bbbb""])"
HumanEval_150,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// prime number လႄႈ တေလႆႈၶိုၼ်းပၼ် ၵႃႈၶၼ် y ပေႃးဢမ်ႇၼၼ်။ // ပရူဝ်ႇၵရမ်ႇဢၼ်ငၢႆႈ ဢၼ်တေလႆႈၶိုၼ်း ၵႃႈၶၼ်ၶွင် x သင်ၸိူဝ်ႉဝႃႈ n ၼႆႉပဵၼ် /// >>> x_or_y(n: 7, x: 34, y: 12)
/// 34
/// >>> x_or_y(n: 15, x: 8, y: 5)
/// 5
func x_or_y(n: Int, x: Int, y: Int) -> Int {
","func x_or_y(n: Int, x: Int, y: Int) -> Int {
    func isPrime(_ number: Int) -> Bool {
        if number <= 1 { return false }
        if number <= 3 { return true }
        if number % 2 == 0 || number % 3 == 0 { return false }
        
        var i = 5
        while i * i <= number {
            if number % i == 0 || number % (i + 2) == 0 {
                return false
            }
            i += 6
        }
        return true
    }
    
    return isPrime(n) ? x : y
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(x_or_y(n: 7, x: 34, y: 12) == 34)
assert(x_or_y(n: 15, x: 8, y: 5) == 5)
assert(x_or_y(n: 3, x: 33, y: 5212) == 33)
assert(x_or_y(n: 1259, x: 3, y: 52) == 3)
assert(x_or_y(n: 7919, x: -1, y: 12) == -1)
assert(x_or_y(n: 3609, x: 1245, y: 583) == 583)
assert(x_or_y(n: 91, x: 56, y: 129) == 129)
assert(x_or_y(n: 6, x: 34, y: 1234) == 1234)
assert(x_or_y(n: 1, x: 2, y: 0) == 0)
assert(x_or_y(n: 2, x: 2, y: 0) == 2)"
HumanEval_151,shn_Mymr,swift,"
တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉ ပႅတ်ႈပႅတ်ႈ တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ဢမ်ႇၼၼ် တူဝ်ၼပ်ႉဢၼ်ဢမ်ႇတဵမ်ၼၼ်ႉ။// ပၼ်ဝႆႉ တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၼပ်ႉသီႇၸဵင်ႇ ဢၼ်ႁူမ်ႈၵၼ်ၼၼ်ႉမႃး/// >>> double_the_difference(lst: [1, 3, 2, 0])
/// 10
/// >>> double_the_difference(lst: [-1, -2, 0])
/// 0
/// >>> double_the_difference(lst: [9, -2])
/// 81
/// >>> double_the_difference(lst: [0])
/// 0
/// If the input array is empty, return 0.
func double_the_difference(lst: [Double]) -> Int {
","func double_the_difference(lst: [Double]) -> Int {
    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }
              .map { Int($0) * Int($0) }
              .reduce(0, +)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(double_the_difference(lst: [] as [Double]) == 0)
assert(double_the_difference(lst: [5.0, 4.0]) == 25)
assert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)
assert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)
assert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)
assert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)
assert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"
HumanEval_152,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // ၵႃႈၶၼ်မၼ်းပဵၼ် 0 လႄႈ သင်ဢမ်ႇၸႂ်ႈၼႆ ၵႃႈၶၼ်မၼ်းပဵၼ် လွင်ႈပႅၵ်ႇပိူင်ႈဢၼ်ဢမ်ႇမီးတီႈပွင်ႇ ၼႂ်းၵႄႈ လွင်ႈလၢမ်းၶၢတ်ႈလႄႈ လွင်ႈလႆႈၶၼ်။// ၶိုၼ်းဢဝ် array ဢၼ်တၢင်းယၢဝ်းမၼ်းမိူၼ်ၵၼ် ဢၼ်ၼႄပၼ်ဝႃႈ လွင်ႈလၢမ်းၶၢတ်ႈဢၼ်လႂ်ဢၼ်ၼၼ်ႉ မၼ်းၵႆၵႃႈႁိုဝ် ပေႃးၶဝ်လၢမ်းၶၢတ်ႈမႅၼ်ႈၼႆ // လႆႈပၼ်ဝႆႉ လွင်ႈလၢမ်းၶၢတ်ႈ လႄႈ လွင်ႈမၵ်းမၢႆသွင်ဢၼ် ဢၼ်ယၢဝ်းမိူၼ်ၵၼ်၊ တီႈဢၼ် index ၵူႈဢၼ်ဢၼ် ၼႄပၼ် လွင်ႈဢၼ်ၵွင်ႉၵၢႆႇၵၼ်ၼၼ်ႉယဝ်ႉ။// ၼႃႈၵၢၼ်ၶွင်သူၼႆႉ ပဵၼ်တႃႇတႅပ်းတတ်းဝႃႈ ၵူၼ်းၵေႃႉၼိူင်ႈၵေႃႉၼၼ်ႉ ထၢင်ႇၸႅင်ႈလီ လွင်ႈလႆႈမႃးၶွင် လွင်ႈဢၼ်ပဵင်းၵၼ်တၢင်းၼမ်ၼၼ်ႉႁိုဝ်ၼႆၼၼ်ႉယဝ်ႉ။// ဢၼ်ထၢင်ႇၸႅင်ႈလီသေ ထၢင်ႇၸႅင်ႈလီၼၼ်ႉ ပဵၼ်လွင်ႈမၢႆတွင်း လႄႈ လွင်ႈတႅၵ်ႈၼိူင်းၵၼ်ၼၼ်ႉယဝ်ႉ။လွင်ႈဢၼ်ပဵၼ်မႃးၼၼ်ႉ ပဵၼ်ဢၼ်ႁူႉဝႆႉယဝ်ႉသေတႃႉ လွင်ႈဢၼ်ႁဝ်းမီးလွင်ႈတၢင်း လႄႈ တၢင်းဝူၼ်ႉဢၼ်မီးတီႈၶၼ်ၼၼ်ႉ ပဵၼ်ဢၼ်ႁူႉဝႆႉယဝ်ႉ။ႁဝ်းၶႃႈလႆႈႁူႉဝႃႈ ၼႂ်းမိူင်းႁူမ်ႈတုမ်ၼႆႉ မီးလွင်ႈၶိုပ်ႈၼႃႈမႃး ၶၢဝ်းႁိုင်ယဝ်ႉလႄႈ ႁဝ်းၶႃႈလႆႈၶတ်းၸႂ် ႁဵတ်းသၢင်ႈၵႂႃႇ ။/// >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])
/// [0, 0, 0, 0, 3, 3]
/// >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])
/// [4, 4, 1, 0, 0, 6]
func compare(game: [Int], guess: [Int]) -> [Int] {
","func compare(game: [Int], guess: [Int]) -> [Int] {
    var result: [Int] = []
    
    for i in 0..<game.count {
        let difference = abs(game[i] - guess[i])
        result.append(difference)
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])
assert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])
assert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])
assert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"
HumanEval_153,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // (ႁႅင်းမၼ်းပဵၼ် -1) // return 'Slices.SErviNGSliCes' ယွၼ်ႉဝႃႈ 'SErviNGSliCes' ၼႆႉ ပဵၼ်လွင်ႈၶႂၢၵ်ႈဢၼ်ၶိုၵ်ႉၶႅမ်ႉသုတ်း // extension: ['SERVINGSliCes', 'Cheese', 'StuFfed'] ပေႃးၼၼ် ၸဝ်ႈၵဝ်ႇ ထုၵ်ႇလီ တူဝ်ယၢင်ႇမၼ်း သင်ဝႃႈႁဝ်းလႆႈပၼ် ""Slices"" မိူၼ်ၼင်ႇ class လႄႈ array ၶွင် // လိူၵ်ႈဢဝ် ဢၼ်မႃးဢွၼ်တၢင်းသုတ်း ၼႂ်း array ၼၼ်ႉၶႃႈ။ // သင်ဝႃႈမီးလွင်ႈၶႂၢၵ်ႈဢၼ်မိူၼ်ၵၼ်တင်းသွင်ဢၼ် ဢမ်ႇၼၼ် ၼမ်လိူဝ်ၼၼ်ႉၼႆၸိုင် သူတေလႆႈ// format: ClassName.StrongestExtensionName.  ၼႆႉပဵၼ်ၸိုဝ်ႈဢၼ်မီးလွင်ႈၵႅၼ်ႇၶႅင်သေပိူၼ်ႈ ဢၼ်ၼိူင်ႈယဝ်ႉ။// တေလႆႈႁႃလွင်ႈၶႂၢၵ်ႈဢၼ်ၶိုၵ်ႉၶႅမ်ႉသေပိူၼ်ႈ လႄႈ ၶိုၼ်းဢဝ် string ဢၼ်ၼႆႉမႃးၶိုၼ်း // တီႈၸိုဝ်ႈဢၼ်ၶႂၢၵ်ႈမၼ်းၼၼ်ႉ၊ ႁႅင်းမၼ်းၼႆႉ လႆႈထုၵ်ႇပၼ်ဝႆႉလူၺ်ႈ လွင်ႈတႅၵ်ႈ CAP - SM ၼၼ်ႉယဝ်ႉ။// တူဝ်လိၵ်ႈၼႂ်းၸိုဝ်ႈ extension လႄႈ SM ပဵၼ်တူဝ်လိၵ်ႈလဵၵ်ႉလဵၵ်ႉ// ႁႅင်းၶွင်လွင်ႈၶႂၢၵ်ႈၼႆႉပဵၼ်မိူၼ်ၼင်ႇတႂ်ႈၼႆႉ: ႁႂ်ႈ CAP ပဵၼ်တူဝ်ၼပ်ႉၶွင် တူဝ်လိၵ်ႈယႂ်ႇ // Extensions ၼႆႉတေလႆႈၸႂ်ႉတိုဝ်းတႃႇတၢင်ႇတၢင်ႇၸၼ်ႉထၢၼ်ႈတၢင်ႇဢၼ်။// တေပၼ်ၸိုဝ်ႈ class (string) လႄႈ တူဝ်ၼပ်ႉဢၼ်ၶႂၢၵ်ႈမၼ်းဝႆႉ။/// >>> Strongest_Extension(class_name: ""my_class"", extensions: [""AA"", ""Be"", ""CC""])
/// ""my_class.AA""
func Strongest_Extension(class_name: String, extensions: [String]) -> String {
","func Strongest_Extension(class_name: String, extensions: [String]) -> String {
    var strongestExtension: String? = nil
    var maxStrength = Int.min
    
    for ext in extensions {
        let cap = ext.filter { $0.isUppercase }.count
        let sm = ext.filter { $0.isLowercase }.count
        let strength = cap - sm
        
        if strength > maxStrength {
            maxStrength = strength
            strongestExtension = ext
        }
    }
    
    if let strongestExt = strongestExtension {
        return ""\(class_name).\(strongestExt)""
    }
    
    return class_name
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(Strongest_Extension(class_name: ""Watashi"", extensions: [""tEN"", ""niNE"", ""eIGHt8OKe""]) == ""Watashi.eIGHt8OKe"")
assert(Strongest_Extension(class_name: ""Boku123"", extensions: [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]) == ""Boku123.YEs.WeCaNe"")
assert(Strongest_Extension(class_name: ""__YESIMHERE"", extensions: [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]) == ""__YESIMHERE.NuLl__"")
assert(Strongest_Extension(class_name: ""K"", extensions: [""Ta"", ""TAR"", ""t234An"", ""cosSo""]) == ""K.TAR"")
assert(Strongest_Extension(class_name: ""__HAHA"", extensions: [""Tab"", ""123"", ""781345"", ""-_-""]) == ""__HAHA.123"")
assert(Strongest_Extension(class_name: ""YameRore"", extensions: [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]) == ""YameRore.okIWILL123"")
assert(Strongest_Extension(class_name: ""finNNalLLly"", extensions: [""Die"", ""NowW"", ""Wow"", ""WoW""]) == ""finNNalLLly.WoW"")
assert(Strongest_Extension(class_name: ""_"", extensions: [""Bb"", ""91245""]) == ""_.Bb"")
assert(Strongest_Extension(class_name: ""Sp"", extensions: [""671235"", ""Bb""]) == ""Sp.671235"")"
HumanEval_154,shn_Mymr,swift,"
// ပၼ်ၶေႃႈၵႂၢမ်း 2 ၶေႃႈ၊ သင်ဝႃႈ ၶေႃႈၵႂၢမ်းၵမ်းသွင် ဢမ်ႇၼၼ် လွင်ႈလႅၵ်ႈလၢႆႈမၼ်းပဵၼ် substring ၼႂ်းၶေႃႈၵႂၢမ်းၵမ်းဢွၼ်တၢင်းသုတ်းၼႆ တေလႆႈၶိုၼ်း true/// >>> cycpattern_check(a: ""abcd"", b: ""abd"")
/// false
/// >>> cycpattern_check(a: ""hello"", b: ""ell"")
/// true
/// >>> cycpattern_check(a: ""whassup"", b: ""psus"")
/// false
/// >>> cycpattern_check(a: ""abab"", b: ""baa"")
/// true
/// >>> cycpattern_check(a: ""efef"", b: ""eeff"")
/// false
/// >>> cycpattern_check(a: ""himenss"", b: ""simen"")
/// true
func cycpattern_check(a: String, b: String) -> Bool {
","func cycpattern_check(a: String, b: String) -> Bool {
    guard !b.isEmpty else { return true }
    let bCombined = b + b
    for i in 0..<b.count {
        let rotation = String(bCombined.dropFirst(i).prefix(b.count))
        if a.contains(rotation) {
            return true
        }
    }
    return false
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(cycpattern_check(a: ""xyzw"", b: ""xyw"") == false)
assert(cycpattern_check(a: ""yello"", b: ""ell"") == true)
assert(cycpattern_check(a: ""whattup"", b: ""ptut"") == false)
assert(cycpattern_check(a: ""efef"", b: ""fee"") == true)
assert(cycpattern_check(a: ""abab"", b: ""aabb"") == false)
assert(cycpattern_check(a: ""winemtt"", b: ""tinem"") == true)"
HumanEval_155,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ်ဢၼ်ၼိူင်ႈၼၼ်ႉ၊ ၶိုၼ်းဢဝ် တူဝ်ၼပ်ႉဢၼ်ၼိူင်ႈ ဢၼ်ပႃး တူဝ်ၼပ်ႉဢၼ်ပဵၼ် တူဝ်ၸႅၼ်ႇ လႄႈ တူဝ်ၸႅၼ်ႇ ဢၼ်ဢမ်ႇမိူၼ်ၵၼ်ၼၼ်ႉ ၶိုၼ်းမႃး။ /// >>> even_odd_count(num: -12)
/// (1, 1)
/// >>> even_odd_count(num: 123)
/// (1, 2)
func even_odd_count(num: Int) -> (Int, Int) {
","func even_odd_count(num: Int) -> (Int, Int) {
    var countEvens = 0
    var countOdds = 0
    var number = abs(num) // Handle negative numbers by taking absolute value

    while number > 0 {
        let digit = number % 10
        if digit % 2 == 0 {
            countEvens += 1
        } else {
            countOdds += 1
        }
        number /= 10
    }
    return (countEvens, countOdds)
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(even_odd_count(num: 7) == (0, 1))
assert(even_odd_count(num: -78) == (1, 1))
assert(even_odd_count(num: 3452) == (2, 2))
assert(even_odd_count(num: 346211) == (3, 3))
assert(even_odd_count(num: -345821) == (3, 3))
assert(even_odd_count(num: -2) == (1, 0))
assert(even_odd_count(num: -45347) == (2, 3))
assert(even_odd_count(num: 0) == (1, 0))"
HumanEval_156,shn_Mymr,swift,"
တူဝ်ယၢင်ႇ:// လွင်ႈမၵ်းၶၢၼ်း: 1 <= num <= 1000 // လႄႈ ၶိုၼ်းဢဝ်မၼ်းမႃးပဵၼ် တူဝ်လိၵ်ႈလဵၵ်ႉ။ // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉတဵမ် ဢၼ်သၢင်ႇထုၵ်ႇၼၼ်ႉသေ၊ ဢဝ်တူဝ်ၼပ်ႉ ရေႃးမ ဢၼ်မိူၼ်ၵၼ်ၼၼ်ႉသေ ႁဵတ်းပဵၼ် တူဝ်ထႅဝ်၊ /// >>> int_to_mini_roman(number: 19)
/// ""xix""
/// >>> int_to_mini_roman(number: 152)
/// ""clii""
/// >>> int_to_mini_roman(number: 426)
/// ""cdxxvi""
func int_to_mini_roman(number: Int) -> String {
","func int_to_mini_roman(number: Int) -> String {
    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    let numerals = [""m"", ""cm"", ""d"", ""cd"", ""c"", ""xc"", ""l"", ""xl"", ""x"", ""ix"", ""v"", ""iv"", ""i""]
    
    var num = number
    var result = """"
    
    for (index, value) in values.enumerated() {
        while num >= value {
            result += numerals[index]
            num -= value
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(int_to_mini_roman(number: 19) == ""xix"")
assert(int_to_mini_roman(number: 152) == ""clii"")
assert(int_to_mini_roman(number: 251) == ""ccli"")
assert(int_to_mini_roman(number: 426) == ""cdxxvi"")
assert(int_to_mini_roman(number: 500) == ""d"")
assert(int_to_mini_roman(number: 1) == ""i"")
assert(int_to_mini_roman(number: 4) == ""iv"")
assert(int_to_mini_roman(number: 43) == ""xliii"")
assert(int_to_mini_roman(number: 90) == ""xc"")
assert(int_to_mini_roman(number: 94) == ""xciv"")
assert(int_to_mini_roman(number: 532) == ""dxxxii"")
assert(int_to_mini_roman(number: 900) == ""cm"")
assert(int_to_mini_roman(number: 994) == ""cmxciv"")
assert(int_to_mini_roman(number: 1000) == ""m"")"
HumanEval_157,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // 90 တီႇၵရီႇ။ // သၢမ်ၸဵင်ႇဢၼ်မီးသဵၼ်ႈတႃသိုဝ်ႈၼႆႉ ပဵၼ်သၢမ်ၸဵင်ႇဢၼ်မီးသဵၼ်ႈတႃသိုဝ်ႈ ဢမ်ႇၼၼ် // သွင်ၽၢႆႇၼႆႉ ပဵၼ်သၢမ်ၸဵင်ႇတဵမ်တဵမ်၊ ပေႃးဢမ်ႇၼၼ်တႄႉ ၽိတ်း။ // ပေႃးဝႃႈႁဝ်းပၼ်တၢင်းယၢဝ်းသၢမ်ၽၢႆႇၶွင် သၢမ်ၸဵင်ႇၼႆ ၶိုၼ်းဢဝ် true မႃးၶိုၼ်း သင်ၸိူဝ်ႉဝႃႈ သၢမ်ၽၢႆႇၼႆႉ/// >>> right_angle_triangle(a: 3, b: 4, c: 5)
/// true
/// >>> right_angle_triangle(a: 1, b: 2, c: 3)
/// false
func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
","func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {
    let sides = [a, b, c].sorted()
    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(right_angle_triangle(a: 3, b: 4, c: 5) == true)
assert(right_angle_triangle(a: 1, b: 2, c: 3) == false)
assert(right_angle_triangle(a: 10, b: 6, c: 8) == true)
assert(right_angle_triangle(a: 2, b: 2, c: 2) == false)
assert(right_angle_triangle(a: 7, b: 24, c: 25) == true)
assert(right_angle_triangle(a: 10, b: 5, c: 7) == false)
assert(right_angle_triangle(a: 5, b: 12, c: 13) == true)
assert(right_angle_triangle(a: 15, b: 8, c: 17) == true)
assert(right_angle_triangle(a: 48, b: 55, c: 73) == true)
assert(right_angle_triangle(a: 1, b: 1, c: 1) == false)
assert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"
HumanEval_158,shn_Mymr,swift,"
// characters, return the one which comes first in lexicographical order. တူဝ်လိၵ်ႈဢၼ်မႃးဢွၼ်တၢင်းသုတ်း ၼႂ်းသဵၼ်ႈမၢႆပွင်ႈၵႂၢမ်းၼၼ်ႉ ၶိုၼ်းဢဝ်မႃးၶိုၼ်း။သင်ၸိူဝ်ႉဝႃႈ သဵၼ်ႈမၢႆတူဝ်လိၵ်ႈတင်းၼမ် မီးတူဝ်လိၵ်ႈဢၼ်ဢမ်ႇမိူၼ်ၵၼ် ၼမ်သုတ်းၼႆၸိုင်// တီႈၼႂ်း array ၼၼ်ႉ မီးဝႆႉ ၶေႃႈၵႂၢမ်းလၢႆလၢႆၶေႃႈ။ ၶိုၼ်းဢဝ် ၶေႃႈၵႂၢမ်းဢၼ်မီး တူဝ်ၼပ်ႉသုင်သုတ်းၼၼ်ႉ ၶိုၼ်းပၼ်။// တႅမ်ႈပၼ် တူဝ်ဢိင် ဢၼ်ႁပ်ႉလႆႈ တူဝ်ၼပ်ႉဢၼ်ပဵၼ် ထႅဝ်ၸႅၼ်ႇဝႆႉၼၼ်ႉ။/// >>> find_max(words: [""name"", ""of"", ""string""])
/// ""string""
/// >>> find_max(words: [""name"", ""enam"", ""game""])
/// ""enam""
/// >>> find_max(words: [""aaaaaaa"", ""bb"", ""cc""])
/// ""aaaaaaa""
func find_max(words: [String]) -> String {
","func find_max(words: [String]) -> String {
    func uniqueCharacterCount(in word: String) -> Int {
        return Set(word).count
    }
    
    return words.max { a, b in
        let uniqueCountA = uniqueCharacterCount(in: a)
        let uniqueCountB = uniqueCharacterCount(in: b)
        
        if uniqueCountA == uniqueCountB {
            return a > b
        }
        
        return uniqueCountA < uniqueCountB
    } ?? """"
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(find_max(words: [""name"", ""of"", ""string""]) == ""string"")
assert(find_max(words: [""name"", ""enam"", ""game""]) == ""enam"")
assert(find_max(words: [""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa"")
assert(find_max(words: [""abc"", ""cba""]) == ""abc"")
assert(find_max(words: [""play"", ""this"", ""game"", ""of"", ""footbott""]) == ""footbott"")
assert(find_max(words: [""we"", ""are"", ""gonna"", ""rock""]) == ""gonna"")
assert(find_max(words: [""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation"")
assert(find_max(words: [""this"", ""is"", ""a"", ""prrk""]) == ""this"")
assert(find_max(words: [""b""]) == ""b"")
assert(find_max(words: [""play"", ""play"", ""play""]) == ""play"")"
HumanEval_159,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ: // သင်ဝႃႈ ဢမ်ႇမီးၵိူဝ်ဝၢၼ် ဢၼ်ၵိုတ်းဝႆႉတင်းၼမ်ၸိုင် တေၵိၼ်ၵိူဝ်ဝၢၼ် ဢၼ်ၵိုတ်းဝႆႉတင်းမူတ်းသေတႃႉၵေႃႈ တေတိုၵ်ႉၵႂင်ယူႇယဝ်ႉ။// တူဝ်ၼပ်ႉ ၵရူဝ်ႇတိတ်ႉ ဢၼ်ၵိုတ်းဝႆႉ ဝႆးသေ ၵိၼ်ၶဝ်ႈယဝ်ႉ ] // တေလႆႈၶိုၼ်းပၼ် မၢႆလပ်ႉ ၶွင် [ ႁူဝ်ၼပ်ႉ ၵရူဝ်ႇတိတ်ႉ ဢၼ်ၵိၼ်ယဝ်ႉ ၼ်ႂးၶၢဝ်းတၢင်းၵိၼ်ဝၢၼ်၊ ၵူၺ်းၵႃႈ မိူဝ်ႈလဵဝ်ၼႆႉ သူလူဝ်ႇၵိၼ် မၢၵ်ႇၶိူဝ်သူမ်ႈၼမ်လိူဝ်ၼႆႉယဝ်ႉ တႃႇတေႁႂ်ႈၶဝ်ႈဝၼ်းတဵမ်ထူၼ်ႈ။ၸဝ်ႈႁဝ်းၼႆႉ ပဵၼ်ၼူၵ်ႉ ဢၼ်မႆႈၸႂ် ၵိၼ်ၼမ်၊ ၸဝ်ႈႁဝ်းၵေႃႈ လႆႈၵိၼ် မၢၵ်ႇၶိူဝ်သူမ်ႈ မၢင်မဵဝ်းယဝ်ႉ/// >>> eat(number: 5, need: 6, remaining: 10)
/// [11, 4]
/// >>> eat(number: 4, need: 8, remaining: 9)
/// [12, 1]
/// >>> eat(number: 1, need: 10, remaining: 10)
/// [11, 0]
/// >>> eat(number: 2, need: 11, remaining: 5)
/// [7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
func eat(number: Int, need: Int, remaining: Int) -> [Int] {
","func eat(number: Int, need: Int, remaining: Int) -> [Int] {
    let totalNeeded = number + need
    let totalEaten = min(totalNeeded, number + remaining)
    let carrotsLeft = max(0, remaining - (totalEaten - number))
    return [totalEaten, carrotsLeft]
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])
assert(eat(number: 4, need: 8, remaining: 9) == [12, 1])
assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])
assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])
assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])
assert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
HumanEval_160,shn_Mymr,swift,"
// Operator array ၼႆႉ မီး operator တီႈဢေႇသုတ်းမၼ်း 1 တူဝ် လႄႈ operand array ၼႆႉ မီး 2 တူဝ် တီႈဢေႇသုတ်းမၼ်း// Operand ၼႆႉပဵၼ် တူဝ်ၼပ်ႉတဵမ် ဢၼ်ဢမ်ႇၸႂ်ႈ တူဝ်ၼပ်ႉၶိုၵ်ႉတွၼ်းၼၼ်ႉယဝ်ႉ။// တၢင်းယၢဝ်း Operator array ၼႆႉ မၼ်းမိူၼ်ၵၼ်တၢင်း တၢင်းယၢဝ်း Operand array ဢၼ်ထွၼ်ဢွၵ်ႇ 1.// မၢႆတွင်း: // => ၶေႃႈလႆႈၸႂ် = 9 // ၶေႃႈတွပ်ႇ = 2 + 3 * 4 - 5 // array = [2, 3, 4, 5] // operator['+', '*', '-']  ဢၼ်ႁဵတ်းၵၢၼ်// တူဝ်ယၢင်ႇ: // လွင်ႈၽိူမ်ႉထႅမ် (**) // လွင်ႈၸႅၵ်ႇၽႄၸၼ်ႉ ( // ) // လွင်ႈၵုၼ်း (* ) // ထွၼ်ဢွၵ်ႇ ( - ) // ထႅမ်သႂ်ႇ (+ ) // လွင်ႈႁဵတ်းသၢင်ႈ algebra ဢၼ်လမ်ႇလွင်ႈ: // expression လႄႈ ၶိုၼ်းဢဝ် လွင်ႈထတ်းသၢင်ႈ expression ၼႆႉမႃး။ // array ဢၼ်သွင်ၼႆႉ ပဵၼ် array တူဝ်ၼပ်ႉတဵမ် ၸႂ်ႉ array ဢၼ်ပၼ်ဝႆႉသွင်ဢၼ်ၼႆႉသေ ၵေႃႇသၢင်ႈ algebraic // ပၼ်ဝႆႉ တူဝ်ၼပ်ႉသႅၼ်းသွင်ဢၼ် ဢၼ်ပဵၼ် operator လႄႈ operand။ တူဝ်ၼပ်ႉသႅၼ်းဢွၼ်တၢင်းသုတ်းၼႆႉ မီးလွင်ႈႁဵတ်းသၢင်ႈ algebra ဢၼ်လမ်ႇလွင်ႈ လႄႈ func do_algebra(operator: [String], operand: [Int]) -> Int {
","func do_algebra(operator: [String], operand: [Int]) -> Int {
    var result = operand[0]
    let precedence: [String: Int] = [""+"": 1, ""-"": 1, ""*"": 2, ""//"": 2, ""**"": 3]
    
    var opStack: [String] = []
    var numStack: [Int] = [result]
    
    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {
        switch op {
        case ""+"":
            return a + b
        case ""-"":
            return a - b
        case ""*"":
            return a * b
        case ""//"":
            return a / b
        case ""**"":
            return Int(pow(Double(a), Double(b)))
        default:
            fatalError(""Unsupported operator: \(op)"")
        }
    }
    
    for i in 0..<operator.count {
        let currentOp = `operator`[i]
        let currentNum = operand[i + 1]
        
        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {
            opStack.removeLast()
            let b = numStack.removeLast()
            let a = numStack.removeLast()
            numStack.append(applyOperator(lastOp, b, a))
        }
        
        opStack.append(currentOp)
        numStack.append(currentNum)
    }
    
    while let lastOp = opStack.popLast() {
        let b = numStack.removeLast()
        let a = numStack.removeLast()
        numStack.append(applyOperator(lastOp, b, a))
    }
    
    return numStack.first!
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(do_algebra(operator: [""**"", ""*"", ""+""], operand: [2, 3, 4, 5]) == 37)
assert(do_algebra(operator: [""+"", ""*"", ""-""], operand: [2, 3, 4, 5]) == 9)
assert(do_algebra(operator: [""//"", ""*""], operand: [7, 3, 4]) == 8)"
HumanEval_161,shn_Mymr,swift,"
// တူဝ်ယၢင်ႇ // တူဝ်ဢိင်ၼႆႉ တေလႆႈၶိုၼ်းပၼ် တူဝ်ၵိုတ်းမၼ်းမႃး// သင်ဝႃႈ string ဢမ်ႇမီးတူဝ်လိၵ်ႈသင်ၼႆ ၶၢႆႉၶိုၼ်း string ၼၼ်ႉ။ပေႃးဢမ်ႇၼၼ် ႁႂ်ႈမၼ်းမီးၼင်ႇၵဝ်ႇ// သင်ဝႃႈ s[i] ပဵၼ်တူဝ်လိၵ်ႈၼႆ ၶၢႆႉတူဝ်လိၵ်ႈမၼ်း လုၵ်ႉတီႈတႂ်ႈၵႂႃႇၼိူဝ် ဢမ်ႇၼၼ် vice versa၊ // လႆႈပၼ် string s. /// >>> solve(s: ""1234"")
/// ""4321""
/// >>> solve(s: ""ab"")
/// ""AB""
/// >>> solve(s: ""#a@C"")
/// ""#A@c""
func solve(s: String) -> String {
","func solve(s: String) -> String {
    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {
        return String(s.reversed())
    }
    
    var result = """"
    for char in s {
        if char.isLetter {
            if char.isLowercase {
                result.append(char.uppercased())
            } else {
                result.append(char.lowercased())
            }
        } else {
            result.append(char)
        }
    }
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(solve(s: ""AsDf"") == ""aSdF"")
assert(solve(s: ""1234"") == ""4321"")
assert(solve(s: ""ab"") == ""AB"")
assert(solve(s: ""#a@C"") == ""#A@c"")
assert(solve(s: ""#AsdfW^45"") == ""#aSDFw^45"")
assert(solve(s: ""#6@2"") == ""2@6#"")
assert(solve(s: ""#$a^D"") == ""#$A^d"")
assert(solve(s: ""#ccc"") == ""#CCC"")"
HumanEval_162,shn_Mymr,swift,"
// သင်ဝႃႈ 'text' ၼႆႉပဵၼ် ထႅဝ်လိၵ်ႈဢၼ်ဢမ်ႇမီးတူဝ်ၼၼ်ႉ ၶိုၼ်းဢဝ် nil ၼၼ်ႉမႃး။// ပၼ်ဝႆႉ သၢႆထႅဝ် 'text' ၼၼ်ႉ၊ ၶိုၼ်းဢဝ် md5 hash equivalent သၢႆထႅဝ်မၼ်းၼၼ်ႉ။/// >>> string_to_md5(text: ""Hello world"")
/// ""3e25960a79dbc69b674cd4ec67a72c62""
func string_to_md5(text: String) -> String? {
","import Foundation
import CommonCrypto

func string_to_md5(text: String) -> String? {
    guard !text.isEmpty else { return nil }
    
    let length = Int(CC_MD5_DIGEST_LENGTH)
    let messageData = text.data(using: .utf8)!
    var digestData = Data(count: length)
    
    _ = digestData.withUnsafeMutableBytes { digestBytes in
        messageData.withUnsafeBytes { messageBytes in
            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)
        }
    }
    
    return digestData.map { String(format: ""%02hhx"", $0) }.joined()
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(string_to_md5(text: ""Hello world"") == ""3e25960a79dbc69b674cd4ec67a72c62"")
assert(string_to_md5(text: """") == nil)
assert(string_to_md5(text: ""A B C"") == ""0ef78513b0cb8cef12743f5aeb35f888"")
assert(string_to_md5(text: ""password"") == ""5f4dcc3b5aa765d61d8327deb882cf99"")"
HumanEval_163,shn_Mymr,swift,"
တူဝ်ယၢင်ႇမၼ်း-// လႄႈ b၊ ၶိုၼ်ႈမႃးၸွမ်းၶၵ်ႉတွၼ်ႈ။ // ပေႃးပၼ်တူဝ်ၼပ်ႉတဵမ်သႂ် သွင်တူဝ် a လႄႈ b ၼႆ ၶိုၼ်းဢဝ်တူဝ်ၼပ်ႉဢၼ်ပဵၼ်ၸဵင်ႇပဵင်းၵၼ် ၼႂ်းၵႄႈ a /// >>> generate_integers(a: 2, b: 8)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 8, b: 2)
/// [2, 4, 6, 8]
/// >>> generate_integers(a: 10, b: 14)
/// [] as [Int]
func generate_integers(a: Int, b: Int) -> [Int] {
","func generate_integers(a: Int, b: Int) -> [Int] {
    let lower = min(a, b)
    let upper = max(a, b)
    var result = [Int]()
    
    for number in lower...upper {
        if number % 2 == 0 {
            result.append(number)
        }
    }
    
    return result
}","}


func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {
    if left.count != right.count {
        return false
    }
    for (l, r) in zip(left, right) {
        if l != r {
            return false
        }
    }
    return true
}
            
assert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])
assert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])
assert(generate_integers(a: 17, b: 89) == [] as [Int])"
