[{"task_id":"HumanEval_0","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ প্ৰদান কৰা থ্ৰেশ্বল। \/\/ এটা সংখ্যাৰ সজ্জাত, দুটা সংখ্যাৰ মাজত তকৈ বেছি দূৰত্ব আছে নেকি পৰীক্ষা কৰক\/\/\/ >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)\n\/\/\/ true\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n","canonical_solution":"func has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n    let sortedNumbers = numbers.sorted()\n    for i in 0..<sortedNumbers.count - 1 {\n        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"},{"task_id":"HumanEval_1","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ইনপুট ষ্ট্ৰিংৰ যিকোনো স্পেচ অৱজ্ঞা কৰক।\/\/ পৃথক গোটবোৰ ভাৰসাম্যপূৰ্ণ (প্ৰতিটো মুকলি ব্ৰেকেট সঠিকভাৱে বন্ধ) আৰু ইজনে সিজনৰ ভিতৰত নিস্তদ্ধ নহয় ।\/\/ সেইবোৰ গোটক পৃথক শাৰীলৈ পৃথক কৰক আৰু সেইবোৰৰ এৰে ঘূৰাই দিয়ক।\/\/ এই ফাংচনৰ ইনপুট হৈছে এটা ষ্ট্ৰিং য'ত বহুতো গোটৰ এনষ্টেড প্যাৰেণ্টেজ থাকে। আপোনাৰ লক্ষ্য হ'ল \/\/\/ >>> separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\")\n\/\/\/ [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string: String) -> [String] {\n","canonical_solution":"func separate_paren_groups(paren_string: String) -> [String] {\n    var results = [String]()\n    var currentGroup = \"\"\n    var balance = 0\n\n    for char in paren_string {\n        \/\/ Ignore spaces\n        if char == \" \" {\n            continue\n        }\n        \n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\n        currentGroup.append(char)\n\n        if balance == 0 && !currentGroup.isEmpty {\n            results.append(currentGroup)\n            currentGroup = \"\"\n        }\n    }\n    \n    return results\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"},{"task_id":"HumanEval_2","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ সংখ্যাৰ দশমিক অংশ ঘূৰাই দিব. \/\/ (বাকি অংশটো সদায় ১ তকৈ সৰু) ।\/\/ আৰু পূৰ্ণসংখ্যাৰ অংশ (প্ৰদত্ত সংখ্যাতকৈ ডাঙৰ পূৰ্ণসংখ্যাৰ অংশ) আৰু দশমিক সংখ্যা \/\/ এটা ধনাত্মক ভ্ৰাম্যমাণ বিন্দু সংখ্যা দিয়া হ'লে, ইয়াক লৈ বিভাজিত কৰিব পাৰি।\/\/\/ >>> truncate_number(number: 3.5)\n\/\/\/ 0.5\nfunc truncate_number(number: Double) -> Double {\n","canonical_solution":"func truncate_number(number: Double) -> Double {\n    return number - Double(Int(number))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"},{"task_id":"HumanEval_3","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ তেতিয়া ফাংচন true ৰিটাৰ্ণ কৰিব লাগে অন্যথা false ৰিটাৰ্ণ কৰিব লাগেআপোনাৰ কাম হ'ল যিকোনো মুহূৰ্তত একাউণ্টৰ বেলেন্স শূন্যৰ তললৈ নামি যায়, আৰু আপুনি এটা বেংক একাউণ্টত জমা আৰু উঠাই লোৱাৰ বিভিন্ন ধৰণৰ কাৰ্য্য প্ৰদান কৰা হয় যিটো  ৰে আৰম্ভ হয়।\/\/\/ >>> below_zero(operations: [1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(operations: [1, 2, -4, 5])\n\/\/\/ true\nfunc below_zero(operations: [Int]) -> Bool {\n","canonical_solution":"func below_zero(operations: [Int]) -> Bool {\n    var balance = 0\n    for operation in operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_zero(operations: [] as [Int]) == false)\nassert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)\nassert(below_zero(operations: [1, 2, -4, 5, 6]) == true)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)\nassert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"},{"task_id":"HumanEval_4","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ MAD = গড় । x - x_mean ।\/\/ উপাদান আৰু এটা কেন্দ্ৰ বিন্দু (এই ক্ষেত্ৰত গড়): \/\/ গড় নিখুঁত বিচ্যুতি হ'ল প্ৰতিটো এই ডাটা ছেটৰ গড়ৰ আশে-পাশে।\/\/ এটা নিৰ্দিষ্ট ইনপুট নম্বৰ এৰেজৰ বাবে, গড় নিখুঁত বিচ্যুতি গণনা কৰক ।\/\/\/ >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n","canonical_solution":"func mean_absolute_deviation(numbers: [Double]) -> Double {\n    guard !numbers.isEmpty else { return 0.0 }\n    \n    let mean = numbers.reduce(0.0, +) \/ Double(numbers.count)\n    let absoluteDifferences = numbers.map { abs($0 - mean) }\n    let mad = absoluteDifferences.reduce(0.0, +) \/ Double(absoluteDifferences.count)\n    \n    return mad\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"},{"task_id":"HumanEval_5","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ইনপুট এৰেজ ∀numbers ৰ প্ৰতিটো দুটা ক্ৰমাগত উপাদানৰ মাজত এটা সংখ্যা 'delimeter' সন্নিৱিষ্ট কৰক' \/\/\/ >>> intersperse(numbers: [] as [Int], delimeter: 4)\n\/\/\/ [] as [Int]\n\/\/\/ >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\/\/\/ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n","canonical_solution":"func intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    \n    var result: [Int] = []\n    \n    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n    }\n    \n    \/\/ Remove the last added delimiter\n    result.removeLast()\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"},{"task_id":"HumanEval_6","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপে (() (()) ৰ গঁড়ৰ সংখ্যা সৰ্বাধিক দুটাকৈ স্তৰ আছে যদিও ((())) ৰ তিনিটা স্তৰ আছে। \/\/ গ্ৰুপৰ প্ৰত্যেকৰ বাবে, বন্ধনীসমূহৰ গভীৰতম স্তৰৰ নিস্তাৰ কৰক।\/\/ এই ফাংচনৰ ইনপুট হৈছে স্পেচৰে পৃথক কৰা ব্ৰেণ্টেজৰ বাবে একাধিক গোট প্ৰতিনিধিত্ব কৰা এটা ষ্ট্ৰিং।\/\/\/ >>> parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\")\n\/\/\/ [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n","canonical_solution":"func parse_nested_parens(paren_string: String) -> [Int] {\n    let groups = paren_string.split(separator: \" \")\n    var depths: [Int] = []\n    \n    for group in groups {\n        var maxDepth = 0\n        var currentDepth = 0\n        \n        for char in group {\n            if char == \"(\" {\n                currentDepth += 1\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == \")\" {\n                currentDepth -= 1\n            }\n        }\n        \n        depths.append(maxDepth)\n    }\n    \n    return depths\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])"},{"task_id":"HumanEval_7","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা ইনপুট ছেটত কেৱল সেইবোৰ ছেট ফিল্টাৰ কৰক যিবোৰত এটা উপ-ছেট থাকে ।\/\/\/ >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n\/\/\/ [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n","canonical_solution":"func filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter { $0.contains(substring) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"},{"task_id":"HumanEval_8","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ শূন্য যোগফলটো 0 আৰু শূন্য উৎপাদিত 1 হ'ব লাগে।\/\/ এটা অখণ্ড সংখ্যাৰ অ্যারেৰ বাবে, এটা সমষ্টি আৰু এটা এৰেৰ সকলো অখণ্ড সংখ্যাৰ উৎপাদিত এটা টুপল ঘূৰাই দিব.\/\/\/ >>> sum_product(numbers: [] as [Int])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(numbers: [1, 2, 3, 4])\n\/\/\/ (10, 24)\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n","canonical_solution":"func sum_product(numbers: [Int]) -> (Int, Int) {\n    let sum = numbers.reduce(0, +)\n    let product = numbers.reduce(1, *)\n    return (sum, product)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_product(numbers: [] as [Int]) == (0, 1))\nassert(sum_product(numbers: [1, 1, 1]) == (3, 1))\nassert(sum_product(numbers: [100, 0]) == (100, 0))\nassert(sum_product(numbers: [3, 5, 7]) == (15, 105))\nassert(sum_product(numbers: [10]) == (10, 10))"},{"task_id":"HumanEval_9","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ক্ৰমত। \/\/ এটা নিৰ্দিষ্ট সংখ্যাৰ এৰেজৰ পৰা এটা নিৰ্দিষ্ট মুহূৰ্তলৈকে পোৱা ৰোলিং সৰ্বাধিক উপাদানৰ এৰেজ সৃষ্টি কৰা ।\/\/\/ >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])\n\/\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int]) -> [Int] {\n","canonical_solution":"func rolling_max(numbers: [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax: Int? = nil\n    for number in numbers {\n        if let max = currentMax {\n            currentMax = max > number ? max : number\n        } else {\n            currentMax = number\n        }\n        result.append(currentMax!)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"},{"task_id":"HumanEval_10","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ - এটা ষ্ট্ৰিং উপসৰ্গ ষ্ট্ৰিংৰ শেষত যোগ কৰক যিটো পলিণ্ড্ৰোমিক উপসৰ্গৰ আগতে আহে।\/\/ - এটা পলিণ্ড্ৰ'ম থকা যোগান ধৰা স্ট্ৰিংৰ দীৰ্ঘতম পোষ্টফিক্সটো বিচাৰি উলিওৱা ।\/\/ অ্যালগৰিদমৰ ধাৰণা সহজ: \/\/ এটা যোগান ধৰা স্ট্ৰিংৰ সৈতে আৰম্ভ হোৱা আটাইতকৈ সৰু পালিনড্ৰমটো বিচাৰক।\/\/\/ >>> make_palindrome(string: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> make_palindrome(string: \"cat\")\n\/\/\/ \"catac\"\n\/\/\/ >>> make_palindrome(string: \"cata\")\n\/\/\/ \"catac\"\nfunc make_palindrome(string: String) -> String {\n","canonical_solution":"func make_palindrome(string: String) -> String {\n    func isPalindrome(_ s: String) -> Bool {\n        return s == String(s.reversed())\n    }\n    \n    if string.isEmpty || isPalindrome(string) {\n        return string\n    }\n    \n    for i in stride(from: string.count, through: 0, by: -1) {\n        let suffixIndex = string.index(string.startIndex, offsetBy: i)\n        let suffix = String(string[suffixIndex..<string.endIndex])\n        if isPalindrome(suffix) {\n            let prefix = String(string[string.startIndex..<suffixIndex])\n            return string + String(prefix.reversed())\n        }\n    }\n    \n    return string\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"},{"task_id":"HumanEval_11","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এই ইনপুটসমূহত বাইনেৰী XOR প্ৰদৰ্শন কৰক আৰু ফলাফলটো এটা ষ্ট্ৰিং হিচাপে উভতাই দিয়ক।\/\/ ইনপুট দুটা ষ্ট্ৰিং a আৰু b যিটো কেৱল 1s আৰু 0s ৰ দ্বাৰা গঠিত।\/\/\/ >>> string_xor(a: \"010\", b: \"110\")\n\/\/\/ \"100\"\nfunc string_xor(a: String, b: String) -> String {\n","canonical_solution":"func string_xor(a: String, b: String) -> String {\n    let charactersA = Array(a)\n    let charactersB = Array(b)\n    var result = \"\"\n\n    for i in 0..<charactersA.count {\n        let bitA = charactersA[i]\n        let bitB = charactersB[i]\n        \n        if bitA != bitB {\n            result.append(\"1\")\n        } else {\n            result.append(\"0\")\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"},{"task_id":"HumanEval_12","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ একে দীঘল শাৰী। ইনপুট এৰে খালী হ'লে শূন্য ঘূৰাই আনে।\/\/ অংকন সূত্ৰৰ এটা সজ্জাৰ ভিতৰত দীৰ্ঘতমটো ঘূৰাই দিব। বহুতো অংকন সূত্ৰৰ ক্ষেত্ৰত প্ৰথমটো ঘূৰাই দিব।\/\/\/ >>> longest(strings: [] as [String])\n\/\/\/ nil\n\/\/\/ >>> longest(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"a\"\n\/\/\/ >>> longest(strings: [\"a\", \"bb\", \"ccc\"])\n\/\/\/ \"ccc\"\nfunc longest(strings: [String]) -> String? {\n","canonical_solution":"func longest(strings: [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n    for string in strings {\n        if string.count > longestString.count {\n            longestString = string\n        }\n    }\n    return longestString\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"},{"task_id":"HumanEval_13","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ দুটা পূৰ্ণসংখ্যাৰ a আৰু b ৰ সৰ্ববৃহৎ সাধাৰণ বিভাজক ঘূৰাই আনা ।\/\/\/ >>> greatest_common_divisor(a: 3, b: 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(a: 25, b: 15)\n\/\/\/ 5\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n","canonical_solution":"func greatest_common_divisor(a: Int, b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return greatest_common_divisor(a: b, b: a % b)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(greatest_common_divisor(a: 3, b: 7) == 1)\nassert(greatest_common_divisor(a: 10, b: 15) == 5)\nassert(greatest_common_divisor(a: 49, b: 14) == 7)\nassert(greatest_common_divisor(a: 144, b: 60) == 12)"},{"task_id":"HumanEval_14","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ইনপুট ষ্ট্ৰিংৰ আটাইতকৈ দীঘল প্ৰিফিক্সৰ পৰা আটাইতকৈ সৰু প্ৰিফিক্সৰ এৰেজ ঘূৰাই আনে ।\/\/\/ >>> all_prefixes(string: \"abc\")\n\/\/\/ [\"a\", \"ab\", \"abc\"]\nfunc all_prefixes(string: String) -> [String] {\n","canonical_solution":"func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] = []\n    for i in 1...string.count {\n        let prefix = String(string.prefix(i))\n        prefixes.append(prefix)\n    }\n    return prefixes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"},{"task_id":"HumanEval_15","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ 0 ৰ পৰা n লৈকে অন্তৰ্ভুক্ত কৰি থকা স্থান-সীমাবদ্ধ সংখ্যা থকা এটা স্ট্ৰিং ঘূৰাই আনে। \/\/\/ >>> string_sequence(n: 0)\n\/\/\/ \"0\"\n\/\/\/ >>> string_sequence(n: 5)\n\/\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n: Int) -> String {\n","canonical_solution":"func string_sequence(n: Int) -> String {\n    return (0...n).map { String($0) }.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_sequence(n: 0) == \"0\")\nassert(string_sequence(n: 3) == \"0 1 2 3\")\nassert(string_sequence(n: 10) == \"0 1 2 3 4 5 6 7 8 9 10\")"},{"task_id":"HumanEval_16","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা ষ্ট্ৰিং দিয়া হৈছে, কিমানটা পৃথক বৰ্ণ (কেছ নিৰ্বিশেষে) ইয়াত আছে জানক \/\/\/ >>> count_distinct_characters(string: \"xyzXYZ\")\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(string: \"Jerry\")\n\/\/\/ 4\nfunc count_distinct_characters(string: String) -> Int {\n","canonical_solution":"func count_distinct_characters(string: String) -> Int {\n    let lowercasedString = string.lowercased()\n    let distinctCharacters = Set(lowercasedString)\n    return distinctCharacters.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_distinct_characters(string: \"\") == 0)\nassert(count_distinct_characters(string: \"abcde\") == 5)\nassert(count_distinct_characters(string: \"abcdecadeCADE\") == 5)\nassert(count_distinct_characters(string: \"aaaaAAAAaaaa\") == 1)\nassert(count_distinct_characters(string: \"Jerry jERRY JeRRRY\") == 5)"},{"task_id":"HumanEval_17","nl":"asm_Beng","pl":"swift","prompt":"\n' 'কোৱাৰ্টাৰ নোট, এটা বীটত শেষ হয়''অ' হ'ব' - আধা নোট, দুটা বীট থাকে\/\/ 'অ' - সম্পূৰ্ণ নোট, চাৰিটা বীট থাকে এইখন কিংবদন্তিঃশেষৰটো নহয়।আপোনাৰ কাম হ'ল এই শাৰীটো বিশ্লেষণ কৰা আৰু প্ৰত্যেকটো কিমানবাৰ হ'ব তাৰ সৈতে সামঞ্জস্য থকা পূৰ্ণসংখ্যাৰ এটা শাৰী ঘূৰাই দিয়া।\/\/ এই ফাংচনৰ ইনপুট হৈছে এটা বিশেষ ASCII ফৰ্মেটত সংগীত নোট প্ৰতিনিধিত্ব কৰা এটা শাৰী।\/\/\/ >>> parse_music(music_string: \"o o| .| o| o| .| .| .| .| o o\")\n\/\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string: String) -> [Int] {\n","canonical_solution":"func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.split(separator: \" \")\n    var beats: [Int] = []\n    \n    for note in notes {\n        switch note {\n        case \"o\":\n            beats.append(4)\n        case \"o|\":\n            beats.append(2)\n        case \".|\":\n            beats.append(1)\n        default:\n            continue\n        }\n    }\n    \n    return beats\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"},{"task_id":"HumanEval_18","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা নিৰ্দিষ্ট ছাবষ্ট্ৰিংৰ প্ৰাথমিক ষ্ট্ৰিংত কিমানবাৰ পোৱা যায় সেয়া বিচাৰক। ওভাৰল্যাপিং কেচবোৰ গণনা কৰক।\/\/\/ >>> how_many_times(string: \"\", substring: \"a\")\n\/\/\/ 0\n\/\/\/ >>> how_many_times(string: \"aaa\", substring: \"a\")\n\/\/\/ 3\n\/\/\/ >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n\/\/\/ 3\nfunc how_many_times(string: String, substring: String) -> Int {\n","canonical_solution":"func how_many_times(string: String, substring: String) -> Int {\n    guard !substring.isEmpty else { return 0 }\n    \n    var count = 0\n    var startIndex = string.startIndex\n    \n    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {\n        count += 1\n        startIndex = string.index(after: range.lowerBound)\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"},{"task_id":"HumanEval_19","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ সংখ্যাৰ সৈতে সৰুৰ পৰা ডাঙৰলৈ শৃংখলাটো ঘূৰাই আনে ।\/\/ বৈধ বিকল্পসমূহ হ'ল 'শূন্য', 'এটা', 'দুটা', 'তিনি', 'চাৰি', 'পাঁচ', 'ছয়', 'সাত', 'আঠ' আৰু 'নয়'।\/\/ ইনপুট হৈছে 'শূন্য'ৰ পৰা 'ন'লৈ সংখ্যাসমূহৰ এটা স্থান-সীমাবদ্ধ শৃংখলা।\/\/\/ >>> sort_numbers(numbers: \"three one five\")\n\/\/\/ \"one three five\"\nfunc sort_numbers(numbers: String) -> String {\n","canonical_solution":"func sort_numbers(numbers: String) -> String {\n    \/\/ Mapping of word numbers to digits\n    let numberWords: [String: Int] = [\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    ]\n\n    \/\/ Split the input string into words\n    let words = numbers.split(separator: \" \")\n\n    \/\/ Sort the words based on their corresponding number values\n    let sortedWords = words.sorted { \n        numberWords[String($0)]! < numberWords[String($1)]! \n    }\n\n    \/\/ Join the sorted words back into a single string\n    return sortedWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_numbers(numbers: \"\") == \"\")\nassert(sort_numbers(numbers: \"three\") == \"three\")\nassert(sort_numbers(numbers: \"three five nine\") == \"three five nine\")\nassert(sort_numbers(numbers: \"five zero four seven nine eight\") == \"zero four five seven eight nine\")\nassert(sort_numbers(numbers: \"six five four three two one zero\") == \"zero one two three four five six\")"},{"task_id":"HumanEval_20","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অন্যান্য আৰু সেইবোৰ ক্ৰমে ঘূৰাই দিব (সৰু সংখ্যা, ডাঙৰ সংখ্যা) ।\/\/ প্ৰদান কৰা সংখ্যাৰ এটা এৰেজ (অন্তত দুটাৰ দৈৰ্ঘ্যৰ) ৰ পৰা প্ৰতিটো সংখ্যাৰ সৰ্বাধিক কাষৰ দুটা নিৰ্বাচন কৰি উভতাই দিব \/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n","canonical_solution":"func find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    \/\/ Sort the array to bring closest numbers next to each other\n    let sortedNumbers = numbers.sorted()\n    \n    \/\/ Initialize variables to keep track of the smallest difference and the pair\n    var minDifference = Double.greatestFiniteMagnitude\n    var closestPair: (Double, Double) = (0.0, 0.0)\n    \n    \/\/ Iterate over the sorted numbers to find the smallest difference\n    for i in 0..<sortedNumbers.count - 1 {\n        let num1 = sortedNumbers[i]\n        let num2 = sortedNumbers[i + 1]\n        let difference = abs(num1 - num2)\n        \n        if difference < minDifference {\n            minDifference = difference\n            closestPair = (num1, num2)\n        }\n    }\n    \n    return closestPair\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"},{"task_id":"HumanEval_21","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ যাতে আটাইতকৈ সৰু সংখ্যাটো 0 হয় আৰু আটাইতকৈ ডাঙৰটো 1 হয় ।\/\/ সংখ্যাৰ এটা অ্যারে (অন্তত দুটা উপাদানৰ), দিয়া হৈছে, সেই অ্যারেৰ এটা লিনিয়াৰ ট্রান্সফর্ম প্রয়োগ কৰা,\/\/\/ >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n","canonical_solution":"func rescale_to_unit(numbers: [Double]) -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    \n    let minValue = numbers.min()!\n    let maxValue = numbers.max()!\n    let range = maxValue - minValue\n    \n    guard range != 0 else {\n        return numbers.map { _ in 0.0 }\n    }\n    \n    return numbers.map { ($0 - minValue) \/ range }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"},{"task_id":"HumanEval_22","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ কেৱল পূৰ্ণসংখ্যাৰ বাবে যিকোনো swiftthon মানৰ দিয়া এৰেজ ফিল্টাৰ কৰক ।\/\/\/ >>> filter_integers(values: [\"a\", 3.14, 5])\n\/\/\/ [5]\n\/\/\/ >>> filter_integers(values: [1, 2, 3, \"abc\", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])\n\/\/\/ [1, 2, 3]\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n","canonical_solution":"func filter_integers(values: [AnyHashable]) -> [Int] {\n    return values.compactMap { $0 as? Int }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])\nassert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, \"adasd\"]) == [4, 9])\nassert(filter_integers(values: [3, \"c\", 3, 3, \"a\", \"b\"]) == [3, 3, 3])"},{"task_id":"HumanEval_23","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ প্ৰদান কৰা স্ট্ৰিংৰ দৈৰ্ঘ্য ঘূৰাই আনা ।\/\/\/ >>> strlen(string: \"\")\n\/\/\/ 0\n\/\/\/ >>> strlen(string: \"abc\")\n\/\/\/ 3\nfunc strlen(string: String) -> Int {\n","canonical_solution":"func strlen(string: String) -> Int {\n    return string.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strlen(string: \"\") == 0)\nassert(strlen(string: \"x\") == 1)\nassert(strlen(string: \"asdasnakj\") == 9)"},{"task_id":"HumanEval_24","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা নিৰ্দিষ্ট সংখ্যাৰ বাবে n, আটাইতকৈ ডাঙৰ সংখ্যাটো বিচাৰক যি n তকৈ সৰু, আৰু ইয়াক সমান ভাঙি দিব পাৰি।\/\/\/ >>> largest_divisor(n: 15)\n\/\/\/ 5\nfunc largest_divisor(n: Int) -> Int {\n","canonical_solution":"func largest_divisor(n: Int) -> Int {\n    for i in stride(from: n \/ 2, to: 0, by: -1) {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_divisor(n: 3) == 1)\nassert(largest_divisor(n: 7) == 1)\nassert(largest_divisor(n: 10) == 5)\nassert(largest_divisor(n: 100) == 50)\nassert(largest_divisor(n: 49) == 7)"},{"task_id":"HumanEval_25","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ইনপুট নম্বৰটো সকলো কাৰকৰ উৎপাদনৰ সমান হ'ব লাগে ।\/\/ প্ৰতিটো কাৰকক গুণন পদ্ধতিত প্ৰদৰ্শিত হোৱা সংখ্যাৰ সৈতে মিলি সংখ্যাৰ সংখ্যাৰ সৈতে সংযুক্ত কৰা উচিত।\/\/ এটা অখণ্ড সংখ্যাৰ অগ্ৰগণ্য গুণকৰ অংকন সৰুৰ পৰা ডাঙৰলৈ ক্ৰম অনুসাৰে ঘূৰাই আনে।\/\/\/ >>> factorize(n: 8)\n\/\/\/ [2, 2, 2]\n\/\/\/ >>> factorize(n: 25)\n\/\/\/ [5, 5]\n\/\/\/ >>> factorize(n: 70)\n\/\/\/ [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n","canonical_solution":"func factorize(n: Int) -> [Int] {\n    guard n > 1 else { return [] }\n    var number = n\n    var factors: [Int] = []\n    var divisor = 2\n    \n    while number >= divisor {\n        while number % divisor == 0 {\n            factors.append(divisor)\n            number \/= divisor\n        }\n        divisor += 1\n    }\n    \n    return factors\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"},{"task_id":"HumanEval_26","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ইনপুটৰ দৰে এলিমেণ্টৰ বাম ক্ৰমটো একেই ৰাখক।\/\/ এটা সম্পূৰ্ণ সংখ্যাৰ সজ্জাত, এটাতকৈ অধিকবাৰ হোৱা সকলোবোৰ উপাদান আঁতৰাওক।\/\/\/ >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])\n\/\/\/ [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n","canonical_solution":"func remove_duplicates(numbers: [Int]) -> [Int] {\n    var elementCount = [Int: Int]()\n    for number in numbers {\n        elementCount[number, default: 0] += 1\n    }\n    return numbers.filter { elementCount[$0] == 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"},{"task_id":"HumanEval_27","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা নিৰ্দিষ্ট ষ্ট্ৰিংৰ বাবে, সৰু আখৰবোৰ ডাঙৰ আখৰলৈ আৰু ডাঙৰ আখৰবোৰ সৰু আখৰলৈ ঘূৰাই লওক।\/\/\/ >>> flip_case(string: \"Hello\")\n\/\/\/ \"hELLO\"\nfunc flip_case(string: String) -> String {\n","canonical_solution":"func flip_case(string: String) -> String {\n    return String(string.map { character in\n        if character.isLowercase {\n            return character.uppercased()\n        } else if character.isUppercase {\n            return character.lowercased()\n        } else {\n            return String(character)\n        }\n    }.joined())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(flip_case(string: \"\") == \"\")\nassert(flip_case(string: \"Hello!\") == \"hELLO!\")\nassert(flip_case(string: \"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")"},{"task_id":"HumanEval_28","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা শাৰীলৈ শাৰীসমূহৰ সংযুক্ত বিন্যাস \/\/\/ >>> concatenate(strings: [] as [String])\n\/\/\/ \"\"\n\/\/\/ >>> concatenate(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"abc\"\nfunc concatenate(strings: [String]) -> String {\n","canonical_solution":"func concatenate(strings: [String]) -> String {\n    return strings.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(concatenate(strings: [] as [String]) == \"\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\"]) == \"xyz\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\", \"w\", \"k\"]) == \"xyzwk\")"},{"task_id":"HumanEval_29","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা নিৰ্দিষ্ট উপসৰ্গৰে আৰম্ভ হোৱা শাৰীবোৰৰ বাবেহে ইনপুট শাৰী ফিল্টাৰ কৰক।\/\/\/ >>> filter_by_prefix(strings: [] as [String], prefix: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_prefix(strings: [\"abc\", \"bcd\", \"cde\", \"array\"], prefix: \"a\")\n\/\/\/ [\"abc\", \"array\"]\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n","canonical_solution":"func filter_by_prefix(strings: [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"},{"task_id":"HumanEval_30","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অংকনক্ষেত্ৰৰ কেৱল ধনাত্মক সংখ্যাহে ঘূৰাই আনে।\/\/\/ >>> get_positive(l: [-1, 2, -4, 5, 6])\n\/\/\/ [2, 5, 6]\n\/\/\/ >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunc get_positive(l: [Int]) -> [Int] {\n","canonical_solution":"func get_positive(l: [Int]) -> [Int] {\n    return l.filter { $0 > 0 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])\nassert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\nassert(get_positive(l: [-1, -2]) == [] as [Int])\nassert(get_positive(l: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_31","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা অংক অংক হ'লে সত্য আৰু অন্যথা মিছা প্ৰত্যাহাৰ কৰক।\/\/\/ >>> is_prime(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 101)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 11)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 61)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 1)\n\/\/\/ false\nfunc is_prime(n: Int) -> Bool {\n","canonical_solution":"func is_prime(n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false\n    }\n    var i = 5\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_prime(n: 6) == false)\nassert(is_prime(n: 101) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 13441) == true)\nassert(is_prime(n: 61) == true)\nassert(is_prime(n: 4) == false)\nassert(is_prime(n: 1) == false)\nassert(is_prime(n: 5) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 17) == true)\nassert(is_prime(n: 85) == false)\nassert(is_prime(n: 77) == false)\nassert(is_prime(n: 255379) == false)"},{"task_id":"HumanEval_33","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ l ৰ সংশ্লিষ্ট সূচকৰ মানসমূহলৈ, কিন্তু ছাৰ্ট কৰা হৈছে।\/\/ l' ই 3 ৰে বিভাজ্য নোহোৱা সূচকসমূহত l ৰ সৈতে একে, যদিও 3 ৰে বিভাজ্য সূচকসমূহত ইয়াৰ মান সমান হয় ।\/\/ এই ফাংচনে এটা এৰেজ লয় আৰু এটা এৰেজ ঘূৰাই আনে l' যেনে যে\/\/\/ >>> sort_third(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])\n\/\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunc sort_third(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_third(l: [Int]) -> [Int] {\n    \/\/ Collect indices and their values where index is divisible by 3\n    var divisibleByThreeValues: [(index: Int, value: Int)] = []\n    for (index, value) in l.enumerated() where index % 3 == 0 {\n        divisibleByThreeValues.append((index, value))\n    }\n    \n    \/\/ Sort the values that were at the indices divisible by 3\n    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()\n    \n    \/\/ Create a mutable copy of original array to modify\n    var result = l\n    \n    \/\/ Replace the sorted values back into their original indices\n    for (i, sortedValue) in sortedValues.enumerated() {\n        result[divisibleByThreeValues[i].index] = sortedValue\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])\nassert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])\nassert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])\nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"},{"task_id":"HumanEval_34","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এটা এৰেজত ছৰ্ট কৰা অনন্য উপাদানসমূহ ঘূৰাই আনে \/\/\/ >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [0, 2, 3, 5, 9, 123]\nfunc unique(l: [Int]) -> [Int] {\n","canonical_solution":"func unique(l: [Int]) -> [Int] {\n    return Array(Set(l)).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"},{"task_id":"HumanEval_35","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অংকনক্ষেত্ৰৰ সৰ্বোচ্চ উপাদান ঘূৰাই আনে।\/\/\/ >>> max_element(l: [1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfunc max_element(l: [Int]) -> Int {\n","canonical_solution":"func max_element(l: [Int]) -> Int {\n    guard let max = l.max() else {\n        fatalError(\"Array should not be empty\")\n    }\n    return max\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"},{"task_id":"HumanEval_36","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ 11 বা 13 ৰ দ্বাৰা বিভাজ্য n ৰ কম সংখ্যক পূৰ্ণ সংখ্যাত 7 সংখ্যাটো প্ৰকাশ হোৱা সংখ্যাৰ সংখ্যা ঘূৰাই দিব. \/\/\/ >>> fizz_buzz(n: 50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(n: 78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(n: 79)\n\/\/\/ 3\nfunc fizz_buzz(n: Int) -> Int {\n","canonical_solution":"func fizz_buzz(n: Int) -> Int {\n    var count = 0\n    for number in 0..<n {\n        if number % 11 == 0 || number % 13 == 0 {\n            var current = number\n            while current > 0 {\n                if current % 10 == 7 {\n                    count += 1\n                }\n                current \/= 10\n            }\n        }\n    }\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fizz_buzz(n: 50) == 0)\nassert(fizz_buzz(n: 78) == 2)\nassert(fizz_buzz(n: 79) == 3)\nassert(fizz_buzz(n: 100) == 3)\nassert(fizz_buzz(n: 200) == 6)\nassert(fizz_buzz(n: 4000) == 192)\nassert(fizz_buzz(n: 10000) == 639)\nassert(fizz_buzz(n: 100000) == 8026)"},{"task_id":"HumanEval_37","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ l ৰ সম সূচকৰ মানসমূহলৈ, কিন্তু ছৰ্ট কৰা হৈছে।\/\/ l' অগণন সূচকৰ ক্ষেত্ৰত l ৰ সৈতে একে, যদিও সম সূচকৰ ক্ষেত্ৰত ইয়াৰ মান সমান হয় ।\/\/ এই ফাংচনে এটা এৰেজ লয় আৰু এটা এৰেজ ঘূৰাই আনে l' যেনে যে\/\/\/ >>> sort_even(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_even(l: [5, 6, 3, 4])\n\/\/\/ [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_even(l: [Int]) -> [Int] {\n    var evenIndicesValues = [Int]()\n    \n    \/\/ Collect values from even indices\n    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n            evenIndicesValues.append(value)\n        }\n    }\n    \n    \/\/ Sort the collected even indices values\n    evenIndicesValues.sort()\n    \n    var result = l\n    var evenIndex = 0\n    \n    \/\/ Replace even-indexed elements in result with sorted values\n    for i in 0..<result.count {\n        if i % 2 == 0 {\n            result[i] = evenIndicesValues[evenIndex]\n            evenIndex += 1\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"},{"task_id":"HumanEval_39","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ prime_fib n-তম সংখ্যাক উভতাই দিয়ে যিটো এটা ফিব'নাচ্চি সংখ্যা আৰু ইও এটা অগ্ৰগণ্য সংখ্যা। \/\/\/ >>> prime_fib(n: 1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(n: 2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(n: 3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(n: 4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(n: 5)\n\/\/\/ 89\nfunc prime_fib(n: Int) -> Int {\n","canonical_solution":"func isPrime(_ num: Int) -> Bool {\n    if num <= 1 { return false }\n    if num <= 3 { return true }\n    if num % 2 == 0 || num % 3 == 0 { return false }\n    var i = 5\n    while i * i <= num {\n        if num % i == 0 || num % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}\n\nfunc generateFibonacci(n: Int) -> [Int] {\n    var fibs = [1, 2]\n    var next = fibs[0] + fibs[1]\n    while fibs.count < n || !isPrime(next) {\n        fibs.append(next)\n        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]\n    }\n    return fibs\n}\n\nfunc prime_fib(n: Int) -> Int {\n    var count = 0\n    var fibs = generateFibonacci(n: n)\n    for fib in fibs {\n        if isPrime(fib) {\n            count += 1\n            if count == n {\n                return fib\n            }\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_fib(n: 1) == 2)\nassert(prime_fib(n: 2) == 3)\nassert(prime_fib(n: 3) == 5)\nassert(prime_fib(n: 4) == 13)\nassert(prime_fib(n: 5) == 89)\nassert(prime_fib(n: 6) == 233)\nassert(prime_fib(n: 7) == 1597)\nassert(prime_fib(n: 8) == 28657)\nassert(prime_fib(n: 9) == 514229)\nassert(prime_fib(n: 10) == 433494437)"},{"task_id":"HumanEval_40","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ শূন্যৰ সমান আৰু অন্যথা মিছা।\/\/ যদিহে এটা এৰেজত তিনিটা পৃথক উপাদান আছে, তেন্তে ই true ৰিটাৰ্ণ কৰে\/\/ triples_sum_to_zero এ এটা অখণ্ড সংখ্যাৰ সজ্জা এটা ইনপুট হিচাপে গ্ৰহণ কৰে।\/\/\/ >>> triples_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1])\n\/\/\/ false\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func triples_sum_to_zero(l: [Int]) -> Bool {\n    let count = l.count\n    if count < 3 {\n        return false\n    }\n    \n    let sortedArray = l.sorted()\n    \n    for i in 0..<count - 2 {\n        var left = i + 1\n        var right = count - 1\n        \n        while left < right {\n            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]\n            if currentSum == 0 {\n                return true\n            } else if currentSum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)\nassert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)\nassert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)\nassert(triples_sum_to_zero(l: [1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)\nassert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"},{"task_id":"HumanEval_41","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এই ফাংচনে এনে সংঘৰ্ষৰ সংখ্যা আউটপুট কৰে।\/\/ তেওঁলোকৰ গতিপথত যেন তেওঁলোক সংঘৰ্ষ কৰা নাই।কিন্তু এই গাড়ীবোৰ অসীম শক্তিশালী আৰু শক্তিশালী, যাৰ ফলত ইবোৰ চলিয়েই থাকে।\/\/ যেতিয়া এখন গাড়ী বাওঁৰ পৰা সোঁলৈ গৈ আছে তেতিয়া এটা গাড়ী সোঁৰ পৰা বাওঁলৈ গৈ আছে তেতিয়া ই খুন্দা মাৰে।সকলো গাড়ী একেই গতিত গতি কৰে। দুইখন গাড়ী সংঘৰ্ষ হয় বুলি কোৱা হয়।এই দুটা গাড়ীৰ দলটো আৰম্ভ হয় বহু দূৰৈৰ পৰা।\/\/ n গাড়ী বামৰ পৰা সোঁলৈ চলিব; একে সময়তে, n গাড়ীসমূহৰ এটা বেলেগ ছেট এটা পথ কল্পনা কৰক যিটো সম্পূৰ্ণৰূপে সৰল, অসীম দীঘল ৰেখা।func car_race_collision(n: Int) -> Int {\n","canonical_solution":"func car_race_collision(n: Int) -> Int {\n    return n\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(car_race_collision(n: 2) == 4)\nassert(car_race_collision(n: 3) == 9)\nassert(car_race_collision(n: 4) == 16)\nassert(car_race_collision(n: 8) == 64)\nassert(car_race_collision(n: 10) == 100)"},{"task_id":"HumanEval_42","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ 1 দ্বাৰা বৃদ্ধি কৰা উপাদানৰ সৈতে এৰেজ ঘূৰাই আনা।\/\/\/ >>> incr_list(l: [1, 2, 3])\n\/\/\/ [2, 3, 4]\n\/\/\/ >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n","canonical_solution":"func incr_list(l: [Int]) -> [Int] {\n    return l.map { $0 + 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"},{"task_id":"HumanEval_43","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ শূন্যৰ সমান আৰু অন্যথা মিছা।\/\/ যদিহে দুটা পৃথক উপাদান আছে তেন্তে ই true ঘূৰাই দিয়ে যিটো \/\/ pairs_sum_to_zero এ এটা অখণ্ড সংখ্যাৰ সজ্জা এটা ইনপুট হিচাপে গ্ৰহণ কৰে।\/\/\/ >>> pairs_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(l: [1])\n\/\/\/ false\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func pairs_sum_to_zero(l: [Int]) -> Bool {\n    var set = Set<Int>()\n    for num in l {\n        if set.contains(-num) {\n            return true\n        }\n        set.insert(num)\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)\nassert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)\nassert(pairs_sum_to_zero(l: [1]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"},{"task_id":"HumanEval_44","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ মৌলিক সংখ্যা ১০ তকৈ কম।\/\/ ৰূপান্তৰ কৰাৰ পিছত শাৰী প্ৰতিনিধিত্ব ঘূৰাই আনে। \/\/ ইনপুট নম্বৰ x ৰ সংখ্যাগত ভিত্তি ভিত্তিলৈ পৰিবৰ্তন কৰক।\/\/\/ >>> change_base(x: 8, base: 3)\n\/\/\/ \"22\"\n\/\/\/ >>> change_base(x: 8, base: 2)\n\/\/\/ \"1000\"\n\/\/\/ >>> change_base(x: 7, base: 2)\n\/\/\/ \"111\"\nfunc change_base(x: Int, base: Int) -> String {\n","canonical_solution":"func change_base(x: Int, base: Int) -> String {\n    guard base > 1 && base < 10 else {\n        return \"\"\n    }\n    \n    var number = x\n    var result = \"\"\n    \n    repeat {\n        let remainder = number % base\n        result = \"\\(remainder)\" + result\n        number \/= base\n    } while number > 0\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(change_base(x: 8, base: 3) == \"22\")\nassert(change_base(x: 9, base: 3) == \"100\")\nassert(change_base(x: 234, base: 2) == \"11101010\")\nassert(change_base(x: 16, base: 2) == \"10000\")\nassert(change_base(x: 8, base: 2) == \"1000\")\nassert(change_base(x: 7, base: 2) == \"111\")\nassert(change_base(x: 2, base: 3) == \"2\")\nassert(change_base(x: 3, base: 4) == \"3\")\nassert(change_base(x: 4, base: 5) == \"4\")\nassert(change_base(x: 5, base: 6) == \"5\")\nassert(change_base(x: 6, base: 7) == \"6\")\nassert(change_base(x: 7, base: 8) == \"7\")"},{"task_id":"HumanEval_45","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ত্ৰিভুজৰ এটা পক্ষৰ দৈৰ্ঘ্য আৰু উচ্চতম ৰিটাৰ্ণ এৰীয়া দিয়া হৈছে।\/\/\/ >>> triangle_area(a: 5, h: 3)\n\/\/\/ 7.5\nfunc triangle_area(a: Int, h: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, h: Int) -> Double {\n    return 0.5 * Double(a) * Double(h)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 5, h: 3) == 7.5)\nassert(triangle_area(a: 2, h: 2) == 2.0)\nassert(triangle_area(a: 10, h: 8) == 40.0)"},{"task_id":"HumanEval_46","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অনুগ্ৰহ কৰি fib4 সংখ্যা ক্ৰমৰ n-তম উপাদানটো কাৰ্যকৰীভাৱে গণনা কৰিবলৈ এটা ফাংশন লিখক। পুনৰাবৃত্তি ব্যৱহাৰ নকৰিব। \/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) ।\/\/ fib4(3) -> 0 \/\/ fib4(2) -> 2 \/\/ fib4(1) -> 0 \/\/ fib4(0) -> 0 \/\/ Fib4 সংখ্যা ক্ৰমটো ফিব'নাক্সি ক্ৰমৰ সৈতে একে ধৰণৰ ক্ৰম যিটো তলত দিয়া ধৰণে সংজ্ঞায়িত কৰা হৈছে: \/\/\/ >>> fib4(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fib4(n: 6)\n\/\/\/ 8\n\/\/\/ >>> fib4(n: 7)\n\/\/\/ 14\nfunc fib4(n: Int) -> Int {\n","canonical_solution":"func fib4(n: Int) -> Int {\n    if n == 0 || n == 1 || n == 3 {\n        return 0\n    } else if n == 2 {\n        return 2\n    }\n    \n    var fibs = [0, 0, 2, 0]\n    \n    for i in 4...n {\n        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]\n        fibs.append(nextFib)\n    }\n    \n    return fibs[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib4(n: 5) == 4)\nassert(fib4(n: 8) == 28)\nassert(fib4(n: 10) == 104)\nassert(fib4(n: 12) == 386)"},{"task_id":"HumanEval_47","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অংকনক্ষেত্ৰ l ৰ উপাদানসমূহৰ মধ্যম সংখ্যা ঘূৰাই আনে ।\/\/\/ >>> median(l: [3, 1, 2, 4, 5])\n\/\/\/ 3\n\/\/\/ >>> median(l: [-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfunc median(l: [Int]) -> Double {\n","canonical_solution":"func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    let count = sorted.count\n    if count % 2 == 0 {\n        return Double(sorted[count \/ 2 - 1] + sorted[count \/ 2]) \/ 2.0\n    } else {\n        return Double(sorted[count \/ 2])\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"},{"task_id":"HumanEval_48","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ দিয়া শাৰীটো এটা পলিণ্ড্ৰ'ম হয় নে নহয় পৰীক্ষা কৰে ।\/\/\/ >>> is_palindrome(text: \"\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aba\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aaaaa\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"zbcd\")\n\/\/\/ false\nfunc is_palindrome(text: String) -> Bool {\n","canonical_solution":"func is_palindrome(text: String) -> Bool {\n    return text == String(text.reversed())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_palindrome(text: \"\") == true)\nassert(is_palindrome(text: \"aba\") == true)\nassert(is_palindrome(text: \"aaaaa\") == true)\nassert(is_palindrome(text: \"zbcd\") == false)\nassert(is_palindrome(text: \"xywyx\") == true)\nassert(is_palindrome(text: \"xywyz\") == false)\nassert(is_palindrome(text: \"xywzx\") == false)"},{"task_id":"HumanEval_49","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ 2^n modulo p ঘূৰাই আনা (সংখ্যাটোৰ বিষয়ে অৱগত হওক) ।\/\/\/ >>> modp(n: 3, p: 5)\n\/\/\/ 3\n\/\/\/ >>> modp(n: 1101, p: 101)\n\/\/\/ 2\n\/\/\/ >>> modp(n: 0, p: 101)\n\/\/\/ 1\n\/\/\/ >>> modp(n: 3, p: 11)\n\/\/\/ 8\n\/\/\/ >>> modp(n: 100, p: 101)\n\/\/\/ 1\nfunc modp(n: Int, p: Int) -> Int {\n","canonical_solution":"func modp(n: Int, p: Int) -> Int {\n    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"},{"task_id":"HumanEval_51","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ remove_vowels এটা ফাংচন যি শাৰী লৈ শাৰী বিনা স্বৰলিপি দিয়ে।\/\/\/ >>> remove_vowels(text: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"abcdef\")\n\/\/\/ \"bcdf\"\n\/\/\/ >>> remove_vowels(text: \"aaaaa\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"aaBAA\")\n\/\/\/ \"B\"\n\/\/\/ >>> remove_vowels(text: \"zbcd\")\n\/\/\/ \"zbcd\"\nfunc remove_vowels(text: String) -> String {\n","canonical_solution":"func remove_vowels(text: String) -> String {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return String(text.filter { !vowels.contains($0) })\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_vowels(text: \"\") == \"\")\nassert(remove_vowels(text: \"abcdef\\nghijklm\") == \"bcdf\\nghjklm\")\nassert(remove_vowels(text: \"fedcba\") == \"fdcb\")\nassert(remove_vowels(text: \"eeeee\") == \"\")\nassert(remove_vowels(text: \"acBAA\") == \"cB\")\nassert(remove_vowels(text: \"EcBOO\") == \"cB\")\nassert(remove_vowels(text: \"ybcd\") == \"ybcd\")"},{"task_id":"HumanEval_52","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ যদি অংকবোৰ প্ৰান্তিক t তকৈ কম হয় তেন্তে true ঘূৰাই দিব. \/\/\/ >>> below_threshold(l: [1, 2, 4, 10], t: 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(l: [1, 20, 4, 10], t: 5)\n\/\/\/ false\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n","canonical_solution":"func below_threshold(l: [Int], t: Int) -> Bool {\n    for number in l {\n        if number >= t {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)\nassert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"},{"task_id":"HumanEval_53","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ দুটা সংখ্যা x আৰু y যোগ কৰা ।\/\/\/ >>> add(x: 2, y: 3)\n\/\/\/ 5\n\/\/\/ >>> add(x: 5, y: 7)\n\/\/\/ 12\nfunc add(x: Int, y: Int) -> Int {\n","canonical_solution":"func add(x: Int, y: Int) -> Int {\n    return x + y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(x: 0, y: 1) == 1)\nassert(add(x: 1, y: 0) == 1)\nassert(add(x: 2, y: 3) == 5)\nassert(add(x: 5, y: 7) == 12)\nassert(add(x: 7, y: 5) == 12)"},{"task_id":"HumanEval_54","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ দুটা শব্দৰ একে ধৰণৰ বৰ্ণ আছে নে নাই পৰীক্ষা কৰক।\/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"dddddddabc\", s1: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"eabcd\", s1: \"dddddddabc\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabce\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\")\n\/\/\/ false\nfunc same_chars(s0: String, s1: String) -> Bool {\n","canonical_solution":"func same_chars(s0: String, s1: String) -> Bool {\n    let set0 = Set(s0)\n    let set1 = Set(s1)\n    return set0 == set1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\") == true)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabc\") == true)\nassert(same_chars(s0: \"dddddddabc\", s1: \"abcd\") == true)\nassert(same_chars(s0: \"eabcd\", s1: \"dddddddabc\") == false)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabcf\") == false)\nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\") == false)\nassert(same_chars(s0: \"aabb\", s1: \"aaccc\") == false)"},{"task_id":"HumanEval_55","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ n-তম ফিব'নাচ্চি সংখ্যা ঘূৰাই দিব. \/\/\/ >>> fib(n: 10)\n\/\/\/ 55\n\/\/\/ >>> fib(n: 1)\n\/\/\/ 1\n\/\/\/ >>> fib(n: 8)\n\/\/\/ 21\nfunc fib(n: Int) -> Int {\n","canonical_solution":"func fib(n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    }\n    \n    var a = 0\n    var b = 1\n    for _ in 2...n {\n        let temp = a + b\n        a = b\n        b = temp\n    }\n    return b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib(n: 10) == 55)\nassert(fib(n: 1) == 1)\nassert(fib(n: 8) == 21)\nassert(fib(n: 11) == 89)\nassert(fib(n: 12) == 144)"},{"task_id":"HumanEval_56","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ প্ৰত্যেক খোলাৰ ব্ৰেকেটত যদি একেটা বন্ধৰ ব্ৰেকেট থাকে তেন্তে true ৰিটাৰ্ণ কৰক।\/\/ বন্ধনীৰ মাজত \"<\" আৰু \">\" ৰ এটা শাৰী আছে.\/\/\/ >>> correct_bracketing(brackets: \"<\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"<>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"<<><>>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"><<>\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    \n    for bracket in brackets {\n        if bracket == \"<\" {\n            balance += 1\n        } else if bracket == \">\" {\n            balance -= 1\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    \n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)"},{"task_id":"HumanEval_57","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ true ৰিটাৰ্ণ কৰক যদি এৰে এলিমেণ্টবোৰ এককভাৱে বাঢ়ি বা হ্ৰাস হয়।\/\/\/ >>> monotonic(l: [1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(l: [1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(l: [4, 1, 0, -10])\n\/\/\/ true\nfunc monotonic(l: [Int]) -> Bool {\n","canonical_solution":"func monotonic(l: [Int]) -> Bool {\n    guard l.count > 1 else {\n        return true\n    }\n    \n    var increasing = true\n    var decreasing = true\n    \n    for i in 1..<l.count {\n        if l[i] > l[i - 1] {\n            decreasing = false\n        } else if l[i] < l[i - 1] {\n            increasing = false\n        }\n    }\n    \n    return increasing || decreasing\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"},{"task_id":"HumanEval_58","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ দুটা এৰেজৰ বাবে ছৰ্ট কৰা অনন্য সাধাৰণ উপাদানসমূহ ঘূৰাই আনে।\/\/\/ >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n\/\/\/ [1, 5, 653]\n\/\/\/ >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n\/\/\/ [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n","canonical_solution":"func common(l1: [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let commonElements = set1.intersection(set2)\n    return Array(commonElements).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_59","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ n ৰ সৰ্ববৃহৎ মৌলিক গুণক ঘূৰাই দিয়া. n > 1 আৰু এটা মৌলিক নহয় বুলি ধৰি লোৱা. \/\/\/ >>> largest_prime_factor(n: 13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(n: 2048)\n\/\/\/ 2\nfunc largest_prime_factor(n: Int) -> Int {\n","canonical_solution":"func largest_prime_factor(n: Int) -> Int {\n    var number = n\n    var divisor = 2\n    \n    while number > 1 {\n        if number % divisor == 0 {\n            number \/= divisor\n        } else {\n            divisor += 1\n        }\n    }\n    \n    return divisor\n}\n\n\/\/ Example usage:\n\/\/ print(largest_prime_factor(n: 13195)) \/\/ Output: 29\n\/\/ print(largest_prime_factor(n: 2048))  \/\/ Output: 2","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"},{"task_id":"HumanEval_60","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ sum_to_n হৈছে এটা ফাংচন যি 1 ৰ পৰা n লৈকে সংখ্যাবোৰৰ যোগফল দিয়ে।\/\/\/ >>> sum_to_n(n: 30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(n: 100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(n: 5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(n: 10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(n: 1)\n\/\/\/ 1\nfunc sum_to_n(n: Int) -> Int {\n","canonical_solution":"func sum_to_n(n: Int) -> Int {\n    return (n * (n + 1)) \/ 2\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_to_n(n: 1) == 1)\nassert(sum_to_n(n: 6) == 21)\nassert(sum_to_n(n: 11) == 66)\nassert(sum_to_n(n: 30) == 465)\nassert(sum_to_n(n: 100) == 5050)"},{"task_id":"HumanEval_61","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ প্ৰত্যেক খোলাৰ ব্ৰেকেটত যদি একেটা বন্ধৰ ব্ৰেকেট থাকে তেন্তে true ৰিটাৰ্ণ কৰক।\/\/ বন্ধনীৰ মাজত \"(\" আৰু \"\") ৰ এটা শাৰী আছে।\/\/\/ >>> correct_bracketing(brackets: \"(\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"()\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"(()())\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \")(()\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    for char in brackets {\n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)"},{"task_id":"HumanEval_62","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ এই বহুপদটোৰ সমানুপাতিক সূত্ৰটো ঘূৰাই দিব।\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/ xs এ বহুপদটোৰ সহগবোৰক প্ৰতিনিধিত্ব কৰে।\/\/\/ >>> derivative(xs: [3, 1, 2, 4, 5])\n\/\/\/ [1, 4, 12, 20]\n\/\/\/ >>> derivative(xs: [1, 2, 3])\n\/\/\/ [2, 6]\nfunc derivative(xs: [Int]) -> [Int] {\n","canonical_solution":"func derivative(xs: [Int]) -> [Int] {\n    guard xs.count > 1 else { return [] }\n    var result: [Int] = []\n    for i in 1..<xs.count {\n        result.append(xs[i] * i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])\nassert(derivative(xs: [1, 2, 3]) == [2, 6])\nassert(derivative(xs: [3, 2, 1]) == [2, 2])\nassert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])\nassert(derivative(xs: [1]) == [] as [Int])"},{"task_id":"HumanEval_63","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অনুগ্ৰহ কৰি fibfib সংখ্যা ক্ৰমৰ n-তম উপাদানটো কাৰ্যকৰীভাৱে গণনা কৰিবলৈ এটা ফাংশন লিখক।\/\/ fib fib (n) == fib fib (n-1) + fib fib (n-2) + fib fib (n-3) ।\/\/ fib fib ((2) == 1 \/\/ ফিবিবিব (১) == ০\/\/ ফিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিবিব\/\/ FibFib সংখ্যা ক্ৰমটো ফিব'নাক্সি ক্ৰমৰ সৈতে একে ধৰণৰ ক্ৰম যিটো তলত দিয়া ধৰণে সংজ্ঞায়িত কৰা হৈছে: \/\/\/ >>> fibfib(n: 1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(n: 8)\n\/\/\/ 24\nfunc fibfib(n: Int) -> Int {\n","canonical_solution":"func fibfib(n: Int) -> Int {\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    \n    var fibfibNums = [0, 0, 1]\n    \n    for i in 3...n {\n        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]\n        fibfibNums.append(nextFibFib)\n    }\n    \n    return fibfibNums[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fibfib(n: 2) == 1)\nassert(fibfib(n: 1) == 0)\nassert(fibfib(n: 5) == 4)\nassert(fibfib(n: 8) == 24)\nassert(fibfib(n: 10) == 81)\nassert(fibfib(n: 12) == 274)\nassert(fibfib(n: 14) == 927)"},{"task_id":"HumanEval_64","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ স্বৰবৰ্ণ, কিন্তু কেৱল যেতিয়া ই নিৰ্দিষ্ট শব্দৰ শেষত থাকে।এই ক্ষেত্ৰত স্বৰবৰ্ণবোৰ হ'ল 'a', 'e', 'i', 'o', 'u'। ইয়াত, 'y' হৈছে a \/\/ এটা শব্দ ইনপুট হিচাপে আৰু শাৰীটোত স্বৰবৰ্ণৰ সংখ্যা ঘূৰাই দিয়ে।\/\/ এটা ফাংচন ভেকুৱেলছ_কাউন্ট লিখক যিয়ে এটা \/\/\/ >>> vowels_count(s: \"abcde\")\n\/\/\/ 2\n\/\/\/ >>> vowels_count(s: \"ACEDY\")\n\/\/\/ 3\nfunc vowels_count(s: String) -> Int {\n","canonical_solution":"func vowels_count(s: String) -> Int {\n    guard !s.isEmpty else { return 0 }\n    \n    let vowels = Set(\"aeiouAEIOU\")\n    var count = 0\n    let characters = Array(s)\n    \n    for i in 0..<characters.count {\n        let char = characters[i]\n        \n        if vowels.contains(char) {\n            count += 1\n        } else if char == \"y\" || char == \"Y\" {\n            if i == characters.count - 1 {\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(vowels_count(s: \"abcde\") == 2)\nassert(vowels_count(s: \"Alone\") == 3)\nassert(vowels_count(s: \"key\") == 2)\nassert(vowels_count(s: \"bye\") == 1)\nassert(vowels_count(s: \"keY\") == 2)\nassert(vowels_count(s: \"bYe\") == 1)\nassert(vowels_count(s: \"ACEDY\") == 3)"},{"task_id":"HumanEval_65","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ যদি shift > সংখ্যাৰ অংক, ৰিটাৰ্ণ অংক বিপরীত।\/\/ আৰু ফলাফলটো এটা ষ্ট্ৰিং হিচাপে ঘূৰাই দিব. \/\/ পৰিভ্ৰামক x অংকটোৰ অংকবোৰ স্থানান্তৰ কৰক, অংকবোৰ স্থানান্তৰ কৰি সোঁফালে স্থানান্তৰ কৰক \/\/\/ >>> circular_shift(x: 12, shift: 1)\n\/\/\/ \"21\"\n\/\/\/ >>> circular_shift(x: 12, shift: 2)\n\/\/\/ \"12\"\nfunc circular_shift(x: Int, shift: Int) -> String {\n","canonical_solution":"func circular_shift(x: Int, shift: Int) -> String {\n    let digits = Array(String(x))\n    let count = digits.count\n    \n    \/\/ If shift is greater than the number of digits, return the digits reversed\n    if shift >= count {\n        return String(digits.reversed())\n    }\n    \n    \/\/ Calculate the actual shift needed by using modulo operation\n    let actualShift = shift % count\n    \n    \/\/ Perform the circular shift to the right\n    let splitIndex = count - actualShift\n    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]\n    \n    return String(shiftedDigits)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(circular_shift(x: 100, shift: 2) == \"001\")\nassert(circular_shift(x: 12, shift: 2) == \"12\")\nassert(circular_shift(x: 97, shift: 8) == \"79\")\nassert(circular_shift(x: 12, shift: 1) == \"21\")\nassert(circular_shift(x: 11, shift: 101) == \"11\")"},{"task_id":"HumanEval_66","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ ASCII কোডসমূহ\/\/ এটা ফাংচন লিখক যি এটা ষ্ট্ৰিংক ইনপুট হিচাপে লয় আৰু কেৱল ওপৰৰ বৰ্ণবোৰৰ যোগফল ঘূৰাই আনে' \/\/ কাৰ্য্য \/\/\/ >>> digitSum(s: \"\")\n\/\/\/ 0\n\/\/\/ >>> digitSum(s: \"abAB\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"abcCd\")\n\/\/\/ 67\n\/\/\/ >>> digitSum(s: \"helloE\")\n\/\/\/ 69\n\/\/\/ >>> digitSum(s: \"woArBld\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"aAaaaXa\")\n\/\/\/ 153\nfunc digitSum(s: String) -> Int {\n","canonical_solution":"func digitSum(s: String) -> Int {\n    var sum = 0\n    for character in s {\n        if character.isUppercase {\n            sum += Int(character.asciiValue ?? 0)\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digitSum(s: \"\") == 0)\nassert(digitSum(s: \"abAB\") == 131)\nassert(digitSum(s: \"abcCd\") == 67)\nassert(digitSum(s: \"helloE\") == 69)\nassert(digitSum(s: \"woArBld\") == 131)\nassert(digitSum(s: \"aAaaaXa\") == 153)\nassert(digitSum(s: \" How are yOu?\") == 151)\nassert(digitSum(s: \"You arE Very Smart\") == 327)"},{"task_id":"HumanEval_67","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অনুবাদৰ বাবে: \/\/ ক'ৰ্টত ক'ৰ্টত থকা আমৰ ফলবোৰৰ সংখ্যা ঘূৰাই দিব. \/\/ কমলা আৰু আপেল আৰু এটা পূৰ্ণ সংখ্যা যি ফলবোৰৰ মুঠ সংখ্যা প্ৰতিনিধিত্ব কৰে ।আপেল, কমলা আৰু আমৰ ফলক এটা শাৰী দিয়া হ'ল যিটো মুঠ সংখ্যাক প্ৰতিনিধিত্ব কৰে।\/\/ যিসমূহ ফলমূলৰ এখন ক'ৰবাত বিতৰণ কৰা হয় এই ক'ৰবাত থাকে \/\/ এই কাৰ্য্যত, আপোনাক এটা শাৰী দিয়া হ'ব যি এপল আৰু কমলা সংখ্যাক প্ৰতিনিধিত্ব কৰে \/\/\/ >>> fruit_distribution(s: \"5 apples and 6 oranges\", n: 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(s: \"0 apples and 1 oranges\", n: 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(s: \"2 apples and 3 oranges\", n: 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(s: \"100 apples and 1 oranges\", n: 120)\n\/\/\/ 19\nfunc fruit_distribution(s: String, n: Int) -> Int {\n","canonical_solution":"func fruit_distribution(s: String, n: Int) -> Int {\n    let components = s.components(separatedBy: \" \")\n    var apples = 0\n    var oranges = 0\n    \n    for (index, component) in components.enumerated() {\n        if component == \"apples\" || component == \"apple\" {\n            if let number = Int(components[index - 1]) {\n                apples = number\n            }\n        } else if component == \"oranges\" || component == \"orange\" {\n            if let number = Int(components[index - 1]) {\n                oranges = number\n            }\n        }\n    }\n    \n    let totalApplesOranges = apples + oranges\n    let mangoes = n - totalApplesOranges\n    return mangoes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 19) == 8)\nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 21) == 10)\nassert(fruit_distribution(s: \"0 apples and 1 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"1 apples and 0 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 100) == 95)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 5) == 0)\nassert(fruit_distribution(s: \"1 apples and 100 oranges\", n: 120) == 19)"},{"task_id":"HumanEval_68","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ ১ঃ \/\/ যদি কোনো জোৰা মান নাই বা দিয়া এৰে খালী, ৰিটাৰ্ণ [].\/\/ পিক কৰা ন'ডটো এটা এৰেজত ঘূৰাই দিব লাগে, [ smalest_value, ইয়াৰ সূচী ], \/\/ যদি একেটা সৰু মান থকা একাধিক ন'ড পোৱা যায়, তেন্তে ন'ডৰ যিটো ন'ডৰ সূচক আটাইতকৈ সৰু তাক ঘূৰাই দিব।\/\/ পিক কৰা নডটো আটাইতকৈ সৰু জোৰা মান থকা নডটো হ'ব লাগে।আপোনাৰ কাম হ'ল এটা ন'ডৰ পৰা এটা ন'ড উলিয়াই পুনৰ ঘূৰাই অনা।\/\/ \"এক অংকিত অংকন দিয়া হৈছে যিটো অংকিত অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা অংকন কৰা\/\/\/ >>> pluck(arr: [4, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(arr: [1, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(arr: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\/\/\/ [0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfunc pluck(arr: [Int]) -> [Int] {\n","canonical_solution":"func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue: Int? = nil\n    var smallestIndex: Int? = nil\n\n    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {\n                smallestEvenValue = value\n                smallestIndex = index\n            }\n        }\n    }\n\n    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {\n        return [smallestEvenValue, smallestIndex]\n    } else {\n        return []\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"},{"task_id":"HumanEval_69","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ যদি এনে কোনো মান নাই, তেন্তে -1 ঘূৰাই দিব.\/\/ এটা পূৰ্ণসংখ্যাৰ সঘনতা হৈছে এটা এৰেজত দেখা পোৱা সংখ্যাৰ সংখ্যা।\/\/ শূন্য, আৰু ইয়াৰ সঘনতা সম্পূৰ্ণ সংখ্যাৰ মানতকৈ বেছি বা সমান।আপুনি এটা অ-খালি ধনাত্মক পূৰ্ণসংখ্যাৰ অ্যারে দিয়া হৈছে। তকৈ ডাঙৰ সৰ্বোচ্চ পূৰ্ণসংখ্যাক ঘূৰাই দিয়ক।\/\/\/ >>> search(lst: [4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(lst: [5, 5, 4, 4, 4])\n\/\/\/ -1\nfunc search(lst: [Int]) -> Int {\n","canonical_solution":"func search(lst: [Int]) -> Int {\n    var frequencyMap = [Int: Int]()\n    \n    \/\/ Count frequencies of each number in the list\n    for number in lst {\n        frequencyMap[number, default: 0] += 1\n    }\n    \n    var result = -1\n    \n    \/\/ Iterate through the frequency map to find the greatest integer that satisfies the condition\n    for (number, frequency) in frequencyMap {\n        if frequency >= number {\n            result = max(result, number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(lst: [5, 5, 5, 5, 1]) == 1)\nassert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)\nassert(search(lst: [3, 3]) == -1)\nassert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)\nassert(search(lst: [2, 3, 3, 2, 2]) == 2)\nassert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\nassert(search(lst: [3, 2, 8, 2]) == 2)\nassert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\nassert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)\nassert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\nassert(search(lst: [1, 9, 10, 1, 3]) == 1)\nassert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\nassert(search(lst: [1]) == 1)\nassert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\nassert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\nassert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\nassert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)\nassert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\nassert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\nassert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\nassert(search(lst: [10]) == -1)\nassert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\nassert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\nassert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\nassert(search(lst: [3, 10, 10, 9, 2]) == -1)"},{"task_id":"HumanEval_70","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ তাৰ পিছত বাকী থকা পূৰ্ণসংখ্যাৰ সৰ্বোচ্চ, তাৰ পিছত সৰ্বনিম্ন আৰু এনেদৰে।\/\/ অদ্ভুত ছাৰ্টিং, যেতিয়া আপুনি ন্যূনতম মানৰ সৈতে আৰম্ভ কৰে, \/\/ অখণ্ড সংখ্যাৰ এটা অ্যারে দিয়া হ'লে, অদ্ভুত ক্ৰমত অ্যারে ঘূৰাই দিব.\/\/\/ >>> strange_sort_list(lst: [1, 2, 3, 4])\n\/\/\/ [1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(lst: [5, 5, 5, 5])\n\/\/\/ [5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(lst: [] as [Int])\n\/\/\/ [] as [Int]\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n","canonical_solution":"func strange_sort_list(lst: [Int]) -> [Int] {\n    var sortedList = lst.sorted()\n    var result: [Int] = []\n    \n    while !sortedList.isEmpty {\n        if let min = sortedList.first {\n            result.append(min)\n            sortedList.removeFirst()\n        }\n        \n        if let max = sortedList.last {\n            result.append(max)\n            sortedList.removeLast()\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"},{"task_id":"HumanEval_71","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ তৃতীয় পক্ষৰ তুলনাত। \/\/ ত্ৰিপাক্ষই এটা বৈধ ত্ৰিভুজ গঠন কৰে যেতিয়া যিকোনো দুটা ত্ৰিপাক্ষৰ যোগফল বেছি হয় ।\/\/ অন্যথা -1 ঘূৰাই দিব\/\/ যদি ত্ৰিভুজৰ তিনিওটা ফালে বৈধ ত্ৰিভুজ গঠন কৰে তেন্তে ত্ৰিভুজটো ২টা দশমিক বিন্দুত ঘূৰণীয়া কৰা হ'ব।\/\/ এটা ত্ৰিভুজৰ তিনিটা পক্ষৰ দৈৰ্ঘ্য দিয়া হ'লে,  ৰ ক্ষেত্ৰফল ঘূৰাই দিয়া\/\/\/ >>> triangle_area(a: 3, b: 4, c: 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(a: 1, b: 2, c: 10)\n\/\/\/ -1\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, b: Int, c: Int) -> Double {\n    \/\/ Check if the sides form a valid triangle\n    if a + b > c && a + c > b && b + c > a {\n        \/\/ Calculate the semi-perimeter\n        let s = Double(a + b + c) \/ 2.0\n        \/\/ Calculate the area using Heron's formula\n        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))\n        \/\/ Round to 2 decimal places\n        return round(area * 100) \/ 100\n    } else {\n        return -1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 3, b: 4, c: 5) == 6.0)\nassert(triangle_area(a: 1, b: 2, c: 10) == -1)\nassert(triangle_area(a: 4, b: 8, c: 5) == 8.18)\nassert(triangle_area(a: 2, b: 2, c: 2) == 1.73)\nassert(triangle_area(a: 1, b: 2, c: 3) == -1)\nassert(triangle_area(a: 10, b: 5, c: 7) == 16.25)\nassert(triangle_area(a: 2, b: 6, c: 3) == -1)\nassert(triangle_area(a: 1, b: 1, c: 1) == 0.43)\nassert(triangle_area(a: 2, b: 2, c: 10) == -1)"},{"task_id":"HumanEval_72","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ বস্তু q উৰি যাব যদিহে ই ভাৰসাম্যপূৰ্ণ হয় (এয়া এটা পলিণ্ড্ৰোমিক এৰে) আৰু ইয়াৰ উপাদানসমূহৰ যোগফল সৰ্বাধিক সম্ভৱ ওজন w ৰ সমান বা তাতকৈ কম হয়।এটা ফাংচন লিখক যিটো যদি বস্তু q উৰি যায় সত্য আৰু অন্যথা মিছা উভতাই দিয়ে।\/\/\/ >>> will_it_fly(q: [1, 2], w: 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(q: [3], w: 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int], w: Int) -> Bool {\n","canonical_solution":"func will_it_fly(q: [Int], w: Int) -> Bool {\n    func isPalindromic(_ array: [Int]) -> Bool {\n        return array == array.reversed()\n    }\n    \n    let sum = q.reduce(0, +)\n    return isPalindromic(q) && sum <= w\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"},{"task_id":"HumanEval_73","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ এটা পৰিৱৰ্তনত আপুনি এটা উপাদানক যিকোনো অন্য উপাদানৰ সৈতে পৰিৱৰ্তন কৰিব পাৰে।এটা পলিণ্ড্ৰমিক এৰে এটা এৰে যিটো \/\/ এটা এৰেৰ পূৰ্ণসংখ্যাক দিয়া হ'লে, \/\/\/ >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 2, 1])\n\/\/\/ 0\nfunc smallest_change(arr: [Int]) -> Int {\n","canonical_solution":"func smallest_change(arr: [Int]) -> Int {\n    var changes = 0\n    let n = arr.count\n\n    for i in 0..<(n \/ 2) {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1\n        }\n    }\n\n    return changes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)\nassert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)\nassert(smallest_change(arr: [3, 1, 1, 3]) == 0)\nassert(smallest_change(arr: [1]) == 0)\nassert(smallest_change(arr: [0, 1]) == 1)"},{"task_id":"HumanEval_74","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ যদি দুয়োটা এৰেজত একে সংখ্যক অক্ষৰ থাকে, তেন্তে প্ৰথম এৰেজটো ঘূৰাই দিব.\/\/ অক্ষৰ সমূহৰ মুঠ সংখ্যা অক্ষৰ সমূহৰ সংখ্যাতকৈ কম।\/\/ এটা ফাংচন লিখা যি দুটা শাৰী গ্ৰহণ কৰে আৰু যি শাৰী আছে তাক ঘূৰাই দিয়ে ।\/\/\/ >>> total_match(lst1: [] as [String], lst2: [] as [String])\n\/\/\/ [] as [String]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"])\n\/\/\/ [\"hI\", \"Hi\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/\/ [\"hi\", \"admin\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"])\n\/\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/\/ >>> total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/\/ [\"4\"]\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n","canonical_solution":"func total_match(lst1: [String], lst2: [String]) -> [String] {\n    let totalChars1 = lst1.reduce(0) { $0 + $1.count }\n    let totalChars2 = lst2.reduce(0) { $0 + $1.count }\n    \n    if totalChars1 < totalChars2 {\n        return lst1\n    } else if totalChars2 < totalChars1 {\n        return lst2\n    } else {\n        return lst1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"]) == [\"4\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [] as [String], lst2: [\"this\"]) == [] as [String])\nassert(total_match(lst1: [\"this\"], lst2: [] as [String]) == [] as [String])"},{"task_id":"HumanEval_75","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ (a) ১০০ তকৈ সৰু বুলি জানিলে।\/\/ আৰু অন্যথা মিছা। \/\/ এটা ফাংচন লিখা যিটো সত্য বুলি উভতাই দিয়ে যদিহে দিয়া সংখ্যাটো 3টা মৌলিক সংখ্যাৰ গুণন হয় ।\/\/\/ >>> is_multiply_prime(a: 30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a: Int) -> Bool {\n","canonical_solution":"func is_multiply_prime(a: Int) -> Bool {\n    \/\/ Function to check if a number is prime\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Generate all prime numbers less than 100\n    var primes = [Int]()\n    for i in 2..<100 {\n        if isPrime(i) {\n            primes.append(i)\n        }\n    }\n    \n    \/\/ Check combinations of 3 primes\n    let primeCount = primes.count\n    for i in 0..<primeCount {\n        for j in i..<primeCount {\n            for k in j..<primeCount {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_multiply_prime(a: 5) == false)\nassert(is_multiply_prime(a: 30) == true)\nassert(is_multiply_prime(a: 8) == true)\nassert(is_multiply_prime(a: 10) == false)\nassert(is_multiply_prime(a: 125) == true)\nassert(is_multiply_prime(a: 105) == true)\nassert(is_multiply_prime(a: 126) == false)\nassert(is_multiply_prime(a: 729) == false)\nassert(is_multiply_prime(a: 891) == false)\nassert(is_multiply_prime(a: 1001) == true)"},{"task_id":"HumanEval_76","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ x হৈছে n ৰ এটা সৰল শক্তি যদি n**int=x \/\/ n ৰ শক্তি আৰু অন্য ক্ষেত্ৰত মিছা।আপোনাৰ কাম হ'ল এটা ফাংচন লিখা যিটো এটা সংখ্যা x হ'লে true ঘূৰাই আনে।\/\/\/ >>> is_simple_power(x: 1, n: 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 2, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 8, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 3, n: 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 3, n: 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 5, n: 3)\n\/\/\/ false\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n","canonical_solution":"func is_simple_power(x: Int, n: Int) -> Bool {\n    if x < 1 || n < 1 {\n        return false\n    }\n    if x == 1 {\n        return true \/\/ n**0 = 1\n    }\n    var power = 1\n    while power < x {\n        power *= n\n    }\n    return power == x\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_simple_power(x: 16, n: 2) == true)\nassert(is_simple_power(x: 143214, n: 16) == false)\nassert(is_simple_power(x: 4, n: 2) == true)\nassert(is_simple_power(x: 9, n: 3) == true)\nassert(is_simple_power(x: 16, n: 4) == true)\nassert(is_simple_power(x: 24, n: 2) == false)\nassert(is_simple_power(x: 128, n: 4) == false)\nassert(is_simple_power(x: 12, n: 6) == false)\nassert(is_simple_power(x: 1, n: 1) == true)\nassert(is_simple_power(x: 1, n: 12) == true)"},{"task_id":"HumanEval_77","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ টোকাঃ আপুনি ধাৰণা কৰিব পাৰে যে ইনপুটটো সদায় বৈধ।\/\/ যদি এই ইন্জেগাৰটো কোনো পূৰ্ণসংখ্যাৰ ঘনত্ব হয়।এটা ফাংচন লিখা যি এটা পূৰ্ণ সংখ্যা a লৈ true ঘূৰাই আনে\/\/\/ >>> iscube(a: 1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 2)\n\/\/\/ false\n\/\/\/ >>> iscube(a: -1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 64)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 0)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 180)\n\/\/\/ false\nfunc iscube(a: Int) -> Bool {\n","canonical_solution":"func iscube(a: Int) -> Bool {\n    if a == 0 { return true } \/\/ 0 is a cube (0^3)\n    let absA = abs(a)\n    let cubeRoot = Int(round(pow(Double(absA), 1.0\/3.0)))\n    return cubeRoot * cubeRoot * cubeRoot == absA\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(iscube(a: 1) == true)\nassert(iscube(a: 2) == false)\nassert(iscube(a: -1) == true)\nassert(iscube(a: 64) == true)\nassert(iscube(a: 180) == false)\nassert(iscube(a: 1000) == true)\nassert(iscube(a: 0) == true)\nassert(iscube(a: 1729) == false)"},{"task_id":"HumanEval_78","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ আৰু চিহ্ন A,B,C,D,E,F সকলো ডাঙৰ আখৰেৰে লিখা হয়।\/\/ টোকাঃ আপুনি ধাৰণা কৰিব পাৰে যে ইনপুটটো সদায় শুদ্ধ বা খালী শাৰী, \/\/ বি (= দশমিক 11), ডি (= দশমিক 13) ।\/\/ তলৰ অংকবোৰৰ এটা সংখ্যা নিৰ্ণয় কৰিব লাগিব: 2, 3, 5, 7, \/\/ মৌলিক সংখ্যাবোৰ হ'ল ২, ৩, ৫, ৭, ১১, ১৩, ১৭,...\/\/ ষোড়শ সংখ্যাটো হ'ল 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\/\/ 1 ৰ অধিক যি দুটা সৰু স্বাভাৱিক সংখ্যাৰ গুণফল নহয়) ।\/\/ অংকসমূহ প্ৰাইম (প্ৰাইম নম্বৰ, বা এটা প্ৰাইম, এটা প্ৰাকৃতিক সংখ্যা)\/\/ এটা ষোড়শ সংখ্যা এটা শাৰী হিচাপে আৰু ষোড়শ সংখ্যাটো গণনা কৰে \/\/ আপোনাক এটা ফাংচন লিখিবলৈ কোৱা হৈছে যি গ্ৰহণ কৰে \/\/\/ >>> hex_key(num: \"AB\")\n\/\/\/ 1\n\/\/\/ >>> hex_key(num: \"1077E\")\n\/\/\/ 2\n\/\/\/ >>> hex_key(num: \"ABED1A33\")\n\/\/\/ 4\n\/\/\/ >>> hex_key(num: \"123456789ABCDEF0\")\n\/\/\/ 6\n\/\/\/ >>> hex_key(num: \"2020\")\n\/\/\/ 2\nfunc hex_key(num: String) -> Int {\n","canonical_solution":"func hex_key(num: String) -> Int {\n    \/\/ Define hexadecimal digits that are prime numbers\n    let primeHexDigits: Set<Character> = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    \n    \/\/ Initialize count\n    var primeCount = 0\n    \n    \/\/ Iterate over each character in the string\n    for char in num {\n        \/\/ Check if the character is a prime hexadecimal digit\n        if primeHexDigits.contains(char) {\n            primeCount += 1\n        }\n    }\n    \n    return primeCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"},{"task_id":"HumanEval_79","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ অতিৰিক্ত বৰ্ণবোৰ ফৰ্মেটৰ সহায়ত আছে।\/\/ ষ্ট্ৰিংৰ আৰম্ভণি আৰু শেষত অতিৰিক্ত দুটা বৰ্ণ 'db' থাকিব।\/\/ সংখ্যা. ষ্ট্ৰিংৰ প্ৰতিটো চিহ্ন হ'ব '0' বা '1'.\/\/ বাইনেৰী বিন্যাস। ফাংশনটোৱে এটা ষ্ট্ৰিং ঘূৰাই দিব লাগে, য'ত প্ৰতিটো বৰ্ণই এটা বাইনেৰী প্ৰতিনিধিত্ব কৰে।\/\/ আপোনাক এটা সংখ্যা দিয়া হ'ব দশমিক আকাৰত আৰু আপোনাৰ কাম হ'ব ইয়াক ৰূপান্তৰ কৰা \/\/\/ >>> decimal_to_binary(decimal: 15)\n\/\/\/ \"db1111db\"\n\/\/\/ >>> decimal_to_binary(decimal: 32)\n\/\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal: Int) -> String {\n","canonical_solution":"func decimal_to_binary(decimal: Int) -> String {\n    let binaryString = String(decimal, radix: 2)\n    return \"db\" + binaryString + \"db\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(decimal_to_binary(decimal: 0) == \"db0db\")\nassert(decimal_to_binary(decimal: 32) == \"db100000db\")\nassert(decimal_to_binary(decimal: 103) == \"db1100111db\")\nassert(decimal_to_binary(decimal: 15) == \"db1111db\")"},{"task_id":"HumanEval_80","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ এটা ষ্ট্ৰিং হ'ল হাপচুইফ্ট যদিহে ইয়াৰ দৈৰ্ঘ্য কমেও 3 আৰু প্ৰত্যেক 3 ক্ৰমাগত আখৰ পৃথক হয় ।\/\/ আপোনাৰ কাম হৈছে ষ্ট্ৰিংটো হাছৱীফ্ট হয় নে নহয় পৰীক্ষা কৰা।\/\/ আপোনাক এটা ষ্ট্ৰিং দিয়া হৈছে s. \/\/\/ >>> is_happy(s: \"a\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"aa\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"aabb\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"adb\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"xyy\")\n\/\/\/ false\nfunc is_happy(s: String) -> Bool {\n","canonical_solution":"func is_happy(s: String) -> Bool {\n    let characters = Array(s)\n    if characters.count < 3 {\n        return false\n    }\n    \n    for i in 0..<(characters.count - 2) {\n        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"},{"task_id":"HumanEval_81","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ 0.0 ই \/\/ > 0.0 ডি- \/\/ > 0.7 D \/\/ > ১.০ ডি+ \/\/ > ১.৩ C- \/\/ > ১.৭ ছেন্টিগ্ৰেড২.০ চি+ \/\/ > ২.৩ বি- \/\/ > ২.৭ বি \/\/ > ৩.০ বি+ \/\/ > ৩.৩ এ- \/\/ > ৩.৭ এ \/\/ ৪.০ এ+ \/ গড়. আখৰ নম্বৰ.\/\/ এটা ফাংচন যি নিম্নলিখিত টেবুল ব্যৱহাৰ কৰি আখৰ শ্ৰেণীৰ এটা এৰে আউটপুট কৰিব পাৰেঃ তেওঁ আপোনাক কিছুমান ছাত্ৰৰ বাবে গ্লেচাৰৰ এক সঞ্চালন দিছে আৰু আপুনি লিখিব লাগিব।একমাত্ৰ সমস্যাটো হ'ল, তেওঁ নম্বৰ দিয়া কোডটো হেৰুৱাই পেলাইছে।শিক্ষকে নিজৰ গ্ৰেডিং এলগৰিথম তৈয়াৰ কৰিছে।এইখন ছেমিষ্টাৰৰ শেষ সপ্তাহ আৰু শিক্ষকে নম্বৰ দিব লাগে।\/\/\/ >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])\n\/\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n","canonical_solution":"func numerical_letter_grade(grades: [Double]) -> [String] {\n    return grades.map { gpa in\n        switch gpa {\n        case 4.0:\n            return \"A+\"\n        case 3.7...4.0:\n            return \"A\"\n        case 3.3..<3.7:\n            return \"A-\"\n        case 3.0..<3.3:\n            return \"B+\"\n        case 2.7..<3.0:\n            return \"B\"\n        case 2.3..<2.7:\n            return \"B-\"\n        case 2.0..<2.3:\n            return \"C+\"\n        case 1.7..<2.0:\n            return \"C\"\n        case 1.3..<1.7:\n            return \"C-\"\n        case 1.0..<1.3:\n            return \"D+\"\n        case 0.7..<1.0:\n            return \"D\"\n        case 0.0..<0.7:\n            return \"D-\"\n        default:\n            return \"E\"\n        }\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\nassert(numerical_letter_grade(grades: [1.2]) == [\"D+\"])\nassert(numerical_letter_grade(grades: [0.5]) == [\"D-\"])\nassert(numerical_letter_grade(grades: [0.0]) == [\"E\"])\nassert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\nassert(numerical_letter_grade(grades: [0.0, 0.7]) == [\"E\", \"D-\"])"},{"task_id":"HumanEval_82","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ দৈৰ্ঘ্য এটা মৌলিক সংখ্যা বা অন্যথা মিছা এটা ফাংচন লিখা যি এটা ষ্ট্ৰিং লয় আৰু যদি ষ্ট্ৰিংটো হয় সত্য বুলি উভতাই দিয়ে\/\/\/ >>> prime_length(string: \"Hello\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"abcdcba\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"kittens\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"orange\")\n\/\/\/ false\nfunc prime_length(string: String) -> Bool {\n","canonical_solution":"func prime_length(string: String) -> Bool {\n    let length = string.count\n    \n    guard length > 1 else {\n        return false\n    }\n    \n    for i in 2..<length {\n        if length % i == 0 {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_length(string: \"Hello\") == true)\nassert(prime_length(string: \"abcdcba\") == true)\nassert(prime_length(string: \"kittens\") == true)\nassert(prime_length(string: \"orange\") == false)\nassert(prime_length(string: \"wow\") == true)\nassert(prime_length(string: \"world\") == true)\nassert(prime_length(string: \"MadaM\") == true)\nassert(prime_length(string: \"Wow\") == true)\nassert(prime_length(string: \"\") == false)\nassert(prime_length(string: \"HI\") == true)\nassert(prime_length(string: \"go\") == true)\nassert(prime_length(string: \"gogo\") == false)\nassert(prime_length(string: \"aaaaaaaaaaaaaaa\") == false)\nassert(prime_length(string: \"Madam\") == true)\nassert(prime_length(string: \"M\") == false)\nassert(prime_length(string: \"0\") == false)"},{"task_id":"HumanEval_83","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ধনাত্মক পূৰ্ণ সংখ্যা যি 1 ৰ সৈতে আৰম্ভ বা শেষ হয়।\/\/ এটা ধনাত্মক n সংখ্যা দিয়া হ'লে, n অংক থকা সংখ্যাৰ গণনা ঘূৰাই দিয়ক func starts_one_ends(n: Int) -> Int {\n","canonical_solution":"func starts_one_ends(n: Int) -> Int {\n    if n == 1 {\n        \/\/ For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.\n        return 1\n    }\n    \n    \/\/ Count of n-digit numbers starting with 1:\n    \/\/ First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.\n    let startWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Count of n-digit numbers ending with 1:\n    \/\/ Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.\n    \/\/ So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.\n    let endWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Intersection of both sets is the numbers starting and ending with 1\n    \/\/ which are of the form `1` followed by (n-2) digits and `1`, so:\n    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))\n    \n    return startWithOne + endWithOne - startAndEndWithOne\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n: 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4) == 1800)\nassert(starts_one_ends(n: 5) == 18000)"},{"task_id":"HumanEval_84","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ এটা ধনাত্মক পূৰ্ণ সংখ্যা N দিয়া হ'লে, ইয়াৰ অংকবোৰৰ যোগফল বাইনেৰী পদ্ধতিত ঘূৰাই দিয়া হ'ব।\/\/\/ >>> solve(N: 1000)\n\/\/\/ \"1\"\n\/\/\/ >>> solve(N: 150)\n\/\/\/ \"110\"\n\/\/\/ >>> solve(N: 147)\n\/\/\/ \"1100\"\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfunc solve(N: Int) -> String {\n","canonical_solution":"func solve(N: Int) -> String {\n    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    return String(sumOfDigits, radix: 2)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"},{"task_id":"HumanEval_85","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ এটা অ-খালি অখণ্ড সংখ্যাৰ অ্যাৰে দিয়া হ'লে, প্ৰথমতে অস্বাভাৱিক সূচক থকা জোৰা সংখ্যাবোৰ যোগ কৰা হ'ব...\/\/\/ >>> add(lst: [4, 2, 6, 7])\n\/\/\/ 2\nfunc add(lst: [Int]) -> Int {\n","canonical_solution":"func add(lst: [Int]) -> Int {\n    var sum = 0\n    for i in stride(from: 1, to: lst.count, by: 2) {\n        if lst[i] % 2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(lst: [4, 88]) == 88)\nassert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)\nassert(add(lst: [4, 0, 6, 7]) == 0)\nassert(add(lst: [4, 4, 6, 8]) == 12)"},{"task_id":"HumanEval_86","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ টোকাঃ আপুনি বাক্যত শব্দৰ ক্ৰম আৰু খালী স্থান ৰাখিব লাগিব।\/\/ ASCII মানৰ ওপৰত ভিত্তি কৰি ক্ৰমান্বয়ে বৃদ্ধি কৰা।\/\/ নতুন শব্দৰ দ্বাৰা সলনি কৰা হয় য'ত সকলো বৰ্ণ ত সজ্জিত কৰা হয়\/\/ String ৰ এটা ordered version, এটা string য'ত সকলো শব্দ (স্পেচত পৃথক) এটা ফাংচন লিখক যি এটা ষ্ট্ৰিং লয় আৰু তাৰ এটা আদেশযুক্ত সংস্কৰণ ঘূৰাই আনে।\/\/\/ >>> anti_shuffle(s: \"Hi\")\n\/\/\/ \"Hi\"\n\/\/\/ >>> anti_shuffle(s: \"hello\")\n\/\/\/ \"ehllo\"\n\/\/\/ >>> anti_shuffle(s: \"Hello World!!!\")\n\/\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s: String) -> String {\n","canonical_solution":"func anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy: .whitespaces)\n    let orderedWords = words.map { String($0.sorted()) }\n    var result = \"\"\n    var wordIndex = 0\n    \n    for character in s {\n        if character.isWhitespace {\n            result.append(character)\n        } else if wordIndex < orderedWords.count {\n            if let currentWord = orderedWords[wordIndex].first {\n                result.append(currentWord)\n                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)\n            }\n        }\n        \n        if let lastCharacter = result.last {\n            if lastCharacter.isWhitespace {\n                wordIndex += 1\n            }\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"},{"task_id":"HumanEval_87","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ লগতে, ক্ৰমবৰ্ধমান ক্ৰমত কলামৰ দ্বাৰা শাৰীটোৰ সমন্বয়বোৰ ছৰ্ট কৰক।\/\/ অংকবোৰ প্ৰথমে ক্ৰমবৰ্ধমান ক্ৰমত শাৰী অনুসাৰে ছৰ্ট কৰক।\/\/ প্ৰতিটো টুপল এটা সমন্বয় - (শাৰী, স্তম্ভ), 0 ৰ পৰা আৰম্ভ হয়।\/\/ আৰু টুপলসমূহৰ এটা এৰেজ ঘূৰাই দিব, [(x1, y1), (x2, y2) ...] যেনে \/\/ lst, আৰু পূৰ্ণ সংখ্যা x দিয়া হ'লে, সমতলটোত পূৰ্ণ সংখ্যা x বিচাৰি উলিওৱা, \/\/ প্ৰতিটো শাৰীত বিভিন্ন সংখ্যক কলাম থাকিব পাৰে।\/\/ যিটো মেট্ৰিক্সৰ লগত একে, কিন্তু মেট্ৰিক্সৰ বিৰূদ্ধে,\/\/ আপোনাক এটা 2D ডাটা দিয়া হৈছে, এটা নেষ্টড এৰে হিচাপে, \/\/\/ >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n\/\/\/ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(lst: [] as [[Int]], x: 1)\n\/\/\/ [] as [(Int, Int)]\n\/\/\/ >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)\n\/\/\/ [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n","canonical_solution":"func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var coordinates: [(Int, Int)] = []\n    \n    for (rowIndex, row) in lst.enumerated() {\n        for (colIndex, value) in row.enumerated() {\n            if value == x {\n                coordinates.append((rowIndex, colIndex))\n            }\n        }\n    }\n    \n    let sortedCoordinates = coordinates.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n        } else {\n            return $0.0 < $1.0\n        }\n    }\n    \n    return sortedCoordinates\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"},{"task_id":"HumanEval_88","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ * দিয়া এৰে সলনি নকৰিব. \/\/ টোকাঃ \/\/ অথবা ইয়াক নিম্নগামী ক্ৰমত ছৰ্ট কৰক যদি যোগফলটো (প্ৰথম সূচকৰ মান, অন্তিম সূচকৰ মান) জোৰা হয়।\/\/ যদি যোগফলটো (প্ৰথম সূচক মান, অন্তিম সূচক মান) অস্বাভাৱিক হয়, তেন্তে আপুনি দিয়া এৰেক ক্ৰমান্বয়ে ছৰ্ট কৰিব, \/\/ অ-নতিবাচক অখণ্ড সংখ্যাৰ এটা অ্যারে দিয়া হ'লে, ছ'ৰ্টিং কৰাৰ পিছত, দিয়া অ্যারেৰ এটা ক'স্ভিফ্ট ঘূৰাই দিয়া হ'ব, \/\/\/ >>> sort_array(array: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ >>> sort_array(array: [5])\n\/\/\/ [5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5])\n\/\/\/ [0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])\n\/\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunc sort_array(array: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(array: [Int]) -> [Int] {\n    guard let first = array.first, let last = array.last else {\n        return array\n    }\n    let sum = first + last\n    if sum % 2 == 0 {\n        return array.sorted(by: >) \/\/ Descending order\n    } else {\n        return array.sorted() \/\/ Ascending order\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(array: [] as [Int]) == [] as [Int])\nassert(sort_array(array: [5]) == [5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\nassert(sort_array(array: [2, 1]) == [1, 2])\nassert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\nassert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"},{"task_id":"HumanEval_89","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ দুই স্থানলৈ দুই গুণ কৰি তললৈ স্থানান্তৰ কৰা।\/\/ বৰ্ণমালাৰ আখৰবোৰ এনেদৰে ঘূৰাই দিব লাগে যাতে আখৰবোৰ \/\/ এটা ক্ৰম ঘূৰাই আনে য'ত বৰ্ণমালাৰ পৰিৱৰ্তন হয়।\/\/ এটা ফাংচন এনক্ৰিপ্ট সৃষ্টি কৰক যি এটা ষ্ট্ৰিংক এটা আর্গুমেন্ট হিচাপে লয় আৰু \/\/\/ >>> encrypt(s: \"hi\")\n\/\/\/ \"lm\"\n\/\/\/ >>> encrypt(s: \"asdfghjkl\")\n\/\/\/ \"ewhjklnop\"\n\/\/\/ >>> encrypt(s: \"gf\")\n\/\/\/ \"kj\"\n\/\/\/ >>> encrypt(s: \"et\")\n\/\/\/ \"ix\"\nfunc encrypt(s: String) -> String {\n","canonical_solution":"func encrypt(s: String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let shift = 2 * 2 \/\/ shift down by two multiplied by two places, i.e., 4\n    var result = \"\"\n\n    for character in s {\n        if let index = alphabet.firstIndex(of: character) {\n            let newIndex = (index + shift) % alphabet.count\n            result.append(alphabet[newIndex])\n        } else {\n            result.append(character) \/\/ append non-alphabetic characters unchanged\n        }\n    }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") == \"e\")"},{"task_id":"HumanEval_90","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ যদি তেনে কোনো উপাদান নাই তেন্তে nil ঘূৰাই দিব. \/\/ এটা ফাংচন next_smallest লিখক যি এৰেৰ দ্বিতীয় ক্ষুদ্ৰতম উপাদানটো ঘূৰাই দিয়ে।\/\/ আপোনাক এটা সম্পূৰ্ণ সংখ্যাৰ অ্যারে দিয়া হৈছে।\/\/\/ >>> next_smallest(lst: [1, 2, 3, 4, 5])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [] as [Int])\n\/\/\/ nil\n\/\/\/ >>> next_smallest(lst: [1, 1])\n\/\/\/ nil\nfunc next_smallest(lst: [Int]) -> Int? {\n","canonical_solution":"func next_smallest(lst: [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    \n    var uniqueSorted = Array(Set(lst)).sorted()\n    \n    if uniqueSorted.count < 2 {\n        return nil\n    }\n    \n    return uniqueSorted[1]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"},{"task_id":"HumanEval_91","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ বাক্যবোৰ '.', '?' বা '!' ৰে সীমাবদ্ধ।\"I\" শব্দৰে আৰম্ভ হোৱা এটা বাক্য হৈছে \"boredom\"\/\/ আপোনাক এটা শব্দৰ শাৰী দিয়া হ'ব, আৰু আপোনাৰ কাম হ'ব সংখ্যাটো গণনা কৰা \/\/\/ >>> is_bored(S: \"Hello world\")\n\/\/\/ 0\n\/\/\/ >>> is_bored(S: \"The sky is blue. The sun is shining. I love this weather\")\n\/\/\/ 1\nfunc is_bored(S: String) -> Int {\n","canonical_solution":"func is_bored(S: String) -> Int {\n    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }\n    var boredomCount = 0\n    \n    for sentence in sentences {\n        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)\n        if trimmedSentence.hasPrefix(\"I\") {\n            boredomCount += 1\n        }\n    }\n    \n    return boredomCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_bored(S: \"Hello world\") == 0)\nassert(is_bored(S: \"Is the sky blue?\") == 0)\nassert(is_bored(S: \"I love It !\") == 1)\nassert(is_bored(S: \"bIt\") == 0)\nassert(is_bored(S: \"I feel good today. I will be productive. will kill It\") == 2)\nassert(is_bored(S: \"You and I are going for a walk\") == 0)"},{"task_id":"HumanEval_92","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ অন্য যিকোনো ক্ষেত্ৰত false ঘূৰাই আনে. \/\/ যদি এটা সংখ্যা বাকী দুটা সংখ্যাৰ যোগফলৰ সমান হয় আৰু সকলো সংখ্যা সম্পূৰ্ণ সংখ্যা হয় তেন্তে true প্ৰাপ্ত কৰা হয়।এটা ফাংচন সৃষ্টি কৰক যিয়ে ৩টা সংখ্যা গ্ৰহণ কৰে।\/\/\/ >>> any_int(x: 5, y: 2, z: 7)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3, y: 2, z: 2)\n\/\/\/ false\n\/\/\/ >>> any_int(x: 3, y: -2, z: 1)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3.6, y: -2.2, z: 2)\n\/\/\/ false\nfunc any_int(x: Double, y: Double, z: Double) -> Bool {\n","canonical_solution":"func any_int(x: Double, y: Double, z: Double) -> Bool {\n    guard x == floor(x), y == floor(y), z == floor(z) else {\n        return false\n    }\n    \n    let a = Int(x)\n    let b = Int(y)\n    let c = Int(z)\n    \n    return a == b + c || b == a + c || c == a + b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(any_int(x: 2, y: 3, z: 1) == true)\nassert(any_int(x: 2.5, y: 2, z: 3) == false)\nassert(any_int(x: 1.5, y: 5, z: 3.5) == false)\nassert(any_int(x: 2, y: 6, z: 2) == false)\nassert(any_int(x: 4, y: 2, z: 2) == true)\nassert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)\nassert(any_int(x: -4, y: 6, z: 2) == true)\nassert(any_int(x: 2, y: 1, z: 1) == true)\nassert(any_int(x: 3, y: 4, z: 7) == true)\nassert(any_int(x: 3.0, y: 4, z: 7) == false)"},{"task_id":"HumanEval_93","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ কেৱল আখৰবোৰ অনুমান কৰক।\/\/ ইংৰাজী বৰ্ণমালাৰ স্বৰবৰ্ণ। \/\/ বাৰ্তাৰ লগত চিঠি যিটো তাৰ আগতে 2টা স্থানত দেখা যায় \/\/ এই পদ্ধতিত সকলো আখৰৰে কেচ সলনি হয়, সকলো স্বৰবৰ্ণৰ ঠাইত এটা ফাংচন লিখা যিয়ে এটা বাৰ্তা গ্ৰহণ কৰে আৰু এনে এটা বাৰ্তাত এনকোড কৰে যে\/\/\/ >>> encode(message: \"test\")\n\/\/\/ \"TGST\"\n\/\/\/ >>> encode(message: \"This is a message\")\n\/\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n","canonical_solution":"func encode(message: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    let vowelReplacement = [\n        \"a\": \"c\", \"e\": \"g\", \"i\": \"k\", \"o\": \"q\", \"u\": \"w\",\n        \"A\": \"C\", \"E\": \"G\", \"I\": \"K\", \"O\": \"Q\", \"U\": \"W\"\n    ]\n    \n    var encodedMessage = \"\"\n    \n    for char in message {\n        if vowels.contains(char) {\n            if let replacement = vowelReplacement[String(char)] {\n                encodedMessage.append(replacement)\n            }\n        } else {\n            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())\n            encodedMessage.append(swappedCase)\n        }\n    }\n    \n    return encodedMessage\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"},{"task_id":"HumanEval_94","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ আপুনি আটাইতকৈ ডাঙৰ অগ্ৰ মানটো বিচাৰি উলিয়াব লাগিব আৰু তাৰ অংকবোৰৰ যোগফল ঘূৰাই দিব লাগিব।\/\/ আপোনাক এটা সম্পূৰ্ণ সংখ্যাৰ অ্যারে দিয়া হৈছে।\/\/\/ >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfunc skjkasdkd(lst: [Int]) -> Int {\n","canonical_solution":"func skjkasdkd(lst: [Int]) -> Int {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    var largestPrime: Int? = nil\n    for number in lst {\n        if isPrime(number) {\n            if largestPrime == nil || number > largestPrime! {\n                largestPrime = number\n            }\n        }\n    }\n    \n    if let largestPrime = largestPrime {\n        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    }\n    \n    return 0 \/\/ In case there are no prime numbers\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)\nassert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)\nassert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)\nassert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)\nassert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)\nassert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)\nassert(skjkasdkd(lst: [8191]) == 19)\nassert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)\nassert(skjkasdkd(lst: [127, 97, 8192]) == 10)"},{"task_id":"HumanEval_96","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ স্বৰূপেঃ \/\/ অখণ্ড সংখ্যা যিটো অগ্ৰ সংখ্যা আৰু n তকৈ সৰু। \/\/ এটা ফাংচন প্ৰয়োগ কৰক যি এটা অ-নতিবাচক পূৰ্ণ সংখ্যা লয় আৰু প্ৰথম n ৰ এটা অ্যারে ঘূৰাই আনে ।\/\/\/ >>> count_up_to(n: 5)\n\/\/\/ [2, 3]\n\/\/\/ >>> count_up_to(n: 11)\n\/\/\/ [2, 3, 5, 7]\n\/\/\/ >>> count_up_to(n: 0)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 20)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(n: 1)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 18)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunc count_up_to(n: Int) -> [Int] {\n","canonical_solution":"func count_up_to(n: Int) -> [Int] {\n    guard n > 2 else { return [] }\n    \n    var primes: [Int] = [2]\n    \n    for number in 3..<n {\n        var isPrime = true\n        for prime in primes {\n            if prime * prime > number {\n                break\n            }\n            if number % prime == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes.append(number)\n        }\n    }\n    \n    return primes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_up_to(n: 5) == [2, 3])\nassert(count_up_to(n: 6) == [2, 3, 5])\nassert(count_up_to(n: 7) == [2, 3, 5])\nassert(count_up_to(n: 10) == [2, 3, 5, 7])\nassert(count_up_to(n: 0) == [] as [Int])\nassert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])\nassert(count_up_to(n: 1) == [] as [Int])\nassert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])\nassert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\nassert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"},{"task_id":"HumanEval_97","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ ধাৰণা কৰা যে ইনপুটটো সদায় বৈধ।\/\/ তেওঁলোকৰ একক অংকবোৰৰ উৎপাদনৰ সংখ্যা।\/\/ দুটা পূৰ্ণ সংখ্যা লৈ ফাংচনটো সম্পূৰ্ণ কৰক আৰু উভতাই দিয়ক \/\/\/ >>> multiply(a: 148, b: 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(a: 19, b: 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(a: 2020, b: 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(a: 14, b: -15)\n\/\/\/ 20\nfunc multiply(a: Int, b: Int) -> Int {\n","canonical_solution":"func multiply(a: Int, b: Int) -> Int {\n    let unitDigitA = abs(a % 10)\n    let unitDigitB = abs(b % 10)\n    return unitDigitA * unitDigitB\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply(a: 148, b: 412) == 16)\nassert(multiply(a: 19, b: 28) == 72)\nassert(multiply(a: 2020, b: 1851) == 0)\nassert(multiply(a: 14, b: -15) == 20)\nassert(multiply(a: 76, b: 67) == 42)\nassert(multiply(a: 17, b: 27) == 49)\nassert(multiply(a: 0, b: 1) == 0)\nassert(multiply(a: 0, b: 0) == 0)"},{"task_id":"HumanEval_98","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ এটা ষ্ট্ৰিং s দিয়া হ'লে, সম সূচকত থকা বড়ো স্বৰসমূহৰ সংখ্যা গণনা কৰা।\/\/\/ >>> count_upper(s: \"aBCdEf\")\n\/\/\/ 1\n\/\/\/ >>> count_upper(s: \"abcdefg\")\n\/\/\/ 0\n\/\/\/ >>> count_upper(s: \"dBBE\")\n\/\/\/ 0\nfunc count_upper(s: String) -> Int {\n","canonical_solution":"func count_upper(s: String) -> Int {\n    let upperVowels = Set<Character>([\"A\", \"E\", \"I\", \"O\", \"U\"])\n    var count = 0\n\n    for (index, char) in s.enumerated() {\n        if index % 2 == 0 && upperVowels.contains(char) {\n            count += 1\n        }\n    }\n\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"},{"task_id":"HumanEval_99","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ দুটা পূৰ্ণসংখ্যাৰ পৰা, ইয়াক শূন্যৰ পৰা দূৰলৈ ঘূৰাই ল'ব.যদি সংখ্যাটো সমান দূৰত্বত থাকে, তেন্তে ইয়াক সম-দূৰত্বত থকা সংখ্যা বুলি কোৱা হয়।\/\/ এটা সংখ্যা প্ৰতিনিধিত্ব কৰা এটা মান (ষ্ট্ৰিং) গ্ৰহণ কৰা এটা ফাংচন সৃষ্টি কৰক ।\/\/\/ >>> closest_integer(value: \"10\")\n\/\/\/ 10\n\/\/\/ >>> closest_integer(value: \"15.3\")\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n","canonical_solution":"func closest_integer(value: String) -> Int {\n    if let number = Double(value) {\n        return Int(number.rounded(.awayFromZero))\n    }\n    return 0 \/\/ or handle error as needed\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"},{"task_id":"HumanEval_100","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ i স্তৰৰ শিলৰ সংখ্যা (i+1) ।\/\/ এটা এৰেজত প্ৰতিটো স্তৰত থকা শিলৰ সংখ্যা ঘূৰাই আনে, য'ত সূচকৰ এলেমেণ্ট \/\/ - যদি n জোৰা হয়, তেন্তে পৰৱৰ্তী জোৰা সংখ্যাটো।\/\/ - যদি n অগণন হয়, তেন্তে পৰৱৰ্তী অগণন সংখ্যাটো।\/\/ পৰৱৰ্তী স্তৰত শিলৰ সংখ্যা হ'লঃ \/\/ প্ৰথম স্তৰত nটা শিল আছে।এটা ধনাত্মক পূৰ্ণ সংখ্যা n দিলে, আপুনি n স্তৰৰ শিলৰ এটা গুটি তৈয়াৰ কৰিব লাগিব।\/\/\/ >>> make_a_pile(n: 3)\n\/\/\/ [3, 5, 7]\nfunc make_a_pile(n: Int) -> [Int] {\n","canonical_solution":"func make_a_pile(n: Int) -> [Int] {\n    var pile = [Int]()\n    var currentLevelStones = n\n    \n    for _ in 0..<n {\n        pile.append(currentLevelStones)\n        if n % 2 == 0 {\n            currentLevelStones += 2\n        } else {\n            currentLevelStones += 2\n        }\n    }\n    \n    return pile\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n: 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"},{"task_id":"HumanEval_101","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ শব্দবোৰ শাৰীলৈ বিভাজন কৰি এটা শব্দৰ এৰেজ ঘূৰাই দিব।\/\/ আপোনাক কমা বা স্পেচৰে পৃথক কৰা শব্দৰ এটা শৃংখলা দিয়া হ'ব। আপোনাৰ কাম হ'ল \/\/\/ >>> words_string(s: \"Hi, my name is John\")\n\/\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/\/ >>> words_string(s: \"One, two, three, four, five, six\")\n\/\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunc words_string(s: String) -> [String] {\n","canonical_solution":"func words_string(s: String) -> [String] {\n    let separators = CharacterSet(charactersIn: \", \")\n    return s.components(separatedBy: separators).filter { !$0.isEmpty }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_string(s: \"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\nassert(words_string(s: \"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"Hi, my name\") == [\"Hi\", \"my\", \"name\"])\nassert(words_string(s: \"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"\") == [] as [String])\nassert(words_string(s: \"ahmed     , gamal\") == [\"ahmed\", \"gamal\"])"},{"task_id":"HumanEval_102","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ যদি এনে কোনো সংখ্যা নাই, তেন্তে ফাংচনে -1 ঘূৰাই দিব লাগে।\/\/ আটাইতকৈ ডাঙৰ সমসংখ্যাৰ সংখ্যা যিটো [x, y] অন্তৰ্ভুক্ত। যদি \/\/ এই ফাংচনে দুটা ধনাত্মক সংখ্যা x আৰু y লৈ \/\/\/ >>> choose_num(x: 12, y: 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(x: 13, y: 12)\n\/\/\/ -1\nfunc choose_num(x: Int, y: Int) -> Int {\n","canonical_solution":"func choose_num(x: Int, y: Int) -> Int {\n    \/\/ Determine the starting and ending range values\n    let start = min(x, y)\n    let end = max(x, y)\n    \n    \/\/ Iterate from the end of the range to the start\n    for num in (start...end).reversed() {\n        \/\/ Check if the current number is even\n        if num % 2 == 0 {\n            return num\n        }\n    }\n    \n    \/\/ Return -1 if no even number is found\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(choose_num(x: 12, y: 15) == 14)\nassert(choose_num(x: 13, y: 12) == -1)\nassert(choose_num(x: 33, y: 12354) == 12354)\nassert(choose_num(x: 5234, y: 5233) == -1)\nassert(choose_num(x: 6, y: 29) == 28)\nassert(choose_num(x: 27, y: 10) == -1)\nassert(choose_num(x: 7, y: 7) == -1)\nassert(choose_num(x: 546, y: 546) == 546)"},{"task_id":"HumanEval_103","nl":"asm_Beng","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ উদাহৰণঃ \/\/ যদি n m ৰ পৰা ডাঙৰ হয়, তেন্তে -1 ঘূৰাই দিব.\/\/ উত্তৰটো আটাইতকৈ ওচৰৰ পূৰ্ণ সংখ্যালৈ ঘূৰাই লওক আৰু ইয়াক বাইনেৰীলৈ ৰূপান্তৰ কৰক।\/\/ n ৰ পৰা m লৈকে (n আৰু m সহ) সম্পূৰ্ণ সংখ্যাৰ গড়।\/\/ আপোনাক দুটা ধনাত্মক পূৰ্ণ সংখ্যা n আৰু m দিয়া হৈছে, আৰু আপোনাৰ কাম হ'ল \/\/\/ >>> rounded_avg(n: 1, m: 5)\n\/\/\/ .success(\"0b11\")\n\/\/\/ >>> rounded_avg(n: 7, m: 5)\n\/\/\/ .failure(-1)\n\/\/\/ >>> rounded_avg(n: 10, m: 20)\n\/\/\/ .success(\"0b1111\")\n\/\/\/ >>> rounded_avg(n: 20, m: 33)\n\/\/\/ .success(\"0b11010\")\nfunc rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n","canonical_solution":"func rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n    if n > m {\n        return .failure(-1)\n    }\n    \n    let count = m - n + 1\n    let sum = (n + m) * count \/ 2\n    let average = Double(sum) \/ Double(count)\n    let roundedAverage = Int(average.rounded())\n    let binaryString = String(roundedAverage, radix: 2)\n    \n    return .success(\"0b\" + binaryString)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rounded_avg(n: 1, m: 5) == .success(\"0b11\"))\nassert(rounded_avg(n: 7, m: 13) == .success(\"0b1010\"))\nassert(rounded_avg(n: 964, m: 977) == .success(\"0b1111001010\"))\nassert(rounded_avg(n: 996, m: 997) == .success(\"0b1111100100\"))\nassert(rounded_avg(n: 560, m: 851) == .success(\"0b1011000010\"))\nassert(rounded_avg(n: 185, m: 546) == .success(\"0b101101110\"))\nassert(rounded_avg(n: 362, m: 496) == .success(\"0b110101101\"))\nassert(rounded_avg(n: 350, m: 902) == .success(\"0b1001110010\"))\nassert(rounded_avg(n: 197, m: 233) == .success(\"0b11010111\"))\nassert(rounded_avg(n: 7, m: 5) == .failure(-1))\nassert(rounded_avg(n: 5, m: 1) == .failure(-1))\nassert(rounded_avg(n: 5, m: 5) == .success(\"0b101\"))"},{"task_id":"HumanEval_104","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ টোকাঃ ঘূৰি অহা এৰে বৃদ্ধিৰ ক্ৰমত বাছনি কৰা উচিত।\/\/ কোনো জোৰা সংখ্যা নথকা উপাদান।\/\/ এটা ধনাত্মক পূৰ্ণসংখ্যাৰ অ্যারে দিয়া হ'লে x. এটা সকলোবোৰ অক্ষৰৰ এক বাছনি কৰা অ্যারে ঘূৰাই আনে ।\/\/\/ >>> unique_digits(x: [15, 33, 1422, 1])\n\/\/\/ [1, 15, 33]\n\/\/\/ >>> unique_digits(x: [152, 323, 1422, 10])\n\/\/\/ [] as [Int]\nfunc unique_digits(x: [Int]) -> [Int] {\n","canonical_solution":"func unique_digits(x: [Int]) -> [Int] {\n    return x.filter { number in\n        var hasEvenDigit = false\n        var num = number\n        while num > 0 {\n            if (num % 10) % 2 == 0 {\n                hasEvenDigit = true\n                break\n            }\n            num \/= 10\n        }\n        return !hasEvenDigit\n    }.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])\nassert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])\nassert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])\nassert(unique_digits(x: [135, 103, 31]) == [31, 135])"},{"task_id":"HumanEval_105","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ এক, দুই, তিনি, চাৰি, পাঁচ, ছয়, সাত, আঠ, ন'\/\/ ফলাফলৰ এৰে উলটি, আৰু তাৰ পিছত প্ৰতিটো অংকক ইয়াৰ সৈতে সম্পৰ্কিত নামৰ সৈতে প্ৰতিস্থাপন কৰক \/\/ এটা অখণ্ড সংখ্যাৰ অ্যারে দিয়া হ'লে, 1 আৰু 9 ৰ মাজত থকা অখণ্ড সংখ্যাবোৰ ছৰ্প কৰক,\/\/\/ >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/\/ If the array is empty, return an empty array:\n\/\/\/ >>> by_length(arr: [] as [Int])\n\/\/\/ [] as [String]\n\/\/\/ If the array has any strange number ignore it:\n\/\/\/ >>> by_length(arr: [1, -1, 55])\n\/\/\/ [\"One\"]\nfunc by_length(arr: [Int]) -> [String] {\n","canonical_solution":"func by_length(arr: [Int]) -> [String] {\n    let numberNames: [Int: String] = [\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    ]\n    \n    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }\n                                           .sorted(by: >)\n    \n    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? \"\" }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\nassert(by_length(arr: [] as [Int]) == [] as [String])\nassert(by_length(arr: [1, -1, 55]) == [\"One\"])\nassert(by_length(arr: [1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\nassert(by_length(arr: [9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])"},{"task_id":"HumanEval_106","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ i ৰ কাৰক হ'ল 1 ৰ পৰা i লৈ থকা সংখ্যাবোৰৰ গুণফল (1 * 2 * ... * i) ।\/\/ i 1 ৰ পৰা আৰম্ভ হয়.\/\/ বা 1 ৰ পৰা i লৈকে সংখ্যাৰ যোগফল অন্যথা।\/\/ আৰু আকাৰ n ৰ এটা এৰে ঘূৰাই আনে, যাতে সূচক i ত থকা উপাদানৰ মানটো যদি i সম হয়, তেন্তে i ৰ ফেক্টৰিয়েল হয়।\/\/ f ফাংচনটো প্ৰণয়ন কৰক যি n কে পৰিমাপ হিচাপে লয়, \/\/\/ >>> f(n: 5)\n\/\/\/ [1, 2, 6, 24, 15]\nfunc f(n: Int) -> [Int] {\n","canonical_solution":"func f(n: Int) -> [Int] {\n    func factorial(_ x: Int) -> Int {\n        guard x > 1 else { return 1 }\n        return (1...x).reduce(1, *)\n    }\n    \n    func sumTo(_ x: Int) -> Int {\n        return (1...x).reduce(0, +)\n    }\n    \n    var result = [Int]()\n    for i in 1...n {\n        if i % 2 == 0 {\n            result.append(factorial(i))\n        } else {\n            result.append(sumTo(i))\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 5) == [1, 2, 6, 24, 15])\nassert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])\nassert(f(n: 1) == [1])\nassert(f(n: 3) == [1, 2, 6])"},{"task_id":"HumanEval_107","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ ১ঃ \/\/ পৰিসৰৰ ভিতৰত থকা পূৰ্ণসংখ্যাৰ পালিনড্ৰমসমূহ ((1, n), অন্তৰ্ভুক্ত কৰা হৈছে। \/\/ এটা ধনাত্মক পূৰ্ণ সংখ্যা n দিয়া হ'লে, এটা সম আৰু অস্বাভাৱিক সংখ্যাৰ সৈতে এটা টুপল ঘূৰাই দিয়া হ'ব \/\/\/ >>> even_odd_palindrome(n: 3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(n: 12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_palindrome(n: Int) -> (Int, Int) {\n    func isPalindrome(_ num: Int) -> Bool {\n        let str = String(num)\n        return str == String(str.reversed())\n    }\n    \n    var evenCount = 0\n    var oddCount = 0\n    \n    for i in 1...n {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n                evenCount += 1\n            } else {\n                oddCount += 1\n            }\n        }\n    }\n    \n    return (evenCount, oddCount)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_palindrome(n: 123) == (8, 13))\nassert(even_odd_palindrome(n: 12) == (4, 6))\nassert(even_odd_palindrome(n: 3) == (1, 2))\nassert(even_odd_palindrome(n: 63) == (6, 8))\nassert(even_odd_palindrome(n: 25) == (5, 6))\nassert(even_odd_palindrome(n: 19) == (4, 6))\nassert(even_odd_palindrome(n: 9) == (4, 5))\nassert(even_odd_palindrome(n: 1) == (0, 1))"},{"task_id":"HumanEval_108","nl":"asm_Beng","pl":"swift","prompt":"\nউদাহৰণস্বৰূপে, -১২৩ৰ স্বাক্ষৰ সংখ্যা হৈছে -১, ২, আৰু ৩।\/\/ যদি এটা সংখ্যা ঋণাত্মক হয়, তেন্তে তাৰ প্ৰথম স্বাক্ষৰিত অংকটো ঋণাত্মক হ'ব: \/\/ অংকবোৰৰ যোগফল যিটো 0 ৰ ওপৰত থাকে সেই উপাদানৰ সংখ্যা।\/\/ এটা count_nums ফাংশন লিখা যি এটা অখণ্ড সংখ্যাৰ অ্যারে লয় আৰু ৰিটাৰ্ণ দিয়ে ।\/\/\/ >>> count_nums(arr: [] as [Int])\n\/\/\/ 0\n\/\/\/ >>> count_nums(arr: [-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(arr: [1, 1, 2])\n\/\/\/ 3\nfunc count_nums(arr: [Int]) -> Int {\n","canonical_solution":"func count_nums(arr: [Int]) -> Int {\n    return arr.filter { number in\n        var n = number\n        var sumOfDigits = 0\n\n        while n != 0 {\n            sumOfDigits += n % 10\n            n \/= 10\n        }\n\n        return sumOfDigits > 0\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_nums(arr: [] as [Int]) == 0)\nassert(count_nums(arr: [-1, -2, 0]) == 0)\nassert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)\nassert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)\nassert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)\nassert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)\nassert(count_nums(arr: [0, 1]) == 1)\nassert(count_nums(arr: [1]) == 1)"},{"task_id":"HumanEval_109","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ টোকাঃ প্ৰদান কৰা এৰেৰ অনন্য উপাদান থকাটো নিশ্চিত।\/\/ যদি দিয়া এৰে খালী হয় তেন্তে true ঘূৰাই দিব.\/\/ তাৰ পিছত true ঘূৰাই আনটো false ঘূৰাই দিব. \/\/ যদি ওপৰৰ কাৰ্য্য সম্পাদন কৰি ছৰ্ট কৰা এৰে প্ৰাপ্ত কৰা সম্ভৱ হয় \/\/ অৰিজিনৰ আৰম্ভণিৰ স্থান অৰ্থাৎ 0th সূচক।এই এৰেৰ শেষ উপাদানটো স্থানান্তৰিত হ'ব \/\/ এটা সোঁ সোঁ স্থানান্তৰ কাৰ্য্য মানে এৰেৰ সকলো উপাদান একৰ দ্বাৰা স্থানান্তৰ কৰা ।\/\/ আপুনি যিকোনো সংখ্যক বাৰ ডান স্থানান্তৰ কাৰ্য সম্পাদন কৰিবলৈ অনুমতি দিয়া হৈছে।\/\/ দিয়া এৰেৰ ওপৰত নিম্নলিখিত অপাৰেচনঃ \/\/ এটা অ-হ্ৰাসমান ক্ৰমত এটা এৰে ছৰ্ট কৰা সম্ভৱ আপোনাৰ কাম হ'ল নিৰ্ণয় কৰা যে যদি \/\/ আমাৰ এটা এৰে 'আৰ' আছে N সংখ্যক পূৰ্ণসংখ্যাৰ arr[1], arr[2], ..., arr[N]।\/\/\/ >>> move_one_ball(arr: [3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given array.\n\/\/\/ >>> move_one_ball(arr: [3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ array by performing any number of right shift operations.\nfunc move_one_ball(arr: [Int]) -> Bool {\n","canonical_solution":"func move_one_ball(arr: [Int]) -> Bool {\n    guard !arr.isEmpty else { return true }\n    \n    let n = arr.count\n    var breakPointCount = 0\n    \n    \/\/ Find the number of break points where the array is decreasing\n    for i in 0..<n {\n        if arr[i] > arr[(i + 1) % n] {\n            breakPointCount += 1\n        }\n    }\n    \n    \/\/ If there's at most one break point, the array can be right shifted\n    return breakPointCount <= 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)\nassert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)\nassert(move_one_ball(arr: [4, 3, 1, 2]) == false)\nassert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)\nassert(move_one_ball(arr: [] as [Int]) == true)"},{"task_id":"HumanEval_110","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ অন্যথা, \"NO\" ঘূৰাই দিব\/\/ lst1 ৰ সকলোবোৰ উপাদান সমকামী হ'ব, \"YES\" ঘূৰাই দিব.\/\/ যদি ই সম্ভৱ হয় lst1 আৰু lst2 ৰ মাজত উপাদান বিনিময় কৰিবলৈ \/\/ lst1 আৰু lst2 ৰ মাজত বিনিময় কৰা উপাদানৰ সংখ্যাৰ কোনো সীমা নাই।\/\/ৰ মাজত এটা এৰেজ তৈয়াৰ কৰিব লাগে যাতে lst1 কেৱল জোৰা সংখ্যাৰ এৰেজ হয়।\/\/ আৰু নিৰ্ণয় কৰে যে এটা উপাদানৰ বিনিময় কৰা সম্ভৱনে \/\/ এই সমস্যাত, আপুনি এটা ফাংচন প্ৰয়োগ কৰিব যি দুটা সংখ্যাৰ অ্যারে লয়, \/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])\n\/\/\/ \"YES\"\n\/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])\n\/\/\/ \"NO\"\n\/\/\/ It is assumed that the input arrays will be non-empty.\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n","canonical_solution":"func exchange(lst1: [Int], lst2: [Int]) -> String {\n    var hasOddInLst1 = false\n    var hasEvenInLst2 = false\n    \n    for num in lst1 {\n        if num % 2 != 0 {\n            hasOddInLst1 = true\n            break\n        }\n    }\n    \n    for num in lst2 {\n        if num % 2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasOddInLst1 {\n        return \"YES\"\n    }\n    \n    if hasEvenInLst2 {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == \"YES\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == \"NO\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == \"NO\")\nassert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == \"NO\")\nassert(exchange(lst1: [100, 200], lst2: [200, 200]) == \"YES\")"},{"task_id":"HumanEval_111","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ যদি কেইবাটাও আখৰ একেধৰণৰ হয়, তেন্তে আটাইবোৰ ঘূৰাই দিব.\/\/ আটাইতকৈ বেছি পুনৰাবৃত্তি কৰা আখৰটোৰ আৰু ইয়াৰ সৈতে সম্পৰ্কিত সংখ্যাটো অন্তৰ্ভুক্ত কৰা।\/\/ এটা শাৰী দিয়া হৈছে যি এটা স্পেচ পৃথক সৰু আখৰক প্ৰতিনিধিত্ব কৰে, এটা অভিধান ঘূৰাই আনে \/\/\/ >>> histogram(test: \"a b c\")\n\/\/\/ [\"a\" : 1, \"b\" : 1, \"c\" : 1]\n\/\/\/ >>> histogram(test: \"a b b a\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"a b c a b\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"b b b b a\")\n\/\/\/ [\"b\" : 4]\n\/\/\/ >>> histogram(test: \"\")\n\/\/\/ [:] as [String : Int]\nfunc histogram(test: String) -> [String : Int] {\n","canonical_solution":"func histogram(test: String) -> [String : Int] {\n    var letterCount: [String: Int] = [:]\n\n    \/\/ Split the string into an array of letters\n    let letters = test.split(separator: \" \").map { String($0) }\n\n    \/\/ Count occurrences of each letter\n    for letter in letters {\n        letterCount[letter, default: 0] += 1\n    }\n\n    \/\/ Determine the maximum number of occurrences\n    guard let maxCount = letterCount.values.max() else {\n        return [:] as [String : Int]\n    }\n\n    \/\/ Filter the letterCount dictionary to only include letters with the max count\n    let result = letterCount.filter { $0.value == maxCount }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"},{"task_id":"HumanEval_112","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ আপুনি ফলাফলৰ শাৰী আৰু true\/false থকা এটা টুপল ঘূৰাই দিব লাগিব।\/\/ এটা ষ্ট্ৰিংক পলিণ্ড্ৰ'ম বোলা হয় যদি ই আগলৈ আৰু পিছলৈ একেদৰে পঢ়া হয়।\/\/ তাৰপিছত ফলাফলৰ শাৰীটো পলিণ্ড্ৰ'ম হয় নে নহয় পৰীক্ষা কৰক।\/\/ আমাক দুটা ষ্ট্ৰিং দিয়া হৈছে s আৰু c, আপুনি s ৰ সকলো বৰ্ণ বিলোপ কৰিব লাগিব যি c ৰ যিকোনো বৰ্ণৰ সমান \/\/ কাৰ্য্য \/\/\/ >>> reverse_delete(s: \"abcde\", c: \"ae\")\n\/\/\/ (\"bcd\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdef\", c: \"b\")\n\/\/\/ (\"acdef\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdedcba\", c: \"ab\")\n\/\/\/ (\"cdedc\", true)\nfunc reverse_delete(s: String, c: String) -> (String, Bool) {\n","canonical_solution":"func reverse_delete(s: String, c: String) -> (String, Bool) {\n    \/\/ Remove characters from s that are in c\n    let filteredString = s.filter { !c.contains($0) }\n    \n    \/\/ Check if the resulting string is a palindrome\n    let isPalindrome = filteredString == String(filteredString.reversed())\n    \n    \/\/ Return the resulting string and the palindrome check result\n    return (filteredString, isPalindrome)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_delete(s: \"abcde\", c: \"ae\") == (\"bcd\", false))\nassert(reverse_delete(s: \"abcdef\", c: \"b\") == (\"acdef\", false))\nassert(reverse_delete(s: \"abcdedcba\", c: \"ab\") == (\"cdedc\", true))\nassert(reverse_delete(s: \"dwik\", c: \"w\") == (\"dik\", false))\nassert(reverse_delete(s: \"a\", c: \"a\") == (\"\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"v\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"vabba\", c: \"v\") == (\"abba\", true))\nassert(reverse_delete(s: \"mamma\", c: \"mia\") == (\"\", true))"},{"task_id":"HumanEval_113","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অদ্ভুত অংকবোৰ i'th stringত আছে.\/\/ ইনপুটৰ string i. \" য'ত সকলো i's সংখ্যাৰ দ্বাৰা সলনি কৰা উচিত \/\/ আউটপুটৰ প্ৰতিটো উপাদান i হ'ব লাগিব \"অসমীয়া উপাদানৰ সংখ্যা \/\/ এটা অক্ষৰ ক্ৰম দিয়া হৈছে, য'ত প্ৰতিটো অক্ষৰ ক্ৰম কেৱল অংকৰে গঠিত, এটা অক্ষৰ ক্ৰম ঘূৰাই দিব.\/\/\/ >>> odd_count(lst: [\"1234567\"])\n\/\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/\/ >>> odd_count(lst: [\"3\", \"11111111\"])\n\/\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunc odd_count(lst: [String]) -> [String] {\n","canonical_solution":"func odd_count(lst: [String]) -> [String] {\n    return lst.map { str in\n        let oddCount = str.filter { \"13579\".contains($0) }.count\n        return \"the number of odd elements \\(oddCount)n the str\\(oddCount)ng \\(oddCount) of the \\(oddCount)nput.\"\n    }\n}\n\n\/\/ Example Usage\nprint(odd_count(lst: [\"1234567\"]))\nprint(odd_count(lst: [\"3\", \"11111111\"]))","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_count(lst: [\"1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\nassert(odd_count(lst: [\"3\", \"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\nassert(odd_count(lst: [\"271\", \"137\", \"314\"]) == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])"},{"task_id":"HumanEval_114","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ সংখ্যাৰ. \/\/ এটা অখণ্ড সংখ্যাৰ অ্যারে দিয়া হ'লে, কোনো অ-খালি উপ-অ্যাৰেৰ ন্যূনতম যোগফলটো বিচাৰক \/\/\/ >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(nums: [-1, -2, -3])\n\/\/\/ -6\nfunc minSubArraySum(nums: [Int]) -> Int {\n","canonical_solution":"func minSubArraySum(nums: [Int]) -> Int {\n    guard !nums.isEmpty else { return 0 }\n    \n    var currentMin = nums[0]\n    var overallMin = nums[0]\n    \n    for i in 1..<nums.count {\n        currentMin = min(nums[i], currentMin + nums[i])\n        overallMin = min(overallMin, currentMin)\n    }\n    \n    return overallMin\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)\nassert(minSubArraySum(nums: [-1, -2, -3]) == -6)\nassert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)\nassert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)\nassert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)\nassert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)\nassert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)\nassert(minSubArraySum(nums: [-10]) == -10)\nassert(minSubArraySum(nums: [7]) == 7)\nassert(minSubArraySum(nums: [1, -1]) == -1)"},{"task_id":"HumanEval_115","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ ১ঃ \/\/ আপুনি কিমানবাৰ বাল্টিবোৰ নামাব লাগে তাৰ সংখ্যা আউটপুট কৰক।তোমাৰ কাম হ'ল কুঁৱাৰ খালী কৰিবলৈ বালতি ব্যৱহাৰ কৰা।\/\/ আৰু সকলো বালিত সমান ক্ষমতা আছে।\/\/ প্ৰতিটো পুখুৰীত এটা সমতুল্য বালতি থাকে যাৰ পৰা পানী আহৰণ কৰিবলৈ ব্যৱহাৰ কৰিব পাৰি,\/\/ আৰু এটা শাৰীত থকা প্ৰতিটো ১য়ে এটা একক পানীৰ প্ৰতিনিধিত্ব কৰে।\/\/ আপোনাক কুঁৱাৰ এটা আয়তক্ষেত্ৰাকাৰ গ্ৰীড দিয়া হৈছে। প্ৰতিটো শাৰী এটা কুঁৱাৰ প্ৰতিনিধিত্ব কৰে, \/\/\/ >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n","canonical_solution":"func max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var totalWater = 0\n    for row in grid {\n        for unit in row {\n            if unit == 1 {\n                totalWater += 1\n            }\n        }\n    }\n    return (totalWater + capacity - 1) \/ capacity\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"},{"task_id":"HumanEval_116","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ইয়াক এনেদৰে ৰূপায়ণ কৰিব লাগিব: \/\/ একে ধৰণৰ সংখ্যাৰ বাবে, দশমিক মানৰ ওপৰত ভিত্তি কৰি ছাৰ্ট কৰক।\/\/ একৰ সংখ্যা তেওঁলোকৰ বাইনেৰী প্ৰতিনিধিত্বত ক্ৰমান্বয়ে বৃদ্ধি হৈ আছে।\/\/ এই কটাত, আপুনি  অনুসৰি অ-নতিবাচক পূৰ্ণসংখ্যাৰ এটা সজ্জা বাছনি কৰিব লাগিব\/\/\/ >>> sort_array(arr: [1, 5, 2, 3, 4])\n\/\/\/ [1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(arr: [-2, -3, -4, -5, -6])\n\/\/\/ [-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(arr: [1, 0, 2, 3, 4])\n\/\/\/ [0, 1, 2, 3, 4]\nfunc sort_array(arr: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted {\n        let onesCount1 = $0.nonNegativeOnesCount()\n        let onesCount2 = $1.nonNegativeOnesCount()\n        return (onesCount1, $0) < (onesCount2, $1)\n    }\n}\n\nextension Int {\n    func nonNegativeOnesCount() -> Int {\n        return self < 0 ? 0 : self.nonBitCount()\n    }\n    \n    private func nonBitCount() -> Int {\n        var count = 0\n        var num = self\n        while num > 0 {\n            count += num & 1\n            num >>= 1\n        }\n        return count\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"},{"task_id":"HumanEval_117","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ টোকাঃ আপুনি ধাৰণা কৰিব পাৰে যে ইনপুট ষ্ট্ৰিংত কেৱল আখৰ আৰু স্পেচ থাকে।\/\/ যদি string s খালী হয় তেন্তে function এ এটা খালী এৰে ৰিটাৰ্ণ কৰিব লাগে.\/\/ n বৰ্ণ, এই শব্দবোৰ s শৃংখলত প্ৰকাশ হোৱাৰ অনুক্ৰমত। \/\/ এটা ফাংচন যি  string s ৰ পৰা সকলো শব্দৰ এটা এৰেজ ঘূৰাই আনে য'ত ঠিক \/\/ এটা ষ্ট্ৰিং s আৰু এটা স্বাভাৱিক সংখ্যা n দিয়া হ'লে, আপোনাক কাৰ্যকৰী কৰিবলৈ কোৱা হৈছে \/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 4)\n\/\/\/ [\"little\"]\n\/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 3)\n\/\/\/ [\"Mary\", \"lamb\"]\n\/\/\/ >>> select_words(s: \"simple white space\", n: 2)\n\/\/\/ [] as [String]\n\/\/\/ >>> select_words(s: \"Hello world\", n: 4)\n\/\/\/ [\"world\"]\n\/\/\/ >>> select_words(s: \"Uncle sam\", n: 3)\n\/\/\/ [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n","canonical_solution":"func select_words(s: String, n: Int) -> [String] {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    let words = s.split(separator: \" \")\n    var result: [String] = []\n    \n    for word in words {\n        let consonantCount = word.filter { !vowels.contains($0) }.count\n        if consonantCount == n {\n            result.append(String(word))\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"},{"task_id":"HumanEval_118","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ আপুনি ধাৰণা কৰিব পাৰে যে দিয়া শাৰীটোত কেৱল ইংৰাজী আখৰ আছে।\/\/ উপৰোক্ত চৰ্ত পূৰণ কৰা যিকোনো স্বৰ পোৱা ।\/\/ আৰম্ভণি আৰু শেষৰ স্বৰসমূহ গণনা কৰা নহয়। যদি আপুনি কৰা নাই তেন্তে খালী শাৰী ঘূৰাই দিয়ক \/\/ শব্দটোৰ সোঁফালৰ পৰা দুটা স্ব-সংকেত (কেছ সেন্টিটিভ) ।আপোনাৰ কাম হ'ল শব্দটোৰ মাজত থকা আটাইতকৈ ওচৰৰ স্বৰবৰ্ণটো বিচাৰি উলিওৱা।\/\/\/ >>> get_closest_vowel(word: \"yogurt\")\n\/\/\/ \"u\"\n\/\/\/ >>> get_closest_vowel(word: \"FULL\")\n\/\/\/ \"U\"\n\/\/\/ >>> get_closest_vowel(word: \"quick\")\n\/\/\/ \"\"\n\/\/\/ >>> get_closest_vowel(word: \"ab\")\n\/\/\/ \"\"\nfunc get_closest_vowel(word: String) -> String {\n","canonical_solution":"func get_closest_vowel(word: String) -> String {\n    let vowels = Set(\"aeiouAEIOU\")\n    var foundVowel: Character? = nil\n    \n    for i in stride(from: word.count - 2, through: 1, by: -1) {\n        let currentIndex = word.index(word.startIndex, offsetBy: i)\n        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)\n        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)\n        \n        if vowels.contains(word[currentIndex]) && \n            !vowels.contains(word[previousIndex]) && \n            !vowels.contains(word[nextIndex]) {\n            foundVowel = word[currentIndex]\n            break\n        }\n    }\n    \n    return foundVowel != nil ? String(foundVowel!) : \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"},{"task_id":"HumanEval_119","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ যদি এটা ভাল শাৰী তৈয়াৰ কৰাৰ উপায় আছে তেন্তে 'হয়' ঘূৰাই দিব, আৰু অন্যথা 'নহয়' ঘূৰাই দিব।\/\/ '())' নহয়।উদাহৰণস্বৰূপে, '(()))))' শাৰীটো ভাল, আনহাতে \/\/ এটা ষ্ট্ৰিং S ভাল বুলি গণ্য কৰা হয় যদি আৰু কেৱল যদি S ৰ সকলো বন্ধনীৰ ভিতৰত \/\/ কোনো এটা ক্ৰম, যাৰ ফলত শাৰীটো ভাল হ'ব।\/\/ আপোনাৰ কাম হ'ল দুটা ষ্ট্ৰিং সংযুক্ত কৰাটো সম্ভৱ নে নহয় পৰীক্ষা কৰা ।\/\/ কেৱল '(' বা ') ' বন্ধ বন্ধনীবোৰত।\/\/ আপোনাক দুটা ষ্ট্ৰিং দিয়া হৈছে, দুয়োটা ষ্ট্ৰিং খোলা \/\/\/ >>> match_parens(lst: [\"()(\", \")\"])\n\/\/\/ \"Yes\"\n\/\/\/ >>> match_parens(lst: [\")\", \")\"])\n\/\/\/ \"No\"\nfunc match_parens(lst: [String]) -> String {\n","canonical_solution":"func match_parens(lst: [String]) -> String {\n    let combined1 = lst[0] + lst[1]\n    let combined2 = lst[1] + lst[0]\n    \n    func isBalanced(_ s: String) -> Bool {\n        var balance = 0\n        for char in s {\n            if char == \"(\" {\n                balance += 1\n            } else if char == \")\" {\n                balance -= 1\n            }\n            if balance < 0 {\n                return false\n            }\n        }\n        return balance == 0\n    }\n    \n    if isBalanced(combined1) || isBalanced(combined2) {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")"},{"task_id":"HumanEval_120","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ ১ঃ \/\/ দীঘ k ৰ সৈতে arr ত সৰ্বাধিক k সংখ্যাৰ সৈতে। \/\/ এটা এৰেৰ সংখ্যা আৰু এটা ধনাত্মক সংখ্যা k দিয়া হৈছে, এটা ছৰ্টড এৰে ঘূৰাই দিয়ক ।\/\/\/ >>> maximum(arr: [-3, -4, 5], k: 3)\n\/\/\/ [-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(arr: [4, -4, 4], k: 2)\n\/\/\/ [4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\n\/\/\/ [2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n","canonical_solution":"func maximum(arr: [Int], k: Int) -> [Int] {\n    guard k > 0 else { return [] }\n    let sortedArr = arr.sorted(by: >)\n    let maxElements = Array(sortedArr.prefix(k))\n    return maxElements.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"},{"task_id":"HumanEval_121","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ এটা অ-খালি অখণ্ড সংখ্যাৰ অ্যারে দিয়া হ'লে, সম-অৱস্থানত থকা সকলো অস্বাভাৱিক উপাদানৰ যোগফল ঘূৰাই দিব.\/\/\/ >>> solution(lst: [5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(lst: [3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(lst: [30, 13, 24, 321])\n\/\/\/ 0\nfunc solution(lst: [Int]) -> Int {\n","canonical_solution":"func solution(lst: [Int]) -> Int {\n    var sum = 0\n    for (index, value) in lst.enumerated() {\n        if index % 2 == 0 && value % 2 != 0 {\n            sum += value\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solution(lst: [5, 8, 7, 1]) == 12)\nassert(solution(lst: [3, 3, 3, 3, 3]) == 9)\nassert(solution(lst: [30, 13, 24, 321]) == 0)\nassert(solution(lst: [5, 9]) == 5)\nassert(solution(lst: [2, 4, 8]) == 0)\nassert(solution(lst: [30, 13, 23, 32]) == 23)\nassert(solution(lst: [3, 13, 2, 9]) == 3)"},{"task_id":"HumanEval_122","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ arr ৰ প্ৰথম k টা উপাদানৰ পৰা সৰ্বাধিক দুটা অংক থকা উপাদানৰ যোগফল। \/\/ এটা অ-খালি এৰেজ দিয়া হৈছে, ইয়াত arr আৰু k সংখ্যা আছে, return \/\/\/ >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr: [Int], k: Int) -> Int {\n","canonical_solution":"func add_elements(arr: [Int], k: Int) -> Int {\n    var sum = 0\n    for i in 0..<k {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)\nassert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)\nassert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)\nassert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)\nassert(add_elements(arr: [1], k: 1) == 1)"},{"task_id":"HumanEval_123","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ get_odd_collatz(5) ৰিটাৰ্ণ কৰে [1, 5] # 5 ৰ বাবে ক'লাটজ ক্ৰম হৈছে [5, 16, 8, 4, 2, 1], সেয়েহে অদ্ভুত সংখ্যাবোৰ কেৱল 1, আৰু 5 ।\/\/ উদাহৰণস্বৰূপেঃ \/\/ 2. ক্ৰমান্বয়ে বৃদ্ধি হোৱা ক্ৰমত শ্ৰেণীবদ্ধ কৰা এৰেজ ঘূৰাই আনে। \/\/ ১. কল্লেটজ (১) হৈছে [1]।\/\/ টোকাঃ \/\/ পদ + ১. অনুমানটো হ'ল n ৰ মান যিমানেই নহওক কিয়, ক্ৰমটো সদায় ১ লৈ যাব।যদি আগৰ পদটো অগণন হয়, তেন্তে পৰৱৰ্তী পদটো আগৰ পদটোৰ ৩ গুণ হ'ব।\/\/ পূৰ্বৱৰ্তী পদটো যদি সম হয়, তেন্তে পৰৱৰ্তী পদটো হ'ব  ৰ আধা\/\/ নিম্নলিখিত ধৰণেঃ যিকোনো ধনাত্মক পূৰ্ণসংখ্যাৰ n ৰ পৰা আৰম্ভ কৰক। তাৰ পিছত প্ৰতিটো পদ  ৰ পৰা প্ৰাপ্ত কৰা হয়।\/\/ কল্যাট্জ অনুমান হৈছে গণিতৰ এটা অনুমান যি এটা নিৰ্দিষ্ট ক্ৰমৰ বিষয়ে ।\/\/ এটা ধনাত্মক n সংখ্যা দিয়া হ'লে, এটা ছৰ্টড এৰে ঘূৰাই দিয়া যাক ক'লাটজ ক্ৰমত অস্বাভাৱিক সংখ্যা থাকে।\/\/\/ >>> get_odd_collatz(n: 5)\n\/\/\/ [1, 5]\nfunc get_odd_collatz(n: Int) -> [Int] {\n","canonical_solution":"func get_odd_collatz(n: Int) -> [Int] {\n    var collatzSequence: [Int] = []\n    var number = n\n\n    while number != 1 {\n        if number % 2 != 0 {\n            collatzSequence.append(number)\n        }\n        if number % 2 == 0 {\n            number \/= 2\n        } else {\n            number = 3 * number + 1\n        }\n    }\n\n    collatzSequence.append(1) \/\/ append 1 as the sequence ends at 1\n\n    let sortedOdds = collatzSequence.sorted()\n    \n    return sortedOdds\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"},{"task_id":"HumanEval_124","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ ৪. তাৰিখটো এই বিন্যাসত থাকিব লাগিবঃ এমএম-ডিডি-ইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইইই\/\/ ৩. মাহ ১ ৰ কম বা ১২ ৰ অধিক হ'ব নালাগিব।১,৩,৫,৭,৮,১০,১২ মাহৰ বাবে দিনৰ সংখ্যা ১ৰ কম বা ৩০ৰ বেছি হ'ব নালাগে আৰু ৪,৬,৯,১১ মাহৰ বাবে দিনৰ সংখ্যা ১ৰ কম বা ২৯ৰ বেছি হ'ব নালাগে।\/\/ 1. তাৰিখৰ শাৰী খালী নহয়।\/\/ নিম্নলিখিত সকলো নিয়ম পূৰণ কৰিলে তাৰিখটো বৈধঃ\/\/ যদি তাৰিখটো বৈধ হয় তেন্তে true প্ৰত্যাহাৰ কৰে অন্যথা false ।\/\/ আপুনি এটা ফাংচন লিখিব লাগিব যিয়ে এটা নিৰ্দিষ্ট তাৰিখৰ ষ্ট্ৰিংক বৈধতা প্ৰদান কৰিব আৰু\/\/\/ >>> valid_date(date: \"03-11-2000\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"15-01-2012\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"04-0-2040\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"06-04-2020\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"06\/04\/2020\")\n\/\/\/ false\nfunc valid_date(date: String) -> Bool {\n","canonical_solution":"func valid_date(date: String) -> Bool {\n    \/\/ Check if the date is empty\n    if date.isEmpty {\n        return false\n    }\n    \n    \/\/ Split the date into components using the \"-\" delimiter\n    let components = date.split(separator: \"-\")\n    \n    \/\/ Ensure the date has exactly three components\n    if components.count != 3 {\n        return false\n    }\n    \n    \/\/ Ensure the date components are integers\n    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {\n        return false\n    }\n    \n    \/\/ Check if the month is within the valid range\n    if month < 1 || month > 12 {\n        return false\n    }\n    \n    \/\/ Define the number of days in each month\n    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    \/\/ Check the day range for each month\n    if day < 1 || day > daysInMonth[month] {\n        return false\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(valid_date(date: \"03-11-2000\") == true)\nassert(valid_date(date: \"15-01-2012\") == false)\nassert(valid_date(date: \"04-0-2040\") == false)\nassert(valid_date(date: \"06-04-2020\") == true)\nassert(valid_date(date: \"01-01-2007\") == true)\nassert(valid_date(date: \"03-32-2011\") == false)\nassert(valid_date(date: \"\") == false)\nassert(valid_date(date: \"04-31-3000\") == false)\nassert(valid_date(date: \"06-06-2005\") == true)\nassert(valid_date(date: \"21-31-2000\") == false)\nassert(valid_date(date: \"04-12-2003\") == true)\nassert(valid_date(date: \"04122003\") == false)\nassert(valid_date(date: \"20030412\") == false)\nassert(valid_date(date: \"2003-04\") == false)\nassert(valid_date(date: \"2003-04-12\") == false)\nassert(valid_date(date: \"04-2003\") == false)"},{"task_id":"HumanEval_125","nl":"asm_Beng","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ উদাহৰণ \/\/ বৰ্ণমালা, অৰ্ডাৰ (a) = 0, অৰ্ডাৰ (b) = 1, ... অৰ্ডাৰ (z) = 25\/\/ কমা ','ত বিভাজিত হ'ব লাগিব যদি কোনো কমা নাই আপুনি অদ্ভুত ক্ৰমত সৰু আখৰবোৰৰ সংখ্যা ঘূৰাই দিব লাগিব \/\/ এটা শব্দৰ শাৰী দিয়া হৈছে, শ্বেতস্থানত বিভাজিত শব্দৰ এটা এৰেজ ঘূৰাই দিব, যদি কোনো শ্বেতস্থান আপোনাৰ পাঠত নাই \/\/\/ >>> split_words(txt: \"Hello world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"Hello,world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"abcdef\")\n\/\/\/ .failure(3)\nfunc split_words(txt: String) -> Result<[String], Int> {\n","canonical_solution":"func split_words(txt: String) -> Result<[String], Int> {\n    if txt.contains(\" \") {\n        let words = txt.split(separator: \" \").map { String($0) }\n        return .success(words)\n    } else if txt.contains(\",\") {\n        let words = txt.split(separator: \",\").map { String($0) }\n        return .success(words)\n    } else {\n        let oddOrderedLowerCaseLetters = txt.filter { char in\n            if let asciiValue = char.asciiValue {\n                let order = asciiValue - Character(\"a\").asciiValue!\n                return order % 2 == 1\n            }\n            return false\n        }\n        return .failure(oddOrderedLowerCaseLetters.count)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"},{"task_id":"HumanEval_126","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ সংখ্যা, false ঘূৰাই দিব. কোনো ঋণাত্মক সংখ্যা আৰু কেৱল পূৰ্ণ সংখ্যা ধৰা নলওক।যদি এটা এৰেজত একেটা এৰেজৰ ১ ৰো অধিক ডুপ্লিকেট থাকে\/\/ এটা সংখ্যাৰ অ্যারে দিয়া হ'লে, সিহঁতে ছৰ্ট কৰা হওক বা নহওক উভতাই দিব \/\/\/ >>> is_sorted(lst: [5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfunc is_sorted(lst: [Int]) -> Bool {\n","canonical_solution":"func is_sorted(lst: [Int]) -> Bool {\n    guard !lst.isEmpty else { return true }\n\n    var previous = lst[0]\n    var duplicates = 0\n\n    for i in 1..<lst.count {\n        if lst[i] < previous {\n            return false\n        } else if lst[i] == previous {\n            duplicates += 1\n            if duplicates > 1 {\n                return false\n            }\n        } else {\n            duplicates = 0\n        }\n        previous = lst[i]\n    }\n\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"},{"task_id":"HumanEval_127","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ [ইনপুট\/আউটপুট] নমুনাঃ \/\/ যদি দুটাকৈ অন্তৰাল পাৰ হৈ নাযায়, \"NO\" ঘূৰাই দিয়ক।\/\/ অন্যথা, \"NO\" ঘূৰাই দিব.\/\/ যদি ছেদটোৰ দৈৰ্ঘ্য এটা মৌলিক সংখ্যা হয়, \"YES\" ঘূৰাই দিয়ক, \/\/ যাৰ দৈৰ্ঘ্য 1 আৰু যিটো এটা অগণন সংখ্যা নহয়।\/\/ উদাহৰণ, অন্তৰাল (1, 3), (2, 4) ৰ ছেদ (2, 3) ।\/\/ অন্তৰাল এটা মৌলিক সংখ্যা।\/\/ আপোনাৰ কাম হ'ল এই দুটাৰ ছেদক দৈৰ্ঘ্য নিৰ্ণয় কৰা\/\/ প্ৰতিটো নিৰ্দিষ্ট অন্তৰালৰ বাবে, এইটো ধাৰণা কৰা হয় যে ইয়াৰ আৰম্ভণি ইয়াৰ শেষৰ সমান বা কম।\/\/ আৰম্ভণি আৰু শেষ দুয়োটাই অন্তৰ্ভুক্ত কৰে।\/\/ দিয়া অন্তৰালসমূহ বন্ধ হৈছে যাৰ অৰ্থ হৈছে অন্তৰাল (আৰম্ভ, অন্ত) উদাহৰণ স্বৰূপে, অন্তৰাল = (আৰম্ভ, শেষ) = (1, 2) ।\/\/ আপোনাক দুটা অন্তৰাল দিয়া হৈছে, \/\/\/ >>> intersection(interval1: (1, 2), interval2: (2, 3))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-1, 1), interval2: (0, 4))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-3, -1), interval2: (-5, 5))\n\/\/\/ \"YES\"\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n","canonical_solution":"func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n    \/\/ Helper function to determine if a number is prime\n    func isPrime(_ num: Int) -> Bool {\n        if num <= 1 {\n            return false\n        }\n        if num <= 3 {\n            return true\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false\n        }\n        var i = 5\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Find the start and end of the intersection\n    let intersectStart = max(interval1.0, interval2.0)\n    let intersectEnd = min(interval1.1, interval2.1)\n    \n    \/\/ Calculate the length of the intersection\n    let intersectionLength = intersectEnd - intersectStart\n\n    \/\/ Check if intersection length is positive and prime\n    if intersectionLength > 0 && isPrime(intersectionLength) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersection(interval1: (1, 2), interval2: (2, 3)) == \"NO\")\nassert(intersection(interval1: (-1, 1), interval2: (0, 4)) == \"NO\")\nassert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == \"YES\")\nassert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == \"YES\")\nassert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (3, 5)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (1, 2)) == \"NO\")\nassert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == \"NO\")"},{"task_id":"HumanEval_128","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ টোকাঃ শূন্য arr ৰ বাবে nil ঘূৰাই দিব. \/\/ অংকটোৰ প্ৰতিটো সংখ্যাৰ প্ৰতিনিধিত্ব কৰা ১, -১ বা ০।\/\/ পূৰ্ণসংখ্যাৰ যোগফল সকলো চিহ্নৰ উৎপাদনৰ দ্বাৰা গুণিত কৰা ।\/\/ আপোনাক এটা এৰে দিয়া হৈছে আৰু আপুনি ৰিটাৰ্ণ কৰিব লাগিব \/\/\/ >>> prod_signs(arr: [1, 2, 2, -4])\n\/\/\/ 9\n\/\/\/ >>> prod_signs(arr: [0, 1])\n\/\/\/ 0\n\/\/\/ >>> prod_signs(arr: [] as [Int])\n\/\/\/ nil\nfunc prod_signs(arr: [Int]) -> Int? {\n","canonical_solution":"func prod_signs(arr: [Int]) -> Int? {\n    \/\/ Return nil for empty array\n    if arr.isEmpty {\n        return nil\n    }\n\n    \/\/ Calculate the sum of magnitudes\n    let sumOfMagnitudes = arr.reduce(0) { sum, num in\n        return sum + abs(num)\n    }\n\n    \/\/ Calculate the product of all signs\n    let productOfSigns = arr.reduce(1) { product, num in\n        if num > 0 {\n            return product * 1\n        } else if num < 0 {\n            return product * -1\n        } else {\n            return 0\n        }\n    }\n\n    \/\/ Return the result of sum of magnitudes multiplied by product of signs\n    return sumOfMagnitudes * productOfSigns\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"},{"task_id":"HumanEval_129","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ ন্যূনতম পথৰ মাজেৰে যোৱা কোষসমূহৰ মানসমূহৰ এটা আদেশযুক্ত অ্যারে ঘূৰাই আনে।\/\/ এইটো নিশ্চিত যে উত্তৰটো অনন্য।\/\/ অন্ত_আ[জ] = অন্ত_বি[জ] ।\/\/ এনে যে lst_A[i] < lst_B[i] আৰু যিকোনো j (1 <= j < i) ৰ বাবে আমি পাইছো \/\/ than lst_B, অন্য কথাত ক'বলৈ গ'লে, ইয়াত এটা পূৰ্ণসংখ্যাৰ সূচক i (1 <= i <= k) আছে।\/\/ৰ জৰিয়তে (আমি সিহঁতক lst_A আৰু lst_B বুলি কওঁ), lst_A শব্দকোষীয়ভাৱে কম ।\/\/ A আৰু B কক্ষত থকা মানবোৰক এটা এৰেজত ভাগ কৰি ল'লে\/\/ এটা পথ A (k দৈৰ্ঘ্যৰ) এটা পথ B (k দৈৰ্ঘ্যৰ) তকৈ সৰু বুলি গণ্য কৰা হয় যদিহে আপুনি গ্ৰিডৰ বাহিৰত যাব নোৱাৰে।(অৱশ্যেই পৃথক) ।\/\/ অনুগ্ৰহ কৰি মন কৰক যে k দৈৰ্ঘ্যৰ এটা পথৰ অৰ্থ হৈছে একেবাৰে k কোষ পৰিদৰ্শন কৰা (নক \/\/ কোষ. \/\/ অন্য কথাত, আপুনি আপোনাৰ সৈতে এটা এজ ভাগ কৰা কোষবোৰলৈ যাব পাৰে \/\/ যিকোনো কোষৰ পৰা, আৰু প্ৰতিটো পদক্ষেপত আপুনি যিকোনো চুবুৰীয়া কোষলৈ যাব পাৰে, আপুনি গ্ৰীডত k দৈৰ্ঘ্যৰ ন্যূনতম পথটো বিচাৰি উলিয়াব লাগিব। আপুনি আৰম্ভ কৰিব পাৰে।\/\/ অন্তৰ্ভুক্তিকাৰী গ্ৰীডৰ কোষত একেবাৰে এবাৰ দেখা যায়।\/\/ গ্ৰীডৰ প্ৰতিটো কোষত এটা মান থাকে. [1, N * N] ৰ ভিতৰত প্ৰতিটো সম্পূৰ্ণ সংখ্যা \/\/ N শাৰী আৰু N কলাম থকা এটা গ্ৰীড (N >= 2) আৰু এটা ধনাত্মক পূৰ্ণ সংখ্যা k, দিয়া হ'লে, \/\/\/ >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)\n\/\/\/ [1, 2, 1]\n\/\/\/ >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)\n\/\/\/ [1]\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n","canonical_solution":"func minPath(grid: [[Int]], k: Int) -> [Int] {\n    let n = grid.count\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    struct Path: Comparable {\n        let cells: [Int]\n        \n        static func < (lhs: Path, rhs: Path) -> Bool {\n            return lhs.cells.lexicographicallyPrecedes(rhs.cells)\n        }\n    }\n    \n    var minPath: Path? = nil\n    \n    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {\n        var currentPath = currentPath\n        currentPath.append(grid[x][y])\n        \n        if currentPath.count == k {\n            let newPath = Path(cells: currentPath)\n            if minPath == nil || newPath < minPath! {\n                minPath = newPath\n            }\n            return\n        }\n        \n        for direction in directions {\n            let newX = x + direction.0\n            let newY = y + direction.1\n            if newX >= 0 && newX < n && newY >= 0 && newY < n {\n                dfs(x: newX, y: newY, k: k, currentPath: currentPath)\n            }\n        }\n    }\n    \n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(x: i, y: j, k: k, currentPath: [])\n        }\n    }\n    \n    return minPath!.cells\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])\nassert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])\nassert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])\nassert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])\nassert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])\nassert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\nassert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\nassert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])\nassert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])\nassert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\nassert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"},{"task_id":"HumanEval_130","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ ট্ৰিবোনাচ্চি ক্ৰমৰ প্ৰথম n + 1 সংখ্যা। \/\/ আপোনাক এটা অ-নতিবাচক পূৰ্ণ সংখ্যা n দিয়া হৈছে, আপুনি এটা ৰিটাৰ্ণ কৰিব লাগিব \/\/ = 2 + 3 + 3 = 8 \/\/ ত্ৰি (৩) = ত্ৰি (২) + ত্ৰি (১) + ত্ৰি (৪)\/\/ ত্ৰি (তাত) = ৩\/\/ ত্ৰি (২) = ১ + (২ \/ ২) = ২ \/\/ উদাহৰণস্বৰূপেঃ \/\/ ত্ৰি (n) = ত্ৰি (n - 1) + ত্ৰি (n - 2) + ত্ৰি (n + 1), যদি n অস্বাভাৱিক হয়।\/\/ ত্ৰি (n) = 1 + n \/ 2, যদি n জোৰা হয়।\/\/ ত্ৰি (ত) = ৩\/\/ ট্ৰিবোনাচি ক্ৰমৰ পুনৰাবৃত্তিৰ দ্বাৰা সংজ্ঞায়িত কৰা হয়: কিন্তু মানুহে নাজানে ট্ৰিবোনাচি ক্ৰম কি।\/\/ সকলোৱে ফিব'নাচ্চি ক্ৰম জানে, ইয়াক গভীৰভাৱে অধ্যয়ন কৰিছিল গণিতজ্ঞসকলে \/\/\/ >>> tri(n: 3)\n\/\/\/ [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n","canonical_solution":"func tri(n: Int) -> [Int] {\n    guard n >= 0 else { return [] }\n    if n == 0 { return [1] }\n    if n == 1 { return [1, 3] }\n    if n == 2 { return [1, 3, 2] }\n    \n    var sequence = [1, 3, 2]\n    \n    for i in 3...n {\n        if i % 2 == 0 {\n            sequence.append(1 + i \/ 2)\n        } else {\n            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]\n            sequence.append(nextVal)\n        }\n    }\n    \n    return sequence\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])"},{"task_id":"HumanEval_131","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ যদি সকলো অংক সম হয় 0 ঘূৰাই দিয়ক।\/\/ এটা ধনাত্মক n সংখ্যা দিয়া হ'লে, অদ্ভুত অংকবোৰৰ উৎপাদনৰ সংখ্যাটো ঘূৰাই দিব।\/\/\/ >>> digits(n: 1)\n\/\/\/ 1\n\/\/\/ >>> digits(n: 4)\n\/\/\/ 0\n\/\/\/ >>> digits(n: 235)\n\/\/\/ 15\nfunc digits(n: Int) -> Int {\n","canonical_solution":"func digits(n: Int) -> Int {\n    var num = n\n    var product = 1\n    var hasOdd = false\n    \n    while num > 0 {\n        let digit = num % 10\n        if digit % 2 != 0 {\n            hasOdd = true\n            product *= digit\n        }\n        num \/= 10\n    }\n    \n    return hasOdd ? product : 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digits(n: 5) == 5)\nassert(digits(n: 54) == 5)\nassert(digits(n: 120) == 1)\nassert(digits(n: 5014) == 5)\nassert(digits(n: 98765) == 315)\nassert(digits(n: 5576543) == 2625)\nassert(digits(n: 2468) == 0)"},{"task_id":"HumanEval_132","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ য'ত উপ-অনুসৰণত কমেও এটা ব্ৰেকেট অন্তৰ্ভুক্ত হৈ থাকে।\/\/ ফাংচনে true ৰিটাৰ্ণ কৰিব লাগে যদিহে ব্ৰেকেটৰ এটা বৈধ উপ-অনুসৰণ থাকে।\/\/ এটা ফাংচন সৃষ্টি কৰক যি এটা ষ্ট্ৰিংক ইনপুট হিচাপে লয় য'ত কেৱল বৰ্গাকৃতিৰ বন্ধনীৰ ভিতৰত থাকে।\/\/\/ >>> is_nested(string: \"[[]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[]]]]]]][[[[[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[][]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[[][]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[[]][[\")\n\/\/\/ true\nfunc is_nested(string: String) -> Bool {\n","canonical_solution":"func is_nested(string: String) -> Bool {\n    var stack: [Character] = []\n    var nested = false\n\n    for bracket in string {\n        if bracket == \"[\" {\n            stack.append(bracket)\n        } else if bracket == \"]\" {\n            if let last = stack.last, last == \"[\" {\n                stack.removeLast()\n                if !stack.isEmpty {\n                    nested = true\n                }\n            } else {\n                return false\n            }\n        }\n    }\n    return nested\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"},{"task_id":"HumanEval_133","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ প্ৰথমে অংকনক্ষেত্ৰৰ প্ৰতিটো উপাদানক ওপৰৰ int{}লৈ ঘূৰি চাওক।\/\/ আপুনি প্ৰদান কৰা এৰেজত থকা সংখ্যাৰ স্কোৱাডৰ যোগফল ঘূৰাই দিব লাগিব, \/\/ আপোনাক এটা সংখ্যাৰ অ্যারে দিয়া হৈছে।\/\/\/ >>> sum_squares(lst: [1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> sum_squares(lst: [1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> sum_squares(lst: [1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> sum_squares(lst: [-2.4, 1.0, 1.0])\n\/\/\/ 6\nfunc sum_squares(lst: [Double]) -> Int {\n","canonical_solution":"func sum_squares(lst: [Double]) -> Int {\n    return lst.map { ceil($0) } \/\/ Round each element to the upper int (Ceiling)\n              .map { Int($0 * $0) } \/\/ Square each element\n              .reduce(0, +) \/\/ Sum all squared elements\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)\nassert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)\nassert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)\nassert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)\nassert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)\nassert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)\nassert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)\nassert(sum_squares(lst: [0.0]) == 0)\nassert(sum_squares(lst: [-1.0]) == 1)\nassert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"},{"task_id":"HumanEval_134","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ টোকাঃ \"word\" হ'ল শাৰীৰে পৃথক কৰা বৰ্ণৰ এটা গোট।\/\/ এটা শব্দৰ অংশ, আৰু অন্যথা মিছা।\/\/ এটা নিৰ্দিষ্ট শাৰী এটা বৰ্ণমালাৰ বৰ্ণ আৰু নহয় \/\/ এটা ফাংচন সৃষ্টি কৰক যিটো true ৰিটাৰ্ণ কৰে যদি শেষৰ বৰ্ণটো \/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pie\")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e\")\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e \")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"\")\n\/\/\/ false\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n","canonical_solution":"func check_if_last_char_is_a_letter(txt: String) -> Bool {\n    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {\n        return false\n    }\n    \n    if lastChar.isLetter {\n        let words = txt.split(separator: \" \")\n        if let lastWord = words.last {\n            return lastWord.count == 1\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_if_last_char_is_a_letter(txt: \"apple\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"A\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie 1\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee e \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pie\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e \") == false)"},{"task_id":"HumanEval_135","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ দ্বৈত মানসমূহ।\/\/ এনে কোনো উপাদান নাই তেতিয়া -১ ঘূৰাই দিব। দিয়া অ্যারেটোত  অন্তৰ্ভুক্ত নহ'ব।\/\/ ইয়াৰ আগতে থকা উপাদানৰ সমান বা অধিক নহয়। যদি \/\/ এটা ফাংচন সৃষ্টি কৰক যি এটা উপাদানৰ সৰ্ববৃহৎ সূচক ঘূৰাই দিয়ে যিটো \/\/\/ >>> can_arrange(arr: [1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(arr: [1, 2, 3])\n\/\/\/ -1\nfunc can_arrange(arr: [Int]) -> Int {\n","canonical_solution":"func can_arrange(arr: [Int]) -> Int {\n    for i in (1..<arr.count).reversed() {\n        if arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"},{"task_id":"HumanEval_136","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ যদি কোনো ঋণাত্মক বা ধনাত্মক পূৰ্ণ সংখ্যা নাই, তেন্তে সেইবোৰক nil হিচাপে ঘূৰাই দিব।এটা এৰেজত ধনাত্মক পূৰ্ণসংখ্যাৰ সংখ্যা।\/\/ আটাইতকৈ ডাঙৰ ঋণাত্মক পূৰ্ণ সংখ্যা, আৰু 'b' আটাইতকৈ সৰু \/\/ এটা ফাংচন সৃষ্টি কৰক যি এটা টুপল (a, b) ঘূৰাই আনে, য'ত 'a' হ'ল \/\/\/ >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])\n\/\/\/ (nil, 1)\n\/\/\/ >>> largest_smallest_integers(lst: [] as [Int])\n\/\/\/ (nil, nil)\n\/\/\/ >>> largest_smallest_integers(lst: [0])\n\/\/\/ (nil, nil)\nfunc largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n","canonical_solution":"func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n    var largestNegative: Int? = nil\n    var smallestPositive: Int? = nil\n\n    for number in lst {\n        if number < 0 {\n            if largestNegative == nil || number > largestNegative! {\n                largestNegative = number\n            }\n        } else if number > 0 {\n            if smallestPositive == nil || number < smallestPositive! {\n                smallestPositive = number\n            }\n        }\n    }\n\n    return (largestNegative, smallestPositive)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\nassert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"},{"task_id":"HumanEval_137","nl":"asm_Beng","pl":"swift","prompt":"\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n\/\/ টোকাঃ যদি এটা বাস্তৱ সংখ্যা এটা শাৰী হিচাপে প্ৰতিনিধিত্ব কৰা হয়, তেন্তে ফ্ল'টিং পইণ্ট হ'ব পাৰে . বা , \/\/ যদি মানবোৰ সমান হয় তেন্তে nil ঘূৰাই দিব.\/\/ বাস্তৱ সংখ্যা, আৰু ইয়াৰ প্ৰদান কৰা ভৰিবল প্ৰকাৰৰ বৃহত্তৰ ভৰিবলটো ঘূৰাই আনে।\/\/ এটা ফাংচন সৃষ্টি কৰক যিয়ে পূৰ্ণ সংখ্যা, ফ্ল'ট, বা  প্ৰতিনিধিত্ব কৰা \/\/\/ >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))\n\/\/\/ .doubleValue(2.5)\n\/\/\/ >>> compare_one(a: .intValue(1), b: .stringValue(\"2,3\"))\n\/\/\/ .stringValue(\"2,3\")\n\/\/\/ >>> compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n\/\/\/ .stringValue(\"6\")\n\/\/\/ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n\/\/\/ nil\nfunc compare_one(a: Value, b: Value) -> Value? {\n","canonical_solution":"func compare_one(a: Value, b: Value) -> Value? {\n    func convertToDouble(value: Value) -> Double? {\n        switch value {\n        case .intValue(let int):\n            return Double(int)\n        case .doubleValue(let double):\n            return double\n        case .stringValue(let string):\n            let formatter = NumberFormatter()\n            formatter.locale = Locale(identifier: \"en_US_POSIX\")\n            if string.contains(\",\") {\n                formatter.decimalSeparator = \",\"\n            } else {\n                formatter.decimalSeparator = \".\"\n            }\n            return formatter.number(from: string)?.doubleValue\n        }\n    }\n    \n    let aDouble = convertToDouble(value: a)\n    let bDouble = convertToDouble(value: b)\n    \n    if let aDouble = aDouble, let bDouble = bDouble {\n        if aDouble > bDouble {\n            return a\n        } else if bDouble > aDouble {\n            return b\n        }\n    }\n    \n    return nil\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)"},{"task_id":"HumanEval_138","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ নিৰ্দিষ্ট সংখ্যা n ক সঠিকভাৱে 4 টা ধনাত্মক সম সংখ্যাৰ যোগফল হিচাপে লিখিব পাৰি নে নাই তাৰ মূল্যায়ন কৰা ।\/\/\/ >>> is_equal_to_sum_even(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 8)\n\/\/\/ true\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n","canonical_solution":"func is_equal_to_sum_even(n: Int) -> Bool {\n    if n <= 8 {\n        return false\n    }\n    return n % 2 == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_equal_to_sum_even(n: 4) == false)\nassert(is_equal_to_sum_even(n: 6) == false)\nassert(is_equal_to_sum_even(n: 8) == true)\nassert(is_equal_to_sum_even(n: 10) == true)\nassert(is_equal_to_sum_even(n: 11) == false)\nassert(is_equal_to_sum_even(n: 12) == true)\nassert(is_equal_to_sum_even(n: 13) == false)\nassert(is_equal_to_sum_even(n: 16) == true)"},{"task_id":"HumanEval_139","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ য'ত n > 0 \/\/ ব্ৰাজিলিয়ান_ফেক্টৰিয়েল (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/ ব্ৰাজিলীয় কাৰকক সংজ্ঞায়িত কৰা হৈছেঃ \/\/\/ >>> special_factorial(n: 4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfunc special_factorial(n: Int) -> Int {\n","canonical_solution":"func factorial(_ n: Int) -> Int {\n    return n <= 1 ? 1 : n * factorial(n - 1)\n}\n\nfunc special_factorial(n: Int) -> Int {\n    var result = 1\n    for i in 1...n {\n        result *= factorial(i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"},{"task_id":"HumanEval_140","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ তাৰপিছত সকলো ক্ৰমিক স্থানৰ ঠাইত -  দিয়ে\/\/ আৰু যদি এটা স্ট্ৰিংত 2 ৰো অধিক ক্ৰমাগত স্পেচ থাকে, \/\/ এটা পাঠৰ শাৰী দিয়া হৈছে, তাত থকা সকলো স্থানৰ ঠাইত আণ্ডাৰস্ক'ৰ ব্যৱহাৰ কৰা হ'ব,\/\/\/ >>> fix_spaces(text: \" Example\")\n\/\/\/ \"Example\"\n\/\/\/ >>> fix_spaces(text: \" Example 1\")\n\/\/\/ \"Example_1\"\n\/\/\/ >>> fix_spaces(text: \" Example 2\")\n\/\/\/ \"_Example_2\"\n\/\/\/ >>> fix_spaces(text: \" Example 3\")\n\/\/\/ \"_Example-3\"\nfunc fix_spaces(text: String) -> String {\n","canonical_solution":"func fix_spaces(text: String) -> String {\n    var result = \"\"\n    var spaceCount = 0\n    \n    for character in text {\n        if character == \" \" {\n            spaceCount += 1\n        } else {\n            if spaceCount == 1 {\n                result.append(\"_\")\n            } else if spaceCount > 1 {\n                result.append(\"-\")\n            }\n            result.append(character)\n            spaceCount = 0\n        }\n    }\n    \n    if spaceCount == 1 {\n        result.append(\"_\")\n    } else if spaceCount > 1 {\n        result.append(\"-\")\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fix_spaces(text: \"Example\") == \"Example\")\nassert(fix_spaces(text: \"Mudasir Hanif \") == \"Mudasir_Hanif_\")\nassert(fix_spaces(text: \"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\")\nassert(fix_spaces(text: \"Exa   mple\") == \"Exa-mple\")\nassert(fix_spaces(text: \"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\")"},{"task_id":"HumanEval_141","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ - বিন্দুটোৰ পিছত থকা উপশাৰীটো এইবিলাকৰ এটা হ'ব লাগেঃ ['txt', 'exe', 'dll'] \/\/ লেটিন বৰ্ণমালা ('a'-'z' আৰু 'A'-'Z') ।\/\/ - বিন্দুটোৰ আগত থকা উপশাৰী খালী হ'ব নালাগে, আৰু ই  ৰ পৰা এটা আখৰেৰে আৰম্ভ হয়\/\/ - ফাইলৰ নামত একেবাৰে এটা বিন্দু আছে '.' \/\/ - ফাইলৰ নামত তিনিটাতকৈ অধিক অংক থাকিব নালাগে ('0'-'9') ।\/\/ পূৰণ কৰা হৈছেঃ \/\/ এটা ফাইলৰ নাম বৈধ বুলি গণ্য কৰা হয় যদিহে আৰু কেৱল যদিহে তলত দিয়া সকলোবোৰ চৰ্ত পূৰণ হয়।\/\/ ফাইলৰ নাম বৈধ হ'লে 'হয়', অন্যথা 'নহয়' ৰিটাৰ্ণ কৰে।\/\/ এটা ফাংচন সৃষ্টি কৰক যি এটা ফাইলৰ নাম প্ৰতিনিধিত্ব কৰা এটা ষ্ট্ৰিং লয় আৰু ৰিটাৰ্ণ কৰে \/\/\/ >>> file_name_check(file_name: \"example.txt\")\n\/\/\/ \"Yes\"\n\/\/\/ >>> file_name_check(file_name: \"1example.dll\")\n\/\/\/ \"No\"\nfunc file_name_check(file_name: String) -> String {\n","canonical_solution":"func file_name_check(file_name: String) -> String {\n    \/\/ Split by the dot.\n    let components = file_name.split(separator: \".\", omittingEmptySubsequences: false)\n    \n    \/\/ Check if there's exactly one dot.\n    guard components.count == 2 else {\n        return \"No\"\n    }\n    \n    \/\/ Extract the prefix and suffix.\n    let prefix = String(components[0])\n    let suffix = String(components[1])\n    \n    \/\/ Check if the prefix is non-empty and starts with a letter.\n    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {\n        return \"No\"\n    }\n    \n    \/\/ Check if the suffix is one of the allowed types.\n    let validSuffixes = [\"txt\", \"exe\", \"dll\"]\n    guard validSuffixes.contains(suffix) else {\n        return \"No\"\n    }\n    \n    \/\/ Count digits in the file name.\n    let digitCount = file_name.filter { $0.isNumber }.count\n    \n    \/\/ Ensure that there are not more than 3 digits.\n    guard digitCount <= 3 else {\n        return \"No\"\n    }\n    \n    \/\/ If all checks pass, it's a valid file name.\n    return \"Yes\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(file_name_check(file_name: \"example.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"1example.dll\") == \"No\")\nassert(file_name_check(file_name: \"s1sdf3.asd\") == \"No\")\nassert(file_name_check(file_name: \"K.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"MY16FILE3.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"His12FILE94.exe\") == \"No\")\nassert(file_name_check(file_name: \"_Y.txt\") == \"No\")\nassert(file_name_check(file_name: \"?aREYA.exe\") == \"No\")\nassert(file_name_check(file_name: \"\/this_is_valid.dll\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.wow\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"this_is_valid.txtexe\") == \"No\")\nassert(file_name_check(file_name: \"#this2_i4s_5valid.ten\") == \"No\")\nassert(file_name_check(file_name: \"@this1_is6_valid.exe\") == \"No\")\nassert(file_name_check(file_name: \"this_is_12valid.6exe4.txt\") == \"No\")\nassert(file_name_check(file_name: \"all.exe.txt\") == \"No\")\nassert(file_name_check(file_name: \"I563_No.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"Is3youfault.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"no_one#knows.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"1I563_Yes3.exe\") == \"No\")\nassert(file_name_check(file_name: \"I563_Yes3.txtt\") == \"No\")\nassert(file_name_check(file_name: \"final..txt\") == \"No\")\nassert(file_name_check(file_name: \"final132\") == \"No\")\nassert(file_name_check(file_name: \"_f4indsartal132.\") == \"No\")\nassert(file_name_check(file_name: \".txt\") == \"No\")\nassert(file_name_check(file_name: \"s.\") == \"No\")"},{"task_id":"HumanEval_143","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ ১ঃ \/\/ নতুন শাৰীটোৰ শব্দৰ ক্ৰম প্ৰাথমিক শাৰীৰ দৰে হ'ব লাগে।\/\/ যাৰ দৈৰ্ঘ্য মৌলিক সংখ্যা, \/\/ আৰু আপুনি এটা ষ্ট্ৰিং ঘূৰাই দিব লাগিব য'ত মূল বাক্যটোৰ শব্দবোৰ আছে, \/\/ বাক্যটোত কিছুমান শব্দ আছে যিসমূহ এটা স্পেচ (space) ৰ দ্বাৰা পৃথক কৰা হৈছে, \/\/ আপোনাক এটা বাক্য প্ৰতিনিধিত্ব কৰা এটা শাৰী দিয়া হৈছে, \/\/\/ >>> words_in_sentence(sentence: \"This is a test\")\n\/\/\/ \"is\"\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(sentence: \"lets go for swimming\")\n\/\/\/ \"go for\"\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence: String) -> String {\n","canonical_solution":"func words_in_sentence(sentence: String) -> String {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    let words = sentence.split(separator: \" \")\n    let primeLengthWords = words.filter { isPrime($0.count) }\n    return primeLengthWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"},{"task_id":"HumanEval_144","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ আপুনি ধাৰণা কৰিব পাৰে যে x, আৰু n বৈধ ভগ্নাংশ, আৰু শূন্যক দ্ৰাবিষ হিচাপে নাপায়।\/\/ <numerator>\/<denominator> য'ত নম্বৰ আৰু নাম্বাৰ দুয়োটা ধনাত্মক পূৰ্ণ সংখ্যা।x আৰু n দুয়োটাই ভগ্নাংশৰ এটা শাৰী প্ৰতিনিধিত্ব আৰু নিম্নলিখিত বিন্যাস আছে,\/\/ x * n. যদি x * n এটা সম্পূৰ্ণ সংখ্যা আৰু false হয়, তেন্তে ফাংচনে true ৰিটাৰ্ণ কৰে ।\/\/ আপোনাৰ কাম হৈছে এটা ফাংচন প্ৰয়োগ কৰা যি এক্সপ্ৰেছনটো সৰল কৰিব \/\/\/ >>> simplify(x: \"1\/5\", n: \"5\/1\")\n\/\/\/ true\n\/\/\/ >>> simplify(x: \"1\/6\", n: \"2\/1\")\n\/\/\/ false\n\/\/\/ >>> simplify(x: \"7\/10\", n: \"10\/2\")\n\/\/\/ false\nfunc simplify(x: String, n: String) -> Bool {\n","canonical_solution":"func simplify(x: String, n: String) -> Bool {\n    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {\n        let parts = fraction.split(separator: \"\/\").map { Int($0)! }\n        return (numerator: parts[0], denominator: parts[1])\n    }\n    \n    let (xNumerator, xDenominator) = parseFraction(fraction: x)\n    let (nNumerator, nDenominator) = parseFraction(fraction: n)\n    \n    \/\/ Multiply the two fractions: (xNumerator * nNumerator) \/ (xDenominator * nDenominator)\n    let resultNumerator = xNumerator * nNumerator\n    let resultDenominator = xDenominator * nDenominator\n    \n    \/\/ Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator\n    return resultNumerator % resultDenominator == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/6\", n: \"2\/1\") == false)\nassert(simplify(x: \"5\/1\", n: \"3\/1\") == true)\nassert(simplify(x: \"7\/10\", n: \"10\/2\") == false)\nassert(simplify(x: \"2\/10\", n: \"50\/10\") == true)\nassert(simplify(x: \"7\/2\", n: \"4\/2\") == true)\nassert(simplify(x: \"11\/6\", n: \"6\/1\") == true)\nassert(simplify(x: \"2\/3\", n: \"5\/2\") == false)\nassert(simplify(x: \"5\/2\", n: \"3\/5\") == false)\nassert(simplify(x: \"2\/4\", n: \"8\/4\") == true)\nassert(simplify(x: \"2\/4\", n: \"4\/2\") == true)\nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/5\", n: \"1\/5\") == false)"},{"task_id":"HumanEval_145","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ মূল এৰেৰ তেওঁলোকৰ সূচকৰ ভিত্তিত সিহঁতক ক্ৰম কৰক।\/\/ টোকাঃ যদি বহুতো প্ৰবন্ধ আছে যিবোৰৰ অংকবোৰৰ সমষ্টি একেই, \/\/ তেওঁলোকৰ অংকবোৰৰ যোগফল অনুসৰি ক্ৰমান্বয়ে।\/\/ এটা ফাংচন লিখা যিটো দিয়া পূৰ্ণসংখ্যাৰ অ্যাৰেৰ সাজিব ।\/\/\/ >>> order_by_points(nums: [1, 11, -1, -11, -12])\n\/\/\/ [-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(nums: [] as [Int])\n\/\/\/ [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n","canonical_solution":"func order_by_points(nums: [Int]) -> [Int] {\n    return nums.enumerated().sorted {\n        let sum1 = digitSum($0.element)\n        let sum2 = digitSum($1.element)\n        if sum1 == sum2 {\n            return $0.offset < $1.offset\n        } else {\n            return sum1 < sum2\n        }\n    }.map { $0.element }\n}\n\nfunc digitSum(_ number: Int) -> Int {\n    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"},{"task_id":"HumanEval_146","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ এটা সংখ্যাৰ প্ৰথম আৰু শেষ অংকটো অদ্ভুত (1, 3, 5, 7, 9) ।\/\/ এৰেৰ ১০ ৰ অধিক সংখ্যক উপাদান আৰু দুয়োটা \/\/ এটা ফাংচন লিখা যি এটা সংখ্যাৰ এৰে ইনপুট হিচাপে লয় আৰু ৰিটাৰ্ণ দিয়ে ।\/\/\/ >>> specialFilter(nums: [15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfunc specialFilter(nums: [Int]) -> Int {\n","canonical_solution":"func specialFilter(nums: [Int]) -> Int {\n    return nums.filter { num in\n        let absNum = abs(num)\n        \n        guard absNum > 10 else {\n            return false\n        }\n        \n        let firstDigit = String(String(absNum).first!)\n        let lastDigit = String(absNum % 10)\n        \n        let oddDigits: Set = [\"1\", \"3\", \"5\", \"7\", \"9\"]\n        \n        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(specialFilter(nums: [5, -2, 1, -5]) == 0)\nassert(specialFilter(nums: [15, -73, 14, -15]) == 1)\nassert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)\nassert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)\nassert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)\nassert(specialFilter(nums: [1]) == 0)\nassert(specialFilter(nums: [] as [Int]) == 0)"},{"task_id":"HumanEval_147","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ আৰু a[i] + a[j] + a[k] হৈছে 3 ৰ গুণিতক।\/\/ a ৰ ত্ৰিপল সংখ্যাৰ সংখ্যা (a[i], a[j], a[k]) ঘূৰাই আনে য'ত i < j < k, \/\/ প্ৰত্যেক i (1 ≤ i ≤ n) ৰ বাবে, a[i] = i * i - i + 1 ৰ মান।আপুনি এটা পূৰ্ণ সংখ্যা n দিয়া হৈছে। আপুনি এটা পূৰ্ণ সংখ্যা এৰে সৃষ্টি কৰিব লাগিব যাৰ দৈৰ্ঘ্য n।\/\/\/ >>> get_max_triples(n: 5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n: Int) -> Int {\n","canonical_solution":"func get_max_triples(n: Int) -> Int {\n    \/\/ Create the array a based on the problem description\n    var a = [Int](repeating: 0, count: n)\n    for i in 1...n {\n        a[i - 1] = i * i - i + 1\n    }\n    \n    var count = 0\n    \/\/ Check for all possible triples\n    for i in 0..<n {\n        for j in (i + 1)..<n {\n            for k in (j + 1)..<n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1\n                }\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_max_triples(n: 5) == 1)\nassert(get_max_triples(n: 6) == 4)\nassert(get_max_triples(n: 10) == 36)\nassert(get_max_triples(n: 100) == 53361)"},{"task_id":"HumanEval_149","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ আপুনি অনুমান কৰিব পাৰে যে সকলো শব্দৰ দীঘল সমান হ'ব।\/\/ ফাংচনে এটা শাৰী শাৰীবোৰক ছৰ্ট কৰা ক্ৰমত ঘূৰাই দিব লাগে।\/\/ যদি দুটা শব্দৰ দৈৰ্ঘ্য সমান হয়, তেন্তে আখৰ অনুসাৰে শ্ৰেণীবিভাজন কৰা।\/\/ এই নিয়মৰ দ্বাৰা ছৰ্ট কৰা এৰে ৰিটাৰ্ণ কৰিব লাগে।\/\/ অক্ষৰবোৰে শব্দৰ দৈৰ্ঘ্য অনুসাৰে ক্ৰমবৰ্ধমান হ'ব লাগে, আৰু আপুনি আৰু ইয়াত ডুপ্লিকেট থাকিব পাৰে।\/\/ এটা এৰে সদায় এটা ষ্ট্ৰিং এৰে আৰু কেতিয়াও এটা সংখ্যাৰ এৰে নহয়,\/\/ আৰু ফলাফলৰ এৰেজটো এটা ছৰ্ট কৰা ক্ৰমত ঘূৰাই আনে, \/\/ ইয়াৰ পৰা অস্বাভাৱিক দৈৰ্ঘ্যৰ ষ্ট্ৰিং বিলোপ কৰে,এটা ফাংচন লিখক যি এটা স্ট্ৰিং এৰেক পৰিমাপ হিচাপে গ্ৰহণ কৰে,\/\/\/ >>> sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"])\n\/\/\/ [\"aa\"]\n\/\/\/ >>> sorted_list_sum(lst: [\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/\/ [\"ab\", \"cd\"]\nfunc sorted_list_sum(lst: [String]) -> [String] {\n","canonical_solution":"func sorted_list_sum(lst: [String]) -> [String] {\n    return lst.filter { $0.count % 2 == 0 }\n              .sorted { \n                  if $0.count == $1.count {\n                      return $0 < $1\n                  }\n                  return $0.count < $1.count\n              }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"]) == [\"aa\"])\nassert(sorted_list_sum(lst: [\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"])\nassert(sorted_list_sum(lst: [\"d\", \"b\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\nassert(sorted_list_sum(lst: [\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\nassert(sorted_list_sum(lst: [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])"},{"task_id":"HumanEval_150","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ এটা মৌলিক সংখ্যা আৰু y ৰ মান ঘূৰাই দিব লাগে অন্যথা।\/\/ এটা সৰল প্ৰগ্ৰাম যি x ৰ মান ঘূৰাই দিব লাগে যদি n হয় \/\/\/ >>> x_or_y(n: 7, x: 34, y: 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(n: 15, x: 8, y: 5)\n\/\/\/ 5\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n","canonical_solution":"func x_or_y(n: Int, x: Int, y: Int) -> Int {\n    func isPrime(_ number: Int) -> Bool {\n        if number <= 1 { return false }\n        if number <= 3 { return true }\n        if number % 2 == 0 || number % 3 == 0 { return false }\n        \n        var i = 5\n        while i * i <= number {\n            if number % i == 0 || number % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    return isPrime(n) ? x : y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(x_or_y(n: 7, x: 34, y: 12) == 34)\nassert(x_or_y(n: 15, x: 8, y: 5) == 5)\nassert(x_or_y(n: 3, x: 33, y: 5212) == 33)\nassert(x_or_y(n: 1259, x: 3, y: 52) == 3)\nassert(x_or_y(n: 7919, x: -1, y: 12) == -1)\nassert(x_or_y(n: 3609, x: 1245, y: 583) == 583)\nassert(x_or_y(n: 91, x: 56, y: 129) == 129)\nassert(x_or_y(n: 6, x: 34, y: 1234) == 1234)\nassert(x_or_y(n: 1, x: 2, y: 0) == 0)\nassert(x_or_y(n: 2, x: 2, y: 0) == 2)"},{"task_id":"HumanEval_151","nl":"asm_Beng","pl":"swift","prompt":"\nঅগণন সংখ্যাবোৰ বাদ দিয়া যােগ্য সংখ্যাবোৰ বাদ দিয়া যােগ্য সংখ্যাবোৰ বাদ দিয়া যােগ্য সংখ্যাবোৰ বাদ দিয়া যােগ্য সংখ্যাবোৰ বাদ দিয়া যােগ্য সংখ্যাবোৰ বাদ দিয়া যােগ্য সংখ্যাবোৰ বাদ দিয়া যােগ্য সংখ্যাসমূহ বাদ দিয়া যােগ্য সংখ্যাসমূহ বাদ দিয়া যােগ্য সংখ্যাসমূহ বাদ দিয়া\/\/ এটা সংখ্যাৰ অ্যারে দিয়া হ'লে, সংখ্যাৰ স্কোৱাডৰ যোগফল ঘূৰাই দিব \/\/\/ >>> double_the_difference(lst: [1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(lst: [-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(lst: [9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(lst: [0])\n\/\/\/ 0\n\/\/\/ If the input array is empty, return 0.\nfunc double_the_difference(lst: [Double]) -> Int {\n","canonical_solution":"func double_the_difference(lst: [Double]) -> Int {\n    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }\n              .map { Int($0) * Int($0) }\n              .reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(double_the_difference(lst: [] as [Double]) == 0)\nassert(double_the_difference(lst: [5.0, 4.0]) == 25)\nassert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)\nassert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)\nassert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)\nassert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)\nassert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"},{"task_id":"HumanEval_152","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ মানটো হ'ল 0, আৰু যদি নহয়, মানটো হ'ল অনুমান আৰু স্ক'ৰৰ মাজৰ সম্পূৰ্ণ পাৰ্থক্য।\/\/ প্ৰত্যেক অনুমান কিমান দূৰলৈ আছিল তাক বুজোৱা একে দীঘল এৰেজ এটা ঘূৰাই আনে। যদি তেওঁলোকে সঠিকভাৱে অনুমান কৰিছে, \/\/ আপোনাক দুটা সম-লম্বৰ স্ক'ৰ আৰু অনুমানৰ এৰেজ দিয়া হৈছে, য'ত প্ৰতিটো সূচকে মিল দেখুৱায়।আপোনাৰ কাম হ'ল কোনো ব্যক্তিয়ে সঠিকভাৱে বহু সংখ্যক মেচত ফলাফল অনুমান কৰিছে নে নাই সেয়া নিৰ্ণয় কৰা।\/\/ নিশ্চিতভাৱে নোট কৰি তুলনা কৰাৰ যোগ্য।এই ঘটনাটো অৱশেষত জানিব পাৰিছো। সেই মুহূৰ্তত আপোনাৰ যি ভাব আৰু অনুভূতি আছে সেইবোৰ হৈছেআমি সকলোৱে মনত ৰাখিম যেতিয়া বহুদিনৰ পৰা আশা কৰা কোনো এটা কামৰ ফলাফলত আমি নিজকে সুখী অনুভৱ কৰো।\/\/\/ >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])\n\/\/\/ [0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])\n\/\/\/ [4, 4, 1, 0, 0, 6]\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n","canonical_solution":"func compare(game: [Int], guess: [Int]) -> [Int] {\n    var result: [Int] = []\n    \n    for i in 0..<game.count {\n        let difference = abs(game[i] - guess[i])\n        result.append(difference)\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])\nassert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])\nassert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])\nassert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"},{"task_id":"HumanEval_153","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ (তাৰ শক্তি হ'ল -১) ।\/\/ 'Slices.SERVINGSliCes' ৰিটাৰ্ণ কৰে যিহেতু 'SERVINGSliCes' হৈছে আটাইতকৈ শক্তিশালী সম্প্ৰসাৰণ \/\/ extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] তেতিয়া আপুনি উদাহৰণস্বৰূপে, যদি আপোনাক \"Slices\" শ্ৰেণী আৰু এটা এৰেজ দিয়া হয়,\/\/ এৰেজত প্ৰথম যিটো আহিছে সেইটো বাছনি কৰক।\/\/ যদি দুটা বা ততোধিক এক্সটেনশ্যন একেই শক্তিৰ থাকে, আপুনি \/\/ বিন্যাসঃ শ্ৰেণীৰ নাম. শক্তিশালী সম্প্ৰসাৰণ নাম. \/\/ আপুনি আটাইতকৈ শক্তিশালী সম্প্ৰসাৰণটো বিচাৰি উলিয়াব লাগিব আৰু ইয়াত এটা ষ্ট্ৰিং ঘূৰাই দিব লাগিব \/\/ সম্প্ৰসাৰণৰ নামত, শক্তি CAP - SM ভগ্নাংশৰ দ্বাৰা দিয়া হয়।\/\/ এক্সটেনশ্যনৰ নামত আখৰবোৰ, আৰু SM সৰু আখৰৰ সংখ্যা হওক \/\/ সম্প্ৰসাৰণৰ শক্তি নিম্নলিখিত ধৰণৰঃ CAPক ডাঙৰ আখৰৰ সংখ্যা বুলি ধৰা হওক ।\/\/ সম্প্ৰসাৰণসমূহ শ্ৰেণীৰ অতিৰিক্ত শ্ৰেণীসমূহ লোড কৰিবলৈ ব্যৱহাৰ কৰা হ'ব।\/\/ আপোনাক এটা শ্ৰেণীৰ নাম (এটা স্ট্ৰিং) আৰু এটা এক্সটেনশ্যন এৰেজ দিয়া হ'ব।\/\/\/ >>> Strongest_Extension(class_name: \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n\/\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n","canonical_solution":"func Strongest_Extension(class_name: String, extensions: [String]) -> String {\n    var strongestExtension: String? = nil\n    var maxStrength = Int.min\n    \n    for ext in extensions {\n        let cap = ext.filter { $0.isUppercase }.count\n        let sm = ext.filter { $0.isLowercase }.count\n        let strength = cap - sm\n        \n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = ext\n        }\n    }\n    \n    if let strongestExt = strongestExtension {\n        return \"\\(class_name).\\(strongestExt)\"\n    }\n    \n    return class_name\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"},{"task_id":"HumanEval_154","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ আপোনাক দুটা শব্দ দিয়া হৈছে. আপুনি true ঘূৰাই দিব লাগিব যদি দ্বিতীয় শব্দটো বা ইয়াৰ যিকোনো এটা ঘূৰ্ণন প্ৰথম শব্দটোৰ এটা উপশাৰী হয় \/\/\/ >>> cycpattern_check(a: \"abcd\", b: \"abd\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"hello\", b: \"ell\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"whassup\", b: \"psus\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"abab\", b: \"baa\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"efef\", b: \"eeff\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"himenss\", b: \"simen\")\n\/\/\/ true\nfunc cycpattern_check(a: String, b: String) -> Bool {\n","canonical_solution":"func cycpattern_check(a: String, b: String) -> Bool {\n    guard !b.isEmpty else { return true }\n    let bCombined = b + b\n    for i in 0..<b.count {\n        let rotation = String(bCombined.dropFirst(i).prefix(b.count))\n        if a.contains(rotation) {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cycpattern_check(a: \"xyzw\", b: \"xyw\") == false)\nassert(cycpattern_check(a: \"yello\", b: \"ell\") == true)\nassert(cycpattern_check(a: \"whattup\", b: \"ptut\") == false)\nassert(cycpattern_check(a: \"efef\", b: \"fee\") == true)\nassert(cycpattern_check(a: \"abab\", b: \"aabb\") == false)\nassert(cycpattern_check(a: \"winemtt\", b: \"tinem\") == true)"},{"task_id":"HumanEval_155","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ এটা পূৰ্ণ সংখ্যা দিয়া হ'লে, এটা সম আৰু অগণন সংখ্যা থকা এটা টুপল ঘূৰাই দিয়া হ'ব।\/\/\/ >>> even_odd_count(num: -12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(num: 123)\n\/\/\/ (1, 2)\nfunc even_odd_count(num: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_count(num: Int) -> (Int, Int) {\n    var countEvens = 0\n    var countOdds = 0\n    var number = abs(num) \/\/ Handle negative numbers by taking absolute value\n\n    while number > 0 {\n        let digit = number % 10\n        if digit % 2 == 0 {\n            countEvens += 1\n        } else {\n            countOdds += 1\n        }\n        number \/= 10\n    }\n    return (countEvens, countOdds)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_count(num: 7) == (0, 1))\nassert(even_odd_count(num: -78) == (1, 1))\nassert(even_odd_count(num: 3452) == (2, 2))\nassert(even_odd_count(num: 346211) == (3, 3))\nassert(even_odd_count(num: -345821) == (3, 3))\nassert(even_odd_count(num: -2) == (1, 0))\nassert(even_odd_count(num: -45347) == (2, 3))\nassert(even_odd_count(num: 0) == (1, 0))"},{"task_id":"HumanEval_156","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ প্ৰতিবন্ধকতাঃ ১ <= সংখ্যা <= ১০০০\/\/ আৰু ইয়াক সৰু আখৰেৰে ঘূৰাই দিব. \/\/ এটা ধনাত্মক পূৰ্ণ সংখ্যা দিয়া হ'লে, ইয়াৰ ৰোমান সংখ্যা সমতুল্য এটা শাৰী হিচাপে প্ৰাপ্ত কৰক, \/\/\/ >>> int_to_mini_roman(number: 19)\n\/\/\/ \"xix\"\n\/\/\/ >>> int_to_mini_roman(number: 152)\n\/\/\/ \"clii\"\n\/\/\/ >>> int_to_mini_roman(number: 426)\n\/\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number: Int) -> String {\n","canonical_solution":"func int_to_mini_roman(number: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    \n    var num = number\n    var result = \"\"\n    \n    for (index, value) in values.enumerated() {\n        while num >= value {\n            result += numerals[index]\n            num -= value\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"},{"task_id":"HumanEval_157","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ ৯০ ডিগ্ৰী. \/\/ এটা সমকোণযুক্ত ত্ৰিভুজ হৈছে এটা ত্ৰিভুজ য'ত এটা কোণ সঠিক কোণ বা \/\/ পক্ষবোৰে এটা সোঁ কোণযুক্ত ত্ৰিভুজ গঠন কৰে, অন্যথা মিছা।\/\/ ত্ৰিভুজৰ তিনিটা পক্ষৰ দৈৰ্ঘ্য দিয়া হৈছে। যদি তিনিটা \/\/\/ >>> right_angle_triangle(a: 3, b: 4, c: 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(a: 1, b: 2, c: 3)\n\/\/\/ false\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n","canonical_solution":"func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n    let sides = [a, b, c].sorted()\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(right_angle_triangle(a: 3, b: 4, c: 5) == true)\nassert(right_angle_triangle(a: 1, b: 2, c: 3) == false)\nassert(right_angle_triangle(a: 10, b: 6, c: 8) == true)\nassert(right_angle_triangle(a: 2, b: 2, c: 2) == false)\nassert(right_angle_triangle(a: 7, b: 24, c: 25) == true)\nassert(right_angle_triangle(a: 10, b: 5, c: 7) == false)\nassert(right_angle_triangle(a: 5, b: 12, c: 13) == true)\nassert(right_angle_triangle(a: 15, b: 8, c: 17) == true)\nassert(right_angle_triangle(a: 48, b: 55, c: 73) == true)\nassert(right_angle_triangle(a: 1, b: 1, c: 1) == false)\nassert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"},{"task_id":"HumanEval_158","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ চিহ্ন, যিটো শব্দকোষীয় ক্ৰমত প্ৰথম আহে তাক ঘূৰাই দিয়ে।যদি একাধিক শাৰীসমূহত সৰ্বাধিক সংখ্যক অনন্য চিহ্ন থাকে।\/\/ এৰেটোত বিভিন্ন শব্দ আছে. সৰ্বাধিক সংখ্যাৰ সৈতে শব্দটো ঘূৰাই আনা ।এটা ফাংচন লিখা যি এটা ষ্ট্ৰীঙৰ এৰে গ্ৰহণ কৰে।\/\/\/ >>> find_max(words: [\"name\", \"of\", \"string\"])\n\/\/\/ \"string\"\n\/\/\/ >>> find_max(words: [\"name\", \"enam\", \"game\"])\n\/\/\/ \"enam\"\n\/\/\/ >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/\/ \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n","canonical_solution":"func find_max(words: [String]) -> String {\n    func uniqueCharacterCount(in word: String) -> Int {\n        return Set(word).count\n    }\n    \n    return words.max { a, b in\n        let uniqueCountA = uniqueCharacterCount(in: a)\n        let uniqueCountB = uniqueCharacterCount(in: b)\n        \n        if uniqueCountA == uniqueCountB {\n            return a > b\n        }\n        \n        return uniqueCountA < uniqueCountB\n    } ?? \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"},{"task_id":"HumanEval_159","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণঃ \/\/ যদি পৰ্যাপ্ত পৰিমাণৰ গাজৰ বাকী নাই, আপুনি বাকী থকা সকলো গাজৰ খাব, কিন্তু তেতিয়াও ভোকত থাকিব।* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\/\/ আপুনি [ আপোনাৰ আহাৰৰ পিছত খোৱা গাজৰৰ মুঠ সংখ্যা, কিন্তু এতিয়া আপুনি দিনটোৰ আহাৰ সম্পূৰ্ণ কৰিবলৈ অধিক কেৰাচ খাব লাগিব।তুমি এটা ভোকাতুৰ কণী, আৰু তুমি ইতিমধ্যে এটা নিৰ্দিষ্ট সংখ্যক গাজৰ খাইছো,\/\/\/ >>> eat(number: 5, need: 6, remaining: 10)\n\/\/\/ [11, 4]\n\/\/\/ >>> eat(number: 4, need: 8, remaining: 9)\n\/\/\/ [12, 1]\n\/\/\/ >>> eat(number: 1, need: 10, remaining: 10)\n\/\/\/ [11, 0]\n\/\/\/ >>> eat(number: 2, need: 11, remaining: 5)\n\/\/\/ [7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n","canonical_solution":"func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalNeeded = number + need\n    let totalEaten = min(totalNeeded, number + remaining)\n    let carrotsLeft = max(0, remaining - (totalEaten - number))\n    return [totalEaten, carrotsLeft]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"},{"task_id":"HumanEval_160","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ অপাৰেটৰ এৰেজত কমেও এটা অপাৰেটৰ থাকে আৰু অপাৰেণ্ড এৰেজত কমেও দুটা অপাৰেণ্ড থাকে।\/\/ অপাৰেণ্ড হৈছে অ-নতিবাচক অখণ্ড সংখ্যাৰ এটা সজ্জা।\/\/ অপাৰেটৰ এৰেজটোৰ দৈৰ্ঘ্য অপাৰেণ্ড এৰেজটোৰ দৈৰ্ঘ্য বিয়োগ একৰ সমান।\/\/ টোকাঃ \/\/ => ফলাফল = 9 \/\/ ফলাফল = 2 + 3 * 4 - 5 \/\/ এৰে = [2, 3, 4, 5] \/\/ অপাৰেটৰ['+', '*', '-'] \/\/ উদাহৰণঃ \/\/ বিৰূপকৰণ (**) \/\/ তল ভাগ কৰা ( \/\/ ) \/\/ গুণন (* ) \/\/ বিয়োগ ( - ) \/\/ যোগ কৰা (+) \/\/ মৌলিক বীজগণিতৰ কাৰ্য্য: \/\/ এক্সপ্ৰেছন আৰু এই এক্সপ্ৰেছনৰ মূল্যাংকন ঘূৰাই দিব.\/\/ দ্বিতীয় এৰেজটো হ'ল এটা সম্পূৰ্ণ সংখ্যাৰ এৰেজ। এই দুটা এৰেজ ব্যৱহাৰ কৰি বীজগণিত গঠন কৰা।প্ৰথম এৰেজত মৌলিক বীজগণিতৰ ক্ৰিয়া আছে, আৰু func do_algebra(operator: [String], operand: [Int]) -> Int {\n","canonical_solution":"func do_algebra(operator: [String], operand: [Int]) -> Int {\n    var result = operand[0]\n    let precedence: [String: Int] = [\"+\": 1, \"-\": 1, \"*\": 2, \"\/\/\": 2, \"**\": 3]\n    \n    var opStack: [String] = []\n    var numStack: [Int] = [result]\n    \n    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {\n        switch op {\n        case \"+\":\n            return a + b\n        case \"-\":\n            return a - b\n        case \"*\":\n            return a * b\n        case \"\/\/\":\n            return a \/ b\n        case \"**\":\n            return Int(pow(Double(a), Double(b)))\n        default:\n            fatalError(\"Unsupported operator: \\(op)\")\n        }\n    }\n    \n    for i in 0..<operator.count {\n        let currentOp = `operator`[i]\n        let currentNum = operand[i + 1]\n        \n        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {\n            opStack.removeLast()\n            let b = numStack.removeLast()\n            let a = numStack.removeLast()\n            numStack.append(applyOperator(lastOp, b, a))\n        }\n        \n        opStack.append(currentOp)\n        numStack.append(currentNum)\n    }\n    \n    while let lastOp = opStack.popLast() {\n        let b = numStack.removeLast()\n        let a = numStack.removeLast()\n        numStack.append(applyOperator(lastOp, b, a))\n    }\n    \n    return numStack.first!\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(do_algebra(operator: [\"**\", \"*\", \"+\"], operand: [2, 3, 4, 5]) == 37)\nassert(do_algebra(operator: [\"+\", \"*\", \"-\"], operand: [2, 3, 4, 5]) == 9)\nassert(do_algebra(operator: [\"\/\/\", \"*\"], operand: [7, 3, 4]) == 8)"},{"task_id":"HumanEval_161","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণ \/\/ ফাংচনে ফলাফলৰ শাৰীটো ঘূৰাই দিব লাগে।\/\/ যদি শাৰীটোত কোনো আখৰ নাই, শাৰীটো উলটি লওক।\/ অন্যথা যিদৰে আছে তেনেকৈয়ে থাকক।\/\/ যদি s[i] এটা আখৰ হয়, ইয়াৰ কেচ নিম্নৰ পৰা উচ্চলৈ বা বিপৰীতলৈ উলট-পালট কৰা,\/\/ আপোনাক এটা ষ্ট্ৰিং দিয়া হৈছে s. \/\/\/ >>> solve(s: \"1234\")\n\/\/\/ \"4321\"\n\/\/\/ >>> solve(s: \"ab\")\n\/\/\/ \"AB\"\n\/\/\/ >>> solve(s: \"#a@C\")\n\/\/\/ \"#A@c\"\nfunc solve(s: String) -> String {\n","canonical_solution":"func solve(s: String) -> String {\n    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n    \n    var result = \"\"\n    for char in s {\n        if char.isLetter {\n            if char.isLowercase {\n                result.append(char.uppercased())\n            } else {\n                result.append(char.lowercased())\n            }\n        } else {\n            result.append(char)\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"},{"task_id":"HumanEval_162","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ যদি 'text' এটা খালী স্ট্ৰিং হয়, null ঘূৰাই দিব.\/\/ এটা ষ্ট্ৰিং 'text' দিয়া হ'লে, ইয়াৰ md5 হেচ সমতুল্য ষ্ট্ৰিং ঘূৰাই দিয়ক।\/\/\/ >>> string_to_md5(text: \"Hello world\")\n\/\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunc string_to_md5(text: String) -> String? {\n","canonical_solution":"import Foundation\nimport CommonCrypto\n\nfunc string_to_md5(text: String) -> String? {\n    guard !text.isEmpty else { return nil }\n    \n    let length = Int(CC_MD5_DIGEST_LENGTH)\n    let messageData = text.data(using: .utf8)!\n    var digestData = Data(count: length)\n    \n    _ = digestData.withUnsafeMutableBytes { digestBytes in\n        messageData.withUnsafeBytes { messageBytes in\n            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)\n        }\n    }\n    \n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\nassert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\nassert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\")"},{"task_id":"HumanEval_163","nl":"asm_Beng","pl":"swift","prompt":"\n\/\/ উদাহৰণস্বৰূপেঃ \/\/ আৰু b, ক্ৰমান্বয়ে বৃদ্ধি হৈ আছে।\/\/ দুটা ধনাত্মক পূৰ্ণ সংখ্যা a আৰু b দিয়া হ'লে, a আৰু b ৰ মাজৰ সমসংখ্যাৰ অংকটো ঘূৰাই দিব \/\/\/ >>> generate_integers(a: 2, b: 8)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 8, b: 2)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 10, b: 14)\n\/\/\/ [] as [Int]\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n","canonical_solution":"func generate_integers(a: Int, b: Int) -> [Int] {\n    let lower = min(a, b)\n    let upper = max(a, b)\n    var result = [Int]()\n    \n    for number in lower...upper {\n        if number % 2 == 0 {\n            result.append(number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])\nassert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 17, b: 89) == [] as [Int])"}]