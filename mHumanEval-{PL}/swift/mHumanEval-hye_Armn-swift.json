[{"task_id":"HumanEval_0","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ տրված շեմը: \/\/ Ստուգեք, թե տվյալ թվերի շարքում, արդյոք երկու թվեր ավելի մոտ են իրար, քան \/\/\/ >>> has_close_elements(numbers: [1.0, 2.0, 3.0], threshold: 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(numbers: [1.0, 2.8, 3.0, 4.0, 5.0, 2.0], threshold: 0.3)\n\/\/\/ true\nfunc has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n","canonical_solution":"func has_close_elements(numbers: [Double], threshold: Double) -> Bool {\n    let sortedNumbers = numbers.sorted()\n    for i in 0..<sortedNumbers.count - 1 {\n        if sortedNumbers[i+1] - sortedNumbers[i] < threshold {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.3) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2], threshold: 0.05) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.95) == true)\nassert(has_close_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0], threshold: 0.8) == false)\nassert(has_close_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0], threshold: 0.1) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 1.0) == true)\nassert(has_close_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1], threshold: 0.5) == false)"},{"task_id":"HumanEval_1","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Անտեսեք մուտքագրման տողում եղած ցանկացած բաց տարածություն:\/\/ Բաժանված խմբերը հավասարակշռված են (յուրաքանչյուր բաց կոշիկ պատշաճ կերպով փակված է) եւ չեն տեղավորվում միմյանց մեջ:\/\/ բաժանեք այդ խմբերը առանձին տողերի եւ վերադարձրեք դրանց զանգվածը:\/\/ Այս ֆունկցիայի մուտքը պարունակում է վարդակ, որը պարունակում է վարդակավորված կլորների բազմաթիվ խմբեր: Ձեր նպատակը ' \/\/\/ >>> separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\")\n\/\/\/ [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string: String) -> [String] {\n","canonical_solution":"func separate_paren_groups(paren_string: String) -> [String] {\n    var results = [String]()\n    var currentGroup = \"\"\n    var balance = 0\n\n    for char in paren_string {\n        \/\/ Ignore spaces\n        if char == \" \" {\n            continue\n        }\n        \n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\n        currentGroup.append(char)\n\n        if balance == 0 && !currentGroup.isEmpty {\n            results.append(currentGroup)\n            currentGroup = \"\"\n        }\n    }\n    \n    return results\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"},{"task_id":"HumanEval_2","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է թվերի տասնորդական մասը: \/\/ (մնացած մասը միշտ փոքր է, քան 1):\/\/ եւ ամբողջական մասը (առավել մեծ ամբողջական թիվը, որը փոքր է տրված թվից) եւ տասնորդականները \/\/ Եթե տրվի դրական փոփոխական կետով թիվ, այն կարող է բաժանվել \/\/\/ >>> truncate_number(number: 3.5)\n\/\/\/ 0.5\nfunc truncate_number(number: Double) -> Double {\n","canonical_solution":"func truncate_number(number: Double) -> Double {\n    return number - Double(Int(number))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"},{"task_id":"HumanEval_3","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ այդ պահին ֆունկցիան պետք է վերադարձնի true. հակառակ դեպքում պետք է վերադարձնի false:Ձեր խնդիրն է հայտնաբերել, եթե որեւէ պահի հաշվին մնացորդը ընկնում է զրոյից ցածր, եւ\/\/ Ձեզ տրվում է բանկային հաշիվից գումարներ դնելու եւ հանելու մի շարք գործողություններ, որոնք սկսվում են \/\/\/ >>> below_zero(operations: [1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(operations: [1, 2, -4, 5])\n\/\/\/ true\nfunc below_zero(operations: [Int]) -> Bool {\n","canonical_solution":"func below_zero(operations: [Int]) -> Bool {\n    var balance = 0\n    for operation in operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_zero(operations: [] as [Int]) == false)\nassert(below_zero(operations: [1, 2, -3, 1, 2, -3]) == false)\nassert(below_zero(operations: [1, 2, -4, 5, 6]) == true)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -4]) == false)\nassert(below_zero(operations: [1, -1, 2, -2, 5, -5, 4, -5]) == true)\nassert(below_zero(operations: [1, -2, 2, -2, 5, -5, 4, -4]) == true)"},{"task_id":"HumanEval_4","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ MAD = միջին x - x_mean \/\/ տարր եւ կենտրոնական կետ (սա միջինն է): \/\/ Միջին բացարձակ շեղումը յուրաքանչյուրի միջեւ միջին բացարձակ տարբերությունն է:\/\/ այս տվյալների հավաքածուի միջին արժեքի շուրջ: \/\/ Տվյալ մուտքագրված թվերի համար հաշվարկեք միջին բացարձակ շեղումը:\/\/\/ >>> mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfunc mean_absolute_deviation(numbers: [Double]) -> Double {\n","canonical_solution":"func mean_absolute_deviation(numbers: [Double]) -> Double {\n    guard !numbers.isEmpty else { return 0.0 }\n    \n    let mean = numbers.reduce(0.0, +) \/ Double(numbers.count)\n    let absoluteDifferences = numbers.map { abs($0 - mean) }\n    let mad = absoluteDifferences.reduce(0.0, +) \/ Double(absoluteDifferences.count)\n    \n    return mad\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(mean_absolute_deviation(numbers: [1.0, 2.0]) == 0.5)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0]) == 1.0)\nassert(mean_absolute_deviation(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2)"},{"task_id":"HumanEval_5","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Ներդրեք \"մերձավորող\" թիվը մուտքագրման զանգվածի յուրաքանչյուր երկու հաջորդական տարրերի միջեւ ' `numbers' \/\/\/ >>> intersperse(numbers: [] as [Int], delimeter: 4)\n\/\/\/ [] as [Int]\n\/\/\/ >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\/\/\/ [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n","canonical_solution":"func intersperse(numbers: [Int], delimeter: Int) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    \n    var result: [Int] = []\n    \n    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n    }\n    \n    \/\/ Remove the last added delimiter\n    result.removeLast()\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"},{"task_id":"HumanEval_6","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ (() (()) ունի առավելագույնը երկու մակարդակ, իսկ ((())) -ը ունի երեք: \/\/ Յուրաքանչյուր խմբի համար արտադրի՛ր կլորակետերի խորանարդության ամենախոր մակարդակը:\/\/ Այս ֆունկցիայի մուտքը մի շարք է, որը ներկայացված է բազմաթիվ խմբերով, որոնք բաժանված են միջակայքով:\/\/\/ >>> parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\")\n\/\/\/ [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String) -> [Int] {\n","canonical_solution":"func parse_nested_parens(paren_string: String) -> [Int] {\n    let groups = paren_string.split(separator: \" \")\n    var depths: [Int] = []\n    \n    for group in groups {\n        var maxDepth = 0\n        var currentDepth = 0\n        \n        for char in group {\n            if char == \"(\" {\n                currentDepth += 1\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == \")\" {\n                currentDepth -= 1\n            }\n        }\n        \n        depths.append(maxDepth)\n    }\n    \n    return depths\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\") == [4])"},{"task_id":"HumanEval_7","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Ֆիլտրում է տողերի մուտքային զանգվածը միայն այն տողերի համար, որոնք պարունակում են տրված ենթատողեր:\/\/\/ >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n\/\/\/ [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n","canonical_solution":"func filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter { $0.contains(substring) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"},{"task_id":"HumanEval_8","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վիճակագծի բաց գումարը պետք է լինի 0 եւ վիճակագծի բաց բազմապատկումը պետք է լինի 1։ \/\/ Տվյալ ամբողջ թվերի շարքի համար վերադարձնել մի տուփլ, որը բաղկացած է մի շարք բոլոր ամբողջ թվերի գումարից եւ արտադրանքից: \/\/\/ >>> sum_product(numbers: [] as [Int])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(numbers: [1, 2, 3, 4])\n\/\/\/ (10, 24)\nfunc sum_product(numbers: [Int]) -> (Int, Int) {\n","canonical_solution":"func sum_product(numbers: [Int]) -> (Int, Int) {\n    let sum = numbers.reduce(0, +)\n    let product = numbers.reduce(1, *)\n    return (sum, product)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_product(numbers: [] as [Int]) == (0, 1))\nassert(sum_product(numbers: [1, 1, 1]) == (3, 1))\nassert(sum_product(numbers: [100, 0]) == (100, 0))\nassert(sum_product(numbers: [3, 5, 7]) == (15, 105))\nassert(sum_product(numbers: [10]) == (10, 10))"},{"task_id":"HumanEval_9","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ հաջորդականության մեջ: \/\/ Տվյալ ամբողջ թվերի շարքից, ստեղծեք մինչեւ տվյալ պահը գտնված առավելագույն տարրի շարք:\/\/\/ >>> rolling_max(numbers: [1, 2, 3, 2, 3, 4, 2])\n\/\/\/ [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int]) -> [Int] {\n","canonical_solution":"func rolling_max(numbers: [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax: Int? = nil\n    for number in numbers {\n        if let max = currentMax {\n            currentMax = max > number ? max : number\n        } else {\n            currentMax = number\n        }\n        result.append(currentMax!)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"},{"task_id":"HumanEval_10","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ - Շղթայի վերջում ավելացնել այն նախադասությունը, որը գալիս է պալինդրոմային վերջույթից առաջ: \/\/ - Գտեք մատակարարված տողի ամենաերկար postfix- ը, որը պալինդրոմ է: \/\/ Ալգորիթմի գաղափարը պարզ է: \/\/ Գտեք ամենակարճ պալինդրոմը, որը սկսվում է տրված տողով: \/\/\/ >>> make_palindrome(string: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> make_palindrome(string: \"cat\")\n\/\/\/ \"catac\"\n\/\/\/ >>> make_palindrome(string: \"cata\")\n\/\/\/ \"catac\"\nfunc make_palindrome(string: String) -> String {\n","canonical_solution":"func make_palindrome(string: String) -> String {\n    func isPalindrome(_ s: String) -> Bool {\n        return s == String(s.reversed())\n    }\n    \n    if string.isEmpty || isPalindrome(string) {\n        return string\n    }\n    \n    for i in stride(from: string.count, through: 0, by: -1) {\n        let suffixIndex = string.index(string.startIndex, offsetBy: i)\n        let suffix = String(string[suffixIndex..<string.endIndex])\n        if isPalindrome(suffix) {\n            let prefix = String(string[string.startIndex..<suffixIndex])\n            return string + String(prefix.reversed())\n        }\n    }\n    \n    return string\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"},{"task_id":"HumanEval_11","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Կատարեք երկակի XOR այս մուտքագրումների վրա եւ վերադարձեք արդյունքը նաեւ որպես տող: \/\/ Ներդնում ենք երկու տողեր a եւ b, որոնք բաղկացած են միայն 1 եւ 0 թվերից:\/\/\/ >>> string_xor(a: \"010\", b: \"110\")\n\/\/\/ \"100\"\nfunc string_xor(a: String, b: String) -> String {\n","canonical_solution":"func string_xor(a: String, b: String) -> String {\n    let charactersA = Array(a)\n    let charactersB = Array(b)\n    var result = \"\"\n\n    for i in 0..<charactersA.count {\n        let bitA = charactersA[i]\n        let bitB = charactersB[i]\n        \n        if bitA != bitB {\n            result.append(\"1\")\n        } else {\n            result.append(\"0\")\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"},{"task_id":"HumanEval_12","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ նույն երկարության տողեր: Վերադարձեք null, եթե մուտքագրման զանգվածը դատարկ է:\/\/ Արիեից դուրս, վերադարձնում ենք ամենաերկարը:\/\/\/ >>> longest(strings: [] as [String])\n\/\/\/ nil\n\/\/\/ >>> longest(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"a\"\n\/\/\/ >>> longest(strings: [\"a\", \"bb\", \"ccc\"])\n\/\/\/ \"ccc\"\nfunc longest(strings: [String]) -> String? {\n","canonical_solution":"func longest(strings: [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n    for string in strings {\n        if string.count > longestString.count {\n            longestString = string\n        }\n    }\n    return longestString\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"},{"task_id":"HumanEval_13","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է a եւ b երկու ամբողջ թվերի ամենամեծ ընդհանուր բաժանարարը\/\/\/ >>> greatest_common_divisor(a: 3, b: 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(a: 25, b: 15)\n\/\/\/ 5\nfunc greatest_common_divisor(a: Int, b: Int) -> Int {\n","canonical_solution":"func greatest_common_divisor(a: Int, b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return greatest_common_divisor(a: b, b: a % b)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(greatest_common_divisor(a: 3, b: 7) == 1)\nassert(greatest_common_divisor(a: 10, b: 15) == 5)\nassert(greatest_common_divisor(a: 49, b: 14) == 7)\nassert(greatest_common_divisor(a: 144, b: 60) == 12)"},{"task_id":"HumanEval_14","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է մուտքագրման տողերի բոլոր նախադաշարերի շարքը՝ ամենակարճից մինչեւ ամենաերկարը:\/\/\/ >>> all_prefixes(string: \"abc\")\n\/\/\/ [\"a\", \"ab\", \"abc\"]\nfunc all_prefixes(string: String) -> [String] {\n","canonical_solution":"func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] = []\n    for i in 1...string.count {\n        let prefix = String(string.prefix(i))\n        prefixes.append(prefix)\n    }\n    return prefixes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"},{"task_id":"HumanEval_15","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է տող, որը պարունակում է տարածությամբ սահմանված թվեր՝ սկսած 0-ից մինչեւ n ներառյալ: \/\/\/ >>> string_sequence(n: 0)\n\/\/\/ \"0\"\n\/\/\/ >>> string_sequence(n: 5)\n\/\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n: Int) -> String {\n","canonical_solution":"func string_sequence(n: Int) -> String {\n    return (0...n).map { String($0) }.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_sequence(n: 0) == \"0\")\nassert(string_sequence(n: 3) == \"0 1 2 3\")\nassert(string_sequence(n: 10) == \"0 1 2 3 4 5 6 7 8 9 10\")"},{"task_id":"HumanEval_16","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Տված տողից պարզեք, թե քանի տարբերակիչ նիշ է պարունակում (անկախ տեքստից)\/\/\/ >>> count_distinct_characters(string: \"xyzXYZ\")\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(string: \"Jerry\")\n\/\/\/ 4\nfunc count_distinct_characters(string: String) -> Int {\n","canonical_solution":"func count_distinct_characters(string: String) -> Int {\n    let lowercasedString = string.lowercased()\n    let distinctCharacters = Set(lowercasedString)\n    return distinctCharacters.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_distinct_characters(string: \"\") == 0)\nassert(count_distinct_characters(string: \"abcde\") == 5)\nassert(count_distinct_characters(string: \"abcdecadeCADE\") == 5)\nassert(count_distinct_characters(string: \"aaaaAAAAaaaa\") == 1)\nassert(count_distinct_characters(string: \"Jerry jERRY JeRRRY\") == 5)"},{"task_id":"HumanEval_17","nl":"hye_Armn","pl":"swift","prompt":"\n\"Առաջին\" - քառորդային նոտա, տեւում է մեկ բիթ:\"o\" - կես նոտա, տեւում է երկու բիթ:\"Օ\" - ամբողջ նոտա, տեւում է չորս բիթ:\/ Ահա մի լեգենդ: \/\/\/ ոչ վերջինը: \/\/ Ձեր խնդիրն է վերլուծել այս տողը եւ վերադարձնել ամբողջ թվերի շարքը, որը համապատասխանում է յուրաքանչյուրի քանի հարվածի:\/\/ Այս ֆունկցիայի մուտքը երաժշտական նոտաների շարքն է, որը ներկայացվում է հատուկ ASCII ձեւաչափով: \/\/\/ >>> parse_music(music_string: \"o o| .| o| o| .| .| .| .| o o\")\n\/\/\/ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunc parse_music(music_string: String) -> [Int] {\n","canonical_solution":"func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.split(separator: \" \")\n    var beats: [Int] = []\n    \n    for note in notes {\n        switch note {\n        case \"o\":\n            beats.append(4)\n        case \"o|\":\n            beats.append(2)\n        case \".|\":\n            beats.append(1)\n        default:\n            continue\n        }\n    }\n    \n    return beats\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"},{"task_id":"HumanEval_18","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Գտեք, թե քանի անգամ է տրված ենթաշարը կարելի գտնել սկզբնական շղթայում: Հաշվեք ծածկվող դեպքերը: \/\/\/ >>> how_many_times(string: \"\", substring: \"a\")\n\/\/\/ 0\n\/\/\/ >>> how_many_times(string: \"aaa\", substring: \"a\")\n\/\/\/ 3\n\/\/\/ >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n\/\/\/ 3\nfunc how_many_times(string: String, substring: String) -> Int {\n","canonical_solution":"func how_many_times(string: String, substring: String) -> Int {\n    guard !substring.isEmpty else { return 0 }\n    \n    var count = 0\n    var startIndex = string.startIndex\n    \n    while let range = string.range(of: substring, range: startIndex..<string.endIndex) {\n        count += 1\n        startIndex = string.index(after: range.lowerBound)\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"},{"task_id":"HumanEval_19","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է թվերի շարքը՝ դասավորված ամենափոքրից մինչեւ ամենամեծը:\/\/ Գործող ընտրությունները 'զրո', 'մեկ', 'երկու', 'երեք', 'չորս', 'հինգ', 'վեց', 'յոթ', 'ութ' եւ 'նուներեք' են: \/\/ Մուտքը թվային թվերի տող է, որը սահմանված է տարածքով 'զրո' -ից 'նյոթ':\/\/\/ >>> sort_numbers(numbers: \"three one five\")\n\/\/\/ \"one three five\"\nfunc sort_numbers(numbers: String) -> String {\n","canonical_solution":"func sort_numbers(numbers: String) -> String {\n    \/\/ Mapping of word numbers to digits\n    let numberWords: [String: Int] = [\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    ]\n\n    \/\/ Split the input string into words\n    let words = numbers.split(separator: \" \")\n\n    \/\/ Sort the words based on their corresponding number values\n    let sortedWords = words.sorted { \n        numberWords[String($0)]! < numberWords[String($1)]! \n    }\n\n    \/\/ Join the sorted words back into a single string\n    return sortedWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_numbers(numbers: \"\") == \"\")\nassert(sort_numbers(numbers: \"three\") == \"three\")\nassert(sort_numbers(numbers: \"three five nine\") == \"three five nine\")\nassert(sort_numbers(numbers: \"five zero four seven nine eight\") == \"zero four five seven eight nine\")\nassert(sort_numbers(numbers: \"six five four three two one zero\") == \"zero one two three four five six\")"},{"task_id":"HumanEval_20","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ այլ եւ վերադարձնել դրանք ըստ կարգի (փոքր թիվ, մեծ թիվ):\/\/ Տրամադրված թվերի շարքից (առնվազն երկուսը) ընտրեք եւ վերադարձրեք երկուսը, որոնք ամենից մոտ են յուրաքանչյուրին:\/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n","canonical_solution":"func find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    \/\/ Sort the array to bring closest numbers next to each other\n    let sortedNumbers = numbers.sorted()\n    \n    \/\/ Initialize variables to keep track of the smallest difference and the pair\n    var minDifference = Double.greatestFiniteMagnitude\n    var closestPair: (Double, Double) = (0.0, 0.0)\n    \n    \/\/ Iterate over the sorted numbers to find the smallest difference\n    for i in 0..<sortedNumbers.count - 1 {\n        let num1 = sortedNumbers[i]\n        let num2 = sortedNumbers[i + 1]\n        let difference = abs(num1 - num2)\n        \n        if difference < minDifference {\n            minDifference = difference\n            closestPair = (num1, num2)\n        }\n    }\n    \n    return closestPair\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"},{"task_id":"HumanEval_21","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ այնպես, որ ամենափոքր թիվը դառնա 0 եւ ամենամեծը' 1 \/\/ Տված թվերի շարքը (առնվազն երկու տարրից), կիրառեք գծային վերափոխում այդ շարքի վրա, \/\/\/ >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double] {\n","canonical_solution":"func rescale_to_unit(numbers: [Double]) -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    \n    let minValue = numbers.min()!\n    let maxValue = numbers.max()!\n    let range = maxValue - minValue\n    \n    guard range != 0 else {\n        return numbers.map { _ in 0.0 }\n    }\n    \n    return numbers.map { ($0 - minValue) \/ range }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"},{"task_id":"HumanEval_22","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Ֆիլտրում է տրված զանգվածը ցանկացած swiftthon արժեքների համար միայն ամբողջ թվերի համար:\/\/\/ >>> filter_integers(values: [\"a\", 3.14, 5])\n\/\/\/ [5]\n\/\/\/ >>> filter_integers(values: [1, 2, 3, \"abc\", [:] as [AnyHashable : AnyHashable], [] as [AnyHashable]])\n\/\/\/ [1, 2, 3]\nfunc filter_integers(values: [AnyHashable]) -> [Int] {\n","canonical_solution":"func filter_integers(values: [AnyHashable]) -> [Int] {\n    return values.compactMap { $0 as? Int }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_integers(values: [] as [AnyHashable]) == [] as [Int])\nassert(filter_integers(values: [4, [:] as [AnyHashable : AnyHashable], [] as [AnyHashable], 23.2, 9, \"adasd\"]) == [4, 9])\nassert(filter_integers(values: [3, \"c\", 3, 3, \"a\", \"b\"]) == [3, 3, 3])"},{"task_id":"HumanEval_23","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձում է տրված տողերի երկարությունը \/\/\/ >>> strlen(string: \"\")\n\/\/\/ 0\n\/\/\/ >>> strlen(string: \"abc\")\n\/\/\/ 3\nfunc strlen(string: String) -> Int {\n","canonical_solution":"func strlen(string: String) -> Int {\n    return string.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strlen(string: \"\") == 0)\nassert(strlen(string: \"x\") == 1)\nassert(strlen(string: \"asdasnakj\") == 9)"},{"task_id":"HumanEval_24","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Տվյալ n թվին համար գտեք ամենամեծ թիվը, որը n-ը հավասարապես բաժանում է, ավելի փոքր է n-ից:\/\/\/ >>> largest_divisor(n: 15)\n\/\/\/ 5\nfunc largest_divisor(n: Int) -> Int {\n","canonical_solution":"func largest_divisor(n: Int) -> Int {\n    for i in stride(from: n \/ 2, to: 0, by: -1) {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_divisor(n: 3) == 1)\nassert(largest_divisor(n: 7) == 1)\nassert(largest_divisor(n: 10) == 5)\nassert(largest_divisor(n: 100) == 50)\nassert(largest_divisor(n: 49) == 7)"},{"task_id":"HumanEval_25","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Մուտքագրված թիվը պետք է հավասար լինի բոլոր գործոնների բազմապատիկին:\/\/ Յուրաքանչյուր գործոն պետք է շարված լինի այն թվով անգամների համար, որոնք համապատասխանում են այն թվին, որով այն հայտնվում է գործոնավորման մեջ:\/\/ Վերադարձնում է տրված ամբողջ թվերի պարզ գործոնների շարքը փոքրից մինչեւ մեծ կարգով: \/\/\/ >>> factorize(n: 8)\n\/\/\/ [2, 2, 2]\n\/\/\/ >>> factorize(n: 25)\n\/\/\/ [5, 5]\n\/\/\/ >>> factorize(n: 70)\n\/\/\/ [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n","canonical_solution":"func factorize(n: Int) -> [Int] {\n    guard n > 1 else { return [] }\n    var number = n\n    var factors: [Int] = []\n    var divisor = 2\n    \n    while number >= divisor {\n        while number % divisor == 0 {\n            factors.append(divisor)\n            number \/= divisor\n        }\n        divisor += 1\n    }\n    \n    return factors\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"},{"task_id":"HumanEval_26","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Մնացորդ տարրերի կարգը պահպանել նույնը, ինչ մուտքագրման մեջ: \/\/ Ամբողջ թվերի շարքից հեռացրեք բոլոր տարրերը, որոնք հանդիպում են ավելի քան մեկ անգամ:\/\/\/ >>> remove_duplicates(numbers: [1, 2, 3, 2, 4])\n\/\/\/ [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int] {\n","canonical_solution":"func remove_duplicates(numbers: [Int]) -> [Int] {\n    var elementCount = [Int: Int]()\n    for number in numbers {\n        elementCount[number, default: 0] += 1\n    }\n    return numbers.filter { elementCount[$0] == 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int]) == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"},{"task_id":"HumanEval_27","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Տվյալ տողերի համար փոքր տառերը վերափոխեք մեծ տառերի եւ մեծ տառերը փոքր տառերի: \/\/\/ >>> flip_case(string: \"Hello\")\n\/\/\/ \"hELLO\"\nfunc flip_case(string: String) -> String {\n","canonical_solution":"func flip_case(string: String) -> String {\n    return String(string.map { character in\n        if character.isLowercase {\n            return character.uppercased()\n        } else if character.isUppercase {\n            return character.lowercased()\n        } else {\n            return String(character)\n        }\n    }.joined())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(flip_case(string: \"\") == \"\")\nassert(flip_case(string: \"Hello!\") == \"hELLO!\")\nassert(flip_case(string: \"These violent delights have violent ends\") == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")"},{"task_id":"HumanEval_28","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Շղթաների շարքը միացրեք մեկ շղթայի մեջ:\/\/\/ >>> concatenate(strings: [] as [String])\n\/\/\/ \"\"\n\/\/\/ >>> concatenate(strings: [\"a\", \"b\", \"c\"])\n\/\/\/ \"abc\"\nfunc concatenate(strings: [String]) -> String {\n","canonical_solution":"func concatenate(strings: [String]) -> String {\n    return strings.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(concatenate(strings: [] as [String]) == \"\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\"]) == \"xyz\")\nassert(concatenate(strings: [\"x\", \"y\", \"z\", \"w\", \"k\"]) == \"xyzwk\")"},{"task_id":"HumanEval_29","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Ֆիլտրում է տողերի մուտքային զանգվածը միայն այն տողերի համար, որոնք սկսվում են տրված նախադասությամբ: \/\/\/ >>> filter_by_prefix(strings: [] as [String], prefix: \"a\")\n\/\/\/ [] as [String]\n\/\/\/ >>> filter_by_prefix(strings: [\"abc\", \"bcd\", \"cde\", \"array\"], prefix: \"a\")\n\/\/\/ [\"abc\", \"array\"]\nfunc filter_by_prefix(strings: [String], prefix: String) -> [String] {\n","canonical_solution":"func filter_by_prefix(strings: [String], prefix: String) -> [String] {\n    return strings.filter { $0.hasPrefix(prefix) }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_prefix(strings: [] as [String], prefix: \"john\") == [] as [String])\nassert(filter_by_prefix(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], prefix: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])"},{"task_id":"HumanEval_30","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է միայն դրական թվերը զանգվածում: \/\/\/ >>> get_positive(l: [-1, 2, -4, 5, 6])\n\/\/\/ [2, 5, 6]\n\/\/\/ >>> get_positive(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ [5, 3, 2, 3, 9, 123, 1]\nfunc get_positive(l: [Int]) -> [Int] {\n","canonical_solution":"func get_positive(l: [Int]) -> [Int] {\n    return l.filter { $0 > 0 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_positive(l: [-1, -2, 4, 5, 6]) == [4, 5, 6])\nassert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\nassert(get_positive(l: [-1, -2]) == [] as [Int])\nassert(get_positive(l: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_31","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է true, եթե տրված թիվը պարզ է, եւ false այլ կերպ: \/\/\/ >>> is_prime(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 101)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 11)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 61)\n\/\/\/ true\n\/\/\/ >>> is_prime(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_prime(n: 1)\n\/\/\/ false\nfunc is_prime(n: Int) -> Bool {\n","canonical_solution":"func is_prime(n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false\n    }\n    var i = 5\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_prime(n: 6) == false)\nassert(is_prime(n: 101) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 13441) == true)\nassert(is_prime(n: 61) == true)\nassert(is_prime(n: 4) == false)\nassert(is_prime(n: 1) == false)\nassert(is_prime(n: 5) == true)\nassert(is_prime(n: 11) == true)\nassert(is_prime(n: 17) == true)\nassert(is_prime(n: 85) == false)\nassert(is_prime(n: 77) == false)\nassert(is_prime(n: 255379) == false)"},{"task_id":"HumanEval_33","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ l-ի համապատասխան ցուցանիշների արժեքներին, բայց դասակարգված:\/\/ l' նույնական է l-ի հետ այն ցուցանիշներում, որոնք չեն բաժանվում երեքով, մինչդեռ նրա արժեքները այն ցուցանիշներում, որոնք բաժանվում են երեքով, հավասար են:\/\/ Այս ֆունկցիան վերցնում է l շարքը եւ վերադարձնում է l շարքը, որը\/\/\/ >>> sort_third(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])\n\/\/\/ [2, 6, 3, 4, 8, 9, 5]\nfunc sort_third(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_third(l: [Int]) -> [Int] {\n    \/\/ Collect indices and their values where index is divisible by 3\n    var divisibleByThreeValues: [(index: Int, value: Int)] = []\n    for (index, value) in l.enumerated() where index % 3 == 0 {\n        divisibleByThreeValues.append((index, value))\n    }\n    \n    \/\/ Sort the values that were at the indices divisible by 3\n    let sortedValues = divisibleByThreeValues.map { $0.value }.sorted()\n    \n    \/\/ Create a mutable copy of original array to modify\n    var result = l\n    \n    \/\/ Replace the sorted values back into their original indices\n    for (i, sortedValue) in sortedValues.enumerated() {\n        result[divisibleByThreeValues[i].index] = sortedValue\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5])\nassert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5])\nassert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5])\nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1])"},{"task_id":"HumanEval_34","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է դասավորված եզակի տարրեր զանգվածում\/\/\/ >>> unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [0, 2, 3, 5, 9, 123]\nfunc unique(l: [Int]) -> [Int] {\n","canonical_solution":"func unique(l: [Int]) -> [Int] {\n    return Array(Set(l)).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])"},{"task_id":"HumanEval_35","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է զանգվածի առավելագույն տարրը: \/\/\/ >>> max_element(l: [1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfunc max_element(l: [Int]) -> Int {\n","canonical_solution":"func max_element(l: [Int]) -> Int {\n    guard let max = l.max() else {\n        fatalError(\"Array should not be empty\")\n    }\n    return max\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_element(l: [1, 2, 3]) == 3)\nassert(max_element(l: [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124)"},{"task_id":"HumanEval_36","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է 7 թվանշանի թվանշանի թվաքանակը n-ից փոքր ամբողջ թվերի մեջ, որոնք բաժանվում են 11 կամ 13-ով: \/\/\/ >>> fizz_buzz(n: 50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(n: 78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(n: 79)\n\/\/\/ 3\nfunc fizz_buzz(n: Int) -> Int {\n","canonical_solution":"func fizz_buzz(n: Int) -> Int {\n    var count = 0\n    for number in 0..<n {\n        if number % 11 == 0 || number % 13 == 0 {\n            var current = number\n            while current > 0 {\n                if current % 10 == 7 {\n                    count += 1\n                }\n                current \/= 10\n            }\n        }\n    }\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fizz_buzz(n: 50) == 0)\nassert(fizz_buzz(n: 78) == 2)\nassert(fizz_buzz(n: 79) == 3)\nassert(fizz_buzz(n: 100) == 3)\nassert(fizz_buzz(n: 200) == 6)\nassert(fizz_buzz(n: 4000) == 192)\nassert(fizz_buzz(n: 10000) == 639)\nassert(fizz_buzz(n: 100000) == 8026)"},{"task_id":"HumanEval_37","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ l-ի զույգ ցուցանիշների արժեքներին, բայց դասակարգված: \/\/ l-ը նույնական է l-ի հետ տարօրինակ ցուցանիշներում, մինչդեռ նրա արժեքները հավասար են նույնիսկ ցուցանիշներում:\/\/ Այս ֆունկցիան վերցնում է l շարքը եւ վերադարձնում է l շարքը, որը\/\/\/ >>> sort_even(l: [1, 2, 3])\n\/\/\/ [1, 2, 3]\n\/\/\/ >>> sort_even(l: [5, 6, 3, 4])\n\/\/\/ [3, 6, 5, 4]\nfunc sort_even(l: [Int]) -> [Int] {\n","canonical_solution":"func sort_even(l: [Int]) -> [Int] {\n    var evenIndicesValues = [Int]()\n    \n    \/\/ Collect values from even indices\n    for (index, value) in l.enumerated() {\n        if index % 2 == 0 {\n            evenIndicesValues.append(value)\n        }\n    }\n    \n    \/\/ Sort the collected even indices values\n    evenIndicesValues.sort()\n    \n    var result = l\n    var evenIndex = 0\n    \n    \/\/ Replace even-indexed elements in result with sorted values\n    for i in 0..<result.count {\n        if i % 2 == 0 {\n            result[i] = evenIndicesValues[evenIndex]\n            evenIndex += 1\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_even(l: [1, 2, 3]) == [1, 2, 3])\nassert(sort_even(l: [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\nassert(sort_even(l: [5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])"},{"task_id":"HumanEval_39","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ prime_fib վերադարձնում է n-րդ թիվը, որը Ֆիբոնաչիի թիվ է եւ նաեւ պարզ թիվ է: \/\/\/ >>> prime_fib(n: 1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(n: 2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(n: 3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(n: 4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(n: 5)\n\/\/\/ 89\nfunc prime_fib(n: Int) -> Int {\n","canonical_solution":"func isPrime(_ num: Int) -> Bool {\n    if num <= 1 { return false }\n    if num <= 3 { return true }\n    if num % 2 == 0 || num % 3 == 0 { return false }\n    var i = 5\n    while i * i <= num {\n        if num % i == 0 || num % (i + 2) == 0 {\n            return false\n        }\n        i += 6\n    }\n    return true\n}\n\nfunc generateFibonacci(n: Int) -> [Int] {\n    var fibs = [1, 2]\n    var next = fibs[0] + fibs[1]\n    while fibs.count < n || !isPrime(next) {\n        fibs.append(next)\n        next = fibs[fibs.count - 1] + fibs[fibs.count - 2]\n    }\n    return fibs\n}\n\nfunc prime_fib(n: Int) -> Int {\n    var count = 0\n    var fibs = generateFibonacci(n: n)\n    for fib in fibs {\n        if isPrime(fib) {\n            count += 1\n            if count == n {\n                return fib\n            }\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_fib(n: 1) == 2)\nassert(prime_fib(n: 2) == 3)\nassert(prime_fib(n: 3) == 5)\nassert(prime_fib(n: 4) == 13)\nassert(prime_fib(n: 5) == 89)\nassert(prime_fib(n: 6) == 233)\nassert(prime_fib(n: 7) == 1597)\nassert(prime_fib(n: 8) == 28657)\nassert(prime_fib(n: 9) == 514229)\nassert(prime_fib(n: 10) == 433494437)"},{"task_id":"HumanEval_40","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ գումարածը զրոյից, եւ այլ դեպքում՝ սխալ:\/\/ true է վերադարձնում, եթե շարքում կա երեք տարբեր տարր, որոնք\/\/ triple_sum_to_zero-ն ընդունում է ամբողջ թվերի շարքը որպես մուտք:\/\/\/ >>> triples_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(l: [1])\n\/\/\/ false\nfunc triples_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func triples_sum_to_zero(l: [Int]) -> Bool {\n    let count = l.count\n    if count < 3 {\n        return false\n    }\n    \n    let sortedArray = l.sorted()\n    \n    for i in 0..<count - 2 {\n        var left = i + 1\n        var right = count - 1\n        \n        while left < right {\n            let currentSum = sortedArray[i] + sortedArray[left] + sortedArray[right]\n            if currentSum == 0 {\n                return true\n            } else if currentSum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triples_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, -2, 1]) == true)\nassert(triples_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(triples_sum_to_zero(l: [1, 2, 5, 7]) == false)\nassert(triples_sum_to_zero(l: [2, 4, -5, 3, 9, 7]) == true)\nassert(triples_sum_to_zero(l: [1]) == false)\nassert(triples_sum_to_zero(l: [1, 3, 5, -100]) == false)\nassert(triples_sum_to_zero(l: [100, 3, 5, -100]) == false)"},{"task_id":"HumanEval_41","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Այս ֆունկցիան արտահանում է նման բախումների թիվը: \/ \/ իրենց ուղեծրի մեջ, կարծես նրանք չեն բախվել: \/\/ Սակայն, մեքենաները անվերջ ամուր են եւ ուժեղ, արդյունքում, նրանք շարունակում են շարժվել \/\/\/ երբ ձախից աջ շարժվող մեքենան բախվում է աջից ձախ շարժվող մեքենային:Բոլոր մեքենաները շարժվում են նույն արագությամբ:\/մեկը աջից ձախ է գնում: \/ երկու մեքենաները սկսում են շատ հեռու լինել:\/\/ n մեքենաներ են շարժվում ձախից աջ, միաժամանակ, տարբեր n մեքենաների հավաքածու:Պատկերացրեք ճանապարհ, որը կատարյալ ուղիղ է, անվերջ երկար գիծ:func car_race_collision(n: Int) -> Int {\n","canonical_solution":"func car_race_collision(n: Int) -> Int {\n    return n\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(car_race_collision(n: 2) == 4)\nassert(car_race_collision(n: 3) == 9)\nassert(car_race_collision(n: 4) == 16)\nassert(car_race_collision(n: 8) == 64)\nassert(car_race_collision(n: 10) == 100)"},{"task_id":"HumanEval_42","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձում է զանգված, որի տարրերը ավելացվում են 1-ով:\/\/\/ >>> incr_list(l: [1, 2, 3])\n\/\/\/ [2, 3, 4]\n\/\/\/ >>> incr_list(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ [6, 4, 6, 3, 4, 4, 10, 1, 124]\nfunc incr_list(l: [Int]) -> [Int] {\n","canonical_solution":"func incr_list(l: [Int]) -> [Int] {\n    return l.map { $0 + 1 }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(incr_list(l: [] as [Int]) == [] as [Int])\nassert(incr_list(l: [3, 2, 1]) == [4, 3, 2])\nassert(incr_list(l: [5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124])"},{"task_id":"HumanEval_43","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ գումարածը զրոյից, եւ այլ դեպքում՝ սխալ:\/\/ true է վերադարձնում, եթե զանգվածում կան երկու տարբեր տարրեր, որոնք\/\/ pairs_sum_to_zero-ն ընդունում է ամբողջ թվերի շարքը որպես մուտք:\/\/\/ >>> pairs_sum_to_zero(l: [1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(l: [1])\n\/\/\/ false\nfunc pairs_sum_to_zero(l: [Int]) -> Bool {\n","canonical_solution":"func pairs_sum_to_zero(l: [Int]) -> Bool {\n    var set = Set<Int>()\n    for num in l {\n        if set.contains(-num) {\n            return true\n        }\n        set.insert(num)\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pairs_sum_to_zero(l: [1, 3, 5, 0]) == false)\nassert(pairs_sum_to_zero(l: [1, 3, -2, 1]) == false)\nassert(pairs_sum_to_zero(l: [1, 2, 3, 7]) == false)\nassert(pairs_sum_to_zero(l: [2, 4, -5, 3, 5, 7]) == true)\nassert(pairs_sum_to_zero(l: [1]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 30]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 3, 2, 31]) == true)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 30]) == false)\nassert(pairs_sum_to_zero(l: [-3, 9, -1, 4, 2, 31]) == false)"},{"task_id":"HumanEval_44","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ բազային թվերը 10-ից փոքր են: \/\/ Վերադարձում է տողերի ներկայացումը փոխարկումից հետո: \/\/ Փոխեք մուտքագրված x թվային բազան բազա:\/\/\/ >>> change_base(x: 8, base: 3)\n\/\/\/ \"22\"\n\/\/\/ >>> change_base(x: 8, base: 2)\n\/\/\/ \"1000\"\n\/\/\/ >>> change_base(x: 7, base: 2)\n\/\/\/ \"111\"\nfunc change_base(x: Int, base: Int) -> String {\n","canonical_solution":"func change_base(x: Int, base: Int) -> String {\n    guard base > 1 && base < 10 else {\n        return \"\"\n    }\n    \n    var number = x\n    var result = \"\"\n    \n    repeat {\n        let remainder = number % base\n        result = \"\\(remainder)\" + result\n        number \/= base\n    } while number > 0\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(change_base(x: 8, base: 3) == \"22\")\nassert(change_base(x: 9, base: 3) == \"100\")\nassert(change_base(x: 234, base: 2) == \"11101010\")\nassert(change_base(x: 16, base: 2) == \"10000\")\nassert(change_base(x: 8, base: 2) == \"1000\")\nassert(change_base(x: 7, base: 2) == \"111\")\nassert(change_base(x: 2, base: 3) == \"2\")\nassert(change_base(x: 3, base: 4) == \"3\")\nassert(change_base(x: 4, base: 5) == \"4\")\nassert(change_base(x: 5, base: 6) == \"5\")\nassert(change_base(x: 6, base: 7) == \"6\")\nassert(change_base(x: 7, base: 8) == \"7\")"},{"task_id":"HumanEval_45","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Տված երկարությունը կողմի եւ բարձր վերադարձի տարածքը եռանկյունի համար: \/\/\/ >>> triangle_area(a: 5, h: 3)\n\/\/\/ 7.5\nfunc triangle_area(a: Int, h: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, h: Int) -> Double {\n    return 0.5 * Double(a) * Double(h)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 5, h: 3) == 7.5)\nassert(triangle_area(a: 2, h: 2) == 2.0)\nassert(triangle_area(a: 10, h: 8) == 40.0)"},{"task_id":"HumanEval_46","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Խնդրում ենք գրել ֆունկցիա, որը արդյունավետորեն կվերահաշվարկի fib4 թվային հաջորդականության n-րդ տարրը: Մի օգտագործեք ռեկուրսիան: \/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \/\/ fib4(3) -> 0 \/\/ fib4(2) -> 2 \/\/ fib4(1) -> 0 \/\/ fib4(0) -> 0 \/\/ Fib4 թվային հաջորդականությունը նման է Ֆիբոնաչիի հաջորդականությանը, որը սահմանվում է հետեւյալ կերպ.\/\/\/ >>> fib4(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fib4(n: 6)\n\/\/\/ 8\n\/\/\/ >>> fib4(n: 7)\n\/\/\/ 14\nfunc fib4(n: Int) -> Int {\n","canonical_solution":"func fib4(n: Int) -> Int {\n    if n == 0 || n == 1 || n == 3 {\n        return 0\n    } else if n == 2 {\n        return 2\n    }\n    \n    var fibs = [0, 0, 2, 0]\n    \n    for i in 4...n {\n        let nextFib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]\n        fibs.append(nextFib)\n    }\n    \n    return fibs[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib4(n: 5) == 4)\nassert(fib4(n: 8) == 28)\nassert(fib4(n: 10) == 104)\nassert(fib4(n: 12) == 386)"},{"task_id":"HumanEval_47","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է զանգվածի տարրերի միջին թիվը l: \/\/\/ >>> median(l: [3, 1, 2, 4, 5])\n\/\/\/ 3\n\/\/\/ >>> median(l: [-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfunc median(l: [Int]) -> Double {\n","canonical_solution":"func median(l: [Int]) -> Double {\n    let sorted = l.sorted()\n    let count = sorted.count\n    if count % 2 == 0 {\n        return Double(sorted[count \/ 2 - 1] + sorted[count \/ 2]) \/ 2.0\n    } else {\n        return Double(sorted[count \/ 2])\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median(l: [3, 1, 2, 4, 5]) == 3)\nassert(median(l: [-10, 4, 6, 1000, 10, 20]) == 8.0)\nassert(median(l: [5]) == 5)\nassert(median(l: [6, 5]) == 5.5)\nassert(median(l: [8, 1, 3, 9, 9, 2, 7]) == 7)"},{"task_id":"HumanEval_48","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Ստուգում է, թե տվյալ տողը պալինդրոմ է \/\/\/ >>> is_palindrome(text: \"\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aba\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"aaaaa\")\n\/\/\/ true\n\/\/\/ >>> is_palindrome(text: \"zbcd\")\n\/\/\/ false\nfunc is_palindrome(text: String) -> Bool {\n","canonical_solution":"func is_palindrome(text: String) -> Bool {\n    return text == String(text.reversed())\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_palindrome(text: \"\") == true)\nassert(is_palindrome(text: \"aba\") == true)\nassert(is_palindrome(text: \"aaaaa\") == true)\nassert(is_palindrome(text: \"zbcd\") == false)\nassert(is_palindrome(text: \"xywyx\") == true)\nassert(is_palindrome(text: \"xywyz\") == false)\nassert(is_palindrome(text: \"xywzx\") == false)"},{"task_id":"HumanEval_49","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է 2^n մոդուլ p (հիշեք թվային արժեքները) ։\/\/\/ >>> modp(n: 3, p: 5)\n\/\/\/ 3\n\/\/\/ >>> modp(n: 1101, p: 101)\n\/\/\/ 2\n\/\/\/ >>> modp(n: 0, p: 101)\n\/\/\/ 1\n\/\/\/ >>> modp(n: 3, p: 11)\n\/\/\/ 8\n\/\/\/ >>> modp(n: 100, p: 101)\n\/\/\/ 1\nfunc modp(n: Int, p: Int) -> Int {\n","canonical_solution":"func modp(n: Int, p: Int) -> Int {\n    return Int(pow(2.0, Double(n)).truncatingRemainder(dividingBy: Double(p)))\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"},{"task_id":"HumanEval_51","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ remove_vowels ֆունկցիան ստանձնում է string եւ վերադարձնում string առանց վոկալների: \/\/\/ >>> remove_vowels(text: \"\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"abcdef\")\n\/\/\/ \"bcdf\"\n\/\/\/ >>> remove_vowels(text: \"aaaaa\")\n\/\/\/ \"\"\n\/\/\/ >>> remove_vowels(text: \"aaBAA\")\n\/\/\/ \"B\"\n\/\/\/ >>> remove_vowels(text: \"zbcd\")\n\/\/\/ \"zbcd\"\nfunc remove_vowels(text: String) -> String {\n","canonical_solution":"func remove_vowels(text: String) -> String {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return String(text.filter { !vowels.contains($0) })\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_vowels(text: \"\") == \"\")\nassert(remove_vowels(text: \"abcdef\\nghijklm\") == \"bcdf\\nghjklm\")\nassert(remove_vowels(text: \"fedcba\") == \"fdcb\")\nassert(remove_vowels(text: \"eeeee\") == \"\")\nassert(remove_vowels(text: \"acBAA\") == \"cB\")\nassert(remove_vowels(text: \"EcBOO\") == \"cB\")\nassert(remove_vowels(text: \"ybcd\") == \"ybcd\")"},{"task_id":"HumanEval_52","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է true, եթե l շարքի բոլոր թվերը t սահմանից ցածր են: \/\/\/ >>> below_threshold(l: [1, 2, 4, 10], t: 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(l: [1, 20, 4, 10], t: 5)\n\/\/\/ false\nfunc below_threshold(l: [Int], t: Int) -> Bool {\n","canonical_solution":"func below_threshold(l: [Int], t: Int) -> Bool {\n    for number in l {\n        if number >= t {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(below_threshold(l: [1, 2, 4, 10], t: 100) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 5) == false)\nassert(below_threshold(l: [1, 20, 4, 10], t: 21) == true)\nassert(below_threshold(l: [1, 20, 4, 10], t: 22) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 11) == true)\nassert(below_threshold(l: [1, 8, 4, 10], t: 10) == false)"},{"task_id":"HumanEval_53","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Բերեք երկու թվեր x եւ y \/\/\/ >>> add(x: 2, y: 3)\n\/\/\/ 5\n\/\/\/ >>> add(x: 5, y: 7)\n\/\/\/ 12\nfunc add(x: Int, y: Int) -> Int {\n","canonical_solution":"func add(x: Int, y: Int) -> Int {\n    return x + y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(x: 0, y: 1) == 1)\nassert(add(x: 1, y: 0) == 1)\nassert(add(x: 2, y: 3) == 5)\nassert(add(x: 5, y: 7) == 12)\nassert(add(x: 7, y: 5) == 12)"},{"task_id":"HumanEval_54","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Ստուգեք, թե արդյոք երկու բառերն ունեն նույնական նիշեր: \/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabc\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"dddddddabc\", s1: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> same_chars(s0: \"eabcd\", s1: \"dddddddabc\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"abcd\", s1: \"dddddddabce\")\n\/\/\/ false\n\/\/\/ >>> same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\")\n\/\/\/ false\nfunc same_chars(s0: String, s1: String) -> Bool {\n","canonical_solution":"func same_chars(s0: String, s1: String) -> Bool {\n    let set0 = Set(s0)\n    let set1 = Set(s1)\n    return set0 == set1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddeddabc\") == true)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabc\") == true)\nassert(same_chars(s0: \"dddddddabc\", s1: \"abcd\") == true)\nassert(same_chars(s0: \"eabcd\", s1: \"dddddddabc\") == false)\nassert(same_chars(s0: \"abcd\", s1: \"dddddddabcf\") == false)\nassert(same_chars(s0: \"eabcdzzzz\", s1: \"dddzzzzzzzddddabc\") == false)\nassert(same_chars(s0: \"aabb\", s1: \"aaccc\") == false)"},{"task_id":"HumanEval_55","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է n-րդ Ֆիբոնաչիի թիվը: \/\/\/ >>> fib(n: 10)\n\/\/\/ 55\n\/\/\/ >>> fib(n: 1)\n\/\/\/ 1\n\/\/\/ >>> fib(n: 8)\n\/\/\/ 21\nfunc fib(n: Int) -> Int {\n","canonical_solution":"func fib(n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    }\n    \n    var a = 0\n    var b = 1\n    for _ in 2...n {\n        let temp = a + b\n        a = b\n        b = temp\n    }\n    return b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fib(n: 10) == 55)\nassert(fib(n: 1) == 1)\nassert(fib(n: 8) == 21)\nassert(fib(n: 11) == 89)\nassert(fib(n: 12) == 144)"},{"task_id":"HumanEval_56","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ վերադարձնում է true, եթե յուրաքանչյուր բացման կոտրվածք ունի համապատասխան փակման կոտրվածք: \/\/ կոճակները \"<\" եւ \">\" շարքեր են:\/\/\/ >>> correct_bracketing(brackets: \"<\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"<>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"<<><>>\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"><<>\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    \n    for bracket in brackets {\n        if bracket == \"<\" {\n            balance += 1\n        } else if bracket == \">\" {\n            balance -= 1\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    \n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)"},{"task_id":"HumanEval_57","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձեք true, եթե շարքի տարրերը մոնոտոնորեն աճում կամ նվազում են:\/\/\/ >>> monotonic(l: [1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(l: [1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(l: [4, 1, 0, -10])\n\/\/\/ true\nfunc monotonic(l: [Int]) -> Bool {\n","canonical_solution":"func monotonic(l: [Int]) -> Bool {\n    guard l.count > 1 else {\n        return true\n    }\n    \n    var increasing = true\n    var decreasing = true\n    \n    for i in 1..<l.count {\n        if l[i] > l[i - 1] {\n            decreasing = false\n        } else if l[i] < l[i - 1] {\n            increasing = false\n        }\n    }\n    \n    return increasing || decreasing\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"},{"task_id":"HumanEval_58","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է երկու շարքերի դասավորված եզակի ընդհանուր տարրեր: \/\/\/ >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n\/\/\/ [1, 5, 653]\n\/\/\/ >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n\/\/\/ [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n","canonical_solution":"func common(l1: [Int], l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let commonElements = set1.intersection(set2)\n    return Array(commonElements).sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"},{"task_id":"HumanEval_59","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է n-ի ամենամեծ առաջնային գործոնը: Ենթադրենք, որ n > 1 եւ առաջնային չէ: \/\/\/ >>> largest_prime_factor(n: 13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(n: 2048)\n\/\/\/ 2\nfunc largest_prime_factor(n: Int) -> Int {\n","canonical_solution":"func largest_prime_factor(n: Int) -> Int {\n    var number = n\n    var divisor = 2\n    \n    while number > 1 {\n        if number % divisor == 0 {\n            number \/= divisor\n        } else {\n            divisor += 1\n        }\n    }\n    \n    return divisor\n}\n\n\/\/ Example usage:\n\/\/ print(largest_prime_factor(n: 13195)) \/\/ Output: 29\n\/\/ print(largest_prime_factor(n: 2048))  \/\/ Output: 2","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"},{"task_id":"HumanEval_60","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ sum_to_n ֆունկցիան գումարում է 1-ից n թվերը:\/\/\/ >>> sum_to_n(n: 30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(n: 100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(n: 5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(n: 10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(n: 1)\n\/\/\/ 1\nfunc sum_to_n(n: Int) -> Int {\n","canonical_solution":"func sum_to_n(n: Int) -> Int {\n    return (n * (n + 1)) \/ 2\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_to_n(n: 1) == 1)\nassert(sum_to_n(n: 6) == 21)\nassert(sum_to_n(n: 11) == 66)\nassert(sum_to_n(n: 30) == 465)\nassert(sum_to_n(n: 100) == 5050)"},{"task_id":"HumanEval_61","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ վերադարձնում է true, եթե յուրաքանչյուր բացման կոտրվածք ունի համապատասխան փակման կոտրվածք: \/\/ կոտորակները \"(\" եւ \"\") շարքեր են:\/\/\/ >>> correct_bracketing(brackets: \"(\")\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(brackets: \"()\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \"(()())\")\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(brackets: \")(()\")\n\/\/\/ false\nfunc correct_bracketing(brackets: String) -> Bool {\n","canonical_solution":"func correct_bracketing(brackets: String) -> Bool {\n    var balance = 0\n    for char in brackets {\n        if char == \"(\" {\n            balance += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"()\") == true)\nassert(correct_bracketing(brackets: \"(()())\") == true)\nassert(correct_bracketing(brackets: \"()()(()())()\") == true)\nassert(correct_bracketing(brackets: \"()()((()()())())(()()(()))\") == true)\nassert(correct_bracketing(brackets: \"((()())))\") == false)\nassert(correct_bracketing(brackets: \")(()\") == false)\nassert(correct_bracketing(brackets: \"(\") == false)\nassert(correct_bracketing(brackets: \"((((\") == false)\nassert(correct_bracketing(brackets: \")\") == false)\nassert(correct_bracketing(brackets: \"(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())())(()\") == false)\nassert(correct_bracketing(brackets: \"()()(()())()))()\") == false)"},{"task_id":"HumanEval_62","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձեք այս բազմանունի ածանցյալը նույն ձեւով: \/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/ x-ները բազմանունի գործակիցներն են:\/\/\/ >>> derivative(xs: [3, 1, 2, 4, 5])\n\/\/\/ [1, 4, 12, 20]\n\/\/\/ >>> derivative(xs: [1, 2, 3])\n\/\/\/ [2, 6]\nfunc derivative(xs: [Int]) -> [Int] {\n","canonical_solution":"func derivative(xs: [Int]) -> [Int] {\n    guard xs.count > 1 else { return [] }\n    var result: [Int] = []\n    for i in 1..<xs.count {\n        result.append(xs[i] * i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(derivative(xs: [3, 1, 2, 4, 5]) == [1, 4, 12, 20])\nassert(derivative(xs: [1, 2, 3]) == [2, 6])\nassert(derivative(xs: [3, 2, 1]) == [2, 2])\nassert(derivative(xs: [3, 2, 1, 0, 4]) == [2, 2, 0, 16])\nassert(derivative(xs: [1]) == [] as [Int])"},{"task_id":"HumanEval_63","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Խնդրում ենք գրել ֆունկցիա, որը կօգնի արդյունավետ հաշվարկել fib-ի n-րդ տարրը:\/\/ fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) ։\/\/ fib fib ((2) == 1 \/\/ fib fib ((1) == 0 \/\/ fib fib ((0) == 0 \/\/ FibFib թվային հաջորդականությունը նման է Ֆիբոնաչիի հաջորդականությանը, որը սահմանվում է հետեւյալ կերպ. \/\/\/ >>> fibfib(n: 1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(n: 5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(n: 8)\n\/\/\/ 24\nfunc fibfib(n: Int) -> Int {\n","canonical_solution":"func fibfib(n: Int) -> Int {\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    \n    var fibfibNums = [0, 0, 1]\n    \n    for i in 3...n {\n        let nextFibFib = fibfibNums[i - 1] + fibfibNums[i - 2] + fibfibNums[i - 3]\n        fibfibNums.append(nextFibFib)\n    }\n    \n    return fibfibNums[n]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fibfib(n: 2) == 1)\nassert(fibfib(n: 1) == 0)\nassert(fibfib(n: 5) == 4)\nassert(fibfib(n: 8) == 24)\nassert(fibfib(n: 10) == 81)\nassert(fibfib(n: 12) == 274)\nassert(fibfib(n: 14) == 927)"},{"task_id":"HumanEval_64","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ ձայնային, բայց միայն այն դեպքում, երբ այն տրված բառի վերջում է:\/\/ Այս դեպքում ձայնավորները 'a', 'e', 'i', 'o', 'u' են: Այստեղ 'y' -ը նույնպես 'a' է:\/\/ բառը որպես մուտք եւ վերադարձնում է տողում հնչող ձայնավորների թիվը:\/\/ Գրեք ֆունկցիա vowels_count, որը վերցնում է string ներկայացնելով \/\/\/ >>> vowels_count(s: \"abcde\")\n\/\/\/ 2\n\/\/\/ >>> vowels_count(s: \"ACEDY\")\n\/\/\/ 3\nfunc vowels_count(s: String) -> Int {\n","canonical_solution":"func vowels_count(s: String) -> Int {\n    guard !s.isEmpty else { return 0 }\n    \n    let vowels = Set(\"aeiouAEIOU\")\n    var count = 0\n    let characters = Array(s)\n    \n    for i in 0..<characters.count {\n        let char = characters[i]\n        \n        if vowels.contains(char) {\n            count += 1\n        } else if char == \"y\" || char == \"Y\" {\n            if i == characters.count - 1 {\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(vowels_count(s: \"abcde\") == 2)\nassert(vowels_count(s: \"Alone\") == 3)\nassert(vowels_count(s: \"key\") == 2)\nassert(vowels_count(s: \"bye\") == 1)\nassert(vowels_count(s: \"keY\") == 2)\nassert(vowels_count(s: \"bYe\") == 1)\nassert(vowels_count(s: \"ACEDY\") == 3)"},{"task_id":"HumanEval_65","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Եթե shift > թվանշանների թիվը, վերադարձի թվանշանները հակառակ ուղղությամբ: \/\/ եւ արդյունքը վերադարձնում է որպես տող: \/\/ Շրջանաձեւ տեղափոխեք x ամբողջ թվերի թվերը, տեղափոխեք թվերը աջով տեղափոխելով:\/\/\/ >>> circular_shift(x: 12, shift: 1)\n\/\/\/ \"21\"\n\/\/\/ >>> circular_shift(x: 12, shift: 2)\n\/\/\/ \"12\"\nfunc circular_shift(x: Int, shift: Int) -> String {\n","canonical_solution":"func circular_shift(x: Int, shift: Int) -> String {\n    let digits = Array(String(x))\n    let count = digits.count\n    \n    \/\/ If shift is greater than the number of digits, return the digits reversed\n    if shift >= count {\n        return String(digits.reversed())\n    }\n    \n    \/\/ Calculate the actual shift needed by using modulo operation\n    let actualShift = shift % count\n    \n    \/\/ Perform the circular shift to the right\n    let splitIndex = count - actualShift\n    let shiftedDigits = digits[splitIndex...] + digits[..<splitIndex]\n    \n    return String(shiftedDigits)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(circular_shift(x: 100, shift: 2) == \"001\")\nassert(circular_shift(x: 12, shift: 2) == \"12\")\nassert(circular_shift(x: 97, shift: 8) == \"79\")\nassert(circular_shift(x: 12, shift: 1) == \"21\")\nassert(circular_shift(x: 11, shift: 101) == \"11\")"},{"task_id":"HumanEval_66","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ ASCII կոդեր:\/\/ Գրեք ֆունկցիա, որը ստանձնում է տող որպես մուտք եւ վերադարձնում է միայն վերին տառերի գումարը ' \/\/ Գործառույթ \/\/\/ >>> digitSum(s: \"\")\n\/\/\/ 0\n\/\/\/ >>> digitSum(s: \"abAB\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"abcCd\")\n\/\/\/ 67\n\/\/\/ >>> digitSum(s: \"helloE\")\n\/\/\/ 69\n\/\/\/ >>> digitSum(s: \"woArBld\")\n\/\/\/ 131\n\/\/\/ >>> digitSum(s: \"aAaaaXa\")\n\/\/\/ 153\nfunc digitSum(s: String) -> Int {\n","canonical_solution":"func digitSum(s: String) -> Int {\n    var sum = 0\n    for character in s {\n        if character.isUppercase {\n            sum += Int(character.asciiValue ?? 0)\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digitSum(s: \"\") == 0)\nassert(digitSum(s: \"abAB\") == 131)\nassert(digitSum(s: \"abcCd\") == 67)\nassert(digitSum(s: \"helloE\") == 69)\nassert(digitSum(s: \"woArBld\") == 131)\nassert(digitSum(s: \"aAaaaXa\") == 153)\nassert(digitSum(s: \" How are yOu?\") == 151)\nassert(digitSum(s: \"You arE Very Smart\") == 327)"},{"task_id":"HumanEval_67","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ համար examble: \/\/ in the basket վերադարձնում է մանգոյի պտուղների թիվը:\/\/ նարնջերը եւ խնձորները եւ ամբողջական թիվը, որը ներկայացնում է պտուղների ընդհանուր թիվը:\/\/ խնձոր, նարնջ եւ մանգո պտուղներ: Տվյալ է այն տողը, որը ներկայացնում է \/\/ որոնք բաշխվում են մրգերի զամբյուղում, որը պարունակում է այս զամբյուղը:\/\/ Այս առաջադրանքում ձեզ տրվում է մի շղթա, որը ներկայացնում է խնձորների եւ նարնջի մի շարք:\/\/\/ >>> fruit_distribution(s: \"5 apples and 6 oranges\", n: 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(s: \"0 apples and 1 oranges\", n: 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(s: \"2 apples and 3 oranges\", n: 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(s: \"100 apples and 1 oranges\", n: 120)\n\/\/\/ 19\nfunc fruit_distribution(s: String, n: Int) -> Int {\n","canonical_solution":"func fruit_distribution(s: String, n: Int) -> Int {\n    let components = s.components(separatedBy: \" \")\n    var apples = 0\n    var oranges = 0\n    \n    for (index, component) in components.enumerated() {\n        if component == \"apples\" || component == \"apple\" {\n            if let number = Int(components[index - 1]) {\n                apples = number\n            }\n        } else if component == \"oranges\" || component == \"orange\" {\n            if let number = Int(components[index - 1]) {\n                oranges = number\n            }\n        }\n    }\n    \n    let totalApplesOranges = apples + oranges\n    let mangoes = n - totalApplesOranges\n    return mangoes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 19) == 8)\nassert(fruit_distribution(s: \"5 apples and 6 oranges\", n: 21) == 10)\nassert(fruit_distribution(s: \"0 apples and 1 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"1 apples and 0 oranges\", n: 3) == 2)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 100) == 95)\nassert(fruit_distribution(s: \"2 apples and 3 oranges\", n: 5) == 0)\nassert(fruit_distribution(s: \"1 apples and 100 oranges\", n: 120) == 19)"},{"task_id":"HumanEval_68","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ 1: \/\/ Եթե չույտ արժեքներ չկան կամ տրված շարքը դատարկ է, վերադարձեք []-ը: \/\/ Հավաքված հանգույցը պետք է վերադարձվի զանգվածում, [ smalest_value, իր ինդեքսը ], \/\/ Եթե նույն փոքրագույն զույգ արժեքով բազմաթիվ հանգույցներ են հայտնաբերվում, վերադարձնում ենք այն հանգույցը, որն ունի ամենափոքր ինդեքսը: \/\/ Հավաքված հանգույցը պետք է լինի ամենափոքր զույգ արժեք ունեցող հանգույցը: \/\/ Ձեր խնդիրն է վերցնել հանգույցներից մեկը եւ վերադարձնել այն: \/\/ \"Տվյալ է մի զանգված, որը ներկայացնում է ծառի ճյուղ, որը ունի ոչ բացասական ամբողջ թվերի հանգույցներ:\/\/\/ >>> pluck(arr: [4, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(arr: [1, 2, 3])\n\/\/\/ [2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(arr: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\/\/\/ [0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfunc pluck(arr: [Int]) -> [Int] {\n","canonical_solution":"func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue: Int? = nil\n    var smallestIndex: Int? = nil\n\n    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n            if smallestEvenValue == nil || value < smallestEvenValue! || (value == smallestEvenValue! && index < smallestIndex!) {\n                smallestEvenValue = value\n                smallestIndex = index\n            }\n        }\n    }\n\n    if let smallestEvenValue = smallestEvenValue, let smallestIndex = smallestIndex {\n        return [smallestEvenValue, smallestIndex]\n    } else {\n        return []\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"},{"task_id":"HumanEval_69","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Եթե նման արժեք գոյություն չունի, վերադարձնում է -1. \/\/ Ամբողջ թվերի հաճախականությունը այն թվերն են, որոնք հայտնվում են զանգվածում:\/\/ զրոյական է եւ ունի հաճախականություն, որը մեծ է կամ հավասար է ամբողջ թվերի արժեքին: \/\/ Ձեզ տրված է դրական ամբողջ թվերի ոչ դատարկ շարք: Վերադարձեք ամենամեծ ամբողջ թիվը, որը մեծ է -ից:\/\/\/ >>> search(lst: [4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(lst: [1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(lst: [5, 5, 4, 4, 4])\n\/\/\/ -1\nfunc search(lst: [Int]) -> Int {\n","canonical_solution":"func search(lst: [Int]) -> Int {\n    var frequencyMap = [Int: Int]()\n    \n    \/\/ Count frequencies of each number in the list\n    for number in lst {\n        frequencyMap[number, default: 0] += 1\n    }\n    \n    var result = -1\n    \n    \/\/ Iterate through the frequency map to find the greatest integer that satisfies the condition\n    for (number, frequency) in frequencyMap {\n        if frequency >= number {\n            result = max(result, number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(lst: [5, 5, 5, 5, 1]) == 1)\nassert(search(lst: [4, 1, 4, 1, 4, 4]) == 4)\nassert(search(lst: [3, 3]) == -1)\nassert(search(lst: [8, 8, 8, 8, 8, 8, 8, 8]) == 8)\nassert(search(lst: [2, 3, 3, 2, 2]) == 2)\nassert(search(lst: [2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1)\nassert(search(lst: [3, 2, 8, 2]) == 2)\nassert(search(lst: [6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1)\nassert(search(lst: [8, 8, 3, 6, 5, 6, 4]) == -1)\nassert(search(lst: [6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1)\nassert(search(lst: [1, 9, 10, 1, 3]) == 1)\nassert(search(lst: [6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5)\nassert(search(lst: [1]) == 1)\nassert(search(lst: [8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4)\nassert(search(lst: [2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2)\nassert(search(lst: [1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1)\nassert(search(lst: [9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4)\nassert(search(lst: [2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4)\nassert(search(lst: [9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2)\nassert(search(lst: [5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1)\nassert(search(lst: [10]) == -1)\nassert(search(lst: [9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2)\nassert(search(lst: [5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1)\nassert(search(lst: [7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1)\nassert(search(lst: [3, 10, 10, 9, 2]) == -1)"},{"task_id":"HumanEval_70","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ ապա մնացած ամբողջ թվերի առավելագույնը, ապա նվազագույնը եւ այլն: \/\/ տարօրինակ դասակարգումը, երբ սկսում եք նվազագույն արժեքից, \/\/ Տված ամբողջ թվերի շարքը, վերադարձնում է շարքը տարօրինակ կարգով:\/\/\/ >>> strange_sort_list(lst: [1, 2, 3, 4])\n\/\/\/ [1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(lst: [5, 5, 5, 5])\n\/\/\/ [5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(lst: [] as [Int])\n\/\/\/ [] as [Int]\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n","canonical_solution":"func strange_sort_list(lst: [Int]) -> [Int] {\n    var sortedList = lst.sorted()\n    var result: [Int] = []\n    \n    while !sortedList.isEmpty {\n        if let min = sortedList.first {\n            result.append(min)\n            sortedList.removeFirst()\n        }\n        \n        if let max = sortedList.last {\n            result.append(max)\n            sortedList.removeLast()\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"},{"task_id":"HumanEval_71","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ քան երրորդ կողմը: \/\/ Երեք կողմերը եռանկյուն են, երբ ցանկացած երկու կողմերի գումարն ավելի մեծ է:\/\/ Հակառակ դեպքում վերադարձնում է -1 \/\/ եռանկյունը կլորացված է 2 տասնորդական կետով, եթե երեք կողմերը կազմում են վավեր եռանկյուն: \/\/ Տված են եռանկյան երեք կողմերի երկարությունները: Վերադարձեք -ի մակերեսը:\/\/\/ >>> triangle_area(a: 3, b: 4, c: 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(a: 1, b: 2, c: 10)\n\/\/\/ -1\nfunc triangle_area(a: Int, b: Int, c: Int) -> Double {\n","canonical_solution":"func triangle_area(a: Int, b: Int, c: Int) -> Double {\n    \/\/ Check if the sides form a valid triangle\n    if a + b > c && a + c > b && b + c > a {\n        \/\/ Calculate the semi-perimeter\n        let s = Double(a + b + c) \/ 2.0\n        \/\/ Calculate the area using Heron's formula\n        let area = sqrt(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)))\n        \/\/ Round to 2 decimal places\n        return round(area * 100) \/ 100\n    } else {\n        return -1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(a: 3, b: 4, c: 5) == 6.0)\nassert(triangle_area(a: 1, b: 2, c: 10) == -1)\nassert(triangle_area(a: 4, b: 8, c: 5) == 8.18)\nassert(triangle_area(a: 2, b: 2, c: 2) == 1.73)\nassert(triangle_area(a: 1, b: 2, c: 3) == -1)\nassert(triangle_area(a: 10, b: 5, c: 7) == 16.25)\nassert(triangle_area(a: 2, b: 6, c: 3) == -1)\nassert(triangle_area(a: 1, b: 1, c: 1) == 0.43)\nassert(triangle_area(a: 2, b: 2, c: 10) == -1)"},{"task_id":"HumanEval_72","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ Q օբյեկտը կթռչի, եթե հավասարակշռված է (դա պալինդրոմային շարք է) եւ դրա տարրերի գումարը փոքր է կամ հավասար է հնարավոր առավելագույն քաշի w-ին:\/\/ Գրեք ֆունկցիա, որը true կվերադարձնի, եթե q օբյեկտը թռչում է, եւ false այլ կերպ:\/\/\/ >>> will_it_fly(q: [1, 2], w: 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(q: [3, 2, 3], w: 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(q: [3], w: 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int], w: Int) -> Bool {\n","canonical_solution":"func will_it_fly(q: [Int], w: Int) -> Bool {\n    func isPalindromic(_ array: [Int]) -> Bool {\n        return array == array.reversed()\n    }\n    \n    let sum = q.reduce(0, +)\n    return isPalindromic(q) && sum <= w\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"},{"task_id":"HumanEval_73","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ նույնն է կարդում առաջ եւ ետ: Մեկ փոփոխության ընթացքում դուք կարող եք փոխել մեկ տարրը ցանկացած այլ տարրով:\/\/ պետք է փոխվի, որպեսզի շարքը պալինդրոմ լինի: Պալինդրոմ շարքը այն շարքն է, որը\/\/ Տված ամբողջ թվերի շարքը, գտեք տարրերի նվազագույն թիվը, որ \/\/\/ >>> smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(arr: [1, 2, 3, 2, 1])\n\/\/\/ 0\nfunc smallest_change(arr: [Int]) -> Int {\n","canonical_solution":"func smallest_change(arr: [Int]) -> Int {\n    var changes = 0\n    let n = arr.count\n\n    for i in 0..<(n \/ 2) {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1\n        }\n    }\n\n    return changes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(smallest_change(arr: [1, 2, 3, 5, 4, 7, 9, 6]) == 4)\nassert(smallest_change(arr: [1, 2, 3, 4, 3, 2, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 4, 4, 2]) == 1)\nassert(smallest_change(arr: [1, 2, 3, 2, 1]) == 0)\nassert(smallest_change(arr: [3, 1, 1, 3]) == 0)\nassert(smallest_change(arr: [1]) == 0)\nassert(smallest_change(arr: [0, 1]) == 1)"},{"task_id":"HumanEval_74","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ \/\/ եթե երկու շարքերը ունեն նույն թվով տառեր, վերադարձնում ենք առաջին շարքը:\/\/ բոլոր թվերի թվերի թվերի ընդհանուր թիվը, որը պակաս է մյուս թվից:\/\/ Գրեք ֆունկցիա, որը ընդունում է երկու շարք եւ վերադարձնում այն շարքը, որը ունի \/\/\/ >>> total_match(lst1: [] as [String], lst2: [] as [String])\n\/\/\/ [] as [String]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"])\n\/\/\/ [\"hI\", \"Hi\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"])\n\/\/\/ [\"hi\", \"admin\"]\n\/\/\/ >>> total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"])\n\/\/\/ [\"hI\", \"hi\", \"hi\"]\n\/\/\/ >>> total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\/\/\/ [\"4\"]\nfunc total_match(lst1: [String], lst2: [String]) -> [String] {\n","canonical_solution":"func total_match(lst1: [String], lst2: [String]) -> [String] {\n    let totalChars1 = lst1.reduce(0) { $0 + $1.count }\n    let totalChars2 = lst2.reduce(0) { $0 + $1.count }\n    \n    if totalChars1 < totalChars2 {\n        return lst1\n    } else if totalChars2 < totalChars1 {\n        return lst2\n    } else {\n        return lst1\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(total_match(lst1: [] as [String], lst2: [] as [String]) == [] as [String])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\"]) == [\"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hi\", \"hi\", \"admin\", \"project\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [\"4\"], lst2: [\"1\", \"2\", \"3\", \"4\", \"5\"]) == [\"4\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"Hi\"]) == [\"hI\", \"Hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hi\"]) == [\"hI\", \"hi\", \"hi\"])\nassert(total_match(lst1: [\"hi\", \"admin\"], lst2: [\"hI\", \"hi\", \"hii\"]) == [\"hi\", \"admin\"])\nassert(total_match(lst1: [] as [String], lst2: [\"this\"]) == [] as [String])\nassert(total_match(lst1: [\"this\"], lst2: [] as [String]) == [] as [String])"},{"task_id":"HumanEval_75","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ Գիտելով, որ (a) -ը 100-ից փոքր է: \/\/ եւ այլն սխալ է: \/\/ Գրեք ֆունկցիա, որը կվերադառնա true, եթե տրված թիվը 3 պարզ թվերի բազմապատկումն է:\/\/\/ >>> is_multiply_prime(a: 30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a: Int) -> Bool {\n","canonical_solution":"func is_multiply_prime(a: Int) -> Bool {\n    \/\/ Function to check if a number is prime\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Generate all prime numbers less than 100\n    var primes = [Int]()\n    for i in 2..<100 {\n        if isPrime(i) {\n            primes.append(i)\n        }\n    }\n    \n    \/\/ Check combinations of 3 primes\n    let primeCount = primes.count\n    for i in 0..<primeCount {\n        for j in i..<primeCount {\n            for k in j..<primeCount {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_multiply_prime(a: 5) == false)\nassert(is_multiply_prime(a: 30) == true)\nassert(is_multiply_prime(a: 8) == true)\nassert(is_multiply_prime(a: 10) == false)\nassert(is_multiply_prime(a: 125) == true)\nassert(is_multiply_prime(a: 105) == true)\nassert(is_multiply_prime(a: 126) == false)\nassert(is_multiply_prime(a: 729) == false)\nassert(is_multiply_prime(a: 891) == false)\nassert(is_multiply_prime(a: 1001) == true)"},{"task_id":"HumanEval_76","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ x-ը n-ի պարզ հզորություն է, եթե n**int=x \/\/ n-ի ուժգնությունը եւ այլ դեպքերում՝ սխալ:\/\/ Ձեր խնդիրն է գրել ֆունկցիա, որը կվերադառնա true, եթե x թիվը պարզ է:\/\/\/ >>> is_simple_power(x: 1, n: 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 2, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 8, n: 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(x: 3, n: 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 3, n: 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(x: 5, n: 3)\n\/\/\/ false\nfunc is_simple_power(x: Int, n: Int) -> Bool {\n","canonical_solution":"func is_simple_power(x: Int, n: Int) -> Bool {\n    if x < 1 || n < 1 {\n        return false\n    }\n    if x == 1 {\n        return true \/\/ n**0 = 1\n    }\n    var power = 1\n    while power < x {\n        power *= n\n    }\n    return power == x\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_simple_power(x: 16, n: 2) == true)\nassert(is_simple_power(x: 143214, n: 16) == false)\nassert(is_simple_power(x: 4, n: 2) == true)\nassert(is_simple_power(x: 9, n: 3) == true)\nassert(is_simple_power(x: 16, n: 4) == true)\nassert(is_simple_power(x: 24, n: 2) == false)\nassert(is_simple_power(x: 128, n: 4) == false)\nassert(is_simple_power(x: 12, n: 6) == false)\nassert(is_simple_power(x: 1, n: 1) == true)\nassert(is_simple_power(x: 1, n: 12) == true)"},{"task_id":"HumanEval_77","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Նշում. դուք կարող եք ենթադրել, որ մուտքագրումը միշտ վավեր է: \/\/ եթե այս ինգերը մի ամբողջ թվերի խորանարդ է: \/\/ Գրեք ֆունկցիա, որը ընդունում է ամբողջ թիվ a եւ վերադարձնում է true:\/\/\/ >>> iscube(a: 1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 2)\n\/\/\/ false\n\/\/\/ >>> iscube(a: -1)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 64)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 0)\n\/\/\/ true\n\/\/\/ >>> iscube(a: 180)\n\/\/\/ false\nfunc iscube(a: Int) -> Bool {\n","canonical_solution":"func iscube(a: Int) -> Bool {\n    if a == 0 { return true } \/\/ 0 is a cube (0^3)\n    let absA = abs(a)\n    let cubeRoot = Int(round(pow(Double(absA), 1.0\/3.0)))\n    return cubeRoot * cubeRoot * cubeRoot == absA\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(iscube(a: 1) == true)\nassert(iscube(a: 2) == false)\nassert(iscube(a: -1) == true)\nassert(iscube(a: 64) == true)\nassert(iscube(a: 180) == false)\nassert(iscube(a: 1000) == true)\nassert(iscube(a: 0) == true)\nassert(iscube(a: 1729) == false)"},{"task_id":"HumanEval_78","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ եւ A,B,C,D,E,F սիմվոլները միշտ մեծատառերով են: \/\/ Նշում. դուք կարող եք ենթադրել, որ մուտքագրումը միշտ ճիշտ է կամ դատարկ տող, B (= տասնորդական 11), D (= տասնորդական 13)\/\/ Այսպիսով, դուք պետք է որոշեք հետեւյալ թվերից մեկը. 2, 3, 5, 7, \/\/ Առաջնային թվերը 2, 3, 5, 7, 11, 13, 17... են:\/\/ Հեքսադեզիմալ թվանշանները 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F են: \/\/ ավելի մեծ է, քան 1, որը երկու փոքր բնական թվերի բազմապատկ չէ) ։\/\/ թվեր, որոնք պարզ թվեր են (հասարակ թիվը կամ պարզ թիվը բնական թիվ է)\/\/ վեցանասական թվերը որպես տող եւ հաշվում է վեցանասական թվերի քանակը:\/\/ Ձեզ հանձնարարվել է գրել ֆունկցիա, որը ստանում է \/\/\/ >>> hex_key(num: \"AB\")\n\/\/\/ 1\n\/\/\/ >>> hex_key(num: \"1077E\")\n\/\/\/ 2\n\/\/\/ >>> hex_key(num: \"ABED1A33\")\n\/\/\/ 4\n\/\/\/ >>> hex_key(num: \"123456789ABCDEF0\")\n\/\/\/ 6\n\/\/\/ >>> hex_key(num: \"2020\")\n\/\/\/ 2\nfunc hex_key(num: String) -> Int {\n","canonical_solution":"func hex_key(num: String) -> Int {\n    \/\/ Define hexadecimal digits that are prime numbers\n    let primeHexDigits: Set<Character> = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    \n    \/\/ Initialize count\n    var primeCount = 0\n    \n    \/\/ Iterate over each character in the string\n    for char in num {\n        \/\/ Check if the character is a prime hexadecimal digit\n        if primeHexDigits.contains(char) {\n            primeCount += 1\n        }\n    }\n    \n    return primeCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(hex_key(num: \"AB\") == 1)\nassert(hex_key(num: \"1077E\") == 2)\nassert(hex_key(num: \"ABED1A33\") == 4)\nassert(hex_key(num: \"2020\") == 2)\nassert(hex_key(num: \"123456789ABCDEF0\") == 6)\nassert(hex_key(num: \"112233445566778899AABBCCDDEEFF00\") == 12)"},{"task_id":"HumanEval_79","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Լրացուցիչ նիշերը նախատեսված են ձեւաչափի համար: \/\/ Կլինի ավելորդ երկու նիշ 'db' տողի սկզբում եւ վերջում: \/\/ թիվ: Շղթայի յուրաքանչյուր նիշ կլինի '0' կամ '1':\/\/ երկակի ձեւաչափ: Ֆունկցիան պետք է վերադարձնի տող, որտեղ յուրաքանչյուր նիշ ներկայացնում է երկակի \/\/ Ձեզ տրվում է տասնորդական թվեր եւ ձեր խնդիրն է փոխարկել դրանք \/\/\/ >>> decimal_to_binary(decimal: 15)\n\/\/\/ \"db1111db\"\n\/\/\/ >>> decimal_to_binary(decimal: 32)\n\/\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal: Int) -> String {\n","canonical_solution":"func decimal_to_binary(decimal: Int) -> String {\n    let binaryString = String(decimal, radix: 2)\n    return \"db\" + binaryString + \"db\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(decimal_to_binary(decimal: 0) == \"db0db\")\nassert(decimal_to_binary(decimal: 32) == \"db100000db\")\nassert(decimal_to_binary(decimal: 103) == \"db1100111db\")\nassert(decimal_to_binary(decimal: 15) == \"db1111db\")"},{"task_id":"HumanEval_80","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Հասքային է, եթե նրա երկարությունը առնվազն 3 է, եւ յուրաքանչյուր հաջորդական 3 տառ տարբեր է:\/\/ Ձեր խնդիրն է ստուգել, թե արդյոք տողը hapswift է, թե ոչ: \/\/ Ձեզ տրվում է string s. \/\/\/ >>> is_happy(s: \"a\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"aa\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"abcd\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"aabb\")\n\/\/\/ false\n\/\/\/ >>> is_happy(s: \"adb\")\n\/\/\/ true\n\/\/\/ >>> is_happy(s: \"xyy\")\n\/\/\/ false\nfunc is_happy(s: String) -> Bool {\n","canonical_solution":"func is_happy(s: String) -> Bool {\n    let characters = Array(s)\n    if characters.count < 3 {\n        return false\n    }\n    \n    for i in 0..<(characters.count - 2) {\n        if characters[i] == characters[i + 1] || characters[i] == characters[i + 2] || characters[i + 1] == characters[i + 2] {\n            return false\n        }\n    }\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s: \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\") == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\") == false)"},{"task_id":"HumanEval_81","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ 0.0 E \/\/ > 0.0 D- \/\/ > 0,7 Դ \/\/ > 1,0 Դ+ \/\/ > 1.3 C- \/\/ > 1,7 C \/\/ > 2.0 C+ \/\/ > 2.3 Բ- \/\/ > 2.7 Բ \/\/ > 3.0 Բ+ \/ > 3.3 Ա- \/\/ > 3.7 Ա \/\/ 4.0 A+ \/ GPA: \/ Բառերի գնահատական:\/\/ ֆունկցիա, որը կարող է արտադառնալ տառերի դասակարգման զանգված՝ օգտագործելով հետեւյալ աղյուսակը: \/ Նա ձեզ տվել է մի շարք GPAs որոշ ուսանողների համար եւ դուք պետք է գրեք \/\/ Միակ խնդիրը այն է, որ նա կորցրել է կոդը, որով նա գնահատում էր: \/\/\/ աշակերտներին: Ուսուցիչը ստեղծում է գնահատման սեփական ալգորիթմը:\/\/ Սա սեմեստերի վերջին շաբաթն է եւ ուսուցիչը պետք է գնահատականներ տա:\/\/\/ >>> numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5])\n\/\/\/ [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\nfunc numerical_letter_grade(grades: [Double]) -> [String] {\n","canonical_solution":"func numerical_letter_grade(grades: [Double]) -> [String] {\n    return grades.map { gpa in\n        switch gpa {\n        case 4.0:\n            return \"A+\"\n        case 3.7...4.0:\n            return \"A\"\n        case 3.3..<3.7:\n            return \"A-\"\n        case 3.0..<3.3:\n            return \"B+\"\n        case 2.7..<3.0:\n            return \"B\"\n        case 2.3..<2.7:\n            return \"B-\"\n        case 2.0..<2.3:\n            return \"C+\"\n        case 1.7..<2.0:\n            return \"C\"\n        case 1.3..<1.7:\n            return \"C-\"\n        case 1.0..<1.3:\n            return \"D+\"\n        case 0.7..<1.0:\n            return \"D\"\n        case 0.0..<0.7:\n            return \"D-\"\n        default:\n            return \"E\"\n        }\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(numerical_letter_grade(grades: [4.0, 3, 1.7, 2, 3.5]) == [\"A+\", \"B\", \"C-\", \"C\", \"A-\"])\nassert(numerical_letter_grade(grades: [1.2]) == [\"D+\"])\nassert(numerical_letter_grade(grades: [0.5]) == [\"D-\"])\nassert(numerical_letter_grade(grades: [0.0]) == [\"E\"])\nassert(numerical_letter_grade(grades: [1.0, 0.3, 1.5, 2.8, 3.3]) == [\"D\", \"D-\", \"C-\", \"B\", \"B+\"])\nassert(numerical_letter_grade(grades: [0.0, 0.7]) == [\"E\", \"D-\"])"},{"task_id":"HumanEval_82","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ \/\/ երկարությունը պարզ թիվ է կամ այլ կերպ սխալ է:\/\/ Գրեք ֆունկցիա, որը վերցնում է տող եւ true է վերադարձնում, եթե տողը \/\/\/ >>> prime_length(string: \"Hello\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"abcdcba\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"kittens\")\n\/\/\/ true\n\/\/\/ >>> prime_length(string: \"orange\")\n\/\/\/ false\nfunc prime_length(string: String) -> Bool {\n","canonical_solution":"func prime_length(string: String) -> Bool {\n    let length = string.count\n    \n    guard length > 1 else {\n        return false\n    }\n    \n    for i in 2..<length {\n        if length % i == 0 {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_length(string: \"Hello\") == true)\nassert(prime_length(string: \"abcdcba\") == true)\nassert(prime_length(string: \"kittens\") == true)\nassert(prime_length(string: \"orange\") == false)\nassert(prime_length(string: \"wow\") == true)\nassert(prime_length(string: \"world\") == true)\nassert(prime_length(string: \"MadaM\") == true)\nassert(prime_length(string: \"Wow\") == true)\nassert(prime_length(string: \"\") == false)\nassert(prime_length(string: \"HI\") == true)\nassert(prime_length(string: \"go\") == true)\nassert(prime_length(string: \"gogo\") == false)\nassert(prime_length(string: \"aaaaaaaaaaaaaaa\") == false)\nassert(prime_length(string: \"Madam\") == true)\nassert(prime_length(string: \"M\") == false)\nassert(prime_length(string: \"0\") == false)"},{"task_id":"HumanEval_83","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ դրական ամբողջ թվեր, որոնք սկսվում կամ ավարտվում են 1-ով: \/\/ Նշված է դրական ամբողջ թիվ n, վերադարձնել n-համարի թվերի քանակը:func starts_one_ends(n: Int) -> Int {\n","canonical_solution":"func starts_one_ends(n: Int) -> Int {\n    if n == 1 {\n        \/\/ For a 1-digit number, it can be either starting or ending with 1, which is just the number 1.\n        return 1\n    }\n    \n    \/\/ Count of n-digit numbers starting with 1:\n    \/\/ First digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9.\n    let startWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Count of n-digit numbers ending with 1:\n    \/\/ Last digit is fixed as 1 and the rest (n-1) digits can be any digit from 0-9, but cannot be zero at the first place.\n    \/\/ So these are (n-1) digit numbers that can be from 10^(n-1) to (10^n - 1), of which we need the count.\n    let endWithOne = Int(pow(10.0, Double(n - 1)))\n    \n    \/\/ Intersection of both sets is the numbers starting and ending with 1\n    \/\/ which are of the form `1` followed by (n-2) digits and `1`, so:\n    let startAndEndWithOne = Int(pow(10.0, Double(n - 2)))\n    \n    return startWithOne + endWithOne - startAndEndWithOne\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n: 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4) == 1800)\nassert(starts_one_ends(n: 5) == 18000)"},{"task_id":"HumanEval_84","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ \/\/ Նշված է դրական ամբողջ թիվ N, վերադարձնել է իր թվանշանների ընդհանուր գումարը երկակի թվով: \/\/\/ >>> solve(N: 1000)\n\/\/\/ \"1\"\n\/\/\/ >>> solve(N: 150)\n\/\/\/ \"110\"\n\/\/\/ >>> solve(N: 147)\n\/\/\/ \"1100\"\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfunc solve(N: Int) -> String {\n","canonical_solution":"func solve(N: Int) -> String {\n    let sumOfDigits = String(N).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    return String(sumOfDigits, radix: 2)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(N: 1000) == \"1\")\nassert(solve(N: 150) == \"110\")\nassert(solve(N: 147) == \"1100\")\nassert(solve(N: 333) == \"1001\")\nassert(solve(N: 963) == \"10010\")"},{"task_id":"HumanEval_85","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Տված է ոչ դատարկ ամբողջ թվերի շարք lst. ավելացնել զույգ տարրերը, որոնք զույգ ցուցանիշներ են ... \/\/\/ >>> add(lst: [4, 2, 6, 7])\n\/\/\/ 2\nfunc add(lst: [Int]) -> Int {\n","canonical_solution":"func add(lst: [Int]) -> Int {\n    var sum = 0\n    for i in stride(from: 1, to: lst.count, by: 2) {\n        if lst[i] % 2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add(lst: [4, 88]) == 88)\nassert(add(lst: [4, 5, 6, 7, 2, 122]) == 122)\nassert(add(lst: [4, 0, 6, 7]) == 0)\nassert(add(lst: [4, 4, 6, 8]) == 12)"},{"task_id":"HumanEval_86","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Նշում. Դուք պետք է պահպանեք բառերի եւ դատարկ տարածությունների կարգը նախադասության մեջ:\/\/ աճող կարգը հիմնված է ASCII արժեքի վրա:\/\/ փոխարինվում են նոր բառով, որտեղ բոլոր նիշերը դասավորված են \/\/ String-ի կարգավորված տարբերակը, այն տողն է, որտեղ բոլոր բառերը (տարբերվում են տարածությամբ)\/\/ Գրեք ֆունկցիա, որը վերցնում է տող եւ վերադարձնում դրա կարգավորված տարբերակը: \/\/\/ >>> anti_shuffle(s: \"Hi\")\n\/\/\/ \"Hi\"\n\/\/\/ >>> anti_shuffle(s: \"hello\")\n\/\/\/ \"ehllo\"\n\/\/\/ >>> anti_shuffle(s: \"Hello World!!!\")\n\/\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s: String) -> String {\n","canonical_solution":"func anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy: .whitespaces)\n    let orderedWords = words.map { String($0.sorted()) }\n    var result = \"\"\n    var wordIndex = 0\n    \n    for character in s {\n        if character.isWhitespace {\n            result.append(character)\n        } else if wordIndex < orderedWords.count {\n            if let currentWord = orderedWords[wordIndex].first {\n                result.append(currentWord)\n                orderedWords[wordIndex].remove(at: orderedWords[wordIndex].startIndex)\n            }\n        }\n        \n        if let lastCharacter = result.last {\n            if lastCharacter.isWhitespace {\n                wordIndex += 1\n            }\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"},{"task_id":"HumanEval_87","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Բացի այդ, շարքի կոորդինատները դասակարգեք սյունակների կողմից իջնող կարգով: \/\/ Սկզբում դասակարգեք կոորդինատները շարքերով աճող կարգով: \/\/ յուրաքանչյուր տուպլը կոորդինատ է (հորիզոնականը 0-ից սկսած)\/\/ եւ վերադարձնում է տուպլերի շարքը, [(x1, y1), (x2, y2) ...] այնպես, որ \/\/ Տվյալ lst, եւ ամբողջական x, գտնեք ամբողջական x թվերը զանգվածում, \/\/ յուրաքանչյուր շարքը կարող է պարունակել տարբեր թվով սյունակներ: \/\/ որը նման է մետրիկային, սակայն, ի տարբերություն մետրիկների, \/\/ Ձեզ տրվում է 2 չափման տվյալներ, որպես տեղադրված զանգվածներ, \/\/\/ >>> get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n\/\/\/ [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(lst: [] as [[Int]], x: 1)\n\/\/\/ [] as [(Int, Int)]\n\/\/\/ >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)\n\/\/\/ [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n","canonical_solution":"func get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n    var coordinates: [(Int, Int)] = []\n    \n    for (rowIndex, row) in lst.enumerated() {\n        for (colIndex, value) in row.enumerated() {\n            if value == x {\n                coordinates.append((rowIndex, colIndex))\n            }\n        }\n    }\n    \n    let sortedCoordinates = coordinates.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n        } else {\n            return $0.0 < $1.0\n        }\n    }\n    \n    return sortedCoordinates\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"},{"task_id":"HumanEval_88","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ * չփոխեք տրված շարքը: \/\/ Նշում: \/\/ կամ դասակարգեք այն իջնող կարգով, եթե գումարն է ((առաջին ինդեքսային արժեքը, վերջին ինդեքսային արժեքը) նույնիսկ: \/\/ դուք կսորտիացնեք տրված շարքը աճող կարգով, եթե գումարը ((առաջին ինդեքսային արժեքը, վերջին ինդեքսային արժեքը) զույգ է, \/\/ Տված ոչ բացասական ամբողջ թվերի շարքը, դասակարգելուց հետո վերադարձնում է տրված շարքի coswift- ը, \/\/\/ >>> sort_array(array: [] as [Int])\n\/\/\/ [] as [Int]\n\/\/\/ >>> sort_array(array: [5])\n\/\/\/ [5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5])\n\/\/\/ [0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(array: [2, 4, 3, 0, 1, 5, 6])\n\/\/\/ [6, 5, 4, 3, 2, 1, 0]\nfunc sort_array(array: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(array: [Int]) -> [Int] {\n    guard let first = array.first, let last = array.last else {\n        return array\n    }\n    let sum = first + last\n    if sum % 2 == 0 {\n        return array.sorted(by: >) \/\/ Descending order\n    } else {\n        return array.sorted() \/\/ Ascending order\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(array: [] as [Int]) == [] as [Int])\nassert(sort_array(array: [5]) == [5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\nassert(sort_array(array: [2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\nassert(sort_array(array: [2, 1]) == [1, 2])\nassert(sort_array(array: [15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\nassert(sort_array(array: [21, 14, 23, 11]) == [23, 21, 14, 11])"},{"task_id":"HumanEval_89","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ տեղաշարժվում է ներքեւ երկու անգամ երկու տեղում: \/\/ Աբբենը պետք է պտտվի այնպես, որ տառերը \/\/ վերադարձնում է կոդավորված տող, որի մեջ պարունակվում է այբուբենը: \/\/ Ստեղծեք ֆունկցիա, որը կոդավորում է string- ը որպես փաստարկ եւ \/\/\/ >>> encrypt(s: \"hi\")\n\/\/\/ \"lm\"\n\/\/\/ >>> encrypt(s: \"asdfghjkl\")\n\/\/\/ \"ewhjklnop\"\n\/\/\/ >>> encrypt(s: \"gf\")\n\/\/\/ \"kj\"\n\/\/\/ >>> encrypt(s: \"et\")\n\/\/\/ \"ix\"\nfunc encrypt(s: String) -> String {\n","canonical_solution":"func encrypt(s: String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let shift = 2 * 2 \/\/ shift down by two multiplied by two places, i.e., 4\n    var result = \"\"\n\n    for character in s {\n        if let index = alphabet.firstIndex(of: character) {\n            let newIndex = (index + shift) % alphabet.count\n            result.append(alphabet[newIndex])\n        } else {\n            result.append(character) \/\/ append non-alphabetic characters unchanged\n        }\n    }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") == \"e\")"},{"task_id":"HumanEval_90","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Վերադարձնում է null, եթե նման տարր չկա: \/\/ Գրեք next_smallest () ֆունկցիա, որը վերադարձնում է զանգվածի 2-րդ ամենափոքր տարրը: \/\/ Ձեզ տրված է ամբողջ թվերի շարք: \/\/\/ >>> next_smallest(lst: [1, 2, 3, 4, 5])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n\/\/\/ 2\n\/\/\/ >>> next_smallest(lst: [] as [Int])\n\/\/\/ nil\n\/\/\/ >>> next_smallest(lst: [1, 1])\n\/\/\/ nil\nfunc next_smallest(lst: [Int]) -> Int? {\n","canonical_solution":"func next_smallest(lst: [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    \n    var uniqueSorted = Array(Set(lst)).sorted()\n    \n    if uniqueSorted.count < 2 {\n        return nil\n    }\n    \n    return uniqueSorted[1]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"},{"task_id":"HumanEval_91","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Բառերը սահմանվում են '.', '?' կամ '!' տերմիններով:Բժշկությունը ձանձրույթ է, որը սկսվում է \"I\" բառով:\/\/ Ձեզ տրվում է բառերի շարք, եւ ձեր խնդիրը հաշվելն է:\/\/\/ >>> is_bored(S: \"Hello world\")\n\/\/\/ 0\n\/\/\/ >>> is_bored(S: \"The sky is blue. The sun is shining. I love this weather\")\n\/\/\/ 1\nfunc is_bored(S: String) -> Int {\n","canonical_solution":"func is_bored(S: String) -> Int {\n    let sentences = S.split { $0 == '.' || $0 == '?' || $0 == '!' }\n    var boredomCount = 0\n    \n    for sentence in sentences {\n        let trimmedSentence = sentence.trimmingCharacters(in: .whitespaces)\n        if trimmedSentence.hasPrefix(\"I\") {\n            boredomCount += 1\n        }\n    }\n    \n    return boredomCount\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_bored(S: \"Hello world\") == 0)\nassert(is_bored(S: \"Is the sky blue?\") == 0)\nassert(is_bored(S: \"I love It !\") == 1)\nassert(is_bored(S: \"bIt\") == 0)\nassert(is_bored(S: \"I feel good today. I will be productive. will kill It\") == 2)\nassert(is_bored(S: \"You and I are going for a walk\") == 0)"},{"task_id":"HumanEval_92","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ \/\/ false է վերադարձնում ցանկացած այլ դեպքում: \/\/ Վերադարձնում է true, եթե թվերից մեկը հավասար է մյուս երկուսի գումարին, եւ բոլոր թվերը ամբողջական թվեր են: \/\/ Ստեղծեք ֆունկցիա, որը 3 թվեր է ընդունում:\/\/\/ >>> any_int(x: 5, y: 2, z: 7)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3, y: 2, z: 2)\n\/\/\/ false\n\/\/\/ >>> any_int(x: 3, y: -2, z: 1)\n\/\/\/ true\n\/\/\/ >>> any_int(x: 3.6, y: -2.2, z: 2)\n\/\/\/ false\nfunc any_int(x: Double, y: Double, z: Double) -> Bool {\n","canonical_solution":"func any_int(x: Double, y: Double, z: Double) -> Bool {\n    guard x == floor(x), y == floor(y), z == floor(z) else {\n        return false\n    }\n    \n    let a = Int(x)\n    let b = Int(y)\n    let c = Int(z)\n    \n    return a == b + c || b == a + c || c == a + b\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(any_int(x: 2, y: 3, z: 1) == true)\nassert(any_int(x: 2.5, y: 2, z: 3) == false)\nassert(any_int(x: 1.5, y: 5, z: 3.5) == false)\nassert(any_int(x: 2, y: 6, z: 2) == false)\nassert(any_int(x: 4, y: 2, z: 2) == true)\nassert(any_int(x: 2.2, y: 2.2, z: 2.2) == false)\nassert(any_int(x: -4, y: 6, z: 2) == true)\nassert(any_int(x: 2, y: 1, z: 1) == true)\nassert(any_int(x: 3, y: 4, z: 7) == true)\nassert(any_int(x: 3.0, y: 4, z: 7) == false)"},{"task_id":"HumanEval_93","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Ենթադրում ենք միայն տառեր:\/\/ անգլերեն այբուբենի վոկալը:\/\/ այն նամակը, որի տառը 2 տեղ առաջ է հայտնվում:\/\/ ձեւով, որ այն փոխում է բոլոր տառերի կազինոները, փոխարինում է բոլոր վոկալները \/\/ Գրեք ֆունկցիա, որը կվերցնի հաղորդագրություն եւ կոդավորի այն նման \/\/\/ >>> encode(message: \"test\")\n\/\/\/ \"TGST\"\n\/\/\/ >>> encode(message: \"This is a message\")\n\/\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n","canonical_solution":"func encode(message: String) -> String {\n    let vowels = \"aeiouAEIOU\"\n    let vowelReplacement = [\n        \"a\": \"c\", \"e\": \"g\", \"i\": \"k\", \"o\": \"q\", \"u\": \"w\",\n        \"A\": \"C\", \"E\": \"G\", \"I\": \"K\", \"O\": \"Q\", \"U\": \"W\"\n    ]\n    \n    var encodedMessage = \"\"\n    \n    for char in message {\n        if vowels.contains(char) {\n            if let replacement = vowelReplacement[String(char)] {\n                encodedMessage.append(replacement)\n            }\n        } else {\n            let swappedCase = char.isUppercase ? Character(char.lowercased()) : Character(char.uppercased())\n            encodedMessage.append(swappedCase)\n        }\n    }\n    \n    return encodedMessage\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\nassert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\") == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\")\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\")"},{"task_id":"HumanEval_94","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Դուք պետք է գտնեք ամենամեծ պարզ արժեքը եւ վերադարձնեք դրա թվանշանների գումարը: \/\/ Ձեզ տրված է ամբողջ թվերի շարք: \/\/\/ >>> skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(lst: [0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(lst: [0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfunc skjkasdkd(lst: [Int]) -> Int {\n","canonical_solution":"func skjkasdkd(lst: [Int]) -> Int {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    var largestPrime: Int? = nil\n    for number in lst {\n        if isPrime(number) {\n            if largestPrime == nil || number > largestPrime! {\n                largestPrime = number\n            }\n        }\n    }\n    \n    if let largestPrime = largestPrime {\n        return String(largestPrime).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    }\n    \n    return 0 \/\/ In case there are no prime numbers\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(skjkasdkd(lst: [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10)\nassert(skjkasdkd(lst: [1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25)\nassert(skjkasdkd(lst: [1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13)\nassert(skjkasdkd(lst: [0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11)\nassert(skjkasdkd(lst: [0, 81, 12, 3, 1, 21]) == 3)\nassert(skjkasdkd(lst: [0, 8, 1, 2, 1, 7]) == 7)\nassert(skjkasdkd(lst: [8191]) == 19)\nassert(skjkasdkd(lst: [8191, 123456, 127, 7]) == 19)\nassert(skjkasdkd(lst: [127, 97, 8192]) == 10)"},{"task_id":"HumanEval_96","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ օրինակ՝ \/\/ ամբողջ թվեր, որոնք պարզ թվեր են եւ n-ից փոքր են: \/\/ Կիրառել ֆունկցիա, որը վերցնում է ոչ բացասական ամբողջ թիվ եւ վերադարձնում է առաջին n-ի զանգվածը:\/\/\/ >>> count_up_to(n: 5)\n\/\/\/ [2, 3]\n\/\/\/ >>> count_up_to(n: 11)\n\/\/\/ [2, 3, 5, 7]\n\/\/\/ >>> count_up_to(n: 0)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 20)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(n: 1)\n\/\/\/ [] as [Int]\n\/\/\/ >>> count_up_to(n: 18)\n\/\/\/ [2, 3, 5, 7, 11, 13, 17]\nfunc count_up_to(n: Int) -> [Int] {\n","canonical_solution":"func count_up_to(n: Int) -> [Int] {\n    guard n > 2 else { return [] }\n    \n    var primes: [Int] = [2]\n    \n    for number in 3..<n {\n        var isPrime = true\n        for prime in primes {\n            if prime * prime > number {\n                break\n            }\n            if number % prime == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes.append(number)\n        }\n    }\n    \n    return primes\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_up_to(n: 5) == [2, 3])\nassert(count_up_to(n: 6) == [2, 3, 5])\nassert(count_up_to(n: 7) == [2, 3, 5])\nassert(count_up_to(n: 10) == [2, 3, 5, 7])\nassert(count_up_to(n: 0) == [] as [Int])\nassert(count_up_to(n: 22) == [2, 3, 5, 7, 11, 13, 17, 19])\nassert(count_up_to(n: 1) == [] as [Int])\nassert(count_up_to(n: 18) == [2, 3, 5, 7, 11, 13, 17])\nassert(count_up_to(n: 47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\nassert(count_up_to(n: 101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])"},{"task_id":"HumanEval_97","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Ենթադրենք, որ մուտքագրվածը միշտ վավեր է: \/\/ նրանց միավորների թվանշանների բազմապատկումը: \/\/ Լրացրեք ֆունկցիան, որը վերցնում է երկու ամբողջ թվեր եւ վերադարձնում է \/\/\/ >>> multiply(a: 148, b: 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(a: 19, b: 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(a: 2020, b: 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(a: 14, b: -15)\n\/\/\/ 20\nfunc multiply(a: Int, b: Int) -> Int {\n","canonical_solution":"func multiply(a: Int, b: Int) -> Int {\n    let unitDigitA = abs(a % 10)\n    let unitDigitB = abs(b % 10)\n    return unitDigitA * unitDigitB\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply(a: 148, b: 412) == 16)\nassert(multiply(a: 19, b: 28) == 72)\nassert(multiply(a: 2020, b: 1851) == 0)\nassert(multiply(a: 14, b: -15) == 20)\nassert(multiply(a: 76, b: 67) == 42)\nassert(multiply(a: 17, b: 27) == 49)\nassert(multiply(a: 0, b: 1) == 0)\nassert(multiply(a: 0, b: 0) == 0)"},{"task_id":"HumanEval_98","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Տված s շարքը, հաշվել մեծատառերով ձայնավորների քանակը զույգ ցուցանիշներով: \/\/\/ >>> count_upper(s: \"aBCdEf\")\n\/\/\/ 1\n\/\/\/ >>> count_upper(s: \"abcdefg\")\n\/\/\/ 0\n\/\/\/ >>> count_upper(s: \"dBBE\")\n\/\/\/ 0\nfunc count_upper(s: String) -> Int {\n","canonical_solution":"func count_upper(s: String) -> Int {\n    let upperVowels = Set<Character>([\"A\", \"E\", \"I\", \"O\", \"U\"])\n    var count = 0\n\n    for (index, char) in s.enumerated() {\n        if index % 2 == 0 && upperVowels.contains(char) {\n            count += 1\n        }\n    }\n\n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_upper(s: \"aBCdEf\") == 1)\nassert(count_upper(s: \"abcdefg\") == 0)\nassert(count_upper(s: \"dBBE\") == 0)\nassert(count_upper(s: \"B\") == 0)\nassert(count_upper(s: \"U\") == 1)\nassert(count_upper(s: \"\") == 0)\nassert(count_upper(s: \"EEEE\") == 2)"},{"task_id":"HumanEval_99","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ \/\/ երկու ամբողջ թվերից, կլորացրեք այն զրոյից հեռու: \/\/ եւ վերադարձնում է դրան ամենամոտ ամբողջ թիվը: Եթե թիվը հավասար հեռավորության վրա է, ապա\/\/ Ստեղծել ֆունկցիա , որը ընդունում է արժեք (հոսք) ՝ ներկայացնելով թիվը:\/\/\/ >>> closest_integer(value: \"10\")\n\/\/\/ 10\n\/\/\/ >>> closest_integer(value: \"15.3\")\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n","canonical_solution":"func closest_integer(value: String) -> Int {\n    if let number = Double(value) {\n        return Int(number.rounded(.awayFromZero))\n    }\n    return 0 \/\/ or handle error as needed\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"},{"task_id":"HumanEval_100","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ i-ն ներկայացնում է քարերի քանակը (i+1) մակարդակում:\/\/ Վերադարձնում է աղյուսակի յուրաքանչյուր մակարդակի քարերի քանակը, որտեղ տարրը ինդեքսում է:\/\/ - հաջորդ զույգ թիվը, եթե n-ը զույգ է: \/\/ - հաջորդ անհավասար թիվը, եթե n-ը անհավասար է: \/\/ Հաջորդ մակարդակի քարերի թիվը հետեւյալն է. \/\/ Առաջին մակարդակը ունի n քարեր: \/\/ Նշված է դրական ամբողջ թիվ n, դուք պետք է պատրաստեք n մակարդակի քարերի կուտակ:\/\/\/ >>> make_a_pile(n: 3)\n\/\/\/ [3, 5, 7]\nfunc make_a_pile(n: Int) -> [Int] {\n","canonical_solution":"func make_a_pile(n: Int) -> [Int] {\n    var pile = [Int]()\n    var currentLevelStones = n\n    \n    for _ in 0..<n {\n        pile.append(currentLevelStones)\n        if n % 2 == 0 {\n            currentLevelStones += 2\n        } else {\n            currentLevelStones += 2\n        }\n    }\n    \n    return pile\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n: 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n: 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16, 18, 20, 22])"},{"task_id":"HumanEval_101","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ բաժանելու համար տողերը բառերի եւ վերադարձնելու համար բառերի շարքը:\/\/ Ձեզ կտրվի բառերի շարք, որոնք բաժանված են կոմայի կամ տարածության միջոցով: Ձեր խնդիրն է '\/\/\/ >>> words_string(s: \"Hi, my name is John\")\n\/\/\/ [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n\/\/\/ >>> words_string(s: \"One, two, three, four, five, six\")\n\/\/\/ [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nfunc words_string(s: String) -> [String] {\n","canonical_solution":"func words_string(s: String) -> [String] {\n    let separators = CharacterSet(charactersIn: \", \")\n    return s.components(separatedBy: separators).filter { !$0.isEmpty }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_string(s: \"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\nassert(words_string(s: \"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"Hi, my name\") == [\"Hi\", \"my\", \"name\"])\nassert(words_string(s: \"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"\") == [] as [String])\nassert(words_string(s: \"ahmed     , gamal\") == [\"ahmed\", \"gamal\"])"},{"task_id":"HumanEval_102","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ չկա այդպիսի թիվ, ապա ֆունկցիան պետք է վերադարձնի -1։\/\/ ամենամեծ զույգ ամբողջ թիվը, որը գտնվում է [x, y] միջակայքում ներառյալ: Եթե \/\/ Այս ֆունկցիան վերցնում է երկու դրական թվեր x եւ y եւ վերադարձնում է \/\/\/ >>> choose_num(x: 12, y: 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(x: 13, y: 12)\n\/\/\/ -1\nfunc choose_num(x: Int, y: Int) -> Int {\n","canonical_solution":"func choose_num(x: Int, y: Int) -> Int {\n    \/\/ Determine the starting and ending range values\n    let start = min(x, y)\n    let end = max(x, y)\n    \n    \/\/ Iterate from the end of the range to the start\n    for num in (start...end).reversed() {\n        \/\/ Check if the current number is even\n        if num % 2 == 0 {\n            return num\n        }\n    }\n    \n    \/\/ Return -1 if no even number is found\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(choose_num(x: 12, y: 15) == 14)\nassert(choose_num(x: 13, y: 12) == -1)\nassert(choose_num(x: 33, y: 12354) == 12354)\nassert(choose_num(x: 5234, y: 5233) == -1)\nassert(choose_num(x: 6, y: 29) == 28)\nassert(choose_num(x: 27, y: 10) == -1)\nassert(choose_num(x: 7, y: 7) == -1)\nassert(choose_num(x: 546, y: 546) == 546)"},{"task_id":"HumanEval_103","nl":"hye_Armn","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ Օրինակ: \/\/ Եթե n-ը մեծ է m-ից, վերադարձնում ենք -1-ը:\/\/ Գլխավորեք պատասխանը մինչեւ ամենամոտ ամբողջ թիվը եւ այն փոխարկեք երկակի թվային: \/\/ n-ից մինչեւ m ամբողջ թվերի միջին (ներառյալ n եւ m) ։\/\/ Ձեզ տրված են երկու դրական ամբողջ թվեր՝ n եւ m, եւ ձեր խնդիրը հաշվարկել է \/\/\/ >>> rounded_avg(n: 1, m: 5)\n\/\/\/ .success(\"0b11\")\n\/\/\/ >>> rounded_avg(n: 7, m: 5)\n\/\/\/ .failure(-1)\n\/\/\/ >>> rounded_avg(n: 10, m: 20)\n\/\/\/ .success(\"0b1111\")\n\/\/\/ >>> rounded_avg(n: 20, m: 33)\n\/\/\/ .success(\"0b11010\")\nfunc rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n","canonical_solution":"func rounded_avg(n: Int, m: Int) -> Result<String, Int> {\n    if n > m {\n        return .failure(-1)\n    }\n    \n    let count = m - n + 1\n    let sum = (n + m) * count \/ 2\n    let average = Double(sum) \/ Double(count)\n    let roundedAverage = Int(average.rounded())\n    let binaryString = String(roundedAverage, radix: 2)\n    \n    return .success(\"0b\" + binaryString)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rounded_avg(n: 1, m: 5) == .success(\"0b11\"))\nassert(rounded_avg(n: 7, m: 13) == .success(\"0b1010\"))\nassert(rounded_avg(n: 964, m: 977) == .success(\"0b1111001010\"))\nassert(rounded_avg(n: 996, m: 997) == .success(\"0b1111100100\"))\nassert(rounded_avg(n: 560, m: 851) == .success(\"0b1011000010\"))\nassert(rounded_avg(n: 185, m: 546) == .success(\"0b101101110\"))\nassert(rounded_avg(n: 362, m: 496) == .success(\"0b110101101\"))\nassert(rounded_avg(n: 350, m: 902) == .success(\"0b1001110010\"))\nassert(rounded_avg(n: 197, m: 233) == .success(\"0b11010111\"))\nassert(rounded_avg(n: 7, m: 5) == .failure(-1))\nassert(rounded_avg(n: 5, m: 1) == .failure(-1))\nassert(rounded_avg(n: 5, m: 5) == .success(\"0b101\"))"},{"task_id":"HumanEval_104","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Նշում. Վերադարձված զանգվածը պետք է դասավորվի աճող կարգով: \/\/ տարրեր, որոնք չունեն զույգ թվանշաններ:\/\/ Տված դրական ամբողջ թվերի շարքը x. վերադարձնել բոլորի դասավորված շարքը \/\/\/ >>> unique_digits(x: [15, 33, 1422, 1])\n\/\/\/ [1, 15, 33]\n\/\/\/ >>> unique_digits(x: [152, 323, 1422, 10])\n\/\/\/ [] as [Int]\nfunc unique_digits(x: [Int]) -> [Int] {\n","canonical_solution":"func unique_digits(x: [Int]) -> [Int] {\n    return x.filter { number in\n        var hasEvenDigit = false\n        var num = number\n        while num > 0 {\n            if (num % 10) % 2 == 0 {\n                hasEvenDigit = true\n                break\n            }\n            num \/= 10\n        }\n        return !hasEvenDigit\n    }.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_digits(x: [15, 33, 1422, 1]) == [1, 15, 33])\nassert(unique_digits(x: [152, 323, 1422, 10]) == [] as [Int])\nassert(unique_digits(x: [12345, 2033, 111, 151]) == [111, 151])\nassert(unique_digits(x: [135, 103, 31]) == [31, 135])"},{"task_id":"HumanEval_105","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ \"Մեկ\", \"Երկու\", \"Երեք\", \"Չորս\", \"Հինգ\", \"Վեց\", \"Յոթ\", \"Ութ\", \"Նա\",\/\/ փոխեք արդյունքում ստացված զանգվածը, եւ ապա յուրաքանչյուր թվանշան փոխարինեք համապատասխան անունով \/\/ Տված ամբողջ թվերի շարքը, դասակարգեք այն ամբողջ թվերը, որոնք 1-ից մինչեւ 9-ը ներառյալ են, \/\/\/ >>> by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\/\/\/ If the array is empty, return an empty array:\n\/\/\/ >>> by_length(arr: [] as [Int])\n\/\/\/ [] as [String]\n\/\/\/ If the array has any strange number ignore it:\n\/\/\/ >>> by_length(arr: [1, -1, 55])\n\/\/\/ [\"One\"]\nfunc by_length(arr: [Int]) -> [String] {\n","canonical_solution":"func by_length(arr: [Int]) -> [String] {\n    let numberNames: [Int: String] = [\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    ]\n    \n    let filteredSortedReversedNumbers = arr.filter { (1...9).contains($0) }\n                                           .sorted(by: >)\n    \n    let result = filteredSortedReversedNumbers.map { numberNames[$0] ?? \"\" }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(by_length(arr: [2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\nassert(by_length(arr: [] as [Int]) == [] as [String])\nassert(by_length(arr: [1, -1, 55]) == [\"One\"])\nassert(by_length(arr: [1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\nassert(by_length(arr: [9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])"},{"task_id":"HumanEval_106","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ i-ի ֆակտորիալը 1-ից i-ի համարների բազմապատկումն է (1 * 2 * ... * i) ։\/\/ i-ն սկսվում է 1-ից:\/\/ կամ 1-ից i-ի թվերի գումարը:\/\/ եւ վերադարձնում է n չափի զանգված, այնպես որ i ցուցանիշի տարրի արժեքը i-ի ֆակտորիալն է, եթե i-ն զույգ է:\/\/ Կիրառել ֆունկցիան f, որը n-ը որպես պարամետր է ընդունում, \/\/\/ >>> f(n: 5)\n\/\/\/ [1, 2, 6, 24, 15]\nfunc f(n: Int) -> [Int] {\n","canonical_solution":"func f(n: Int) -> [Int] {\n    func factorial(_ x: Int) -> Int {\n        guard x > 1 else { return 1 }\n        return (1...x).reduce(1, *)\n    }\n    \n    func sumTo(_ x: Int) -> Int {\n        return (1...x).reduce(0, +)\n    }\n    \n    var result = [Int]()\n    for i in 1...n {\n        if i % 2 == 0 {\n            result.append(factorial(i))\n        } else {\n            result.append(sumTo(i))\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(f(n: 5) == [1, 2, 6, 24, 15])\nassert(f(n: 7) == [1, 2, 6, 24, 15, 720, 28])\nassert(f(n: 1) == [1])\nassert(f(n: 3) == [1, 2, 6])"},{"task_id":"HumanEval_107","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ 1: \/\/ ամբողջական պալինդրոմներ, որոնք ընկնում են ((1, n), ներառյալ) միջակայքի մեջ: \/\/ Նշված է դրական ամբողջ թիվ n, վերադարձնել մի տուպլ, որը ունի նույնիսկ եւ անհավասար թվեր \/\/\/ >>> even_odd_palindrome(n: 3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(n: 12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_palindrome(n: Int) -> (Int, Int) {\n    func isPalindrome(_ num: Int) -> Bool {\n        let str = String(num)\n        return str == String(str.reversed())\n    }\n    \n    var evenCount = 0\n    var oddCount = 0\n    \n    for i in 1...n {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n                evenCount += 1\n            } else {\n                oddCount += 1\n            }\n        }\n    }\n    \n    return (evenCount, oddCount)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_palindrome(n: 123) == (8, 13))\nassert(even_odd_palindrome(n: 12) == (4, 6))\nassert(even_odd_palindrome(n: 3) == (1, 2))\nassert(even_odd_palindrome(n: 63) == (6, 8))\nassert(even_odd_palindrome(n: 25) == (5, 6))\nassert(even_odd_palindrome(n: 19) == (4, 6))\nassert(even_odd_palindrome(n: 9) == (4, 5))\nassert(even_odd_palindrome(n: 1) == (0, 1))"},{"task_id":"HumanEval_108","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ օրինակ, -123-ը ունի -1, 2 եւ 3 թվանշաններ: \/\/ Եթե թիվը բացասական է, ապա նրա առաջին ստորագրված թվանշանը կլինի բացասական: \/\/ տարրերի թիվը, որի թվանշանների գումարը > 0 է: \/\/ Գրեք count_nums ֆունկցիան, որը վերցնում է ամբողջ թվերի շարք եւ վերադարձնում է \/\/\/ >>> count_nums(arr: [] as [Int])\n\/\/\/ 0\n\/\/\/ >>> count_nums(arr: [-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(arr: [1, 1, 2])\n\/\/\/ 3\nfunc count_nums(arr: [Int]) -> Int {\n","canonical_solution":"func count_nums(arr: [Int]) -> Int {\n    return arr.filter { number in\n        var n = number\n        var sumOfDigits = 0\n\n        while n != 0 {\n            sumOfDigits += n % 10\n            n \/= 10\n        }\n\n        return sumOfDigits > 0\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_nums(arr: [] as [Int]) == 0)\nassert(count_nums(arr: [-1, -2, 0]) == 0)\nassert(count_nums(arr: [1, 1, 2, -2, 3, 4, 5]) == 6)\nassert(count_nums(arr: [1, 6, 9, -6, 0, 1, 5]) == 5)\nassert(count_nums(arr: [1, 100, 98, -7, 1, -1]) == 4)\nassert(count_nums(arr: [12, 23, 34, -45, -56, 0]) == 5)\nassert(count_nums(arr: [0, 1]) == 1)\nassert(count_nums(arr: [1]) == 1)"},{"task_id":"HumanEval_109","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Նշում. Տվյալ շարքը երաշխավորված է ունենալ եզակի տարրեր: \/\/ Եթե տրված շարքը դատարկ է, ապա վերադարձնում է true: \/\/ ապա վերադարձնում ենք true, այլապես վերադարձնում ենք false:\/\/ Եթե հնարավոր է ստանալ կարգավորված զանգվածը՝ կատարելով վերոնշյալ գործողությունը:\/\/ սկիզբային դիրքը զանգվածում, այսինքն ՝ 0-րդ ինդեքսը: \/\/ դիրքը ճիշտ ուղղությամբ: Արիի վերջին տարրը կտեղափոխվի \/\/ Մի աջ տեղաշարժի գործողությունը նշանակում է, որ աղյուսակի բոլոր տարրերը տեղաշարժվում են մեկով:\/\/ Ձեզ թույլատրվում է կատարել աջ տեղաշարժի գործողությունը ցանկացած քանակությամբ անգամներ: \/\/ տրված շարքի վրա կատարվում է հետեւյալ գործողությունը. \/\/ հնարավոր է ստանալ աղյուսակ, որը դասակարգված է ոչ նվազող կարգով ՝ կատարելով \/\/ թվերը շարքում պատահականորեն կարգավորվելու են: Ձեր խնդիրն է որոշել, թե արդյոք\/\/ Մենք ունենք array 'arr' N ամբողջ թվերից arr[1], arr[2], ..., arr[N] \/\/\/ >>> move_one_ball(arr: [3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given array.\n\/\/\/ >>> move_one_ball(arr: [3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ array by performing any number of right shift operations.\nfunc move_one_ball(arr: [Int]) -> Bool {\n","canonical_solution":"func move_one_ball(arr: [Int]) -> Bool {\n    guard !arr.isEmpty else { return true }\n    \n    let n = arr.count\n    var breakPointCount = 0\n    \n    \/\/ Find the number of break points where the array is decreasing\n    for i in 0..<n {\n        if arr[i] > arr[(i + 1) % n] {\n            breakPointCount += 1\n        }\n    }\n    \n    \/\/ If there's at most one break point, the array can be right shifted\n    return breakPointCount <= 1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_one_ball(arr: [3, 4, 5, 1, 2]) == true)\nassert(move_one_ball(arr: [3, 5, 10, 1, 2]) == true)\nassert(move_one_ball(arr: [4, 3, 1, 2]) == false)\nassert(move_one_ball(arr: [3, 5, 4, 1, 2]) == false)\nassert(move_one_ball(arr: [] as [Int]) == true)"},{"task_id":"HumanEval_110","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Հակառակ դեպքում վերադարձեք \"ՈՉ\"\/\/ lst1-ի բոլոր տարրերը պետք է լինեն զույգ, վերադարձնել \"YES\" \/\/ Եթե հնարավոր է փոխանակել տարրերը lst1-ի եւ lst2-ի միջեւ, որպեսզի \/\/ Չկա սահմանափակում lst1-ի եւ lst2-ի միջեւ փոխանակվող տարրերի քանակի վրա:\/\/ նրանց միջեւ, որպեսզի LST1 շարքը կազմի միայն զույգ թվերի շարք:\/\/ եւ որոշում է, թե արդյոք հնարավոր է տարրերի փոխանակում կատարել:\/\/ Այս խնդրի մեջ դուք կկիրառեք մի ֆունկցիա, որը կվերցնի երկու թվային շարքեր,\/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4])\n\/\/\/ \"YES\"\n\/\/\/ >>> exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4])\n\/\/\/ \"NO\"\n\/\/\/ It is assumed that the input arrays will be non-empty.\nfunc exchange(lst1: [Int], lst2: [Int]) -> String {\n","canonical_solution":"func exchange(lst1: [Int], lst2: [Int]) -> String {\n    var hasOddInLst1 = false\n    var hasEvenInLst2 = false\n    \n    for num in lst1 {\n        if num % 2 != 0 {\n            hasOddInLst1 = true\n            break\n        }\n    }\n    \n    for num in lst2 {\n        if num % 2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasOddInLst1 {\n        return \"YES\"\n    }\n    \n    if hasEvenInLst2 {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 2, 3, 4]) == \"YES\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [1, 5, 3, 4]) == \"NO\")\nassert(exchange(lst1: [1, 2, 3, 4], lst2: [2, 1, 4, 3]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 4]) == \"YES\")\nassert(exchange(lst1: [5, 7, 3], lst2: [2, 6, 3]) == \"NO\")\nassert(exchange(lst1: [3, 2, 6, 1, 8, 9], lst2: [3, 5, 5, 1, 1, 1]) == \"NO\")\nassert(exchange(lst1: [100, 200], lst2: [200, 200]) == \"YES\")"},{"task_id":"HumanEval_111","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ Եթե մի քանի տառեր ունեն նույն դեպքը, վերադարձնել բոլորին: \/\/ ամենաշատ կրկնվող տառը եւ համապատասխան թվաքանակը: \/\/ Տված տող, որը ներկայացնում է տարածությամբ բաժանված փոքր տառեր, վերադարձնում է բառարան:\/\/\/ >>> histogram(test: \"a b c\")\n\/\/\/ [\"a\" : 1, \"b\" : 1, \"c\" : 1]\n\/\/\/ >>> histogram(test: \"a b b a\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"a b c a b\")\n\/\/\/ [\"a\" : 2, \"b\" : 2]\n\/\/\/ >>> histogram(test: \"b b b b a\")\n\/\/\/ [\"b\" : 4]\n\/\/\/ >>> histogram(test: \"\")\n\/\/\/ [:] as [String : Int]\nfunc histogram(test: String) -> [String : Int] {\n","canonical_solution":"func histogram(test: String) -> [String : Int] {\n    var letterCount: [String: Int] = [:]\n\n    \/\/ Split the string into an array of letters\n    let letters = test.split(separator: \" \").map { String($0) }\n\n    \/\/ Count occurrences of each letter\n    for letter in letters {\n        letterCount[letter, default: 0] += 1\n    }\n\n    \/\/ Determine the maximum number of occurrences\n    guard let maxCount = letterCount.values.max() else {\n        return [:] as [String : Int]\n    }\n\n    \/\/ Filter the letterCount dictionary to only include letters with the max count\n    let result = letterCount.filter { $0.value == maxCount }\n\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"},{"task_id":"HumanEval_112","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ \/\/ Դուք պետք է վերադարձնեք տուպլ, որը պարունակում է արդյունքի տող եւ true\/false ստուգման համար: \/\/ Բջջային տողը կոչվում է պալինդրոմ, եթե այն նույնն է կարդում հետ եւ առաջ: \/\/ ապա ստուգեք, թե արդյո՞ք արդյունքի տողը պալինդրոմ է: \/\/ Մենք ունենք երկու տողեր՝ s եւ c, դուք պետք է ջնջեք բոլոր նիշերը s-ում, որոնք հավասար են c-ի ցանկացած նիշին:\/\/ Գործառույթ \/\/\/ >>> reverse_delete(s: \"abcde\", c: \"ae\")\n\/\/\/ (\"bcd\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdef\", c: \"b\")\n\/\/\/ (\"acdef\", false)\n\/\/\/ >>> reverse_delete(s: \"abcdedcba\", c: \"ab\")\n\/\/\/ (\"cdedc\", true)\nfunc reverse_delete(s: String, c: String) -> (String, Bool) {\n","canonical_solution":"func reverse_delete(s: String, c: String) -> (String, Bool) {\n    \/\/ Remove characters from s that are in c\n    let filteredString = s.filter { !c.contains($0) }\n    \n    \/\/ Check if the resulting string is a palindrome\n    let isPalindrome = filteredString == String(filteredString.reversed())\n    \n    \/\/ Return the resulting string and the palindrome check result\n    return (filteredString, isPalindrome)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_delete(s: \"abcde\", c: \"ae\") == (\"bcd\", false))\nassert(reverse_delete(s: \"abcdef\", c: \"b\") == (\"acdef\", false))\nassert(reverse_delete(s: \"abcdedcba\", c: \"ab\") == (\"cdedc\", true))\nassert(reverse_delete(s: \"dwik\", c: \"w\") == (\"dik\", false))\nassert(reverse_delete(s: \"a\", c: \"a\") == (\"\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"v\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"vabba\", c: \"v\") == (\"abba\", true))\nassert(reverse_delete(s: \"mamma\", c: \"mia\") == (\"\", true))"},{"task_id":"HumanEval_113","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ զույգ թվանշանների i-րդ տողում մուտքագրվածի:\/\/ մուտքի տող i-ը: \" որտեղ բոլոր i-ները պետք է փոխարինվեն թվով:\/\/ Արտադրանքի յուրաքանչյուր i տարրը պետք է լինի \"մեկակի տարրերի թիվը \/\/ Տված տողերի շարքը, որտեղ յուրաքանչյուր տող բաղկացած է միայն թվանշաններից, վերադարձնում է շարք: \/\/\/ >>> odd_count(lst: [\"1234567\"])\n\/\/\/ [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\/\/\/ >>> odd_count(lst: [\"3\", \"11111111\"])\n\/\/\/ [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nfunc odd_count(lst: [String]) -> [String] {\n","canonical_solution":"func odd_count(lst: [String]) -> [String] {\n    return lst.map { str in\n        let oddCount = str.filter { \"13579\".contains($0) }.count\n        return \"the number of odd elements \\(oddCount)n the str\\(oddCount)ng \\(oddCount) of the \\(oddCount)nput.\"\n    }\n}\n\n\/\/ Example Usage\nprint(odd_count(lst: [\"1234567\"]))\nprint(odd_count(lst: [\"3\", \"11111111\"]))","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_count(lst: [\"1234567\"]) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\nassert(odd_count(lst: [\"3\", \"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"])\nassert(odd_count(lst: [\"271\", \"137\", \"314\"]) == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"])"},{"task_id":"HumanEval_114","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ \/\/ թվերի: \/\/ Տված ամբողջ թվերի զանգված, գտեք ոչ դատարկ ենթաշարերի նվազագույն գումարը:\/\/\/ >>> minSubArraySum(nums: [2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(nums: [-1, -2, -3])\n\/\/\/ -6\nfunc minSubArraySum(nums: [Int]) -> Int {\n","canonical_solution":"func minSubArraySum(nums: [Int]) -> Int {\n    guard !nums.isEmpty else { return 0 }\n    \n    var currentMin = nums[0]\n    var overallMin = nums[0]\n    \n    for i in 1..<nums.count {\n        currentMin = min(nums[i], currentMin + nums[i])\n        overallMin = min(overallMin, currentMin)\n    }\n    \n    return overallMin\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minSubArraySum(nums: [2, 3, 4, 1, 2, 4]) == 1)\nassert(minSubArraySum(nums: [-1, -2, -3]) == -6)\nassert(minSubArraySum(nums: [-1, -2, -3, 2, -10]) == -14)\nassert(minSubArraySum(nums: [-9999999999999999]) == -9999999999999999)\nassert(minSubArraySum(nums: [0, 10, 20, 1000000]) == 0)\nassert(minSubArraySum(nums: [-1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [100, -1, -2, -3, 10, -5]) == -6)\nassert(minSubArraySum(nums: [10, 11, 13, 8, 3, 4]) == 3)\nassert(minSubArraySum(nums: [100, -33, 32, -1, 0, -2]) == -33)\nassert(minSubArraySum(nums: [-10]) == -10)\nassert(minSubArraySum(nums: [7]) == 7)\nassert(minSubArraySum(nums: [1, -1]) == -1)"},{"task_id":"HumanEval_115","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ 1: \/\/ Տեղադրել այն թվաքանակը, որը անհրաժեշտ է ցած նետելու համար: \/\/ Ձեր խնդիրն է օգտագործել էշի դատարկել ջրհորները. \/\/ եւ բոլոր բակիդերը նույն հզորությունն ունեն: \/\/ Յուրաքանչյուր ջրհոր ունի համապատասխան բեկոր, որը կարող է օգտագործվել ջուր հանելու համար, \/\/ եւ յուրաքանչյուր 1 մի շարքում ներկայացնում է մեկ միավոր ջուր: \/\/ Ձեզ տրվում է հորիզոնականների ուղղանկյուն ցանց: Յուրաքանչյուր շարք ներկայացնում է մեկ հորիզոնական, \/\/\/ >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n","canonical_solution":"func max_fill(grid: [[Int]], capacity: Int) -> Int {\n    var totalWater = 0\n    for row in grid {\n        for unit in row {\n            if unit == 1 {\n                totalWater += 1\n            }\n        }\n    }\n    return (totalWater + capacity - 1) \/ capacity\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"},{"task_id":"HumanEval_116","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Այն պետք է իրականացվի հետեւյալ կերպ. \/\/ Նման թվով 1-ականների համար դասակարգեք ըստ տասնորդական արժեքի: \/\/ միավորների թիվը բինարային ներկայացումներում աճող կարգով:\/\/ Այս կատայում դուք պետք է դասակարգեք ոչ բացասական ամբողջ թվերի շարքը ըստ \/\/\/ >>> sort_array(arr: [1, 5, 2, 3, 4])\n\/\/\/ [1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(arr: [-2, -3, -4, -5, -6])\n\/\/\/ [-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(arr: [1, 0, 2, 3, 4])\n\/\/\/ [0, 1, 2, 3, 4]\nfunc sort_array(arr: [Int]) -> [Int] {\n","canonical_solution":"func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted {\n        let onesCount1 = $0.nonNegativeOnesCount()\n        let onesCount2 = $1.nonNegativeOnesCount()\n        return (onesCount1, $0) < (onesCount2, $1)\n    }\n}\n\nextension Int {\n    func nonNegativeOnesCount() -> Int {\n        return self < 0 ? 0 : self.nonBitCount()\n    }\n    \n    private func nonBitCount() -> Int {\n        var count = 0\n        var num = self\n        while num > 0 {\n            count += num & 1\n            num >>= 1\n        }\n        return count\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"},{"task_id":"HumanEval_117","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Նշում. կարող եք ենթադրել, որ մուտքագրման տողը պարունակում է միայն տառեր եւ բաց տարածություններ: \/\/ Եթե s շարքը դատարկ է, ապա ֆունկցիան պետք է դատարկ զանգված վերադարձնի: \/\/ n համահնչյուններ, ըստ այն հերթականության, որով այդ բառերը հայտնվում են s շարքում: \/\/ ֆունկցիա, որը վերադարձնում է բոլոր բառերի շարքը string s-ից, որոնք պարունակում են ճիշտ \/\/ Նշված է string s եւ բնական թիվ n, դուք պետք է իրականացնեք \/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 4)\n\/\/\/ [\"little\"]\n\/\/\/ >>> select_words(s: \"Mary had a little lamb\", n: 3)\n\/\/\/ [\"Mary\", \"lamb\"]\n\/\/\/ >>> select_words(s: \"simple white space\", n: 2)\n\/\/\/ [] as [String]\n\/\/\/ >>> select_words(s: \"Hello world\", n: 4)\n\/\/\/ [\"world\"]\n\/\/\/ >>> select_words(s: \"Uncle sam\", n: 3)\n\/\/\/ [\"Uncle\"]\nfunc select_words(s: String, n: Int) -> [String] {\n","canonical_solution":"func select_words(s: String, n: Int) -> [String] {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    let words = s.split(separator: \" \")\n    var result: [String] = []\n    \n    for word in words {\n        let consonantCount = word.filter { !vowels.contains($0) }.count\n        if consonantCount == n {\n            result.append(String(word))\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"},{"task_id":"HumanEval_118","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ Դուք կարող եք ենթադրել, որ տրված տողը պարունակում է միայն անգլերեն տառեր: \/\/ գտնեք ցանկացած ինքնական, որը համապատասխանում է վերոնշյալ պայմանին: \/\/ Բանաստեղծները սկզբում եւ վերջում չեն հաշվարկվում: Եթե դուք չեք արել, վերադարձեք դատարկ տող:\/\/ երկու նիշ բառի աջ կողմից (հասարակական տառերով)\/\/ Ձեզ տրվում է բառ: Ձեր խնդիրն է գտնել ամենահարմարական ձայնականը, որը գտնվում է \/\/\/ >>> get_closest_vowel(word: \"yogurt\")\n\/\/\/ \"u\"\n\/\/\/ >>> get_closest_vowel(word: \"FULL\")\n\/\/\/ \"U\"\n\/\/\/ >>> get_closest_vowel(word: \"quick\")\n\/\/\/ \"\"\n\/\/\/ >>> get_closest_vowel(word: \"ab\")\n\/\/\/ \"\"\nfunc get_closest_vowel(word: String) -> String {\n","canonical_solution":"func get_closest_vowel(word: String) -> String {\n    let vowels = Set(\"aeiouAEIOU\")\n    var foundVowel: Character? = nil\n    \n    for i in stride(from: word.count - 2, through: 1, by: -1) {\n        let currentIndex = word.index(word.startIndex, offsetBy: i)\n        let previousIndex = word.index(word.startIndex, offsetBy: i - 1)\n        let nextIndex = word.index(word.startIndex, offsetBy: i + 1)\n        \n        if vowels.contains(word[currentIndex]) && \n            !vowels.contains(word[previousIndex]) && \n            !vowels.contains(word[nextIndex]) {\n            foundVowel = word[currentIndex]\n            break\n        }\n    }\n    \n    return foundVowel != nil ? String(foundVowel!) : \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"},{"task_id":"HumanEval_119","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Վերադարձնում է \"Այո\", եթե կա լավ տող ստեղծելու միջոց, եւ այլ դեպքում վերադարձնում է \"Ոչ\"\/\/ \"()) \" -ը չի:\/\/ հավասարակշռված են: Օրինակ՝ string '(((() ' լավ է, իսկ string \/\/ S շարքը համարվում է լավ, եթե եւ միայն եթե S-ի բոլոր կլորակները \/\/ որոշակի կարգով, որ ստացված տողը լավ կլինի:\/\/ Ձեր գործը ստուգելն է, թե արդյոք հնարավոր է երկու տողերը միացնել իրար:\/\/ միայն \"(\" կամ \") \" կոորդինատները:\/\/ Ձեզ տրված է երկու տողերի շարք, երկու տողերն էլ բաղկացած են բաց տողերից:\/\/\/ >>> match_parens(lst: [\"()(\", \")\"])\n\/\/\/ \"Yes\"\n\/\/\/ >>> match_parens(lst: [\")\", \")\"])\n\/\/\/ \"No\"\nfunc match_parens(lst: [String]) -> String {\n","canonical_solution":"func match_parens(lst: [String]) -> String {\n    let combined1 = lst[0] + lst[1]\n    let combined2 = lst[1] + lst[0]\n    \n    func isBalanced(_ s: String) -> Bool {\n        var balance = 0\n        for char in s {\n            if char == \"(\" {\n                balance += 1\n            } else if char == \")\" {\n                balance -= 1\n            }\n            if balance < 0 {\n                return false\n            }\n        }\n        return balance == 0\n    }\n    \n    if isBalanced(combined1) || isBalanced(combined2) {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"Yes\")"},{"task_id":"HumanEval_120","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ 1: \/\/ երկարության k-ի համար, որի համար առավելագույնը k թվեր են arr-ում: \/\/ Տված ամբողջ թվերի եւ k դրական ամբողջ թվերի շարքը, վերադարձնում է կարգավորված շարքը:\/\/\/ >>> maximum(arr: [-3, -4, 5], k: 3)\n\/\/\/ [-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(arr: [4, -4, 4], k: 2)\n\/\/\/ [4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1)\n\/\/\/ [2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the array will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the array will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr: [Int], k: Int) -> [Int] {\n","canonical_solution":"func maximum(arr: [Int], k: Int) -> [Int] {\n    guard k > 0 else { return [] }\n    let sortedArr = arr.sorted(by: >)\n    let maxElements = Array(sortedArr.prefix(k))\n    return maxElements.sorted()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4, -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr: [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0, 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3], k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7) == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2) == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr: [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\nassert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"},{"task_id":"HumanEval_121","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ \/\/ Տված է ոչ դատարկ ամբողջ թվերի շարքը, վերադարձնում է բոլոր զույգ տարրերի գումարը, որոնք զույգ դիրքերում են: \/\/\/ >>> solution(lst: [5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(lst: [3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(lst: [30, 13, 24, 321])\n\/\/\/ 0\nfunc solution(lst: [Int]) -> Int {\n","canonical_solution":"func solution(lst: [Int]) -> Int {\n    var sum = 0\n    for (index, value) in lst.enumerated() {\n        if index % 2 == 0 && value % 2 != 0 {\n            sum += value\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solution(lst: [5, 8, 7, 1]) == 12)\nassert(solution(lst: [3, 3, 3, 3, 3]) == 9)\nassert(solution(lst: [30, 13, 24, 321]) == 0)\nassert(solution(lst: [5, 9]) == 5)\nassert(solution(lst: [2, 4, 8]) == 0)\nassert(solution(lst: [30, 13, 23, 32]) == 23)\nassert(solution(lst: [3, 13, 2, 9]) == 3)"},{"task_id":"HumanEval_122","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ arr-ի առաջին k տարրերից առավելագույնը երկու թվանշան ունեցող տարրերի գումարը: \/\/ Տվյալ է ամբողջ թվերի ոչ դատարկ զանգված arr եւ ամբողջ թվ k, վերադարձնել \/\/\/ >>> add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr: [Int], k: Int) -> Int {\n","canonical_solution":"func add_elements(arr: [Int], k: Int) -> Int {\n    var sum = 0\n    for i in 0..<k {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_elements(arr: [1, -2, -3, 41, 57, 76, 87, 88, 99], k: 3) == -4)\nassert(add_elements(arr: [111, 121, 3, 4000, 5, 6], k: 2) == 0)\nassert(add_elements(arr: [11, 21, 3, 90, 5, 6, 7, 8, 9], k: 4) == 125)\nassert(add_elements(arr: [111, 21, 3, 4000, 5, 6, 7, 8, 9], k: 4) == 24)\nassert(add_elements(arr: [1], k: 1) == 1)"},{"task_id":"HumanEval_123","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ get_odd_collatz(5) վերադարձնում է [1, 5] # 5-ի համար կոլլատզ հաջորդականությունը [5, 16, 8, 4, 2, 1], այնպես որ զույգ թվերը միայն 1, եւ 5 են: \/\/ Օրինակ ՝\/\/ 2. վերադարձված զանգվածը կարգավորվում է աճող կարգով: \/\/ 1. Collatz(1) -ը [1] է:\/\/ Նշում: \/\/ տերմին գումարած 1։ Ենթադրությունը այն է, որ անկախ n-ի արժեքից, հաջորդականությունը միշտ կհասնի 1։\/\/ նախորդ տերմինը: Եթե նախորդ տերմինը զույգ է, ապա հաջորդ տերմինը 3 անգամ նախորդն է:\/\/ նախորդ տերմինը հետեւյալ կերպ. եթե նախորդ տերմինը զույգ է, ապա հաջորդ տերմինը -ի կեսն է:\/\/ հետեւյալ կերպ. սկսեք ցանկացած դրական ամբողջ թվից n: Այնուհետեւ յուրաքանչյուր տերմին ստացվում է \/\/ Կոլատցի ենթադրությունը մաթեմատիկայի ենթադրություն է, որը վերաբերում է սահմանված հաջորդականությանը:\/\/ Նշված է դրական ամբողջ թիվ n, վերադարձնել կարգավորված շարքը, որը պարունակում է զույգ թվերը կոլլազ հաջորդականությամբ: \/\/\/ >>> get_odd_collatz(n: 5)\n\/\/\/ [1, 5]\nfunc get_odd_collatz(n: Int) -> [Int] {\n","canonical_solution":"func get_odd_collatz(n: Int) -> [Int] {\n    var collatzSequence: [Int] = []\n    var number = n\n\n    while number != 1 {\n        if number % 2 != 0 {\n            collatzSequence.append(number)\n        }\n        if number % 2 == 0 {\n            number \/= 2\n        } else {\n            number = 3 * number + 1\n        }\n    }\n\n    collatzSequence.append(1) \/\/ append 1 as the sequence ends at 1\n\n    let sortedOdds = collatzSequence.sorted()\n    \n    return sortedOdds\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"},{"task_id":"HumanEval_124","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ 4. Տվյալ ամսաթիվը պետք է լինի հետեւյալ ձեւաչափով՝ մմ-դդ-հհհ \/\/ 3. Ամիսները չպետք է լինեն 1 ամսից պակաս կամ 12 ամսից ավելի:\/\/ 2. Օրերի թիվը ոչ պակաս է 1 կամ ավելի քան 31 օր ամիսների 1,3,5,7,8,10,12 եւ օրերի թիվը ոչ պակաս է 1 կամ ավելի քան 30 օր ամիսների 4,6,9,11 եւ օրերի թիվը ոչ պակաս է 1 կամ ավելի քան 29 ամիսների համար 2. \/\/ 1. Տվյալների շարքը դատարկ չէ: \/\/ Տվյալ ամսաթիվը վավեր է, եթե բավարարված են հետեւյալ բոլոր կանոնները.\/\/ true է վերադարձնում, եթե ամսաթիվը վավեր է, այլապես false: \/\/ Դուք պետք է գրեք ֆունկցիա, որը վավերացնում է տրված ամսաթվի տողը եւ \/\/\/ >>> valid_date(date: \"03-11-2000\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"15-01-2012\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"04-0-2040\")\n\/\/\/ false\n\/\/\/ >>> valid_date(date: \"06-04-2020\")\n\/\/\/ true\n\/\/\/ >>> valid_date(date: \"06\/04\/2020\")\n\/\/\/ false\nfunc valid_date(date: String) -> Bool {\n","canonical_solution":"func valid_date(date: String) -> Bool {\n    \/\/ Check if the date is empty\n    if date.isEmpty {\n        return false\n    }\n    \n    \/\/ Split the date into components using the \"-\" delimiter\n    let components = date.split(separator: \"-\")\n    \n    \/\/ Ensure the date has exactly three components\n    if components.count != 3 {\n        return false\n    }\n    \n    \/\/ Ensure the date components are integers\n    guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2]) else {\n        return false\n    }\n    \n    \/\/ Check if the month is within the valid range\n    if month < 1 || month > 12 {\n        return false\n    }\n    \n    \/\/ Define the number of days in each month\n    let daysInMonth = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    \/\/ Check the day range for each month\n    if day < 1 || day > daysInMonth[month] {\n        return false\n    }\n    \n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(valid_date(date: \"03-11-2000\") == true)\nassert(valid_date(date: \"15-01-2012\") == false)\nassert(valid_date(date: \"04-0-2040\") == false)\nassert(valid_date(date: \"06-04-2020\") == true)\nassert(valid_date(date: \"01-01-2007\") == true)\nassert(valid_date(date: \"03-32-2011\") == false)\nassert(valid_date(date: \"\") == false)\nassert(valid_date(date: \"04-31-3000\") == false)\nassert(valid_date(date: \"06-06-2005\") == true)\nassert(valid_date(date: \"21-31-2000\") == false)\nassert(valid_date(date: \"04-12-2003\") == true)\nassert(valid_date(date: \"04122003\") == false)\nassert(valid_date(date: \"20030412\") == false)\nassert(valid_date(date: \"2003-04\") == false)\nassert(valid_date(date: \"2003-04-12\") == false)\nassert(valid_date(date: \"04-2003\") == false)"},{"task_id":"HumanEval_125","nl":"hye_Armn","pl":"swift","prompt":"\nextension Int: Error {}\n        \n\/\/ Օրինակներ \/\/ այբուբեն, ord (a) = 0, ord (b) = 1, ... ord (z) = 25\/\/ պետք է բաժանվի կոմայի վրա ',' եթե կոմա գոյություն չունի, պետք է վերադարձնել փոքր տառերի քանակը տարօրինակ կարգով \/\/ Տված բառերի շարքը, վերադարձնում է բառերի շարքը, որը բաժանված է սպիտակ տարածքի վրա, եթե ձեր տեքստում սպիտակ տարածքներ չկան:\/\/\/ >>> split_words(txt: \"Hello world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"Hello,world!\")\n\/\/\/ .success([\"Hello\", \"world!\"])\n\/\/\/ >>> split_words(txt: \"abcdef\")\n\/\/\/ .failure(3)\nfunc split_words(txt: String) -> Result<[String], Int> {\n","canonical_solution":"func split_words(txt: String) -> Result<[String], Int> {\n    if txt.contains(\" \") {\n        let words = txt.split(separator: \" \").map { String($0) }\n        return .success(words)\n    } else if txt.contains(\",\") {\n        let words = txt.split(separator: \",\").map { String($0) }\n        return .success(words)\n    } else {\n        let oddOrderedLowerCaseLetters = txt.filter { char in\n            if let asciiValue = char.asciiValue {\n                let order = asciiValue - Character(\"a\").asciiValue!\n                return order % 2 == 1\n            }\n            return false\n        }\n        return .failure(oddOrderedLowerCaseLetters.count)\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"},{"task_id":"HumanEval_126","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ \/\/ թիվ, վերադարձնում է false: Ենթադրենք, որ բացասական թվեր չկան եւ միայն ամբողջ թվեր:\/\/ աճող կարգով: Եթե շարքը ունի նույնի ավելի քան 1 կրկնօրինակ:\/\/ Տված թվերի շարքը, վերադարձնում է, թե արդյոք դրանք դասակարգված են, թե ոչ:\/\/\/ >>> is_sorted(lst: [5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfunc is_sorted(lst: [Int]) -> Bool {\n","canonical_solution":"func is_sorted(lst: [Int]) -> Bool {\n    guard !lst.isEmpty else { return true }\n\n    var previous = lst[0]\n    var duplicates = 0\n\n    for i in 1..<lst.count {\n        if lst[i] < previous {\n            return false\n        } else if lst[i] == previous {\n            duplicates += 1\n            if duplicates > 1 {\n                return false\n            }\n        } else {\n            duplicates = 0\n        }\n        previous = lst[i]\n    }\n\n    return true\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"},{"task_id":"HumanEval_127","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ [ներդրում\/արտադրանք] նմուշներ: \/\/ Եթե երկու միջակայքերը չեն խաչվում, վերադարձնել \"ՈՉ\"\/\/ հակառակ դեպքում վերադարձնում է \"ՈՉ\"\/\/ Եթե հատման երկարությունը պարզ թիվ է, վերադարձեք \"YES\", \/\/ որի երկարությունը 1 է, որը պարզ թիվ չէ:\/\/ Օրինակ, միջակայքի (1, 3), (2, 4) հատումը (2, 3) է:\/\/ միջակայքը պարզ թիվ է:\/\/ Ձեր խնդիրն է որոշել, թե արդյոք այս երկուսի խաչմերուկի երկարությունը\/\/ Յուրաքանչյուր տրված միջակայքի համար ենթադրվում է, որ դրա սկիզբը փոքր է կամ հավասար է վերջին: \/\/ ներառում է ինչպես սկիզբը, այնպես էլ վերջը:\/\/ Տվյալ միջակայքները փակ են, ինչը նշանակում է, որ միջակայքը (սկսում, ավարտ) \/\/ որտեղ յուրաքանչյուր միջակայքը ամբողջ թվերի զույգ է: Օրինակ, միջակայքը = (սկսում, ավարտ) = (1, 2):\/\/ Ձեզ տրվում է երկու միջակայք, \/\/\/ >>> intersection(interval1: (1, 2), interval2: (2, 3))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-1, 1), interval2: (0, 4))\n\/\/\/ \"NO\"\n\/\/\/ >>> intersection(interval1: (-3, -1), interval2: (-5, 5))\n\/\/\/ \"YES\"\nfunc intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n","canonical_solution":"func intersection(interval1: (Int, Int), interval2: (Int, Int)) -> String {\n    \/\/ Helper function to determine if a number is prime\n    func isPrime(_ num: Int) -> Bool {\n        if num <= 1 {\n            return false\n        }\n        if num <= 3 {\n            return true\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false\n        }\n        var i = 5\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    \/\/ Find the start and end of the intersection\n    let intersectStart = max(interval1.0, interval2.0)\n    let intersectEnd = min(interval1.1, interval2.1)\n    \n    \/\/ Calculate the length of the intersection\n    let intersectionLength = intersectEnd - intersectStart\n\n    \/\/ Check if intersection length is positive and prime\n    if intersectionLength > 0 && isPrime(intersectionLength) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersection(interval1: (1, 2), interval2: (2, 3)) == \"NO\")\nassert(intersection(interval1: (-1, 1), interval2: (0, 4)) == \"NO\")\nassert(intersection(interval1: (-3, -1), interval2: (-5, 5)) == \"YES\")\nassert(intersection(interval1: (-2, 2), interval2: (-4, 0)) == \"YES\")\nassert(intersection(interval1: (-11, 2), interval2: (-1, -1)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (3, 5)) == \"NO\")\nassert(intersection(interval1: (1, 2), interval2: (1, 2)) == \"NO\")\nassert(intersection(interval1: (-2, -2), interval2: (-3, -2)) == \"NO\")"},{"task_id":"HumanEval_128","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ Նշում. null վերադարձեք դատարկ arr- ի համար: \/\/ յուրաքանչյուր թվից շարքում, որը ներկայացված է 1, -1 կամ 0-ով:\/\/ ամբողջ թվերի մեծությունների գումար բազմապատկված բոլոր նշանների արտադրյալով:\/\/ Ձեզ տրված է ամբողջ թվերի շարք եւ դուք պետք է վերադարձնեք \/\/\/ >>> prod_signs(arr: [1, 2, 2, -4])\n\/\/\/ 9\n\/\/\/ >>> prod_signs(arr: [0, 1])\n\/\/\/ 0\n\/\/\/ >>> prod_signs(arr: [] as [Int])\n\/\/\/ nil\nfunc prod_signs(arr: [Int]) -> Int? {\n","canonical_solution":"func prod_signs(arr: [Int]) -> Int? {\n    \/\/ Return nil for empty array\n    if arr.isEmpty {\n        return nil\n    }\n\n    \/\/ Calculate the sum of magnitudes\n    let sumOfMagnitudes = arr.reduce(0) { sum, num in\n        return sum + abs(num)\n    }\n\n    \/\/ Calculate the product of all signs\n    let productOfSigns = arr.reduce(1) { product, num in\n        if num > 0 {\n            return product * 1\n        } else if num < 0 {\n            return product * -1\n        } else {\n            return 0\n        }\n    }\n\n    \/\/ Return the result of sum of magnitudes multiplied by product of signs\n    return sumOfMagnitudes * productOfSigns\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"},{"task_id":"HumanEval_129","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Վերադարձնում է բջիջների արժեքների կարգավորված շարքը, որոնցով անցնում է նվազագույն ուղին: \/\/ երաշխավորված է, որ պատասխանը եզակի է: \/\/ lst_A[j] = lst_B[j]։\/\/ այնպես, որ lst_A[i] < lst_B[i] եւ ցանկացած j (1 <= j < i) համար մենք ունենք \/\/ քան lst_B, այլ կերպ ասած, գոյություն ունի ամբողջ թվային ինդեքս i (1 <= i <= k) \/\/ միջոցով (թող նրանց անվանենք lst_A եւ lst_B), lst_A-ն բառաբանորեն ավելի քիչ է:\/\/ A եւ B բջիջների արժեքների կարգավորված շարքերը կազմելուց հետո:\/\/ A ուղին (k երկարության) համարվում է ավելի փոքր, քան B ուղին (k երկարության), եթե \/\/ Դուք չեք կարող գնալ ցանցից դուրս. \/\/ պարտադիր տարբերվում են) \/\/ Խնդրում ենք նկատի ունենալ, որ k երկարության ուղին նշանակում է այցելել ճիշտ k բջիջներ (ոչ \/\/ բջիջ: Այլ կերպ ասած, դուք կարող եք գնալ բջիջների, որոնք կիսում են ձեր ծայրը:\/\/ ցանկացած բջիջից, եւ յուրաքանչյուր քայլում դուք կարող եք տեղափոխվել ցանկացած հարեւան բջիջ, \/\/ Դուք պետք է գտնեք k երկարության նվազագույն ուղին ցանցում: Դուք կարող եք սկսել:\/\/ ներառյալը հայտնվում է ճիշտ մեկ անգամ ցանցի բջիջների վրա: \/\/ ցանցի յուրաքանչյուր բջիջ պարունակում է արժեք: [1, N * N] միջակայքում յուրաքանչյուր ամբողջական թիվ:\/\/ Նշված է ցանց N շարքերով եւ N սյունակներով (N >= 2) եւ k դրական ամբողջ թվով, \/\/\/ >>> minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3)\n\/\/\/ [1, 2, 1]\n\/\/\/ >>> minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1)\n\/\/\/ [1]\nfunc minPath(grid: [[Int]], k: Int) -> [Int] {\n","canonical_solution":"func minPath(grid: [[Int]], k: Int) -> [Int] {\n    let n = grid.count\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    struct Path: Comparable {\n        let cells: [Int]\n        \n        static func < (lhs: Path, rhs: Path) -> Bool {\n            return lhs.cells.lexicographicallyPrecedes(rhs.cells)\n        }\n    }\n    \n    var minPath: Path? = nil\n    \n    func dfs(x: Int, y: Int, k: Int, currentPath: [Int]) {\n        var currentPath = currentPath\n        currentPath.append(grid[x][y])\n        \n        if currentPath.count == k {\n            let newPath = Path(cells: currentPath)\n            if minPath == nil || newPath < minPath! {\n                minPath = newPath\n            }\n            return\n        }\n        \n        for direction in directions {\n            let newX = x + direction.0\n            let newY = y + direction.1\n            if newX >= 0 && newX < n && newY >= 0 && newY < n {\n                dfs(x: newX, y: newY, k: k, currentPath: currentPath)\n            }\n        }\n    }\n    \n    for i in 0..<n {\n        for j in 0..<n {\n            dfs(x: i, y: j, k: k, currentPath: [])\n        }\n    }\n    \n    return minPath!.cells\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minPath(grid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], k: 3) == [1, 2, 1])\nassert(minPath(grid: [[5, 9, 3], [4, 1, 6], [7, 8, 2]], k: 1) == [1])\nassert(minPath(grid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], k: 4) == [1, 2, 1, 2])\nassert(minPath(grid: [[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], k: 7) == [1, 10, 1, 10, 1, 10, 1])\nassert(minPath(grid: [[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], k: 5) == [1, 7, 1, 7, 1])\nassert(minPath(grid: [[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], k: 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1])\nassert(minPath(grid: [[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], k: 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\nassert(minPath(grid: [[2, 7, 4], [3, 1, 5], [6, 8, 9]], k: 8) == [1, 3, 1, 3, 1, 3, 1, 3])\nassert(minPath(grid: [[6, 1, 5], [3, 8, 9], [2, 7, 4]], k: 8) == [1, 5, 1, 5, 1, 5, 1, 5])\nassert(minPath(grid: [[1, 2], [3, 4]], k: 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\nassert(minPath(grid: [[1, 3], [3, 2]], k: 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3])"},{"task_id":"HumanEval_130","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ առաջին n + 1 թվերը Tribonacci հաջորդականության. \/\/ Ձեզ տրված է ոչ բացասական ամբողջ թիվ n, դուք պետք է վերադարձնեք array-ը \/\/ = 2 + 3 + 3 = 8 \/\/ tri(3) = tri(2) + tri(1) + tri(4) \/\/ tri(4) = 3 \/\/ tri(2) = 1 + (2 \/ 2) = 2 \/\/ Օրինակ ՝\/\/ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), եթե n-ը զույգ է: \/\/ tri (n) = 1 + n \/ 2, եթե n-ը զույգ է: \/\/ tri(1) = 3 \/\/ Տրիբոնաչիի հաջորդականությունը սահմանվում է կրկնվողությամբ: Այնուամենայնիվ, մարդիկ չգիտեն, որ տրիբոնաչիի հաջորդականությունը:Բոլորը գիտեն Ֆիբոնաչիի հաջորդականությունը, այն խորապես ուսումնասիրվել է մաթեմատիկոսների կողմից \/\/\/ >>> tri(n: 3)\n\/\/\/ [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n","canonical_solution":"func tri(n: Int) -> [Int] {\n    guard n >= 0 else { return [] }\n    if n == 0 { return [1] }\n    if n == 1 { return [1, 3] }\n    if n == 2 { return [1, 3, 2] }\n    \n    var sequence = [1, 3, 2]\n    \n    for i in 3...n {\n        if i % 2 == 0 {\n            sequence.append(1 + i \/ 2)\n        } else {\n            let nextVal = sequence[i-1] + sequence[i-2] + sequence[i+1-1]\n            sequence.append(nextVal)\n        }\n    }\n    \n    return sequence\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])"},{"task_id":"HumanEval_131","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Վերադարձնում է 0-ը, եթե բոլոր թվանշանները զույգ են: \/\/ Նշված է դրական ամբողջ թիվ n, վերադարձնել զույգ թվանշանների արտադրյալը: \/\/\/ >>> digits(n: 1)\n\/\/\/ 1\n\/\/\/ >>> digits(n: 4)\n\/\/\/ 0\n\/\/\/ >>> digits(n: 235)\n\/\/\/ 15\nfunc digits(n: Int) -> Int {\n","canonical_solution":"func digits(n: Int) -> Int {\n    var num = n\n    var product = 1\n    var hasOdd = false\n    \n    while num > 0 {\n        let digit = num % 10\n        if digit % 2 != 0 {\n            hasOdd = true\n            product *= digit\n        }\n        num \/= 10\n    }\n    \n    return hasOdd ? product : 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digits(n: 5) == 5)\nassert(digits(n: 54) == 5)\nassert(digits(n: 120) == 1)\nassert(digits(n: 5014) == 5)\nassert(digits(n: 98765) == 315)\nassert(digits(n: 5576543) == 2625)\nassert(digits(n: 2468) == 0)"},{"task_id":"HumanEval_132","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ որտեղ առնվազն մեկ կոտորակ է տեղադրված հաջորդականության մեջ: \/\/ Ֆունկցիան պետք է true վերադարձնի, եթե եւ միայն եթե կա կլորակետերի վավեր հաջորդականություն:\/\/ Ստեղծեք ֆունկցիա, որը որպես մուտք է ընդունում տող, որը պարունակում է միայն քառակուսի կլորակ: \/\/\/ >>> is_nested(string: \"[[]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[]]]]]]][[[[[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[][]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[]\")\n\/\/\/ false\n\/\/\/ >>> is_nested(string: \"[[][]]\")\n\/\/\/ true\n\/\/\/ >>> is_nested(string: \"[[]][[\")\n\/\/\/ true\nfunc is_nested(string: String) -> Bool {\n","canonical_solution":"func is_nested(string: String) -> Bool {\n    var stack: [Character] = []\n    var nested = false\n\n    for bracket in string {\n        if bracket == \"[\" {\n            stack.append(bracket)\n        } else if bracket == \"]\" {\n            if let last = stack.last, last == \"[\" {\n                stack.removeLast()\n                if !stack.isEmpty {\n                    nested = true\n                }\n            } else {\n                return false\n            }\n        }\n    }\n    return nested\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"},{"task_id":"HumanEval_133","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ ամեն տարրը զանգվածի մեջ նախ կլորացրեք մինչեւ վերին int ((Ceiling) \/\/ Դուք պետք է վերադարձնել քառակուսի թվերի գումար տրված շարքում, \/\/ Ձեզ տրվում է թվերի շարք: \/\/\/ >>> sum_squares(lst: [1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> sum_squares(lst: [1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> sum_squares(lst: [1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> sum_squares(lst: [1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> sum_squares(lst: [-2.4, 1.0, 1.0])\n\/\/\/ 6\nfunc sum_squares(lst: [Double]) -> Int {\n","canonical_solution":"func sum_squares(lst: [Double]) -> Int {\n    return lst.map { ceil($0) } \/\/ Round each element to the upper int (Ceiling)\n              .map { Int($0 * $0) } \/\/ Square each element\n              .reduce(0, +) \/\/ Sum all squared elements\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 3.0, 5.0, 7.0]) == 84)\nassert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)\nassert(sum_squares(lst: [-2.4, 1.0, 1.0]) == 6)\nassert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)\nassert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)\nassert(sum_squares(lst: [-1.4, 4.6, 6.3]) == 75)\nassert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) == 1086)\nassert(sum_squares(lst: [0.0]) == 0)\nassert(sum_squares(lst: [-1.0]) == 1)\nassert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"},{"task_id":"HumanEval_134","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Նշում. \"խոսք\" բառը տառերի մի խումբ է, որոնք բաժանված են տարածությամբ:\/\/ բառի մի մասը, եւ այլապես կեղծ է:\/\/ տողը այբուբենային նիշ է եւ ոչ թե \/\/ Ստեղծեք ֆունկցիա, որը true կվերադարձնի, եթե վերջին նիշը \/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pie\")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e\")\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"apple pi e \")\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(txt: \"\")\n\/\/\/ false\nfunc check_if_last_char_is_a_letter(txt: String) -> Bool {\n","canonical_solution":"func check_if_last_char_is_a_letter(txt: String) -> Bool {\n    guard let lastChar = txt.trimmingCharacters(in: .whitespaces).last else {\n        return false\n    }\n    \n    if lastChar.isLetter {\n        let words = txt.split(separator: \" \")\n        if let lastWord = words.last {\n            return lastWord.count == 1\n        }\n    }\n    \n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_if_last_char_is_a_letter(txt: \"apple\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"A\") == true)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"Pumpkin pie 1\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"eeeee e \") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pie\") == false)\nassert(check_if_last_char_is_a_letter(txt: \"apple pi e \") == false)"},{"task_id":"HumanEval_135","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ կրկնօրինակ արժեքներ:\/\/ նման տարր գոյություն չունի, ապա վերադարձնում է -1. Տվյալ շարքը չի պարունակում \/\/ մեծ չէ կամ հավասար չէ անմիջապես նախորդող տարրին: Եթե \/\/ Ստեղծել ֆունկցիա, որը վերադարձնում է տարրի ամենամեծ ինդեքսը, որը \/\/\/ >>> can_arrange(arr: [1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(arr: [1, 2, 3])\n\/\/\/ -1\nfunc can_arrange(arr: [Int]) -> Int {\n","canonical_solution":"func can_arrange(arr: [Int]) -> Int {\n    for i in (1..<arr.count).reversed() {\n        if arr[i] < arr[i - 1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(can_arrange(arr: [1, 2, 4, 3, 5]) == 3)\nassert(can_arrange(arr: [1, 2, 4, 5]) == -1)\nassert(can_arrange(arr: [1, 4, 2, 5, 6, 7, 8, 9, 10]) == 2)\nassert(can_arrange(arr: [4, 8, 5, 7, 3]) == 4)\nassert(can_arrange(arr: [] as [Int]) == -1)"},{"task_id":"HumanEval_136","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Եթե բացասական կամ դրական ամբողջ թվեր չկան, վերադարձրեք դրանք որպես null: \/\/ դրական ամբողջ թվերի զանգվածում: \/\/ մեծագույն բացասական ամբողջ թվերը, եւ 'b' ամենափոքրը:\/\/ Ստեղծեք ֆունկցիա, որը վերադարձնում է տուպլ (a, b), որտեղ 'a' \/\/\/ >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])\n\/\/\/ (nil, 1)\n\/\/\/ >>> largest_smallest_integers(lst: [] as [Int])\n\/\/\/ (nil, nil)\n\/\/\/ >>> largest_smallest_integers(lst: [0])\n\/\/\/ (nil, nil)\nfunc largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n","canonical_solution":"func largest_smallest_integers(lst: [Int]) -> (Int?, Int?) {\n    var largestNegative: Int? = nil\n    var smallestPositive: Int? = nil\n\n    for number in lst {\n        if number < 0 {\n            if largestNegative == nil || number > largestNegative! {\n                largestNegative = number\n            }\n        } else if number > 0 {\n            if smallestPositive == nil || number < smallestPositive! {\n                smallestPositive = number\n            }\n        }\n    }\n\n    return (largestNegative, smallestPositive)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6, -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7]) == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\nassert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3, -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100, 1]) == (-3, 1))"},{"task_id":"HumanEval_137","nl":"hye_Armn","pl":"swift","prompt":"\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n\/\/ Նշում. Եթե իրական թիվը ներկայացված է որպես տող, ապա շարժական կետը կարող է լինել . կամ , \/\/ Վերադարձնում է null, եթե արժեքները հավասար են: \/\/ իրական թվեր եւ վերադարձնում է մեծ փոփոխականը իր տրված փոփոխական տիպով: \/\/ Ստեղծեք ֆունկցիա, որը ընդունում է ամբողջ թվեր, floats կամ string-ներ, որոնք ներկայացնում են \/\/\/ >>> compare_one(a: .intValue(1), b: .doubleValue(2.5))\n\/\/\/ .doubleValue(2.5)\n\/\/\/ >>> compare_one(a: .intValue(1), b: .stringValue(\"2,3\"))\n\/\/\/ .stringValue(\"2,3\")\n\/\/\/ >>> compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n\/\/\/ .stringValue(\"6\")\n\/\/\/ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n\/\/\/ nil\nfunc compare_one(a: Value, b: Value) -> Value? {\n","canonical_solution":"func compare_one(a: Value, b: Value) -> Value? {\n    func convertToDouble(value: Value) -> Double? {\n        switch value {\n        case .intValue(let int):\n            return Double(int)\n        case .doubleValue(let double):\n            return double\n        case .stringValue(let string):\n            let formatter = NumberFormatter()\n            formatter.locale = Locale(identifier: \"en_US_POSIX\")\n            if string.contains(\",\") {\n                formatter.decimalSeparator = \",\"\n            } else {\n                formatter.decimalSeparator = \".\"\n            }\n            return formatter.number(from: string)?.doubleValue\n        }\n    }\n    \n    let aDouble = convertToDouble(value: a)\n    let bDouble = convertToDouble(value: b)\n    \n    if let aDouble = aDouble, let bDouble = bDouble {\n        if aDouble > bDouble {\n            return a\n        } else if bDouble > aDouble {\n            return b\n        }\n    }\n    \n    return nil\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)"},{"task_id":"HumanEval_138","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ \/\/ Գնահատեք, թե արդյոք տրված թիվը n կարող է գրվել որպես ճիշտ 4 դրական զույգ թվերի գումար:\/\/\/ >>> is_equal_to_sum_even(n: 4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(n: 8)\n\/\/\/ true\nfunc is_equal_to_sum_even(n: Int) -> Bool {\n","canonical_solution":"func is_equal_to_sum_even(n: Int) -> Bool {\n    if n <= 8 {\n        return false\n    }\n    return n % 2 == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_equal_to_sum_even(n: 4) == false)\nassert(is_equal_to_sum_even(n: 6) == false)\nassert(is_equal_to_sum_even(n: 8) == true)\nassert(is_equal_to_sum_even(n: 10) == true)\nassert(is_equal_to_sum_even(n: 11) == false)\nassert(is_equal_to_sum_even(n: 12) == true)\nassert(is_equal_to_sum_even(n: 13) == false)\nassert(is_equal_to_sum_even(n: 16) == true)"},{"task_id":"HumanEval_139","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ որտեղ n > 0 \/\/ բրազիլական_ֆակտորիալը (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/ Բրազիլական ֆակտորիալը սահմանվում է հետեւյալ կերպ. \/\/\/ >>> special_factorial(n: 4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfunc special_factorial(n: Int) -> Int {\n","canonical_solution":"func factorial(_ n: Int) -> Int {\n    return n <= 1 ? 1 : n * factorial(n - 1)\n}\n\nfunc special_factorial(n: Int) -> Int {\n    var result = 1\n    for i in 1...n {\n        result *= factorial(i)\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(special_factorial(n: 4) == 288)\nassert(special_factorial(n: 5) == 34560)\nassert(special_factorial(n: 7) == 125411328000)\nassert(special_factorial(n: 1) == 1)"},{"task_id":"HumanEval_140","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ ապա փոխարինեք բոլոր հաջորդական տարածքները - \/\/ եւ եթե տողն ունի ավելի քան 2 հաջորդական տարածք, \/\/ Տված տեքստային տող, փոխարինեք բոլոր տարածությունները ստորագրություններով, \/\/\/ >>> fix_spaces(text: \" Example\")\n\/\/\/ \"Example\"\n\/\/\/ >>> fix_spaces(text: \" Example 1\")\n\/\/\/ \"Example_1\"\n\/\/\/ >>> fix_spaces(text: \" Example 2\")\n\/\/\/ \"_Example_2\"\n\/\/\/ >>> fix_spaces(text: \" Example 3\")\n\/\/\/ \"_Example-3\"\nfunc fix_spaces(text: String) -> String {\n","canonical_solution":"func fix_spaces(text: String) -> String {\n    var result = \"\"\n    var spaceCount = 0\n    \n    for character in text {\n        if character == \" \" {\n            spaceCount += 1\n        } else {\n            if spaceCount == 1 {\n                result.append(\"_\")\n            } else if spaceCount > 1 {\n                result.append(\"-\")\n            }\n            result.append(character)\n            spaceCount = 0\n        }\n    }\n    \n    if spaceCount == 1 {\n        result.append(\"_\")\n    } else if spaceCount > 1 {\n        result.append(\"-\")\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(fix_spaces(text: \"Example\") == \"Example\")\nassert(fix_spaces(text: \"Mudasir Hanif \") == \"Mudasir_Hanif_\")\nassert(fix_spaces(text: \"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\")\nassert(fix_spaces(text: \"Exa   mple\") == \"Exa-mple\")\nassert(fix_spaces(text: \"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\")"},{"task_id":"HumanEval_141","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ - Նշանային կետից հետո ենթաշարը պետք է լինի հետեւյալներից մեկը. ['txt', 'exe', 'dll'] \/\/ լատիներեն այբուբենը ('a'-'z' եւ 'A'-'Z'). \/\/ - Նշանախագծի նախորդ ենթաշարը չպետք է լինի դատարկ, եւ այն սկսվում է -ից\/\/ - Ֆայլի անվանումը պարունակում է ճիշտ մեկ կետ '.' \/\/ - Փաստաթղթի անվանումը չպետք է ունենա ավելի քան երեք թվանշան ('0'-'9 '): \/\/ հանդիպում են: \/\/ Ֆայլի անունը համարվում է վավեր, եթե եւ միայն եթե բոլոր հետեւյալ պայմանները կատարվում են:\/\/ \"Այո\", եթե ֆայլի անունը վավեր է, եւ այլ դեպքում վերադարձնում է \"Ոչ\"\/\/ Ստեղծեք ֆունկցիա, որը վերցնում է ֆայլի անվանումը ներկայացնող տող եւ վերադարձնում է \/\/\/ >>> file_name_check(file_name: \"example.txt\")\n\/\/\/ \"Yes\"\n\/\/\/ >>> file_name_check(file_name: \"1example.dll\")\n\/\/\/ \"No\"\nfunc file_name_check(file_name: String) -> String {\n","canonical_solution":"func file_name_check(file_name: String) -> String {\n    \/\/ Split by the dot.\n    let components = file_name.split(separator: \".\", omittingEmptySubsequences: false)\n    \n    \/\/ Check if there's exactly one dot.\n    guard components.count == 2 else {\n        return \"No\"\n    }\n    \n    \/\/ Extract the prefix and suffix.\n    let prefix = String(components[0])\n    let suffix = String(components[1])\n    \n    \/\/ Check if the prefix is non-empty and starts with a letter.\n    guard !prefix.isEmpty, let firstChar = prefix.first, firstChar.isLetter else {\n        return \"No\"\n    }\n    \n    \/\/ Check if the suffix is one of the allowed types.\n    let validSuffixes = [\"txt\", \"exe\", \"dll\"]\n    guard validSuffixes.contains(suffix) else {\n        return \"No\"\n    }\n    \n    \/\/ Count digits in the file name.\n    let digitCount = file_name.filter { $0.isNumber }.count\n    \n    \/\/ Ensure that there are not more than 3 digits.\n    guard digitCount <= 3 else {\n        return \"No\"\n    }\n    \n    \/\/ If all checks pass, it's a valid file name.\n    return \"Yes\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(file_name_check(file_name: \"example.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"1example.dll\") == \"No\")\nassert(file_name_check(file_name: \"s1sdf3.asd\") == \"No\")\nassert(file_name_check(file_name: \"K.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"MY16FILE3.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"His12FILE94.exe\") == \"No\")\nassert(file_name_check(file_name: \"_Y.txt\") == \"No\")\nassert(file_name_check(file_name: \"?aREYA.exe\") == \"No\")\nassert(file_name_check(file_name: \"\/this_is_valid.dll\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.wow\") == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"this_is_valid.txtexe\") == \"No\")\nassert(file_name_check(file_name: \"#this2_i4s_5valid.ten\") == \"No\")\nassert(file_name_check(file_name: \"@this1_is6_valid.exe\") == \"No\")\nassert(file_name_check(file_name: \"this_is_12valid.6exe4.txt\") == \"No\")\nassert(file_name_check(file_name: \"all.exe.txt\") == \"No\")\nassert(file_name_check(file_name: \"I563_No.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"Is3youfault.txt\") == \"Yes\")\nassert(file_name_check(file_name: \"no_one#knows.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"1I563_Yes3.exe\") == \"No\")\nassert(file_name_check(file_name: \"I563_Yes3.txtt\") == \"No\")\nassert(file_name_check(file_name: \"final..txt\") == \"No\")\nassert(file_name_check(file_name: \"final132\") == \"No\")\nassert(file_name_check(file_name: \"_f4indsartal132.\") == \"No\")\nassert(file_name_check(file_name: \".txt\") == \"No\")\nassert(file_name_check(file_name: \"s.\") == \"No\")"},{"task_id":"HumanEval_143","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ 1: \/\/ նոր տողում բառերի կարգը պետք է նույնը լինի, ինչ սկզբնականը:\/\/ որի երկարությունը պարզ թվեր են, \/\/ եւ դուք պետք է վերադարձնեք մի տող, որը պարունակում է բառերը սկզբնական նախադասությունից, \/\/ նախադասությունը պարունակում է որոշ բառեր, որոնք բաժանված են տարածությամբ, \/\/ Ձեզ տրվում է նախադասություն ներկայացնող տող, \/\/\/ >>> words_in_sentence(sentence: \"This is a test\")\n\/\/\/ \"is\"\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(sentence: \"lets go for swimming\")\n\/\/\/ \"go for\"\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence: String) -> String {\n","canonical_solution":"func words_in_sentence(sentence: String) -> String {\n    func isPrime(_ n: Int) -> Bool {\n        if n <= 1 { return false }\n        if n <= 3 { return true }\n        if n % 2 == 0 || n % 3 == 0 { return false }\n        var i = 5\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 { return false }\n            i += 6\n        }\n        return true\n    }\n    \n    let words = sentence.split(separator: \" \")\n    let primeLengthWords = words.filter { isPrime($0.count) }\n    return primeLengthWords.joined(separator: \" \")\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"},{"task_id":"HumanEval_144","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Դուք կարող եք ենթադրել, որ x-ը եւ n-ը վավեր կոտորակներ են, եւ չունեն զրոյին որպես անվանիչ:\/\/ <հաշվիչ>\/<հիշատակ> որտեղ եւ՛ թվատուն եւ՛ անվանիչը դրական ամբողջ թվեր են: \/\/ այլապես: x-ը եւ n-ը կոտորակի շարային ներկայացում են եւ ունեն հետեւյալ ձեւաչափը, \/\/ x * n: Ֆունկցիան true է վերադարձնում, եթե x * n-ը ամբողջ թիվ է եւ false:\/\/ Ձեր խնդիրն է գործարկել մի ֆունկցիա, որը պարզեցնելու է արտահայտությունը:\/\/\/ >>> simplify(x: \"1\/5\", n: \"5\/1\")\n\/\/\/ true\n\/\/\/ >>> simplify(x: \"1\/6\", n: \"2\/1\")\n\/\/\/ false\n\/\/\/ >>> simplify(x: \"7\/10\", n: \"10\/2\")\n\/\/\/ false\nfunc simplify(x: String, n: String) -> Bool {\n","canonical_solution":"func simplify(x: String, n: String) -> Bool {\n    func parseFraction(fraction: String) -> (numerator: Int, denominator: Int) {\n        let parts = fraction.split(separator: \"\/\").map { Int($0)! }\n        return (numerator: parts[0], denominator: parts[1])\n    }\n    \n    let (xNumerator, xDenominator) = parseFraction(fraction: x)\n    let (nNumerator, nDenominator) = parseFraction(fraction: n)\n    \n    \/\/ Multiply the two fractions: (xNumerator * nNumerator) \/ (xDenominator * nDenominator)\n    let resultNumerator = xNumerator * nNumerator\n    let resultDenominator = xDenominator * nDenominator\n    \n    \/\/ Check if the resulting fraction is a whole number by verifying if the numerator is divisible by the denominator\n    return resultNumerator % resultDenominator == 0\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/6\", n: \"2\/1\") == false)\nassert(simplify(x: \"5\/1\", n: \"3\/1\") == true)\nassert(simplify(x: \"7\/10\", n: \"10\/2\") == false)\nassert(simplify(x: \"2\/10\", n: \"50\/10\") == true)\nassert(simplify(x: \"7\/2\", n: \"4\/2\") == true)\nassert(simplify(x: \"11\/6\", n: \"6\/1\") == true)\nassert(simplify(x: \"2\/3\", n: \"5\/2\") == false)\nassert(simplify(x: \"5\/2\", n: \"3\/5\") == false)\nassert(simplify(x: \"2\/4\", n: \"8\/4\") == true)\nassert(simplify(x: \"2\/4\", n: \"4\/2\") == true)\nassert(simplify(x: \"1\/5\", n: \"5\/1\") == true)\nassert(simplify(x: \"1\/5\", n: \"1\/5\") == false)"},{"task_id":"HumanEval_145","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ կարգավորել դրանք ըստ իրենց ինդեքսի սկզբնական շարքում: \/\/ Նշում. եթե կան մի քանի կետեր, որոնց թվանշանների գումարը նման է, ապա \/\/ ըստ թվանշանների գումարման աճող կարգով: \/\/ Գրեք ֆունկցիա, որը դասակարգում է ամբողջ թվերի տրված շարքը:\/\/\/ >>> order_by_points(nums: [1, 11, -1, -11, -12])\n\/\/\/ [-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(nums: [] as [Int])\n\/\/\/ [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n","canonical_solution":"func order_by_points(nums: [Int]) -> [Int] {\n    return nums.enumerated().sorted {\n        let sum1 = digitSum($0.element)\n        let sum2 = digitSum($1.element)\n        if sum1 == sum2 {\n            return $0.offset < $1.offset\n        } else {\n            return sum1 < sum2\n        }\n    }.map { $0.element }\n}\n\nfunc digitSum(_ number: Int) -> Int {\n    return String(abs(number)).compactMap { Int(String($0)) }.reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"},{"task_id":"HumanEval_146","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ թվերի առաջին եւ վերջին թվանշանները զույգ են (1, 3, 5, 7, 9) ։\/\/ այն տարրերի թիվը, որոնք ավելի մեծ են 10-ից եւ երկուսն էլ \/\/ Գրեք ֆունկցիա, որը թվերի շարք է ընդունում որպես մուտք եւ վերադարձում է \/\/\/ >>> specialFilter(nums: [15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(nums: [33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfunc specialFilter(nums: [Int]) -> Int {\n","canonical_solution":"func specialFilter(nums: [Int]) -> Int {\n    return nums.filter { num in\n        let absNum = abs(num)\n        \n        guard absNum > 10 else {\n            return false\n        }\n        \n        let firstDigit = String(String(absNum).first!)\n        let lastDigit = String(absNum % 10)\n        \n        let oddDigits: Set = [\"1\", \"3\", \"5\", \"7\", \"9\"]\n        \n        return oddDigits.contains(firstDigit) && oddDigits.contains(lastDigit)\n    }.count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(specialFilter(nums: [5, -2, 1, -5]) == 0)\nassert(specialFilter(nums: [15, -73, 14, -15]) == 1)\nassert(specialFilter(nums: [33, -2, -3, 45, 21, 109]) == 2)\nassert(specialFilter(nums: [43, -12, 93, 125, 121, 109]) == 4)\nassert(specialFilter(nums: [71, -2, -33, 75, 21, 19]) == 3)\nassert(specialFilter(nums: [1]) == 0)\nassert(specialFilter(nums: [] as [Int]) == 0)"},{"task_id":"HumanEval_147","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ եւ a[i] + a[j] + a[k] -ը 3 -ի բազմապատիկն է: \/\/ Վերադարձնում է a-ի եռապատիկների թիվը (a[i], a[j], a[k]) որտեղ i < j < k, \/\/ Յուրաքանչյուր i-ի համար (1 ≤ i ≤ n), a[i] = i * i - i + 1-ի արժեքը: \/\/ Ձեզ տրված է դրական ամբողջ թիվ n: Դուք պետք է ստեղծեք ամբողջ թվերի շարք a երկարությամբ n: \/\/\/ >>> get_max_triples(n: 5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n: Int) -> Int {\n","canonical_solution":"func get_max_triples(n: Int) -> Int {\n    \/\/ Create the array a based on the problem description\n    var a = [Int](repeating: 0, count: n)\n    for i in 1...n {\n        a[i - 1] = i * i - i + 1\n    }\n    \n    var count = 0\n    \/\/ Check for all possible triples\n    for i in 0..<n {\n        for j in (i + 1)..<n {\n            for k in (j + 1)..<n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1\n                }\n            }\n        }\n    }\n    \n    return count\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_max_triples(n: 5) == 1)\nassert(get_max_triples(n: 6) == 4)\nassert(get_max_triples(n: 10) == 36)\nassert(get_max_triples(n: 100) == 53361)"},{"task_id":"HumanEval_149","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ Դուք կարող եք ենթադրել, որ բոլոր բառերը նույն երկարությունը կունենան: \/\/ Ֆունկցիան պետք է վերադարձնի շարքերի շարքը կարգավորված կարգով: \/\/ Եթե երկու բառերն ունեն նույն երկարությունը, ապա դասակարգեք շարքը այբուբենական կարգով: \/\/ պետք է վերադարձնի այդ կանոնով դասավորված զանգվածը: \/\/ Մասնակիցների շարքը պետք է բարձրանա յուրաքանչյուր բառի երկարությամբ, եւ դուք կստանաք\/\/ եւ կարող է կրկնօրինակներ պարունակել: \/\/ Արիը միշտ շարքերի շարք է եւ երբեք թվերի շարք, \/\/ եւ վերադարձնում է արդյունքային զանգվածը կարգավորված կարգով, \/\/ ջնջում է այն տողերը, որոնք ունեն անհավասար երկարություններ, \/\/ Գրեք ֆունկցիա, որը որպես պարամետր ընդունում է տողերի շարք, \/\/\/ >>> sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"])\n\/\/\/ [\"aa\"]\n\/\/\/ >>> sorted_list_sum(lst: [\"ab\", \"a\", \"aaa\", \"cd\"])\n\/\/\/ [\"ab\", \"cd\"]\nfunc sorted_list_sum(lst: [String]) -> [String] {\n","canonical_solution":"func sorted_list_sum(lst: [String]) -> [String] {\n    return lst.filter { $0.count % 2 == 0 }\n              .sorted { \n                  if $0.count == $1.count {\n                      return $0 < $1\n                  }\n                  return $0.count < $1.count\n              }\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sorted_list_sum(lst: [\"aa\", \"a\", \"aaa\"]) == [\"aa\"])\nassert(sorted_list_sum(lst: [\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"])\nassert(sorted_list_sum(lst: [\"d\", \"b\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"])\nassert(sorted_list_sum(lst: [\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"])\nassert(sorted_list_sum(lst: [\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == [] as [String])\nassert(sorted_list_sum(lst: [\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"])"},{"task_id":"HumanEval_150","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ պարզ թիվ է եւ պետք է վերադարձնի y-ի արժեքը այլ կերպ: \/\/ Պարզ ծրագիր, որը պետք է վերադարձնի x-ի արժեքը, եթե n-ը  է:\/\/\/ >>> x_or_y(n: 7, x: 34, y: 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(n: 15, x: 8, y: 5)\n\/\/\/ 5\nfunc x_or_y(n: Int, x: Int, y: Int) -> Int {\n","canonical_solution":"func x_or_y(n: Int, x: Int, y: Int) -> Int {\n    func isPrime(_ number: Int) -> Bool {\n        if number <= 1 { return false }\n        if number <= 3 { return true }\n        if number % 2 == 0 || number % 3 == 0 { return false }\n        \n        var i = 5\n        while i * i <= number {\n            if number % i == 0 || number % (i + 2) == 0 {\n                return false\n            }\n            i += 6\n        }\n        return true\n    }\n    \n    return isPrime(n) ? x : y\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(x_or_y(n: 7, x: 34, y: 12) == 34)\nassert(x_or_y(n: 15, x: 8, y: 5) == 5)\nassert(x_or_y(n: 3, x: 33, y: 5212) == 33)\nassert(x_or_y(n: 1259, x: 3, y: 52) == 3)\nassert(x_or_y(n: 7919, x: -1, y: 12) == -1)\nassert(x_or_y(n: 3609, x: 1245, y: 583) == 583)\nassert(x_or_y(n: 91, x: 56, y: 129) == 129)\nassert(x_or_y(n: 6, x: 34, y: 1234) == 1234)\nassert(x_or_y(n: 1, x: 2, y: 0) == 0)\nassert(x_or_y(n: 2, x: 2, y: 0) == 2)"},{"task_id":"HumanEval_151","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ անհավասար թվերը շարքում: Անտեսեք այն թվերը, որոնք բացասական են կամ ամբողջ թվեր չեն:\/\/ Տված թվերի շարքը, վերադարձնում է թվերի քառակուսիների գումարը:\/\/\/ >>> double_the_difference(lst: [1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(lst: [-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(lst: [9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(lst: [0])\n\/\/\/ 0\n\/\/\/ If the input array is empty, return 0.\nfunc double_the_difference(lst: [Double]) -> Int {\n","canonical_solution":"func double_the_difference(lst: [Double]) -> Int {\n    return lst.filter { $0 >= 0 && $0 == floor($0) && Int($0) % 2 != 0 }\n              .map { Int($0) * Int($0) }\n              .reduce(0, +)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(double_the_difference(lst: [] as [Double]) == 0)\nassert(double_the_difference(lst: [5.0, 4.0]) == 25)\nassert(double_the_difference(lst: [0.1, 0.2, 0.3]) == 0)\nassert(double_the_difference(lst: [-10.0, -20.0, -30.0]) == 0)\nassert(double_the_difference(lst: [-1.0, -2.0, 8.0]) == 0)\nassert(double_the_difference(lst: [0.2, 3.0, 5.0]) == 34)\nassert(double_the_difference(lst: [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165)"},{"task_id":"HumanEval_152","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ օրինակ: \/\/ արժեքը 0 է, եւ եթե ոչ, ապա արժեքը ենթադրության եւ միավորի միջեւ բացարձակ տարբերությունն է: \/\/ Վերադարձնում է նույն երկարության զանգված, որը ցույց է տալիս, թե որքան հեռու է յուրաքանչյուր ենթադրությունը: Եթե նրանք ճիշտ են ենթադրել, ապա \/\/ Ձեզ տրվում է հավասար երկարության երկու գնահատականների եւ ենթադրությունների շարք, որտեղ յուրաքանչյուր ցուցիչ ցույց է տալիս համապատասխանություն: \/\/ Ձեր խնդիրն է պարզել, թե արդյոք մարդը ճիշտ է գուշակել մի շարք խաղերի արդյունքները:\/\/ Անկասկած արժե նշել եւ համեմատել:Այն ամենը, ինչ դուք զգում եք եւ մտածում այդ պահին,\/ Կարծում եմ, որ բոլորս էլ հիշում ենք այն զգացողությունը, երբ երկար սպասվածի արդյունքը \/\/\/\/ >>> compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2])\n\/\/\/ [0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(game: [0, 5, 0, 0, 0, 4], guess: [4, 1, 1, 0, 0, -2])\n\/\/\/ [4, 4, 1, 0, 0, 6]\nfunc compare(game: [Int], guess: [Int]) -> [Int] {\n","canonical_solution":"func compare(game: [Int], guess: [Int]) -> [Int] {\n    var result: [Int] = []\n    \n    for i in 0..<game.count {\n        let difference = abs(game[i] - guess[i])\n        result.append(difference)\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(compare(game: [1, 2, 3, 4, 5, 1], guess: [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3])\nassert(compare(game: [0, 0, 0, 0, 0, 0], guess: [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0])\nassert(compare(game: [1, 2, 3], guess: [-1, -2, -3]) == [2, 4, 6])\nassert(compare(game: [1, 2, 3, 5], guess: [-1, 2, 3, 4]) == [2, 0, 0, 1])"},{"task_id":"HumanEval_153","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ (այն ուժգնությունը -1 է) \/\/ վերադարձնում է \"Slices.SERVINGSliCes\", քանի որ \"SERVINGSliCes\" -ը ամենաուժեղ ընդլայնումն է:\/\/ ընդլայնումներ: ['SErviNGSliCes', 'Cheese', 'StuFfed'], ապա դուք պետք է \/\/ Օրինակ, եթե ձեզ տրված է \"Slices\" որպես դաս եւ array of the \/\/ ընտրեք այն, որը առաջինն է արշավում:\/\/ Եթե կա երկու կամ ավելի երկարաձգումներ նույն ուժի, դուք պետք է \/\/ ձեւաչափ: ClassName.StrongestExtensionName. \/\/ Դուք պետք է գտնեք ամենաուժեղ ընդլայնումը եւ վերադարձնեք սցենարը այստեղ \/\/ ընդլայնման անվանումում ուժը տրվում է CAP - SM կոտրվածքով: \/\/ նիշերը ընդլայնման անվանումում, եւ թող SM-ը լինի փոքր տառերի թիվը:\/\/ ընդլայնման ուժը հետեւյալն է. թող CAP- ը լինի մեծամասնական թվերը:\/\/ Ընդլայնումները պետք է օգտագործվեն դասի լրացուցիչ դասեր ներբեռնելու համար:\/\/ Ձեզ կներկայացվի դասի անուն (հղում) եւ ընդլայնումների զանգված: \/\/\/ >>> Strongest_Extension(class_name: \"my_class\", extensions: [\"AA\", \"Be\", \"CC\"])\n\/\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name: String, extensions: [String]) -> String {\n","canonical_solution":"func Strongest_Extension(class_name: String, extensions: [String]) -> String {\n    var strongestExtension: String? = nil\n    var maxStrength = Int.min\n    \n    for ext in extensions {\n        let cap = ext.filter { $0.isUppercase }.count\n        let sm = ext.filter { $0.isLowercase }.count\n        let strength = cap - sm\n        \n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = ext\n        }\n    }\n    \n    if let strongestExt = strongestExtension {\n        return \"\\(class_name).\\(strongestExt)\"\n    }\n    \n    return class_name\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"},{"task_id":"HumanEval_154","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Ձեզ տրված է 2 բառ: Դուք պետք է վերադարձնեք true, եթե երկրորդ բառը կամ դրա ցանկացած պտույտ առաջին բառի ենթաշարն է:\/\/\/ >>> cycpattern_check(a: \"abcd\", b: \"abd\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"hello\", b: \"ell\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"whassup\", b: \"psus\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"abab\", b: \"baa\")\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(a: \"efef\", b: \"eeff\")\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(a: \"himenss\", b: \"simen\")\n\/\/\/ true\nfunc cycpattern_check(a: String, b: String) -> Bool {\n","canonical_solution":"func cycpattern_check(a: String, b: String) -> Bool {\n    guard !b.isEmpty else { return true }\n    let bCombined = b + b\n    for i in 0..<b.count {\n        let rotation = String(bCombined.dropFirst(i).prefix(b.count))\n        if a.contains(rotation) {\n            return true\n        }\n    }\n    return false\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cycpattern_check(a: \"xyzw\", b: \"xyw\") == false)\nassert(cycpattern_check(a: \"yello\", b: \"ell\") == true)\nassert(cycpattern_check(a: \"whattup\", b: \"ptut\") == false)\nassert(cycpattern_check(a: \"efef\", b: \"fee\") == true)\nassert(cycpattern_check(a: \"abab\", b: \"aabb\") == false)\nassert(cycpattern_check(a: \"winemtt\", b: \"tinem\") == true)"},{"task_id":"HumanEval_155","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ Տված ամբողջական թիվը, վերադարձնում է մի տուպլ, որը պարունակում է համապատասխանաբար զույգ եւ անհավասար թվանշաններ: \/\/\/ >>> even_odd_count(num: -12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(num: 123)\n\/\/\/ (1, 2)\nfunc even_odd_count(num: Int) -> (Int, Int) {\n","canonical_solution":"func even_odd_count(num: Int) -> (Int, Int) {\n    var countEvens = 0\n    var countOdds = 0\n    var number = abs(num) \/\/ Handle negative numbers by taking absolute value\n\n    while number > 0 {\n        let digit = number % 10\n        if digit % 2 == 0 {\n            countEvens += 1\n        } else {\n            countOdds += 1\n        }\n        number \/= 10\n    }\n    return (countEvens, countOdds)\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_odd_count(num: 7) == (0, 1))\nassert(even_odd_count(num: -78) == (1, 1))\nassert(even_odd_count(num: 3452) == (2, 2))\nassert(even_odd_count(num: 346211) == (3, 3))\nassert(even_odd_count(num: -345821) == (3, 3))\nassert(even_odd_count(num: -2) == (1, 0))\nassert(even_odd_count(num: -45347) == (2, 3))\nassert(even_odd_count(num: 0) == (1, 0))"},{"task_id":"HumanEval_156","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ: \/\/ Սահմանափակումներ. 1 <= num <= 1000 \/\/ եւ վերադարձնել այն փոքր տառերով: \/\/ Տված դրական ամբողջ թիվը, ստացեք նրա հռոմեական թվային հավասարումը որպես տող, \/\/\/ >>> int_to_mini_roman(number: 19)\n\/\/\/ \"xix\"\n\/\/\/ >>> int_to_mini_roman(number: 152)\n\/\/\/ \"clii\"\n\/\/\/ >>> int_to_mini_roman(number: 426)\n\/\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number: Int) -> String {\n","canonical_solution":"func int_to_mini_roman(number: Int) -> String {\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    \n    var num = number\n    var result = \"\"\n    \n    for (index, value) in values.enumerated() {\n        while num >= value {\n            result += numerals[index]\n            num -= value\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"},{"task_id":"HumanEval_157","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ 90 աստիճան: \/\/ Ուղիղ անկյունային եռանկյունը եռանկյուն է, որի մեկ անկյունը ուղիղ անկյուն է կամ \/\/ կողմերը ձեւավորում են ուղղանկյուն եռանկյուն, այլապես սխալ է:\/\/ Տված են եռանկյան երեք կողմերի երկարությունները: Վերադարձեք true, եթե երեքը \/\/\/ >>> right_angle_triangle(a: 3, b: 4, c: 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(a: 1, b: 2, c: 3)\n\/\/\/ false\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n","canonical_solution":"func right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n    let sides = [a, b, c].sorted()\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(right_angle_triangle(a: 3, b: 4, c: 5) == true)\nassert(right_angle_triangle(a: 1, b: 2, c: 3) == false)\nassert(right_angle_triangle(a: 10, b: 6, c: 8) == true)\nassert(right_angle_triangle(a: 2, b: 2, c: 2) == false)\nassert(right_angle_triangle(a: 7, b: 24, c: 25) == true)\nassert(right_angle_triangle(a: 10, b: 5, c: 7) == false)\nassert(right_angle_triangle(a: 5, b: 12, c: 13) == true)\nassert(right_angle_triangle(a: 15, b: 8, c: 17) == true)\nassert(right_angle_triangle(a: 48, b: 55, c: 73) == true)\nassert(right_angle_triangle(a: 1, b: 1, c: 1) == false)\nassert(right_angle_triangle(a: 2, b: 2, c: 10) == false)"},{"task_id":"HumanEval_158","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ նիշերը, վերադարձնում է այն, որը առաջ է գալիս բառաբանական կարգով: \/\/ եզակի նիշերի: Եթե բազմաթիվ տողեր ունեն առավելագույն թվով եզակի նիշեր:\/\/ Արիը պարունակում է տարբեր բառեր: Վերադարձնում է բառը առավելագույն թվով:\/\/ Գրեք ֆունկցիա, որը ընդունում է տողերի շարք:\/\/\/ >>> find_max(words: [\"name\", \"of\", \"string\"])\n\/\/\/ \"string\"\n\/\/\/ >>> find_max(words: [\"name\", \"enam\", \"game\"])\n\/\/\/ \"enam\"\n\/\/\/ >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n\/\/\/ \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n","canonical_solution":"func find_max(words: [String]) -> String {\n    func uniqueCharacterCount(in word: String) -> Int {\n        return Set(word).count\n    }\n    \n    return words.max { a, b in\n        let uniqueCountA = uniqueCharacterCount(in: a)\n        let uniqueCountB = uniqueCharacterCount(in: b)\n        \n        if uniqueCountA == uniqueCountB {\n            return a > b\n        }\n        \n        return uniqueCountA < uniqueCountB\n    } ?? \"\"\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"},{"task_id":"HumanEval_159","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ: \/\/ եթե մնացած գազարները բավարար չեն, ապա կուտեք մնացած գազարները, բայց դեռ սոված կլինեք:\/ \/ Ձեր ճաշից հետո մնացած գազարների քանակը ] \/\/\/ պետք է վերադարձնել մի շարք [ ուտված գազարների ընդհանուր թիվը ձեր ճաշից հետո, Բայց հիմա դուք պետք է ուտեք ավելի շատ գազարներ, որպեսզի ավարտեք օրվա սնունդը:\/\/ Դուք սոված ճագար եք, եւ դուք արդեն կերել եք որոշակի քանակությամբ գազարներ, \/\/\/ >>> eat(number: 5, need: 6, remaining: 10)\n\/\/\/ [11, 4]\n\/\/\/ >>> eat(number: 4, need: 8, remaining: 9)\n\/\/\/ [12, 1]\n\/\/\/ >>> eat(number: 1, need: 10, remaining: 10)\n\/\/\/ [11, 0]\n\/\/\/ >>> eat(number: 2, need: 11, remaining: 5)\n\/\/\/ [7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfunc eat(number: Int, need: Int, remaining: Int) -> [Int] {\n","canonical_solution":"func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalNeeded = number + need\n    let totalEaten = min(totalNeeded, number + remaining)\n    let carrotsLeft = max(0, remaining - (totalEaten - number))\n    return [totalEaten, carrotsLeft]\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"},{"task_id":"HumanEval_160","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օպերատորների շարքը ունի առնվազն մեկ օպերատոր, եւ օպերանդների շարքը ունի առնվազն երկու օպերանդ: \/\/ Օպերանդը ոչ բացասական ամբողջ թվերի շարք է: \/\/ Օպերատորների շարքի երկարությունը հավասար է օպերանդների շարքի երկարությանը՝ մեկի բացառումով: \/\/ Նշում: \/\/ => արդյունքը = 9 \/\/ արդյունքը = 2 + 3 * 4 - 5 \/\/ array = [2, 3, 4, 5] \/\/ օպերատոր['+', '*', '-'] \/\/ Օրինակ: \/\/ Հատկապատկում (**) \/\/ Բաժանման հատակ ( \/\/ ) \/\/ Բազմապատկում (*) \/\/ Բաժանում ( - ) \/\/ Բարձրացում (+) \/\/ Ալգեբրայի հիմնական գործառույթները: \/\/ արտահայտություն եւ վերադարձնել այդ արտահայտության գնահատումը: \/\/ երկրորդ շարքը ամբողջ թվերի շարք է: Օգտագործեք երկու տրված շարքերը ՝ ալգեբրիկ կառուցելու համար:\/\/ Տված են երկու շարքերի օպերատոր եւ օպերանդ: Առաջին շարքը պարունակում է հիմնական ալգեբրային գործողություններ, եւ func do_algebra(operator: [String], operand: [Int]) -> Int {\n","canonical_solution":"func do_algebra(operator: [String], operand: [Int]) -> Int {\n    var result = operand[0]\n    let precedence: [String: Int] = [\"+\": 1, \"-\": 1, \"*\": 2, \"\/\/\": 2, \"**\": 3]\n    \n    var opStack: [String] = []\n    var numStack: [Int] = [result]\n    \n    func applyOperator(_ op: String, _ b: Int, _ a: Int) -> Int {\n        switch op {\n        case \"+\":\n            return a + b\n        case \"-\":\n            return a - b\n        case \"*\":\n            return a * b\n        case \"\/\/\":\n            return a \/ b\n        case \"**\":\n            return Int(pow(Double(a), Double(b)))\n        default:\n            fatalError(\"Unsupported operator: \\(op)\")\n        }\n    }\n    \n    for i in 0..<operator.count {\n        let currentOp = `operator`[i]\n        let currentNum = operand[i + 1]\n        \n        while let lastOp = opStack.last, precedence[lastOp]! >= precedence[currentOp] {\n            opStack.removeLast()\n            let b = numStack.removeLast()\n            let a = numStack.removeLast()\n            numStack.append(applyOperator(lastOp, b, a))\n        }\n        \n        opStack.append(currentOp)\n        numStack.append(currentNum)\n    }\n    \n    while let lastOp = opStack.popLast() {\n        let b = numStack.removeLast()\n        let a = numStack.removeLast()\n        numStack.append(applyOperator(lastOp, b, a))\n    }\n    \n    return numStack.first!\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(do_algebra(operator: [\"**\", \"*\", \"+\"], operand: [2, 3, 4, 5]) == 37)\nassert(do_algebra(operator: [\"+\", \"*\", \"-\"], operand: [2, 3, 4, 5]) == 9)\nassert(do_algebra(operator: [\"\/\/\", \"*\"], operand: [7, 3, 4]) == 8)"},{"task_id":"HumanEval_161","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակներ \/\/ Ֆունկցիան պետք է վերադարձնի ստացված տողը: \/\/ Եթե տողն առանց տառերի է, ապա տողը հակառակ ուղղությամբ:\/\/ հակառակ դեպքում թողնել այն, ինչպես կա:\/\/ եթե s[i]-ը տառ է, ապա վերադարձեք նրա տողը ներքեւից վերեւ կամ հակառակը, \/\/ Ձեզ տրվում է string s. \/\/\/ >>> solve(s: \"1234\")\n\/\/\/ \"4321\"\n\/\/\/ >>> solve(s: \"ab\")\n\/\/\/ \"AB\"\n\/\/\/ >>> solve(s: \"#a@C\")\n\/\/\/ \"#A@c\"\nfunc solve(s: String) -> String {\n","canonical_solution":"func solve(s: String) -> String {\n    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n    \n    var result = \"\"\n    for char in s {\n        if char.isLetter {\n            if char.isLowercase {\n                result.append(char.uppercased())\n            } else {\n                result.append(char.lowercased())\n            }\n        } else {\n            result.append(char)\n        }\n    }\n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"},{"task_id":"HumanEval_162","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Եթե 'text' դատարկ տող է, վերադարձեք null: \/\/ Տված տող 'text', վերադարձնել md5 hash հավասարազոր տողը: \/\/\/ >>> string_to_md5(text: \"Hello world\")\n\/\/\/ \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunc string_to_md5(text: String) -> String? {\n","canonical_solution":"import Foundation\nimport CommonCrypto\n\nfunc string_to_md5(text: String) -> String? {\n    guard !text.isEmpty else { return nil }\n    \n    let length = Int(CC_MD5_DIGEST_LENGTH)\n    let messageData = text.data(using: .utf8)!\n    var digestData = Data(count: length)\n    \n    _ = digestData.withUnsafeMutableBytes { digestBytes in\n        messageData.withUnsafeBytes { messageBytes in\n            CC_MD5(messageBytes.baseAddress, CC_LONG(messageData.count), digestBytes.bindMemory(to: UInt8.self).baseAddress)\n        }\n    }\n    \n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\nassert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\nassert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\")"},{"task_id":"HumanEval_163","nl":"hye_Armn","pl":"swift","prompt":"\n\/\/ Օրինակ ՝\/\/ եւ բ, աճող կարգով: \/\/ Տված երկու դրական ամբողջ թվեր a եւ b, վերադարձնել զույգ թվանշանները a \/\/\/ >>> generate_integers(a: 2, b: 8)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 8, b: 2)\n\/\/\/ [2, 4, 6, 8]\n\/\/\/ >>> generate_integers(a: 10, b: 14)\n\/\/\/ [] as [Int]\nfunc generate_integers(a: Int, b: Int) -> [Int] {\n","canonical_solution":"func generate_integers(a: Int, b: Int) -> [Int] {\n    let lower = min(a, b)\n    let upper = max(a, b)\n    var result = [Int]()\n    \n    for number in lower...upper {\n        if number % 2 == 0 {\n            result.append(number)\n        }\n    }\n    \n    return result\n}","tests":"}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(generate_integers(a: 2, b: 10) == [2, 4, 6, 8])\nassert(generate_integers(a: 10, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 132, b: 2) == [2, 4, 6, 8])\nassert(generate_integers(a: 17, b: 89) == [] as [Int])"}]