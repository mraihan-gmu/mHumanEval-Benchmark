task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚད་གཞི་འདི་ ཚད་གཞི་འདི་ཨིན།    //ཨང་གྲངས་ཀྱི་ཐོ་ནང་ ཟེར་བ་ལས་ ཟེར་བའི་ཨང་གྲངས་གཉིས་ གཅིག་དང་གཅིག་ཉེ་བའི་ནང་ཡོད་མེད་བལྟ་།    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))
    // (false)
    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))
    // (true)
    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {
","def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {
      val sortedNumbers = numbers.sorted
      for (i <- 1 until sortedNumbers.length) {
        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {
          return true
        }
      }
      false
    }
}","    }
    def main(args: Array[String]) = {
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));
    }

}
"
HumanEval_1,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་བསྐྱོད་ཐིག་ནང་ བར་སྟོང་ཚུ་སྣང་མེད་སྦེ་བཞག་དགོ།    //སྡེ་ཚན་སོ་སོ་འདི་ ཚད་ལྡན་ (སྒོ་ཕྱེ་ཡོད་པའི་རྒྱབ་ལག་རེ་རེ་འདི་ ལེགས་ཤོམ་སྦེ་བསྡམས་ཏེ་ཡོདཔ་) དང་ གཅིག་གིས་གཅིག་ལུ་ སྦྲེལ་མ་རྐྱབ་པར་ཡོདཔ་ཨིན།    //ཕྲ་རིང་འདི་ནང་ ཕྲ་རིང་གི་མིང་ཚུ་དབྱེ་བ་ཕྱེ་ཞིནམ་ལས་ ཕྲ་རིང་གི་མིང་ཚུ་ལོག་གཏང་།    //འ་ནི་ལས་འགན་ནང་ ནང་ཐིག་འདི་ ནང་སྡུད་འབད་མི་ ལྡེ་མིག་གི་སྡེ་ཚན་ལེ་ཤ་ཡོད་པའི་ཐིག་ཁྲམ་ཨིན། ཁྱོད་ཀྱི་དམིགས་གཏད་འདི་     // >>> separateParenGroups((""( ) (( )) (( )( ))""))
    // (List[String](""()"", ""(())"", ""(()())""))
    def separateParenGroups(paren_string : String) : List[String] = {
","def separateParenGroups(paren_string: String): List[String] = {
    val result = ListBuffer[String]()
    val sanitizedInput = paren_string.replaceAll(""\\s"", """")
    var balance = 0
    var currentGroup = new StringBuilder()

    for (char <- sanitizedInput) {
        currentGroup.append(char)
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1

        if (balance == 0 && currentGroup.nonEmpty) {
            result += currentGroup.toString()
            currentGroup = new StringBuilder()
        }
    }

    result.toList
}","    }
    def main(args: Array[String]) = {
    assert(separateParenGroups((""(()()) ((())) () ((())()())"")).equals((List[String](""(()())"", ""((()))"", ""()"", ""((())()())""))));
    assert(separateParenGroups((""() (()) ((())) (((())))"")).equals((List[String](""()"", ""(())"", ""((()))"", ""(((())))""))));
    assert(separateParenGroups((""(()(())((())))"")).equals((List[String](""(()(())((())))""))));
    assert(separateParenGroups((""( ) (( )) (( )( ))"")).equals((List[String](""()"", ""(())"", ""(()())""))));
    }

}
"
HumanEval_2,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ཀྱི་བཅུ་ཆ་ཆ་འདི་སླར་ལོག་འབདཝ་ཨིན།    //(ལྷག་ལུས་ཆ་ཤས་འདི་ རྟག་བུ་རང་ ༡ ལས་ཆུང་བ་ཨིན།)    //ཨང་གྲངས་ཧྲིལ་བུམ་ (ཨང་གྲངས་སྦོམ་ཤོས་འདི་ བྱིན་ཡོད་པའི་ཨང་གྲངས་ལས་ཆུང་བ་) དང་ཨང་གྲངས་བཅུ་ཆ་ཚུ་ཨིན།    //འགྱུར་ལྡོག་ཅན་གྱི་ཆ་ཤས་ཨང་འདི་ཐོབ་པ་ཅིན་ ནང་ལུ་བཅགས་ཚུགས།    // >>> truncateNumber((3.5f))
    // (0.5f)
    def truncateNumber(number : Float) : Float = {
","val integerPart = number.floor
        val decimalPart = number - integerPart
        decimalPart.toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(truncateNumber((3.5f)) == (0.5f));
    assert(truncateNumber((1.25f)) == (0.25f));
    assert(truncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དེ་བསྒང་ལས་ function གིས་ true སླར་ལོག་འབད་ནི་ཨིན་མེན་ན་ false སླར་ལོག་འབད་ནི་ཨིན།    //ཁྱོད་ཀྱི་ལཱ་འདི་ ཚོད་བལྟ་འབད་དགོ འདི་ཡང་ ཚོད་བལྟ་འབད་དགོ    //ཁྱོད་ཀྱིས་ དངུལ་ཁང་གི་རྩིས་ཁྲ་ནང་ལས་ དངུལ་བཏོན་དང་བཙུགས་ཀྱི་ལཱ་གི་ཐོ་འདི་ ཟེར་འགོ་བཙུགས་ཏེ་ཐོབ་འོང་།    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (false)
    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))
    // (true)
    def belowZero(operations : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def belowZero(operations: List[Long]): Boolean = {
    var balance: Long = 0
    for (operation <- operations) {
      balance += operation
      if (balance < 0) {
        return true
      }
    }
    false
  }

  def main(args: Array[String]): Unit = {
    println(belowZero(List(1L, 2L, 3L)))         // false
    println(belowZero(List(1L, 2L, -4L, 5L)))    // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowZero((List[Long]())) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));
    }

}
"
HumanEval_4,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //MAD = average ཨིན། x - x_mean ཨིན།    //ཚད་གཞི་དང་ལྟེ་བ་ (གནས་སྟངས་འདི་ནང་ལུ་ མནོ་བསམ་བཏང་སྟེ་)    //ཚད་ལྡན་བར་ནའི་བར་སྟོང་འདི་ ཚད་ལྡན་བར་ནའི་བར་སྟོང་ཨིན།    //གནས་སྡུད་འདི་ནང་ལུ་ ཚད་གཞི་འདི་ ཚད་གཞི་གི་མཐའ་མར་ཡོདཔ་ཨིན།    //ནང་ཐིག་ཨང་གྲངས་ཀྱི་ཐོ་ཡིག་ཅིག་གི་དོན་ལུ་ མན་ངག་ཆ་མཉམ་གྱི་བར་ཚད་རྩིས་སྟོནམ་ཨིན།    // >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))
    // (1.0f)
    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {
","val mean = numbers.sum / numbers.size
    val deviations = numbers.map(num => math.abs(num - mean))
    val mad = deviations.sum / deviations.size
    mad
  }
}","    }
    def main(args: Array[String]) = {
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));
    }

}
"
HumanEval_5,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་ཐིག་གི་ཐོ་ཡིག་ནང་ཐིག་གཉིས་རེ་གི་བར་ན་ ཨང་གྲངས་ ""delimiter"" ཅིག་བཙུགས་དགོ།    // >>> intersperse((List[Long]()), (4l))
    // (List[Long]())
    // >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))
    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {
","if (numbers.isEmpty) {
        List()
      } else {
        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last
      }
    }
}","    }
    def main(args: Array[String]) = {
    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));
    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));
    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    }

}
"
HumanEval_6,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེར་ན་ (() (()) འདི་ནང་ལུ་ ཚང་བཟོ་ནིའི་གནས་ཚད་གཉིས་ཡོདཔ་དང་ ((())) འདི་ནང་ལུ་ ༣ ཡོདཔ་ཨིན།    //སྡེ་ཚན་རེ་རེ་བཞིན་དུ་ལུ་ ནང་ཐིག་གི་ཧེ་མའི་གནས་ཚད་འདི་བཏོན་དགོ།    //འ་ནི་ལས་འགན་ནང་ ཨང་གྲངས་ཐིག་ཁྲམ་འདི་ སྦྲེལ་ཡོད་པའི་སྒོ་སྒྲིག་གི་དོན་ལུ་ སྡེ་ཚན་ལེ་ཤ་ཅིག་ལུ་ ངོ་ཚབ་འབདཝ་ཨིན།    // >>> parseNestedParens((""(()()) ((())) () ((())()())""))
    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))
    def parseNestedParens(paren_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseNestedParens(paren_string: String): List[Long] = {
    paren_string.split("" "").toList.map { group =>
      var maxDepth = 0
      var currentDepth = 0
      group.foreach {
        case '(' => 
          currentDepth += 1
          maxDepth = max(maxDepth, currentDepth)
        case ')' => 
          currentDepth -= 1
      }
      maxDepth.toLong
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    val result = parseNestedParens(""(()()) ((())) () ((())()())"")
    println(s""Result: ${result.mkString("", "")}"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseNestedParens((""(()()) ((())) () ((())()())"")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(parseNestedParens((""() (()) ((())) (((())))"")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(parseNestedParens((""(()(())((())))"")).equals((List[Long](4l.toLong))));
    }

}
"
HumanEval_7,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་བསྐྱོད་ཐིག་གི་ཐོ་ཡིག་ནང་ལུ་ ཚད་འཛིན་ཐིག་གི་ཐོ་ཡིག་རྐྱངམ་ཅིག་ ཌའི་ལོག་ནང་ཐིག་ ཡོད་པའི་དོན་ལུ་ ཌའི་ལོག་ནང་ཐིག་ བཙུགས།    // >>> filterBySubstring((List[String]()), (""a""))
    // (List[String]())
    // >>> filterBySubstring((List[String](""abc"", ""bacd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""bacd"", ""array""))
    def filterBySubstring(strings : List[String], substring : String) : List[String] = {
","strings.filter(_.contains(substring))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterBySubstring((List[String]()), (""john"")).equals((List[String]())));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xx"")).equals((List[String](""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""grunt"", ""trumpet"", ""prune"", ""gruesome"")), (""run"")).equals((List[String](""grunt"", ""prune""))));
    }

}
"
HumanEval_8,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་སྟོངམ་འདི་ ༠ དང་ ཨང་གྲངས་སྟོངམ་ཐོན་སྐྱེད་འདི་ ༡ སྦེ་ཆ་མཉམ་འབད་དགོཔ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་ཅིག་གི་དོན་ལུ་ ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་ནང་ལུ་ ཨང་གྲངས་ཧྲིལ་བུའི་བསྡོམས་དང་ དབྱེ་བ་འདི་སླར་ལོག་འབདཝ་ཨིན།    // >>> sumProduct((List[Long]()))
    // ((0l, 1l))
    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // ((10l, 24l))
    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {
","def sumProduct(numbers: List[Long]): (Long, Long) = {
        val sum = numbers.sum
        val product = numbers.foldLeft(1L)(_ * _)
        (sum, product)
    }

    def main(args: Array[String]): Unit = {
        // Test examples
        println(sumProduct(List[Long]())) // (0L, 1L)
        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) // (10L, 24L)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumProduct((List[Long]())).equals(((0l, 1l))));
    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));
    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));
    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));
    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));
    }

}
"
HumanEval_9,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཤུལ་ཐིག་ནང་    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་ཅིག་ལས་ གནས་སྐབས་ཅིག་ཚུན་ཚོད་ཐོབ་མི་ ཚད་ལྡན་ཆ་ཤས་ཚུ་གི་ཐོ་ཡིག་ཅིག་བཟོ་དགོ།    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))
    def rollingMax(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def rollingMax(numbers: List[Long]): List[Long] = {
        var maxSoFar = Long.MinValue
        numbers.map { num =>
            maxSoFar = max(maxSoFar, num)
            maxSoFar
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(rollingMax((List[Long]())).equals((List[Long]())));
    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));
    }

}
"
HumanEval_10,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //- ཚད་འཛིན་གྱི་མཐའ་མ་ལུ་ ཚད་འཛིན་གྱི་སྔོན་འཇུག་འདི་བཙུགས་ ཚད་འཛིན་གྱི་ཤུལ་འཇུག་གི་ཧེ་མ་འོང་འོང་།    //- ཇི་ཇི་ཨའི་གི་ནང་ཐིག་གི་ཤུལ་མ་གི་ཡིག་འབྲུ་འདི་ ཇི་ཇི་ཨའི་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་གི་ནང་ཐིག་ཚུ་ཨིན།    //ཨེལ་གོར་ཇི་མིཊི་གི་བསམ་འཆར་འདི་འཇམ་ཏོང་ཏོ་ཨིན།    //ཚད་འཛིན་འབད་ཡོད་པའི་ཐིག་ཁྲམ་འདི་ལས་འགོ་བཙུགས་ཏེ་ཡོད་པའི་ ཕྲ་རིང་ཤོས་འདི་འཚོལ་དགོ།    // >>> makePalindrome((""""))
    // ("""")
    // >>> makePalindrome((""cat""))
    // (""catac"")
    // >>> makePalindrome((""cata""))
    // (""catac"")
    def makePalindrome(string : String) : String = {
","def makePalindrome(string: String): String = {
    // Helper function to check if a string is a palindrome
    def isPalindrome(s: String): Boolean = s == s.reverse

    // Find the longest palindromic suffix
    var endIndex = string.length
    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {
      endIndex -= 1
    }

    // Extract the non-palindromic prefix
    val prefix = string.substring(0, endIndex - 1)

    // Append the reverse of the prefix to form the shortest palindrome
    string + prefix.reverse
  }
}","    }
    def main(args: Array[String]) = {
    assert(makePalindrome(("""")).equals(("""")));
    assert(makePalindrome((""x"")).equals((""x"")));
    assert(makePalindrome((""xyz"")).equals((""xyzyx"")));
    assert(makePalindrome((""xyx"")).equals((""xyx"")));
    assert(makePalindrome((""jerry"")).equals((""jerryrrej"")));
    }

}
"
HumanEval_11,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //འ་ནི་ནང་འདྲེན་ཚུ་ནང་ binary XOR འདི་འབད་ཞིནམ་ལས་ གྲུབ་འབྲས་འདི་ string སྦེ་ལོག་གཏང་།    //ནང་བསྐྱོད་འདི་ ༡ དང་ ༠ འབད་མི་ཐིག་ཁྲམ་གཉིས་ a དང་ b ཚུ་ཨིན།    // >>> stringXor((""010""), (""110""))
    // (""100"")
    def stringXor(a : String, b : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringXor(a: String, b: String): String = {
    (a zip b).map { case (charA, charB) => 
      if (charA == charB) '0' else '1'
    }.mkString
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringXor((""111000""), (""101010"")).equals((""010010"")));
    assert(stringXor((""1""), (""1"")).equals((""0"")));
    assert(stringXor((""0101""), (""0000"")).equals((""0101"")));
    }

}
"
HumanEval_12,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་ཐིག་ནང་ཐིག་ཚུ་ འདྲ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ None སླར་ལོག་འབདཝ་ཨིན།    //string གི་ཐོ་ཡིག་ནང་ལས་ ཚེ་རིང་ཤོས་དེ་སླར་ལོག་འབདཝ་ཨིན། ལེ་ཤ་ཡོད་པ་ཅིན་ དང་པ་རང་སླར་ལོག་འབདཝ་ཨིན།    // >>> longest((List[String]()))
    // None
    // >>> longest((List[String](""a"", ""b"", ""c"")))
    // Some(""a"")
    // >>> longest((List[String](""a"", ""bb"", ""ccc"")))
    // Some(""ccc"")
    def longest(strings : List[String]) : Option[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Out of list of strings, return the longest one. Return the first one in case of multiple
    // strings of the same length. Return None in case the input list is empty.
    def longest(strings: List[String]): Option[String] = {
        if (strings.isEmpty) None
        else Some(strings.maxBy(_.length))
    }
}","    }
    def main(args: Array[String]) = {
    assert(longest((List[String]())).equals(None));
    assert(longest((List[String](""x"", ""y"", ""z""))).equals(Some(""x"")));
    assert(longest((List[String](""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""))).equals(Some(""zzzz"")));
    }

}
"
HumanEval_13,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ཧྲིལ་པོ་ a དང་ b གཉིས་ཀྱི་སྤྱིར་བཏང་ཆ་བགོས་སྦོམ་ཤོས་ཅིག་སླར་ལོག་འབདཝ་ཨིན།    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return a greatest common divisor of two integers a and b
    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a: Long, b: Long): Long = {
        if (b == 0) a else greatestCommonDivisor(b, a % b)
    }
}","    }
    def main(args: Array[String]) = {
    assert(greatestCommonDivisor((3l), (7l)) == (1l));
    assert(greatestCommonDivisor((10l), (15l)) == (5l));
    assert(greatestCommonDivisor((49l), (14l)) == (7l));
    assert(greatestCommonDivisor((144l), (60l)) == (12l));
    }

}
"
HumanEval_14,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་བསྐྱོད་ཐིག་གི་ཕྲ་རིང་ལས་ ཕྲ་རིང་ཚུན་གྱི་སྔོན་འཇུག་ག་ར་སླར་ལོག་འབདཝ་ཨིན།    // >>> allPrefixes((""abc""))
    // (List[String](""a"", ""ab"", ""abc""))
    def allPrefixes(string : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return list of all prefixes from shortest to longest of the input string
  // >>> allPrefixes((""abc""))
  // (List[String](""a"", ""ab"", ""abc""))
  def allPrefixes(string: String): List[String] = {
    (1 to string.length).map(i => string.substring(0, i)).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(allPrefixes(("""")).equals((List[String]())));
    assert(allPrefixes((""asdfgh"")).equals((List[String](""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""))));
    assert(allPrefixes((""WWW"")).equals((List[String](""W"", ""WW"", ""WWW""))));
    }

}
"
HumanEval_15,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //༠ ལས་ n ཚུན་གྱི་བར་ནའི་བར་སྟོང་ནང་ལུ་ དབྱེ་ཞིབ་འབད་མི་ཨང་གྲངས་ཚུ་ཡོད་པའི་ཐིག་ཁྲམ་ཅིག་སླར་ལོག་འབདཝ་ཨིན།    // >>> stringSequence((0l))
    // (""0"")
    // >>> stringSequence((5l))
    // (""0 1 2 3 4 5"")
    def stringSequence(n : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringSequence(n: Long): String = {
    (0L to n).mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringSequence((0l)).equals((""0"")));
    assert(stringSequence((3l)).equals((""0 1 2 3"")));
    assert(stringSequence((10l)).equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //string ཅིག་བྱིན་པ་ཅིན་ འདི་ནང་ལུ་ཡིག་འབྲུ་ག་དེ་ཅིག་ཡོདཔ་ཨིན་ན་འཚོལ་དགོ།    // >>> countDistinctCharacters((""xyzXYZ""))
    // (3l)
    // >>> countDistinctCharacters((""Jerry""))
    // (4l)
    def countDistinctCharacters(string : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a string, find out how many distinct characters (regardless of case) does it consist of
  // >>> countDistinctCharacters((""xyzXYZ""))
  // (3l)
  // >>> countDistinctCharacters((""Jerry""))
  // (4l)
  def countDistinctCharacters(string: String): Long = {
    string.toLowerCase.toSet.size.toLong
  }
}","    }
    def main(args: Array[String]) = {
    assert(countDistinctCharacters(("""")) == (0l));
    assert(countDistinctCharacters((""abcde"")) == (5l));
    assert(countDistinctCharacters((""abcdecadeCADE"")) == (5l));
    assert(countDistinctCharacters((""aaaaAAAAaaaa"")) == (1l));
    assert(countDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5l));
    }

}
"
HumanEval_17,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //'High' འདི་ ཀོ་ཝེཊ་ཊར་གྱི་གློག་སྒྲ་ཨིནམ་ད་ གློག་སྒྲ་འདི་ beat གཅིག་ལས་བརྒལ་མི་ལེན་    //'o Sa Ri' - ཟླཝ་ཕྱེད་ཀྱི་གློག་སྒྲ་དང་ གློག་སྒྲ་གཉིས་ནང་ཚངམ་ཨིན།    //'o' - སྒྲ་དབྱངས་ཀྱི་རྣམ་པ་ཅིག་ཨིན་ འདི་ཡང་ གློག་ཤུགས་བཞི་ལུ་གནས་འོང་།    //འདི་ནང་ལུ་ ལོ་རྒྱུས་ཅིག་ཡང་འདུག    //མཇུག་མ་བསྡུ་བར་    //ཁྱོད་ཀྱི་ལཱ་འདི་ string འདི་དབྱེ་ཞིབ་འབད་དེ་ ཨང་གྲངས་ཚུའི་ཐོ་ཡིག་འདི་སླར་ལོག་འབདཝ་ཨིན།    //འ་ནི་ལས་འགན་འདི་ནང་ལུ་ ཨེསི་སི་ཨི་ཨའི་ཡིག་གཟུགས་ནང་ལུ་ སྒྲ་དབྱངས་ཀྱི་ཨང་ཡིག་འདི་ སྐུད་པ་ཅིག་སྦེ་བཙུགས་ཡོདཔ་ཨིན།    // >>> parseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))
    def parseMusic(music_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseMusic(music_string: String): List[Long] = {
    val noteMap = Map(""o"" -> 4L, ""o|"" -> 2L, "".|"" -> 1L)
    val notes = music_string.split("" "")
    notes.toList.map(note => noteMap(note))
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseMusic(("""")).equals((List[Long]())));
    assert(parseMusic((""o o o o"")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic(("".| .| .| .|"")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));
    assert(parseMusic((""o| o| .| .| o o o o"")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic((""o| .| o| .| o o| o o|"")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));
    }

}
"
HumanEval_18,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //གཞི་རྟེན་ཐིག་ཁྲམ་ནང་ལུ་ ཚར་ག་དེ་ཅིག་རང་ ཚར་གྲངས་ཀྱི་ཐིག་ཁྲམ་འདི་ཐོབ་ཚུགས་ག་འཚོལ་ཏེ་བལྟ་། གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་    // >>> howManyTimes((""""), (""a""))
    // (0l)
    // >>> howManyTimes((""aaa""), (""a""))
    // (3l)
    // >>> howManyTimes((""aaaa""), (""aa""))
    // (3l)
    def howManyTimes(string : String, substring : String) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def howManyTimes(string: String, substring: String): Long = {
        if (substring.isEmpty || string.isEmpty) return 0L
        var count: Long = 0L
        for (i <- 0 to (string.length - substring.length)) {
            if (string.substring(i, i + substring.length) == substring) {
                count += 1
            }
        }
        count
    }

    // Test cases
    def main(args: Array[String]): Unit = {
        println(howManyTimes("""", ""a""))    // Output: 0
        println(howManyTimes(""aaa"", ""a"")) // Output: 3
        println(howManyTimes(""aaaa"", ""aa"")) // Output: 3
    }
}","    }
    def main(args: Array[String]) = {
    assert(howManyTimes((""""), (""x"")) == (0l));
    assert(howManyTimes((""xyxyxyx""), (""x"")) == (4l));
    assert(howManyTimes((""cacacacac""), (""cac"")) == (4l));
    assert(howManyTimes((""john doe""), (""john"")) == (1l));
    }

}
"
HumanEval_19,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཆུང་ཤོས་ལས་སྦོམ་ཤོས་ལུ་རིམ་སྒྲིག་འབད་མི་ ཨང་གྲངས་ཚུ་དང་གཅིག་ཁར་ string སླར་ལོག་འབདཝ་ཨིན།    //གདམ་ཁ་ཚུ་ "" ༠"", "" ༡"", "" ༢ "", "" ༣ "", "" ༤ "", "" ༥ "", "" ༦ "", "" ༧ "", "" ༨ "" དང་ "" ༩ "" ཚུ་ཨིན།    //ནང་བསྐྱོད་འདི་ ས་སྒོ་ནང་ཐིག་ཡིག་སྦེ་ ""ཟི་རོ་""ལས་ ""དགུ་""ཚུན་ཚོད་ཀྱི་ ཨང་གྲངས་ཚུ་ཨིན།    // >>> sortNumbers((""three one five""))
    // (""one three five"")
    def sortNumbers(numbers : String) : String = {
","def sortNumbers(numbers: String): String = {
    val numberWords = Map(
      ""zero"" -> 0,
      ""one"" -> 1,
      ""two"" -> 2,
      ""three"" -> 3,
      ""four"" -> 4,
      ""five"" -> 5,
      ""six"" -> 6,
      ""seven"" -> 7,
      ""eight"" -> 8,
      ""nine"" -> 9
    )
    
    numbers.split("" "")
      .sortBy(word => numberWords(word))
      .mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortNumbers(("""")).equals(("""")));
    assert(sortNumbers((""three"")).equals((""three"")));
    assert(sortNumbers((""three five nine"")).equals((""three five nine"")));
    assert(sortNumbers((""five zero four seven nine eight"")).equals((""zero four five seven eight nine"")));
    assert(sortNumbers((""six five four three two one zero"")).equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //གཞན་ཚུ་དང་རིམ་པ་བཞིན་དུ་ལོག་གཏང་ (གྱངས་ཁ་ཉུང་སུ་དང་གྱངས་ཁ་ཆེ་ཤོས་) །    //ཨང་གྲངས་ཀྱི་ཐོ་ཡིག་ཅིག་ལས་ (ཉུང་ཤོས་ཨང་གྲངས་གཉིས་) ཨང་གྲངས་གཉིས་རེ་ལུ་ སྦོ་ལོགས་ཁར་ཡོད་མི་ཚུ་སེལ་འཐུ་འབད་ཞིནམ་ལས་ ལོག་གཏང་།    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))
    // ((2.0f, 2.2f))
    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))
    // ((2.0f, 2.0f))
    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findClosestElements(numbers: List[Float]): (Float, Float) = {
    require(numbers.length >= 2, ""List must contain at least two elements"")
    val sortedNumbers = numbers.sorted

    var minDiff = Float.MaxValue
    var closestPair = (0.0f, 0.0f)

    for(i <- 0 until sortedNumbers.length - 1) {
      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))
      if(currentDiff < minDiff) {
        minDiff = currentDiff
        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))
      }
    }
    
    closestPair
  }
}","    }
    def main(args: Array[String]) = {
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));
    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));
    }

}
"
HumanEval_21,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དེ་བཟུམ་སྦེ་ ཨང་ཆུང་ཤོས་འདི་ ༠ དང་སྦོམ་ཤོས་འདི་ ༡ ཨིན།    //ཨང་གྲངས་ཀྱི་ཐོ་འདི་ (ཉུང་ཤོས་རང་ ཨེ་རེ་གཉིས་ལས་) བྱིན་པ་ཅིན་ ཐིག་ཁྲམ་འགྱུར་བཅོས་འདི་ ཤོག་ལེབ་དེ་ནང་ལུ་ལག་ལེན་འཐབ་དགོ།    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))
    // (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))
    def rescaleToUnit(numbers : List[Float]) : List[Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given list of numbers (of at least two elements), apply a linear transform to that list,
  // such that the smallest number will become 0 and the largest will become 1
  def rescaleToUnit(numbers: List[Float]): List[Float] = {
    val minVal = numbers.min
    val maxVal = numbers.max
    numbers.map(num => (num - minVal) / (maxVal - minVal))
  }
}

// Usage example
object Main extends App {
  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)
  val rescaledNumbers = Problem.rescaleToUnit(numbers)
  println(rescaledNumbers) // Output: List(0.0, 0.25, 0.5, 0.75, 1.0)
}","    }
    def main(args: Array[String]) = {
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));
    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    }

}
"
HumanEval_22,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་དོན་ལུ་རྐྱངམ་གཅིག་ scalathon གནས་གོང་ཚུ་གི་ཐོ་འདི་སེལ་འཐུ་འབད།    // >>> filterIntegers((List[Any](""a"", 3.14f, 5l)))
    // (List[Long](5l.toLong))
    // >>> filterIntegers((List[Any](1l, 2l, 3l, ""abc"", Map[Long,Long](), List[Long]())))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    def filterIntegers(values : List[Any]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def filterIntegers(values: List[Any]): List[Long] = {
    values.collect {
      case l: Long => l
    }
  }

  def main(args: Array[String]): Unit = {
    println(filterIntegers(List[Any](""a"", 3.14f, 5l))) // List(5)
    println(filterIntegers(List[Any](1l, 2l, 3l, ""abc"", Map[Long, Long](), List[Long]()))) // List(1, 2, 3)
  }
}","    }
    def main(args: Array[String]) = {
    assert(filterIntegers((List[Any]())).equals((List[Long]())));
    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, ""adasd""))).equals((List[Long](4l.toLong, 9l.toLong))));
    assert(filterIntegers((List[Any](3l, ""c"", 3l, 3l, ""a"", ""b""))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_23,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //string ཟེར་མི་ལུ་ལོག་གཏང་    // >>> stringLength((""""))
    // (0l)
    // >>> stringLength((""abc""))
    // (3l)
    def strlen(string : String) : Long = {
","def strlen(string: String): Long = {
        string.length.toLong
    }
}","    }
    def main(args: Array[String]) = {
    assert(strlen(("""")) == (0l));
    assert(strlen((""x"")) == (1l));
    assert(strlen((""asdasnakj"")) == (9l));
    }

}
"
HumanEval_24,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ n ཅིག་ལུ་ ཨང་གྲངས་སྦོམ་ཤོས་ཅིག་ n ལས་ཆུང་བ་ཅིག་སྦེ་ དབྱེ་བ་ཕྱེ་མི་ཅིག་འཚོལ་དགོ།    // >>> largestDivisor((15l))
    // (5l)
    def largestDivisor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // For a given number n, find the largest number that divides n evenly, smaller than n
    // >>> largestDivisor(15l)
    // (5l)
    def largestDivisor(n: Long): Long = {
        for (i <- (n / 2) to 1 by -1) {
            if (n % i == 0) return i
        }
        1L  // if no divisor found, return 1 (since 1 divides any number)
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestDivisor((3l)) == (1l));
    assert(largestDivisor((7l)) == (1l));
    assert(largestDivisor((10l)) == (5l));
    assert(largestDivisor((100l)) == (50l));
    assert(largestDivisor((49l)) == (7l));
    }

}
"
HumanEval_25,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་འདི་ ཨང་གྲངས་ཆ་མཉམ་གྱི་ཐོན་རིམ་དང་འདྲན་འདྲ་འབད་དགོཔ་ཨིན།    //འབྱོར་རྟགས་རེ་རེ་ ཚར་གྲངས་ནང་ཐོ་བཀོད་འབད་དགོཔ་ཨིན།    //ཆུང་ཤོས་ལས་སྦོམ་ཤོས་ལུ་རིམ་པ་བཟུང་ཐོག་ལས་ ཨང་གྲངས་ཧྲིལ་བུའི་གཞི་གྲངས་ཚུའི་ཐོ་ཡིག་སླར་ལོག་འབདཝ་ཨིན།    // >>> factorize((8l))
    // (List[Long](2l.toLong, 2l.toLong, 2l.toLong))
    // >>> factorize((25l))
    // (List[Long](5l.toLong, 5l.toLong))
    // >>> factorize((70l))
    // (List[Long](2l.toLong, 5l.toLong, 7l.toLong))
    def factorize(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def factorize(n: Long): List[Long] = {
    var num = n
    val factors = ListBuffer[Long]()
    
    var i = 2L
    while (i <= sqrt(num).toLong) {
      while (num % i == 0) {
        factors += i
        num /= i
      }
      i += 1
    }
    
    if (num > 1) {
      factors += num
    }
    
    factors.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(factorize((2l)).equals((List[Long](2l.toLong))));
    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));
    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));
    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_26,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་ཐིག་ནང་བཟུམ་སྦེ་ དབྱེ་བ་ཚུ་བཞག་ནིའི་རིམ་པ་བཞག་དགོ།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་ནང་ལས་ ཚར་གཅིག་ལས་ལྷག་པའི་ནང་ཡོད་པའི་ཆ་ཤས་ཚུ་བཏོན་གཏང་།    // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 3l.toLong, 4l.toLong))
    def removeDuplicates(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def removeDuplicates(numbers: List[Long]): List[Long] = {
    val elementCount = numbers.groupBy(identity).mapValues(_.size)
    numbers.filter(num => elementCount(num) == 1)
  }

  def main(args: Array[String]): Unit = {
    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)
    println(removeDuplicates(numbers)) // Output: List(1, 3, 4)
  }
}","    }
    def main(args: Array[String]) = {
    assert(removeDuplicates((List[Long]())).equals((List[Long]())));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));
    }

}
"
HumanEval_27,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚད་ལྡན་ཡིག་འབྲུ་ཚུ་ ཆེ་ཆུང་ཡིག་འབྲུ་ལུ་དང་ ཆེ་ཆུང་ཡིག་འབྲུ་ལུ་ བསྒྱུར་གཏང་།    // >>> flipCase((""Hello""))
    // (""hELLO"")
    def flipCase(string : String) : String = {
","def flipCase(string: String): String = {
    string.map {
      case c if c.isLower => c.toUpper
      case c if c.isUpper => c.toLower
      case c => c
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(flipCase(("""")).equals(("""")));
    assert(flipCase((""Hello!"")).equals((""hELLO!"")));
    assert(flipCase((""These violent delights have violent ends"")).equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //string གི་ཐོ་ཡིག་ཅིག་ལུ་ string གཅིག་བཟོ།    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Concatenate list of strings into a single string
    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings: List[String]): String = {
        strings.mkString("""")
    }
}","    }
    def main(args: Array[String]) = {
    assert(concatenate((List[String]())).equals(("""")));
    assert(concatenate((List[String](""x"", ""y"", ""z""))).equals((""xyz"")));
    assert(concatenate((List[String](""x"", ""y"", ""z"", ""w"", ""k""))).equals((""xyzwk"")));
    }

}
"
HumanEval_29,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་བསྐྱོད་ཐོ་ཡིག་ནང་ལུ་ string འདི་ཚུ་ ཚད་འཛིན་འབད་ཡོད་པའི་སྔོན་སྒྲིག་ཅིག་གིས་ འགོ་བཙུགས་མི་ཚུ་རྐྱངམ་ཅིག་ ཌའི་ལོག་འབདཝ་ཨིན།    // >>> filterByPrefix((List[String]()), (""a""))
    // (List[String]())
    // >>> filterByPrefix((List[String](""abc"", ""bcd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""array""))
    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {
","strings.filter(_.startsWith(prefix))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterByPrefix((List[String]()), (""john"")).equals((List[String]())));
    assert(filterByPrefix((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    }

}
"
HumanEval_30,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ཀྱི་ཐོ་ནང་ ནུས་ཅན་ཨང་གྲངས་ཚུ་རྐྱངམ་ཅིག་ལོག་གཏང་།    // >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](2l.toLong, 5l.toLong, 6l.toLong))
    // >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))
    def getPositive(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def getPositive(l: List[Long]): List[Long] = {
        l.filter(_ > 0)
    }
}","    }
    def main(args: Array[String]) = {
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));
    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));
    assert(getPositive((List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_31,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་འདི་ཨང་གྲངས་ངོ་མ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    // >>> isPrime((6l))
    // (false)
    // >>> isPrime((101l))
    // (true)
    // >>> isPrime((11l))
    // (true)
    // >>> isPrime((13441l))
    // (true)
    // >>> isPrime((61l))
    // (true)
    // >>> isPrime((4l))
    // (false)
    // >>> isPrime((1l))
    // (false)
    def isPrime(n : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if a given number is prime, and false otherwise.
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPrime((6l)) == (false));
    assert(isPrime((101l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((13441l)) == (true));
    assert(isPrime((61l)) == (true));
    assert(isPrime((4l)) == (false));
    assert(isPrime((1l)) == (false));
    assert(isPrime((5l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((17l)) == (true));
    assert(isPrime((85l)) == (false));
    assert(isPrime((77l)) == (false));
    assert(isPrime((255379l)) == (false));
    }

}
"
HumanEval_33,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚད་གཞི་ཚུ་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་    //l' འདི་ ༣ ལུ་མི་བཏུབ་པའི་བརྡ་སྟོན་ནང་ l དང་མཚུངས་པ་ཨིནམ་དང་ འདི་ཡང་ ༣ ལུ་མི་བཏུབ་པའི་བརྡ་སྟོན་ནང་ གྱི་གནས་གོང་ཚུ་འདྲན་འདྲ་ཨིན།    //འ་ནི་འགན་འདི་གིས་ཐོ་ཡིག་ l འདི་ལེན་ཏེ་ འདི་བཟུམ་ཅིག་སྦེ་ཐོ་ཡིག་ l' འདི་ལོག་བྱིན་འོང་།    // >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))
    def sortThird(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def sortThird(l: List[Long]): List[Long] = {
    // Get the elements at indices divisible by 3
    val elementsAtThirdIndices = l.zipWithIndex.collect {
      case (value, index) if index % 3 == 0 => value
    }
    
    // Sort the collected elements
    val sortedElements = elementsAtThirdIndices.sorted
    
    // Replace elements at indices divisible by 3 with the sorted ones
    l.zipWithIndex.map {
      case (_, index) if index % 3 == 0 => sortedElements(index / 3)
      case (value, _) => value
    }
  }

  // Example usage:
  def main(args: Array[String]): Unit = {
    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));
    }

}
"
HumanEval_34,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཐོ་ཡིག་ནང་ལུ་ དབྱེ་བ་ཕྱེ་ཡོད་པའི་ཁྱད་ཆོས་ཅན་གྱི་ཆ་ཤས་ཚུ་སླར་ལོག་འབདཝ་ཨིན།    // >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))
    def unique(l : List[Long]) : List[Long] = {
","def unique(l: List[Long]): List[Long] = {
    l.toSet.toList.sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));
    }

}
"
HumanEval_35,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚད་འཛིན་ནང་ཐིག་ཁྲམ་ནང་ ཚད་འཛིན་འབད་ཡོད་པའི་ཆ་ཤས་འདི་སླར་ལོག་འབདཝ་ཨིན།    // >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (3l)
    // >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (123l)
    def maxElement(l : List[Long]) : Long = {
","def maxElement(l: List[Long]): Long = {
    l.max
  }
}","    }
    def main(args: Array[String]) = {
    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));
    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));
    }

}
"
HumanEval_36,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ 7 འདི་ ཨང་གྲངས་ n ལས་ཆུང་བ་ནང་ལུ་མཐོང་མི་ ཚར་གྲངས་ཚུ་སླར་ལོག་འབདཝ་ཨིན། དེ་ཡང་ ༡༡ དང་ ༡༣ ལུ་ཆ་བགོས་འབད་ཚུགས།    // >>> fizzBuzz((50l))
    // (0l)
    // >>> fizzBuzz((78l))
    // (2l)
    // >>> fizzBuzz((79l))
    // (3l)
    def fizzBuzz(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fizzBuzz(n: Long): Long = {
    var count = 0L
    for (i <- 1L until n) {
      if (i % 11 == 0 || i % 13 == 0) {
        count += i.toString.count(_ == '7')
      }
    }
    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(fizzBuzz((50l)) == (0l));
    assert(fizzBuzz((78l)) == (2l));
    assert(fizzBuzz((79l)) == (3l));
    assert(fizzBuzz((100l)) == (3l));
    assert(fizzBuzz((200l)) == (6l));
    assert(fizzBuzz((4000l)) == (192l));
    assert(fizzBuzz((10000l)) == (639l));
    assert(fizzBuzz((100000l)) == (8026l));
    }

}
"
HumanEval_37,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚད་འཛིན་ཚུ་དང་ འདྲ་མཉམ་སྦེ་ཡོད་རུང་ དབྱེ་བ་ཕྱེ་སྟེ་འདུག    //l' འདི་ ཌིཌི་ཨེན་ཌི་ནང་ལུ་ l དང་འདྲ་མཉམ་ཨིན་པའི་ཁར་ ཌིཌི་ཨེན་ཌི་ཨེན་ཌི་ནང་ལུ་ ཚད་ཚུ་ཆ་མཉམ་ཨིན།    //འ་ནི་འགན་འདི་གིས་ཐོ་ཡིག་ l འདི་ལེན་ཏེ་ འདི་བཟུམ་ཅིག་སྦེ་ཐོ་ཡིག་ l' འདི་ལོག་བྱིན་འོང་།    // >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))
    def sortEven(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // This function takes a list l and returns a list l' such that
  // l' is identical to l in the odd indicies, while its values at the even indicies are equal
  // to the values of the even indicies of l, but sorted.
  def sortEven(l: List[Long]): List[Long] = {
    val evenIndices = l.indices.filter(_ % 2 == 0)
    val sortedEvens = evenIndices.map(l(_)).sorted

    l.indices.map { index =>
      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))
      else l(index)
    }.toList
  }

  // Examples
  def main(args: Array[String]): Unit = {
    println(sortEven(List[Long](1L, 2L, 3L)))
    println(sortEven(List[Long](5L, 6L, 3L, 4L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));
    }

}
"
HumanEval_39,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //prime_fib གིས་ ཨང་གྲངས་ n-th དེ་ ཕི་བཱོན་ཀིཤི་ཨང་གྲངས་ཨིནམ་དང་ དེ་ཡང་ ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཨིན།    // >>> primeFib((1l))
    // (2l)
    // >>> primeFib((2l))
    // (3l)
    // >>> primeFib((3l))
    // (5l)
    // >>> primeFib((4l))
    // (13l)
    // >>> primeFib((5l))
    // (89l)
    def primeFib(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeFib(n: Long): Long = {
    // Function to check if a number is prime
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num == 2) return true
      if (num % 2 == 0) return false
      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {
        if (num % i == 0) return false
      }
      true
    }

    // Function to generate Fibonacci numbers
    def fibonacciStream(): Stream[Long] = {
      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)
      fibs(0, 1)
    }

    // Find the n-th Fibonacci number that is also prime
    val primeFibs = fibonacciStream().filter(isPrime)
    primeFibs.take(n.toInt).last
  }

  // Test the function
  def main(args: Array[String]): Unit = {
    println(primeFib(1L)) // 2
    println(primeFib(2L)) // 3
    println(primeFib(3L)) // 5
    println(primeFib(4L)) // 13
    println(primeFib(5L)) // 89
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeFib((1l)) == (2l));
    assert(primeFib((2l)) == (3l));
    assert(primeFib((3l)) == (5l));
    assert(primeFib((4l)) == (13l));
    assert(primeFib((5l)) == (89l));
    assert(primeFib((6l)) == (233l));
    assert(primeFib((7l)) == (1597l));
    assert(primeFib((8l)) == (28657l));
    assert(primeFib((9l)) == (514229l));
    assert(primeFib((10l)) == (433494437l));
    }

}
"
HumanEval_40,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དེ་མེན་པ་ཅིན་ ཆ་མཉམ་འདི་ ༠ དང་རྫུས་མ་ཨིན།    //དེ་ནང་ལུ་ཐོ་ཡིག་ནང་ལུ་ ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གསུམ་ཡོད་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    //triples_sum_to_zero གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཅིག་ ནང་བསྐྱོད་འབད་སྦེ་ལེན་འབདཝ་ཨིན།    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong)))
    // (false)
    def triplesSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // triples_sum_to_zero takes a list of integers as an input.
    // it returns true if there are three distinct elements in the list that
    // sum to zero, and false otherwise.
    def triplesSumToZero(l: List[Long]): Boolean = {
        val n = l.length
        if (n < 3) return false

        // Sort the list to use the two-pointer technique
        val sortedList = l.sorted

        // Iterate over the list
        for (i <- 0 until n - 2) {
            var left = i + 1
            var right = n - 1

            // Use two pointers to find the remaining two numbers
            while (left < right) {
                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)
                if (currentSum == 0) {
                    return true
                } else if (currentSum < 0) {
                    left += 1
                } else {
                    right -= 1
                }
            }
        }

        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    }

}
"
HumanEval_41,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //འ་ནི་ལས་འགན་འདི་གིས་ དེ་བཟུམ་གྱི་འཐབ་རྒོལ་གྱི་གྱངས་ཁ་བཏོན་འབདཝ་ཨིན།    //ཁོང་གཉིས་མ་རེག་པའི་ཁར་ འགྱོ་དོ་ཡོདཔ་ཨིན་མས།    //ཨིན་རུང་ སྣུམ་འཁོར་ཚུ་ གནམ་མེད་ས་མེད་སྒྲིང་སྒྲིང་དང་སྒྲིང་སྒྲིང་ཨིནམ་ལས་ ཁོང་གིས་ འཕྲོ་མཐུད་དེ་ར་ འགྲོ་འགྲུལ་འབད་དོ་ཡོདཔ་ཨིན་མས།    //གཡས་ལས་གཡོན་ཁ་ཐུག་འགྱོ་མི་ སྣུམ་འཁོར་ཅིག་གིས་ གཡས་ལས་གཡོན་ཁ་ཐུག་འགྱོ་མི་ སྣུམ་འཁོར་ཅིག་ལུ་ ཐུག་པའི་སྐབས་ཨིན།    //སྣུམ་འཁོར་ཆ་མཉམ་ འདི་ཚུ་མགྱོགས་ཚད་གཅིག་སྦེ་འགྱོ་དོ་ སྣུམ་འཁོར་གཉིས་ཅིག་ ཐུག་དོ་ཡོདཔ་སྦེ་སླབ་ཨིན།    //ཕྲང་ལམ་འདི་གཡོན་ཁ་ཐུག་འགྱོ་དོ་ཡོདཔ་དང་ སྣུམ་འཁོར་གཉིས་འདི་ ཕྲང་ལམ་འདི་ལས་ ཐག་རིང་ས་ཅིག་ཁར་འགྱོ་དོ་ཡོདཔ་དང་    //སྣུམ་འཁོར་ n གིས་ གཡས་ལས་གཡས་ཁ་ཐུག་འགྱོ་དོ་ཡོདཔ་དང་ དེ་བསྒང་ སྣུམ་འཁོར་ n གི་སྡེ་ཚན་སོ་སོ་ཅིག་     //ཐད་ཀར་དུ་ཕྲང་ཡོད་པའི་ལམ་འདི་ མཐའ་མེད་པའི་རིང་ཚད་ཅིག་སྦེ་མནོ་བསམ་གཏང་དགོ།    def carRaceCollision(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Imagine a road that's a perfectly straight infinitely long line.
  // n cars are driving left to right; simultaneously, a different set of n cars
  // are driving right to left. The two sets of cars start out being very far from
  // each other. All cars move at the same speed. Two cars are said to collide
  // when a car that's moving left to right hits a car that's moving right to left.
  // However, the cars are infinitely sturdy and strong; as a result, they continue moving
  // in their trajectory as if they did not collide.
  // This function outputs the number of such collisions.
  def carRaceCollision(n: Long): Long = {
    n
  }
}","    }
    def main(args: Array[String]) = {
    assert(carRaceCollision((2l)) == (4l));
    assert(carRaceCollision((3l)) == (9l));
    assert(carRaceCollision((4l)) == (16l));
    assert(carRaceCollision((8l)) == (64l));
    assert(carRaceCollision((10l)) == (100l));
    }

}
"
HumanEval_42,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཕྱིར་ལོག་འབད་ནིའི་ཐོ་ཡིག་ནང་ལུ་ དབྱེ་བ་ཚུ་ ༡ ལུ་ཡར་སེང་འབད་ཡོདཔ་ཨིན།    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))
    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))
    def incrList(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return list with elements incremented by 1.
    def incrList(l: List[Long]): List[Long] = {
        l.map(_ + 1)
    }
}","    }
    def main(args: Array[String]) = {
    assert(incrList((List[Long]())).equals((List[Long]())));
    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));
    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));
    }

}
"
HumanEval_43,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དེ་མེན་པ་ཅིན་ ཆ་མཉམ་འདི་ ༠ དང་རྫུས་མ་ཨིན།    //དེ་ནང་ལུ་ཐོ་ཡིག་ནང་ལུ་ ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གཉིས་ཡོད་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    //pairs_sum_to_zero གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཅིག་ ནང་བསྐྱོད་འབད་སྦེ་ལེན་འབདཝ་ཨིན།    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (true)
    // >>> pairsSumToZero((List[Long](1l.toLong)))
    // (false)
    def pairsSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def pairsSumToZero(l: List[Long]): Boolean = {
        val seen = HashSet[Long]()
        for (num <- l) {
            if (seen.contains(-num)) {
                return true
            }
            seen.add(num)
        }
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));
    }

}
"
HumanEval_44,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //གཞི་གྲངས་ཚུ་ ༡༠ ལས་ཉུང་ཡོདཔ་ཨིན།    //བསྒྱུར་བཅོས་འབད་བའི་ཤུལ་ལས་ string ངོ་ཚབ་ལོག་འབདཝ་ཨིན།    //ནང་བསྐྱོད་ཨང་གྲངས་ x གི་ཨང་གྲངས་གཞི་རྟེན་གཞི་རྟེན་ལུ་ བསྒྱུར་བཅོས་འབད།    // >>> changeBase((8l), (3l))
    // (""22"")
    // >>> changeBase((8l), (2l))
    // (""1000"")
    // >>> changeBase((7l), (2l))
    // (""111"")
    def changeBase(x : Long, base : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def changeBase(x: Long, base: Long): String = {
        require(base > 1 && base < 10, ""Base must be between 2 and 9"")
        
        if (x == 0) return ""0""

        val result = new StringBuilder()
        var number = x

        while (number > 0) {
            val remainder = number % base
            result.append(remainder.toString)
            number /= base
        }

        result.reverse.toString()
    }
}","    }
    def main(args: Array[String]) = {
    assert(changeBase((8l), (3l)).equals((""22"")));
    assert(changeBase((9l), (3l)).equals((""100"")));
    assert(changeBase((234l), (2l)).equals((""11101010"")));
    assert(changeBase((16l), (2l)).equals((""10000"")));
    assert(changeBase((8l), (2l)).equals((""1000"")));
    assert(changeBase((7l), (2l)).equals((""111"")));
    assert(changeBase((2l), (3l)).equals((""2"")));
    assert(changeBase((3l), (4l)).equals((""3"")));
    assert(changeBase((4l), (5l)).equals((""4"")));
    assert(changeBase((5l), (6l)).equals((""5"")));
    assert(changeBase((6l), (7l)).equals((""6"")));
    assert(changeBase((7l), (8l)).equals((""7"")));
    }

}
"
HumanEval_45,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //གཡོན་རིང་ཚད་དང་མཐོ་ཚད་སླར་ལོག་འབད་སའི་ས་སྒོ་འདི་གསུམ་ཟུར་ཅིག་ལུ་བྱིན་ཡོདཔ་ཨིན།    // >>> triangleArea((5l), (3l))
    // (7.5f)
    def triangleArea(a : Long, h : Long) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> triangleArea(5l, 3l)
    // (7.5f)
    def triangleArea(a: Long, h: Long): Float = {
        (a * h / 2.0).toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((5l), (3l)) == (7.5f));
    assert(triangleArea((2l), (2l)) == (2.0f));
    assert(triangleArea((10l), (8l)) == (40.0f));
    }

}
"
HumanEval_46,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཁྱོད་ཀྱིས་ཨང་རིམ་ fib4 ནང་ལུ་ ཨེ་རེ་ n པ་འདི་ ཤུགས་ལྡན་སྦེ་རྩིས་སྟོན་འབད་ནིའི་དོན་ལུ་ ལས་འགན་ཅིག་འབྲི་གནང་། ལོག་གཞི་བཙུགས་འདི་ལག་ལེན་འཐབ་མ་བཏུབ།    //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) ཚུ་ཨིན།    //fib4(3) -> ༠ ཨིན་པུཊི་    //fib4(2) -> ༢ ཨིན།    //fib4(1) -> ༠ ཨིན།    //fib4(0) -> ༠ ཨིན་པུཊི་    //Fib4 ཨང་རིམ་འདི་ Fibbonacci གི་རིམ་པ་བཟུམ་ཅིག་ཨིནམ་དང་ འདི་ཡང་ ཤུལ་མའི་ནང་བཀོད་དེ་ཡོདཔ་ཨིན།    // >>> fib4((5l))
    // (4l)
    // >>> fib4((6l))
    // (8l)
    // >>> fib4((7l))
    // (14l)
    def fib4(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fib4(n: Long): Long = {
    if (n == 0 || n == 1) return 0
    if (n == 2) return 2
    if (n == 3) return 0

    var a: Long = 0
    var b: Long = 0
    var c: Long = 2
    var d: Long = 0
    
    var result: Long = 0
    
    for (i <- 4L to n) {
      result = a + b + c + d
      a = b
      b = c
      c = d
      d = result
    }
    
    result
  }
}","    }
    def main(args: Array[String]) = {
    assert(fib4((5l)) == (4l));
    assert(fib4((8l)) == (28l));
    assert(fib4((10l)) == (104l));
    assert(fib4((12l)) == (386l));
    }

}
"
HumanEval_47,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཤོག་ཁྲམ་ནང་ཡོད་པའི་ཆ་ཤས་ཚུ་གི་བར་མཚམས་སླར་ལོག་འབདཝ་ཨིན།    // >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // 3l
    // >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))
    // (15.0f)
    def median(l : List[Long]) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return median of elements in the list l.
  def median(l: List[Long]): Float = {
    val sortedList = l.sorted
    val n = sortedList.length
    if (n % 2 == 1) {
      sortedList(n / 2).toFloat
    } else {
      (sortedList(n / 2 - 1) + sortedList(n / 2)).toFloat / 2
    }
  }

  def main(args: Array[String]): Unit = {
    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) // 3.0
    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) // 15.0
  }
}","    }
    def main(args: Array[String]) = {
    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);
    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));
    assert(median((List[Long](5l.toLong))) == 5l);
    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));
    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);
    }

}
"
HumanEval_48,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //string འདི་ palindrome ཨིན་ན་བརྟག་དཔྱད་འབདཝ་ཨིན།    // >>> isPalindrome((""""))
    // (true)
    // >>> isPalindrome((""aba""))
    // (true)
    // >>> isPalindrome((""aaaaa""))
    // (true)
    // >>> isPalindrome((""zbcd""))
    // (false)
    def isPalindrome(text : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Checks if given string is a palindrome
  def isPalindrome(text: String): Boolean = {
    val length = text.length
    for (i <- 0 until length / 2) {
      if (text(i) != text(length - i - 1)) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPalindrome(("""")) == (true));
    assert(isPalindrome((""aba"")) == (true));
    assert(isPalindrome((""aaaaa"")) == (true));
    assert(isPalindrome((""zbcd"")) == (false));
    assert(isPalindrome((""xywyx"")) == (true));
    assert(isPalindrome((""xywyz"")) == (false));
    assert(isPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //༢^n modulo p སླར་ལོག་འབདཝ་ཨིན། (ཨང་གྲངས་ཚུ་ཤེས་དགོ)    // >>> modp((3l), (5l))
    // (3l)
    // >>> modp((1101l), (101l))
    // (2l)
    // >>> modp((0l), (101l))
    // (1l)
    // >>> modp((3l), (11l))
    // (8l)
    // >>> modp((100l), (101l))
    // (1l)
    def modp(n : Long, p : Long) : Long = {
","def modp(n: Long, p: Long): Long = {
    // Calculate 2^n modulo p using iterative exponentiation by squaring.
    def powMod(base: Long, exp: Long, mod: Long): Long = {
      var result = 1L
      var b = base % mod
      var e = exp
      
      while (e > 0) {
        if ((e & 1) == 1) { // Check if e is odd
          result = (result * b) % mod
        }
        e >>= 1
        b = (b * b) % mod
      }

      result
    }

    powMod(2, n, p)
  }
}","    }
    def main(args: Array[String]) = {
    assert(modp((3l), (5l)) == (3l));
    assert(modp((1101l), (101l)) == (2l));
    assert(modp((0l), (101l)) == (1l));
    assert(modp((3l), (11l)) == (8l));
    assert(modp((100l), (101l)) == (1l));
    assert(modp((30l), (5l)) == (4l));
    assert(modp((31l), (5l)) == (3l));
    }

}
"
HumanEval_51,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //remove_vowels འདི་ལས་ string དང་ vowels ཚུ་མེད་པར་ string སླར་ལོག་འབདཝ་ཨིན།    // >>> removeVowels((""""))
    // ("""")
    // >>> removeVowels((""abcdef""))
    // (""bcdf"")
    // >>> removeVowels((""aaaaa""))
    // ("""")
    // >>> removeVowels((""aaBAA""))
    // (""B"")
    // >>> removeVowels((""zbcd""))
    // (""zbcd"")
    def removeVowels(text : String) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def removeVowels(text: String): String = {
        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        text.filterNot(vowels.contains)
    }
}","    }
    def main(args: Array[String]) = {
    assert(removeVowels(("""")).equals(("""")));
    assert(removeVowels((""abcdef\nghijklm"")).equals((""bcdf\nghjklm"")));
    assert(removeVowels((""fedcba"")).equals((""fdcb"")));
    assert(removeVowels((""eeeee"")).equals(("""")));
    assert(removeVowels((""acBAA"")).equals((""cB"")));
    assert(removeVowels((""EcBOO"")).equals((""cB"")));
    assert(removeVowels((""ybcd"")).equals((""ybcd"")));
    }

}
"
HumanEval_52,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཐོ་ཡིག་ནང་ཨང་གྲངས་ཚུ་ཆ་མཉམ་རང་ ཐོ་ཡིག་གི་འོག་ལས་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
    // (true)
    // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
    // (false)
    def belowThreshold(l : List[Long], t : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if all numbers in the list l are below threshold t.
  // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
  // (true)
  // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
  // (false)
  def belowThreshold(l: List[Long], t: Long): Boolean = {
    l.forall(_ < t)
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));
    }

}
"
HumanEval_53,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ x དང་ y གཉིས་བསྡོམས་འབད།    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Add two numbers x and y
    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x: Long, y: Long): Long = {
        x + y
    }
}","    }
    def main(args: Array[String]) = {
    assert(add((0l), (1l)) == (1l));
    assert(add((1l), (0l)) == (1l));
    assert(add((2l), (3l)) == (5l));
    assert(add((5l), (7l)) == (12l));
    assert(add((7l), (5l)) == (12l));
    }

}
"
HumanEval_54,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚིག་གཉིས་ལུ་ ཡིག་འབྲུ་འདྲ་མཉམ་ཡོད་མེད་བལྟ་།    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> sameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> sameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> sameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> sameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    def sameChars(s0 : String, s1 : String) : Boolean = {
","import scala.collection.mutable._

object Problem {
  def sameChars(s0: String, s1: String): Boolean = {
    def charSet(s: String): Set[Char] = s.toSet
    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(sameChars((""abcd""), (""dddddddabc"")) == (true));
    assert(sameChars((""dddddddabc""), (""abcd"")) == (true));
    assert(sameChars((""eabcd""), (""dddddddabc"")) == (false));
    assert(sameChars((""abcd""), (""dddddddabcf"")) == (false));
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(sameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཕི་བེ་ནའཅིཤི་ཨང་གྲངས་ nth སླར་ལོག་འབདཝ་ཨིན།    // >>> fib((10l))
    // (55l)
    // >>> fib((1l))
    // (1l)
    // >>> fib((8l))
    // (21l)
    def fib(n : Long) : Long = {
","def fib(n: Long): Long = {
        if (n <= 1) n
        else {
            var a: Long = 0
            var b: Long = 1
            for (_ <- 2L to n) {
                val temp = a + b
                a = b
                b = temp
            }
            b
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(fib((10l)) == (55l));
    assert(fib((1l)) == (1l));
    assert(fib((8l)) == (21l));
    assert(fib((11l)) == (89l));
    assert(fib((12l)) == (144l));
    }

}
"
HumanEval_56,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //སྒོ་སྒྲིག་རེ་རེ་གི་ནང་ ཟུར་འཇུག་གི་ཟུར་འཇུག་ཅིག་ཡོད་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    //brackets འདི་ ""<"" དང་ "">"" ཀྱི་ཐིག་ཁྲམ་ཨིན།    // >>> correctBracketing((""<""))
    // (false)
    // >>> correctBracketing((""<>""))
    // (true)
    // >>> correctBracketing((""<<><>>""))
    // (true)
    // >>> correctBracketing((""><<>""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","import scala.collection.mutable.Stack

object Problem {
  def correctBracketing(brackets: String): Boolean = {
    val stack = new Stack[Char]()
    for (char <- brackets) {
      if (char == '<') {
        stack.push(char)
      } else if (char == '>') {
        if (stack.isEmpty || stack.pop() != '<') {
          return false
        }
      }
    }
    stack.isEmpty
  }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""<>"")) == (true));
    assert(correctBracketing((""<<><>>"")) == (true));
    assert(correctBracketing((""<><><<><>><>"")) == (true));
    assert(correctBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(correctBracketing((""<<<><>>>>"")) == (false));
    assert(correctBracketing((""><<>"")) == (false));
    assert(correctBracketing((""<"")) == (false));
    assert(correctBracketing((""<<<<"")) == (false));
    assert(correctBracketing(("">"")) == (false));
    assert(correctBracketing((""<<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>><<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚད་འཛིན་འབད་ཡོད་པའི་ཐོ་ཡིག་གི་ཆ་ཤས་ཚུ་ ཚད་འཛིན་འབད་ཡོད་པའི་ཐོ་ཡིག་གི་ཆ་ཤས་ཚུ་ཡར་འཕར་འགྱོ་ ཡང་ན་ མར་ཕབ་འགྱོ་དོ་ཡོད་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
    // (true)
    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
    // (false)
    // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
    // (true)
    def monotonic(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if list elements are monotonically increasing or decreasing.
  // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
  // (true)
  // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
  // (false)
  // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
  // (true)
  def monotonic(l: List[Long]): Boolean = {
    if (l.isEmpty || l.length == 1) return true

    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }
    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }

    increasing || decreasing
  }
}","    }
    def main(args: Array[String]) = {
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));
    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));
    }

}
"
HumanEval_58,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཤོག་ལེབ་གཉིས་ཆ་རའི་དོན་ལུ་ དབྱེ་བ་ཕྱེ་མི་ ཁྱད་ཆོས་ཅན་གྱི་ཆ་ཤས་འདི་ལོག་གཏང་།    // >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))
    // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))
    // >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong))
    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return sorted unique common elements for two lists.
  def common(l1: List[Long], l2: List[Long]): List[Long] = {
    (l1.toSet intersect l2.toSet).toList.sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))
    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));
    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_59,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //n གི་གཞི་གྲངས་སྦོམ་ཤོས་འདི་སླར་ལོག་འབདཝ་ཨིན། n > 1 འདི་གཞི་གྲངས་ངོ་མ་མེན་པ་ཅིན་ཨིན།    // >>> largestPrimeFactor((13195l))
    // (29l)
    // >>> largestPrimeFactor((2048l))
    // (2l)
    def largestPrimeFactor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def largestPrimeFactor(n: Long): Long = {
        var number = n
        var largestFactor = 1L

        // Check for number of 2s that divide n
        while (number % 2 == 0) {
            largestFactor = 2L
            number /= 2
        }

        // n must be odd at this point, so a skip of 2 (i = i + 2) can be used
        var i = 3
        while (i <= sqrt(number)) {
            while (number % i == 0) {
                largestFactor = i
                number /= i
            }
            i += 2
        }

        // This condition is to check if number is a prime number greater than 2
        if (number > 2) {
            largestFactor = number
        }

        largestFactor
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestPrimeFactor((15l)) == (5l));
    assert(largestPrimeFactor((27l)) == (3l));
    assert(largestPrimeFactor((63l)) == (7l));
    assert(largestPrimeFactor((330l)) == (11l));
    assert(largestPrimeFactor((13195l)) == (29l));
    }

}
"
HumanEval_60,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //sum_to_n འདི་ལས་ 1 ལས་ n ཚུན་གྱི་ཨང་གྲངས་ཚུ་བསྡོམས་མི་ལས་འགན་ཨིན།    // >>> sumToN((30l))
    // (465l)
    // >>> sumToN((100l))
    // (5050l)
    // >>> sumToN((5l))
    // (15l)
    // >>> sumToN((10l))
    // (55l)
    // >>> sumToN((1l))
    // (1l)
    def sumToN(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def sumToN(n: Long): Long = {
        (1L to n).sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumToN((1l)) == (1l));
    assert(sumToN((6l)) == (21l));
    assert(sumToN((11l)) == (66l));
    assert(sumToN((30l)) == (465l));
    assert(sumToN((100l)) == (5050l));
    }

}
"
HumanEval_61,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //སྒོ་སྒྲིག་རེ་རེ་གི་ནང་ ཟུར་འཇུག་གི་ཟུར་འཇུག་ཅིག་ཡོད་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    //brackets འདི་ ""("" དང་ """") ཟེར་མི་ string ཅིག་ཨིན།    // >>> correctBracketing((""(""))
    // (false)
    // >>> correctBracketing((""()""))
    // (true)
    // >>> correctBracketing((""(()())""))
    // (true)
    // >>> correctBracketing(("")(()""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","var balance = 0
        for (ch <- brackets) {
            if (ch == '(') balance += 1
            else if (ch == ')') balance -= 1
            
            if (balance < 0) return false
        }
        balance == 0
    }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""()"")) == (true));
    assert(correctBracketing((""(()())"")) == (true));
    assert(correctBracketing((""()()(()())()"")) == (true));
    assert(correctBracketing((""()()((()()())())(()()(()))"")) == (true));
    assert(correctBracketing((""((()())))"")) == (false));
    assert(correctBracketing(("")(()"")) == (false));
    assert(correctBracketing((""("")) == (false));
    assert(correctBracketing((""(((("")) == (false));
    assert(correctBracketing(("")"")) == (false));
    assert(correctBracketing((""(()"")) == (false));
    assert(correctBracketing((""()()(()())())(()"")) == (false));
    assert(correctBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚད་ལྡན་འདི་གི་ དོ་འགྲན་འདི་ འདྲ་མཉམ་སྦེ་སླར་ལོག་འབདཝ་ཨིན།    //xs[0] + xs[1] * x + xs[2] * x^2 + .... ཟེར་མི་འདི་ཨིན།    //xs འདི་ མང་གྲངས་ཀྱི་གནས་གོང་ཚུ་ཨིན།    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))
    // >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong))
    def derivative(xs : List[Long]) : List[Long] = {
","import scala.collection.mutable._

object Problem {
  def derivative(xs: List[Long]): List[Long] = {
    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }
  }
}","    }
    def main(args: Array[String]) = {
    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));
    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));
    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_63,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཕབ་ལེན་འབད་ཡོད་པའི་ཡིག་ཆ་འདི་ ཨང་གྲངས་རིམ་པ་ fibfib ནང་ལུ་ n-th པ་ཨིན་པའི་ཆ་ཤས་འདི་ དབྱེ་དཔྱད་འབད་ནིའི་དོན་ལུ་འབྲི་གནང་།    //fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) ཨིན་པུཊི་གིས་འབད་ཚུགས།    //fib fib (((2) == ༡     //fib fib ((1)) == 0     //fib fib ((0) == 0     //FibFib ཨང་རིམ་འདི་ Fibbonacci sequence དང་འདྲ་བའི་རིམ་པ་ཅིག་ཨིནམ་དང་ འདི་ཚུ་ འོག་གི་བཟུམ་སྦེ་གསལ་བཀོད་འབདཝ་ཨིན།    // >>> fibfib((1l))
    // (0l)
    // >>> fibfib((5l))
    // (4l)
    // >>> fibfib((8l))
    // (24l)
    def fibfib(n : Long) : Long = {
","def fibfib(n: Long): Long = {
    if (n == 0) return 0
    if (n == 1) return 0
    if (n == 2) return 1

    var a: Long = 0
    var b: Long = 0
    var c: Long = 1
    var d: Long = 0

    for (_ <- 3L to n) {
      d = a + b + c
      a = b
      b = c
      c = d
    }
    d
  }
}","    }
    def main(args: Array[String]) = {
    assert(fibfib((2l)) == (1l));
    assert(fibfib((1l)) == (0l));
    assert(fibfib((5l)) == (4l));
    assert(fibfib((8l)) == (24l));
    assert(fibfib((10l)) == (81l));
    assert(fibfib((12l)) == (274l));
    assert(fibfib((14l)) == (927l));
    }

}
"
HumanEval_64,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཨང་བཏགས་ནི་དེ་ ཁ་ཚིག་གི་མཇུག་ལུ་ཡོད་པའི་སྐད་ཡིག་ནང་ལུ་རྐྱངམ་གཅིག་ཨིན།    //འ་ནི་གནས་སྟངས་ནང་ལུ་ ཚིག་ཡིག་འདི་ ""a"", ""e"", ""i"", ""o"", ""u"" ཨིན། འ་ནི་ནང་ལུ་ ""y"" འདི་ཡང་ ""a"" ཨིན།    //ཚིག་ཅིག་ནང་བཙུགས་ཏེ་ string ནང་གི་ཕྲ་རིང་གི་གྱངས་ཁ་ལོག་གཏང་འོང་།    //ནང་ལུ་ཡིག་དཔར་འབད་ཡོད་པའི་ལས་འགན་ vowels_count འདི་ལུ་ string ཟེར་ཡིག་དཔར་འབདཝ་ཨིན།    // >>> vowelsCount((""abcde""))
    // (2l)
    // >>> vowelsCount((""ACEDY""))
    // (3l)
    def vowelsCount(s : String) : Long = {
","def vowelsCount(s: String): Long = {
    val vowels = Set('a', 'e', 'i', 'o', 'u')
    val lowerCaseWord = s.toLowerCase
    var count = 0L

    for (i <- lowerCaseWord.indices) {
      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(vowelsCount((""abcde"")) == (2l));
    assert(vowelsCount((""Alone"")) == (3l));
    assert(vowelsCount((""key"")) == (2l));
    assert(vowelsCount((""bye"")) == (1l));
    assert(vowelsCount((""keY"")) == (2l));
    assert(vowelsCount((""bYe"")) == (1l));
    assert(vowelsCount((""ACEDY"")) == (3l));
    }

}
"
HumanEval_65,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Shift > ཨང་གྲངས་ཚུ་ཡོད་པ་ཅིན་ ཨང་གྲངས་ལོག་གཏང་།    //དེ་ལས་ གྲུབ་འབྲས་འདི་ string སྦེ་ལོག་འབདཝ་ཨིན།    //གྱངས་ཁ་ཧྲིལ་བུའི་ཨང་གྲངས་ x གི་ཨང་གྲངས་ཚུ་ ཕྱོགས་སོར་གཏང་། ཨང་གྲངས་ཚུ་ ཕྱོགས་སོར་གཏང་།    // >>> circularShift((12l), (1l))
    // (""21"")
    // >>> circularShift((12l), (2l))
    // (""12"")
    def circularShift(x : Long, shift : Long) : String = {
","def circularShift(x: Long, shift: Long): String = {
  val digits = x.toString
  val length = digits.length
  
  if (shift >= length) {
    digits.reverse
  } else {
    val effectiveShift = (length - shift % length).toInt
    (digits.drop(effectiveShift) + digits.take(effectiveShift))
  }
}","    }
    def main(args: Array[String]) = {
    assert(circularShift((100l), (2l)).equals((""001"")));
    assert(circularShift((12l), (2l)).equals((""12"")));
    assert(circularShift((97l), (8l)).equals((""79"")));
    assert(circularShift((12l), (1l)).equals((""21"")));
    assert(circularShift((11l), (101l)).equals((""11"")));
    }

}
"
HumanEval_66,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཨེསི་སི་ཨི་ཨའི་ཡིག་བྱང་ཚུ་ཨིན།    //ནང་བསྐྱོད་སྦེ་ string དང་ སྟེང་གི་ཡིག་འབྲུ་ཚུ་བསྡོམས་འབད་མི་འདི་ལོག་གཏང་མི་ function ཅིག་འབྲི་དགོ།    //ལཱ་འགན་     // >>> digitSum((""""))
    // (0l)
    // >>> digitSum((""abAB""))
    // (131l)
    // >>> digitSum((""abcCd""))
    // (67l)
    // >>> digitSum((""helloE""))
    // (69l)
    // >>> digitSum((""woArBld""))
    // (131l)
    // >>> digitSum((""aAaaaXa""))
    // (153l)
    def digitSum(s : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def digitSum(s: String): Long = {
    s.filter(_.isUpper).map(_.toLong).sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(digitSum(("""")) == (0l));
    assert(digitSum((""abAB"")) == (131l));
    assert(digitSum((""abcCd"")) == (67l));
    assert(digitSum((""helloE"")) == (69l));
    assert(digitSum((""woArBld"")) == (131l));
    assert(digitSum((""aAaaaXa"")) == (153l));
    assert(digitSum(("" How are yOu?"")) == (151l));
    assert(digitSum((""You arE Very Smart"")) == (327l));
    }

}
"
HumanEval_67,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //གི་དོན་ལུ་:    //སྦ་ཟེ་ནང་ མན་ངག་གི་འབྲས་བུ་ཚུ་ སྦ་ཟེ་ནང་ཡོད་མི་འདི་ ལོག་གཏང་།    //ཨེ་རེ་དང་ ཨེ་པཱལ་ དེ་ལས་ ཨང་གྲངས་ཧྲིལ་བུམ་འདི་ ཨང་གྲངས་ཡོངས་བསྡོམས་ལུ་མཚོན་འབདཝ་ཨིན།    //ཨེཔ་ལིསི་དང་ ཨེཔ་ལིསི་ དེ་ལས་ མེན་གོའི་འབྲས་བུ་ཚུ་ཨིན། ཨེཔ་ལིསི་དང་ ཨེཔ་ལིསི་ དེ་ལས་ མེན་གོའི་འབྲས་བུ་ཚུ་ཨིན།    //འདི་ཚུ་ཤིང་འབྲས་ཀྱི་ཙེལ་ཀ་ནང་ལུ་ བཀྲམ་སྤེལ་འབད་ཡོདཔ་ཨིན།    //འ་ནི་ལཱ་འདི་ནང་ལུ་ ཁྱོད་ཀྱིས་ ཨེབ་གཏང་འབད་ཡོད་པའི་ ཨང་གྲངས་འདི་ ཨེབ་གཏང་འབད་ནི་ཨིན།    // >>> fruitDistribution((""5 apples and 6 oranges""), (19l))
    // (8l)
    // >>> fruitDistribution((""0 apples and 1 oranges""), (3l))
    // (2l)
    // >>> fruitDistribution((""2 apples and 3 oranges""), (100l))
    // (95l)
    // >>> fruitDistribution((""100 apples and 1 oranges""), (120l))
    // (19l)
    def fruitDistribution(s : String, n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fruitDistribution(s: String, n: Long): Long = {
    val fruits = s.split("" and "").map(_.split("" "")(0).toLong)
    val totalApplesAndOranges = fruits.sum
    n - totalApplesAndOranges
  }
}","    }
    def main(args: Array[String]) = {
    assert(fruitDistribution((""5 apples and 6 oranges""), (19l)) == (8l));
    assert(fruitDistribution((""5 apples and 6 oranges""), (21l)) == (10l));
    assert(fruitDistribution((""0 apples and 1 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""1 apples and 0 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (100l)) == (95l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (5l)) == (0l));
    assert(fruitDistribution((""1 apples and 100 oranges""), (120l)) == (19l));
    }

}
"
HumanEval_68,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་གཞི་ ༡:    //གལ་སྲིད་ གནས་གོང་ཆ་སྙོམ་མེད་པ་ཅིན་ ཡང་ན་ འོག་ལུ་ཡོད་པའི་ཐོ་ཡིག་འདི་ སྟོངམ་ཡོད་པ་ཅིན་ སླར་ལོག་འབདཝ་ཨིན།    //བཏོན་གཏང་མི་ཨང་འདི་ཐོ་ཡིག་ནང་ལུ་ལོག་གཏང་དགོ། [ smalest_value, its index ],     //ཕྲང་སྒྲིག་ནང་ ཕྲང་སྒྲིག་ཆུང་ཤོས་ཅིག་དང་ཕྲང་སྒྲིག་ཆུང་ཤོས་ཅིག་ཡོད་པ་ཅིན་ ཕྲང་སྒྲིག་ཆུང་ཤོས་ཡོད་པའི་ཕྲང་སྒྲིག་དེ་སླར་ལོག་འབདཝ་ཨིན།    //ཕྱིར་བཏོན་འབད་ཡོད་པའི་ཨང་འདི་ ཆུང་ཤོས་རང་ ཕྲང་རྟགས་ཡོད་པའི་ཨང་འདི་དགོཔ་ཨིན།    //ཁྱོད་ཀྱི་ལཱ་འདི་ ཀེར་ཐིག་གཅིག་བཏོན་ཏེ་ ལོག་གཏང་ནི་ཨིན།    //""ཚལ་གྱི་ཡན་ལག་འདི་ ངོ་ཚབ་འབད་ཡོད་པའི་ཐོ་འདི་བྱིན་པ་ཅིན་ ནེ་གེ་རེ་ཊི་མེན་པའི་ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་ཡོདཔ་ཨིན།    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> pluck((List[Long]()))
    // (List[Long]())
    // Example 4:
    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    def pluck(arr : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def pluck(arr: List[Long]): List[Long] = {
    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }
    if (evenNodes.isEmpty) {
      List.empty[Long]
    } else {
      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }
      List(smallestValue, index.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long]())).equals((List[Long]())));
    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));
    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_69,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དེ་བཟུམ་གྱི་གནས་གོང་མེད་པ་ཅིན་ -༡ སླར་ལོག་འབདཝ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུའི་འཕྲལ་འཕྲལ་འདི་ ཨང་གྲངས་ཚུ་ཐོ་ནང་མཐོང་མི་གྱངས་ཁ་ཨིན།    //༠ དང་ རྒྱུན་ལྡན་འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་གནས་གོང་ལས་ སྦོམ་ ཡང་ན་ འདྲན་འདྲ་ཨིན།    //ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཆ་མཉམ་ཆ་མཉམ་ཚུ་ སྟོངམ་མེན་པའི་ཐོ་ཡིག་ཐོབ་ཡོདཔ་ཨིན། ལས་སྦོམ་ཤོས་ཨང་གྲངས་ཆ་མཉམ་སླར་ལོག་འབད།    // >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))
    // (2l)
    // >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (3l)
    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (-1l)
    def search(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def search(lst: List[Long]): Long = {
    val frequencyMap = lst.groupBy(identity).mapValues(_.size)
    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {
      case x :: _ => x
      case Nil => -1L
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));
    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));
    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));
    assert(search((List[Long](1l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));
    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));
    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));
    assert(search((List[Long](10l.toLong))) == (-1l));
    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));
    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));
    }

}
"
HumanEval_70,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དེ་ལས་ལྷག་ལུས་ཨང་གྲངས་ཆ་མཉམ་ནང་ལས་ མཐོ་ཤོས་དང་ དམའ་ཤོས་ དེ་ལས་གཞན་ཚུ་ཨིན།    //ཚད་ལྡན་རིམ་སྒྲིག་འདི་ ཁྱོད་ཀྱིས་ཉུང་མཐའི་གནས་གོང་ལས་ འགོ་བཙུགས་པ་ཅིན་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་འདི་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཚུ་རིམ་པ་སོ་སོར་སྦེ་ལོག་གཏང་འོང་།    // >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))
    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))
    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))
    // >>> strangeSortList((List[Long]()))
    // (List[Long]())
    def strangeSortList(lst : List[Long]) : List[Long] = {
","def strangeSortList(lst: List[Long]): List[Long] = {
    val buffer = lst.sorted.toBuffer
    val result = ArrayBuffer[Long]()
    var takeMin = true

    while (buffer.nonEmpty) {
      if (takeMin) {
        result += buffer.remove(0) // take the minimum
      } else {
        result += buffer.remove(buffer.length - 1) // take the maximum of the remaining
      }
      takeMin = !takeMin
    }

    result.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long]())).equals((List[Long]())));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));
    }

}
"
HumanEval_71,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དེ་ལས་ ཕྱོགས་གསུམ་པ་ལས་ལྷག་སྟེ་མེད།    //གཡོན་གསུམ་གྱིས་ ཟུར་གཉིས་ཆ་རའི་བསྡོམས་སྦོམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་ཅིག་སྦེ་ ཆ་གནས་འབདཝ་ཨིན།    //དེ་མེན་པ་ཅིན་ལོག་གཏང་ -1     //ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཆ་མཉམ་སྦེ་ཡོད་འོང་།    //ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་འདི་བྱིན་ཏེ་ གི་ཁྱབ་ཚད་སླར་ལོག་འབདཝ་ཨིན།    // >>> triangleArea((3l), (4l), (5l))
    // (6.0f)
    // >>> triangleArea((1l), (2l), (10l))
    // -1l
    def triangleArea(a : Long, b : Long, c : Long) : Float = {
","import scala.math._

object Problem {
  def triangleArea(a: Long, b: Long, c: Long): Float = {
    if (a + b > c && a + c > b && b + c > a) {
      val s = (a + b + c) / 2.0
      val area = sqrt(s * (s - a) * (s - b) * (s - c))
      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat
    } else {
      -1f
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((3l), (4l), (5l)) == (6.0f));
    assert(triangleArea((1l), (2l), (10l)) == -1l);
    assert(triangleArea((4l), (8l), (5l)) == (8.18f));
    assert(triangleArea((2l), (2l), (2l)) == (1.73f));
    assert(triangleArea((1l), (2l), (3l)) == -1l);
    assert(triangleArea((10l), (5l), (7l)) == (16.25f));
    assert(triangleArea((2l), (6l), (3l)) == -1l);
    assert(triangleArea((1l), (1l), (1l)) == (0.43f));
    assert(triangleArea((2l), (2l), (10l)) == -1l);
    }

}
"
HumanEval_72,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དངོས་པོ་ q འདི་ཚད་ལྡན་ཨིན་པ་ཅིན་ འཕུར་འགྲུལ་འབད་འོང་། (འདི་ palindromic list ཨིན་) དེ་ལས་ འདི་གི་ཆ་ཤས་ཚུ་གི་བསྡོམས་དེ་ w ཟེར་བའི་ནུས་ཤུགས་སྦོམ་ཤོས་ལས་ ཆུང་བ་ ཡང་ན་ འདྲན་འདྲ་ཨིན།    //དངོས་པོ་ q འདི་འཕུར་འགྱོ་བ་ཅིན་ true དང་ གཞན་འབད་བ་ཅིན་ false སླར་ལོག་འབད་མི་ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> willItFly((List[Long](3l.toLong)), (5l))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    def willItFly(q : List[Long], w : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def willItFly(q: List[Long], w: Long): Boolean = {
    val isPalindromic = q == q.reverse
    val sumOfElements = q.sum
    isPalindromic && sumOfElements <= w
  }

  def main(args: Array[String]): Unit = {
    println(willItFly(List[Long](1L, 2L), 5L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 1L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 9L)) // true
    println(willItFly(List[Long](3L), 5L)) // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));
    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));
    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));
    }

}
"
HumanEval_73,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //ཕྱིར་འཐོན་དང་རྒྱབ་ལོག་གཉིས་ཆ་ར་ལུ་ དབྱེ་བ་འདྲ་མཉམ་སྦེ་ལྷག་ཚུགས། བསྒྱུར་བཅོས་གཅིག་གི་ནང་ ཁྱོད་ཀྱིས་ ཨེཆ་ཨེམ་ཅིག་ ཨེཆ་ཨེམ་གཞན་ཅིག་ལུ་ བསྒྱུར་བཅོས་འབད་ཚུགས།    //ཤོག་ལེབ་འདི་ ཇི་ཨའི་ཨེམ་སི་གི་ཡིག་གཟུགས་ལུ་འགྱུར་དགོ་པ་ཅིན་ ཇི་ཨེམ་སི་དེ་ ཇི་ཨེམ་སི་གི་ཡིག་གཟུགས་ལུ་འགྱུར་དགོ།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་ཅིག་གནང་པ་ཅིན་ ཇི་ཨེམ་ཨེལ་གྱི་ཉུང་མཐའ་ཨང་གྲངས་དེ་འཚོལ་དགོ།    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))
    // (4l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))
    // (1l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))
    // (0l)
    def smallestChange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a list arr of integers, find the minimum number of elements that
  // need to be changed to make the list palindromic.

  def smallestChange(arr: List[Long]): Long = {
    var changes: Long = 0

    for (i <- 0 until arr.length / 2) {
      if (arr(i) != arr(arr.length - 1 - i)) {
        changes += 1
      }
    }

    changes
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  // Output: 4
    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  // Output: 1
    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  // Output: 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));
    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));
    assert(smallestChange((List[Long](1l.toLong))) == (0l));
    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));
    }

}
"
HumanEval_74,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //གལ་སྲིད་ཐོ་ཡིག་གཉིས་ཆ་ར་ལུ་ ཡིག་འབྲུ་གྱངས་ཁ་འདྲ་མཉམ་ཡོད་པ་ཅིན་ དང་པ་ཐོ་ཡིག་འདི་ལོག་གཏང་།    //ཐོ་བཀོད་ནང་ལུ་ཡིག་འབྲུ་ཚུ་ གྱངས་ཁ་གཞན་གྱི་ཐོ་ཡིག་ལས་ཉུང་བ་ཡོདཔ་ཨིན།    //ཨང་གྲངས་ཐིག་ཁྲམ་གཉིས་ཆ་ར་ལུ་ ངོས་ལེན་འབད་ཞིནམ་ལས་ ཡོད་པའི་ཐིག་ཁྲམ་དེ་ལོག་གཏང་ནིའི་འགན་ཡིག་ཅིག་འབྲི་དགོ།    // >>> totalMatch((List[String]()), (List[String]()))
    // (List[String]())
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi"")))
    // (List[String](""hI"", ""Hi""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project"")))
    // (List[String](""hi"", ""admin""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi"")))
    // (List[String](""hI"", ""hi"", ""hi""))
    // >>> totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5"")))
    // (List[String](""4""))
    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {
    val sum1 = lst1.map(_.length).sum
    val sum2 = lst2.map(_.length).sum
    if (sum1 <= sum2) lst1 else lst2
  }
}","    }
    def main(args: Array[String]) = {
    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi""))).equals((List[String](""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5""))).equals((List[String](""4""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi""))).equals((List[String](""hI"", ""Hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi""))).equals((List[String](""hI"", ""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hii""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String]()), (List[String](""this""))).equals((List[String]())));
    assert(totalMatch((List[String](""this"")), (List[String]())).equals((List[String]())));
    }

}
"
HumanEval_75,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //(a) འདི་ ༡༠༠ ལས་ཆུང་བ་ཨིནམ་ཤེས་པ་ཅིན་    //དེ་མེན་པ་ཅིན་ རྫུན་ཁ་བཟེད་འོང་།    //ཨང་གྲངས་འདི་ ཨང་གྲངས་གཙོ་བོ་༣ གྱི་གྱངས་ཁ་ཨིནམ་སྦེ་ཨིན་པ་ཅིན་ གནས་གོང་དེ་བདེན་པ་སྦེ་སླར་ལོག་འབད་ནིའི་འགན་ཡིག་ཅིག་འབྲི་དགོ།    // >>> isMultiplyPrime((30l))
    // (true)
    // 30 = 2 * 3 * 5
    def isMultiplyPrime(a : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isMultiplyPrime(a: Long): Boolean = {
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num <= 3) return true
      if (num % 2 == 0 || num % 3 == 0) return false
      var i = 5
      while (i * i <= num) {
        if (num % i == 0 || num % (i + 2) == 0) return false
        i += 6
      }
      true
    }

    val primes = (2L to 100L).filter(isPrime)
    val primeList = primes.toList

    for {
      i <- primeList.indices
      j <- i until primeList.size
      k <- j until primeList.size
      if primeList(i) * primeList(j) * primeList(k) == a
    } return true

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isMultiplyPrime((5l)) == (false));
    assert(isMultiplyPrime((30l)) == (true));
    assert(isMultiplyPrime((8l)) == (true));
    assert(isMultiplyPrime((10l)) == (false));
    assert(isMultiplyPrime((125l)) == (true));
    assert(isMultiplyPrime((105l)) == (true));
    assert(isMultiplyPrime((126l)) == (false));
    assert(isMultiplyPrime((729l)) == (false));
    assert(isMultiplyPrime((891l)) == (false));
    assert(isMultiplyPrime((1001l)) == (true));
    }

}
"
HumanEval_76,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //x འདི་ n གི་ཤུགས་རྐྱང་ཅིག་ཨིན་པ་ཅིན་ n**int=x     //power of n དང་ གཞན་གནས་སྟངས་ཚུ་ནང་ false ཨིན།    //ཁྱོད་ཀྱི་ལཱ་འདི་ གྲངས་གནས་ x འདི་ ཕྲང་ཨིན་པ་ཅིན་ གནས་གོང་ true སླར་ལོག་འབད་ནིའི་འགན་ཁུར་འདི་འབྲི་ནི་ཨིན།    // >>> isSimplePower((1l), (4l))
    // (true)
    // >>> isSimplePower((2l), (2l))
    // (true)
    // >>> isSimplePower((8l), (2l))
    // (true)
    // >>> isSimplePower((3l), (2l))
    // (false)
    // >>> isSimplePower((3l), (1l))
    // (false)
    // >>> isSimplePower((5l), (3l))
    // (false)
    def isSimplePower(x : Long, n : Long) : Boolean = {
","def isSimplePower(x: Long, n: Long): Boolean = {
        if (n == 1) {
            return x == 1
        }
        
        var value: Long = n
        while (value <= x) {
            if (value == x) {
                return true
            }
            
            if (value > Long.MaxValue / n) {
                return false
            }
            value *= n
        }
        
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(isSimplePower((16l), (2l)) == (true));
    assert(isSimplePower((143214l), (16l)) == (false));
    assert(isSimplePower((4l), (2l)) == (true));
    assert(isSimplePower((9l), (3l)) == (true));
    assert(isSimplePower((16l), (4l)) == (true));
    assert(isSimplePower((24l), (2l)) == (false));
    assert(isSimplePower((128l), (4l)) == (false));
    assert(isSimplePower((12l), (6l)) == (false));
    assert(isSimplePower((1l), (1l)) == (true));
    assert(isSimplePower((1l), (12l)) == (true));
    }

}
"
HumanEval_77,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དྲན་གསོ། ཁྱོད་ཀྱིས་འཛུལ་ཞུགས་འདི་ དུས་རྒྱུན་དུ་ ཆ་གནས་འབད་འོང་ཟེར་ཆ་བཞག་བཏུབ།    //འ་ནི་ཨང་གྲངས་འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་ཅིག་གི་ ཀུ་བིཀ་ཨིན་པ་ཅིན་།    //ཨང་གྲངས་ཧྲིལ་ཨང་ aལེན་ཏེ་ true སླར་ལོག་འབད་མི་འགན་ཡིག་ཅིག་འབྲི་དགོ།    // >>> iscube((1l))
    // (true)
    // >>> iscube((2l))
    // (false)
    // >>> iscube((-1l))
    // (true)
    // >>> iscube((64l))
    // (true)
    // >>> iscube((0l))
    // (true)
    // >>> iscube((180l))
    // (false)
    def iscube(a : Long) : Boolean = {
","def iscube(a: Long): Boolean = {
  val cubeRoot = math.cbrt(a.toDouble).round
  cubeRoot * cubeRoot * cubeRoot == a
}","    }
    def main(args: Array[String]) = {
    assert(iscube((1l)) == (true));
    assert(iscube((2l)) == (false));
    assert(iscube((-1l)) == (true));
    assert(iscube((64l)) == (true));
    assert(iscube((180l)) == (false));
    assert(iscube((1000l)) == (true));
    assert(iscube((0l)) == (true));
    assert(iscube((1729l)) == (false));
    }

}
"
HumanEval_78,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དེ་ལས་ བརྡ་རྟགས་ A,B,C,D,E,F འདི་ཨ་རྟག་རང་ སྦོམ་ཡིག་སྦེ་རང་ཨིན།    //དྲན་གསོ། ཁྱོད་ཀྱིས་ཨེབ་གཏང་འདི་ རྒྱུན་ཆད་མེད་པར་ཕྲང་ ཡང་ན་ སྟོང་པ་སྦེ་བཟོཝ་ཨིན།    //བི་ (=བཅུ་ཆ་༡༡) དང་ཌི་ (=བཅུ་ཆ་༡༣) ཨིན།    //ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཚུ་ ངེས་གཏན་བཟོ་དགོཔ་ཨིན། ༢,༣,༥,༧,     //ཨང་གྲངས་ཚུའི་ཨང་གྲངས་འདི་ ༢,༣,༥,༧,༡༡,༡༣,༡༧ ...ཨིན།    //ཨང་གྲངས་ཧེ་ཀ་ཌེ་སི་མཱལ་འདི་ ༠,༡,༢,༣,༤,༥,༦,༧,༨,༩, A,B,C,D,E,Fཨིན།    //༡ ལས་སྦོམ་ཤོས་འདི་ རང་བཞིན་གྱི་ཨང་གྲངས་ཆུང་བ་གཉིས་ལས་ཐོན་མི་ཨིན།)    //ཨང་གྲངས་ཚུ་ (ཨང་གྲངས་ངོ་མ་ ཡང་ན་ ཨང་གྲངས་ངོ་མ་འདི་ རང་བཞིན་གྱི་ཨང་གྲངས་ཨིན།    //ཨང་གྲངས་ཧེ་ཀ་ཌེ་སི་མཱལ་འདི་ string སྦེ་བཙུགས་ཏེ་ ཨང་གྲངས་ཧེ་ཀ་ཌེ་སི་མཱལ་ ཚུ་རྩིས་སྟོནམ་ཨིན།    //ཁྱོད་ཀྱིས་ ཐོབ་མི་ལས་འགན་ཅིག་འབྲི་དགོཔ་ཨིན།    // >>> hexKey((""AB""))
    // (1l)
    // >>> hexKey((""1077E""))
    // (2l)
    // >>> hexKey((""ABED1A33""))
    // (4l)
    // >>> hexKey((""123456789ABCDEF0""))
    // (6l)
    // >>> hexKey((""2020""))
    // (2l)
    def hexKey(num : String) : Long = {
","def hexKey(num: String): Long = {
  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')
  num.count(ch => primeHexDigits.contains(ch)).toLong
}","    }
    def main(args: Array[String]) = {
    assert(hexKey((""AB"")) == (1l));
    assert(hexKey((""1077E"")) == (2l));
    assert(hexKey((""ABED1A33"")) == (4l));
    assert(hexKey((""2020"")) == (2l));
    assert(hexKey((""123456789ABCDEF0"")) == (6l));
    assert(hexKey((""112233445566778899AABBCCDDEEFF00"")) == (12l));
    }

}
"
HumanEval_79,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ལྷག་ལུས་ཡིག་འབྲུ་ཚུ་ ཤོག་ལེབ་བཟོ་རྣམ་ལུ་ཕན་ཐོགས་ཡོདཔ་ཨིན།    //string གི་འགོ་དང་མཇུག་ནང་ལུ་ ཌི་བི་ཡིག་འབྲུ་གཉིས་རེ་ལྷག་ལུས་འོང་།    //ཨང་གྲངས་ནང་ཐིག་ཡིག་རེ་རེ་ '0' ཡང་ན་ '1' ཨིན།    //binary format. functionའདི་གིས་ string སླར་ལོག་འབད་དགོཔ་ཨིན་ དེ་ལས་ཡིག་འབྲུ་རེ་རེ་གིས་ binary འདི་ངོ་ཚབ་འབདཝ་ཨིན།    //ཁྱོད་ཀྱིས་ ཨང་གྲངས་འདི་ ཨང་གྲངས་བཅུ་གྲངས་སྦེ་ཐོབ་སྟེ་ ཁྱོད་ཀྱི་ལཱ་འདི་ ཨང་གྲངས་འདི་ ལུ་བསྒྱུར་གཏང་ནི་ཨིན།    // >>> decimalToBinary((15l))
    // (""db1111db"")
    // >>> decimalToBinary((32l))
    // (""db100000db"")
    def decimalToBinary(decimal : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def decimalToBinary(decimal: Long): String = {
    ""db"" + decimal.toBinaryString + ""db""
  }
}","    }
    def main(args: Array[String]) = {
    assert(decimalToBinary((0l)).equals((""db0db"")));
    assert(decimalToBinary((32l)).equals((""db100000db"")));
    assert(decimalToBinary((103l)).equals((""db1100111db"")));
    assert(decimalToBinary((15l)).equals((""db1111db"")));
    }

}
"
HumanEval_80,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //string འདི་ hapscala ཨིནམ་ད་ འདི་ནང་ལུ་ ཡུན་ཚད་ཉུང་ཤོས་རང་ 3 དང་ ཚར་གསུམ་གྱི་ཡིག་འབྲུ་སོ་སོ་ཡོད་པ་ཅིན་ཨིན།    //ཁྱོད་ཀྱི་ལཱ་འདི་ stringའདི་ hapscala ཡང་ན་མེན་ན་བརྟག་དཔྱད་འབད་དགོ    //ཁྱོད་ལུ་ string s ཅིག་བྱིན་ནུག    // >>> isHappy((""a""))
    // (false)
    // >>> isHappy((""aa""))
    // (false)
    // >>> isHappy((""abcd""))
    // (true)
    // >>> isHappy((""aabb""))
    // (false)
    // >>> isHappy((""adb""))
    // (true)
    // >>> isHappy((""xyy""))
    // (false)
    def isHappy(s : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isHappy(s: String): Boolean = {
    if (s.length < 3) return false 

    for (i <- 0 until s.length - 2) {
      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {
        return false
      }
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isHappy((""a"")) == (false));
    assert(isHappy((""aa"")) == (false));
    assert(isHappy((""abcd"")) == (true));
    assert(isHappy((""aabb"")) == (false));
    assert(isHappy((""adb"")) == (true));
    assert(isHappy((""xyy"")) == (false));
    assert(isHappy((""iopaxpoi"")) == (true));
    assert(isHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //༠.༠ ཨེ    //> ༠.༠ D-     //> 0.7 D ཨིན།    //>༡.༠ D+ ཨིན།    //> ༡.༣ C-     //> ༡.༧ C ཨིན།    //>༢.༠ C+ ཨིན།    //> 2.3 B- ཟེར་མི་འདི་    //>2.7 B ཟེར་མི་འདི་ཨིན།    //>༣.༠ བི་+ ཨིན།    //> ༣.༣ A- ཟེར་    //> ༣.༧ A ཨིན།    //༤.༠ ཨེ+ ཨིན།    //GPA འབྲི་ཤོག་གི་ཨང་རྟགས་     //འོག་གི་ཐིག་ཁྲམ་འདི་ལག་ལེན་འཐབ་ཐོག་ལས་ ཡིག་འབྲུ་གི་དབྱེ་བ་ཚུ་ ཕྱིར་ཐོན་འབད་ཚུགས་པའི་འགན་ཁ།    //ཁོ་གིས་ སློབ་ཕྲུག་ཚུ་གི་ GPA ཚུ་གི་ཐོ་ཅིག་ ཁྱོད་ལུ་བྱིན་ཏེ་ཡོདཔ་ལས་ ཁྱོད་ཀྱིས་ འབྲི་དགོཔ་ཨིན།    //དཀའ་ངལ་འདི་ མོ་གིས་ཚད་གཞི་བཟོ་ནིའི་དོན་ལུ་ ལག་ལེན་འཐབ་མི་ ཨང་བཏགས་འདི་འབྱང་སོང་ཡོདཔ་ཨིན།    //སློབ་དཔོན་གྱིས་ སློབ་ཕྲུག་ཚུ་ལུ་ ཨང་བཏགས་ནི་གི་ ཨལ་གོར་ཇི་མཱིས་འདི་ མོ་རང་བཟོ་ནུག    //སློབ་དུས་ཀྱི་ བདུན་ཕྲག་མཇུག་འདི་ཨིནམ་ལས་ སློབ་དཔོན་གྱིས་ སྐུགས་ཚད་ཚུ་བྱིན་དགོཔ་ཨིན།    // >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))
    // (List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))
    def numericalLetterGrade(grades : List[Float]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def numericalLetterGrade(grades: List[Float]): List[String] = {
    grades.map { gpa =>
      gpa match {
        case g if g == 4.0 => ""A+""
        case g if g > 3.7 => ""A""
        case g if g > 3.3 => ""A-""
        case g if g > 3.0 => ""B+""
        case g if g > 2.7 => ""B""
        case g if g > 2.3 => ""B-""
        case g if g > 2.0 => ""C+""
        case g if g > 1.7 => ""C""
        case g if g > 1.3 => ""C-""
        case g if g > 1.0 => ""D+""
        case g if g > 0.7 => ""D""
        case g if g > 0.0 => ""D-""
        case _ => ""E""
      }
    }
  }

  def main(args: Array[String]): Unit = {
    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)
    println(numericalLetterGrade(grades)) // Output: List(A+, B, C-, C, A-)
  }
}","    }
    def main(args: Array[String]) = {
    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))));
    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](""D+""))));
    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](""D-""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](""E""))));
    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](""D"", ""D-"", ""C-"", ""B"", ""B+""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](""E"", ""D-""))));
    }

}
"
HumanEval_82,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //length དེ་ཨང་གྲངས་ངོ་མ་ཅིག་ཨིན་པ་ཅིན་ ཡང་ན་ ཨང་གྲངས་རྫུས་མ་ཅིག་ཨིན་པ་ཅིན་     //string ཅིག་ཡོད་པ་ཅིན་ true སླར་ལོག་འབད་ཡོད་པའི་ function འདི་འབྲི་དགོ།    // >>> primeLength((""Hello""))
    // (true)
    // >>> primeLength((""abcdcba""))
    // (true)
    // >>> primeLength((""kittens""))
    // (true)
    // >>> primeLength((""orange""))
    // (false)
    def primeLength(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeLength(string: String): Boolean = {
    val length = string.length

    if (length <= 1) return false
    
    for (i <- 2 to sqrt(length).toInt) {
      if (length % i == 0) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeLength((""Hello"")) == (true));
    assert(primeLength((""abcdcba"")) == (true));
    assert(primeLength((""kittens"")) == (true));
    assert(primeLength((""orange"")) == (false));
    assert(primeLength((""wow"")) == (true));
    assert(primeLength((""world"")) == (true));
    assert(primeLength((""MadaM"")) == (true));
    assert(primeLength((""Wow"")) == (true));
    assert(primeLength(("""")) == (false));
    assert(primeLength((""HI"")) == (true));
    assert(primeLength((""go"")) == (true));
    assert(primeLength((""gogo"")) == (false));
    assert(primeLength((""aaaaaaaaaaaaaaa"")) == (false));
    assert(primeLength((""Madam"")) == (true));
    assert(primeLength((""M"")) == (false));
    assert(primeLength((""0"")) == (false));
    }

}
"
HumanEval_83,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ཚུའི་ནང་ ཚུད་དེ་ཡོད་པའི་ཨང་གྲངས་ཚུའི་ནང་ ཚུད་དེ་ཡོད་པའི་ཨང་གྲངས་ཚུའི་ནང་ ཚུད་དེ་ཡོད་པའི་ཨང་གྲངས་ཚུའི་ནང་ ཚུད་དེ་ཡོདཔ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུམ་ ནུས་པ་ཅན་ཅིག་བྱིནམ་ད་ ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ཀྱི་རྩིས་ལོག་འབདཝ་ཨིན།    def startsOneEnds(n : Long) : Long = {
","def startsOneEnds(n: Long): Long = {
        if (n <= 0) return 0
        
        // Calculate numbers starting with 1: 1XX...X (n-1) digits after 1
        val startWithOne: Long = math.pow(10, n - 1).toLong
        
        // Calculate numbers ending with 1: XX...X1 (n-1) digits before 1
        // but without leading zeroes allowed, i.e., the first digit can't be zero
        val endWithOne: Long = math.pow(10, n - 1).toLong
        
        // Reverse counting: numbers starting and ending with 1 (11XX...X)
        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0
        
        // The total numbers starting or ending, or both, with 1
        startWithOne + endWithOne - bothStartAndEndWithOne
    }
}","    }
    def main(args: Array[String]) = {
    assert(startsOneEnds((1l)) == (1l));
    assert(startsOneEnds((2l)) == (18l));
    assert(startsOneEnds((3l)) == (180l));
    assert(startsOneEnds((4l)) == (1800l));
    assert(startsOneEnds((5l)) == (18000l));
    }

}
"
HumanEval_84,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་     //ཤོག་གྲངས་ཆ་མཉམ་ N ཅིག་ཐོབ་པ་ཅིན་ ཨང་གྲངས་ཚུའི་རྩིས་ཁྲ་ནང་ ཨང་གྲངས་ཚུའི་རྩིས་ཁྲ་སླར་ལོག་འབད།    // >>> solve((1000l))
    // (""1"")
    // >>> solve((150l))
    // (""110"")
    // >>> solve((147l))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    def solve(N : Long) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Given a positive integer N, return the total sum of its digits in binary.
    def solve(N: Long): String = {
        val sumOfDigits = N.toString.map(_.asDigit).sum
        sumOfDigits.toBinaryString
    }

    def main(args: Array[String]): Unit = {
        println(solve(1000L))  // should print ""1""
        println(solve(150L))   // should print ""110""
        println(solve(147L))   // should print ""1100""
    }
}","    }
    def main(args: Array[String]) = {
    assert(solve((1000l)).equals((""1"")));
    assert(solve((150l)).equals((""110"")));
    assert(solve((147l)).equals((""1100"")));
    assert(solve((333l)).equals((""1001"")));
    assert(solve((963l)).equals((""10010"")));
    }

}
"
HumanEval_85,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཨང་གྲངས་ཧྲིལ་བུ་མེད་མི་ཐོ་འདི་བྱིན་ཏེ་ དང་པ་རང་ ཨང་གྲངས་ཧྲིལ་བུ་མེད་མི་ཆ་མཉམ་འདི་བསྡོམས་དགོ།    // >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))
    // (2l)
    def add(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a non-empty list of integers lst. add the even elements that are at odd indices.
  def add(lst: List[Long]): Long = {
    lst.zipWithIndex.collect {
      case (value, index) if index % 2 == 1 && value % 2 == 0 => value
    }.sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));
    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));
    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));
    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));
    }

}
"
HumanEval_86,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //དྲན་གསོ། ཁྱོད་ཀྱིས་ཚིག་དང་ བར་སྟོང་གི་རིམ་པ་ཚུ་ ཚིག་ཡིག་ནང་ལུ་བཞག་དགོ།    //ཚད་འཛིན་གྱི་གོང་ཚད་ལུ་གཞི་བཞག་སྟེ་ ཡར་སེང་འབད་ཐངས་ཨིན།    //ཚིག་གསརཔ་ཅིག་གིས་ཚབ་བཙུགས་ཡོདཔ་ད་ དེ་ནང་ལུ་ ཡིག་འབྲུ་ཆ་མཉམ་རིམ་སྒྲིག་འབད་ཡོདཔ་ཨིན།    //string གི་རིམ་སྒྲིག་འབད་ཡོད་པའི་རྣམ་པ་འདི་ string འདི་ནང་ལུ་ ཚིག་ཆ་མཉམ་ (བར་སྟོང་གིས་སོ་སོར་) ཨིན།    //ཨང་གྲངས་ཐིག་ཁྲམ་ཅིག་ལེན་ཏེ་ འདི་གི་རིམ་སྒྲིག་ཅིག་སླར་ལོག་འབད་མི་ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> antiShuffle((""Hi""))
    // (""Hi"")
    // >>> antiShuffle((""hello""))
    // (""ehllo"")
    // >>> antiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    def antiShuffle(s : String) : String = {
","import scala.collection.mutable.ArrayBuffer

object Problem {
  def antiShuffle(s: String): String = {
    val words = s.split(""(?<=\\s)"")
    val sortedWords = words.map(word => {
      val trimmedWord = word.trim
      val sortedChars = trimmedWord.sorted
      word.replace(trimmedWord, sortedChars)
    })
    sortedWords.mkString("""")
  }

  def main(args: Array[String]): Unit = {
    println(antiShuffle(""Hi""))
    println(antiShuffle(""hello""))
    println(antiShuffle(""Hello World!!!""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(antiShuffle((""Hi"")).equals((""Hi"")));
    assert(antiShuffle((""hello"")).equals((""ehllo"")));
    assert(antiShuffle((""number"")).equals((""bemnru"")));
    assert(antiShuffle((""abcd"")).equals((""abcd"")));
    assert(antiShuffle((""Hello World!!!"")).equals((""Hello !!!Wdlor"")));
    assert(antiShuffle(("""")).equals(("""")));
    assert(antiShuffle((""Hi. My name is Mister Robot. How are you?"")).equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དེ་བཟུམ་སྦེ་ ཐིག་ཁྲམ་ནང་གི་ས་སྒོ་ཚུ་ གྱལ་རིམ་གྱིས་རིམ་སྒྲིག་འབད་དགོ    //ཚད་འཛིན་ཚུ་ འགོ་དང་པ་གྲལ་རིམ་ནང་ ཡར་སེང་གི་རིམ་པ་ལས་རིམ་སྒྲིག་འབད།    //ཕྲང་སྒྲིག་རེ་འདི་ ༠ ལས་འགོ་བཙུགསཔ་ཨིན།    //དེ་ལས་ ཌའི་ལོག་གི་ཐོ་ཡིག་འདི་ [(x1, y1), (x2, y2) ...] འདི་བཟུམ་འབད་འབདཝ་ལས་     //lst དང་ཧྲིལ་ཨང་ x ཚུ་བྱིན་ཏེ་ ཨང་གྲངས་ཧྲིལ་ཨང་ x འདི་ཐོ་ཡིག་ནང་ལུ་འཚོལ་དགོ།    //ཐིག་ཁྲམ་རེ་རེའི་ནང་ ཀེར་ཐིག་གི་གྱངས་ཁ་མ་འདྲཝ་སྦེ་འོང་ཚུགས།    //འདི་ཡང་ matrix དང་འདྲཝ་ཅིག་ཨིན་རུང་ matrix དང་མ་འདྲ་བ་ཨིན།    //ཁྱོད་ཀྱིས་ ཚད་གཉིས་ཅན་གྱི་ གནས་སྡུད་ཅིག་ཐོབ་སྟེ་ འདི་ཡང་ ནང་འཁོད་ཐོ་ཡིག་སྦེ་     // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))
    // (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))
    // >>> getRow((List[List[Long]]()), (1l))
    // (List[Tuple2[Long, Long]]())
    // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))
    // (List[Tuple2[Long, Long]]((2l, 2l)))
    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {
    val coordinates = for {
      (row, rowIndex) <- lst.zipWithIndex
      (value, colIndex) <- row.zipWithIndex
      if value == x
    } yield (rowIndex.toLong, colIndex.toLong)

    coordinates
      .groupBy(_._1)
      .toList
      .sortBy(_._1)
      .flatMap { case (rowIndex, coords) =>
        coords.sortBy(-_._2)
      }
  }
}","    }
    def main(args: Array[String]) = {
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));
    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));
    }

}
"
HumanEval_88,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //* ཁྱོད་ཀྱིས་ བྱིན་ཡོད་པའི་ཐོ་ཡིག་འདི་ བསྒྱུར་བཅོས་མ་རྐྱབས་།    //དྲན་གསོ།    //ཡང་ན་ ཨང་གྲངས་ཚུ་མར་འབབ་འགྱོ་མི་རིམ་པ་ལུ་དབྱེ་བ་ཕྱེ་བ་ཅིན་ (རྩིས་གཞི་དང་པའི་གནས་གོང་དང་ མཇུག་གི་གནས་གོང་) འདི་ཡང་ཨིན།    //ཁྱོད་ཀྱིས་ཐོ་ཡིག་འདི་ཡར་སེང་གི་རིམ་པ་ལུ་དབྱེ་བ་ཕྱེ་ནི་ཨིན་པ་ཅིན་བསྡོམས་ (ཐོག་མའི་ཨང་རྟགས་གོང་ཚད་དང་ མཇུག་གི་ཨང་རྟགས་གོང་ཚད་) འདི་རྣམ་རྟོག་ཨིནམ་སྦེ་མཐོང་འོང་།    //ནུས་མེད་ཨང་གྲངས་ཀྱི་ཐོ་འདི་བྱིན་ཏེ་ རིམ་སྒྲིག་འབད་བའི་ཤུལ་ལས་ མིང་ཐོ་འདི་སླར་ལོག་འབདཝ་ཨིན།    // >>> sortArray((List[Long]()))
    // (List[Long]())
    // >>> sortArray((List[Long](5l.toLong)))
    // (List[Long](5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))
    def sortArray(array : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def sortArray(array: List[Long]): List[Long] = {
    if (array.isEmpty) {
      array
    } else {
      val first = array.head
      val last = array.last
      val sum = first + last
      if (sum % 2 == 0) {
        array.sorted(Ordering[Long].reverse)
      } else {
        array.sorted
      }
    }
  }

  def main(args: Array[String]): Unit = {
    println(sortArray(List[Long]())) // (List[Long]())
    println(sortArray(List[Long](5L))) // (List[Long](5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) // (List[Long](0L, 1L, 2L, 3L, 4L, 5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) // (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));
    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));
    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));
    }

}
"
HumanEval_89,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //གྱངས་ཁ་འདི་ ༢ ལུ་ཡར་འཕར་ཏེ་ ༢ ལུ་ཡར་འཕར་འགྱོ་འོང་།    //ཨེཕ་བི་འདི་ ཚིག་ཡིག་ ཚུ་ ཡོད་པའི་ཐབས་ལམ་ཅིག་ནང་ བསྒྱུར་དགོཔ་ཨིན།    //ཨེབ་གཏང་འབད་ཡོད་པའི་ཡིག་འབྲུ་འདི་ ཕྱིར་འཐོན་འབདཝ་ཨིན།    //ཨེ་རེ་ཅིག་ནང་ཐིག་སྦེ་ལག་ལེན་འཐབ་མི་ ལས་འགན་ཨེན་ཀིརོཊི་ཅིག་བཟོ་ནི་དང་     // >>> encrypt((""hi""))
    // (""lm"")
    // >>> encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> encrypt((""gf""))
    // (""kj"")
    // >>> encrypt((""et""))
    // (""ix"")
    def encrypt(s : String) : String = {
","def encrypt(s: String): String = {
  s.map(c => {
    val rotatedChar = (c - 'a' + 4) % 26 + 'a'
    rotatedChar.toChar
  })
}","    }
    def main(args: Array[String]) = {
    assert(encrypt((""hi"")).equals((""lm"")));
    assert(encrypt((""asdfghjkl"")).equals((""ewhjklnop"")));
    assert(encrypt((""gf"")).equals((""kj"")));
    assert(encrypt((""et"")).equals((""ix"")));
    assert(encrypt((""faewfawefaewg"")).equals((""jeiajeaijeiak"")));
    assert(encrypt((""hellomyfriend"")).equals((""lippsqcjvmirh"")));
    assert(encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    assert(encrypt((""a"")).equals((""e"")));
    }

}
"
HumanEval_90,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དེ་བཟུམ་གྱི་ཆ་ཤས་མེད་པ་ཅིན་ སླར་ལོག་འབདཝ་ཨིན།    //Next_smallest () ལས་འགན་འབྲི་ཞིནམ་ལས་ ཐོ་ཡིག་ནང་གི་ ཨང་གཉིས་པ་ཆུང་ཤོས་འདི་ལོག་བྱིན་འོང་།    //ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཐོབ་ཡོདཔ་ཨིན།    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long]()))
    // None
    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))
    // None
    def nextSmallest(lst : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def nextSmallest(lst: List[Long]): Option[Long] = {
    if (lst.size < 2) return None

    val distinctSorted = lst.distinct.sorted
    if (distinctSorted.size < 2) None
    else Some(distinctSorted(1))
  }
}","    }
    def main(args: Array[String]) = {
    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long]())).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));
    }

}
"
HumanEval_91,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //ཚིག་ཡིག་ཚུ་ """", ""?"" ཡང་ན་ ""!"" དང་གཅིག་ཁར་ དབྱེ་སེལ་འབདཝ་ཨིན།    //རྒྱུད་བསྐུལ་འདི་ ""I"" ཟེར་མི་ཚིག་འདི་དང་འགོ་བཙུགས་མི་ཚིག་ཅིག་ཨིན།    //ཁྱོད་ཀྱིས་ཚིག་ཡིག་གི་ཐིག་ཁྲམ་ཅིག་ཐོབ་སྟེ་ ཁྱོད་ཀྱི་ལཱ་འདི་ ཨང་གྲངས་རྩིས་ནི་ཨིན།    // >>> isBored((""Hello world""))
    // (0l)
    // >>> isBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1l)
    def isBored(S : String) : Long = {
","def isBored(S: String): Long = {
    // Split the input string into sentences using '.', '?' or '!' as delimiters
    val sentences = S.split(""[.!?]"").map(_.trim)

    // Filter sentences that start with 'I' and count them
    sentences.count(sentence => sentence.startsWith(""I""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(isBored((""Hello world"")) == (0l));
    assert(isBored((""Is the sky blue?"")) == (0l));
    assert(isBored((""I love It !"")) == (1l));
    assert(isBored((""bIt"")) == (0l));
    assert(isBored((""I feel good today. I will be productive. will kill It"")) == (2l));
    assert(isBored((""You and I are going for a walk"")) == (0l));
    }

}
"
HumanEval_92,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //གནད་དོན་གཞན་ཚུ་ནང་ false སླར་ལོག་འབདཝ་ཨིན།    //ཨང་གྲངས་གཅིག་འདི་ གཞན་གཉིས་བསྡོམས་དང་ ཨང་གྲངས་ཆ་མཉམ་འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    //ཨང་གྲངས་༣ འབད་མི་ལས་འགན་ཅིག་བཟོ།    // >>> anyInt(5l, 2l, 7l)
    // (true)
    // >>> anyInt(3l, 2l, 2l)
    // (false)
    // >>> anyInt(3l, -2l, 1l)
    // (true)
    // >>> anyInt((3.6f), (-2.2f), 2l)
    // (false)
    def anyInt(x : Float, y : Float, z : Float) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Create a function that takes 3 numbers.
  // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
  // Returns false in any other cases.
  def anyInt(x: Float, y: Float, z: Float): Boolean = {
    val xLong = x.toLong
    val yLong = y.toLong
    val zLong = z.toLong

    // Check if all inputs are actually integers
    if (xLong == x && yLong == y && zLong == z) {
      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong
    }
    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(anyInt(2l, 3l, 1l) == (true));
    assert(anyInt((2.5f), 2l, 3l) == (false));
    assert(anyInt((1.5f), 5l, (3.5f)) == (false));
    assert(anyInt(2l, 6l, 2l) == (false));
    assert(anyInt(4l, 2l, 2l) == (true));
    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));
    assert(anyInt(-4l, 6l, 2l) == (true));
    assert(anyInt(2l, 1l, 1l) == (true));
    assert(anyInt(3l, 4l, 7l) == (true));
    assert(anyInt((3.0f), 4l, 7l) == (false));
    }

}
"
HumanEval_93,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཡིག་འབྲུ་ཚུ་རྐྱངམ་ཅིག་ ཆ་འཇོག་འབད།    //ཨིང་ལིཤ་གི་ཡིག་གཟུགས་ནང་ ཚིག་ཡིག་ཅིག་ཡོདཔ་ཨིན།    //ཌའི་ལོག་ནང་ཡིག་འབྲུ་འདི་ ཌའི་ལོག་གི་ཧེ་མ་ས་སྒོ་ ༢ ཡོད་མི་ཡིག་འབྲུ་འདི་ཨིན།    //ནང་ལུ་ ཚིག་ཡིག་ཆ་མཉམ་ལུ་ ཆེ་ཆུང་གི་ཚབ་ལུ་ ཟེར་བའི་ཚིག་ཡིག་འདི་བཙུགས་ཡོདཔ་ཨིན།    //བརྡ་འཕྲིན་ཅིག་ལེན་ཏེ་ འདི་བཟུམ་ཅིག་སྦེ་ ཨང་བཏགས་མི་ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> encode((""test""))
    // (""TGST"")
    // >>> encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    def encode(message : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def encode(message: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    val vowelMap = Map(
      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',
      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'
    )
    
    message.map { char =>
      if (vowels.contains(char)) {
        vowelMap(char)
      } else if (char.isLetter) {
        if (char.isLower) char.toUpper else char.toLower
      } else {
        char
      }
    }.mkString
  }

  // Test cases
  def main(args: Array[String]): Unit = {
    println(encode(""test""))            // should print ""TGST""
    println(encode(""This is a message"")) // should print ""tHKS KS C MGSSCGG""
  }
}","    }
    def main(args: Array[String]) = {
    assert(encode((""TEST"")).equals((""tgst"")));
    assert(encode((""Mudasir"")).equals((""mWDCSKR"")));
    assert(encode((""YES"")).equals((""ygs"")));
    assert(encode((""This is a message"")).equals((""tHKS KS C MGSSCGG"")));
    assert(encode((""I DoNt KnOw WhAt tO WrItE"")).equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཁྱོད་ཀྱིས་ སྦོམ་ཤོས་ཨང་གྲངས་དང་པོ་འདི་འཚོལ་ཏེ་ ཨང་གྲངས་ཀྱི་བསྡོམས་འདི་ལོག་གཏང་དགོ།    //ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཐོབ་ཡོདཔ་ཨིན།    // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))
    // (10l)
    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))
    // (25l)
    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))
    // (13l)
    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))
    // (11l)
    // >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))
    // (3l)
    // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))
    // (7l)
    def skjkasdkd(lst : List[Long]) : Long = {
","def skjkasdkd(lst: List[Long]): Long = {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) false
    else if (n == 2) true
    else if (n % 2 == 0) false
    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)
  }

  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum

  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)
  sumOfDigits(largestPrime)
}","    }
    def main(args: Array[String]) = {
    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));
    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));
    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));
    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));
    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));
    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));
    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));
    }

}
"
HumanEval_95,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ལས་འགན་འདི་ false སླར་ལོག་འབད་དགོཔ་ཨིན། འདི་ཡང་ འབྲི་ཤོག་འདི་ སྟོངམ་ཡོད་པ་ཅིན་ཨིན།    //case ཡང་ན་ ཀི་ཝིསི་ཆ་མཉམ་ uppercase ལུ་ཐིག་ཁྲམ་ཨིནམ་དང་ གཞན་འབད་བ་ཅིན་ false སླར་ལོག་འབདཝ་ཨིན།    //ཚད་གཞི་འདི་གཞི་བསྟུན་ཏེ་ཡོད་པ་ཅིན་ གཞི་བསྟུན་ཆ་མཉམ་རང་ འོག་ལུ་ཡོད་པའི་ཐིག་ཁྲམ་ཚུ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""b"" -> ""banana"")))
    // (true)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""A"" -> ""banana"", ""B"" -> ""banana"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", 8l -> ""banana"", ""a"" -> ""apple"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345"")))
    // (true)
    def checkDictCase(dict : Map[String,String]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def checkDictCase(dict: Map[String, String]): Boolean = {
    if (dict.isEmpty) return false

    val keys = dict.keys.toList
    val allLowerCase = keys.forall(key => key == key.toLowerCase)
    val allUpperCase = keys.forall(key => key == key.toUpperCase)

    allLowerCase || allUpperCase
  }
}","    }
    def main(args: Array[String]) = {
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""b"" -> ""banana""))) == (true));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""A"" -> ""banana"", ""B"" -> ""banana""))) == (false));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""5"" -> ""banana"", ""a"" -> ""apple""))) == (false));
    assert(checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston""))) == (false));
    assert(checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345""))) == (true));
    assert(checkDictCase((Map[String,String](""fruit"" -> ""Orange"", ""taste"" -> ""Sweet""))) == (true));
    assert(checkDictCase((Map[String,String]())) == (false));
    }

}
"
HumanEval_96,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེར་ན་:     //ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་ ཨང་གྲངས་དང་པོ་དང་ n ལས་ཆུང་བ་ཨིན།    //ནུས་མེད་ཨང་གྲངས་ཆ་མཉམ་ལེན་ཏེ་ དང་པ་ཨང་གྲངས་ n གི་ཐོ་ཡིག་ཅིག་སླར་ལོག་འབད་མི་འགན་འཁྲི་ཅིག་ལག་ལེན་འཐབ་དགོ།    // >>> countUpTo((5l))
    // (List[Long](2l.toLong, 3l.toLong))
    // >>> countUpTo((11l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))
    // >>> countUpTo((0l))
    // (List[Long]())
    // >>> countUpTo((20l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))
    // >>> countUpTo((1l))
    // (List[Long]())
    // >>> countUpTo((18l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))
    def countUpTo(n : Long) : List[Long] = {
","def countUpTo(n: Long): List[Long] = {
    def isPrime(num: Long): Boolean = {
      if (num < 2) return false
      for (i <- 2L to math.sqrt(num).toLong) {
        if (num % i == 0) return false
      }
      true
    }

    (2L until n).filter(isPrime).map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));
    assert(countUpTo((0l)).equals((List[Long]())));
    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));
    assert(countUpTo((1l)).equals((List[Long]())));
    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));
    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));
    }

}
"
HumanEval_97,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ནང་བསྐྱོད་དེ་ དུས་རྒྱུན་དུ་ ཆ་གནས་ཅན་སྦེ་ར་སྡོད་འོང་ཟེར་ཆ་བཞགཔ་ཨིན།    //ཤོག་ལེབ་འདི་ནང་ལུ་ ཨང་གྲངས་ཚུ་ གྱངས་ཁ་སྦེ་བཙུགས་ཏེ་བཙུགསཔ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་པོ་གཉིས་ལེན་ཏེ་ function འདི་ཚངམ་སྦེ་གྲུབ་ཞིནམ་ལས་ སླར་ལོག་འབདཝ་ཨིན།    // >>> multiply((148l), (412l))
    // (16l)
    // >>> multiply((19l), (28l))
    // (72l)
    // >>> multiply((2020l), (1851l))
    // (0l)
    // >>> multiply((14l), (-15l))
    // (20l)
    def multiply(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def multiply(a: Long, b: Long): Long = {
        val unitDigitA = abs(a % 10)
        val unitDigitB = abs(b % 10)
        unitDigitA * unitDigitB
    }

    def main(args: Array[String]): Unit = {
        println(multiply(148l, 412l))  // 16l
        println(multiply(19l, 28l))    // 72l
        println(multiply(2020l, 1851l)) // 0l
        println(multiply(14l, -15l))   // 20l
    }
}","    }
    def main(args: Array[String]) = {
    assert(multiply((148l), (412l)) == (16l));
    assert(multiply((19l), (28l)) == (72l));
    assert(multiply((2020l), (1851l)) == (0l));
    assert(multiply((14l), (-15l)) == (20l));
    assert(multiply((76l), (67l)) == (42l));
    assert(multiply((17l), (27l)) == (49l));
    assert(multiply((0l), (1l)) == (0l));
    assert(multiply((0l), (0l)) == (0l));
    }

}
"
HumanEval_98,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //string s ཅིག་བྱིན་པ་ཅིན་ སྦོམ་ཡིག་གི་སྐད་ཡིག་ཚུ་རྩིས་སྟོནམ་ཨིན།    // >>> countUpper((""aBCdEf""))
    // (1l)
    // >>> countUpper((""abcdefg""))
    // (0l)
    // >>> countUpper((""dBBE""))
    // (0l)
    def countUpper(s : String) : Long = {
","def countUpper(s: String): Long = {
  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')
  s.zipWithIndex.collect {
    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch
  }.size.toLong
}","    }
    def main(args: Array[String]) = {
    assert(countUpper((""aBCdEf"")) == (1l));
    assert(countUpper((""abcdefg"")) == (0l));
    assert(countUpper((""dBBE"")) == (0l));
    assert(countUpper((""B"")) == (0l));
    assert(countUpper((""U"")) == (1l));
    assert(countUpper(("""")) == (0l));
    assert(countUpper((""EEEE"")) == (2l));
    }

}
"
HumanEval_99,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //ཨང་གྲངས་ཆ་མཉམ་གཉིས་ལས་ བསྐོར་རྒྱབ་འབད་ཞིནམ་ལས་ ༠ ལས་ཁ་འབྱལ་གཏང་།    //དེ་ལས་ ཕྲང་ཕྲང་གི་གྲངས་འདི་ རྒྱང་ཕྲང་སྦེ་ཡོད་པ་ཅིན་ ཕྲང་ཕྲང་གི་གྲངས་འདི་ རྒྱང་ཕྲང་སྦེ་ཡོད་པ་ཅིན་    //ཨང་གྲངས་ངོ་ཚབ་འབད་ཡོད་པའི་ གནས་གོང་ (ཐིག་ཁྲམ་) ཅིག་ལེན་མི་ལས་འགན་ཅིག་བཟོ།    // >>> closestInteger((""10""))
    // (10l)
    // >>> closestInteger((""15.3""))
    // (15l)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    def closestInteger(value : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def closestInteger(value: String): Long = {
    val num = value.toDouble
    val lower = floor(num).toLong
    val upper = ceil(num).toLong
    
    if (abs(num - lower) == abs(num - upper)) {
      if (num > 0) upper else lower
    } else {
      round(num)
    }
  }

  def main(args: Array[String]): Unit = {
    println(closestInteger(""10""))  // 10
    println(closestInteger(""15.3"")) // 15
    println(closestInteger(""14.5"")) // 15
    println(closestInteger(""-14.5"")) // -15
  }
}","    }
    def main(args: Array[String]) = {
    assert(closestInteger((""10"")) == (10l));
    assert(closestInteger((""14.5"")) == (15l));
    assert(closestInteger((""-15.5"")) == (-16l));
    assert(closestInteger((""15.3"")) == (15l));
    assert(closestInteger((""0"")) == (0l));
    }

}
"
HumanEval_100,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //i འདི་ཚད་ (i+1) ནང་ རྡོ་གི་གྱངས་ཁ་འདི་ཨིན།    //ཌེ་བི་ནང་ཡོད་པའི་ཐོ་ཡིག་ནང་ལུ་ ཚད་རེ་རེ་ནང་ཡོད་པའི་རྡོ་གྱངས་ཁ་སླར་ལོག་འབདཝ་ཨིན།    //- nའདི་ཆ་མཉམ་ཨིན་པ་ཅིན་ ཤུལ་མའི་ཆ་མཉམ་ཨང་འདི་ཨིན།    //- nའདི་ གྱངས་ཁ་མ་ཚངམ་ཨིན་པ་ཅིན་ ཤུལ་མའི་གྱངས་ཁ་འདི་ཨིན།    //ཤུལ་མའི་གནས་ཚད་ནང་ལུ་ རྡོ་གི་གྱངས་ཁ་འདི་:    //ཐོག་ཚད་དང་པ་འདི་ལུ་ རྡོ་ n ཡོདཔ་ཨིན།    //ཁྱོད་ཀྱིས་ ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ n བྱིན་པ་ཅིན་ ཁྱོད་ཀྱིས་ རྡོ་གི་ཚད་ n འབད་མི་རྡོ་བསྡམ་དགོཔ་ཨིན།    // >>> makeAPile((3l))
    // (List[Long](3l.toLong, 5l.toLong, 7l.toLong))
    def makeAPile(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
    def makeAPile(n: Long): List[Long] = {
        val pile = ListBuffer[Long]()
        var currentStones = n
        for (_ <- 0 until n.toInt) {
            pile += currentStones
            currentStones += (if (currentStones % 2 == 0) 2 else 2)
        }
        pile.toList
    }

    def main(args: Array[String]): Unit = {
        val result = makeAPile(3L)
        println(result)
    }
}","    }
    def main(args: Array[String]) = {
    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));
    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));
    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));
    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));
    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));
    }

}
"
HumanEval_101,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //string འདི་ཚིག་ཡིག་སྦེ་ཁ་ཕྱེ་ཞིནམ་ལས་ ཚིག་ཡིག་གི་ཐོ་ཡིག་ཅིག་ལོག་གཏང་འོང་།    //ཁྱོད་ཀྱིས་ཚིག་ཡིག་ཐིག་ཅིག་བྱིན་ནི་ཨིན་ འདི་ནང་ ཀམ་ཡང་ན་ བར་སྟོང་བཙུགས་ཏེ་ དབྱེ་བ་ཕྱེ་འོང་། ཁྱོད་ཀྱི་ལཱ་འདི་ ཨིན།    // >>> wordsString((""Hi, my name is John""))
    // (List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))
    // >>> wordsString((""One, two, three, four, five, six""))
    // (List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))
    def wordsString(s : String) : List[String] = {
","def wordsString(s: String): List[String] = {
    s.split(""[, ]+"").toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(wordsString((""Hi, my name is John"")).equals((List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))));
    assert(wordsString((""One, two, three, four, five, six"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString((""Hi, my name"")).equals((List[String](""Hi"", ""my"", ""name""))));
    assert(wordsString((""One,, two, three, four, five, six,"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString(("""")).equals((List[String]())));
    assert(wordsString((""ahmed     , gamal"")).equals((List[String](""ahmed"", ""gamal""))));
    }

}
"
HumanEval_102,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //དེ་བཟུམ་ཨང་གྲངས་མེད་པ་ཅིན་ ལས་འགན་འདི་གིས་ -༡ སླར་ལོག་འབདཝ་ཨིན།    //སྦོམ་ཤོས་འདི་ [x, y] ནང་ཚུད་ཡོད་པའི་ཧྲིལ་ཨང་ཆ་མཉམ་ཨིན།    //འ་ནི་འགན་ཁྲམ་འདི་གིས་ ནུས་ལྡན་ཨང་གྲངས་ x དང་ y གཉིས་ལེན་ཏེ་ སླར་ལོག་འབདཝ་ཨིན།    // >>> chooseNum((12l), (15l))
    // (14l)
    // >>> chooseNum((13l), (12l))
    // (-1l)
    def chooseNum(x : Long, y : Long) : Long = {
","def chooseNum(x: Long, y: Long): Long = {
    // Ensure x is the lesser value and y is the greater value
    val (start, end) = if (x > y) (y, x) else (x, y)
    
    // Start from the end of the range and search backwards for an even number
    for (i <- end to start by -1 if i % 2 == 0) {
      return i
    }
    
    // If no even number is found, return -1
    -1
  }
}","    }
    def main(args: Array[String]) = {
    assert(chooseNum((12l), (15l)) == (14l));
    assert(chooseNum((13l), (12l)) == (-1l));
    assert(chooseNum((33l), (12354l)) == (12354l));
    assert(chooseNum((5234l), (5233l)) == (-1l));
    assert(chooseNum((6l), (29l)) == (28l));
    assert(chooseNum((27l), (10l)) == (-1l));
    assert(chooseNum((7l), (7l)) == (-1l));
    assert(chooseNum((546l), (546l)) == (546l));
    }

}
"
HumanEval_103,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //n འདི་ m ལས་སྦོམ་ཡོད་པ་ཅིན་ -1 སླར་ལོག་འབདཝ་ཨིན།    //གྲུབ་འབྲས་འདི་ སྦོ་ལོགས་ཁར་ཡོད་པའི་ཨང་གྲངས་ཧྲིལ་བུམ་ལུ་བསྡུ་སྟེ་ དེ་གཉིས་ལྡན་ལུ་བསྒྱུར་དགོ།    //n ལས་ m ཚུན་གྱི་ཨང་གྲངས་ཧྲིལ་བུའི་བར་ནའི་ (n དང་ m ཚུ་རྩིས་ཏེ་) གྱི་བར་ནའི་གནས་གོང་ཨིན།    //ཁྱོད་ཀྱིས་ ནུས་ལྡན་ཨང་གྲངས་གཉིས་ n དང་ m ཐོབ་ཡོདཔ་དང་ ཁྱོད་ཀྱི་ལཱ་འདི་     // >>> roundedAvg((1l), (5l))
    // ""0b11""
    // >>> roundedAvg((7l), (5l))
    // -1l
    // >>> roundedAvg((10l), (20l))
    // ""0b1111""
    // >>> roundedAvg((20l), (33l))
    // ""0b11010""
    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  // Function to compute the average of the integers from n through m
  def roundedAvg(n: Long, m: Long): Either[String, Long] = {
    if (n > m) {
      Right(-1L)
    } else {
      val count = m - n + 1
      val sum = (n + m) * count / 2
      val average = round(sum.toDouble / count)
      Left(""0b"" + average.toLong.toBinaryString)
    }
  }

  def main(args: Array[String]): Unit = {
    println(roundedAvg(1L, 5L))    // Left(""0b11"")
    println(roundedAvg(7L, 5L))    // Right(-1L)
    println(roundedAvg(10L, 20L))  // Left(""0b1111"")
    println(roundedAvg(20L, 33L))  // Left(""0b11010"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(roundedAvg((1l), (5l)).equals(""0b11""));
    assert(roundedAvg((7l), (13l)).equals(""0b1010""));
    assert(roundedAvg((964l), (977l)).equals(""0b1111001010""));
    assert(roundedAvg((996l), (997l)).equals(""0b1111100100""));
    assert(roundedAvg((560l), (851l)).equals(""0b1011000010""));
    assert(roundedAvg((185l), (546l)).equals(""0b101101110""));
    assert(roundedAvg((362l), (496l)).equals(""0b110101101""));
    assert(roundedAvg((350l), (902l)).equals(""0b1001110010""));
    assert(roundedAvg((197l), (233l)).equals(""0b11010111""));
    assert(roundedAvg((7l), (5l)).equals(-1l));
    assert(roundedAvg((5l), (1l)).equals(-1l));
    assert(roundedAvg((5l), (5l)).equals(""0b101""));
    }

}
"
HumanEval_104,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //དྲན་གསོ། ལོག་བཏང་མི་ཐོ་ཡིག་འདི་ ཡར་སེང་རིམ་སྒྲིག་ནང་དབྱེ་བ་ཕྱེ་དགོ།    //ཨང་གྲངས་ཆ་མཉམ་མེད་པའི་ཆ་ཤས་ཚུ་ཨིན།    //ཤོག་གྲངས་ཧྲིལ་བུམ་ཆ་མཉམ་ x གི་ཐོ་ཡིག་ཐོབ་པ་ཅིན་ ཤོག་གྲངས་ཧྲིལ་བུམ་ཆ་མཉམ་  གི་ཐོ་ཡིག་རིམ་སྒྲིག་འབད་ཡོད་པའི་སླར་ལོག་འབདཝ་ཨིན།    // >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))
    // (List[Long](1l.toLong, 15l.toLong, 33l.toLong))
    // >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))
    // (List[Long]())
    def uniqueDigits(x : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def uniqueDigits(x: List[Long]): List[Long] = {
    def hasEvenDigit(n: Long): Boolean = {
      n.toString.exists(c => (c - '0') % 2 == 0)
    }

    x.filterNot(hasEvenDigit).sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))
    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));
    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));
    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));
    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));
    }

}
"
HumanEval_105,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //གཅིག་ གཉིས་ གསུམ་ བཞི་ ལྔ་ དྲུག་ བདུན་ བརྒྱད་ དགུ་    //འཐོན་མིའི་ཐོ་ཡིག་འདི་ ཕྱིར་བསྒྱུར་འབད་ཞིནམ་ལས་ ཨང་ཡིག་རེ་རེ་འདི་ ནང་ལས་ མིང་ཚིག་དང་འཁྲིལ་ཏེ་ཚབ་རྐྱབས་དགོ།    //ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་འདི་བྱིན་ཏེ་ ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་དབྱེ་བ་ཕྱེ་དགོ། ཨང་གྲངས་འདི་ ༡ དང་ ༩ འི་བར་ན་ཨིན།    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))
    // (List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))
    // If the list is empty, return an empty list:
    // >>> byLength((List[Long]()))
    // (List[String]())
    // If the list has any strange number ignore it:
    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))
    // (List[String](""One""))
    def byLength(arr : List[Long]) : List[String] = {
","import scala.collection.mutable._

object Problem {
  def byLength(arr: List[Long]): List[String] = {
    // Map of digit to its corresponding name
    val numToName = Map(
      1L -> ""One"",
      2L -> ""Two"",
      3L -> ""Three"",
      4L -> ""Four"",
      5L -> ""Five"",
      6L -> ""Six"",
      7L -> ""Seven"",
      8L -> ""Eight"",
      9L -> ""Nine""
    )

    // Filter numbers between 1 and 9
    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)
    // Map filtered and sorted numbers to their corresponding names
    filteredAndSorted.map(numToName)
  }
}","    }
    def main(args: Array[String]) = {
    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))));
    assert(byLength((List[Long]())).equals((List[String]())));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](""One""))));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](""Three"", ""Two"", ""One""))));
    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](""Nine"", ""Eight"", ""Four""))));
    }

}
"
HumanEval_106,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //i གི་གནས་གོང་འདི་ 1 ལས་ i ཚུན་གྱི་ཨང་གྲངས་ཚུ་གྱངས་ཁ་རྐྱབ་ཨིན། (1 * 2 * ... * i)    //iའདི་ ༡ ལས་འགོ་བཙུགསཔ་ཨིན།    //ཡང་ན་ ཨང་གྲངས་ ༡ ལས་ ༡ ཚུན་གྱི་བསྡོམས་ཨིན།    //དེ་ལས་ ཚད་ཀྱི་ཐོ་ཡིག་ཅིག་སླར་ལོག་འབདཝ་ཨིན། འདི་ཡང་ ཚད་གཞི་ i ལུ་ཡོད་པའི་ཆ་ཤས་ཀྱི་གནས་གོང་འདི་ i གི་གནས་གོང་ཨིནམ་དང་ i འདི་ཆ་མཉམ་ཡོད་པ་ཅིན་     //ཚད་འཛིན་སྦེ་ n འབད་མི་ལས་འགན་ f འདི་ལག་ལེན་འཐབ་དགོ།    // >>> f((5l))
    // (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))
    def f(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def f(n: Long): List[Long] = {
        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)
        
        (1L to n).map { i =>
            if (i % 2 == 0) factorial(i) else (1L to i).sum
        }.toList
    }
}","    }
    def main(args: Array[String]) = {
    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));
    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));
    assert(f((1l)).equals((List[Long](1l.toLong))));
    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));
    }

}
"
HumanEval_107,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་གཞི་ ༡:    //ཚད་གཞི་ནང་ཚུད་མི་ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་པེ་ལིན་ཌོརམ།    //ཕྲང་དང་ཕྲང་མེད་པའི་གྲངས་སུ་ཡོད་པའི་ ཌི་ཨེམ་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་    // >>> evenOddPalindrome((3l))
    // ((1l, 2l))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> evenOddPalindrome((12l))
    // ((4l, 6l))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {
","def evenOddPalindrome(n: Long): (Long, Long) = {
  def isPalindrome(x: Long): Boolean = {
    val str = x.toString
    str == str.reverse
  }

  var evenCount: Long = 0
  var oddCount: Long = 0

  for (i <- 1L to n) {
    if (isPalindrome(i)) {
      if (i % 2 == 0) evenCount += 1
      else oddCount += 1
    }
  }

  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));
    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));
    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));
    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));
    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));
    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));
    }

}
"
HumanEval_108,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེར་ན་ -123 གིས་ ཨང་གྲངས་ -1, 2 དང་ 3 ལུ་རྟགས་བཀོད་འབད་ཡོདཔ་ཨིན།    //ཨང་གྲངས་འདི་ ནུས་མེད་ཨིན་པ་ཅིན་ ཨང་གྲངས་དང་པ་འདི་ ནུས་མེད་ཨིན།    //ཨང་གྲངས་ཚུ་ནང་ ཨང་གྲངས་བསྡོམས་ > ༠ ཡོད་པའི་ཆ་ཤས་ཚུ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ལེན་ཏེ་སླར་ལོག་འབད་མི་ count_nums ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> countNums((List[Long]()))
    // (0l)
    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))
    // (1l)
    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))
    // (3l)
    def countNums(arr : List[Long]) : Long = {
","def countNums(arr: List[Long]): Long = {
  arr.count(num => {
    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>
      if (char == '-') acc else acc + (char - '0')
    }
    sumOfDigits > 0
  }).toLong
}","    }
    def main(args: Array[String]) = {
    assert(countNums((List[Long]())) == (0l));
    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));
    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));
    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));
    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));
    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));
    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));
    assert(countNums((List[Long](1l.toLong))) == (1l));
    }

}
"
HumanEval_109,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //དྲན་གསོ། འབྲི་ཤོག་ནང་བཀོད་ཡོད་པའི་ཐོ་ཡིག་ནང་ལུ་ ཚན་པ་མ་འདྲཝ་ཡོད་མི་འདི་ ངེས་བརྟན་ཨིན།    //གལ་སྲིད་ཐོ་འདི་ སྟོངམ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    //དེ་ལས་ true སླར་ལོག་འབད་ ཡང་ན་ false སླར་ལོག་འབད་    //གོང་གི་ལཱ་འདི་འབད་ཞིནམ་ལས་ དབྱེ་བ་ཕྱེ་ཡོད་པའི་ཐོ་འདི་ཐོབ་ཚུགས་པ་ཅིན་     //འགོ་བཙུགས་ཀྱི་ས་སྒོ་དེ་ཐོ་ཡིག་ནང་ཡོད་ འདི་ཡང་ ༠་པའི་བརྡ་བཀོད་འདི་ཨིན།    //ནང་ལུ་ སྤོ་བཤུད་འབད་འོང་།    //གཡས་ཕྱོགས་ལུ་སོར་གཏང་ནིའི་ལཱ་འདི་གིས་ ཐོ་ཡིག་ནང་གི་ཆ་ཕྲན་ཚུ་ གཅིག་གིས་སོར་གཏང་ནི་ཨིན་མས།    //ཁྱོད་ཀྱིས་ ཕྲང་ལམ་འདི་ ཚར་ལེ་ཤ་ཅིག་ར་ བསྒྱུར་བཅོས་འབད་ཚུགས།    //འོག་གི་ལཱ་འདི་ ཤོག་ལེབ་ནང་བཀོད་དེ་ཡོདཔ་ཨིན།    //ཟེར་མི་འདི་འབད་ཞིནམ་ལས་ གྱངས་ཁ་ཡར་མར་འགྱོ་མི་རིམ་པ་ལུ་ཐོ་འདི་དབྱེ་བ་ཕྱེ་ཚུགས།    //ཐོ་བཀོད་ནང་ཡོད་མི་ཨང་ཚུ་ སྟབས་བདེ་ཏོག་ཏོ་སྦེ་རིམ་སྒྲིག་འབད་ནི་ཨིན། ཁྱོད་ཀྱི་ལཱ་འདི་ ཇི་ཨའི་ཨང་འདི་ ཇི་ཨའི་ཨང་འདི་ ཇི་ཨའི་ཨང་འདི་ ཇི་ཨའི་ཨང་འདི་ ཇི་ཨའི་ཨང་འདི་ ཇི་ཨའི་ཨང་འདི་ ཨིན་ན་མེན་ན་ཚུ་ངེས་འཛིན་འབད་ནི་ཨིན།    //ང་བཅས་ནང་ལུ་ ཨང་གྲངས་ཧྲིལ་པོ་ N གི་ཐོ་ཡིག་ 'arr' arr[1], arr[2], ..., arr[N] ཡོདཔ་ཨིན།    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    def moveOneBall(arr : List[Long]) : Boolean = {
","def moveOneBall(arr: List[Long]): Boolean = {
  if (arr.isEmpty) return true

  // Find how many times the array needs to be shifted to become sorted
  val n = arr.length
  var shiftIndex = -1

  for (i <- 0 until n) {
    if (arr(i) > arr((i + 1) % n)) {
      // More than one place where the order breaks means it can't be sorted with a shift
      if (shiftIndex != -1) return false
      shiftIndex = i + 1
    }
  }

  // If no break in order was found, the array is already sorted
  if (shiftIndex == -1) return true

  // Check if shifting by the found index sorts the array
  for (i <- 1 until n) {
    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false
  }
  
  true
}","    }
    def main(args: Array[String]) = {
    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long]())) == (true));
    }

}
"
HumanEval_110,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //དེ་མེན་པ་ཅིན་ ""NO"" སྦེ་ལོག་གཏང་།    //lst1 གི་ཆ་ཤས་ཚུ་ཆ་མཉམ་རང་ཡོད་པ་ཅིན་ ""YES"" སླར་ལོག་འབདཝ་ཨིན།    //གལ་སྲིད་ lst1 དང་ lst2 ཚུ་གི་བར་ན་ དབྱེ་བ་ཕྱེ་ཚུགས་པ་ཅིན་    //lst1 དང་ lst2 ཀྱི་བར་ན་ བརྗེ་སོར་འབད་མི་ཆ་ཤས་ཚུ་གི་གྱངས་ཁ་ལུ་ཚད་གཞི་མེདཔ་ཨིན།    //ཤོག་གྲངས་ཆ་མཉམ་ལས་ 1 གི་ཐོ་ཡིག་བཟོ་ནི་ལུ་ སྦྲགས་བཞག་ཡོདཔ་ཨིན།    //དེ་ལས་ ཌའི་ལོག་འདི་ ཌའི་ལོག་གི་ཆ་ཤས་ཚུ་ བརྗེ་སོར་འབད་ཚུགསཔ་ཨིན་ན་མེན་ན་བརྟག་དཔྱད་འབདཝ་ཨིན།    //འ་ནི་དཀའ་ངལ་འདི་ནང་ལུ་ ཁྱོད་ཀྱིས་གྲངས་ཐོ་གཉིས་ཆ་ར་ལུ་ ལག་ལེན་འཐབ་མི་འགན་འཁྲི་ཅིག་ལག་ལེན་འཐབ་འོང་།    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (""YES"")
    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def exchange(lst1: List[Long], lst2: List[Long]): String = {
    // Check if all elements in lst1 are already even
    if (lst1.forall(_ % 2 == 0)) return ""YES""

    // Find if there's any even number in lst2 to exchange with lst1
    val lst2EvensExist = lst2.exists(_ % 2 == 0)

    // Check if there's also at least one odd in lst1 to swap it out
    val lst1OddsExist = lst1.exists(_ % 2 != 0)

    // Only possible if both an even element in lst2 and an odd element in lst1 exist
    if (lst2EvensExist && lst1OddsExist) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((""YES"")));
    }

}
"
HumanEval_111,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཡི་གུ་ལེ་ཤ་ཅིག་རང་ འབྱུང་པ་ཅིན་ དེ་ཚུ་ག་ར་ལོག་གཏང་།    //འབྲི་ཤོག་གི་ཨང་གྲངས་འདི་ འབྲི་ཤོག་གི་ཨང་གྲངས་དང་ འབྲི་ཤོག་གི་ཨང་གྲངས་ཚུ་དང་ འབྲི་ཤོག་གི་ཨང་གྲངས་ཚུ་དང་ འབྲི་ཤོག་གི་ཨང་གྲངས་ཚུ་དང་ འབྲི་ཤོག་གི་ཨང་གྲངས་ཚུ་དང་ འབྲི་ཤོག་གི་ཨང་གྲངས་ཚུ་ཨིན།    //སྦྲགས་ས་སྒོ་སོ་སོར་ཡོད་མི་ཡིག་ཆུང་གི་ཚབ་ལུ་ string ཅིག་བྱིན་པ་ཅིན་ ཚད་གཞི་འདི་སླར་ལོག་འབདཝ་ཨིན།    // >>> histogram((""a b c""))
    // (Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l))
    // >>> histogram((""a b b a""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""a b c a b""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""b b b b a""))
    // (Map[String,Long](""b"" -> 4l))
    // >>> histogram((""""))
    // (Map[String,Long]())
    def histogram(test : String) : Map[String,Long] = {
","def histogram(test: String): Map[String, Long] = {
        val words = test.split("" "")
        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)

        if (frequencyMap.isEmpty) return Map.empty[String, Long]

        val maxCount = frequencyMap.values.max
        frequencyMap.filter { case (_, count) => count == maxCount }
    }
}","    }
    def main(args: Array[String]) = {
    assert(histogram((""a b b a"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c a b"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c d g"")).equals((Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l, ""d"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""b b b b a"")).equals((Map[String,Long](""b"" -> 4l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram(("""")).equals((Map[String,Long]())));
    assert(histogram((""a"")).equals((Map[String,Long](""a"" -> 1l))));
    }

}
"
HumanEval_112,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་     //ཁྱོད་ཀྱིས་ གྲུབ་འབྲས་ཐིག་ཡིག་དང་ བདེན་/རྫུན་འདི་ཡོད་མི་འདི་ ཌའི་ལོག་འབད་དགོ།    //string འདི་ཧེ་མ་དང་རྒྱབ་ཕྱོགས་གཉིས་ཆ་ར་ལུ་ འདྲ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ འདི་ལུ་ palindrome ཟེར་སླབ་ཨིན།    //དེ་ལས་ གྲུབ་འབྲས་ཐིག་ཁྲམ་འདི་ པཱ་ལིན་ཌོརམསི་ཨིནམ་ཨིན་ན་ བལྟ་དགོ།    //ང་བཅས་ལུ་ string s དང་ c གཉིས་བྱིན་ཡོདཔ་ད་ ཁྱོད་ཀྱིས་ s ནང་གི་ཡིག་འབྲུ་ཚུ་ཆ་མཉམ་འདི་ c ནང་གི་ཡིག་འབྲུ་ཚུ་དང་འདྲན་འདྲ་སྦེ་ཡོད་མི་ཚུ་ སེལ་འཐུ་འབད་དགོཔ་ཨིན།    //ལཱ་འགན་     // >>> reverseDelete((""abcde""), (""ae""))
    // ((""bcd"", false))
    // >>> reverseDelete((""abcdef""), (""b""))
    // ((""acdef"", false))
    // >>> reverseDelete((""abcdedcba""), (""ab""))
    // ((""cdedc"", true))
    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {
","def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {
    // Convert the characters to be deleted into a set for quick lookup
    val deleteSet = c.toSet
    
    // Filter out characters from s that are present in deleteSet
    val filteredString = s.filterNot(deleteSet.contains)
    
    // Check if the filtered string is a palindrome
    val isPalindrome = filteredString == filteredString.reverse
    
    // Return the tuple with the filtered string and the palindrome check result
    (filteredString, isPalindrome)
  }
}","    }
    def main(args: Array[String]) = {
    assert(reverseDelete((""abcde""), (""ae"")).equals(((""bcd"", false))));
    assert(reverseDelete((""abcdef""), (""b"")).equals(((""acdef"", false))));
    assert(reverseDelete((""abcdedcba""), (""ab"")).equals(((""cdedc"", true))));
    assert(reverseDelete((""dwik""), (""w"")).equals(((""dik"", false))));
    assert(reverseDelete((""a""), (""a"")).equals((("""", true))));
    assert(reverseDelete((""abcdedcba""), ("""")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""abcdedcba""), (""v"")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""vabba""), (""v"")).equals(((""abba"", true))));
    assert(reverseDelete((""mamma""), (""mia"")).equals((("""", true))));
    }

}
"
HumanEval_113,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ནང་བསྐྱོད་གྱི་ཐིག་ i'th ནང་ ཨང་གྲངས་རྣམ་རྟོག་མེད་ཀྱི་ཐིག་ཁྲམ་ཚུ་ཡོདཔ་ཨིན།    //ནང་བསྐྱོད་ཀྱི་ string i. "" འདི་ནང་ལུ་ i ཚུ་ཆ་མཉམ་ཨང་གྲངས་ གིས་ཚབ་གཏང་དགོ།    //ཕྱིར་ཐོན་གྱི་ཆ་ཤས་རེ་རེ་ i འདི་ ནང་ལུ་ གྱངས་ཁ་མེད་པའི་ཆ་ཤས་ཚུ་ ཨིནམ་སྦེ་ངེས་འཛིན་འབད་དགོཔ་ཨིན།    //string གི་ཐོ་ཡིག་ཅིག་བྱིནམ་ད་ string རེ་རེ་ནང་ཨང་གྲངས་རྐྱངམ་ཅིག་ཡོདཔ་ལས་ list སླར་ལོག་འབདཝ་ཨིན།    // >>> oddCount((List[String](""1234567"")))
    // (List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))
    // >>> oddCount((List[String](""3"", ""11111111"")))
    // (List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))
    def oddCount(lst : List[String]) : List[String] = {
","def oddCount(lst: List[String]): List[String] = {
    lst.map { str =>
      val oddCount = str.count(c => c.asDigit % 2 != 0)
      val replacedString = s""the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.""
      replacedString
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(oddCount(List(""1234567"")))  // List(""the number of odd elements 4n the str4ng 4 of the 4nput."")
    println(oddCount(List(""3"", ""11111111"")))  // List(""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput."")
  }
}","    }
    def main(args: Array[String]) = {
    assert(oddCount((List[String](""1234567""))).equals((List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))));
    assert(oddCount((List[String](""3"", ""11111111""))).equals((List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))));
    assert(oddCount((List[String](""271"", ""137"", ""314""))).equals((List[String](""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""))));
    }

}
"
HumanEval_114,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་     //གྱངས་ཁ་ཚུ་    //ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཅིག་བྱིན་ཏེ་ སྟོངམ་མེན་པའི་ཐོ་ཡིག་ཆུང་ཤོས་ཀྱི་བསྡོམས་དེ་འཚོལ་དགོ།    // >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))
    // (1l)
    // >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))
    // (-6l)
    def minSubArraySum(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minSubArraySum(nums: List[Long]): Long = {
    var minEndingHere = nums.head
    var minSoFar = nums.head
    
    for (i <- 1 until nums.length) {
      minEndingHere = min(nums(i), minEndingHere + nums(i))
      minSoFar = min(minSoFar, minEndingHere)
    }
    
    minSoFar
  }

  // Test Cases
  def main(args: Array[String]): Unit = {
    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) // Output: 1
    println(minSubArraySum(List(-1l, -2l, -3l))) // Output: -6
  }
}","    }
    def main(args: Array[String]) = {
    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));
    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));
    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));
    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));
    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));
    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));
    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));
    }

}
"
HumanEval_115,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་གཞི་ ༡:    //ཁྱོད་ཀྱིས་བེག་ཚུ་མར་ཕབ་འབད་དགོ་པའི་གྱངས་ཁ་དེ་འཐོན་འབད།    //ཁྱོད་ཀྱི་ལཱ་འདི་ ཆུ་དོང་འདི་ལངམ་སྦེ་འབད་ནིའི་དོན་ལུ་ ཆུ་རྫམ་འདི་ལག་ལེན་འཐབ་དགོ།    //དེ་ལས་བེག་ཆ་མཉམ་ནང་ ཚད་གཞི་གཅིག་རང་ཡོདཔ་ཨིན།    //ཆུ་རྐ་རེ་ལུ་ ཆུ་བླུག་ནིའི་དོན་ལུ་ ཆུ་རྫིང་རེ་ཡོདཔ་ད་    //དེ་ལས་གྲལ་ཐིག་ནང་ལུ་ ༡་རེ་གིས་ ཆུ་གི་ཆ་ཕྲན་གཅིག་འདི་མཚོན་འབདཝ་ཨིན།    //ཁྱོད་ཀྱིས་ ཟུར་ལམ་གྲུ་བཞི་འབད་མི་ ཟུར་ལམ་རེ་ཐོབ་ཨིན། ཟུར་ལམ་རེ་རེ་གིས་ ཟུར་ལམ་གཅིག་འདི་ངོ་ཚབ་འབདཝ་ཨིན།    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))
    // (6l)
    // Example 2:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))
    // (5l)
    // Example 3:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))
    // (0l)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {
","def maxFill(grid: List[List[Long]], capacity: Long): Long = {
  var totalWaterUnits = 0L

  for (row <- grid) {
    totalWaterUnits += row.sum
  }

  // Calculate the number of times you need to lower the buckets
  val bucketOperations = totalWaterUnits / capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)

  bucketOperations
}","    }
    def main(args: Array[String]) = {
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));
    }

}
"
HumanEval_116,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //འདི་ཚུ་ལག་ལེན་འཐབ་དགོ་པ་ཅིན་:    //ཨང་གྲངས་འདྲ་མཉམ་ཅིག་ཡོད་པ་ཅིན་ ཨང་གྲངས་བཅུ་ཐམ་ལུ་གཞི་བཞག་སྟེ་ དབྱེ་བ་ཕྱེ་དགོ།    //གཅིག་གཉིས་སྦེ་བཙུགསཔ་ད་ ཨང་གྲངས་ཚུ་ཡར་འཕར་འགྱོ་ནུག    //འ་ནི་ཀཱད་ལུ་ ཁྱོད་ཀྱིས་ ནུས་མེད་ཨང་གྲངས་ཚུ་  ལུ་གཞི་བཞག་སྟེ་ དབྱེ་བ་ཕྱེ་དགོ།    // >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))
    // (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))
    // >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))
    def sortArray(arr : List[Long]) : List[Long] = {
","def sortArray(arr: List[Long]): List[Long] = {
        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));
    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));
    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    }

}
"
HumanEval_117,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དྲན་གསོ། ཁྱོད་ཀྱིས་ཨེབ་གཏང་ཐིག་ནང་ ཡིག་འབྲུ་དང་བར་སྟོང་ཚུ་རྐྱངམ་ཅིག་ཡོད་ཟེར་ཆ་བཞག་བཏུབ།    //string s འདི་སྟོངམ་ཨིན་པ་ཅིན་ ལས་འགན་འདི་གིས་ སྟོངམ་ཐོ་ཡིག་ཅིག་ལོག་བྱིན་འོང་།    //n གི་ཁ་ཚིག་ཚུ་ ཚིག་ཡིག་གི་རིམ་པ་ནང་འོང་ནིའི་དོན་ལུ་     //string s ནང་ལས་ དོན་དག་ཅིག་རང་ ཡོད་པའི་ཚིག་ཡིག་ཚུ་གི་ཐོ་ཅིག་སླར་ལོག་འབདཝ་ཨིན།    //string s དང་ natural number n ཚུ་བྱིན་པ་ཅིན་ ཁྱོད་ཀྱིས་ ལག་ལེན་བསྟར་སྤྱོད་འབད་དགོཔ་ཨིན།    // >>> selectWords((""Mary had a little lamb""), (4l))
    // (List[String](""little""))
    // >>> selectWords((""Mary had a little lamb""), (3l))
    // (List[String](""Mary"", ""lamb""))
    // >>> selectWords((""simple white space""), (2l))
    // (List[String]())
    // >>> selectWords((""Hello world""), (4l))
    // (List[String](""world""))
    // >>> selectWords((""Uncle sam""), (3l))
    // (List[String](""Uncle""))
    def selectWords(s : String, n : Long) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def selectWords(s: String, n: Long): List[String] = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    def consonantCount(word: String): Int = {
      word.count(c => c.isLetter && !vowels.contains(c))
    }

    if (s.isEmpty) {
      List()
    } else {
      s.split(""\\s+"").filter(word => consonantCount(word) == n).toList
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(selectWords((""Mary had a little lamb""), (4l)).equals((List[String](""little""))));
    assert(selectWords((""Mary had a little lamb""), (3l)).equals((List[String](""Mary"", ""lamb""))));
    assert(selectWords((""simple white space""), (2l)).equals((List[String]())));
    assert(selectWords((""Hello world""), (4l)).equals((List[String](""world""))));
    assert(selectWords((""Uncle sam""), (3l)).equals((List[String](""Uncle""))));
    assert(selectWords((""""), (4l)).equals((List[String]())));
    assert(selectWords((""a b c d e f""), (1l)).equals((List[String](""b"", ""c"", ""d"", ""f""))));
    }

}
"
HumanEval_118,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཁྱོད་ཀྱིས་བྱིན་ཡོད་པའི་ string འདི་ནང་ལུ་ ཨིང་སྐད་ཡིག་འབྲུ་རྐྱངམ་གཅིག་ཡོད་ཟེར་ཆ་བཞག་བཏུབ།    //གོང་གི་གནས་སྟངས་འདི་ནང་ ཚིག་ཡིག་ཚུ་ཐོབ་ཡོདཔ་ཨིན།    //འགོ་བཙུགས་དང་མཇུག་གི་སྐད་སྒྲ་ཚུ་རྩིས་མི་བཏུབ། མེད་པ་ཅིན་ སྟོང་པ་སྦེ་ལོག་གཏང་།    //ཚིག་གི་གཡས་ཁ་ཐུག་ལས་ ཟུར་སྒྲོམ་གཉིས་ (ཡིག་འབྲུ་ཆེ་ཆུང་ལུ་དྭངས་གསལ་སྦེ་) ཨིན།    //ཁྱོད་ཀྱིས་ཚིག་གཅིག་ཐོབ་ཨིན། ཁྱོད་ཀྱི་ལཱ་འདི་ སྦུག་ལས་ ཡོད་མི་ ཕྲང་ཡིག་འདི་འཚོལ་ནི་ཨིན།    // >>> getClosestVowel((""yogurt""))
    // (""u"")
    // >>> getClosestVowel((""FULL""))
    // (""U"")
    // >>> getClosestVowel((""quick""))
    // ("""")
    // >>> getClosestVowel((""ab""))
    // ("""")
    def getClosestVowel(word : String) : String = {
","def getClosestVowel(word: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    for (i <- word.length - 2 until 0 by -1) {
      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {
        return word(i + 1).toString
      }
    }
    
    """"
  }
}","    }
    def main(args: Array[String]) = {
    assert(getClosestVowel((""yogurt"")).equals((""u"")));
    assert(getClosestVowel((""full"")).equals((""u"")));
    assert(getClosestVowel((""easy"")).equals(("""")));
    assert(getClosestVowel((""eAsy"")).equals(("""")));
    assert(getClosestVowel((""ali"")).equals(("""")));
    assert(getClosestVowel((""bad"")).equals((""a"")));
    assert(getClosestVowel((""most"")).equals((""o"")));
    assert(getClosestVowel((""ab"")).equals(("""")));
    assert(getClosestVowel((""ba"")).equals(("""")));
    assert(getClosestVowel((""quick"")).equals(("""")));
    assert(getClosestVowel((""anime"")).equals((""i"")));
    assert(getClosestVowel((""Asia"")).equals(("""")));
    assert(getClosestVowel((""Above"")).equals((""o"")));
    }

}
"
HumanEval_119,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཐབས་ལམ་ལེགས་ཤོམ་ཅིག་ཡོད་པ་ཅིན་ 'Yes' སླར་ལོག་འབད་ དེ་ལས་གཞན་པ་ཅིན་ 'No' སླར་ལོག་འབད་     //""())""འདི་མེན།    //ཚད་གཞི་ཚུ་ཆ་མཉམ་ཨིན། དཔེར་ན་: string '(((() 'འདི་ལེགས་ཤོམ་ཨིན་ དེ་ལས་ string     //string S འདི་ལེགས་ཤོམ་སྦེ་བརྩི་ནི་ཨིན་པ་ཅིན་ S ནང་ལུ་ ནང་ཐིག་ག་ར་ལེགས་ཤོམ་སྦེ་རང་ཡོད་པ་ཅིན་རྐྱངམ་གཅིག་ཨིན།    //ཚད་འཛིན་འབད་ཡོད་པའི་ཐིག་ཁྲམ་འདི་ ལེགས་ལྡན་ཅིག་སྦེ་འཐོན་འོང་།    //ཁྱོད་ཀྱི་ལཱ་འདི་ string གཉིས་བསྡོམས་འབད་ཚུགས་ག་ བལྟ་ནི་ཨིན།    //ནང་ཐིག་ནང་ ""("" ཡང་ན་ ནང་ཐིག་གི་མཐའ་མ་ནང་ "") ""རྐྱངམ་ཅིག་བཙུགས་དགོ།    //ཁྱོད་ཀྱིས་ཐིག་ཁྲམ་གཉིས་ཡོད་པའི་ཐོ་ཡིག་ཐོབ་སྟེ་ ཐིག་ཁྲམ་གཉིས་ཆ་ར་ལུ་ open ཟེར་ཐིག་ཁྲམ་ཡོདཔ་ཨིན།    // >>> matchParens((List[String](""()("", "")"")))
    // (""Yes"")
    // >>> matchParens((List[String]("")"", "")"")))
    // (""No"")
    def matchParens(lst : List[String]) : String = {
","def matchParens(lst: List[String]): String = {
    def isBalanced(s: String): Boolean = {
      var balance = 0
      for (char <- s) {
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1
        if (balance < 0) return false
      }
      balance == 0
    }
    
    val combinations = List(
      lst(0) + lst(1),
      lst(1) + lst(0)
    )
    
    if (combinations.exists(isBalanced)) ""Yes"" else ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(matchParens((List[String](""()("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", "")""))).equals((""No"")));
    assert(matchParens((List[String](""(()(())"", ""())())""))).equals((""No"")));
    assert(matchParens((List[String]("")())"", ""(()()(""))).equals((""Yes"")));
    assert(matchParens((List[String](""(())))"", ""(()())((""))).equals((""Yes"")));
    assert(matchParens((List[String](""()"", ""())""))).equals((""No"")));
    assert(matchParens((List[String](""(()("", ""()))()""))).equals((""Yes"")));
    assert(matchParens((List[String](""(((("", ""((())""))).equals((""No"")));
    assert(matchParens((List[String]("")(()"", ""(()(""))).equals((""No"")));
    assert(matchParens((List[String]("")("", "")(""))).equals((""No"")));
    assert(matchParens((List[String](""("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", ""(""))).equals((""Yes"")));
    }

}
"
HumanEval_120,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་གཞི་ ༡:    //རིང་ཚད་ k དང་ ཨང་གྲངས་ k ལས་ལྷག་པའི་གྲངས་སུ་ཨིན་པའི་ཨེ་རེ་ཚུ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་ arr དང་ ནུས་པའི་ཨང་གྲངས་ཧྲིལ་བུའི་ k ཅིག་བྱིན་པ་ཅིན་ དབྱེ་བ་ཕྱེ་ཡོད་པའི་ཐོ་ཡིག་ཅིག་སླར་ལོག་འབདཝ་ཨིན།    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))
    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))
    // Example 2:
    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))
    // (List[Long](4l.toLong, 4l.toLong))
    // Example 3:
    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))
    // (List[Long](2l.toLong))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    def maximum(arr : List[Long], k : Long) : List[Long] = {
","def maximum(arr: List[Long], k: Long): List[Long] = {
    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));
    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));
    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));
    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));
    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));
    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));
    }

}
"
HumanEval_121,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //ཨང་གྲངས་ཧྲིལ་བུམ་མེན་པའི་ཐོ་ཡིག་ཅིག་བྱིན་པ་ཅིན་ གནས་རིམ་གཉིས་པ་ནང་ཡོད་པའི་ ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་ལོག་གཏང་།    // >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))
    // (12l)
    // >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))
    // (9l)
    // >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))
    // (0l)
    def solution(lst : List[Long]) : Long = {
","def solution(lst: List[Long]): Long = {
  lst.zipWithIndex.collect {
    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num
  }.sum
}","    }
    def main(args: Array[String]) = {
    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));
    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));
    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));
    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));
    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));
    }

}
"
HumanEval_122,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཨེ་རེ་གི་ཆ་ཤས་དང་པའི་ ཀ་ཆ་ཤས་ཚུ་ནང་ལས་ཨང་གྲངས་གཉིས་ལས་ལྷག་སྟེ་མེད་པའི་ཆ་ཤས་ཚུ་གི་བསྡོམས་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུམ་ arr དང་ ཨང་གྲངས་ཧྲིལ་བུམ་ k གི་ཐོ་ཡིག་སྟོངམ་མེན་པའི་སྐབས་སླར་ལོག་འབདཝ་ཨིན།    // >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))
    // (24l)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    def addElements(arr : List[Long], k : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def addElements(arr: List[Long], k: Long): Long = {
    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum
  }

  def main(args: Array[String]): Unit = {
    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)
    println(result) // Output will be 24L
  }
}","    }
    def main(args: Array[String]) = {
    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));
    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));
    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));
    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));
    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));
    }

}
"
HumanEval_123,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //get_odd_collatz(5) གིས་ [1, 5] སླར་ལོག་འབདཝ་ཨིན། # ཀོ་ལ་ཊ་ཛརིམ་པ་ ༥ གི་དོན་ལུ་འདི་ [༥ ༡༦ ༨ ༤ ༢ ༡]ཨིནམ་ལས་ ཨང་གྲངས་ཆ་མེད་ཚུ་ ༡ དང་ ༥ རྐྱངམ་གཅིག་ཨིན།    //དཔེ་འབད་བ་ཅིན་:     //2.ལོག་བཏང་མི་ཐོ་དེ་ ཡར་སེང་རིམ་སྒྲིག་ནང་དབྱེ་བ་ཕྱེ་ཡོདཔ་ཨིན།    //༡། Collatz (༡) འདི་ [1] ཨིན།    //དྲན་གསོ།    //ཚིག་ཡིག་དང་གཅིག་བསྡོམས་ཏེ་ ཚོད་དཔག་འདི་ n གི་གནས་གོང་ག་དེ་ཅིག་ཨིན་རུང་ ཚིག་ཡིག་རིམ་པ་འདི་ དུས་རྒྱུན་དུ་ 1 ལུ་ལྷོད་འོང་།    //ཧེ་མའི་གནས་རིམ་འདི་ གྱངས་ཁ་མ་གཅིགཔ་ཨིན་པ་ཅིན་ ཤུལ་མའི་གནས་རིམ་འདི་ ཧེ་མའི་གནས་རིམ་ལས་ ༣ ལུ་གྱངས་ཁ་རྐྱབ་ཨིན།    //ཤུལ་མའི་གནས་རིམ་འདི་ སྦྲགས་ཏེ་ཡོད་པ་ཅིན་ ཤུལ་མའི་གནས་རིམ་འདི་ གི་ཕྱེད་ཀ་ཨིན།    //འ་ནི་བཟུམ་སྦེ་: ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ཧྲིལ་བུམ་ n ལས་འགོ་བཙུགསཔ་ཨིན། དེ་ལས་ ཚིག་རེ་རེ་ ནང་ལས་ཐོབ་ཨིན།    //ཀོ་ལ་ཊ་གི་དཔའ་བཅམ་འདི་ རྩིས་ཀྱི་དཔའ་བཅམ་ཅིག་ཨིནམ་ད་ འདི་ནང་ དབྱེ་ཞིབ་འབད་ཡོད་པའི་རིམ་པ་ཅིག་ལུ་ འབྲེལ་བ་ཡོདཔ་ཨིན།    //ཤོག་གྲངས་ཚུའི་ནང་ ཨང་གྲངས་ཆ་མཉམ་ n ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཆ་མཉམ་ཚུ་ ཚད་འཛིན་འབད་ཡོད་པའི་ཐོ་ཡིག་ཅིག་ལོག་གཏང་།    // >>> getOddCollatz((5l))
    // (List[Long](1l.toLong, 5l.toLong))
    def getOddCollatz(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def getOddCollatz(n: Long): List[Long] = {
    val oddNumbers = ListBuffer[Long]()
    var number = n
    while (number != 1) {
      if (number % 2 == 1) {
        oddNumbers += number
      }
      number = if (number % 2 == 0) number / 2 else 3 * number + 1
    }
    oddNumbers += 1
    oddNumbers.sorted.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));
    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));
    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));
    }

}
"
HumanEval_124,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཚེས་གྲངས་འདི་ ཨེཆ་ཨེམ་-དི་-ཨའི་ཨའི་གི་རྣམ་པ་ནང་ལུ་དགོཔ་ཨིན།    //ཟླཝ་འདི་ ༡ ལས་ཉུང་ ཡང་ན་ ༡༢ ལས་ལྷག་སྟེ་མི་འོང་།    //ཟླཝ་ ༡,༣,༥,༧,༨,༡༠,༡༢ ཀྱི་དོན་ལུ་ ཉིན་གྲངས་ ༡ ལས་ཉུང་ ཡང་ན་ ༣༡ ལས་ལྷག་སྟེ་མེདཔ་ད་ ཟླཝ་ ༤,༦,༩,༡༡ གྱི་དོན་ལུ་ ཉིན་གྲངས་ ༡ ལས་ཉུང་ ཡང་ན་ ༣༠ ལས་ལྷག་སྟེ་མེདཔ་དང་ ཟླཝ་ ༢ ཀྱི་དོན་ལུ་ ཉིན་གྲངས་ ༡ ལས་ཉུང་ ཡང་ན་ ༢༩ ལས་ལྷག་སྟེ་མེདཔ་ཨིན།    //1. ཚེས་གྲངས་ཐིག་ཁྲམ་འདི་ སྟོངམ་མེན།    //ཚེས་གྲངས་འདི་ འོག་གི་བཀོད་རྒྱ་ཚུ་ཆ་མཉམ་ར་ཆ་མཉམ་ར་ཆ་བཞག་པ་ཅིན་ ཆ་གནས་ཨིན།    //ཚེས་གྲངས་འདི་བདེན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན། དེ་མེན་པ་ཅིན་ false སླར་ལོག་འབདཝ་ཨིན།    //ཁྱོད་ཀྱིས་ ཚེས་གྲངས་ཐིག་ཡིག་ཅིག་ལུ་ ཆ་གནས་འབད་ནིའི་དོན་ལས་ ལས་འགན་ཅིག་འབྲི་དགོཔ་ཨིན།    // >>> validDate((""03-11-2000""))
    // (true)
    // >>> validDate((""15-01-2012""))
    // (false)
    // >>> validDate((""04-0-2040""))
    // (false)
    // >>> validDate((""06-04-2020""))
    // (true)
    // >>> validDate((""06/04/2020""))
    // (false)
    def validDate(date : String) : Boolean = {
","import scala.util.Try

object Problem {
  def validDate(date: String): Boolean = {
    if (date.isEmpty) return false
    
    val datePattern = """"""^(\d{2})-(\d{2})-(\d{4})$"""""".r

    date match {
      case datePattern(monthStr, dayStr, yearStr) => 
        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {
          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>
            month match {
              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31
              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30
              case 2 => day >= 1 && day <= 29
              case _ => false
            }
          case _ => false
        }
      case _ => false
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(validDate((""03-11-2000"")) == (true));
    assert(validDate((""15-01-2012"")) == (false));
    assert(validDate((""04-0-2040"")) == (false));
    assert(validDate((""06-04-2020"")) == (true));
    assert(validDate((""01-01-2007"")) == (true));
    assert(validDate((""03-32-2011"")) == (false));
    assert(validDate(("""")) == (false));
    assert(validDate((""04-31-3000"")) == (false));
    assert(validDate((""06-06-2005"")) == (true));
    assert(validDate((""21-31-2000"")) == (false));
    assert(validDate((""04-12-2003"")) == (true));
    assert(validDate((""04122003"")) == (false));
    assert(validDate((""20030412"")) == (false));
    assert(validDate((""2003-04"")) == (false));
    assert(validDate((""2003-04-12"")) == (false));
    assert(validDate((""04-2003"")) == (false));
    }

}
"
HumanEval_125,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //ཨེཕ་ཊི་, ཨོཌི (a) =༠ ཨོཌི (b) =༡ ཨོཌི (z) =༢༥    //ཀམ་པ་ལུ་ཆ་བགོས་འབད་དགོཔ་ཨིན། ཀམ་པ་མེད་པ་ཅིན་ ཁྱོད་ཀྱིས་ ནང་ལུ་ཡིག་ཆུང་གི་གྱངས་ཁ་འདི་ གྱངས་ཁ་མ་འདྲཝ་སྦེ་ལོག་གཏང་དགོ།    //ཚིག་ཡིག་གི་ཐིག་ཁྲམ་ཅིག་བྱིན་པ་ཅིན་ ཁྱོད་ཀྱིས་ འབྲི་ཤོག་ནང་ སྟོང་པ་ཡོད་མེད་པ་ཅིན་ ཡིག་འབྲུ་ཚུ་ས་སྟོང་ནང་བགོ་བཤའ་རྐྱབ་སྟེ་ལོག་གཏང་།    // >>> splitWords((""Hello world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""Hello,world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""abcdef""))
    // 3l
    def splitWords(txt : String) : Either[List[String], Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def splitWords(txt: String): Either[List[String], Long] = {
    if (txt.contains("" "")) {
      Left(txt.split(""\\s+"").toList)
    } else if (txt.contains("","")) {
      Left(txt.split("","").toList)
    } else {
      val oddOrderCount = txt.toCharArray
        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)
      Right(oddOrderCount.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(splitWords((""Hello world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello,world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello world,!"")).equals(List[String](""Hello"", ""world,!"")));
    assert(splitWords((""Hello,Hello,world !"")).equals(List[String](""Hello,Hello,world"", ""!"")));
    assert(splitWords((""abcdef"")).equals(3l));
    assert(splitWords((""aaabb"")).equals(2l));
    assert(splitWords((""aaaBb"")).equals(1l));
    assert(splitWords(("""")).equals(0l));
    }

}
"
HumanEval_126,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //ཨང་གྲངས་, སླར་ལོག་འབད་ནི་ལུ་ false དེ་ ནེ་གཱཊི་ཨང་གྲངས་དང་ ཨང་གྲངས་ཧྲིལ་པོ་རྐྱངམ་ཅིག་ཨིན་པའི་ མནོ་བསམ་གཏང་དགོ།    //ཤོག་ལེབ་འདི་ ཤོག་ལེབ་གཅིག་ལས་ལྷག་སྟེ་ཡོད་པ་ཅིན་     //ཨང་གྲངས་ཀྱི་ཐོ་འདི་བྱིན་ཏེ་ ཨང་གྲངས་ཚུ་རིམ་སྒྲིག་འབད་རུང་ ཡང་ན་མེན་རུང་ལོག་གཏང་།    // >>> isSorted((List[Long](5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (false)
    def isSorted(lst : List[Long]) : Boolean = {
","def isSorted(lst: List[Long]): Boolean = {
    if (lst.isEmpty || lst.length == 1) return true

    var hasDuplicate = false

    for (i <- 1 until lst.length) {
        if (lst(i) < lst(i - 1)) {
            return false
        }
        if (lst(i) == lst(i - 1)) {
            if (hasDuplicate) return false
            hasDuplicate = true
        } else {
            hasDuplicate = false
        }
    }

    true
}","    }
    def main(args: Array[String]) = {
    assert(isSorted((List[Long](5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));
    assert(isSorted((List[Long]())) == (true));
    assert(isSorted((List[Long](1l.toLong))) == (true));
    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));
    }

}
"
HumanEval_127,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //[འཛུལ་སྒོ་/ཐོན་ཁུངས་] དཔེ་ཚད་ཚུ་:     //བར་མཚམས་གཉིས་ཆ་ར་ ཕྲད་མ་མཐུནམ་ཨིན་པ་ཅིན་ ""NO"" སླར་ལོག་འབདཝ་ཨིན།    //དེ་མེན་པ་ཅིན་ ""NO"" ཟེར་ལོག་གཏང་།    //གལ་སྲིད་ ཟུར་གྱི་རིང་ཚད་དེ་ ཨང་གྲངས་ངོ་མ་ཅིག་ཨིན་པ་ཅིན་ ""YES"" སླར་ལོག་འབད།    //འདི་ཡང་ 1 འདི་ཨང་གྲངས་ངོ་མ་མེན་པའི་ཨང་གྲངས་ཨིན།    //དཔེ་འབད་བ་ཅིན་ བར་མཚམས་ (1,3) དང་ (2,4) གི་བར་མཚམས་འདི་ (2,3) ཨིན།    //བར་མཚམས་འདི་ཨང་གྲངས་ངོ་མ་ཨིན།    //ཁྱོད་ཀྱི་ལཱ་འདི་ འ་ནི་གཉིས་ཆ་རའི་ ཕྲང་ལམ་གྱི་རིང་ཚད་འདི་ ངེས་གཏན་བཟོ་ནི་ཨིན།    //བར་མཚམས་ག་རའི་དོན་ལུ་ འདི་གི་འགོ་འདི་ ཆུང་བ་ ཡང་ན་ མཐའ་མའི་མཐའ་མ་འདི་དང་འདྲན་འདྲ་སྦེ་ ཆ་བཞགཔ་ཨིན།    //འགོ་བཙུགས་དང་མཇུག་གཉིས་ཆ་ར་ཚུད་དེ་ཡོདཔ་ཨིན།    //བྱིན་ཡོད་པའི་བར་སྟོང་འདི་བསྡམས་ཡོདཔ་དང་ འདི་ཡང་ བར་སྟོང་འདི་ (འགོ་བཙུགས་,མཇུག་) ཨིན།    //གནས་ཡུན་རེ་རེ་ནི་ ཨང་གྲངས་ཆ་མཉམ་གྱི་ཆ་ཕྲན་ཨིན། དཔེར་ན་ གནས་ཡུན་ = (འགོ་བཙུགས་, མཇུག་) = (1, 2) ཨིན།    //ཁྱོད་ཀྱིས་བར་སྟོང་གཉིས་ཐོབ་ཡོདཔ་ཨིན།    // >>> intersection(((1l, 2l)), ((2l, 3l)))
    // (""NO"")
    // >>> intersection(((-1l, 1l)), ((0l, 4l)))
    // (""NO"")
    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))
    // (""YES"")
    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {
","import scala.math._

object Problem {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {
    val start = max(interval1._1, interval2._1)
    val end = min(interval1._2, interval2._2)
    if (start > end) return ""NO""

    val length = end - start
    if (isPrime(length)) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((""NO"")));
    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((""NO"")));
    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((""YES"")));
    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((""YES"")));
    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((""NO"")));
    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((""NO"")));
    }

}
"
HumanEval_128,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དྲན་གསོ།: སྟོངམ་ཡོད་པའི་ཨར་ཚུ་གི་དོན་ལུ་སླར་ལོག་འབདཝ་ཨིན།    //ཨང་གྲངས་ཀྱི་ཐོ་ཡིག་ནང་ལུ་ ཨང་གྲངས་རེ་རེ་ལུ་ ༡ དང་ ༡ དང་ ༠ ཟེར་སྟོན་འབདཝ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཆེ་ཆུང་ཚུ་བསྡོམས་ཏེ་ རྟགས་མཚན་ཆ་མཉམ་གྱི་ཐོན་རིམ་གྱིས་ ཕབ་ལེན་འབདཝ་ཨིན།    //ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་ཅིག་ཐོབ་སྟེ་ ལོག་འོང་དགོཔ་ཨིན།    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))
    // Some(9l)
    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))
    // Some(0l)
    // >>> prodSigns((List[Long]()))
    // None
    def prodSigns(arr : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def prodSigns(arr: List[Long]): Option[Long] = {
    if (arr.isEmpty) return None

    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))
    val sumOfMagnitudes = arr.map(_.abs).sum

    Some(sumOfMagnitudes * productOfSigns)
  }

  private def sign(num: Long): Long = {
    if (num > 0) 1
    else if (num < 0) -1
    else 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));
    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));
    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));
    assert(prodSigns((List[Long]())).equals(None));
    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));
    }

}
"
HumanEval_129,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཕྲ་རིང་ནང་ལུ་ཉུང་མཐའ་ལམ་འདི་འགྱོ་མི་ ཀེར་ཐིག་གི་གནས་གོང་ཚུ་རིམ་སྒྲིག་འབད་ཡོད་པའི་ཐོ་ཡིག་ཅིག་སླར་ལོག་འབདཝ་ཨིན།    //འདི་ལུ་ལན་འདི་ངེས་གཏན་སྦེ་རང་ ཨིན།    //lst_A[j] = lst_B[j] ཨིན།    //འདི་བཟུམ་འབད་ lst_A[i] < lst_B[i] དང་ j (1 <= j < i) གི་དོན་ལུ་ ང་བཅས་ལུ་     //lst_Bལས་ལྷག་པའི་ ཚིག་གཞན་ཅིག་ནང་འབད་བ་ཅིན་ ཨང་གྲངས་ཧྲིལ་ཨང་གི་ཐོ་ཡིག་ i (1 <= i <= k) ཅིག་ཡོདཔ་ཨིན།    //རྒྱུད་རིམ་འདི་ (འདི་ཚུ་ལུ་ lst_A དང་ lst_B ཟེར་སླབ་གེ་) རྒྱུད་རིམ་འདི་ཚིག་མཛོད་རིག་པ་ནང་ལུ་ཉུང་སུ་ཅིག་ཨིན།    //ནང་ཐིག་ A དང་ B ཚུ་ནང་ གནས་གོང་ཚུ་རིམ་སྒྲིག་འབད་ཞིནམ་ལས་     //ལམ་ A (རིང་ཚད་ k) འདི་ ལམ་ B (རིང་ཚད་ k) ལས་ཆུང་བ་སྦེ་བརྩི་པ་ཅིན་     //ཁྱོད་ཀྱིས་ ཇི་རིཊི་ནང་ལས་འཐོན་འགྱོ་མི་ཚུགས།    //ཚུ་སོ་སོ་སྦེ་ སྟོན་དགོཔ་ཨིན།)    //ཐབས་ལམ་ k འབད་མི་ལུ་བལྟ་བ་ཅིན་ ཀེལ་སི་ k སྦེ་འོང་ནི་ཨིནམ་ཤེས་དགོ (མི་ ཨིན།    //ཌའི་ལོག་ནང་ལུ་    //འདི་ཡང་ ཁྱོད་ཀྱིས་ ཕྲང་ལམ་གྱི་ཟུར་ཁ་ལུ་ཡོད་པའི་ ཀེལ་སི་ཚུ་ནང་འགྱོ་ཚུགས།    //ཇི་ལག་འདི་ ཇི་ལག་གི་ས་སྒོ་འདི་ ཇི་ལག་གི་ས་སྒོ་འདི་ ཇི་ལག་གི་ས་སྒོ་འདི་ ཇི་ལག་གི་ས་སྒོ་འདི་ ཇི་ལག་གི་ས་སྒོ་འདི་    //ཁྱོད་ཀྱིས་ ཀ་རིང་ཚད་ཀྱི་ཕྲང་ལམ་ཆུང་ཤོས་འདི་ འཚོལ་དགོ་འོང་། ཁྱོད་ཀྱིས་ འགོ་བཙུགས་ཚུགས།    //inclusive འདི་ grid གི་སྒོ་སྒྲིག་ནང་ལུ་ ཚར་གཅིག་རང་མཐོང་འོང་།    //གིཌི་གི་སྒོ་སྒྲིག་རེ་རེའི་ནང་ གནས་གོང་ཅིག་ཡོདཔ་ཨིན། [༡, ན * ན] གི་ནང་དོན་ནང་གི་ཨང་གྲངས་ཧྲིལ་བུམ་རེ་རེ    //གྲལ་ཐིག་ N དང་ ཀེར་ཐིག་ N (N >=2) དང་ ནུས་པའི་ཨང་གྲངས་ཧྲིལ་བུམ་ k ཡོད་མི་ལུ་བརྟེན་།    // >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))
    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))
    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))
    // (List[Long](1l.toLong))
    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minPath(grid: List[List[Long]], k: Long): List[Long] = {
    val n = grid.length
    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))

    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n

    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {
      if (path.length == k) return path
      var minPath: List[Long] = List.fill(k)(Long.MaxValue)
      for ((dx, dy) <- directions) {
        val nx = x + dx
        val ny = y + dy
        if (isValid(nx, ny)) {
          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))
          if (lexCompare(newPath, minPath)) {
            minPath = newPath
          }
        }
      }
      minPath
    }

    def lexCompare(a: List[Long], b: List[Long]): Boolean = {
      a.zip(b).find { case (x, y) => x != y } match {
        case Some((x, y)) => x < y
        case None => false
      }
    }

    var minPathOverall = List.fill(k)(Long.MaxValue)
    for {
      i <- 0 until n
      j <- 0 until n
    } {
      val startingPath = List(grid(i)(j))
      val currentPath = dfs(i, j, startingPath)
      if (lexCompare(currentPath, minPathOverall)) {
        minPathOverall = currentPath
      }
    }
    minPathOverall
  }
}","    }
    def main(args: Array[String]) = {
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));
    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_130,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //Tribonacci གི་རིམ་པ་གི་ཨང་དང་པ་ n+1 ཨིན།    //ཁྱོད་ཀྱིས་ ནུས་མེད་ཨང་གྲངས་ཧྲིལ་བུམ་ n ཅིག་ཐོབ་པ་ཅིན་ ཁྱོད་ཀྱིས་ གི་ཐོ་ཡིག་ཅིག་ལོག་གཏང་དགོ།    //= ༢་༣་༣་ = ༨་    //tri(3) = tri(2) + tri(1) + tri(4) ཨིན།    //tri(4) = ༣ ཨིན་པུཊི་    //tri(2) = ༡ + ༢ / ༢ = ༢ ཨིན།    //དཔེ་འབད་བ་ཅིན་:     //tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) འདི་ nའདི་ གྱངས་ཁ་མ་རྐྱང་པ་ཨིན་པ་ཅིན་ཨིན།    //tri (n) = 1 + n / 2 འདི་ཡང་ n ཅིག་ཨིན་པ་ཅིན་ཨིན།    //tri(1) = ༣ ཨིན་པུཊི་    //Tribonacci sequence འདི་ཡང་བསྐྱར་དུ་འབྱུང་བའི་ཐོག་ལས་གསལ་བཀོད་འབདཝ་ཨིན།    //ཨིན་རུང་ མི་གིས་མ་ཤེས་མི་འདི་ ཏིརི་བཱོན་ཅིཤི་གི་རིམ་པ་ཨིན།    //མི་ག་ར་གིས་ ཕི་བོ་ན་ཅིའི་རིམ་པ་ཤེས་དོ་ཡོདཔ་ཨིན། དེ་ཡང་ ཇི་ཇི་ལུ་ཡོད་པའི་རྩིས་རིག་པ་ཚུ་གིས་ ཞིབ་འཇུག་སྦོམ་སྦེ་རང་འབད་ཡོདཔ་ཨིན།    // >>> tri((3l))
    // (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))
    def tri(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def tri(n: Long): List[Long] = {
    // Initialize list with the first element of the Tribonacci sequence
    val tribonacciSeq = ListBuffer[Long](3)

    // Generate remaining elements up to the nth element
    for (i <- 1L to n) {
      if (i % 2 == 0) {
        // If even, the formula is 1 + n / 2
        tribonacciSeq.append(1 + i / 2)
      } else {
        // If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)
        // tri(n + 1) is handled as we iterate further
        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0
        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0
        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) / 2 else 0 // calculated as if the next is even
        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)
      }
    }

    // Return as a list
    tribonacciSeq.toList
  }

  // Test examples
  def main(args: Array[String]): Unit = {
    println(tri(3)) // List(3, 2, 8)
  }
}","    }
    def main(args: Array[String]) = {
    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));
    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));
    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));
    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));
    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));
    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));
    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));
    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));
    assert(tri((0l)).equals((List[Long](1l.toLong))));
    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_131,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //ཨང་གྲངས་ཆ་མཉམ་རང་ཆ་མཉམ་ཨིན་པ་ཅིན་ ༠ སླར་ལོག་འབདཝ་ཨིན།    //ཤོག་གྲངས་ཧྲིལ་བུམ་ཅིག་ n བྱིན་པ་ཅིན་ ཨང་གྲངས་ཉོག་ཕྲ་འབད་མི་ཚུ་སླར་ལོག་འབདཝ་ཨིན།    // >>> digits((1l))
    // (1l)
    // >>> digits((4l))
    // (0l)
    // >>> digits((235l))
    // (15l)
    def digits(n : Long) : Long = {
","def digits(n: Long): Long = {
    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product
    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product
}","    }
    def main(args: Array[String]) = {
    assert(digits((5l)) == (5l));
    assert(digits((54l)) == (5l));
    assert(digits((120l)) == (1l));
    assert(digits((5014l)) == (5l));
    assert(digits((98765l)) == (315l));
    assert(digits((5576543l)) == (2625l));
    assert(digits((2468l)) == (0l));
    }

}
"
HumanEval_132,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //འདི་ནང་ལུ་ ཤུལ་མམ་གྱི་ནང་ཐིག་གཅིག་ཡང་ སྦྲེལ་མཐུད་འབད་ཡོདཔ་ཨིན།    //ལས་འགན་འདི་ true སླར་ལོག་འབད་དགོཔ་ཨིན། གལ་སྲིད་དང་རྐྱངམ་ཅིག་ ཆ་གནས་ཅན་གྱི་ སྦྲེལ་རྟགས་ཀྱི་རིམ་པ་ ཅིག་ཡོད་པ་ཅིན་ཨིན།    //ཤོག་ཁྲམ་ནང་ ཀེར་ཐིག་གི་རྒྱབ་ལག་རྐྱངམ་ཅིག་ཡོད་པའི་ ནང་ཐིག་ཅིག་སྦེ་ལག་ལེན་འཐབ་མི་ ལས་འགན་ཅིག་བཟོ།    // >>> isNested((""[[]]""))
    // (true)
    // >>> isNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> isNested((""[][]""))
    // (false)
    // >>> isNested((""[]""))
    // (false)
    // >>> isNested((""[[][]]""))
    // (true)
    // >>> isNested((""[[]][[""))
    // (true)
    def isNested(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isNested(string: String): Boolean = {
    var stack = new Stack[Char]()
    var nested = false

    for (char <- string) {
      char match {
        case '[' => stack.push(char)
        case ']' =>
          if (stack.nonEmpty) {
            stack.pop()
            if (stack.nonEmpty) {
              nested = true
            }
          }
      }
      if (nested) return true
    }

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isNested((""[[]]"")) == (true));
    assert(isNested((""[]]]]]]][[[[[]"")) == (false));
    assert(isNested((""[][]"")) == (false));
    assert(isNested((""[]"")) == (false));
    assert(isNested((""[[[[]]]]"")) == (true));
    assert(isNested((""[]]]]]]]]]]"")) == (false));
    assert(isNested((""[][][[]]"")) == (true));
    assert(isNested((""[[]"")) == (false));
    assert(isNested((""[]]"")) == (false));
    assert(isNested((""[[]][["")) == (true));
    assert(isNested((""[[][]]"")) == (true));
    assert(isNested(("""")) == (false));
    assert(isNested((""[[[[[[[["")) == (false));
    assert(isNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ནང་ཐིག་ནང་ཡོད་པའི་ཆ་ཤས་རེ་རེ་ལུ་ གྱངས་ཁ་མཐོ་སའི་ int (_) སྟེང་_ (_) སྦེ་ཡར་འཁོར་རྐྱབས།    //ཁྱོད་ཀྱིས་ ཤོག་ཁྲམ་ནང་ཡོད་པའི་གྱངས་ཁ་ཚུ་ གྱངས་ཁ་གཉིས་སྦེ་བསྡོམས་ཏེ་ལོག་གཏང་དགོ།    //ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཀྱི་ཐོ་འདི་ཐོབ་ཡོདཔ་ཨིན།    // >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))
    // (14l)
    // >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))
    // (98l)
    // >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))
    // (84l)
    // >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))
    // (29l)
    // >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))
    // (6l)
    def sumSquares(lst : List[Float]) : Long = {
","import scala.math._

object Problem {
  def sumSquares(lst: List[Float]): Long = {
    lst.map(x => ceil(x.toDouble).toLong)
      .map(x => x * x)
      .sum
  }

  // Example usage, you can test the function with the given examples:
  def main(args: Array[String]): Unit = {
    println(sumSquares(List(1.0f, 2.0f, 3.0f))) // Output: 14
    println(sumSquares(List(1.0f, 4.0f, 9.0f))) // Output: 98
    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) // Output: 84
    println(sumSquares(List(1.4f, 4.2f, 0.0f))) // Output: 29
    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) // Output: 6
  }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));
    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));
    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));
    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));
    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));
    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));
    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));
    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));
    }

}
"
HumanEval_134,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དྲན་གསོ། ""ཚིག་ཡིག་""འདི་ བར་སྟོང་གིས་སོ་སོ་འཕྱལ་མི་ཡིག་འབྲུ་ཚུ་ཨིན།    //དོན་ཚན་གྱི་ཆ་ཤས་ཅིག་དང་ གཞན་མི་ཆ་ཤས་འདི་རྫུས་མ་ཨིན།    //string གི་ཡིག་འབྲུ་འདི་ ཨེཕ་ཇི་ཡིག་འབྲུ་ཅིག་ཨིནམ་དང་ འདི་མེན་པས།    //མཐའ་མཇུག་གི་ཡིག་འབྲུ་འདི་ ཨིན་པ་ཅིན་ true སླར་ལོག་འབད་མི་ལས་འགན་ཅིག་བཟོ།    // >>> checkIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> checkIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> checkIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> checkIfLastCharIsALetter((""""))
    // (false)
    def checkIfLastCharIsALetter(txt : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def checkIfLastCharIsALetter(txt: String): Boolean = {
        if (txt.isEmpty) return false
        val trimmed = txt.trim
        if (trimmed.isEmpty) return false
        val parts = trimmed.split("" "")
        val lastChars = parts.map(_.last)
        if (lastChars.isEmpty) return false
        val lastChar = trimmed.last
        lastChars.contains(lastChar) && lastChar.isLetter
    }
}","    }
    def main(args: Array[String]) = {
    assert(checkIfLastCharIsALetter((""apple"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e"")) == (true));
    assert(checkIfLastCharIsALetter((""eeeee"")) == (false));
    assert(checkIfLastCharIsALetter((""A"")) == (true));
    assert(checkIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    assert(checkIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    assert(checkIfLastCharIsALetter(("""")) == (false));
    assert(checkIfLastCharIsALetter((""eeeee e "")) == (false));
    assert(checkIfLastCharIsALetter((""apple pie"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //གནས་གོང་གཉིས་མཚུངས་ཨིན།    //དེ་བཟུམ་གྱི་ཆ་ཤས་མེད་པ་ཅིན་ལོག་གཏང་ -1. ཡོད་པའི་ཐོ་ནང་ མི་ཚུད་འོང་།    //དེ་དང་དེ་ཅིག་ཁར་ཡོད་པའི་ཆ་ཤས་འདི་ སྦོམ་ཤོས་དང་འདྲན་འདྲ་མིན་འདུག    //ཇི་ཨེམ་ཨེལ་གྱི་ནང་ཐིག་སྦོམ་ཤོས་སླར་ལོག་འབད་མི་ལས་འགན་ཅིག་བཟོ་དགོ།    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))
    // (3l)
    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (-1l)
    def canArrange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  def canArrange(arr: List[Long]): Long = {
    for (i <- arr.indices.drop(1)) {
      if (arr(i) < arr(i - 1)) return i.toLong
    }
    -1L
  }
}","    }
    def main(args: Array[String]) = {
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));
    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));
    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));
    assert(canArrange((List[Long]())) == (-1l));
    }

}
"
HumanEval_136,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ནེ་གེ་རེ་དང་པེ་སི་ཊི་བཱལ་ཨང་གྲངས་མེད་པ་ཅིན་ དེ་ཚུ་ ནེ་ལུ་སྦེ་ལོག་གཏང་།    //ཤོག་ལེབ་ནང་ལུ་ ནུས་ལྡན་ཨང་གྲངས་ཆ་མཉམ་ཚུ་བཙུགས།    //ནུས་མེད་ཨང་གྲངས་ཚུ་གི་གྲས་ལས་སྦོམ་ཤོས་དང་ b འདི་ཆུང་ཤོས་ཨིན།    //'a'འདི་ ཨིནམ་ལས་ལས་ tuple (a, b) སླར་ལོག་འབད་ཡོད་པའི་ལས་འགན་ཅིག་བཟོ།    // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (Some(None), Some(1l))
    // >>> largestSmallestIntegers((List[Long]()))
    // (Some(None), Some(None))
    // >>> largestSmallestIntegers((List[Long](0l.toLong)))
    // (Some(None), Some(None))
    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {
    val negativeIntegers = lst.filter(_ < 0)
    val positiveIntegers = lst.filter(_ > 0)

    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None
    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None

    (largestNegative, smallestPositive)
  }
}","    }
    def main(args: Array[String]) = {
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));
    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));
    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));
    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));
    }

}
"
HumanEval_138,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་     //ད་ཨང་གྲངས་ n འདི་ཨང་གྲངས་ཆ་མཉམ་ 4 གི་རྩིས་གཞི་སྦེ་འབྲི་ཚུགས་ག་ཟེར་དཔྱད་དེ་བལྟ་     // >>> isEqualToSumEven((4l))
    // (false)
    // >>> isEqualToSumEven((6l))
    // (false)
    // >>> isEqualToSumEven((8l))
    // (true)
    def isEqualToSumEven(n : Long) : Boolean = {
","def isEqualToSumEven(n: Long): Boolean = {
    // Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.
    n >= 8 && n % 2 == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(isEqualToSumEven((4l)) == (false));
    assert(isEqualToSumEven((6l)) == (false));
    assert(isEqualToSumEven((8l)) == (true));
    assert(isEqualToSumEven((10l)) == (true));
    assert(isEqualToSumEven((11l)) == (false));
    assert(isEqualToSumEven((12l)) == (true));
    assert(isEqualToSumEven((13l)) == (false));
    assert(isEqualToSumEven((16l)) == (true));
    }

}
"
HumanEval_139,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //འདི་ནང་ལུ་ n > 0     //brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!     //Brazil གི་གནས་གོང་འདི་ སྦྲགས་ཏེ་ཡོདཔ་ཨིན།    // >>> specialFactorial((4l))
    // (288l)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    def specialFactorial(n : Long) : Long = {
","def specialFactorial(n: Long): Long = {
        def factorial(x: Long): Long = {
            if (x == 0 || x == 1) 1L
            else x * factorial(x - 1)
        }

        (1L to n).map(factorial).product
    }
}","    }
    def main(args: Array[String]) = {
    assert(specialFactorial((4l)) == (288l));
    assert(specialFactorial((5l)) == (34560l));
    assert(specialFactorial((7l)) == (125411328000l));
    assert(specialFactorial((1l)) == (1l));
    }

}
"
HumanEval_140,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དེ་ལས་ཤུལ་མམ་གྱི་ས་སྟོང་ཚུ་ཆ་མཉམ་ལུ་ -  དང་གཅིག་ཁར་ཚབ་རྐྱབས།    //string ལུ་ཤུལ་མམ་གྱི་བར་སྟོང་གཉིས་ལས་ལྷག་ཡོད་པ་ཅིན་     //ཚིག་ཡིག་ཐིག་ཁྲམ་ཅིག་བྱིན་པ་ཅིན་ ས་སྟོང་ག་ར་འོག་ཡིག་སྦེ་ཚབ་རྐྱབས།    // >>> fixSpaces(("" Example""))
    // (""Example"")
    // >>> fixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> fixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> fixSpaces(("" Example 3""))
    // (""_Example-3"")
    def fixSpaces(text : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fixSpaces(text: String): String = {
    val result = new StringBuilder()
    var spaceCount = 0
    var leadingSpace = true
    
    for (ch <- text) {
      if (ch == ' ') {
        spaceCount += 1
      } else {
        if (spaceCount > 0) {
          if (leadingSpace && result.isEmpty) {
            result.append('_')
          } else if (spaceCount == 1) {
            result.append('_')
          } else if (spaceCount > 1) {
            result.append('-')
          }
          spaceCount = 0
        }
        result.append(ch)
        leadingSpace = false
      }
    }
    
    if (spaceCount == 1) {
      result.append('_')
    } else if (spaceCount > 1) {
      result.append('-')
    }
    
    result.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(fixSpaces((""Example"")).equals((""Example"")));
    assert(fixSpaces((""Mudasir Hanif "")).equals((""Mudasir_Hanif_"")));
    assert(fixSpaces((""Yellow Yellow  Dirty  Fellow"")).equals((""Yellow_Yellow__Dirty__Fellow"")));
    assert(fixSpaces((""Exa   mple"")).equals((""Exa-mple"")));
    assert(fixSpaces((""   Exa 1 2 2 mple"")).equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //- ཌོཊི་གི་ཤུལ་ལས་ཡོད་པའི་སབ་སི་ཊི་རིང་འདི་འདི་ཚུ་གི་གྲལ་ལས་ གཅིག་དགོཔ་ཨིན། ['txt', 'exe', 'dll']     //Latin alphabet ('a'-'z' and 'A'-'Z') ཚུ་ནང་ལུ་བཙུགས་ཡོདཔ་ཨིན།    //- ཌོཊི་གི་ཧེ་མ་གི་ཡིག་འབྲུ་འདི་ སྟོངམ་མ་སྡོད་དགོཔ་མ་ཚད་ ནང་ལས་ཡིག་འབྲུ་ཅིག་ལས་ འགོ་བཙུགས་འོང་།    //- ཌའི་ལོག་གི་མིང་ནང་ལུ་ གནད་སྡུད་གཅིག་རང་ཡོད་ '.'     //- ཡིག་སྣོད་མིང་ནང་ལུ་ ཨང་གྲངས་གསུམ་ལས་ལྷག་སྟེ་ཡོད་ནི་མི་འོང་། ('0'-'9')    //འདི་ཚུ་གྲུབ་ནུག    //ཡིག་སྣོད་མིང་འདི་ འོག་གི་གནས་སྟངས་ཚུ་ཆ་མཉམ་ནང་ཡོད་པ་ཅིན་རྐྱངམ་གཅིག་ ཆ་གནས་ཅན་སྦེ་བརྩི་འོང་།    //ཐོ་བཀོད་མིང་འདི་ ཆ་གནས་ཡོད་པ་ཅིན་ ""Yes"" ཟེར་ཨེབ་གཏང་འབད་ དེ་ལས་མེན་པ་ཅིན་ ""No"" ཟེར་ལོག་གཏང་།    //ཡིག་སྣོད་ཅིག་གི་མིང་འདི་ ཕྱིར་བཏོན་འབད་ཡོད་པའི་ཐིག་ཡིག་ཅིག་ལེན་ཏེ་སླར་ལོག་འབད་མི་ ལས་འགན་ཅིག་བཟོ།    // >>> fileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> fileNameCheck((""1example.dll""))
    // (""No"")
    def fileNameCheck(file_name : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fileNameCheck(file_name: String): String = {
    val validExtensions = Set(""txt"", ""exe"", ""dll"")
    val dotIndex = file_name.lastIndexOf('.')

    if (dotIndex == -1) return ""No""

    val beforeDot = file_name.substring(0, dotIndex)
    val afterDot = file_name.substring(dotIndex + 1)

    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return ""No""

    val digitCount = beforeDot.count(_.isDigit)
    if (digitCount > 3) return ""No""

    if (!validExtensions.contains(afterDot)) return ""No""

    ""Yes""
  }

  def main(args: Array[String]): Unit = {
    println(fileNameCheck(""example.txt"")) // ""Yes""
    println(fileNameCheck(""1example.dll"")) // ""No""
    println(fileNameCheck(""test123.exe"")) // ""Yes""
    println(fileNameCheck("".hidden.txt"")) // ""No""
    println(fileNameCheck(""file..txt"")) // ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(fileNameCheck((""example.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""1example.dll"")).equals((""No"")));
    assert(fileNameCheck((""s1sdf3.asd"")).equals((""No"")));
    assert(fileNameCheck((""K.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""MY16FILE3.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""His12FILE94.exe"")).equals((""No"")));
    assert(fileNameCheck((""_Y.txt"")).equals((""No"")));
    assert(fileNameCheck((""?aREYA.exe"")).equals((""No"")));
    assert(fileNameCheck((""/this_is_valid.dll"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.wow"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""this_is_valid.txtexe"")).equals((""No"")));
    assert(fileNameCheck((""#this2_i4s_5valid.ten"")).equals((""No"")));
    assert(fileNameCheck((""@this1_is6_valid.exe"")).equals((""No"")));
    assert(fileNameCheck((""this_is_12valid.6exe4.txt"")).equals((""No"")));
    assert(fileNameCheck((""all.exe.txt"")).equals((""No"")));
    assert(fileNameCheck((""I563_No.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""Is3youfault.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""no_one#knows.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""1I563_Yes3.exe"")).equals((""No"")));
    assert(fileNameCheck((""I563_Yes3.txtt"")).equals((""No"")));
    assert(fileNameCheck((""final..txt"")).equals((""No"")));
    assert(fileNameCheck((""final132"")).equals((""No"")));
    assert(fileNameCheck((""_f4indsartal132."")).equals((""No"")));
    assert(fileNameCheck(("".txt"")).equals((""No"")));
    assert(fileNameCheck((""s."")).equals((""No"")));
    }

}
"
HumanEval_142,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //འོག་ལུ་ཡོད་པའི་ཐོ་ཡིག་ནང་ ནང་ཐིག་ཚུ་ ༣ དང་ ༤ གི་གྱངས་ཁ་སྦེ་མ་འཐོན་མི་ཚུ་ བསྒྱུར་བཅོས་འབད་དགོ་ དེ་ལས་ ལས་འགན་འདི་གིས་ ནང་ཐིག་ཆ་མཉམ་གྱི་བསྡོམས་སླར་ལོག་འབདཝ་ཨིན།    //ལས་འགན་འདི་ 3 གི་གྱངས་ཁ་དང་ ཨང་གྲངས་ཧྲིལ་བུམ་འདི་ ནང་ལུ་བཙུགས་ནི་ཨིན་པ་ཅིན་ འདི་གི་ཨང་གྲངས་དེ་ 4 གི་གྱངས་ཁ་དང་ 3 གི་གྱངས་ཁ་མེན་པ་ཅིན་ ལས་འགན་འདི་གིས་     //འ་ནི་འགན་འདི་གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཅིག་ལེན་འོང་། ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་ཆ་མཉམ་གྱི་དོན་ལུ་འགན་འདི་གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ཐོ་ཡིག་འདི་ སྦེ་ཡོད་པ་ཅིན་ ཨང་གྲངས་ཧྲིལ་བུམ་དེ་  ལུ་ཡར་འཕར་འབདཝ་ཨིན།    //"" ཟེར་བའི་ལན་ལུ་    // >>> lst
    // List[Long](1l.toLong, 2l.toLong, 3l.toLong)
    // >>> lst
    // List[Long]()
    // >>> lst
    // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)
    def sumSquares(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def sumSquares(lst: List[Long]): Long = {
        lst.zipWithIndex.map { case (value, index) =>
            if (index % 3 == 0) {
                value * value
            } else if (index % 4 == 0) {
                value * value * value
            } else {
                value
            }
        }.sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));
    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));
    assert(sumSquares((List[Long]())) == (0l));
    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));
    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));
    assert(sumSquares((List[Long](0l.toLong))) == (0l));
    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));
    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));
    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));
    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));
    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));
    }

}
"
HumanEval_143,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་གཞི་ ༡:    //ཚིག་རིམ་གསརཔ་ནང་ ཚིག་རིམ་དེ་ དང་ཕུའི་ ཚིག་རིམ་དང་འདྲཝ་སྦེ་དགོཔ་ཨིན།    //འདི་ནང་ལུ་ ཚེ་རིང་ཚུ་ཨང་གྲངས་ངོ་མ་ཨིན།    //ཁྱོད་ཀྱིས་ ཚིག་ཡིག་གཞི་རྟེན་ནང་ལས་ ཚིག་ཡིག་ཚུ་ཡོད་པའི་ string སླར་ལོག་འབད་དགོཔ་ཨིན།    //ཚིག་ཡིག་ནང་ལུ་ བར་སྟོང་གིས་སོ་སོར་འབད་མི་ཚིག་ཚུ་ཡོདཔ་ཨིན།    //ཁྱོད་ཀྱིས་ཚིག་ཡིག་ཅིག་ངོ་ཚབ་འབད་ཡོད་པའི་ string ཅིག་ཐོབ་ནུག    // >>> wordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> wordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    def wordsInSentence(sentence : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isPrime(n: Int): Boolean = {
    if (n < 2) false
    else if (n == 2) true
    else !(2 to sqrt(n).toInt).exists(n % _ == 0)
  }

  def wordsInSentence(sentence: String): String = {
    val words = sentence.split("" "")
    val primeLengthWords = words.filter(word => isPrime(word.length))
    primeLengthWords.mkString("" "")
  }
  
  // Example usage:
  // println(wordsInSentence(""This is a test""))
  // println(wordsInSentence(""lets go for swimming""))
}","    }
    def main(args: Array[String]) = {
    assert(wordsInSentence((""This is a test"")).equals((""is"")));
    assert(wordsInSentence((""lets go for swimming"")).equals((""go for"")));
    assert(wordsInSentence((""there is no place available here"")).equals((""there is no place"")));
    assert(wordsInSentence((""Hi I am Hussein"")).equals((""Hi am Hussein"")));
    assert(wordsInSentence((""go for it"")).equals((""go for it"")));
    assert(wordsInSentence((""here"")).equals(("""")));
    assert(wordsInSentence((""here is"")).equals((""is"")));
    }

}
"
HumanEval_144,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཁྱོད་ཀྱིས་ x དང་ n འདི་ ཆ་ཤས་ངོ་མ་ཨིནམ་སྦེ་ཆ་བཞགཔ་ད་ སྦྲེལ་རྟགས་ལུ་ ༠ ཟེར་མེདཔ་ཨིན།    //<གྲངས་རྩིས་>/<གྲངས་རྩིས་> འདི་ནང་ལུ་ གྲངས་རྩིས་དང་གྲངས་རྩིས་གཉིས་ཆ་ར་ ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ཧྲིལ་བུམ་ཨིན།    //x དང་ n གཉིས་ཆ་རང་ལུ་ ཨེགསི་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་    //x * n འདི་གྲངས་ཆ་ཧྲིལ་བུམ་སྦེ་ངེས་འཛིན་འབད་བ་ཅིན་ ལས་འགན་གྱིས་ true སླར་ལོག་འབདཝ་ཨིན།    //ཁྱོད་ཀྱི་ལཱ་འདི་ བརྡ་བཀོད་འདི་འཇམ་ཏོང་ཏོ་འབད་འབད་འབད་ནིའི་དོན་ལས་ ལས་འགན་ཅིག་ལག་ལེན་འཐབ་དགོ།    // >>> simplify((""1/5""), (""5/1""))
    // (true)
    // >>> simplify((""1/6""), (""2/1""))
    // (false)
    // >>> simplify((""7/10""), (""10/2""))
    // (false)
    def simplify(x : String, n : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def simplify(x: String, n: String): Boolean = {
    def parseFraction(fraction: String): (Int, Int) = {
      val parts = fraction.split(""/"")
      (parts(0).toInt, parts(1).toInt)
    }

    val (numX, denX) = parseFraction(x)
    val (numN, denN) = parseFraction(n)

    val multipliedNumerator = numX * numN
    val multipliedDenominator = denX * denN

    multipliedNumerator % multipliedDenominator == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/6""), (""2/1"")) == (false));
    assert(simplify((""5/1""), (""3/1"")) == (true));
    assert(simplify((""7/10""), (""10/2"")) == (false));
    assert(simplify((""2/10""), (""50/10"")) == (true));
    assert(simplify((""7/2""), (""4/2"")) == (true));
    assert(simplify((""11/6""), (""6/1"")) == (true));
    assert(simplify((""2/3""), (""5/2"")) == (false));
    assert(simplify((""5/2""), (""3/5"")) == (false));
    assert(simplify((""2/4""), (""8/4"")) == (true));
    assert(simplify((""2/4""), (""4/2"")) == (true));
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //ཤོག་ལེབ་ཚུ་ ཨང་དང་པའི་ཐོ་ཡིག་ནང་ཡོད་མི་ ཨང་ཡིག་གི་གཞི་བསྟུན་ལུ་གཞི་བཞག་སྟེ་རིམ་སྒྲིག་འབད།    //དྲན་གསོ། ཨང་གྲངས་ཚུ་བསྡོམས་ཏེ་ཡོད་པའི་ ཨང་གྲངས་ལེ་ཤ་ཡོད་པ་ཅིན་     //ཨང་གྲངས་ཚུ་ཡར་སེང་འགྱོ་ནིའི་རིམ་པ་ལུ་གཞི་བཞག་སྟེ་ཨིན།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་འདི་ དབྱེ་བ་ཕྱེ་མི་ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))
    // (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))
    // >>> orderByPoints((List[Long]()))
    // (List[Long]())
    def orderByPoints(nums : List[Long]) : List[Long] = {
","def orderByPoints(nums: List[Long]): List[Long] = {
    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum
    
    nums.zipWithIndex
      .sortBy { case (num, index) => (digitSum(num), index) }
      .map(_._1)
  }
}","    }
    def main(args: Array[String]) = {
    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));
    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));
    assert(orderByPoints((List[Long]())).equals((List[Long]())));
    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));
    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));
    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));
    }

}
"
HumanEval_146,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //ཨང་གྲངས་ཀྱི་ཨང་གྲངས་དང་པ་དང་མཇུག་འདི་ གྱངས་ཁ་རྐྱང་པ་ (1, 3, 5, 7, 9) ཨིན།    //ཨང་གྲངས་དེ་ ༡༠ ལས་ལྷག་སྟེ་ཡོད་པ་ཅིན་ ཨང་གྲངས་དེ་གཉིས་ཆ་ར་ལུ་ ཨང་གྲངས་དེ་ཅིག་རང་ ཨིན།    //ཨང་གྲངས་ཀྱི་ཐོ་ཡིག་ཅིག་ནང་བཙུགས་ཏེ་ ལོག་གཏང་མི་ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))
    // (1l)
    // >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))
    // (2l)
    def specialFilter(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def specialFilter(nums: List[Long]): Long = {
    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
    
    nums.count { num =>
      val absNumStr = num.abs.toString
      val firstDigit = absNumStr.head
      val lastDigit = absNumStr.last
      
      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)
    }.toLong
  }

  def main(args: Array[String]): Unit = {
    println(specialFilter(List(15L, -73L, 14L, -15L))) // Output: 1
    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) // Output: 2
  }
}","    }
    def main(args: Array[String]) = {
    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));
    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));
    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));
    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));
    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));
    assert(specialFilter((List[Long](1l.toLong))) == (0l));
    assert(specialFilter((List[Long]())) == (0l));
    }

}
"
HumanEval_147,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //a[i] + a[j] + a[k] འདི་ ༣ གི་གྱངས་ཁ་ཨིན།    //གནས་གོང་ i < j < k ཡོད་པའི་གནས་གོང་ a གི་ triples (a[i], a[j], a[k]) གི་གྱངས་ཁ་སླར་ལོག་འབདཝ་ཨིན།    //i (༡ ≤ i ≤ n) གི་དོན་ལུ་ a[i] =i * i - i + 1 གི་གནས་གོང་ཨིན།    //ཁྱོད་ཀྱིས་ ནུས་ལྡན་ཨང་གྲངས་ n ཐོབ་པ་ཅིན་ ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཧྲིལ་བུམ་ list a བཟོ་དགོཔ་ཨིན།    // >>> getMaxTriples((5l))
    // (1l)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    def getMaxTriples(n : Long) : Long = {
","def getMaxTriples(n: Long): Long = {
    val a = (1L to n).map(i => i * i - i + 1).toList
    var count = 0L

    for {
      i <- 0L until n
      j <- i + 1 until n
      k <- j + 1 until n
    } {
      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(getMaxTriples((5l)) == (1l));
    assert(getMaxTriples((6l)) == (4l));
    assert(getMaxTriples((10l)) == (36l));
    assert(getMaxTriples((100l)) == (53361l));
    }

}
"
HumanEval_148,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //སྐར་མ་གི་མིང་ཚུ་ ཚུལ་ལྡན་མེན་པས།    //ལས་འགན་འདི་གིས་ plan1 ཡང་ན་ plan2 ཡོད་པ་ཅིན་ སྟོངམ་ཡོད་པའི་ tuple སླར་ལོག་འབདཝ་ཨིན།    //ཉིམ་ལུ་ ཉེ་འདབས་ལུ་ཡོད་པའི་གནས་སྟངས་འདི་ ཨིན།    //སྐར་མ་༡ དང་སྐར་མ་༢ ཀྱི་འཁོར་ལམ་གྱི་བར་ན་ཆགས་ཏེ་ཡོདཔ་ཨིན།    //ལས་འགན་འདི་གིས་ ཙི་ཙི་གུ་འགྱོ་མི་ སྐར་མ་ཆ་མཉམ་ཡོད་པའི་ ཌའི་ལོག་ཅིག་སླར་ལོག་འབདཝ་ཨིན།    //སྐར་མ་གཉིས་ལུ་ སྐར་མ་ ༡ དང་ སྐར་མ་ ༢ སྦེ་མིང་བཏགས་མི་ལས་འགན་ཅིག་བྲིས་།    //ཌའི་ལོག་གི་ཨུ་ར་ནསི་དང་ ནེ་པཱུ་ནིསི་    //ཤུལ་མ་གི་སྐརམ་འདི་ སེར་གུ་ཨིན། དེ་ལས་འཛམ་གླིང་དང་ མོང་སྒར་དང་ ཡུ་པི་ཊར་ དེ་ལས་ སའི་སྐརམ་ཨིན།    //ཉིམ་ནང་ སྐར་མ་༨ ཡོདཔ་ད་ འདི་ ཉིམ་ལུ་ སྦོ་ལོགས་ཁར་ཡོད་མི་ཅིག་ཨིན་མས།    // >>> bf((""Jupiter""), (""Neptune""))
    // (List[String](""Saturn"", ""Uranus""))
    // >>> bf((""Earth""), (""Mercury""))
    // (List[String](""Venus""))
    // >>> bf((""Mercury""), (""Uranus""))
    // (List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))
    def bf(planet1 : String, planet2 : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def bf(planet1: String, planet2: String): List[String] = {
    val planets = List(""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    
    // Find the indices of the given planets
    val index1Opt = planets.indexOf(planet1)
    val index2Opt = planets.indexOf(planet2)
    
    // If either planet is not found, return an empty list
    if (index1Opt == -1 || index2Opt == -1) {
      return List.empty
    }
    
    // Sort indices to ensure proper traversal direction
    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)
    
    // Get the planets between the indices
    planets.slice(startIndex + 1, endIndex)
  }
}","    }
    def main(args: Array[String]) = {
    assert(bf((""Jupiter""), (""Neptune"")).equals((List[String](""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Mercury"")).equals((List[String](""Venus""))));
    assert(bf((""Mercury""), (""Uranus"")).equals((List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))));
    assert(bf((""Neptune""), (""Venus"")).equals((List[String](""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Earth"")).equals((List[String]())));
    assert(bf((""Mars""), (""Earth"")).equals((List[String]())));
    assert(bf((""Jupiter""), (""Makemake"")).equals((List[String]())));
    }

}
"
HumanEval_149,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //ཁྱོད་ཀྱིས་ཚིག་ཆ་མཉམ་ ཡུན་རིང་འདྲ་མཉམ་སྦེ་འོང་ནི་མས་ཟེར་ མནོ་བསམ་བཏུབ།    //ལས་འགན་འདི་གིས་ གྲལ་ཐིག་ཚུ་རིམ་སྒྲིག་འབད་དེ་ལོག་གཏང་དགོ།    //ཚིག་གཉིས་ཆ་ར་ ཡུན་རིང་འདྲན་འདྲ་ཡོད་པ་ཅིན་ ཨེཕ་ཊི་རིམ་སྒྲིག་ཐོག་ལུ་ རིམ་སྒྲིག་འབད།    //ཚད་འཛིན་དེ་གི་ཐོག་ལས་ ཐོ་བཀོད་འདི་ལོག་གཏང་དགོ།    //ཚིག་ཡིག་གི་རིམ་པ་འདི་ ཚིག་རེ་རེ་གི་རིང་ཚད་དང་བསྟུན་ཏེ་ ཡར་སེང་འགྱོ་དགོཔ་ཨིན།    //འདི་ནང་ལུ་ ཐེངས་གཉིས་འབད་མི་ཡང་ འདུག་འོང་།    //ཐོ་བཀོད་འདི་ རྟག་བུ་རང་ ཚིག་ཡིག་གི་ཐོ་ཡིག་དང་ ཨང་གྲངས་ཀྱི་ཐོ་ཡིག་མེན།    //དེ་ལས་ གྲུབ་འབྲས་ཀྱི་ཐོ་དེ་རིམ་སྒྲིག་འབད་ཡོད་པའི་རིམ་སྒྲིག་སྦེ་ལོག་གཏང་འོང་།    //ཚད་ལྡན་ཡིག་འབྲུ་འདི་ ཚད་ལྡན་ཡིག་འབྲུ་འདི་ནང་ལས་ ཆད་ནི་ཨིན།    //ཚད་གཞི་ཅིག་སྦེ་ string གི་ཐོ་ཡིག་ཅིག་ལེན་མི་ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> listSort((List[String](""aa"", ""a"", ""aaa"")))
    // (List[String](""aa""))
    // >>> listSort((List[String](""ab"", ""a"", ""aaa"", ""cd"")))
    // (List[String](""ab"", ""cd""))
    def sortedListSum(lst : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def listSort(lst: List[String]): List[String] = {
        lst.filter(_.length % 2 == 0)
           .sorted
           .sortBy(_.length)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortedListSum((List[String](""aa"", ""a"", ""aaa""))).equals((List[String](""aa""))));
    assert(sortedListSum((List[String](""school"", ""AI"", ""asdf"", ""b""))).equals((List[String](""AI"", ""asdf"", ""school""))));
    assert(sortedListSum((List[String](""d"", ""b"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""d"", ""dcba"", ""abcd"", ""a""))).equals((List[String](""abcd"", ""dcba""))));
    assert(sortedListSum((List[String](""AI"", ""ai"", ""au""))).equals((List[String](""AI"", ""ai"", ""au""))));
    assert(sortedListSum((List[String](""a"", ""b"", ""b"", ""c"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""aaaa"", ""bbbb"", ""dd"", ""cc""))).equals((List[String](""cc"", ""dd"", ""aaaa"", ""bbbb""))));
    }

}
"
HumanEval_150,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཨང་གྲངས་ངོ་མ་ཅིག་ཨིནམ་ལས་ y གི་གནས་གོང་ལོག་གཏང་དགོ།    //ཌི་ཨེམ་ཨེན་འདི་ ཇི་ཨེན་ཨིནམ་སྦེ་ཨིན་པ་ཅིན་ xགི་གནས་གོང་ལོག་བྱིན་དགོཔ་ཨིན་པའི་ གྲུབ་འབྲས་འདི་ ཨིན།    // >>> xOrY((7l), (34l), (12l))
    // (34l)
    // >>> xOrY((15l), (8l), (5l))
    // (5l)
    def xOrY(n : Long, x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def isPrime(num: Long): Boolean = {
    if (num <= 1) return false
    if (num <= 3) return true
    if (num % 2 == 0 || num % 3 == 0) return false
    var i = 5
    while (i * i <= num) {
      if (num % i == 0 || num % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def xOrY(n: Long, x: Long, y: Long): Long = {
    if (isPrime(n)) x else y
  }
}","    }
    def main(args: Array[String]) = {
    assert(xOrY((7l), (34l), (12l)) == (34l));
    assert(xOrY((15l), (8l), (5l)) == (5l));
    assert(xOrY((3l), (33l), (5212l)) == (33l));
    assert(xOrY((1259l), (3l), (52l)) == (3l));
    assert(xOrY((7919l), (-1l), (12l)) == (-1l));
    assert(xOrY((3609l), (1245l), (583l)) == (583l));
    assert(xOrY((91l), (56l), (129l)) == (129l));
    assert(xOrY((6l), (34l), (1234l)) == (1234l));
    assert(xOrY((1l), (2l), (0l)) == (0l));
    assert(xOrY((2l), (2l), (0l)) == (2l));
    }

}
"
HumanEval_151,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཨང་གྲངས་ཆ་མཉམ་མེན་པའི་ ནུས་མེད་ ཡང་ན་ ཨང་གྲངས་ཆ་མཉམ་མེན་པའི་ ཨང་གྲངས་ཚུ་ སྣང་མེད་སྦེ་བཞག་དགོ།    //ཨང་གྲངས་ཀྱི་ཐོ་འདི་བྱིན་ཏེ་ ཨང་གྲངས་ཀྱི་གྲུ་བཞི་བསྡོམས་སླར་ལོག་འབདཝ་ཨིན།    // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))
    // (10l)
    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))
    // (0l)
    // >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))
    // (81l)
    // >>> doubleTheDifference((List[Float](0l.toLong)))
    // (0l)
    // If the input list is empty, return 0.
    def doubleTheDifference(lst : List[Float]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doubleTheDifference(lst: List[Float]): Long = {
    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)
      .map(x => x.toLong * x.toLong)
      .sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(doubleTheDifference((List[Float]())) == (0l));
    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));
    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));
    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));
    }

}
"
HumanEval_152,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //གནས་གོང་འདི་ ༠ ཨིན་པ་ཅིན་ གནས་གོང་འདི་དཔའ་བཅམ་མི་དང་ ཨང་གི་བར་ན་ ཁྱད་པར་ངོ་མ་ཨིན།    //ཚོད་དཔག་འབད་མི་ཚུ་ ཕྲང་ཐངས་སྦེ་ཡོད་པ་ཅིན་ ཚད་གཞི་འདི་ ཚད་གཞི་འདི་ ཕྲང་ཐངས་སྦེ་ཡོད་པ་ཅིན་ ཚད་གཞི་འདི་ ཕྲང་ཐངས་སྦེ་ཡོད་པ་ཅིན་ ཚད་གཞི་འདི་ ཕྲང་ཐངས་སྦེ་ཡོད་པ་ཅིན་ ཚད་གཞི་འདི་ ཕྲང་ཐངས་སྦེ་ཡོད་པ་ཅིན་ ཚད་གཞི་འདི་ ཕྲང་ཐངས་སྦེ་ཡོད་པ་ཅིན་    //ཁྱོད་ཀྱིས་ ཨང་དང་ཚོད་དཔག་འབད་ཡོད་པའི་ཐོ་ཡིག་གཉིས་ཐོབ་ཡོདཔ་དང་ འདི་ནང་ཚད་གཞི་རེ་རེ་བཞིན་དུ་ མཉམ་འབྲེལ་སྦེ་སྟོན་ཡོདཔ་ཨིན།    //ཁྱོད་ཀྱི་ལཱ་འདི་ མི་གཅིག་གིས་ རྩེད་འགྲན་གྱི་གྲུབ་འབྲས་ཚུ་ ལེགས་ཤོམ་སྦེ་ར་ ཧ་གོ་ཡོདཔ་ཨིན་ན་ བལྟ་ནི་དེ་ཨིན།    //འདི་ལུ་བལྟ་བ་ཅིན་ ཐད་རི་བ་རི་རང་ འབྲི་ནི་དང་བསྡུར་རྐྱབ་ནི་དེ་ ལེགས་ཤོམ་ཨིན།    //བྱུང་རྐྱེན་འདི་ མཇུག་བསྡུ་བའི་སྐབས་ལུ་ ཤེས་ཚུགས་འོང་། ཚོར་སྣང་དང་མནོ་བསམ་འདི་ ད་ལྟོ་རང་ ཁྱོད་དང་གཅིག་ཁར་ཡོད་མི་འདི་ཨིན།    //ང་བཅས་ག་ར་གིས་ འདི་བཟུམ་གྱི་ཚོར་སྣང་འདི་ སེམས་ཁར་དྲན་ཏེ་རང་སྡོད་འོང་ འདི་བཟུམ་གྱི་ཚོར་སྣང་འདི་ ཡུན་རིངམོ་སྦེ་སྒུག་སྡོད་མིའི་ འབྲས་བུ་འདི་ བྱུང་བའི་སྐབས་ལུ་ཨིན།    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))
    // (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))
    // >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))
    // (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))
    def compare(game : List[Long], guess : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def compare(game: List[Long], guess: List[Long]): List[Long] = {
    game.zip(guess).map { case (g, gs) => abs(g - gs) }
  }
}","    }
    def main(args: Array[String]) = {
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));
    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));
    }

}
"
HumanEval_153,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //(ཤུགས་དེ་ -༡ ཨིན།)    //return ""Slices.SErviNGSliCes"" འདི་ ཤུགས་ཅན་ལག་ལེན་འཐབ་ཡོད་པའི་ཁྱབ་ཚད་ཨིནམ་ལས་ ""SErviNGSliCes"" ཨིན།    //extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] འདི་ཨིན་པ་ཅིན་ ཁྱོད་ཀྱིས་     //དཔེར་ན་ ཁྱོད་ཀྱིས་ ""Slices"" འདི་ སློབ་ཚན་སྦེ་ཐོབ་པ་ཅིན་དང་     //ཁྱོད་ཀྱིས་ཐོ་ཡིག་ནང་ལུ་ དང་པ་ཐོན་མི་ཅིག་ གདམ་ཁ་རྐྱབས།    //ཤུགས་འདི་གཉིས་ ཡང་ན་དེ་ལས་མང་བ་ཡོད་པ་ཅིན་ ཁྱོད་ཀྱིས་ ཤུགས་འདི་གཉིས་ཆ་ར་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་ ཤུགས་སྦེ་རང་    //format: ClassName.StrongestExtensionName.   ཤོག་ལེབ་འདི་ནང་ལུ་ ཌའི་ལོག་གི་མིང་འདི་ སྟོན་ཚུགས།    //ཁྱོད་ཀྱིས་ ཤུགས་ཅན་ཅིག་ཐོན་མི་འདི་འཚོལ་ཏེ་ འདི་ནང་ལུ་ string སླར་ལོག་འབད་དགོ།    //ཤུགས་འདི་ CAP - SM གི་ཆ་ཤས་ནང་ལས་ཐོབ་ཨིན།    //ཨེགསི་ཨེན་གྱི་མིང་ནང་ལུ་ཡིག་འབྲུ་ཚུ་དང་ SM འདི་ཡིག་འབྲུ་ཆུང་བའི་གྱངས་ཁ་ཨིན།    //རྒྱ་སྐྱེད་ཀྱི་ཤུགས་འདི་ འོག་ལུ་བཟུམ་སྦེ་ཨིན། CAP འདི་ཡིག་འབྲུ་སྦོམ་ཤོས་ཀྱི་ཨང་གྲངས་ཨིན།    //རྒྱས་བཤད་འདི་ སྦྱོར་སྡུད་ཀྱི་དོན་ལུ་ ལག་ལེན་འཐབ་ཨིན།    //ཁྱོད་ཀྱིས་ སྦྱོར་སྡེ་གི་མིང་ (ཐིག་ཡིག་) དང་ ཁྱབ་ཚད་ཀྱི་ཐོ་ཡིག་ཐོབ་འོང་།    // >>> StrongestExtension((""my_class""), (List[String](""AA"", ""Be"", ""CC"")))
    // (""my_class.AA"")
    def StrongestExtension(class_name : String, extensions : List[String]) : String = {
","def StrongestExtension(class_name: String, extensions: List[String]): String = {
        extensions.map { extension =>
            val capCount = extension.count(_.isUpper)
            val lowerCount = extension.count(_.isLower)
            val strength = capCount - lowerCount
            (extension, strength)
        }.maxBy(_._2)._1
    } match {
        case strongest => s""$class_name.$strongest""
    }
}","    }
    def main(args: Array[String]) = {
    assert(StrongestExtension((""Watashi""), (List[String](""tEN"", ""niNE"", ""eIGHt8OKe""))).equals((""Watashi.eIGHt8OKe"")));
    assert(StrongestExtension((""Boku123""), (List[String](""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""))).equals((""Boku123.YEs.WeCaNe"")));
    assert(StrongestExtension((""__YESIMHERE""), (List[String](""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""))).equals((""__YESIMHERE.NuLl__"")));
    assert(StrongestExtension((""K""), (List[String](""Ta"", ""TAR"", ""t234An"", ""cosSo""))).equals((""K.TAR"")));
    assert(StrongestExtension((""__HAHA""), (List[String](""Tab"", ""123"", ""781345"", ""-_-""))).equals((""__HAHA.123"")));
    assert(StrongestExtension((""YameRore""), (List[String](""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""))).equals((""YameRore.okIWILL123"")));
    assert(StrongestExtension((""finNNalLLly""), (List[String](""Die"", ""NowW"", ""Wow"", ""WoW""))).equals((""finNNalLLly.WoW"")));
    assert(StrongestExtension((""_""), (List[String](""Bb"", ""91245""))).equals((""_.Bb"")));
    assert(StrongestExtension((""Sp""), (List[String](""671235"", ""Bb""))).equals((""Sp.671235"")));
    }

}
"
HumanEval_154,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཁྱོད་ཀྱིས་ཚིག་གཉིས་ཐོབ་ཨིན། ཁྱོད་ཀྱིས་ཚིག་གཉིས་པ་ ཡང་ན་ འདི་གི་འཁོར་ལོའི་གྲལ་རིམ་འདི་ ཚིག་དང་པ་ནང་ལུ་ ནང་ཐིག་ཅིག་ཨིན་པ་ཅིན་ ཁྱོད་ཀྱིས་བདེན་པ་སྦེ་ལོག་གཏང་དགོ།    // >>> cycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> cycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> cycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> cycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> cycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> cycpatternCheck((""himenss""), (""simen""))
    // (true)
    def cycpatternCheck(a : String, b : String) : Boolean = {
","def cycpatternCheck(a: String, b: String): Boolean = {
  val bLength = b.length
  val bDouble = b + b // Create a string with b concatenated with itself to represent all rotations
  for (i <- 0 until bLength) {
    val rotation = bDouble.substring(i, i + bLength) // Get the current rotation
    if (a.contains(rotation)) return true
  }
  false
}","    }
    def main(args: Array[String]) = {
    assert(cycpatternCheck((""xyzw""), (""xyw"")) == (false));
    assert(cycpatternCheck((""yello""), (""ell"")) == (true));
    assert(cycpatternCheck((""whattup""), (""ptut"")) == (false));
    assert(cycpatternCheck((""efef""), (""fee"")) == (true));
    assert(cycpatternCheck((""abab""), (""aabb"")) == (false));
    assert(cycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཨང་གྲངས་ཧྲིལ་བུམ་ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཆ་མཉམ་དང་ཆ་མཉམ་མེད་པའི་ཨང་གྲངས་ཚུ་ཡོད་མི་འདི་སླར་ལོག་འབདཝ་ཨིན།    // >>> evenOddCount((-12l))
    // ((1l, 1l))
    // >>> evenOddCount((123l))
    // ((1l, 2l))
    def evenOddCount(num : Long) : Tuple2[Long, Long] = {
","def evenOddCount(num: Long): Tuple2[Long, Long] = {
  val digits = num.abs.toString.map(_.asDigit)
  val evenCount = digits.count(_ % 2 == 0).toLong
  val oddCount = digits.count(_ % 2 != 0).toLong
  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddCount((7l)).equals(((0l, 1l))));
    assert(evenOddCount((-78l)).equals(((1l, 1l))));
    assert(evenOddCount((3452l)).equals(((2l, 2l))));
    assert(evenOddCount((346211l)).equals(((3l, 3l))));
    assert(evenOddCount((-345821l)).equals(((3l, 3l))));
    assert(evenOddCount((-2l)).equals(((1l, 0l))));
    assert(evenOddCount((-45347l)).equals(((2l, 3l))));
    assert(evenOddCount((0l)).equals(((1l, 0l))));
    }

}
"
HumanEval_156,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //ཚད་འཛིན་: ༡ <= ཨང་གྲངས་ <= ༡༠༠༠    //དེ་ལས་ ཆེ་ཆུང་ཡིག་རྒྱུན་ནང་ལོག་གཏང་།    //ཨང་གྲངས་ཧྲིལ་བུམ་ཅིག་ཐོབ་པ་ཅིན་ རོམ་ཨང་གྲངས་ནང་ སྦེ་ཐིག་ཡིག་ཅིག་ཐོབ་དགོ།    // >>> intToMiniRoman((19l))
    // (""xix"")
    // >>> intToMiniRoman((152l))
    // (""clii"")
    // >>> intToMiniRoman((426l))
    // (""cdxxvi"")
    def intToMiniRoman(number : Long) : String = {
","import scala.collection.mutable._

object Problem {
  def intToMiniRoman(number: Long): String = {
    val romanMap: List[(Int, String)] = List(
      (1000, ""m""),
      (900, ""cm""),
      (500, ""d""),
      (400, ""cd""),
      (100, ""c""),
      (90, ""xc""),
      (50, ""l""),
      (40, ""xl""),
      (10, ""x""),
      (9, ""ix""),
      (5, ""v""),
      (4, ""iv""),
      (1, ""i"")
    )

    var num = number.toInt
    val stringBuilder = new StringBuilder

    for ((value, roman) <- romanMap) {
      while (num >= value) {
        stringBuilder.append(roman)
        num -= value
      }
    }

    stringBuilder.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(intToMiniRoman((19l)).equals((""xix"")));
    assert(intToMiniRoman((152l)).equals((""clii"")));
    assert(intToMiniRoman((251l)).equals((""ccli"")));
    assert(intToMiniRoman((426l)).equals((""cdxxvi"")));
    assert(intToMiniRoman((500l)).equals((""d"")));
    assert(intToMiniRoman((1l)).equals((""i"")));
    assert(intToMiniRoman((4l)).equals((""iv"")));
    assert(intToMiniRoman((43l)).equals((""xliii"")));
    assert(intToMiniRoman((90l)).equals((""xc"")));
    assert(intToMiniRoman((94l)).equals((""xciv"")));
    assert(intToMiniRoman((532l)).equals((""dxxxii"")));
    assert(intToMiniRoman((900l)).equals((""cm"")));
    assert(intToMiniRoman((994l)).equals((""cmxciv"")));
    assert(intToMiniRoman((1000l)).equals((""m"")));
    }

}
"
HumanEval_157,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //དབྱེ་བ་ ༩༠ ལུ་ཐིག་ཁྲམ་འདི་    //ཟུར་ཐིག་ཕྲང་ཟུར་གསུམ་འདི་ ཟུར་ཐིག་གཅིག་ ཟུར་ཐིག་ཕྲང་ཟུར་ ཡང་ན་ ཨིནམ་སྦེ་དབྱེ་ཚུགས།    //གཡོན་འདི་ ཟུར་ཟུར་གསུམ་སྦེ་བཟོ་སྟེ་ཡོདཔ་དང་ གཞན་འདི་རྫུས་མ་ཨིན།    //ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཚུ་བྱིན་ཏེ་ ཚད་གསུམ་ཡོད་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།    // >>> rightAngleTriangle((3l), (4l), (5l))
    // (true)
    // >>> rightAngleTriangle((1l), (2l), (3l))
    // (false)
    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {
","def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {
        val sides = List(a, b, c).sorted
        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)
    }
}","    }
    def main(args: Array[String]) = {
    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));
    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));
    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));
    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));
    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));
    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));
    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));
    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));
    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));
    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));
    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));
    }

}
"
HumanEval_158,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ཤོག་བྱང་གི་གྲལ་ཐིག་ནང་ དང་པ་འོང་མི་ཡིག་འབྲུ་འདི་ལོག་གཏང་།    //ཚིག་ཡིག་ཁྱད་པར་ཅན་ཚུ་ ཡོད་པ་ཅིན་ string མང་ཤོས་ཅིག་ལུ་ ཁྱད་པར་ཅན་  ཟེར་ཨང་གྲངས་ཉུང་ཤོས་ཅིག་ཡོདཔ་ཨིན།    //མིང་ཐོ་ནང་ལུ་ ཚིག་མ་འདྲཝ་ལེ་ཤ་ཡོདཔ་ཨིན་ ཚིག་གི་ཨང་གྲངས་མང་ཤོས་ཅིག་སླར་ལོག་འབད།    //string གི་ཐོ་ཡིག་ཅིག་ལེན་མི་ལས་འགན་ཅིག་འབྲི་དགོ།    // >>> findMax((List[String](""name"", ""of"", ""string"")))
    // (""string"")
    // >>> findMax((List[String](""name"", ""enam"", ""game"")))
    // (""enam"")
    // >>> findMax((List[String](""aaaaaaa"", ""bb"", ""cc"")))
    // (""aaaaaaa"")
    def findMax(words : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findMax(words: List[String]): String = {
    words.maxBy(word => (word.toSet.size, -word.toLowerCase))
  }
}","    }
    def main(args: Array[String]) = {
    assert(findMax((List[String](""name"", ""of"", ""string""))).equals((""string"")));
    assert(findMax((List[String](""name"", ""enam"", ""game""))).equals((""enam"")));
    assert(findMax((List[String](""aaaaaaa"", ""bb"", ""cc""))).equals((""aaaaaaa"")));
    assert(findMax((List[String](""abc"", ""cba""))).equals((""abc"")));
    assert(findMax((List[String](""play"", ""this"", ""game"", ""of"", ""footbott""))).equals((""footbott"")));
    assert(findMax((List[String](""we"", ""are"", ""gonna"", ""rock""))).equals((""gonna"")));
    assert(findMax((List[String](""we"", ""are"", ""a"", ""mad"", ""nation""))).equals((""nation"")));
    assert(findMax((List[String](""this"", ""is"", ""a"", ""prrk""))).equals((""this"")));
    assert(findMax((List[String](""b""))).equals((""b"")));
    assert(findMax((List[String](""play"", ""play"", ""play""))).equals((""play"")));
    }

}
"
HumanEval_159,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:    //གལ་སྲིད་ ཀ་ར་ཏཱན་ལངམ་མེད་པ་ཅིན་ ཁྱོད་ཀྱིས་ ཀ་ར་ཏཱན་ལངམ་ཚུ་ཟ་རུང་ ལྟོཝ་བཀྱེས་སྡོད་འོང་།    //ཟ་ཚར་བའི་ཤུལ་ལུ་ ལྷག་ལུས་པའི་ གུ་རུའི་གྱངས་ཁ་འདི་ཨིན།    //ཁྱོད་ཀྱིས་ [ཟ་ཚར་བའི་ཧེ་མར་མར་མར་གུག་ཤད་ཀྱི་གྱངས་ཁ་] ཟེར་མི་ཐོ་ཡིག་ཅིག་ལོག་གཏང་དགོ།    //ད་ཁྱོད་ཀྱིས་ ཉིན་བསྟར་གྱི་བཞེས་སྒོ་ཚུ་ ཟ་ནིའི་དོན་ལུ་ གུ་རུའི་རིགས་ཚུ་ ལྷག་ནི་དེ་ ཁག་ཆེཝ་ཨིན།    //ཁྱོད་ལྟོཝ་བཀྱེས་པའི་བྱ་རྒོད་ཅིག་ཨིན་ ཁྱོད་ཀྱིས་ གུ་རུའི་རིགས་ཚུ་ ལེ་ཤ་ཅིག་རང་ བཟའ་ཚར་ནུག    // >>> eat((5l), (6l), (10l))
    // (List[Long](11l.toLong, 4l.toLong))
    // >>> eat((4l), (8l), (9l))
    // (List[Long](12l.toLong, 1l.toLong))
    // >>> eat((1l), (10l), (10l))
    // (List[Long](11l.toLong, 0l.toLong))
    // >>> eat((2l), (11l), (5l))
    // (List[Long](7l.toLong, 0l.toLong))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def eat(number: Long, need: Long, remaining: Long): List[Long] = {
    val totalNeeded = number + need
    if (remaining >= need) {
      List(totalNeeded, remaining - need)
    } else {
      List(number + remaining, 0)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));
    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));
    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));
    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));
    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));
    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));
    }

}
"
HumanEval_160,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ལས་འགན་ཐོ་ཡིག་ནང་ལུ་ ལས་འགན་ཉུང་ཤོས་ཅིག་དང་ ལས་འགན་ཐོ་ཡིག་ནང་ལུ་ ལས་འགན་ཉུང་ཤོས་གཉིས་ཡོདཔ་ཨིན།    //ཨོ་པེ་རེན་ཌི་འདི་ ནེ་གེ་ཊི་བཱལ་མེན་པའི་ཨང་གྲངས་ཚུའི་ཐོ་ཡིག་ཨིན།    //ལས་འགན་ཐོ་ཡིག་གི་རིང་ཚད་འདི་ ལས་འགན་ཐོ་ཡིག་གི་རིང་ཚད་དང་མཉམ་པ་ཨིན།    //དྲན་གསོ།    //=> གྲུབ་འབྲས་ = ༩     //གྲུབ་འབྲས་ = ༢ + ༣ * ༤ - ༥    //list = [༢,༣,༤,༥] ཨིན།    //ལས་གཡོགཔ་གིས་ ['+', '*', '-']     //དཔེ་འབད་བ་ཅིན་:    //ཨེགསི་ཨོཕ་ནི་ཊེཊི་ (**) ཨིན།    //ས་ཐོག་གི་ཆ་ཤས་ (_)     //མང་བ་བཟོ་ནི་ (*) ཨིན།    //མར་ཕབ་ ( - )     //ཁ་སྐོང་ (+) ཨིན།    //གཞི་རྟེན་ཨེལ་ཇི་བཱར་གི་ལཱ་ཚུ་:    //expression དང་ expression གི་མཐའ་དཔྱད་ལོག་གཏང་།    //ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་འདི་ ཨང་གྲངས་གཉིས་པ་ཨིན་ ཨང་གྲངས་ཧྲིལ་བུའི་ཐོ་ཡིག་འདི་ཨེལ་ཇི་བཱརཀ་བཟོ་ནིའི་དོན་ལུ་ ལག་ལེན་འཐབ་ཨིན།    //ཨེཕ་རེནཌི་དང་ཨོཔརེནཌི་གཉིས་ལུ་ཐོ་ཡིག་བྱིན་ཏེ་ཡོདཔ་ཨིན། དང་པ་ཐོ་ཡིག་ནང་ལུ་གཞི་རྟེན་ཨེལ་ཇི་བཱར་གི་ལཱ་ཚུ་ཡོདཔ་དང་     def doAlgebra(op : List[String], operand : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doAlgebra(op: List[String], operand: List[Long]): Long = {
    var result = operand.head
    for (i <- 0 until op.length) {
      op(i) match {
        case ""+"" => result += operand(i + 1)
        case ""-"" => result -= operand(i + 1)
        case ""*"" => result *= operand(i + 1)
        case ""//"" => result /= operand(i + 1)
        case ""**"" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong
      }
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val operators = List(""+"", ""*"", ""-"")
    val operands = List(2L, 3L, 4L, 5L)
    println(doAlgebra(operators, operands)) // Output: 9
  }
}","    }
    def main(args: Array[String]) = {
    assert(doAlgebra((List[String](""**"", ""*"", ""+"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));
    assert(doAlgebra((List[String](""+"", ""*"", ""-"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));
    assert(doAlgebra((List[String](""//"", ""*"")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));
    }

}
"
HumanEval_161,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་སྟོན་     //ལས་འགན་འདི་གིས་ གྲུབ་འབྲས་ཀྱི་ཐིག་ཁྲམ་སླར་ལོག་འབདཝ་ཨིན།    //stringནང་ལུ་ཡིག་འབྲུ་མེད་པ་ཅིན་ stringའདི་ཁ་བསྒྱུར་འབད།    //དེ་མེན་པ་ཅིན་ འདི་བཟུམ་སྦེ་རང་བཞག་དགོ    //s[i]འདི་ཡིག་འབྲུ་ཨིན་པ་ཅིན་ འོག་ལས་མཐོ་ ཡང་ན་ ཕྱོགས་གཞན་ཁ་ལུ་ འབྲི་དགོ།    //ཁྱོད་ལུ་ string s ཅིག་བྱིན་ནུག    // >>> solve((""1234""))
    // (""4321"")
    // >>> solve((""ab""))
    // (""AB"")
    // >>> solve((""#a@C""))
    // (""#A@c"")
    def solve(s : String) : String = {
","def solve(s: String): String = {
    if (s.exists(_.isLetter)) {
      s.map {
        case c if c.isLetter && c.isLower => c.toUpper
        case c if c.isLetter && c.isUpper => c.toLower
        case c => c
      }.mkString
    } else {
      s.reverse
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(solve((""AsDf"")).equals((""aSdF"")));
    assert(solve((""1234"")).equals((""4321"")));
    assert(solve((""ab"")).equals((""AB"")));
    assert(solve((""#a@C"")).equals((""#A@c"")));
    assert(solve((""#AsdfW^45"")).equals((""#aSDFw^45"")));
    assert(solve((""#6@2"")).equals((""2@6#"")));
    assert(solve((""#$a^D"")).equals((""#$A^d"")));
    assert(solve((""#ccc"")).equals((""#CCC"")));
    }

}
"
HumanEval_162,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //'text'འདི་ སྟོང་པ་སྦེ་ཡོད་པ་ཅིན་ None སླར་ལོག་འབདཝ་ཨིན།    //string 'text' ཅིག་བྱིན་པ་ཅིན་ md5 ཧེཤི་ འདྲ་མཉམ་གྱི་ string འདི་ལོག་གཏང་།    // >>> stringToMd5((""Hello world""))
    // Some(""3e25960a79dbc69b674cd4ec67a72c62"")
    def stringToMd5(text : String) : Option[String] = {
","import java.security.MessageDigest

object Problem {
  def stringToMd5(text: String): Option[String] = {
    if (text.isEmpty) None
    else {
      val md = MessageDigest.getInstance(""MD5"")
      val digest = md.digest(text.getBytes)
      Some(digest.map(""%02x"".format(_)).mkString)
    }
  }
}

// Example usage:
// println(Problem.stringToMd5(""Hello world""))  // Output: Some(""3e25960a79dbc69b674cd4ec67a72c62"")","    }
    def main(args: Array[String]) = {
    assert(stringToMd5((""Hello world"")).equals(Some(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert(stringToMd5(("""")).equals(None));
    assert(stringToMd5((""A B C"")).equals(Some(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert(stringToMd5((""password"")).equals(Some(""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,dzo_Tibt,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //དཔེ་འབད་བ་ཅིན་:     //b འདི་ཡར་སེང་གི་རིམ་པ་ལུ་ཨིན།    //ཤོག་གྲངས་ཆ་མཉམ་ a དང་ b གཉིས་ཐོབ་པ་ཅིན་ ཤོག་གྲངས་ཆ་མཉམ་ a དང་ b གི་བར་ན་སླར་ལོག་འབདཝ་ཨིན།    // >>> generateIntegers((2l), (8l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((8l), (2l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((10l), (14l))
    // (List[Long]())
    def generateIntegers(a : Long, b : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def generateIntegers(a: Long, b: Long): List[Long] = {
    val start = min(a, b)
    val end = max(a, b)
    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i
    evenNumbers.map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((17l), (89l)).equals((List[Long]())));
    }

}
"
