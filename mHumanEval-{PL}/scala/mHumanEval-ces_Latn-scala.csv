task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //    //Zkontrolujte, zda jsou v daném seznamu čísel nějaká dvě čísla blíže k sobě než     // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))
    // (false)
    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))
    // (true)
    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {
","def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {
      val sortedNumbers = numbers.sorted
      for (i <- 1 until sortedNumbers.length) {
        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {
          return true
        }
      }
      false
    }
}","    }
    def main(args: Array[String]) = {
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));
    }

}
"
HumanEval_1,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Nezapomeňte na mezery v vstupním řádku.    //Oddělené skupiny jsou vyvážené (každá otevřená oprava je řádně uzavřena) a nejsou v sobě navzájem vnořeny.    //rozdělit tyto skupiny do samostatných řetězců a vrátit seznam těchto řetězců.     //Vstupní datovou řadou této funkce je řetězec obsahující více skupin vnořených závorek.    // >>> separateParenGroups((""( ) (( )) (( )( ))""))
    // (List[String](""()"", ""(())"", ""(()())""))
    def separateParenGroups(paren_string : String) : List[String] = {
","def separateParenGroups(paren_string: String): List[String] = {
    val result = ListBuffer[String]()
    val sanitizedInput = paren_string.replaceAll(""\\s"", """")
    var balance = 0
    var currentGroup = new StringBuilder()

    for (char <- sanitizedInput) {
        currentGroup.append(char)
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1

        if (balance == 0 && currentGroup.nonEmpty) {
            result += currentGroup.toString()
            currentGroup = new StringBuilder()
        }
    }

    result.toList
}","    }
    def main(args: Array[String]) = {
    assert(separateParenGroups((""(()()) ((())) () ((())()())"")).equals((List[String](""(()())"", ""((()))"", ""()"", ""((())()())""))));
    assert(separateParenGroups((""() (()) ((())) (((())))"")).equals((List[String](""()"", ""(())"", ""((()))"", ""(((())))""))));
    assert(separateParenGroups((""(()(())((())))"")).equals((List[String](""(()(())((())))""))));
    assert(separateParenGroups((""( ) (( )) (( )( ))"")).equals((List[String](""()"", ""(())"", ""(()())""))));
    }

}
"
HumanEval_2,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vraťte desítkovou část čísla.     //(zbytek je vždy menší než 1).    //a celá část (největší celé číslo menší než dané číslo) a desetinná místa     //Je-li to číslo s kladným pohyblivým číslem, může být rozloženo na     // >>> truncateNumber((3.5f))
    // (0.5f)
    def truncateNumber(number : Float) : Float = {
","val integerPart = number.floor
        val decimalPart = number - integerPart
        decimalPart.toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(truncateNumber((3.5f)) == (0.5f));
    assert(truncateNumber((1.25f)) == (0.25f));
    assert(truncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //V opačném případě by měla vrátit hodnotu false.    //Vaším úkolem je zjistit, zda v kterémkoli okamžiku zůstatek účtu klesne pod nulu, a     //Dostanete seznam vkladů a výběrů na bankovním účtu, který začíná na     // >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (false)
    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))
    // (true)
    def belowZero(operations : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def belowZero(operations: List[Long]): Boolean = {
    var balance: Long = 0
    for (operation <- operations) {
      balance += operation
      if (balance < 0) {
        return true
      }
    }
    false
  }

  def main(args: Array[String]): Unit = {
    println(belowZero(List(1L, 2L, 3L)))         // false
    println(belowZero(List(1L, 2L, -4L, 5L)))    // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowZero((List[Long]())) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));
    }

}
"
HumanEval_4,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //MAD = průměr. x - x_mean.    //Prvek a střed (v tomto případě průměr):     //Průměrná absolutní odchylka je průměrný absolutní rozdíl mezi každým     //v průměru tohoto souboru údajů.     //Pro daný seznam vstupních čísel vypočte průměrnou absolutní odchylku     // >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))
    // (1.0f)
    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {
","val mean = numbers.sum / numbers.size
    val deviations = numbers.map(num => math.abs(num - mean))
    val mad = deviations.sum / deviations.size
    mad
  }
}","    }
    def main(args: Array[String]) = {
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));
    }

}
"
HumanEval_5,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vkládá se číslo ""delimiter"" mezi každými dvěma po sobě jdoucími prvky vstupního seznamu `čísla'     // >>> intersperse((List[Long]()), (4l))
    // (List[Long]())
    // >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))
    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {
","if (numbers.isEmpty) {
        List()
      } else {
        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last
      }
    }
}","    }
    def main(args: Array[String]) = {
    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));
    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));
    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    }

}
"
HumanEval_6,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například (() (()) má maximálně dvě úrovně hnízdění, zatímco ((())) má tři.     //Pro každou skupinu vyjádřete nejhlubší úroveň vkládání závorek.     //Vstupní datovou řetězkou této funkce je řetěz, který představuje více skupin pro vnořené závorky oddělené mezerami.    // >>> parseNestedParens((""(()()) ((())) () ((())()())""))
    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))
    def parseNestedParens(paren_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseNestedParens(paren_string: String): List[Long] = {
    paren_string.split("" "").toList.map { group =>
      var maxDepth = 0
      var currentDepth = 0
      group.foreach {
        case '(' => 
          currentDepth += 1
          maxDepth = max(maxDepth, currentDepth)
        case ')' => 
          currentDepth -= 1
      }
      maxDepth.toLong
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    val result = parseNestedParens(""(()()) ((())) () ((())()())"")
    println(s""Result: ${result.mkString("", "")}"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseNestedParens((""(()()) ((())) () ((())()())"")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(parseNestedParens((""() (()) ((())) (((())))"")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(parseNestedParens((""(()(())((())))"")).equals((List[Long](4l.toLong))));
    }

}
"
HumanEval_7,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Filtr vstupního seznamu řetězců pouze pro ty, které obsahují daný podřetěz     // >>> filterBySubstring((List[String]()), (""a""))
    // (List[String]())
    // >>> filterBySubstring((List[String](""abc"", ""bacd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""bacd"", ""array""))
    def filterBySubstring(strings : List[String], substring : String) : List[String] = {
","strings.filter(_.contains(substring))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterBySubstring((List[String]()), (""john"")).equals((List[String]())));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xx"")).equals((List[String](""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""grunt"", ""trumpet"", ""prune"", ""gruesome"")), (""run"")).equals((List[String](""grunt"", ""prune""))));
    }

}
"
HumanEval_8,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Prázdný součet by se měl rovnat 0 a prázdný součet by se měl rovnat 1.    //Pro daný seznam celých čísel se vrátí tuple, který se skládá ze součtu a násobku všech celých čísel v seznamu.     // >>> sumProduct((List[Long]()))
    // ((0l, 1l))
    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // ((10l, 24l))
    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {
","def sumProduct(numbers: List[Long]): (Long, Long) = {
        val sum = numbers.sum
        val product = numbers.foldLeft(1L)(_ * _)
        (sum, product)
    }

    def main(args: Array[String]): Unit = {
        // Test examples
        println(sumProduct(List[Long]())) // (0L, 1L)
        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) // (10L, 24L)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumProduct((List[Long]())).equals(((0l, 1l))));
    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));
    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));
    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));
    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));
    }

}
"
HumanEval_9,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //v pořadí.    //Z daného seznamu celých čísel vytvořit seznam nejvyššího prvku, který byl nalezen do daného okamžiku.    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))
    def rollingMax(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def rollingMax(numbers: List[Long]): List[Long] = {
        var maxSoFar = Long.MinValue
        numbers.map { num =>
            maxSoFar = max(maxSoFar, num)
            maxSoFar
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(rollingMax((List[Long]())).equals((List[Long]())));
    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));
    }

}
"
HumanEval_10,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //- Přidejte na konec řetězce předznak řetězce, který přichází před palindromovou příponou.    //- Najít nejdelší postfix dodacího řetězce, který je palindrom.     //Algoritmus je jednoduchý:    //Najít nejkratší palindrom, který začíná přijatým řetězcem.     // >>> makePalindrome((""""))
    // ("""")
    // >>> makePalindrome((""cat""))
    // (""catac"")
    // >>> makePalindrome((""cata""))
    // (""catac"")
    def makePalindrome(string : String) : String = {
","def makePalindrome(string: String): String = {
    // Helper function to check if a string is a palindrome
    def isPalindrome(s: String): Boolean = s == s.reverse

    // Find the longest palindromic suffix
    var endIndex = string.length
    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {
      endIndex -= 1
    }

    // Extract the non-palindromic prefix
    val prefix = string.substring(0, endIndex - 1)

    // Append the reverse of the prefix to form the shortest palindrome
    string + prefix.reverse
  }
}","    }
    def main(args: Array[String]) = {
    assert(makePalindrome(("""")).equals(("""")));
    assert(makePalindrome((""x"")).equals((""x"")));
    assert(makePalindrome((""xyz"")).equals((""xyzyx"")));
    assert(makePalindrome((""xyx"")).equals((""xyx"")));
    assert(makePalindrome((""jerry"")).equals((""jerryrrej"")));
    }

}
"
HumanEval_11,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Provádějte binární XOR na těchto vstupních číslech a výsledek vrátíte také jako řetězec.    //Vstupní jsou dva řetězce a a b, které se skládají pouze z 1 a 0.    // >>> stringXor((""010""), (""110""))
    // (""100"")
    def stringXor(a : String, b : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringXor(a: String, b: String): String = {
    (a zip b).map { case (charA, charB) => 
      if (charA == charB) '0' else '1'
    }.mkString
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringXor((""111000""), (""101010"")).equals((""010010"")));
    assert(stringXor((""1""), (""1"")).equals((""0"")));
    assert(stringXor((""0101""), (""0000"")).equals((""0101"")));
    }

}
"
HumanEval_12,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //return None v případě, že je vstupní seznam prázdný.    //Z seznamu řetězců se vrátí nejdelší řetěz. V případě více řetězců se vrátí první řetěz.    // >>> longest((List[String]()))
    // None
    // >>> longest((List[String](""a"", ""b"", ""c"")))
    // Some(""a"")
    // >>> longest((List[String](""a"", ""bb"", ""ccc"")))
    // Some(""ccc"")
    def longest(strings : List[String]) : Option[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Out of list of strings, return the longest one. Return the first one in case of multiple
    // strings of the same length. Return None in case the input list is empty.
    def longest(strings: List[String]): Option[String] = {
        if (strings.isEmpty) None
        else Some(strings.maxBy(_.length))
    }
}","    }
    def main(args: Array[String]) = {
    assert(longest((List[String]())).equals(None));
    assert(longest((List[String](""x"", ""y"", ""z""))).equals(Some(""x"")));
    assert(longest((List[String](""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""))).equals(Some(""zzzz"")));
    }

}
"
HumanEval_13,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vraťte největší společný dělitel dvou celých čísel a a b     // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return a greatest common divisor of two integers a and b
    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a: Long, b: Long): Long = {
        if (b == 0) a else greatestCommonDivisor(b, a % b)
    }
}","    }
    def main(args: Array[String]) = {
    assert(greatestCommonDivisor((3l), (7l)) == (1l));
    assert(greatestCommonDivisor((10l), (15l)) == (5l));
    assert(greatestCommonDivisor((49l), (14l)) == (7l));
    assert(greatestCommonDivisor((144l), (60l)) == (12l));
    }

}
"
HumanEval_14,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Zpětný seznam všech předpon od nejkratšího po nejdelšího z vstupního řetězce     // >>> allPrefixes((""abc""))
    // (List[String](""a"", ""ab"", ""abc""))
    def allPrefixes(string : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return list of all prefixes from shortest to longest of the input string
  // >>> allPrefixes((""abc""))
  // (List[String](""a"", ""ab"", ""abc""))
  def allPrefixes(string: String): List[String] = {
    (1 to string.length).map(i => string.substring(0, i)).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(allPrefixes(("""")).equals((List[String]())));
    assert(allPrefixes((""asdfgh"")).equals((List[String](""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""))));
    assert(allPrefixes((""WWW"")).equals((List[String](""W"", ""WW"", ""WWW""))));
    }

}
"
HumanEval_15,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrací řetězec obsahující číslice s omezeným prostorem od 0 do n včetně.     // >>> stringSequence((0l))
    // (""0"")
    // >>> stringSequence((5l))
    // (""0 1 2 3 4 5"")
    def stringSequence(n : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringSequence(n: Long): String = {
    (0L to n).mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringSequence((0l)).equals((""0"")));
    assert(stringSequence((3l)).equals((""0 1 2 3"")));
    assert(stringSequence((10l)).equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Zjistěte, kolik znaků obsahuje řetězec     // >>> countDistinctCharacters((""xyzXYZ""))
    // (3l)
    // >>> countDistinctCharacters((""Jerry""))
    // (4l)
    def countDistinctCharacters(string : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a string, find out how many distinct characters (regardless of case) does it consist of
  // >>> countDistinctCharacters((""xyzXYZ""))
  // (3l)
  // >>> countDistinctCharacters((""Jerry""))
  // (4l)
  def countDistinctCharacters(string: String): Long = {
    string.toLowerCase.toSet.size.toLong
  }
}","    }
    def main(args: Array[String]) = {
    assert(countDistinctCharacters(("""")) == (0l));
    assert(countDistinctCharacters((""abcde"")) == (5l));
    assert(countDistinctCharacters((""abcdecadeCADE"")) == (5l));
    assert(countDistinctCharacters((""aaaaAAAAaaaa"")) == (1l));
    assert(countDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5l));
    }

}
"
HumanEval_17,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //'Hodě' - čtvrtý tón, trvá jeden úder.    //""O"" - půlku noty, trvá dva údery.    //""o"" - celá nota, trvá čtyři údery.    //Tady je legenda:    //Ne poslední.    //Vaším úkolem je analyzovat tento řetězec a vrátit seznam celých čísel odpovídajících počtu úderů každého     //Vstupní datovou řetězcí této funkce je řetěz představující hudební noty ve speciálním formátu ASCII.    // >>> parseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))
    def parseMusic(music_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseMusic(music_string: String): List[Long] = {
    val noteMap = Map(""o"" -> 4L, ""o|"" -> 2L, "".|"" -> 1L)
    val notes = music_string.split("" "")
    notes.toList.map(note => noteMap(note))
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseMusic(("""")).equals((List[Long]())));
    assert(parseMusic((""o o o o"")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic(("".| .| .| .|"")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));
    assert(parseMusic((""o| o| .| .| o o o o"")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic((""o| .| o| .| o o| o o|"")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));
    }

}
"
HumanEval_18,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Zjistěte, kolikrát se daný podstránek objeví v původním strunu. Spočítejte překrývající se případy.     // >>> howManyTimes((""""), (""a""))
    // (0l)
    // >>> howManyTimes((""aaa""), (""a""))
    // (3l)
    // >>> howManyTimes((""aaaa""), (""aa""))
    // (3l)
    def howManyTimes(string : String, substring : String) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def howManyTimes(string: String, substring: String): Long = {
        if (substring.isEmpty || string.isEmpty) return 0L
        var count: Long = 0L
        for (i <- 0 to (string.length - substring.length)) {
            if (string.substring(i, i + substring.length) == substring) {
                count += 1
            }
        }
        count
    }

    // Test cases
    def main(args: Array[String]): Unit = {
        println(howManyTimes("""", ""a""))    // Output: 0
        println(howManyTimes(""aaa"", ""a"")) // Output: 3
        println(howManyTimes(""aaaa"", ""aa"")) // Output: 3
    }
}","    }
    def main(args: Array[String]) = {
    assert(howManyTimes((""""), (""x"")) == (0l));
    assert(howManyTimes((""xyxyxyx""), (""x"")) == (4l));
    assert(howManyTimes((""cacacacac""), (""cac"")) == (4l));
    assert(howManyTimes((""john doe""), (""john"")) == (1l));
    }

}
"
HumanEval_19,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrací řetězec s čísly zorganizovanými od nejmenšího po největší     //Platné výběry jsou ""nula"", ""jedna"", ""dvě"", ""tři"", ""čtyři"", ""pět"", ""šest"", ""sedm"", ""osm"" a ""devět"".     //Vstup je prostorově ohraničený řetězec číslic od ""nula"" do ""devět"".    // >>> sortNumbers((""three one five""))
    // (""one three five"")
    def sortNumbers(numbers : String) : String = {
","def sortNumbers(numbers: String): String = {
    val numberWords = Map(
      ""zero"" -> 0,
      ""one"" -> 1,
      ""two"" -> 2,
      ""three"" -> 3,
      ""four"" -> 4,
      ""five"" -> 5,
      ""six"" -> 6,
      ""seven"" -> 7,
      ""eight"" -> 8,
      ""nine"" -> 9
    )
    
    numbers.split("" "")
      .sortBy(word => numberWords(word))
      .mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortNumbers(("""")).equals(("""")));
    assert(sortNumbers((""three"")).equals((""three"")));
    assert(sortNumbers((""three five nine"")).equals((""three five nine"")));
    assert(sortNumbers((""five zero four seven nine eight"")).equals((""zero four five seven eight nine"")));
    assert(sortNumbers((""six five four three two one zero"")).equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //a vraťte je v pořadí (menší počet, větší počet).    //Z přiděleného seznamu čísel (délka nejméně dvou) vyberte a vrátíte dvě, které jsou každému nejblíže     // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))
    // ((2.0f, 2.2f))
    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))
    // ((2.0f, 2.0f))
    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findClosestElements(numbers: List[Float]): (Float, Float) = {
    require(numbers.length >= 2, ""List must contain at least two elements"")
    val sortedNumbers = numbers.sorted

    var minDiff = Float.MaxValue
    var closestPair = (0.0f, 0.0f)

    for(i <- 0 until sortedNumbers.length - 1) {
      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))
      if(currentDiff < minDiff) {
        minDiff = currentDiff
        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))
      }
    }
    
    closestPair
  }
}","    }
    def main(args: Array[String]) = {
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));
    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));
    }

}
"
HumanEval_21,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //tak, že nejmenší číslo se stane 0, a největší číslo se stane 1     //Za předpokladu, že je uveden seznam čísel (alespoň dvou prvků), použijte na tento seznam lineární transformaci,     // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))
    // (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))
    def rescaleToUnit(numbers : List[Float]) : List[Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given list of numbers (of at least two elements), apply a linear transform to that list,
  // such that the smallest number will become 0 and the largest will become 1
  def rescaleToUnit(numbers: List[Float]): List[Float] = {
    val minVal = numbers.min
    val maxVal = numbers.max
    numbers.map(num => (num - minVal) / (maxVal - minVal))
  }
}

// Usage example
object Main extends App {
  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)
  val rescaledNumbers = Problem.rescaleToUnit(numbers)
  println(rescaledNumbers) // Output: List(0.0, 0.25, 0.5, 0.75, 1.0)
}","    }
    def main(args: Array[String]) = {
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));
    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    }

}
"
HumanEval_22,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Filtr daného seznamu všech hodnot scalathonu pouze pro celé čísla     // >>> filterIntegers((List[Any](""a"", 3.14f, 5l)))
    // (List[Long](5l.toLong))
    // >>> filterIntegers((List[Any](1l, 2l, 3l, ""abc"", Map[Long,Long](), List[Long]())))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    def filterIntegers(values : List[Any]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def filterIntegers(values: List[Any]): List[Long] = {
    values.collect {
      case l: Long => l
    }
  }

  def main(args: Array[String]): Unit = {
    println(filterIntegers(List[Any](""a"", 3.14f, 5l))) // List(5)
    println(filterIntegers(List[Any](1l, 2l, 3l, ""abc"", Map[Long, Long](), List[Long]()))) // List(1, 2, 3)
  }
}","    }
    def main(args: Array[String]) = {
    assert(filterIntegers((List[Any]())).equals((List[Long]())));
    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, ""adasd""))).equals((List[Long](4l.toLong, 9l.toLong))));
    assert(filterIntegers((List[Any](3l, ""c"", 3l, 3l, ""a"", ""b""))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_23,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Zpětná délka daného řetězce     // >>> stringLength((""""))
    // (0l)
    // >>> stringLength((""abc""))
    // (3l)
    def strlen(string : String) : Long = {
","def strlen(string: String): Long = {
        string.length.toLong
    }
}","    }
    def main(args: Array[String]) = {
    assert(strlen(("""")) == (0l));
    assert(strlen((""x"")) == (1l));
    assert(strlen((""asdasnakj"")) == (9l));
    }

}
"
HumanEval_24,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Pro daný počet n, najděte největší číslo, které dělí n rovnoměrně, menší než n     // >>> largestDivisor((15l))
    // (5l)
    def largestDivisor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // For a given number n, find the largest number that divides n evenly, smaller than n
    // >>> largestDivisor(15l)
    // (5l)
    def largestDivisor(n: Long): Long = {
        for (i <- (n / 2) to 1 by -1) {
            if (n % i == 0) return i
        }
        1L  // if no divisor found, return 1 (since 1 divides any number)
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestDivisor((3l)) == (1l));
    assert(largestDivisor((7l)) == (1l));
    assert(largestDivisor((10l)) == (5l));
    assert(largestDivisor((100l)) == (50l));
    assert(largestDivisor((49l)) == (7l));
    }

}
"
HumanEval_25,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vstupní číslo by se mělo rovnat součtu všech faktorů.    //Každý z faktorů by měl být uveden početkrát odpovídající tomu, kolikrát se objeví v faktorizování.    //Vrací seznam prvočísel daného celého čísla v pořadí od nejmenšího po největší.    // >>> factorize((8l))
    // (List[Long](2l.toLong, 2l.toLong, 2l.toLong))
    // >>> factorize((25l))
    // (List[Long](5l.toLong, 5l.toLong))
    // >>> factorize((70l))
    // (List[Long](2l.toLong, 5l.toLong, 7l.toLong))
    def factorize(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def factorize(n: Long): List[Long] = {
    var num = n
    val factors = ListBuffer[Long]()
    
    var i = 2L
    while (i <= sqrt(num).toLong) {
      while (num % i == 0) {
        factors += i
        num /= i
      }
      i += 1
    }
    
    if (num > 1) {
      factors += num
    }
    
    factors.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(factorize((2l)).equals((List[Long](2l.toLong))));
    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));
    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));
    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_26,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Udržujte pořadí prvků stejné jako v vstupním čísle.    //Z seznamu celých čísel odstraníme všechny prvky, které se objeví více než jednou.    // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 3l.toLong, 4l.toLong))
    def removeDuplicates(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def removeDuplicates(numbers: List[Long]): List[Long] = {
    val elementCount = numbers.groupBy(identity).mapValues(_.size)
    numbers.filter(num => elementCount(num) == 1)
  }

  def main(args: Array[String]): Unit = {
    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)
    println(removeDuplicates(numbers)) // Output: List(1, 3, 4)
  }
}","    }
    def main(args: Array[String]) = {
    assert(removeDuplicates((List[Long]())).equals((List[Long]())));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));
    }

}
"
HumanEval_27,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Pro daný řetězec přepojte malí písmena na velká a velká na malí písmena.     // >>> flipCase((""Hello""))
    // (""hELLO"")
    def flipCase(string : String) : String = {
","def flipCase(string: String): String = {
    string.map {
      case c if c.isLower => c.toUpper
      case c if c.isUpper => c.toLower
      case c => c
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(flipCase(("""")).equals(("""")));
    assert(flipCase((""Hello!"")).equals((""hELLO!"")));
    assert(flipCase((""These violent delights have violent ends"")).equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Přidělit seznam řetězců do jednoho řetězce    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Concatenate list of strings into a single string
    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings: List[String]): String = {
        strings.mkString("""")
    }
}","    }
    def main(args: Array[String]) = {
    assert(concatenate((List[String]())).equals(("""")));
    assert(concatenate((List[String](""x"", ""y"", ""z""))).equals((""xyz"")));
    assert(concatenate((List[String](""x"", ""y"", ""z"", ""w"", ""k""))).equals((""xyzwk"")));
    }

}
"
HumanEval_29,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Filtr vstupního seznamu řetězců pouze pro ty, které začínají danou předponou.    // >>> filterByPrefix((List[String]()), (""a""))
    // (List[String]())
    // >>> filterByPrefix((List[String](""abc"", ""bcd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""array""))
    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {
","strings.filter(_.startsWith(prefix))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterByPrefix((List[String]()), (""john"")).equals((List[String]())));
    assert(filterByPrefix((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    }

}
"
HumanEval_30,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vraťte pouze kladná čísla ze seznamu.     // >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](2l.toLong, 5l.toLong, 6l.toLong))
    // >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))
    def getPositive(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def getPositive(l: List[Long]): List[Long] = {
        l.filter(_ > 0)
    }
}","    }
    def main(args: Array[String]) = {
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));
    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));
    assert(getPositive((List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_31,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrací hodnotu true, pokud je dané číslo prvočíslo, a false v opačném případě.    // >>> isPrime((6l))
    // (false)
    // >>> isPrime((101l))
    // (true)
    // >>> isPrime((11l))
    // (true)
    // >>> isPrime((13441l))
    // (true)
    // >>> isPrime((61l))
    // (true)
    // >>> isPrime((4l))
    // (false)
    // >>> isPrime((1l))
    // (false)
    def isPrime(n : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if a given number is prime, and false otherwise.
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPrime((6l)) == (false));
    assert(isPrime((101l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((13441l)) == (true));
    assert(isPrime((61l)) == (true));
    assert(isPrime((4l)) == (false));
    assert(isPrime((1l)) == (false));
    assert(isPrime((5l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((17l)) == (true));
    assert(isPrime((85l)) == (false));
    assert(isPrime((77l)) == (false));
    assert(isPrime((255379l)) == (false));
    }

}
"
HumanEval_33,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //k hodnotám odpovídajících indexů l, ale tříděny.    //l' je totožné s l v indexech, které nejsou dělitelné třemi, zatímco jeho hodnoty v indexech, které jsou dělitelné třemi, jsou stejné     //Tato funkce bere seznam l a vrátí seznam l' tak, že     // >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))
    def sortThird(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def sortThird(l: List[Long]): List[Long] = {
    // Get the elements at indices divisible by 3
    val elementsAtThirdIndices = l.zipWithIndex.collect {
      case (value, index) if index % 3 == 0 => value
    }
    
    // Sort the collected elements
    val sortedElements = elementsAtThirdIndices.sorted
    
    // Replace elements at indices divisible by 3 with the sorted ones
    l.zipWithIndex.map {
      case (_, index) if index % 3 == 0 => sortedElements(index / 3)
      case (value, _) => value
    }
  }

  // Example usage:
  def main(args: Array[String]): Unit = {
    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));
    }

}
"
HumanEval_34,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrací tříděné jedinečné prvky ze seznamu .    // >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))
    def unique(l : List[Long]) : List[Long] = {
","def unique(l: List[Long]): List[Long] = {
    l.toSet.toList.sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));
    }

}
"
HumanEval_35,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrací maximální počet prvků v seznamu.    // >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (3l)
    // >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (123l)
    def maxElement(l : List[Long]) : Long = {
","def maxElement(l: List[Long]): Long = {
    l.max
  }
}","    }
    def main(args: Array[String]) = {
    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));
    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));
    }

}
"
HumanEval_36,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrátí počet případů, kdy se číslice 7 objeví v celých číslech menších než n, které jsou dělitelné 11 nebo 13.     // >>> fizzBuzz((50l))
    // (0l)
    // >>> fizzBuzz((78l))
    // (2l)
    // >>> fizzBuzz((79l))
    // (3l)
    def fizzBuzz(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fizzBuzz(n: Long): Long = {
    var count = 0L
    for (i <- 1L until n) {
      if (i % 11 == 0 || i % 13 == 0) {
        count += i.toString.count(_ == '7')
      }
    }
    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(fizzBuzz((50l)) == (0l));
    assert(fizzBuzz((78l)) == (2l));
    assert(fizzBuzz((79l)) == (3l));
    assert(fizzBuzz((100l)) == (3l));
    assert(fizzBuzz((200l)) == (6l));
    assert(fizzBuzz((4000l)) == (192l));
    assert(fizzBuzz((10000l)) == (639l));
    assert(fizzBuzz((100000l)) == (8026l));
    }

}
"
HumanEval_37,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //k hodnotám párných indexů l, ale tříděné.    //l' je totožné s l v neparevných indexech, zatímco jeho hodnoty v párných indexech jsou stejné     //Tato funkce bere seznam l a vrátí seznam l' tak, že     // >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))
    def sortEven(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // This function takes a list l and returns a list l' such that
  // l' is identical to l in the odd indicies, while its values at the even indicies are equal
  // to the values of the even indicies of l, but sorted.
  def sortEven(l: List[Long]): List[Long] = {
    val evenIndices = l.indices.filter(_ % 2 == 0)
    val sortedEvens = evenIndices.map(l(_)).sorted

    l.indices.map { index =>
      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))
      else l(index)
    }.toList
  }

  // Examples
  def main(args: Array[String]): Unit = {
    println(sortEven(List[Long](1L, 2L, 3L)))
    println(sortEven(List[Long](5L, 6L, 3L, 4L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));
    }

}
"
HumanEval_39,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //prime_fib vrací n-té číslo, které je Fibonacciho číslo a je také prvočíslo.     // >>> primeFib((1l))
    // (2l)
    // >>> primeFib((2l))
    // (3l)
    // >>> primeFib((3l))
    // (5l)
    // >>> primeFib((4l))
    // (13l)
    // >>> primeFib((5l))
    // (89l)
    def primeFib(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeFib(n: Long): Long = {
    // Function to check if a number is prime
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num == 2) return true
      if (num % 2 == 0) return false
      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {
        if (num % i == 0) return false
      }
      true
    }

    // Function to generate Fibonacci numbers
    def fibonacciStream(): Stream[Long] = {
      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)
      fibs(0, 1)
    }

    // Find the n-th Fibonacci number that is also prime
    val primeFibs = fibonacciStream().filter(isPrime)
    primeFibs.take(n.toInt).last
  }

  // Test the function
  def main(args: Array[String]): Unit = {
    println(primeFib(1L)) // 2
    println(primeFib(2L)) // 3
    println(primeFib(3L)) // 5
    println(primeFib(4L)) // 13
    println(primeFib(5L)) // 89
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeFib((1l)) == (2l));
    assert(primeFib((2l)) == (3l));
    assert(primeFib((3l)) == (5l));
    assert(primeFib((4l)) == (13l));
    assert(primeFib((5l)) == (89l));
    assert(primeFib((6l)) == (233l));
    assert(primeFib((7l)) == (1597l));
    assert(primeFib((8l)) == (28657l));
    assert(primeFib((9l)) == (514229l));
    assert(primeFib((10l)) == (433494437l));
    }

}
"
HumanEval_40,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Svaz na nulu a jinak falešný.    //vrátí hodnotu true, pokud jsou v seznamu tři odlišné prvky, které     //triples_sum_to_zero bere jako vstup seznam celých čísel.    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong)))
    // (false)
    def triplesSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // triples_sum_to_zero takes a list of integers as an input.
    // it returns true if there are three distinct elements in the list that
    // sum to zero, and false otherwise.
    def triplesSumToZero(l: List[Long]): Boolean = {
        val n = l.length
        if (n < 3) return false

        // Sort the list to use the two-pointer technique
        val sortedList = l.sorted

        // Iterate over the list
        for (i <- 0 until n - 2) {
            var left = i + 1
            var right = n - 1

            // Use two pointers to find the remaining two numbers
            while (left < right) {
                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)
                if (currentSum == 0) {
                    return true
                } else if (currentSum < 0) {
                    left += 1
                } else {
                    right -= 1
                }
            }
        }

        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    }

}
"
HumanEval_41,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Tato funkce vykazuje počet takovýchto srážek.     //na jejich dráze, jako by se nesetkali.    //Nicméně, auta jsou nekonečně robustní a silná, a proto se stále pohybují.    //Když auto, které se pohybuje zleva doprava narazí na auto, které se pohybuje zprava doleva.    //Všechna auta se pohybují stejnou rychlostí.    //Tyto dvě skupiny aut jsou velmi vzdálené od...    //N aut jezdí zleva doprava; současně, jiná sada n aut.    //Představte si cestu, která je perfektně rovná, nekonečně dlouhá čára.    def carRaceCollision(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Imagine a road that's a perfectly straight infinitely long line.
  // n cars are driving left to right; simultaneously, a different set of n cars
  // are driving right to left. The two sets of cars start out being very far from
  // each other. All cars move at the same speed. Two cars are said to collide
  // when a car that's moving left to right hits a car that's moving right to left.
  // However, the cars are infinitely sturdy and strong; as a result, they continue moving
  // in their trajectory as if they did not collide.
  // This function outputs the number of such collisions.
  def carRaceCollision(n: Long): Long = {
    n
  }
}","    }
    def main(args: Array[String]) = {
    assert(carRaceCollision((2l)) == (4l));
    assert(carRaceCollision((3l)) == (9l));
    assert(carRaceCollision((4l)) == (16l));
    assert(carRaceCollision((8l)) == (64l));
    assert(carRaceCollision((10l)) == (100l));
    }

}
"
HumanEval_42,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Seznam vrácených položek s přírůstkem 1.     // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))
    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))
    def incrList(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return list with elements incremented by 1.
    def incrList(l: List[Long]): List[Long] = {
        l.map(_ + 1)
    }
}","    }
    def main(args: Array[String]) = {
    assert(incrList((List[Long]())).equals((List[Long]())));
    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));
    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));
    }

}
"
HumanEval_43,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Svaz na nulu a jinak falešný.    //vrátí hodnotu true, pokud jsou v seznamu dva odlišné prvky, které     //pairs_sum_to_zero bere jako vstup seznam celých čísel.     // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (true)
    // >>> pairsSumToZero((List[Long](1l.toLong)))
    // (false)
    def pairsSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def pairsSumToZero(l: List[Long]): Boolean = {
        val seen = HashSet[Long]()
        for (num <- l) {
            if (seen.contains(-num)) {
                return true
            }
            seen.add(num)
        }
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));
    }

}
"
HumanEval_44,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //základní čísla jsou menší než 10.    //vrácení řetězcové reprezentace po konverzi.    //Změňte číselnou základnu vstupního čísla x na základnu.    // >>> changeBase((8l), (3l))
    // (""22"")
    // >>> changeBase((8l), (2l))
    // (""1000"")
    // >>> changeBase((7l), (2l))
    // (""111"")
    def changeBase(x : Long, base : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def changeBase(x: Long, base: Long): String = {
        require(base > 1 && base < 10, ""Base must be between 2 and 9"")
        
        if (x == 0) return ""0""

        val result = new StringBuilder()
        var number = x

        while (number > 0) {
            val remainder = number % base
            result.append(remainder.toString)
            number /= base
        }

        result.reverse.toString()
    }
}","    }
    def main(args: Array[String]) = {
    assert(changeBase((8l), (3l)).equals((""22"")));
    assert(changeBase((9l), (3l)).equals((""100"")));
    assert(changeBase((234l), (2l)).equals((""11101010"")));
    assert(changeBase((16l), (2l)).equals((""10000"")));
    assert(changeBase((8l), (2l)).equals((""1000"")));
    assert(changeBase((7l), (2l)).equals((""111"")));
    assert(changeBase((2l), (3l)).equals((""2"")));
    assert(changeBase((3l), (4l)).equals((""3"")));
    assert(changeBase((4l), (5l)).equals((""4"")));
    assert(changeBase((5l), (6l)).equals((""5"")));
    assert(changeBase((6l), (7l)).equals((""6"")));
    assert(changeBase((7l), (8l)).equals((""7"")));
    }

}
"
HumanEval_45,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Dávka délky strany a vysoké návratové plochy pro trojúhelník.    // >>> triangleArea((5l), (3l))
    // (7.5f)
    def triangleArea(a : Long, h : Long) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> triangleArea(5l, 3l)
    // (7.5f)
    def triangleArea(a: Long, h: Long): Float = {
        (a * h / 2.0).toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((5l), (3l)) == (7.5f));
    assert(triangleArea((2l), (2l)) == (2.0f));
    assert(triangleArea((10l), (8l)) == (40.0f));
    }

}
"
HumanEval_46,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Napište prosím funkci, která efektivně vypočítá n-tý prvek číselné řady fib4. Nepoužívejte rekurzi.    //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     //fib4(3) -> 0     //fib4(2) -> 2     //fib4(1) -> 0     //fib4(0) -> 0     //Fib4 je sekvence podobná Fibbonacciho sekvenci, která je definována takto:    // >>> fib4((5l))
    // (4l)
    // >>> fib4((6l))
    // (8l)
    // >>> fib4((7l))
    // (14l)
    def fib4(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fib4(n: Long): Long = {
    if (n == 0 || n == 1) return 0
    if (n == 2) return 2
    if (n == 3) return 0

    var a: Long = 0
    var b: Long = 0
    var c: Long = 2
    var d: Long = 0
    
    var result: Long = 0
    
    for (i <- 4L to n) {
      result = a + b + c + d
      a = b
      b = c
      c = d
      d = result
    }
    
    result
  }
}","    }
    def main(args: Array[String]) = {
    assert(fib4((5l)) == (4l));
    assert(fib4((8l)) == (28l));
    assert(fib4((10l)) == (104l));
    assert(fib4((12l)) == (386l));
    }

}
"
HumanEval_47,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Medián návratnosti prvků v seznamu l.     // >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // 3l
    // >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))
    // (15.0f)
    def median(l : List[Long]) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return median of elements in the list l.
  def median(l: List[Long]): Float = {
    val sortedList = l.sorted
    val n = sortedList.length
    if (n % 2 == 1) {
      sortedList(n / 2).toFloat
    } else {
      (sortedList(n / 2 - 1) + sortedList(n / 2)).toFloat / 2
    }
  }

  def main(args: Array[String]): Unit = {
    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) // 3.0
    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) // 15.0
  }
}","    }
    def main(args: Array[String]) = {
    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);
    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));
    assert(median((List[Long](5l.toLong))) == 5l);
    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));
    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);
    }

}
"
HumanEval_48,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Ověřuje, zda je daný řetězec palindromem.    // >>> isPalindrome((""""))
    // (true)
    // >>> isPalindrome((""aba""))
    // (true)
    // >>> isPalindrome((""aaaaa""))
    // (true)
    // >>> isPalindrome((""zbcd""))
    // (false)
    def isPalindrome(text : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Checks if given string is a palindrome
  def isPalindrome(text: String): Boolean = {
    val length = text.length
    for (i <- 0 until length / 2) {
      if (text(i) != text(length - i - 1)) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPalindrome(("""")) == (true));
    assert(isPalindrome((""aba"")) == (true));
    assert(isPalindrome((""aaaaa"")) == (true));
    assert(isPalindrome((""zbcd"")) == (false));
    assert(isPalindrome((""xywyx"")) == (true));
    assert(isPalindrome((""xywyz"")) == (false));
    assert(isPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vraťte 2^n modulo p (pozor na číslice).    // >>> modp((3l), (5l))
    // (3l)
    // >>> modp((1101l), (101l))
    // (2l)
    // >>> modp((0l), (101l))
    // (1l)
    // >>> modp((3l), (11l))
    // (8l)
    // >>> modp((100l), (101l))
    // (1l)
    def modp(n : Long, p : Long) : Long = {
","def modp(n: Long, p: Long): Long = {
    // Calculate 2^n modulo p using iterative exponentiation by squaring.
    def powMod(base: Long, exp: Long, mod: Long): Long = {
      var result = 1L
      var b = base % mod
      var e = exp
      
      while (e > 0) {
        if ((e & 1) == 1) { // Check if e is odd
          result = (result * b) % mod
        }
        e >>= 1
        b = (b * b) % mod
      }

      result
    }

    powMod(2, n, p)
  }
}","    }
    def main(args: Array[String]) = {
    assert(modp((3l), (5l)) == (3l));
    assert(modp((1101l), (101l)) == (2l));
    assert(modp((0l), (101l)) == (1l));
    assert(modp((3l), (11l)) == (8l));
    assert(modp((100l), (101l)) == (1l));
    assert(modp((30l), (5l)) == (4l));
    assert(modp((31l), (5l)) == (3l));
    }

}
"
HumanEval_51,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //remove_vowels je funkce, která bere řetězec a vrátí řetězec bez samohlásek.     // >>> removeVowels((""""))
    // ("""")
    // >>> removeVowels((""abcdef""))
    // (""bcdf"")
    // >>> removeVowels((""aaaaa""))
    // ("""")
    // >>> removeVowels((""aaBAA""))
    // (""B"")
    // >>> removeVowels((""zbcd""))
    // (""zbcd"")
    def removeVowels(text : String) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def removeVowels(text: String): String = {
        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        text.filterNot(vowels.contains)
    }
}","    }
    def main(args: Array[String]) = {
    assert(removeVowels(("""")).equals(("""")));
    assert(removeVowels((""abcdef\nghijklm"")).equals((""bcdf\nghjklm"")));
    assert(removeVowels((""fedcba"")).equals((""fdcb"")));
    assert(removeVowels((""eeeee"")).equals(("""")));
    assert(removeVowels((""acBAA"")).equals((""cB"")));
    assert(removeVowels((""EcBOO"")).equals((""cB"")));
    assert(removeVowels((""ybcd"")).equals((""ybcd"")));
    }

}
"
HumanEval_52,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrátí hodnotu true, pokud jsou všechna čísla v seznamu l pod prahem t.     // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
    // (true)
    // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
    // (false)
    def belowThreshold(l : List[Long], t : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if all numbers in the list l are below threshold t.
  // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
  // (true)
  // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
  // (false)
  def belowThreshold(l: List[Long], t: Long): Boolean = {
    l.forall(_ < t)
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));
    }

}
"
HumanEval_53,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Přidáme dvě čísla x a y .    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Add two numbers x and y
    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x: Long, y: Long): Long = {
        x + y
    }
}","    }
    def main(args: Array[String]) = {
    assert(add((0l), (1l)) == (1l));
    assert(add((1l), (0l)) == (1l));
    assert(add((2l), (3l)) == (5l));
    assert(add((5l), (7l)) == (12l));
    assert(add((7l), (5l)) == (12l));
    }

}
"
HumanEval_54,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Zkontrolujte, zda dvě slova mají stejné znaky.    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> sameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> sameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> sameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> sameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    def sameChars(s0 : String, s1 : String) : Boolean = {
","import scala.collection.mutable._

object Problem {
  def sameChars(s0: String, s1: String): Boolean = {
    def charSet(s: String): Set[Char] = s.toSet
    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(sameChars((""abcd""), (""dddddddabc"")) == (true));
    assert(sameChars((""dddddddabc""), (""abcd"")) == (true));
    assert(sameChars((""eabcd""), (""dddddddabc"")) == (false));
    assert(sameChars((""abcd""), (""dddddddabcf"")) == (false));
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(sameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vraťte n-té Fibonacciho číslo.     // >>> fib((10l))
    // (55l)
    // >>> fib((1l))
    // (1l)
    // >>> fib((8l))
    // (21l)
    def fib(n : Long) : Long = {
","def fib(n: Long): Long = {
        if (n <= 1) n
        else {
            var a: Long = 0
            var b: Long = 1
            for (_ <- 2L to n) {
                val temp = a + b
                a = b
                b = temp
            }
            b
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(fib((10l)) == (55l));
    assert(fib((1l)) == (1l));
    assert(fib((8l)) == (21l));
    assert(fib((11l)) == (89l));
    assert(fib((12l)) == (144l));
    }

}
"
HumanEval_56,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //return true pokud každá otevřená závorka má odpovídající zavřená závorka.     //závorky je řetězec ""<"" a "">"".     // >>> correctBracketing((""<""))
    // (false)
    // >>> correctBracketing((""<>""))
    // (true)
    // >>> correctBracketing((""<<><>>""))
    // (true)
    // >>> correctBracketing((""><<>""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","import scala.collection.mutable.Stack

object Problem {
  def correctBracketing(brackets: String): Boolean = {
    val stack = new Stack[Char]()
    for (char <- brackets) {
      if (char == '<') {
        stack.push(char)
      } else if (char == '>') {
        if (stack.isEmpty || stack.pop() != '<') {
          return false
        }
      }
    }
    stack.isEmpty
  }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""<>"")) == (true));
    assert(correctBracketing((""<<><>>"")) == (true));
    assert(correctBracketing((""<><><<><>><>"")) == (true));
    assert(correctBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(correctBracketing((""<<<><>>>>"")) == (false));
    assert(correctBracketing((""><<>"")) == (false));
    assert(correctBracketing((""<"")) == (false));
    assert(correctBracketing((""<<<<"")) == (false));
    assert(correctBracketing(("">"")) == (false));
    assert(correctBracketing((""<<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>><<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrací hodnotu true, pokud jsou prvky seznamu monotónně narůstající nebo klesající.    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
    // (true)
    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
    // (false)
    // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
    // (true)
    def monotonic(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if list elements are monotonically increasing or decreasing.
  // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
  // (true)
  // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
  // (false)
  // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
  // (true)
  def monotonic(l: List[Long]): Boolean = {
    if (l.isEmpty || l.length == 1) return true

    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }
    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }

    increasing || decreasing
  }
}","    }
    def main(args: Array[String]) = {
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));
    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));
    }

}
"
HumanEval_58,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrací tříděné jedinečné společné prvky pro dva seznamy.    // >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))
    // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))
    // >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong))
    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return sorted unique common elements for two lists.
  def common(l1: List[Long], l2: List[Long]): List[Long] = {
    (l1.toSet intersect l2.toSet).toList.sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))
    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));
    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_59,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vraťte největší prvočíselný faktor n. Předpokládejme, že n > 1 není prvočíselné číslo.     // >>> largestPrimeFactor((13195l))
    // (29l)
    // >>> largestPrimeFactor((2048l))
    // (2l)
    def largestPrimeFactor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def largestPrimeFactor(n: Long): Long = {
        var number = n
        var largestFactor = 1L

        // Check for number of 2s that divide n
        while (number % 2 == 0) {
            largestFactor = 2L
            number /= 2
        }

        // n must be odd at this point, so a skip of 2 (i = i + 2) can be used
        var i = 3
        while (i <= sqrt(number)) {
            while (number % i == 0) {
                largestFactor = i
                number /= i
            }
            i += 2
        }

        // This condition is to check if number is a prime number greater than 2
        if (number > 2) {
            largestFactor = number
        }

        largestFactor
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestPrimeFactor((15l)) == (5l));
    assert(largestPrimeFactor((27l)) == (3l));
    assert(largestPrimeFactor((63l)) == (7l));
    assert(largestPrimeFactor((330l)) == (11l));
    assert(largestPrimeFactor((13195l)) == (29l));
    }

}
"
HumanEval_60,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //sum_to_n je funkce, která sečítají čísla od 1 do n.     // >>> sumToN((30l))
    // (465l)
    // >>> sumToN((100l))
    // (5050l)
    // >>> sumToN((5l))
    // (15l)
    // >>> sumToN((10l))
    // (55l)
    // >>> sumToN((1l))
    // (1l)
    def sumToN(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def sumToN(n: Long): Long = {
        (1L to n).sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumToN((1l)) == (1l));
    assert(sumToN((6l)) == (21l));
    assert(sumToN((11l)) == (66l));
    assert(sumToN((30l)) == (465l));
    assert(sumToN((100l)) == (5050l));
    }

}
"
HumanEval_61,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //return true pokud každá otevřená závorka má odpovídající zavřená závorka.     //závorky je řetězec ""("" a "")"".     // >>> correctBracketing((""(""))
    // (false)
    // >>> correctBracketing((""()""))
    // (true)
    // >>> correctBracketing((""(()())""))
    // (true)
    // >>> correctBracketing(("")(()""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","var balance = 0
        for (ch <- brackets) {
            if (ch == '(') balance += 1
            else if (ch == ')') balance -= 1
            
            if (balance < 0) return false
        }
        balance == 0
    }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""()"")) == (true));
    assert(correctBracketing((""(()())"")) == (true));
    assert(correctBracketing((""()()(()())()"")) == (true));
    assert(correctBracketing((""()()((()()())())(()()(()))"")) == (true));
    assert(correctBracketing((""((()())))"")) == (false));
    assert(correctBracketing(("")(()"")) == (false));
    assert(correctBracketing((""("")) == (false));
    assert(correctBracketing((""(((("")) == (false));
    assert(correctBracketing(("")"")) == (false));
    assert(correctBracketing((""(()"")) == (false));
    assert(correctBracketing((""()()(()())())(()"")) == (false));
    assert(correctBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vraťte derivaci tohoto polynomia ve stejné podobě.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....     //xs představují koeficienty polynomia.    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))
    // >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong))
    def derivative(xs : List[Long]) : List[Long] = {
","import scala.collection.mutable._

object Problem {
  def derivative(xs: List[Long]): List[Long] = {
    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }
  }
}","    }
    def main(args: Array[String]) = {
    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));
    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));
    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_63,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Napište prosím funkci, která efektivně vypočítá n-tý prvek řady čísel fibfib.    //fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3).     //Fibfib ({\displaystyle f_{fib}{\displaystyle f_{fib}{\displaystyle f_{fib}{\displaystyle f_{\}})    //0     //0 0 0    //FibFib je sekvence podobná Fibbonacciho sekvenci, která je definována takto:    // >>> fibfib((1l))
    // (0l)
    // >>> fibfib((5l))
    // (4l)
    // >>> fibfib((8l))
    // (24l)
    def fibfib(n : Long) : Long = {
","def fibfib(n: Long): Long = {
    if (n == 0) return 0
    if (n == 1) return 0
    if (n == 2) return 1

    var a: Long = 0
    var b: Long = 0
    var c: Long = 1
    var d: Long = 0

    for (_ <- 3L to n) {
      d = a + b + c
      a = b
      b = c
      c = d
    }
    d
  }
}","    }
    def main(args: Array[String]) = {
    assert(fibfib((2l)) == (1l));
    assert(fibfib((1l)) == (0l));
    assert(fibfib((5l)) == (4l));
    assert(fibfib((8l)) == (24l));
    assert(fibfib((10l)) == (81l));
    assert(fibfib((12l)) == (274l));
    assert(fibfib((14l)) == (927l));
    }

}
"
HumanEval_64,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Vokál, ale pouze pokud je na konci daného slova.    //Vokály v tomto případě jsou ""a"", ""e"", ""i"", ""o"", ""u"".    //slovo jako vstup a vrátí počet samohlásek v řetězci.    //Napište funkci vowels_count , která bere řetězec reprezentující     // >>> vowelsCount((""abcde""))
    // (2l)
    // >>> vowelsCount((""ACEDY""))
    // (3l)
    def vowelsCount(s : String) : Long = {
","def vowelsCount(s: String): Long = {
    val vowels = Set('a', 'e', 'i', 'o', 'u')
    val lowerCaseWord = s.toLowerCase
    var count = 0L

    for (i <- lowerCaseWord.indices) {
      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(vowelsCount((""abcde"")) == (2l));
    assert(vowelsCount((""Alone"")) == (3l));
    assert(vowelsCount((""key"")) == (2l));
    assert(vowelsCount((""bye"")) == (1l));
    assert(vowelsCount((""keY"")) == (2l));
    assert(vowelsCount((""bYe"")) == (1l));
    assert(vowelsCount((""ACEDY"")) == (3l));
    }

}
"
HumanEval_65,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Pokud je shift > počet číslic, vrátí se obrácené číslice.     //a výsledek vrátíme jako řetězec.     //Kruhový posun číslic celé čísla x, posun číslic doprava posunem.    // >>> circularShift((12l), (1l))
    // (""21"")
    // >>> circularShift((12l), (2l))
    // (""12"")
    def circularShift(x : Long, shift : Long) : String = {
","def circularShift(x: Long, shift: Long): String = {
  val digits = x.toString
  val length = digits.length
  
  if (shift >= length) {
    digits.reverse
  } else {
    val effectiveShift = (length - shift % length).toInt
    (digits.drop(effectiveShift) + digits.take(effectiveShift))
  }
}","    }
    def main(args: Array[String]) = {
    assert(circularShift((100l), (2l)).equals((""001"")));
    assert(circularShift((12l), (2l)).equals((""12"")));
    assert(circularShift((97l), (8l)).equals((""79"")));
    assert(circularShift((12l), (1l)).equals((""21"")));
    assert(circularShift((11l), (101l)).equals((""11"")));
    }

}
"
HumanEval_66,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //ASCII kódy.     //Napíše funkci, která bere řetěz jako vstup a vrátí pouze součet horních znaků.    //Úkol     // >>> digitSum((""""))
    // (0l)
    // >>> digitSum((""abAB""))
    // (131l)
    // >>> digitSum((""abcCd""))
    // (67l)
    // >>> digitSum((""helloE""))
    // (69l)
    // >>> digitSum((""woArBld""))
    // (131l)
    // >>> digitSum((""aAaaaXa""))
    // (153l)
    def digitSum(s : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def digitSum(s: String): Long = {
    s.filter(_.isUpper).map(_.toLong).sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(digitSum(("""")) == (0l));
    assert(digitSum((""abAB"")) == (131l));
    assert(digitSum((""abcCd"")) == (67l));
    assert(digitSum((""helloE"")) == (69l));
    assert(digitSum((""woArBld"")) == (131l));
    assert(digitSum((""aAaaaXa"")) == (153l));
    assert(digitSum(("" How are yOu?"")) == (151l));
    assert(digitSum((""You arE Very Smart"")) == (327l));
    }

}
"
HumanEval_67,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //pro examble:     //v košíku vyjádří počet mango v košíku.     //pomeranče a jablka a celé číslo , které představuje celkový počet plodů     //Když vezmeme řetězec, který představuje celkový počet     //které jsou rozděleny v košíku s ovocem, který tento košík obsahuje.    //V tomto úkolu vám bude dána řada, která představuje počet jablek a pomerančů.    // >>> fruitDistribution((""5 apples and 6 oranges""), (19l))
    // (8l)
    // >>> fruitDistribution((""0 apples and 1 oranges""), (3l))
    // (2l)
    // >>> fruitDistribution((""2 apples and 3 oranges""), (100l))
    // (95l)
    // >>> fruitDistribution((""100 apples and 1 oranges""), (120l))
    // (19l)
    def fruitDistribution(s : String, n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fruitDistribution(s: String, n: Long): Long = {
    val fruits = s.split("" and "").map(_.split("" "")(0).toLong)
    val totalApplesAndOranges = fruits.sum
    n - totalApplesAndOranges
  }
}","    }
    def main(args: Array[String]) = {
    assert(fruitDistribution((""5 apples and 6 oranges""), (19l)) == (8l));
    assert(fruitDistribution((""5 apples and 6 oranges""), (21l)) == (10l));
    assert(fruitDistribution((""0 apples and 1 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""1 apples and 0 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (100l)) == (95l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (5l)) == (0l));
    assert(fruitDistribution((""1 apples and 100 oranges""), (120l)) == (19l));
    }

}
"
HumanEval_68,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad 1:     //Pokud nejsou žádné párné hodnoty nebo je daný seznam prázdný, vrátíme [].    //Vytržený uzel by měl být vrácen v seznamu [ smalest_value, jeho index ],     //Pokud se najde více uzlů se stejnou nejmenší párnou hodnotou, vrátí se uzel s nejmenším indexem.     //Vytržený uzel by měl být uzlem s nejmenší párnou hodnotou.    //Vaším úkolem je vytrhnout jeden z uzlů a vrátit ho.    //""Dal seznam představující větve stromu, který má non-negativní celé čísla uzlů     // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> pluck((List[Long]()))
    // (List[Long]())
    // Example 4:
    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    def pluck(arr : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def pluck(arr: List[Long]): List[Long] = {
    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }
    if (evenNodes.isEmpty) {
      List.empty[Long]
    } else {
      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }
      List(smallestValue, index.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long]())).equals((List[Long]())));
    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));
    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_69,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Pokud taková hodnota neexistuje, vrátí se -1.    //Frekvence celé čísla je počet jeho výstupů v seznamu.    //nula a má frekvenci větší nebo rovnou hodnotě samotného celého čísla.     //Je vám dán neprázdný seznam kladných celých čísel.    // >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))
    // (2l)
    // >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (3l)
    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (-1l)
    def search(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def search(lst: List[Long]): Long = {
    val frequencyMap = lst.groupBy(identity).mapValues(_.size)
    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {
      case x :: _ => x
      case Nil => -1L
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));
    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));
    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));
    assert(search((List[Long](1l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));
    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));
    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));
    assert(search((List[Long](10l.toLong))) == (-1l));
    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));
    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));
    }

}
"
HumanEval_70,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //pak maximální z zbývajících celých čísel, pak minimální a tak dále.    //Zvláštní třídění je, když začnete s minimální hodnotou,     //Pokud je nám daný seznam celých čísel, vrátíme seznam v podivném pořadí.    // >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))
    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))
    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))
    // >>> strangeSortList((List[Long]()))
    // (List[Long]())
    def strangeSortList(lst : List[Long]) : List[Long] = {
","def strangeSortList(lst: List[Long]): List[Long] = {
    val buffer = lst.sorted.toBuffer
    val result = ArrayBuffer[Long]()
    var takeMin = true

    while (buffer.nonEmpty) {
      if (takeMin) {
        result += buffer.remove(0) // take the minimum
      } else {
        result += buffer.remove(buffer.length - 1) // take the maximum of the remaining
      }
      takeMin = !takeMin
    }

    result.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long]())).equals((List[Long]())));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));
    }

}
"
HumanEval_71,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //než třetí strana.    //Tři strany tvoří platný trojúhelník , když je součet kterýchkoli dvou stran větší .    //V opačném případě se vrátí -1     //trojúhelník zaokrouhlený na 2 desetinná body, pokud tyto tři strany tvoří platný trojúhelník.     //Když máme délky všech stran trojúhelníku, vrátíme plochu     // >>> triangleArea((3l), (4l), (5l))
    // (6.0f)
    // >>> triangleArea((1l), (2l), (10l))
    // -1l
    def triangleArea(a : Long, b : Long, c : Long) : Float = {
","import scala.math._

object Problem {
  def triangleArea(a: Long, b: Long, c: Long): Float = {
    if (a + b > c && a + c > b && b + c > a) {
      val s = (a + b + c) / 2.0
      val area = sqrt(s * (s - a) * (s - b) * (s - c))
      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat
    } else {
      -1f
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((3l), (4l), (5l)) == (6.0f));
    assert(triangleArea((1l), (2l), (10l)) == -1l);
    assert(triangleArea((4l), (8l), (5l)) == (8.18f));
    assert(triangleArea((2l), (2l), (2l)) == (1.73f));
    assert(triangleArea((1l), (2l), (3l)) == -1l);
    assert(triangleArea((10l), (5l), (7l)) == (16.25f));
    assert(triangleArea((2l), (6l), (3l)) == -1l);
    assert(triangleArea((1l), (1l), (1l)) == (0.43f));
    assert(triangleArea((2l), (2l), (10l)) == -1l);
    }

}
"
HumanEval_72,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Objekt q bude létat, pokud je vyvážený (je to palindromový seznam) a součet jeho prvků je menší nebo rovný maximální možné hmotnosti w.    //Napište funkci, která vrátí hodnotu true, pokud objekt q bude létat, a hodnotu false v opačném případě.     // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> willItFly((List[Long](3l.toLong)), (5l))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    def willItFly(q : List[Long], w : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def willItFly(q: List[Long], w: Long): Boolean = {
    val isPalindromic = q == q.reverse
    val sumOfElements = q.sum
    isPalindromic && sumOfElements <= w
  }

  def main(args: Array[String]): Unit = {
    println(willItFly(List[Long](1L, 2L), 5L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 1L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 9L)) // true
    println(willItFly(List[Long](3L), 5L)) // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));
    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));
    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));
    }

}
"
HumanEval_73,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Je čitelná stejným způsobem vpřed i dozadu.    //Palindromový seznam je seznam, který     //Zde je seznam celých čísel, najděte minimální počet prvků, které     // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))
    // (4l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))
    // (1l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))
    // (0l)
    def smallestChange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a list arr of integers, find the minimum number of elements that
  // need to be changed to make the list palindromic.

  def smallestChange(arr: List[Long]): Long = {
    var changes: Long = 0

    for (i <- 0 until arr.length / 2) {
      if (arr(i) != arr(arr.length - 1 - i)) {
        changes += 1
      }
    }

    changes
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  // Output: 4
    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  // Output: 1
    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  // Output: 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));
    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));
    assert(smallestChange((List[Long](1l.toLong))) == (0l));
    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));
    }

}
"
HumanEval_74,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //Pokud mají oba seznamy stejný počet znaků, vrátí se první seznam.    //celkový počet znaků ve všech řadách seznamu menší než v druhém seznamu.     //Napíšejte funkci , která přijme dva seznamy řetězců a vrátí seznam , který má     // >>> totalMatch((List[String]()), (List[String]()))
    // (List[String]())
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi"")))
    // (List[String](""hI"", ""Hi""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project"")))
    // (List[String](""hi"", ""admin""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi"")))
    // (List[String](""hI"", ""hi"", ""hi""))
    // >>> totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5"")))
    // (List[String](""4""))
    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {
    val sum1 = lst1.map(_.length).sum
    val sum2 = lst2.map(_.length).sum
    if (sum1 <= sum2) lst1 else lst2
  }
}","    }
    def main(args: Array[String]) = {
    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi""))).equals((List[String](""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5""))).equals((List[String](""4""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi""))).equals((List[String](""hI"", ""Hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi""))).equals((List[String](""hI"", ""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hii""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String]()), (List[String](""this""))).equals((List[String]())));
    assert(totalMatch((List[String](""this"")), (List[String]())).equals((List[String]())));
    }

}
"
HumanEval_75,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Víme, že a je menší než 100.    //a jinak falešné.    //Napište funkci , která vrátí hodnotu true , pokud je dané číslo násobením tří prvočísel .    // >>> isMultiplyPrime((30l))
    // (true)
    // 30 = 2 * 3 * 5
    def isMultiplyPrime(a : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isMultiplyPrime(a: Long): Boolean = {
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num <= 3) return true
      if (num % 2 == 0 || num % 3 == 0) return false
      var i = 5
      while (i * i <= num) {
        if (num % i == 0 || num % (i + 2) == 0) return false
        i += 6
      }
      true
    }

    val primes = (2L to 100L).filter(isPrime)
    val primeList = primes.toList

    for {
      i <- primeList.indices
      j <- i until primeList.size
      k <- j until primeList.size
      if primeList(i) * primeList(j) * primeList(k) == a
    } return true

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isMultiplyPrime((5l)) == (false));
    assert(isMultiplyPrime((30l)) == (true));
    assert(isMultiplyPrime((8l)) == (true));
    assert(isMultiplyPrime((10l)) == (false));
    assert(isMultiplyPrime((125l)) == (true));
    assert(isMultiplyPrime((105l)) == (true));
    assert(isMultiplyPrime((126l)) == (false));
    assert(isMultiplyPrime((729l)) == (false));
    assert(isMultiplyPrime((891l)) == (false));
    assert(isMultiplyPrime((1001l)) == (true));
    }

}
"
HumanEval_76,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //x je jednoduchá mocnost n, pokud n**int=x     //v jiných případech.    //Vaším úkolem je napsat funkci, která vrátí true, pokud je číslo x prosté     // >>> isSimplePower((1l), (4l))
    // (true)
    // >>> isSimplePower((2l), (2l))
    // (true)
    // >>> isSimplePower((8l), (2l))
    // (true)
    // >>> isSimplePower((3l), (2l))
    // (false)
    // >>> isSimplePower((3l), (1l))
    // (false)
    // >>> isSimplePower((5l), (3l))
    // (false)
    def isSimplePower(x : Long, n : Long) : Boolean = {
","def isSimplePower(x: Long, n: Long): Boolean = {
        if (n == 1) {
            return x == 1
        }
        
        var value: Long = n
        while (value <= x) {
            if (value == x) {
                return true
            }
            
            if (value > Long.MaxValue / n) {
                return false
            }
            value *= n
        }
        
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(isSimplePower((16l), (2l)) == (true));
    assert(isSimplePower((143214l), (16l)) == (false));
    assert(isSimplePower((4l), (2l)) == (true));
    assert(isSimplePower((9l), (3l)) == (true));
    assert(isSimplePower((16l), (4l)) == (true));
    assert(isSimplePower((24l), (2l)) == (false));
    assert(isSimplePower((128l), (4l)) == (false));
    assert(isSimplePower((12l), (6l)) == (false));
    assert(isSimplePower((1l), (1l)) == (true));
    assert(isSimplePower((1l), (12l)) == (true));
    }

}
"
HumanEval_77,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Poznámka: můžete předpokládat, že vstup je vždy platný.    //Pokud je toto číslo kubem nějakého celého čísla.    //Napište funkci , která bere celé číslo a a vrátí hodnotu true .    // >>> iscube((1l))
    // (true)
    // >>> iscube((2l))
    // (false)
    // >>> iscube((-1l))
    // (true)
    // >>> iscube((64l))
    // (true)
    // >>> iscube((0l))
    // (true)
    // >>> iscube((180l))
    // (false)
    def iscube(a : Long) : Boolean = {
","def iscube(a: Long): Boolean = {
  val cubeRoot = math.cbrt(a.toDouble).round
  cubeRoot * cubeRoot * cubeRoot == a
}","    }
    def main(args: Array[String]) = {
    assert(iscube((1l)) == (true));
    assert(iscube((2l)) == (false));
    assert(iscube((-1l)) == (true));
    assert(iscube((64l)) == (true));
    assert(iscube((180l)) == (false));
    assert(iscube((1000l)) == (true));
    assert(iscube((0l)) == (true));
    assert(iscube((1729l)) == (false));
    }

}
"
HumanEval_78,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //a symboly A,B,C,D,E,F jsou vždy velkými písmeny.    //Poznámka: můžete předpokládat, že vstup je vždy správný nebo prázdný řetězec,     //B (= desítka 11), D (= desítka 13).     //Takže musíte určit některé z následujících číslic: 2, 3, 5, 7,     //Prvotní čísla jsou 2, 3, 5, 7, 11, 13, 17,...    //Šestadcenná čísla jsou 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.    //větší než 1, která není součtem dvou menších přirozených čísel).    //číslice, které jsou prvočísla (prvotní číslo, nebo prvočíslo, je přirozené číslo     //Šedesátkové číslo jako řetězec a počítá počet desátkových čísel     //Máte za úkol napsat funkci, která přijímá     // >>> hexKey((""AB""))
    // (1l)
    // >>> hexKey((""1077E""))
    // (2l)
    // >>> hexKey((""ABED1A33""))
    // (4l)
    // >>> hexKey((""123456789ABCDEF0""))
    // (6l)
    // >>> hexKey((""2020""))
    // (2l)
    def hexKey(num : String) : Long = {
","def hexKey(num: String): Long = {
  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')
  num.count(ch => primeHexDigits.contains(ch)).toLong
}","    }
    def main(args: Array[String]) = {
    assert(hexKey((""AB"")) == (1l));
    assert(hexKey((""1077E"")) == (2l));
    assert(hexKey((""ABED1A33"")) == (4l));
    assert(hexKey((""2020"")) == (2l));
    assert(hexKey((""123456789ABCDEF0"")) == (6l));
    assert(hexKey((""112233445566778899AABBCCDDEEFF00"")) == (12l));
    }

}
"
HumanEval_79,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Další znaky jsou tam, aby pomohly s formátem.    //Na začátku a na konci řetězce bude přidaná dvojice znaků 'db'.     //Každý znak v řetězci bude ""0"" nebo ""1"".    //Funkce by měla vrátit řetězec, přičemž každý znak by měl reprezentovat binární     //Dostanete číslo v desetinném čísle a vaším úkolem je převést ho na     // >>> decimalToBinary((15l))
    // (""db1111db"")
    // >>> decimalToBinary((32l))
    // (""db100000db"")
    def decimalToBinary(decimal : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def decimalToBinary(decimal: Long): String = {
    ""db"" + decimal.toBinaryString + ""db""
  }
}","    }
    def main(args: Array[String]) = {
    assert(decimalToBinary((0l)).equals((""db0db"")));
    assert(decimalToBinary((32l)).equals((""db100000db"")));
    assert(decimalToBinary((103l)).equals((""db1100111db"")));
    assert(decimalToBinary((15l)).equals((""db1111db"")));
    }

}
"
HumanEval_80,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Řetěz je hapskala , pokud má délku nejméně 3 a každé 3 po sobě jdoucí písmena jsou odlišná .    //Vaším úkolem je zkontrolovat, zda je řetězec hapskala nebo ne.    //Máte řetězec s.    // >>> isHappy((""a""))
    // (false)
    // >>> isHappy((""aa""))
    // (false)
    // >>> isHappy((""abcd""))
    // (true)
    // >>> isHappy((""aabb""))
    // (false)
    // >>> isHappy((""adb""))
    // (true)
    // >>> isHappy((""xyy""))
    // (false)
    def isHappy(s : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isHappy(s: String): Boolean = {
    if (s.length < 3) return false 

    for (i <- 0 until s.length - 2) {
      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {
        return false
      }
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isHappy((""a"")) == (false));
    assert(isHappy((""aa"")) == (false));
    assert(isHappy((""abcd"")) == (true));
    assert(isHappy((""aabb"")) == (false));
    assert(isHappy((""adb"")) == (true));
    assert(isHappy((""xyy"")) == (false));
    assert(isHappy((""iopaxpoi"")) == (true));
    assert(isHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //0,0 E     //> 0, 0 D-     //> 0,7 D     //> 1,0 D+     //> 1,3 C-     //> 1,7 °C     //> 2,0 C+     //> 2,3 B-     //> 2,7 B     //> 3,0 B+     //> 3.3 A-     //> 3,7 A     //4,0 A+     //GPA. Číslo.    //funkce, která může vypustit seznam tříd písmen pomocí následující tabulky:     //Dala ti seznam průměrů některých studentů a ty musíš napsat .    //Jediný problém je, že ztratila kód, který používala k hodnocení.    //Učitel si vytvořil vlastní algoritmus pro hodnocení.    //Je poslední týden semestru a učitelka musí dát známky .    // >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))
    // (List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))
    def numericalLetterGrade(grades : List[Float]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def numericalLetterGrade(grades: List[Float]): List[String] = {
    grades.map { gpa =>
      gpa match {
        case g if g == 4.0 => ""A+""
        case g if g > 3.7 => ""A""
        case g if g > 3.3 => ""A-""
        case g if g > 3.0 => ""B+""
        case g if g > 2.7 => ""B""
        case g if g > 2.3 => ""B-""
        case g if g > 2.0 => ""C+""
        case g if g > 1.7 => ""C""
        case g if g > 1.3 => ""C-""
        case g if g > 1.0 => ""D+""
        case g if g > 0.7 => ""D""
        case g if g > 0.0 => ""D-""
        case _ => ""E""
      }
    }
  }

  def main(args: Array[String]): Unit = {
    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)
    println(numericalLetterGrade(grades)) // Output: List(A+, B, C-, C, A-)
  }
}","    }
    def main(args: Array[String]) = {
    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))));
    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](""D+""))));
    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](""D-""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](""E""))));
    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](""D"", ""D-"", ""C-"", ""B"", ""B+""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](""E"", ""D-""))));
    }

}
"
HumanEval_82,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //length je prvočíslo nebo jinak falešné     //Napište funkci , která vezme řetězec a vrátí hodnotu true , pokud řetězec     // >>> primeLength((""Hello""))
    // (true)
    // >>> primeLength((""abcdcba""))
    // (true)
    // >>> primeLength((""kittens""))
    // (true)
    // >>> primeLength((""orange""))
    // (false)
    def primeLength(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeLength(string: String): Boolean = {
    val length = string.length

    if (length <= 1) return false
    
    for (i <- 2 to sqrt(length).toInt) {
      if (length % i == 0) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeLength((""Hello"")) == (true));
    assert(primeLength((""abcdcba"")) == (true));
    assert(primeLength((""kittens"")) == (true));
    assert(primeLength((""orange"")) == (false));
    assert(primeLength((""wow"")) == (true));
    assert(primeLength((""world"")) == (true));
    assert(primeLength((""MadaM"")) == (true));
    assert(primeLength((""Wow"")) == (true));
    assert(primeLength(("""")) == (false));
    assert(primeLength((""HI"")) == (true));
    assert(primeLength((""go"")) == (true));
    assert(primeLength((""gogo"")) == (false));
    assert(primeLength((""aaaaaaaaaaaaaaa"")) == (false));
    assert(primeLength((""Madam"")) == (true));
    assert(primeLength((""M"")) == (false));
    assert(primeLength((""0"")) == (false));
    }

}
"
HumanEval_83,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //pozitivní celé čísla, které začínají nebo končí číslem 1.    //Za předpokladu, že je kladné celé číslo n, vraťte počet čísel s číslicemi n.    def startsOneEnds(n : Long) : Long = {
","def startsOneEnds(n: Long): Long = {
        if (n <= 0) return 0
        
        // Calculate numbers starting with 1: 1XX...X (n-1) digits after 1
        val startWithOne: Long = math.pow(10, n - 1).toLong
        
        // Calculate numbers ending with 1: XX...X1 (n-1) digits before 1
        // but without leading zeroes allowed, i.e., the first digit can't be zero
        val endWithOne: Long = math.pow(10, n - 1).toLong
        
        // Reverse counting: numbers starting and ending with 1 (11XX...X)
        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0
        
        // The total numbers starting or ending, or both, with 1
        startWithOne + endWithOne - bothStartAndEndWithOne
    }
}","    }
    def main(args: Array[String]) = {
    assert(startsOneEnds((1l)) == (1l));
    assert(startsOneEnds((2l)) == (18l));
    assert(startsOneEnds((3l)) == (180l));
    assert(startsOneEnds((4l)) == (1800l));
    assert(startsOneEnds((5l)) == (18000l));
    }

}
"
HumanEval_84,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad     //Za předpokladu, že je kladné celé číslo N, vraťte součet jeho číslic v binárním číslice.     // >>> solve((1000l))
    // (""1"")
    // >>> solve((150l))
    // (""110"")
    // >>> solve((147l))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    def solve(N : Long) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Given a positive integer N, return the total sum of its digits in binary.
    def solve(N: Long): String = {
        val sumOfDigits = N.toString.map(_.asDigit).sum
        sumOfDigits.toBinaryString
    }

    def main(args: Array[String]): Unit = {
        println(solve(1000L))  // should print ""1""
        println(solve(150L))   // should print ""110""
        println(solve(147L))   // should print ""1100""
    }
}","    }
    def main(args: Array[String]) = {
    assert(solve((1000l)).equals((""1"")));
    assert(solve((150l)).equals((""110"")));
    assert(solve((147l)).equals((""1100"")));
    assert(solve((333l)).equals((""1001"")));
    assert(solve((963l)).equals((""10010"")));
    }

}
"
HumanEval_85,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Když máme neprázdný seznam celých čísel, nejprve přičteme párné prvky, které jsou v nepárném číselném řádku.    // >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))
    // (2l)
    def add(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a non-empty list of integers lst. add the even elements that are at odd indices.
  def add(lst: List[Long]): Long = {
    lst.zipWithIndex.collect {
      case (value, index) if index % 2 == 1 && value % 2 == 0 => value
    }.sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));
    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));
    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));
    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));
    }

}
"
HumanEval_86,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Poznámka: Udržujte pořadí slov a prázdných míst ve větě.    //vzestupný pořadí podle hodnoty ASCII.    //jsou nahrazeny novým slovem, kde jsou všechny znaky uspořádané v    //Pořadová verze řetězce, je řetěz, kde všechna slova (oddělená mezerou)     //Napište funkci, která bere řetězec a vrátí jeho uspořádanou verzi.    // >>> antiShuffle((""Hi""))
    // (""Hi"")
    // >>> antiShuffle((""hello""))
    // (""ehllo"")
    // >>> antiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    def antiShuffle(s : String) : String = {
","import scala.collection.mutable.ArrayBuffer

object Problem {
  def antiShuffle(s: String): String = {
    val words = s.split(""(?<=\\s)"")
    val sortedWords = words.map(word => {
      val trimmedWord = word.trim
      val sortedChars = trimmedWord.sorted
      word.replace(trimmedWord, sortedChars)
    })
    sortedWords.mkString("""")
  }

  def main(args: Array[String]): Unit = {
    println(antiShuffle(""Hi""))
    println(antiShuffle(""hello""))
    println(antiShuffle(""Hello World!!!""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(antiShuffle((""Hi"")).equals((""Hi"")));
    assert(antiShuffle((""hello"")).equals((""ehllo"")));
    assert(antiShuffle((""number"")).equals((""bemnru"")));
    assert(antiShuffle((""abcd"")).equals((""abcd"")));
    assert(antiShuffle((""Hello World!!!"")).equals((""Hello !!!Wdlor"")));
    assert(antiShuffle(("""")).equals(("""")));
    assert(antiShuffle((""Hi. My name is Mister Robot. How are you?"")).equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Také seřaďte souřadnice řádku podle sloupců v sestupném pořadí.    //Koordináty se nejprve třídí podle řádků ve vzestupném pořadí.    //Každá tuple je souřadnice - (řídka, sloupce), začínající na 0.    //a vrátí seznam tuplí, [(x1, y1), (x2, y2) ...] tak, že     //Pokud je uvedeno lst a celé číslo x, najděte celé čísla x v seznamu,     //každý řádek může obsahovat jiný počet sloupců.     //který je podobný matrici, nicméně, na rozdíl od matic,    //Dostáváte 2 dimenzní data, jako vnořené seznamy,     // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))
    // (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))
    // >>> getRow((List[List[Long]]()), (1l))
    // (List[Tuple2[Long, Long]]())
    // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))
    // (List[Tuple2[Long, Long]]((2l, 2l)))
    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {
    val coordinates = for {
      (row, rowIndex) <- lst.zipWithIndex
      (value, colIndex) <- row.zipWithIndex
      if value == x
    } yield (rowIndex.toLong, colIndex.toLong)

    coordinates
      .groupBy(_._1)
      .toList
      .sortBy(_._1)
      .flatMap { case (rowIndex, coords) =>
        coords.sortBy(-_._2)
      }
  }
}","    }
    def main(args: Array[String]) = {
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));
    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));
    }

}
"
HumanEval_88,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //* nezměň daný seznam.     //Poznámka:     //nebo jej zortujte v sestupném pořadí, pokud je součet (první hodnota indexu, poslední hodnota indexu) párný.     //Pokud je součet (první hodnota indexu, poslední hodnota indexu) nepředmětný, zortujete daný seznam ve vzestupném pořadí,     //Za předpokladu, že je seznam ne-záporných celých čísel, po třídění vraťte koskalu daného seznamu,     // >>> sortArray((List[Long]()))
    // (List[Long]())
    // >>> sortArray((List[Long](5l.toLong)))
    // (List[Long](5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))
    def sortArray(array : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def sortArray(array: List[Long]): List[Long] = {
    if (array.isEmpty) {
      array
    } else {
      val first = array.head
      val last = array.last
      val sum = first + last
      if (sum % 2 == 0) {
        array.sorted(Ordering[Long].reverse)
      } else {
        array.sorted
      }
    }
  }

  def main(args: Array[String]): Unit = {
    println(sortArray(List[Long]())) // (List[Long]())
    println(sortArray(List[Long](5L))) // (List[Long](5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) // (List[Long](0L, 1L, 2L, 3L, 4L, 5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) // (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));
    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));
    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));
    }

}
"
HumanEval_89,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //posun dolů o dvě násobené na dvě místa.    //Alfabet by měl být otočen takovým způsobem, aby písmenka     //vrátí řetězec šifrovaný s otočením abecedy.     //Vytvořit funkci šifrování , která bere řetězec jako argument a     // >>> encrypt((""hi""))
    // (""lm"")
    // >>> encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> encrypt((""gf""))
    // (""kj"")
    // >>> encrypt((""et""))
    // (""ix"")
    def encrypt(s : String) : String = {
","def encrypt(s: String): String = {
  s.map(c => {
    val rotatedChar = (c - 'a' + 4) % 26 + 'a'
    rotatedChar.toChar
  })
}","    }
    def main(args: Array[String]) = {
    assert(encrypt((""hi"")).equals((""lm"")));
    assert(encrypt((""asdfghjkl"")).equals((""ewhjklnop"")));
    assert(encrypt((""gf"")).equals((""kj"")));
    assert(encrypt((""et"")).equals((""ix"")));
    assert(encrypt((""faewfawefaewg"")).equals((""jeiajeaijeiak"")));
    assert(encrypt((""hellomyfriend"")).equals((""lippsqcjvmirh"")));
    assert(encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    assert(encrypt((""a"")).equals((""e"")));
    }

}
"
HumanEval_90,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Vrátí se None, pokud takový prvek neexistuje.     //Napište funkci next_smallest (next_smallest) která vrátí druhý nejmenší prvek seznamu.    //Dostanete seznam celých čísel.    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long]()))
    // None
    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))
    // None
    def nextSmallest(lst : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def nextSmallest(lst: List[Long]): Option[Long] = {
    if (lst.size < 2) return None

    val distinctSorted = lst.distinct.sorted
    if (distinctSorted.size < 2) None
    else Some(distinctSorted(1))
  }
}","    }
    def main(args: Array[String]) = {
    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long]())).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));
    }

}
"
HumanEval_91,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Věty se oddělují od """", ""?"" nebo ""!""     //Nuda je věta, která začíná slovem ""já"".    //Dostanete řadu slov a vaším úkolem je počítat jejich číslo.    // >>> isBored((""Hello world""))
    // (0l)
    // >>> isBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1l)
    def isBored(S : String) : Long = {
","def isBored(S: String): Long = {
    // Split the input string into sentences using '.', '?' or '!' as delimiters
    val sentences = S.split(""[.!?]"").map(_.trim)

    // Filter sentences that start with 'I' and count them
    sentences.count(sentence => sentence.startsWith(""I""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(isBored((""Hello world"")) == (0l));
    assert(isBored((""Is the sky blue?"")) == (0l));
    assert(isBored((""I love It !"")) == (1l));
    assert(isBored((""bIt"")) == (0l));
    assert(isBored((""I feel good today. I will be productive. will kill It"")) == (2l));
    assert(isBored((""You and I are going for a walk"")) == (0l));
    }

}
"
HumanEval_92,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //V ostatních případech se vrátí false.     //Vrací hodnotu true, pokud je jedno z čísel rovno součtu ostatních dvou a všechna čísla jsou celá čísla.    //Vytvořte funkci, která bere 3 čísla.    // >>> anyInt(5l, 2l, 7l)
    // (true)
    // >>> anyInt(3l, 2l, 2l)
    // (false)
    // >>> anyInt(3l, -2l, 1l)
    // (true)
    // >>> anyInt((3.6f), (-2.2f), 2l)
    // (false)
    def anyInt(x : Float, y : Float, z : Float) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Create a function that takes 3 numbers.
  // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
  // Returns false in any other cases.
  def anyInt(x: Float, y: Float, z: Float): Boolean = {
    val xLong = x.toLong
    val yLong = y.toLong
    val zLong = z.toLong

    // Check if all inputs are actually integers
    if (xLong == x && yLong == y && zLong == z) {
      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong
    }
    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(anyInt(2l, 3l, 1l) == (true));
    assert(anyInt((2.5f), 2l, 3l) == (false));
    assert(anyInt((1.5f), 5l, (3.5f)) == (false));
    assert(anyInt(2l, 6l, 2l) == (false));
    assert(anyInt(4l, 2l, 2l) == (true));
    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));
    assert(anyInt(-4l, 6l, 2l) == (true));
    assert(anyInt(2l, 1l, 1l) == (true));
    assert(anyInt(3l, 4l, 7l) == (true));
    assert(anyInt((3.0f), 4l, 7l) == (false));
    }

}
"
HumanEval_93,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Předpokládejme, že jsou to jen písmenka.    //Slovačka v angličtině.    //Zpráva s písmenem , které se objevuje 2 místa před tím .    //Takto, že zamění případ všech písmen, nahradí všechny samohlásky v     //Napište funkci, která přijme zprávu a zakóduje ji do takového     // >>> encode((""test""))
    // (""TGST"")
    // >>> encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    def encode(message : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def encode(message: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    val vowelMap = Map(
      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',
      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'
    )
    
    message.map { char =>
      if (vowels.contains(char)) {
        vowelMap(char)
      } else if (char.isLetter) {
        if (char.isLower) char.toUpper else char.toLower
      } else {
        char
      }
    }.mkString
  }

  // Test cases
  def main(args: Array[String]): Unit = {
    println(encode(""test""))            // should print ""TGST""
    println(encode(""This is a message"")) // should print ""tHKS KS C MGSSCGG""
  }
}","    }
    def main(args: Array[String]) = {
    assert(encode((""TEST"")).equals((""tgst"")));
    assert(encode((""Mudasir"")).equals((""mWDCSKR"")));
    assert(encode((""YES"")).equals((""ygs"")));
    assert(encode((""This is a message"")).equals((""tHKS KS C MGSSCGG"")));
    assert(encode((""I DoNt KnOw WhAt tO WrItE"")).equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Musíte najít největší prvočíselnou hodnotu a vrátit součet jejích číslic.    //Dostanete seznam celých čísel.    // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))
    // (10l)
    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))
    // (25l)
    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))
    // (13l)
    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))
    // (11l)
    // >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))
    // (3l)
    // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))
    // (7l)
    def skjkasdkd(lst : List[Long]) : Long = {
","def skjkasdkd(lst: List[Long]): Long = {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) false
    else if (n == 2) true
    else if (n % 2 == 0) false
    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)
  }

  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum

  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)
  sumOfDigits(largestPrime)
}","    }
    def main(args: Array[String]) = {
    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));
    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));
    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));
    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));
    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));
    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));
    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));
    }

}
"
HumanEval_95,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Funkce by měla vrátit hodnotu false, je-li daná mapa prázdná.    //případ nebo všechny klíče jsou řetězce v velkém písmenu, jinak vrátí false.     //Pokud je mapována, vrátí true, pokud jsou všechny klíče řetězce v nižší     // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""b"" -> ""banana"")))
    // (true)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""A"" -> ""banana"", ""B"" -> ""banana"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", 8l -> ""banana"", ""a"" -> ""apple"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345"")))
    // (true)
    def checkDictCase(dict : Map[String,String]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def checkDictCase(dict: Map[String, String]): Boolean = {
    if (dict.isEmpty) return false

    val keys = dict.keys.toList
    val allLowerCase = keys.forall(key => key == key.toLowerCase)
    val allUpperCase = keys.forall(key => key == key.toUpperCase)

    allLowerCase || allUpperCase
  }
}","    }
    def main(args: Array[String]) = {
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""b"" -> ""banana""))) == (true));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""A"" -> ""banana"", ""B"" -> ""banana""))) == (false));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""5"" -> ""banana"", ""a"" -> ""apple""))) == (false));
    assert(checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston""))) == (false));
    assert(checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345""))) == (true));
    assert(checkDictCase((Map[String,String](""fruit"" -> ""Orange"", ""taste"" -> ""Sweet""))) == (true));
    assert(checkDictCase((Map[String,String]())) == (false));
    }

}
"
HumanEval_96,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //například:     //Celá čísla, která jsou prvočísla menší než n.    //Implementovat funkci, která bere nepříporné celé číslo a vrátí seznam prvních n     // >>> countUpTo((5l))
    // (List[Long](2l.toLong, 3l.toLong))
    // >>> countUpTo((11l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))
    // >>> countUpTo((0l))
    // (List[Long]())
    // >>> countUpTo((20l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))
    // >>> countUpTo((1l))
    // (List[Long]())
    // >>> countUpTo((18l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))
    def countUpTo(n : Long) : List[Long] = {
","def countUpTo(n: Long): List[Long] = {
    def isPrime(num: Long): Boolean = {
      if (num < 2) return false
      for (i <- 2L to math.sqrt(num).toLong) {
        if (num % i == 0) return false
      }
      true
    }

    (2L until n).filter(isPrime).map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));
    assert(countUpTo((0l)).equals((List[Long]())));
    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));
    assert(countUpTo((1l)).equals((List[Long]())));
    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));
    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));
    }

}
"
HumanEval_97,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Předpokládejme, že vstup je vždy platný.    //součin jejich jednotkových číslic.     //Vyplňte funkci, která bere dvě celé čísla a vrátí     // >>> multiply((148l), (412l))
    // (16l)
    // >>> multiply((19l), (28l))
    // (72l)
    // >>> multiply((2020l), (1851l))
    // (0l)
    // >>> multiply((14l), (-15l))
    // (20l)
    def multiply(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def multiply(a: Long, b: Long): Long = {
        val unitDigitA = abs(a % 10)
        val unitDigitB = abs(b % 10)
        unitDigitA * unitDigitB
    }

    def main(args: Array[String]): Unit = {
        println(multiply(148l, 412l))  // 16l
        println(multiply(19l, 28l))    // 72l
        println(multiply(2020l, 1851l)) // 0l
        println(multiply(14l, -15l))   // 20l
    }
}","    }
    def main(args: Array[String]) = {
    assert(multiply((148l), (412l)) == (16l));
    assert(multiply((19l), (28l)) == (72l));
    assert(multiply((2020l), (1851l)) == (0l));
    assert(multiply((14l), (-15l)) == (20l));
    assert(multiply((76l), (67l)) == (42l));
    assert(multiply((17l), (27l)) == (49l));
    assert(multiply((0l), (1l)) == (0l));
    assert(multiply((0l), (0l)) == (0l));
    }

}
"
HumanEval_98,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Pokud je řetězec s, spočítejte počet velkých samohlásk v párných číselných řádcích.    // >>> countUpper((""aBCdEf""))
    // (1l)
    // >>> countUpper((""abcdefg""))
    // (0l)
    // >>> countUpper((""dBBE""))
    // (0l)
    def countUpper(s : String) : Long = {
","def countUpper(s: String): Long = {
  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')
  s.zipWithIndex.collect {
    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch
  }.size.toLong
}","    }
    def main(args: Array[String]) = {
    assert(countUpper((""aBCdEf"")) == (1l));
    assert(countUpper((""abcdefg"")) == (0l));
    assert(countUpper((""dBBE"")) == (0l));
    assert(countUpper((""B"")) == (0l));
    assert(countUpper((""U"")) == (1l));
    assert(countUpper(("""")) == (0l));
    assert(countUpper((""EEEE"")) == (2l));
    }

}
"
HumanEval_99,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //od dvou celých čísel, zaokrouhlíme od nuly.    //a vrátí nejbližší celé číslo.    //Vytvořit funkci , která bere hodnotu (strun) reprezentující číslo     // >>> closestInteger((""10""))
    // (10l)
    // >>> closestInteger((""15.3""))
    // (15l)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    def closestInteger(value : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def closestInteger(value: String): Long = {
    val num = value.toDouble
    val lower = floor(num).toLong
    val upper = ceil(num).toLong
    
    if (abs(num - lower) == abs(num - upper)) {
      if (num > 0) upper else lower
    } else {
      round(num)
    }
  }

  def main(args: Array[String]): Unit = {
    println(closestInteger(""10""))  // 10
    println(closestInteger(""15.3"")) // 15
    println(closestInteger(""14.5"")) // 15
    println(closestInteger(""-14.5"")) // -15
  }
}","    }
    def main(args: Array[String]) = {
    assert(closestInteger((""10"")) == (10l));
    assert(closestInteger((""14.5"")) == (15l));
    assert(closestInteger((""-15.5"")) == (-16l));
    assert(closestInteger((""15.3"")) == (15l));
    assert(closestInteger((""0"")) == (0l));
    }

}
"
HumanEval_100,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //i představuje počet kamenů v úrovni (i+1).     //Vrací počet kamenů v každém stupni v seznamu, kde je index     //- další párné číslo, pokud je n párné.     //- další liché číslo, pokud je n liché.     //Počet kamenů v příštím patře je:    //První úroveň má n kamenů.    //Pokud je kladné celé číslo n, musíte udělat hromadu n úrovní kamenů.    // >>> makeAPile((3l))
    // (List[Long](3l.toLong, 5l.toLong, 7l.toLong))
    def makeAPile(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
    def makeAPile(n: Long): List[Long] = {
        val pile = ListBuffer[Long]()
        var currentStones = n
        for (_ <- 0 until n.toInt) {
            pile += currentStones
            currentStones += (if (currentStones % 2 == 0) 2 else 2)
        }
        pile.toList
    }

    def main(args: Array[String]): Unit = {
        val result = makeAPile(3L)
        println(result)
    }
}","    }
    def main(args: Array[String]) = {
    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));
    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));
    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));
    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));
    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));
    }

}
"
HumanEval_101,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //rozložit řetězec na slova a vrátit seznam slov.    //Budete mít řetězec slov oddělených čárkami nebo mezerami.    // >>> wordsString((""Hi, my name is John""))
    // (List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))
    // >>> wordsString((""One, two, three, four, five, six""))
    // (List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))
    def wordsString(s : String) : List[String] = {
","def wordsString(s: String): List[String] = {
    s.split(""[, ]+"").toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(wordsString((""Hi, my name is John"")).equals((List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))));
    assert(wordsString((""One, two, three, four, five, six"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString((""Hi, my name"")).equals((List[String](""Hi"", ""my"", ""name""))));
    assert(wordsString((""One,, two, three, four, five, six,"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString(("""")).equals((List[String]())));
    assert(wordsString((""ahmed     , gamal"")).equals((List[String](""ahmed"", ""gamal""))));
    }

}
"
HumanEval_102,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Pokud takové číslo neexistuje, funkce by měla vrátit -1.    //Největší párné celé číslo v rozmezí [x, y] včetně.    //Tato funkce bere dvě kladná čísla x a y a vrátí     // >>> chooseNum((12l), (15l))
    // (14l)
    // >>> chooseNum((13l), (12l))
    // (-1l)
    def chooseNum(x : Long, y : Long) : Long = {
","def chooseNum(x: Long, y: Long): Long = {
    // Ensure x is the lesser value and y is the greater value
    val (start, end) = if (x > y) (y, x) else (x, y)
    
    // Start from the end of the range and search backwards for an even number
    for (i <- end to start by -1 if i % 2 == 0) {
      return i
    }
    
    // If no even number is found, return -1
    -1
  }
}","    }
    def main(args: Array[String]) = {
    assert(chooseNum((12l), (15l)) == (14l));
    assert(chooseNum((13l), (12l)) == (-1l));
    assert(chooseNum((33l), (12354l)) == (12354l));
    assert(chooseNum((5234l), (5233l)) == (-1l));
    assert(chooseNum((6l), (29l)) == (28l));
    assert(chooseNum((27l), (10l)) == (-1l));
    assert(chooseNum((7l), (7l)) == (-1l));
    assert(chooseNum((546l), (546l)) == (546l));
    }

}
"
HumanEval_103,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Pokud je n větší než m, vrátíme -1.    //Zaokrouhlte odpověď na nejbližší celé číslo a přečtěte ho na binární číslo.    //průměr celých čísel od n do m (včetně n a m).    //Máte dvě kladné celé čísla n a m a vaším úkolem je vypočítat     // >>> roundedAvg((1l), (5l))
    // ""0b11""
    // >>> roundedAvg((7l), (5l))
    // -1l
    // >>> roundedAvg((10l), (20l))
    // ""0b1111""
    // >>> roundedAvg((20l), (33l))
    // ""0b11010""
    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  // Function to compute the average of the integers from n through m
  def roundedAvg(n: Long, m: Long): Either[String, Long] = {
    if (n > m) {
      Right(-1L)
    } else {
      val count = m - n + 1
      val sum = (n + m) * count / 2
      val average = round(sum.toDouble / count)
      Left(""0b"" + average.toLong.toBinaryString)
    }
  }

  def main(args: Array[String]): Unit = {
    println(roundedAvg(1L, 5L))    // Left(""0b11"")
    println(roundedAvg(7L, 5L))    // Right(-1L)
    println(roundedAvg(10L, 20L))  // Left(""0b1111"")
    println(roundedAvg(20L, 33L))  // Left(""0b11010"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(roundedAvg((1l), (5l)).equals(""0b11""));
    assert(roundedAvg((7l), (13l)).equals(""0b1010""));
    assert(roundedAvg((964l), (977l)).equals(""0b1111001010""));
    assert(roundedAvg((996l), (997l)).equals(""0b1111100100""));
    assert(roundedAvg((560l), (851l)).equals(""0b1011000010""));
    assert(roundedAvg((185l), (546l)).equals(""0b101101110""));
    assert(roundedAvg((362l), (496l)).equals(""0b110101101""));
    assert(roundedAvg((350l), (902l)).equals(""0b1001110010""));
    assert(roundedAvg((197l), (233l)).equals(""0b11010111""));
    assert(roundedAvg((7l), (5l)).equals(-1l));
    assert(roundedAvg((5l), (1l)).equals(-1l));
    assert(roundedAvg((5l), (5l)).equals(""0b101""));
    }

}
"
HumanEval_104,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Poznámka: Vrátěný seznam by měl být tříděn v narůstajícím pořadí.    //prvky, které nemají párné číslice.    //Je-li uveden seznam kladných celých čísel x, vrátí se tříděný seznam všech     // >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))
    // (List[Long](1l.toLong, 15l.toLong, 33l.toLong))
    // >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))
    // (List[Long]())
    def uniqueDigits(x : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def uniqueDigits(x: List[Long]): List[Long] = {
    def hasEvenDigit(n: Long): Boolean = {
      n.toString.exists(c => (c - '0') % 2 == 0)
    }

    x.filterNot(hasEvenDigit).sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))
    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));
    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));
    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));
    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));
    }

}
"
HumanEval_105,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Jedna, dvě, tři, čtyři, pět, šest, sedm, osm, devět.    //výsledný seznam obrátit a pak nahradit každou číslici odpovídajícím názvem z     //Zde je seznam celých čísel, které jsou od 1 do 9 včetně.    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))
    // (List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))
    // If the list is empty, return an empty list:
    // >>> byLength((List[Long]()))
    // (List[String]())
    // If the list has any strange number ignore it:
    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))
    // (List[String](""One""))
    def byLength(arr : List[Long]) : List[String] = {
","import scala.collection.mutable._

object Problem {
  def byLength(arr: List[Long]): List[String] = {
    // Map of digit to its corresponding name
    val numToName = Map(
      1L -> ""One"",
      2L -> ""Two"",
      3L -> ""Three"",
      4L -> ""Four"",
      5L -> ""Five"",
      6L -> ""Six"",
      7L -> ""Seven"",
      8L -> ""Eight"",
      9L -> ""Nine""
    )

    // Filter numbers between 1 and 9
    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)
    // Map filtered and sorted numbers to their corresponding names
    filteredAndSorted.map(numToName)
  }
}","    }
    def main(args: Array[String]) = {
    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))));
    assert(byLength((List[Long]())).equals((List[String]())));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](""One""))));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](""Three"", ""Two"", ""One""))));
    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](""Nine"", ""Eight"", ""Four""))));
    }

}
"
HumanEval_106,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Faktoriál i je násobení čísel od 1 do i (1 * 2 * ... * i).    //Začínám od 1.    //nebo jinak součet čísel od 1 do i.     //a vrátí seznam velikosti n, tak, že hodnota prvku v indexu i je faktoriál i, pokud je i párná     //Implementujte funkci f, která bere n jako parametr,     // >>> f((5l))
    // (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))
    def f(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def f(n: Long): List[Long] = {
        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)
        
        (1L to n).map { i =>
            if (i % 2 == 0) factorial(i) else (1L to i).sum
        }.toList
    }
}","    }
    def main(args: Array[String]) = {
    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));
    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));
    assert(f((1l)).equals((List[Long](1l.toLong))));
    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));
    }

}
"
HumanEval_107,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad 1:     //celá čísla palindromu, která spadají do rozsahu ((1, n), včetně.     //Za předpokladu, že je kladné celé číslo n, vrátíme tupl, který má počet párných a nepárných     // >>> evenOddPalindrome((3l))
    // ((1l, 2l))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> evenOddPalindrome((12l))
    // ((4l, 6l))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {
","def evenOddPalindrome(n: Long): (Long, Long) = {
  def isPalindrome(x: Long): Boolean = {
    val str = x.toString
    str == str.reverse
  }

  var evenCount: Long = 0
  var oddCount: Long = 0

  for (i <- 1L to n) {
    if (isPalindrome(i)) {
      if (i % 2 == 0) evenCount += 1
      else oddCount += 1
    }
  }

  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));
    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));
    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));
    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));
    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));
    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));
    }

}
"
HumanEval_108,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například -123 má podpisy -1, 2 a 3.    //Pokud je číslo záporné, pak jeho první podepsaná číslice bude záporná:     //počet prvků, jejichž součet číslic je > 0.     //Napište funkci count_nums , která bere seznam celých čísel a vrátí     // >>> countNums((List[Long]()))
    // (0l)
    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))
    // (1l)
    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))
    // (3l)
    def countNums(arr : List[Long]) : Long = {
","def countNums(arr: List[Long]): Long = {
  arr.count(num => {
    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>
      if (char == '-') acc else acc + (char - '0')
    }
    sumOfDigits > 0
  }).toLong
}","    }
    def main(args: Array[String]) = {
    assert(countNums((List[Long]())) == (0l));
    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));
    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));
    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));
    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));
    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));
    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));
    assert(countNums((List[Long](1l.toLong))) == (1l));
    }

}
"
HumanEval_109,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Poznámka: Uvedený seznam má zaručeně jedinečné prvky.    //Pokud je uvedený seznam prázdný, vrátí hodnotu true.     //pak vrať true nebo false.    //Pokud je možné získat tříděný seznam provedením výše uvedené operace     //výchozí pozice v seznamu, tj. 0. index.     //Poslední prvek seznamu se přesune na     //Jedna operace posunu doprava znamená posun všech prvků seznamu o jeden     //Můžete provádět operaci přesunu doprava libovolný početkrát.    //následující operace v uvedeném seznamu:     //je možné získat seznam tříděný v nesnížujícím pořadí pomocí     //Vaše úkol je určit, zda     //Máme seznam 'arr' N celých čísel arr[1], arr[2], ..., arr[N].    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    def moveOneBall(arr : List[Long]) : Boolean = {
","def moveOneBall(arr: List[Long]): Boolean = {
  if (arr.isEmpty) return true

  // Find how many times the array needs to be shifted to become sorted
  val n = arr.length
  var shiftIndex = -1

  for (i <- 0 until n) {
    if (arr(i) > arr((i + 1) % n)) {
      // More than one place where the order breaks means it can't be sorted with a shift
      if (shiftIndex != -1) return false
      shiftIndex = i + 1
    }
  }

  // If no break in order was found, the array is already sorted
  if (shiftIndex == -1) return true

  // Check if shifting by the found index sorts the array
  for (i <- 1 until n) {
    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false
  }
  
  true
}","    }
    def main(args: Array[String]) = {
    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long]())) == (true));
    }

}
"
HumanEval_110,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //V opačném případě se vrátí ""NE"".     //Pokud jsou všechny prvky lst1 párné, vraťte ""YES"".    //Pokud je možné vyměnit prvky mezi prvky lst1 a lst2 , aby se    //Není omezen počet vyměňovaných prvků mezi prvky lst1 a lst2.     //A pak je to jen párová čísla.    //a určuje , zda je možné provést výměnu prvků     //V tomto problému budete implementovat funkci, která bere dva seznamy čísel,     // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (""YES"")
    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def exchange(lst1: List[Long], lst2: List[Long]): String = {
    // Check if all elements in lst1 are already even
    if (lst1.forall(_ % 2 == 0)) return ""YES""

    // Find if there's any even number in lst2 to exchange with lst1
    val lst2EvensExist = lst2.exists(_ % 2 == 0)

    // Check if there's also at least one odd in lst1 to swap it out
    val lst1OddsExist = lst1.exists(_ % 2 != 0)

    // Only possible if both an even element in lst2 and an odd element in lst1 exist
    if (lst2EvensExist && lst1OddsExist) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((""YES"")));
    }

}
"
HumanEval_111,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Pokud se několik písmen vyskytuje ve stejném čísle, vrátí se všechny.    //písmeno s nejvíce opakovanými čísly a s odpovídajícím počtem.     //Pokud je řetězec, který představuje malá písmena oddělená mezerami, vrátí mapu     // >>> histogram((""a b c""))
    // (Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l))
    // >>> histogram((""a b b a""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""a b c a b""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""b b b b a""))
    // (Map[String,Long](""b"" -> 4l))
    // >>> histogram((""""))
    // (Map[String,Long]())
    def histogram(test : String) : Map[String,Long] = {
","def histogram(test: String): Map[String, Long] = {
        val words = test.split("" "")
        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)

        if (frequencyMap.isEmpty) return Map.empty[String, Long]

        val maxCount = frequencyMap.values.max
        frequencyMap.filter { case (_, count) => count == maxCount }
    }
}","    }
    def main(args: Array[String]) = {
    assert(histogram((""a b b a"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c a b"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c d g"")).equals((Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l, ""d"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""b b b b a"")).equals((Map[String,Long](""b"" -> 4l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram(("""")).equals((Map[String,Long]())));
    assert(histogram((""a"")).equals((Map[String,Long](""a"" -> 1l))));
    }

}
"
HumanEval_112,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad     //Pro ověření byste měli vrátit tupl obsahující výsledný řetězec a true/false.     //Stránka se nazývá palindrom, pokud se čte stejným směrem dozadu jako dopředu.    //pak zkontrolujte, zda je výsledný řetězec palindrom.     //Máme dva řetězce s a c, musíte vymazat všechny znaky v s, které se rovnají jakémukoli znakovi v c.    //Úkol     // >>> reverseDelete((""abcde""), (""ae""))
    // ((""bcd"", false))
    // >>> reverseDelete((""abcdef""), (""b""))
    // ((""acdef"", false))
    // >>> reverseDelete((""abcdedcba""), (""ab""))
    // ((""cdedc"", true))
    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {
","def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {
    // Convert the characters to be deleted into a set for quick lookup
    val deleteSet = c.toSet
    
    // Filter out characters from s that are present in deleteSet
    val filteredString = s.filterNot(deleteSet.contains)
    
    // Check if the filtered string is a palindrome
    val isPalindrome = filteredString == filteredString.reverse
    
    // Return the tuple with the filtered string and the palindrome check result
    (filteredString, isPalindrome)
  }
}","    }
    def main(args: Array[String]) = {
    assert(reverseDelete((""abcde""), (""ae"")).equals(((""bcd"", false))));
    assert(reverseDelete((""abcdef""), (""b"")).equals(((""acdef"", false))));
    assert(reverseDelete((""abcdedcba""), (""ab"")).equals(((""cdedc"", true))));
    assert(reverseDelete((""dwik""), (""w"")).equals(((""dik"", false))));
    assert(reverseDelete((""a""), (""a"")).equals((("""", true))));
    assert(reverseDelete((""abcdedcba""), ("""")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""abcdedcba""), (""v"")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""vabba""), (""v"")).equals(((""abba"", true))));
    assert(reverseDelete((""mamma""), (""mia"")).equals((("""", true))));
    }

}
"
HumanEval_113,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Číselné číslo v i-tém řádku vstupního čísla.    //řetězec i vstupního kódu. "" kde všechna i by měla být nahrazena číslem     //Každý prvek i výstupu by měl být ""počtem nepárových prvků v     //Je-li uveden seznam řetězců, kde každý řetěz sestává pouze z číslic, vrátí seznam.    // >>> oddCount((List[String](""1234567"")))
    // (List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))
    // >>> oddCount((List[String](""3"", ""11111111"")))
    // (List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))
    def oddCount(lst : List[String]) : List[String] = {
","def oddCount(lst: List[String]): List[String] = {
    lst.map { str =>
      val oddCount = str.count(c => c.asDigit % 2 != 0)
      val replacedString = s""the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.""
      replacedString
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(oddCount(List(""1234567"")))  // List(""the number of odd elements 4n the str4ng 4 of the 4nput."")
    println(oddCount(List(""3"", ""11111111"")))  // List(""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput."")
  }
}","    }
    def main(args: Array[String]) = {
    assert(oddCount((List[String](""1234567""))).equals((List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))));
    assert(oddCount((List[String](""3"", ""11111111""))).equals((List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))));
    assert(oddCount((List[String](""271"", ""137"", ""314""))).equals((List[String](""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""))));
    }

}
"
HumanEval_114,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad     //Číselné číslo.    //Zde je seznam celých čísel, najděte minimální součet všech neprázdných podseznámků.    // >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))
    // (1l)
    // >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))
    // (-6l)
    def minSubArraySum(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minSubArraySum(nums: List[Long]): Long = {
    var minEndingHere = nums.head
    var minSoFar = nums.head
    
    for (i <- 1 until nums.length) {
      minEndingHere = min(nums(i), minEndingHere + nums(i))
      minSoFar = min(minSoFar, minEndingHere)
    }
    
    minSoFar
  }

  // Test Cases
  def main(args: Array[String]): Unit = {
    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) // Output: 1
    println(minSubArraySum(List(-1l, -2l, -3l))) // Output: -6
  }
}","    }
    def main(args: Array[String]) = {
    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));
    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));
    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));
    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));
    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));
    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));
    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));
    }

}
"
HumanEval_115,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad 1:     //Vyberte počet krát, které potřebujete k snížení kbelíků.    //Vaším úkolem je vyprázdnit studny pomocí kbelíků.    //a všechny nádrže mají stejnou kapacitu.    //Každá studna má odpovídající kbelík, který lze použít k extrakci vody z ní,     //a každá 1 v řadě představuje jednu jednotku vody.    //Každý řádek představuje jednu studnu.    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))
    // (6l)
    // Example 2:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))
    // (5l)
    // Example 3:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))
    // (0l)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {
","def maxFill(grid: List[List[Long]], capacity: Long): Long = {
  var totalWaterUnits = 0L

  for (row <- grid) {
    totalWaterUnits += row.sum
  }

  // Calculate the number of times you need to lower the buckets
  val bucketOperations = totalWaterUnits / capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)

  bucketOperations
}","    }
    def main(args: Array[String]) = {
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));
    }

}
"
HumanEval_116,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Musí být provedeno takto:    //Pro podobný počet jedniček se třídí na základě desetinných čísel.    //počet jedniček v binárním zobrazení v narůstajícím pořadí.     //V této kata musíte zorganizovat seznam ne-negativních celých čísel podle     // >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))
    // (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))
    // >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))
    def sortArray(arr : List[Long]) : List[Long] = {
","def sortArray(arr: List[Long]): List[Long] = {
        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));
    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));
    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    }

}
"
HumanEval_117,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Poznámka: můžete předpokládat, že vstupní řetězec obsahuje pouze písmena a mezery.    //Pokud je řetězec s prázdný, funkce by měla vrátit prázdný seznam.    //n souhlásky, v pořadí, v jakém se tato slova objevují v řetězci s.     //funkce, která vrátí seznam všech slov ze řetězce s, které obsahují přesně     //Za předpokladu, že je řetězec s a přirozené číslo n, máte za úkol implementovat     // >>> selectWords((""Mary had a little lamb""), (4l))
    // (List[String](""little""))
    // >>> selectWords((""Mary had a little lamb""), (3l))
    // (List[String](""Mary"", ""lamb""))
    // >>> selectWords((""simple white space""), (2l))
    // (List[String]())
    // >>> selectWords((""Hello world""), (4l))
    // (List[String](""world""))
    // >>> selectWords((""Uncle sam""), (3l))
    // (List[String](""Uncle""))
    def selectWords(s : String, n : Long) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def selectWords(s: String, n: Long): List[String] = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    def consonantCount(word: String): Int = {
      word.count(c => c.isLetter && !vowels.contains(c))
    }

    if (s.isEmpty) {
      List()
    } else {
      s.split(""\\s+"").filter(word => consonantCount(word) == n).toList
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(selectWords((""Mary had a little lamb""), (4l)).equals((List[String](""little""))));
    assert(selectWords((""Mary had a little lamb""), (3l)).equals((List[String](""Mary"", ""lamb""))));
    assert(selectWords((""simple white space""), (2l)).equals((List[String]())));
    assert(selectWords((""Hello world""), (4l)).equals((List[String](""world""))));
    assert(selectWords((""Uncle sam""), (3l)).equals((List[String](""Uncle""))));
    assert(selectWords((""""), (4l)).equals((List[String]())));
    assert(selectWords((""a b c d e f""), (1l)).equals((List[String](""b"", ""c"", ""d"", ""f""))));
    }

}
"
HumanEval_118,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Můžete předpokládat, že daný řetězec obsahuje pouze anglické písmeno.    //Zjisti, zda je v některé samohlásky splněna výše uvedená podmínka.    //Zpět prázdný řetězec, pokud jste to neudělali.    //dvě souhlásky z pravé strany slova (podle významové menšího a menšího písmene).     //Máte slovo, a vaším úkolem je najít nejbližší samohlásky, které jsou mezi nimi.    // >>> getClosestVowel((""yogurt""))
    // (""u"")
    // >>> getClosestVowel((""FULL""))
    // (""U"")
    // >>> getClosestVowel((""quick""))
    // ("""")
    // >>> getClosestVowel((""ab""))
    // ("""")
    def getClosestVowel(word : String) : String = {
","def getClosestVowel(word: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    for (i <- word.length - 2 until 0 by -1) {
      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {
        return word(i + 1).toString
      }
    }
    
    """"
  }
}","    }
    def main(args: Array[String]) = {
    assert(getClosestVowel((""yogurt"")).equals((""u"")));
    assert(getClosestVowel((""full"")).equals((""u"")));
    assert(getClosestVowel((""easy"")).equals(("""")));
    assert(getClosestVowel((""eAsy"")).equals(("""")));
    assert(getClosestVowel((""ali"")).equals(("""")));
    assert(getClosestVowel((""bad"")).equals((""a"")));
    assert(getClosestVowel((""most"")).equals((""o"")));
    assert(getClosestVowel((""ab"")).equals(("""")));
    assert(getClosestVowel((""ba"")).equals(("""")));
    assert(getClosestVowel((""quick"")).equals(("""")));
    assert(getClosestVowel((""anime"")).equals((""i"")));
    assert(getClosestVowel((""Asia"")).equals(("""")));
    assert(getClosestVowel((""Above"")).equals((""o"")));
    }

}
"
HumanEval_119,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Vraťte ""Ano"", pokud existuje způsob, jak vytvořit dobrý řetězec, a vraťte ""Ne"", pokud ne.    //""()) "" není.    //Například řetězec '(()))) je dobrý, zatímco řetězec     //Řetěz S je považován za dobrý, pokud a pouze pokud všechny závorky v S     //Nějaký řád, že výsledný řetězec bude dobrý.    //Vaším úkolem je zkontrolovat , zda je možné spojit tyto dvě řetězce .    //pouze závorky "" (("") nebo závorky "") "".    //Dostanete seznam dvou řetězců, oba řetězce obsahují otevřené     // >>> matchParens((List[String](""()("", "")"")))
    // (""Yes"")
    // >>> matchParens((List[String]("")"", "")"")))
    // (""No"")
    def matchParens(lst : List[String]) : String = {
","def matchParens(lst: List[String]): String = {
    def isBalanced(s: String): Boolean = {
      var balance = 0
      for (char <- s) {
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1
        if (balance < 0) return false
      }
      balance == 0
    }
    
    val combinations = List(
      lst(0) + lst(1),
      lst(1) + lst(0)
    )
    
    if (combinations.exists(isBalanced)) ""Yes"" else ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(matchParens((List[String](""()("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", "")""))).equals((""No"")));
    assert(matchParens((List[String](""(()(())"", ""())())""))).equals((""No"")));
    assert(matchParens((List[String]("")())"", ""(()()(""))).equals((""Yes"")));
    assert(matchParens((List[String](""(())))"", ""(()())((""))).equals((""Yes"")));
    assert(matchParens((List[String](""()"", ""())""))).equals((""No"")));
    assert(matchParens((List[String](""(()("", ""()))()""))).equals((""Yes"")));
    assert(matchParens((List[String](""(((("", ""((())""))).equals((""No"")));
    assert(matchParens((List[String]("")(()"", ""(()(""))).equals((""No"")));
    assert(matchParens((List[String]("")("", "")(""))).equals((""No"")));
    assert(matchParens((List[String](""("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", ""(""))).equals((""Yes"")));
    }

}
"
HumanEval_120,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad 1:     //délky k s maximálními k čísly v arr.     //Za předpokladu, že je zde seznam celých čísel arr a kladné celé číslo k, vrátíme tříděný seznam     // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))
    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))
    // Example 2:
    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))
    // (List[Long](4l.toLong, 4l.toLong))
    // Example 3:
    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))
    // (List[Long](2l.toLong))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    def maximum(arr : List[Long], k : Long) : List[Long] = {
","def maximum(arr: List[Long], k: Long): List[Long] = {
    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));
    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));
    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));
    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));
    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));
    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));
    }

}
"
HumanEval_121,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //Za předpokladu, že je seznam celých čísel neprázdný, vrátíme součet všech nepárových prvků, které jsou v párných polohách.    // >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))
    // (12l)
    // >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))
    // (9l)
    // >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))
    // (0l)
    def solution(lst : List[Long]) : Long = {
","def solution(lst: List[Long]): Long = {
  lst.zipWithIndex.collect {
    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num
  }.sum
}","    }
    def main(args: Array[String]) = {
    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));
    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));
    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));
    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));
    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));
    }

}
"
HumanEval_122,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //součet prvků, které mají nejvýše dvě číslice od prvních k prvků arr.     //Za předpokladu, že je zde neprázdný seznam celých čísel arr a celé číslo k, vrátíme     // >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))
    // (24l)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    def addElements(arr : List[Long], k : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def addElements(arr: List[Long], k: Long): Long = {
    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum
  }

  def main(args: Array[String]): Unit = {
    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)
    println(result) // Output will be 24L
  }
}","    }
    def main(args: Array[String]) = {
    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));
    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));
    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));
    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));
    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));
    }

}
"
HumanEval_123,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //get_odd_collatz(5) vrací [1, 5] # Kollatzova sekvence pro 5 je [5, 16, 8, 4, 2, 1], takže nepředmětné čísla jsou pouze 1 a 5.     //Například:     //2. vrácený seznam seřazen ve vzrůstajícím pořadí.    //1. Collatz(1) je [1].     //Poznámka:     //Předpoklad je, že bez ohledu na hodnotu n, bude pořadí vždy dosaženo 1.    //Pokud je předchozí člen liché číslo, pak je další člen 3 krát předchozí člen.    //předchozí člen následujícím způsobem: pokud je předchozí člen párný, je další člen polovina     //následující: začít s libovolným kladným celým číslem n. Pak se každý člen získá z     //Collatzova domněnka je domněnka v matematice , která se týká definované sekvence .    //Za předpokladu, že je kladné celé číslo n, vrátíme tříděný seznam, který obsahuje nepředstavitelná čísla v Collatzově pořadí.    // >>> getOddCollatz((5l))
    // (List[Long](1l.toLong, 5l.toLong))
    def getOddCollatz(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def getOddCollatz(n: Long): List[Long] = {
    val oddNumbers = ListBuffer[Long]()
    var number = n
    while (number != 1) {
      if (number % 2 == 1) {
        oddNumbers += number
      }
      number = if (number % 2 == 0) number / 2 else 3 * number + 1
    }
    oddNumbers += 1
    oddNumbers.sorted.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));
    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));
    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));
    }

}
"
HumanEval_124,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //4. Datum by mělo být ve formátu: mm-dd-rrrr     //3. Měsíce by neměly být menší než 1 a vyšší než 12.    //2. Počet dnů není menší než 1 nebo vyšší než 31 dnů pro měsíce 1,3,5,7,8,10,12. A počet dnů není menší než 1 nebo vyšší než 30 dnů pro měsíce 4,6,9,11. A počet dnů není menší než 1 nebo vyšší než 29 pro měsíc 2.    //1. Struně data není prázdná.    //Datum je platné, pokud jsou splněna všechna tato pravidla:     //vrátí hodnotu true, pokud je datum platné, jinak false.     //Musíte napsat funkci, která ověří daný řetězec dat a     // >>> validDate((""03-11-2000""))
    // (true)
    // >>> validDate((""15-01-2012""))
    // (false)
    // >>> validDate((""04-0-2040""))
    // (false)
    // >>> validDate((""06-04-2020""))
    // (true)
    // >>> validDate((""06/04/2020""))
    // (false)
    def validDate(date : String) : Boolean = {
","import scala.util.Try

object Problem {
  def validDate(date: String): Boolean = {
    if (date.isEmpty) return false
    
    val datePattern = """"""^(\d{2})-(\d{2})-(\d{4})$"""""".r

    date match {
      case datePattern(monthStr, dayStr, yearStr) => 
        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {
          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>
            month match {
              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31
              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30
              case 2 => day >= 1 && day <= 29
              case _ => false
            }
          case _ => false
        }
      case _ => false
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(validDate((""03-11-2000"")) == (true));
    assert(validDate((""15-01-2012"")) == (false));
    assert(validDate((""04-0-2040"")) == (false));
    assert(validDate((""06-04-2020"")) == (true));
    assert(validDate((""01-01-2007"")) == (true));
    assert(validDate((""03-32-2011"")) == (false));
    assert(validDate(("""")) == (false));
    assert(validDate((""04-31-3000"")) == (false));
    assert(validDate((""06-06-2005"")) == (true));
    assert(validDate((""21-31-2000"")) == (false));
    assert(validDate((""04-12-2003"")) == (true));
    assert(validDate((""04122003"")) == (false));
    assert(validDate((""20030412"")) == (false));
    assert(validDate((""2003-04"")) == (false));
    assert(validDate((""2003-04-12"")) == (false));
    assert(validDate((""04-2003"")) == (false));
    }

}
"
HumanEval_125,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //písmenka, řád a) = 0, řád b) = 1, ... řád z) = 25     //by se měla rozdělit na čárky ',' pokud žádné čárky neexistují, měl byste vrátit počet malých písmen v nepředmětném pořadí v     //Pokud je řetězec slov, vrátí seznam slov rozdělených na prázdné prostory, pokud v textu neexistují žádné prázdné prostory.    // >>> splitWords((""Hello world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""Hello,world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""abcdef""))
    // 3l
    def splitWords(txt : String) : Either[List[String], Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def splitWords(txt: String): Either[List[String], Long] = {
    if (txt.contains("" "")) {
      Left(txt.split(""\\s+"").toList)
    } else if (txt.contains("","")) {
      Left(txt.split("","").toList)
    } else {
      val oddOrderCount = txt.toCharArray
        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)
      Right(oddOrderCount.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(splitWords((""Hello world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello,world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello world,!"")).equals(List[String](""Hello"", ""world,!"")));
    assert(splitWords((""Hello,Hello,world !"")).equals(List[String](""Hello,Hello,world"", ""!"")));
    assert(splitWords((""abcdef"")).equals(3l));
    assert(splitWords((""aaabb"")).equals(2l));
    assert(splitWords((""aaaBb"")).equals(1l));
    assert(splitWords(("""")).equals(0l));
    }

}
"
HumanEval_126,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //Počet, vrací hodnotu false. Předpokládejme, že nejsou žádné záporné čísla, ale pouze celá čísla.    //Pokud má seznam více než jeden duplikát, je třeba ho vypsat ve vzestupném pořadí.    //Je-li uveden seznam čísel, vrátí se, zda jsou nebo nejsou zorganizované.    // >>> isSorted((List[Long](5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (false)
    def isSorted(lst : List[Long]) : Boolean = {
","def isSorted(lst: List[Long]): Boolean = {
    if (lst.isEmpty || lst.length == 1) return true

    var hasDuplicate = false

    for (i <- 1 until lst.length) {
        if (lst(i) < lst(i - 1)) {
            return false
        }
        if (lst(i) == lst(i - 1)) {
            if (hasDuplicate) return false
            hasDuplicate = true
        } else {
            hasDuplicate = false
        }
    }

    true
}","    }
    def main(args: Array[String]) = {
    assert(isSorted((List[Long](5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));
    assert(isSorted((List[Long]())) == (true));
    assert(isSorted((List[Long](1l.toLong))) == (true));
    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));
    }

}
"
HumanEval_127,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //[vstup/výstup] vzorky:     //Pokud se tyto dvě intervaly neseknou, vrátíme ""NE"".    //V opačném případě se vrátí ""NE"".     //Pokud je délka křižovatky prvočíslo, vrátí se ""YES"",     //která má délku 1, která není prvočíslo.    //Například, křižovatka intervalů (1, 3), (2, 4) je (2, 3)     //intervaly je prvočíslo.    //Vaším úkolem je zjistit, zda je délka křižovatky těchto dvou     //U každého intervalu se předpokládá, že jeho začátek je menší nebo rovný jeho konci.    //zahrnuje jak začátek, tak i konec.     //Dávány intervaly jsou uzavřené, což znamená, že interval (začátek, konec)     //kde každý interval je pár celých čísel. Například interval = (začátek, konec) = (1, 2).    //Máte dva intervaly.    // >>> intersection(((1l, 2l)), ((2l, 3l)))
    // (""NO"")
    // >>> intersection(((-1l, 1l)), ((0l, 4l)))
    // (""NO"")
    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))
    // (""YES"")
    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {
","import scala.math._

object Problem {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {
    val start = max(interval1._1, interval2._1)
    val end = min(interval1._2, interval2._2)
    if (start > end) return ""NO""

    val length = end - start
    if (isPrime(length)) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((""NO"")));
    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((""NO"")));
    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((""YES"")));
    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((""YES"")));
    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((""NO"")));
    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((""NO"")));
    }

}
"
HumanEval_128,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Poznámka: return None pro prázdné soubory.     //Každé číslo v seznamu, reprezentované číslem 1, -1 nebo 0.    //Součet veličin celých čísel vynásobených násobkem všech znaků     //Dostanete seznam celých čísel a musíte vrátit     // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))
    // Some(9l)
    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))
    // Some(0l)
    // >>> prodSigns((List[Long]()))
    // None
    def prodSigns(arr : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def prodSigns(arr: List[Long]): Option[Long] = {
    if (arr.isEmpty) return None

    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))
    val sumOfMagnitudes = arr.map(_.abs).sum

    Some(sumOfMagnitudes * productOfSigns)
  }

  private def sign(num: Long): Long = {
    if (num > 0) 1
    else if (num < 0) -1
    else 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));
    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));
    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));
    assert(prodSigns((List[Long]())).equals(None));
    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));
    }

}
"
HumanEval_129,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Vrací se pořadový seznam hodnot buněk, kterými prochází minimální cesta.     //Je zaručeno, že odpověď je jedinečná.    //lst_A[j] = lst_B[j].    //tak, že lst_A[i] < lst_B[i] a pro jakékoliv j (1 <= j < i) máme     //než lst_B, jinými slovy existuje celé číslo indexu i (1 <= i <= k)     //(nazvěme je lst_A a lst_B), lst_A je lexikograficky méně     //po vytvoření řádného seznamu hodnot na buňkách A a B se     //Cesta A (délky k) se považuje za kratší než cesta B (délky k), pokud     //Nemůžeš se dostat mimo síť.    //nezbytně odlišné).    //Vezměte prosím na vědomí, že cesta délky k znamená návštěvu přesně k buněk (ne     //    //Jinými slovy, můžete jít do buněk, které sdílejí okraj s vaším proudem.    //z jakékoliv buňky, a v každém kroku se můžete přesunout do kterékoliv sousední buňky,    //Musíte najít minimální cestu délky k v mřížce.    //v buňkách mřížky se zobrazí přesně jednou.     //Každá buňka v mřížce obsahuje hodnotu.    //Za předpokladu, že je mřížka s N řádky a N sloupci (N >= 2) a kladným celým číslem k,     // >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))
    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))
    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))
    // (List[Long](1l.toLong))
    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minPath(grid: List[List[Long]], k: Long): List[Long] = {
    val n = grid.length
    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))

    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n

    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {
      if (path.length == k) return path
      var minPath: List[Long] = List.fill(k)(Long.MaxValue)
      for ((dx, dy) <- directions) {
        val nx = x + dx
        val ny = y + dy
        if (isValid(nx, ny)) {
          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))
          if (lexCompare(newPath, minPath)) {
            minPath = newPath
          }
        }
      }
      minPath
    }

    def lexCompare(a: List[Long], b: List[Long]): Boolean = {
      a.zip(b).find { case (x, y) => x != y } match {
        case Some((x, y)) => x < y
        case None => false
      }
    }

    var minPathOverall = List.fill(k)(Long.MaxValue)
    for {
      i <- 0 until n
      j <- 0 until n
    } {
      val startingPath = List(grid(i)(j))
      val currentPath = dfs(i, j, startingPath)
      if (lexCompare(currentPath, minPathOverall)) {
        minPathOverall = currentPath
      }
    }
    minPathOverall
  }
}","    }
    def main(args: Array[String]) = {
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));
    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_130,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //První n + 1 čísla Tribonacciho řady.    //Máte ne-záporné celé číslo n, musíte vrátit seznam     //= 2 + 3 + 3 = 8     //tri(3) = tri(2) + tri(1) + tri(4)     //tri(4) = 3     //tri(2) = 1 + (2 / 2) = 2     //Například:     //tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), pokud je n nepárné.     //tri (n) = 1 + n / 2, pokud je n párné.    //tri(1) = 3     //Tribonacciho sekvence je definována recidivou:     //Nicméně, co lidé neznají je Tribonacciho sekvence.    //Každý zná Fibonacciho sekvenci, byla podrobně studována matematiky v roce 1929.    // >>> tri((3l))
    // (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))
    def tri(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def tri(n: Long): List[Long] = {
    // Initialize list with the first element of the Tribonacci sequence
    val tribonacciSeq = ListBuffer[Long](3)

    // Generate remaining elements up to the nth element
    for (i <- 1L to n) {
      if (i % 2 == 0) {
        // If even, the formula is 1 + n / 2
        tribonacciSeq.append(1 + i / 2)
      } else {
        // If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)
        // tri(n + 1) is handled as we iterate further
        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0
        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0
        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) / 2 else 0 // calculated as if the next is even
        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)
      }
    }

    // Return as a list
    tribonacciSeq.toList
  }

  // Test examples
  def main(args: Array[String]): Unit = {
    println(tri(3)) // List(3, 2, 8)
  }
}","    }
    def main(args: Array[String]) = {
    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));
    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));
    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));
    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));
    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));
    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));
    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));
    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));
    assert(tri((0l)).equals((List[Long](1l.toLong))));
    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_131,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Vrátí 0, pokud jsou všechny číslice párné.     //Za předpokladu, že je kladné celé číslo n, vraťte součin nečíselných číslic.     // >>> digits((1l))
    // (1l)
    // >>> digits((4l))
    // (0l)
    // >>> digits((235l))
    // (15l)
    def digits(n : Long) : Long = {
","def digits(n: Long): Long = {
    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product
    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product
}","    }
    def main(args: Array[String]) = {
    assert(digits((5l)) == (5l));
    assert(digits((54l)) == (5l));
    assert(digits((120l)) == (1l));
    assert(digits((5014l)) == (5l));
    assert(digits((98765l)) == (315l));
    assert(digits((5576543l)) == (2625l));
    assert(digits((2468l)) == (0l));
    }

}
"
HumanEval_132,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //kde je vkládána alespoň jedna závorka v podřízenosti.     //Funkce by měla vrátit hodnotu true, pokud a pouze pokud existuje platná podřazenost závorek     //Vytvořit funkci, která bere jako vstup řetězec obsahující pouze závorky.    // >>> isNested((""[[]]""))
    // (true)
    // >>> isNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> isNested((""[][]""))
    // (false)
    // >>> isNested((""[]""))
    // (false)
    // >>> isNested((""[[][]]""))
    // (true)
    // >>> isNested((""[[]][[""))
    // (true)
    def isNested(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isNested(string: String): Boolean = {
    var stack = new Stack[Char]()
    var nested = false

    for (char <- string) {
      char match {
        case '[' => stack.push(char)
        case ']' =>
          if (stack.nonEmpty) {
            stack.pop()
            if (stack.nonEmpty) {
              nested = true
            }
          }
      }
      if (nested) return true
    }

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isNested((""[[]]"")) == (true));
    assert(isNested((""[]]]]]]][[[[[]"")) == (false));
    assert(isNested((""[][]"")) == (false));
    assert(isNested((""[]"")) == (false));
    assert(isNested((""[[[[]]]]"")) == (true));
    assert(isNested((""[]]]]]]]]]]"")) == (false));
    assert(isNested((""[][][[]]"")) == (true));
    assert(isNested((""[[]"")) == (false));
    assert(isNested((""[]]"")) == (false));
    assert(isNested((""[[]][["")) == (true));
    assert(isNested((""[[][]]"")) == (true));
    assert(isNested(("""")) == (false));
    assert(isNested((""[[[[[[[["")) == (false));
    assert(isNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Zaokrouhlte každý prvek v seznamu nejprve na horní int{}    //Musíte vrátit součet čísel na druhou v daném seznamu,     //Dostanete seznam čísel.    // >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))
    // (14l)
    // >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))
    // (98l)
    // >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))
    // (84l)
    // >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))
    // (29l)
    // >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))
    // (6l)
    def sumSquares(lst : List[Float]) : Long = {
","import scala.math._

object Problem {
  def sumSquares(lst: List[Float]): Long = {
    lst.map(x => ceil(x.toDouble).toLong)
      .map(x => x * x)
      .sum
  }

  // Example usage, you can test the function with the given examples:
  def main(args: Array[String]): Unit = {
    println(sumSquares(List(1.0f, 2.0f, 3.0f))) // Output: 14
    println(sumSquares(List(1.0f, 4.0f, 9.0f))) // Output: 98
    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) // Output: 84
    println(sumSquares(List(1.4f, 4.2f, 0.0f))) // Output: 29
    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) // Output: 6
  }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));
    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));
    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));
    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));
    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));
    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));
    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));
    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));
    }

}
"
HumanEval_134,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Poznámka: ""slovo"" je skupina znaků oddělených mezerou.     //část slova a jinak falešná.    //z daného řetězce je abecední znak a není     //Vytvořit funkci , která vrátí hodnotu true , pokud poslední znak     // >>> checkIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> checkIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> checkIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> checkIfLastCharIsALetter((""""))
    // (false)
    def checkIfLastCharIsALetter(txt : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def checkIfLastCharIsALetter(txt: String): Boolean = {
        if (txt.isEmpty) return false
        val trimmed = txt.trim
        if (trimmed.isEmpty) return false
        val parts = trimmed.split("" "")
        val lastChars = parts.map(_.last)
        if (lastChars.isEmpty) return false
        val lastChar = trimmed.last
        lastChars.contains(lastChar) && lastChar.isLetter
    }
}","    }
    def main(args: Array[String]) = {
    assert(checkIfLastCharIsALetter((""apple"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e"")) == (true));
    assert(checkIfLastCharIsALetter((""eeeee"")) == (false));
    assert(checkIfLastCharIsALetter((""A"")) == (true));
    assert(checkIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    assert(checkIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    assert(checkIfLastCharIsALetter(("""")) == (false));
    assert(checkIfLastCharIsALetter((""eeeee e "")) == (false));
    assert(checkIfLastCharIsALetter((""apple pie"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //duplicitní hodnoty.    //Pokud takový prvek neexistuje, vrátí se -1.    //není větší nebo rovna prvku, který je bezprostředně před ním.    //Vytvořit funkci, která vrátí největší index prvku, který     // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))
    // (3l)
    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (-1l)
    def canArrange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  def canArrange(arr: List[Long]): Long = {
    for (i <- arr.indices.drop(1)) {
      if (arr(i) < arr(i - 1)) return i.toLong
    }
    -1L
  }
}","    }
    def main(args: Array[String]) = {
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));
    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));
    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));
    assert(canArrange((List[Long]())) == (-1l));
    }

}
"
HumanEval_136,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Pokud tam nejsou žádné záporné nebo kladné celé čísla, vrátíme je jako None.    //Zásadní je, že se jedná o seznam pozitivních celých čísel.    //Největší z negativních celých čísel a b je nejmenší     //Vytvořte funkci, která vrátí tupl (a, b), kde 'a' je     // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (Some(None), Some(1l))
    // >>> largestSmallestIntegers((List[Long]()))
    // (Some(None), Some(None))
    // >>> largestSmallestIntegers((List[Long](0l.toLong)))
    // (Some(None), Some(None))
    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {
    val negativeIntegers = lst.filter(_ < 0)
    val positiveIntegers = lst.filter(_ > 0)

    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None
    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None

    (largestNegative, smallestPositive)
  }
}","    }
    def main(args: Array[String]) = {
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));
    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));
    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));
    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));
    }

}
"
HumanEval_138,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad     //Zjistěte, zda lze dané číslo n zapsat jako součet přesně čtyř kladných párných čísel.    // >>> isEqualToSumEven((4l))
    // (false)
    // >>> isEqualToSumEven((6l))
    // (false)
    // >>> isEqualToSumEven((8l))
    // (true)
    def isEqualToSumEven(n : Long) : Boolean = {
","def isEqualToSumEven(n: Long): Boolean = {
    // Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.
    n >= 8 && n % 2 == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(isEqualToSumEven((4l)) == (false));
    assert(isEqualToSumEven((6l)) == (false));
    assert(isEqualToSumEven((8l)) == (true));
    assert(isEqualToSumEven((10l)) == (true));
    assert(isEqualToSumEven((11l)) == (false));
    assert(isEqualToSumEven((12l)) == (true));
    assert(isEqualToSumEven((13l)) == (false));
    assert(isEqualToSumEven((16l)) == (true));
    }

}
"
HumanEval_139,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //kde n > 0     //brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1!     //Brazílský faktoriál je definován jako:     // >>> specialFactorial((4l))
    // (288l)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    def specialFactorial(n : Long) : Long = {
","def specialFactorial(n: Long): Long = {
        def factorial(x: Long): Long = {
            if (x == 0 || x == 1) 1L
            else x * factorial(x - 1)
        }

        (1L to n).map(factorial).product
    }
}","    }
    def main(args: Array[String]) = {
    assert(specialFactorial((4l)) == (288l));
    assert(specialFactorial((5l)) == (34560l));
    assert(specialFactorial((7l)) == (125411328000l));
    assert(specialFactorial((1l)) == (1l));
    }

}
"
HumanEval_140,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //pak všechny po sobě jdoucí prostory nahrazujeme -     //a pokud má řetězec více než 2 po sobě jdoucí mezery,     //Pokud je uveden řetězec textu, nahraďte všechny mezery podtržením,     // >>> fixSpaces(("" Example""))
    // (""Example"")
    // >>> fixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> fixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> fixSpaces(("" Example 3""))
    // (""_Example-3"")
    def fixSpaces(text : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fixSpaces(text: String): String = {
    val result = new StringBuilder()
    var spaceCount = 0
    var leadingSpace = true
    
    for (ch <- text) {
      if (ch == ' ') {
        spaceCount += 1
      } else {
        if (spaceCount > 0) {
          if (leadingSpace && result.isEmpty) {
            result.append('_')
          } else if (spaceCount == 1) {
            result.append('_')
          } else if (spaceCount > 1) {
            result.append('-')
          }
          spaceCount = 0
        }
        result.append(ch)
        leadingSpace = false
      }
    }
    
    if (spaceCount == 1) {
      result.append('_')
    } else if (spaceCount > 1) {
      result.append('-')
    }
    
    result.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(fixSpaces((""Example"")).equals((""Example"")));
    assert(fixSpaces((""Mudasir Hanif "")).equals((""Mudasir_Hanif_"")));
    assert(fixSpaces((""Yellow Yellow  Dirty  Fellow"")).equals((""Yellow_Yellow__Dirty__Fellow"")));
    assert(fixSpaces((""Exa   mple"")).equals((""Exa-mple"")));
    assert(fixSpaces((""   Exa 1 2 2 mple"")).equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //- Podstránka po tečce by měla být jedna z těchto: ['txt', 'exe', 'dll']     //latinské abecedy (""a"" - ""z"" a ""A"" - ""Z"").    //- Podstránka před tečkou by neměla být prázdná a začíná písmenem od     //- Název souboru obsahuje přesně jednu tečku.    //- Název souboru by neměl obsahovat více než tři číslice ('0'-'9').     //jsou splněny:     //Název souboru se považuje za platný, pokud a pouze pokud splňují všechny následující podmínky     //""Ano"", pokud je název souboru platný, jinak ""Ne"".    //Vytvořit funkci, která bere řetězec reprezentující název souboru a vrátí     // >>> fileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> fileNameCheck((""1example.dll""))
    // (""No"")
    def fileNameCheck(file_name : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fileNameCheck(file_name: String): String = {
    val validExtensions = Set(""txt"", ""exe"", ""dll"")
    val dotIndex = file_name.lastIndexOf('.')

    if (dotIndex == -1) return ""No""

    val beforeDot = file_name.substring(0, dotIndex)
    val afterDot = file_name.substring(dotIndex + 1)

    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return ""No""

    val digitCount = beforeDot.count(_.isDigit)
    if (digitCount > 3) return ""No""

    if (!validExtensions.contains(afterDot)) return ""No""

    ""Yes""
  }

  def main(args: Array[String]): Unit = {
    println(fileNameCheck(""example.txt"")) // ""Yes""
    println(fileNameCheck(""1example.dll"")) // ""No""
    println(fileNameCheck(""test123.exe"")) // ""Yes""
    println(fileNameCheck("".hidden.txt"")) // ""No""
    println(fileNameCheck(""file..txt"")) // ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(fileNameCheck((""example.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""1example.dll"")).equals((""No"")));
    assert(fileNameCheck((""s1sdf3.asd"")).equals((""No"")));
    assert(fileNameCheck((""K.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""MY16FILE3.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""His12FILE94.exe"")).equals((""No"")));
    assert(fileNameCheck((""_Y.txt"")).equals((""No"")));
    assert(fileNameCheck((""?aREYA.exe"")).equals((""No"")));
    assert(fileNameCheck((""/this_is_valid.dll"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.wow"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""this_is_valid.txtexe"")).equals((""No"")));
    assert(fileNameCheck((""#this2_i4s_5valid.ten"")).equals((""No"")));
    assert(fileNameCheck((""@this1_is6_valid.exe"")).equals((""No"")));
    assert(fileNameCheck((""this_is_12valid.6exe4.txt"")).equals((""No"")));
    assert(fileNameCheck((""all.exe.txt"")).equals((""No"")));
    assert(fileNameCheck((""I563_No.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""Is3youfault.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""no_one#knows.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""1I563_Yes3.exe"")).equals((""No"")));
    assert(fileNameCheck((""I563_Yes3.txtt"")).equals((""No"")));
    assert(fileNameCheck((""final..txt"")).equals((""No"")));
    assert(fileNameCheck((""final132"")).equals((""No"")));
    assert(fileNameCheck((""_f4indsartal132."")).equals((""No"")));
    assert(fileNameCheck(("".txt"")).equals((""No"")));
    assert(fileNameCheck((""s."")).equals((""No"")));
    }

}
"
HumanEval_142,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //změnit položky v seznamu, jejichž indexy nejsou násobkem 3 nebo 4. Funkce pak vrátí součet všech položek.     //Je to násobek 3 a bude se rovnat číslu 3 v případě, že jeho index je násobkem 4 a ne násobkem 3.    //Tato funkce bude mít seznam celých čísel. Pro všechny položky v seznamu, funkce musí umocnit na druhou rovnici celé číslo, pokud je její index     //""     // >>> lst
    // List[Long](1l.toLong, 2l.toLong, 3l.toLong)
    // >>> lst
    // List[Long]()
    // >>> lst
    // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)
    def sumSquares(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def sumSquares(lst: List[Long]): Long = {
        lst.zipWithIndex.map { case (value, index) =>
            if (index % 3 == 0) {
                value * value
            } else if (index % 4 == 0) {
                value * value * value
            } else {
                value
            }
        }.sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));
    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));
    assert(sumSquares((List[Long]())) == (0l));
    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));
    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));
    assert(sumSquares((List[Long](0l.toLong))) == (0l));
    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));
    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));
    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));
    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));
    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));
    }

}
"
HumanEval_143,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad 1:     //pořadí slov v novém řádku by mělo být stejné jako v původním řádku.    //jejichž délky jsou prvočísla,     //a musíte vrátit řetězec, který obsahuje slova z původní věty,     //věta obsahuje slova oddělená mezerou,     //Dostanete řetěz, který představuje větu,     // >>> wordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> wordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    def wordsInSentence(sentence : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isPrime(n: Int): Boolean = {
    if (n < 2) false
    else if (n == 2) true
    else !(2 to sqrt(n).toInt).exists(n % _ == 0)
  }

  def wordsInSentence(sentence: String): String = {
    val words = sentence.split("" "")
    val primeLengthWords = words.filter(word => isPrime(word.length))
    primeLengthWords.mkString("" "")
  }
  
  // Example usage:
  // println(wordsInSentence(""This is a test""))
  // println(wordsInSentence(""lets go for swimming""))
}","    }
    def main(args: Array[String]) = {
    assert(wordsInSentence((""This is a test"")).equals((""is"")));
    assert(wordsInSentence((""lets go for swimming"")).equals((""go for"")));
    assert(wordsInSentence((""there is no place available here"")).equals((""there is no place"")));
    assert(wordsInSentence((""Hi I am Hussein"")).equals((""Hi am Hussein"")));
    assert(wordsInSentence((""go for it"")).equals((""go for it"")));
    assert(wordsInSentence((""here"")).equals(("""")));
    assert(wordsInSentence((""here is"")).equals((""is"")));
    }

}
"
HumanEval_144,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Můžete předpokládat, že x a n jsou platné zlomky a nemají jako jmenovatel nulu.    //<čitatel>/<menovatel>, kde čitatel i jmenovatel jsou kladná celá čísla.    //Obě, x a n, jsou řetězcovými reprezentacemi zlomku a mají následující formát:    //x * n. Funkce vrátí hodnotu true, pokud se x * n vyhodnocuje na celé číslo a false     //Vaším úkolem je implementovat funkci , která zjednoduší tento výraz .    // >>> simplify((""1/5""), (""5/1""))
    // (true)
    // >>> simplify((""1/6""), (""2/1""))
    // (false)
    // >>> simplify((""7/10""), (""10/2""))
    // (false)
    def simplify(x : String, n : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def simplify(x: String, n: String): Boolean = {
    def parseFraction(fraction: String): (Int, Int) = {
      val parts = fraction.split(""/"")
      (parts(0).toInt, parts(1).toInt)
    }

    val (numX, denX) = parseFraction(x)
    val (numN, denN) = parseFraction(n)

    val multipliedNumerator = numX * numN
    val multipliedDenominator = denX * denN

    multipliedNumerator % multipliedDenominator == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/6""), (""2/1"")) == (false));
    assert(simplify((""5/1""), (""3/1"")) == (true));
    assert(simplify((""7/10""), (""10/2"")) == (false));
    assert(simplify((""2/10""), (""50/10"")) == (true));
    assert(simplify((""7/2""), (""4/2"")) == (true));
    assert(simplify((""11/6""), (""6/1"")) == (true));
    assert(simplify((""2/3""), (""5/2"")) == (false));
    assert(simplify((""5/2""), (""3/5"")) == (false));
    assert(simplify((""2/4""), (""8/4"")) == (true));
    assert(simplify((""2/4""), (""4/2"")) == (true));
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Pořadí je podle jejich indexu v původním seznamu.    //Poznámka: pokud existuje několik položek s podobným součtem jejich číslic,     //v postupu stoupajícím podle součtu číslic.     //Napište funkci , která zortuje daný seznam celých čísel .    // >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))
    // (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))
    // >>> orderByPoints((List[Long]()))
    // (List[Long]())
    def orderByPoints(nums : List[Long]) : List[Long] = {
","def orderByPoints(nums: List[Long]): List[Long] = {
    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum
    
    nums.zipWithIndex
      .sortBy { case (num, index) => (digitSum(num), index) }
      .map(_._1)
  }
}","    }
    def main(args: Array[String]) = {
    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));
    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));
    assert(orderByPoints((List[Long]())).equals((List[Long]())));
    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));
    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));
    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));
    }

}
"
HumanEval_146,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //první a poslední číslice čísla jsou nepředmětné (1, 3, 5, 7, 9).    //počet prvků v seznamu, které jsou větší než 10 a oba     //Napište funkci , která bere seznam čísel jako vstup a vrátí     // >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))
    // (1l)
    // >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))
    // (2l)
    def specialFilter(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def specialFilter(nums: List[Long]): Long = {
    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
    
    nums.count { num =>
      val absNumStr = num.abs.toString
      val firstDigit = absNumStr.head
      val lastDigit = absNumStr.last
      
      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)
    }.toLong
  }

  def main(args: Array[String]): Unit = {
    println(specialFilter(List(15L, -73L, 14L, -15L))) // Output: 1
    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) // Output: 2
  }
}","    }
    def main(args: Array[String]) = {
    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));
    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));
    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));
    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));
    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));
    assert(specialFilter((List[Long](1l.toLong))) == (0l));
    assert(specialFilter((List[Long]())) == (0l));
    }

}
"
HumanEval_147,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //a a[i] + a[j] + a[k] je násobek 3.    //Vrací počet trojnásobků (a[i], a[j], a[k]) a kde i < j < k,     //Pro každé i (1 ≤ i ≤ n) je hodnota a[i] = i * i - i + 1.     //Máte kladné celé číslo n. Musíte vytvořit seznam celých čísel a délky n.    // >>> getMaxTriples((5l))
    // (1l)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    def getMaxTriples(n : Long) : Long = {
","def getMaxTriples(n: Long): Long = {
    val a = (1L to n).map(i => i * i - i + 1).toList
    var count = 0L

    for {
      i <- 0L until n
      j <- i + 1 until n
      k <- j + 1 until n
    } {
      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(getMaxTriples((5l)) == (1l));
    assert(getMaxTriples((6l)) == (4l));
    assert(getMaxTriples((10l)) == (36l));
    assert(getMaxTriples((100l)) == (53361l));
    }

}
"
HumanEval_148,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //nejsou správné názvy planet.    //Funkce by měla vrátit prázdný tupl, pokud je planet1 nebo planet2     //blízkost k slunci.    //umístěné mezi oběžné dráhou planety 1 a oběžné dráhou planety 2, tříděné podle     //Funkce by měla vrátit tupl obsahující všechny planety, jejichž oběžné dráhy jsou     //Napište funkci, která bere dvě jména planet jako řetězce planet1 a planet2.    //Uran, Neptun.    //je Merkur, další je Venuše, pak Země, Mars, Jupiter, Saturn,    //V naší sluneční soustavě je osm planet , nejbližší k Slunci .    // >>> bf((""Jupiter""), (""Neptune""))
    // (List[String](""Saturn"", ""Uranus""))
    // >>> bf((""Earth""), (""Mercury""))
    // (List[String](""Venus""))
    // >>> bf((""Mercury""), (""Uranus""))
    // (List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))
    def bf(planet1 : String, planet2 : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def bf(planet1: String, planet2: String): List[String] = {
    val planets = List(""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    
    // Find the indices of the given planets
    val index1Opt = planets.indexOf(planet1)
    val index2Opt = planets.indexOf(planet2)
    
    // If either planet is not found, return an empty list
    if (index1Opt == -1 || index2Opt == -1) {
      return List.empty
    }
    
    // Sort indices to ensure proper traversal direction
    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)
    
    // Get the planets between the indices
    planets.slice(startIndex + 1, endIndex)
  }
}","    }
    def main(args: Array[String]) = {
    assert(bf((""Jupiter""), (""Neptune"")).equals((List[String](""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Mercury"")).equals((List[String](""Venus""))));
    assert(bf((""Mercury""), (""Uranus"")).equals((List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))));
    assert(bf((""Neptune""), (""Venus"")).equals((List[String](""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Earth"")).equals((List[String]())));
    assert(bf((""Mars""), (""Earth"")).equals((List[String]())));
    assert(bf((""Jupiter""), (""Makemake"")).equals((List[String]())));
    }

}
"
HumanEval_149,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //Můžete předpokládat, že všechna slova budou mít stejnou délku.    //Funkce by měla vrátit seznam řetězců ve tříděném pořadí.    //Pokud jsou dvě slova stejné délky, zortujte seznam abecedně.     //by měl vrátit seznam zorganizovaný podle tohoto pravidla.     //Pořadí seznamu by mělo být stoupající podle délky každého slova, a vy     //a může obsahovat duplikáty.    //Seznam je vždy seznam řetězců a nikdy seznam čísel,     //a vrátí výsledný seznam se tříděným pořadím,     //vymaže řetězce, které mají nepárnou délku,     //Napíšejte funkci, která přijímá seznam řetězců jako parametr,     // >>> listSort((List[String](""aa"", ""a"", ""aaa"")))
    // (List[String](""aa""))
    // >>> listSort((List[String](""ab"", ""a"", ""aaa"", ""cd"")))
    // (List[String](""ab"", ""cd""))
    def sortedListSum(lst : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def listSort(lst: List[String]): List[String] = {
        lst.filter(_.length % 2 == 0)
           .sorted
           .sortBy(_.length)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortedListSum((List[String](""aa"", ""a"", ""aaa""))).equals((List[String](""aa""))));
    assert(sortedListSum((List[String](""school"", ""AI"", ""asdf"", ""b""))).equals((List[String](""AI"", ""asdf"", ""school""))));
    assert(sortedListSum((List[String](""d"", ""b"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""d"", ""dcba"", ""abcd"", ""a""))).equals((List[String](""abcd"", ""dcba""))));
    assert(sortedListSum((List[String](""AI"", ""ai"", ""au""))).equals((List[String](""AI"", ""ai"", ""au""))));
    assert(sortedListSum((List[String](""a"", ""b"", ""b"", ""c"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""aaaa"", ""bbbb"", ""dd"", ""cc""))).equals((List[String](""cc"", ""dd"", ""aaaa"", ""bbbb""))));
    }

}
"
HumanEval_150,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //a má vrátit hodnotu y jinak.    //Jednoduchý program, který by měl vrátit hodnotu x, pokud je n     // >>> xOrY((7l), (34l), (12l))
    // (34l)
    // >>> xOrY((15l), (8l), (5l))
    // (5l)
    def xOrY(n : Long, x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def isPrime(num: Long): Boolean = {
    if (num <= 1) return false
    if (num <= 3) return true
    if (num % 2 == 0 || num % 3 == 0) return false
    var i = 5
    while (i * i <= num) {
      if (num % i == 0 || num % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def xOrY(n: Long, x: Long, y: Long): Long = {
    if (isPrime(n)) x else y
  }
}","    }
    def main(args: Array[String]) = {
    assert(xOrY((7l), (34l), (12l)) == (34l));
    assert(xOrY((15l), (8l), (5l)) == (5l));
    assert(xOrY((3l), (33l), (5212l)) == (33l));
    assert(xOrY((1259l), (3l), (52l)) == (3l));
    assert(xOrY((7919l), (-1l), (12l)) == (-1l));
    assert(xOrY((3609l), (1245l), (583l)) == (583l));
    assert(xOrY((91l), (56l), (129l)) == (129l));
    assert(xOrY((6l), (34l), (1234l)) == (1234l));
    assert(xOrY((1l), (2l), (0l)) == (0l));
    assert(xOrY((2l), (2l), (0l)) == (2l));
    }

}
"
HumanEval_151,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Ignorujte čísla, která jsou záporná nebo nejsou celá čísla.    //Za předpokladu, že je seznam čísel, vraťte součet jejich čtverců.    // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))
    // (10l)
    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))
    // (0l)
    // >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))
    // (81l)
    // >>> doubleTheDifference((List[Float](0l.toLong)))
    // (0l)
    // If the input list is empty, return 0.
    def doubleTheDifference(lst : List[Float]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doubleTheDifference(lst: List[Float]): Long = {
    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)
      .map(x => x.toLong * x.toLong)
      .sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(doubleTheDifference((List[Float]())) == (0l));
    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));
    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));
    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));
    }

}
"
HumanEval_152,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //hodnota je 0, a pokud ne, hodnota je absolutní rozdíl mezi odhadem a skóre.     //Vraťte seznam stejné délky, který označuje, jak daleko od každého odhadnutí.    //Dostanete dva seznamy skóre a odhadů stejné délky, kde každý index ukazuje shodu.    //Vaším úkolem je zjistit, zda někdo správně odhadl výsledky několika zápasů.    //Rozhodně stojí za to si to zapsat a porovnat.    //Je to jen otázka, jaká je vaše osobní situace.    //Myslím , že si všichni pamatujeme ten pocit , když se objeví výsledek nějakého dlouho očekávaného ...    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))
    // (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))
    // >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))
    // (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))
    def compare(game : List[Long], guess : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def compare(game: List[Long], guess: List[Long]): List[Long] = {
    game.zip(guess).map { case (g, gs) => abs(g - gs) }
  }
}","    }
    def main(args: Array[String]) = {
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));
    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));
    }

}
"
HumanEval_153,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //(jeho síla je -1).     //return ""Slices.SErviNGSliCes"" protože ""SErviNGSliCes"" je nejsilnější rozšíření     //['SErviNGSliCes', 'Cheese', 'StuFfed'] pak byste měli     //Například, pokud máte ""Slices"" jako třídu a seznam     //Vyberte si to, co je na seznamu první.    //Pokud jsou dvě nebo více prodloužení stejné síly, měli byste     //formát: ClassName.StrongestExtensionName.     //Měli byste najít nejsilnější rozšíření a vrátit řetězec v tomto .    //v názvu rozšíření je síla uvedená jako frakce CAP - SM.     //písmen v názvu rozšíření a SM je počet malých písmen     //síla rozšíření je následující: CAP je číslo velkého písmene     //Rozšíření se použijí k načtení dalších tříd do třídy.    //Získáte název třídy (strun) a seznam rozšíření.    // >>> StrongestExtension((""my_class""), (List[String](""AA"", ""Be"", ""CC"")))
    // (""my_class.AA"")
    def StrongestExtension(class_name : String, extensions : List[String]) : String = {
","def StrongestExtension(class_name: String, extensions: List[String]): String = {
        extensions.map { extension =>
            val capCount = extension.count(_.isUpper)
            val lowerCount = extension.count(_.isLower)
            val strength = capCount - lowerCount
            (extension, strength)
        }.maxBy(_._2)._1
    } match {
        case strongest => s""$class_name.$strongest""
    }
}","    }
    def main(args: Array[String]) = {
    assert(StrongestExtension((""Watashi""), (List[String](""tEN"", ""niNE"", ""eIGHt8OKe""))).equals((""Watashi.eIGHt8OKe"")));
    assert(StrongestExtension((""Boku123""), (List[String](""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""))).equals((""Boku123.YEs.WeCaNe"")));
    assert(StrongestExtension((""__YESIMHERE""), (List[String](""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""))).equals((""__YESIMHERE.NuLl__"")));
    assert(StrongestExtension((""K""), (List[String](""Ta"", ""TAR"", ""t234An"", ""cosSo""))).equals((""K.TAR"")));
    assert(StrongestExtension((""__HAHA""), (List[String](""Tab"", ""123"", ""781345"", ""-_-""))).equals((""__HAHA.123"")));
    assert(StrongestExtension((""YameRore""), (List[String](""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""))).equals((""YameRore.okIWILL123"")));
    assert(StrongestExtension((""finNNalLLly""), (List[String](""Die"", ""NowW"", ""Wow"", ""WoW""))).equals((""finNNalLLly.WoW"")));
    assert(StrongestExtension((""_""), (List[String](""Bb"", ""91245""))).equals((""_.Bb"")));
    assert(StrongestExtension((""Sp""), (List[String](""671235"", ""Bb""))).equals((""Sp.671235"")));
    }

}
"
HumanEval_154,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Je vám dáno 2 slova. Musíte vrátit true, pokud je druhé slovo nebo některá z jeho rotací podstránkou v prvním slově.    // >>> cycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> cycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> cycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> cycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> cycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> cycpatternCheck((""himenss""), (""simen""))
    // (true)
    def cycpatternCheck(a : String, b : String) : Boolean = {
","def cycpatternCheck(a: String, b: String): Boolean = {
  val bLength = b.length
  val bDouble = b + b // Create a string with b concatenated with itself to represent all rotations
  for (i <- 0 until bLength) {
    val rotation = bDouble.substring(i, i + bLength) // Get the current rotation
    if (a.contains(rotation)) return true
  }
  false
}","    }
    def main(args: Array[String]) = {
    assert(cycpatternCheck((""xyzw""), (""xyw"")) == (false));
    assert(cycpatternCheck((""yello""), (""ell"")) == (true));
    assert(cycpatternCheck((""whattup""), (""ptut"")) == (false));
    assert(cycpatternCheck((""efef""), (""fee"")) == (true));
    assert(cycpatternCheck((""abab""), (""aabb"")) == (false));
    assert(cycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Je-li zde celé číslo, vrátíme tupl, který má počet párných a nepárných číslic.    // >>> evenOddCount((-12l))
    // ((1l, 1l))
    // >>> evenOddCount((123l))
    // ((1l, 2l))
    def evenOddCount(num : Long) : Tuple2[Long, Long] = {
","def evenOddCount(num: Long): Tuple2[Long, Long] = {
  val digits = num.abs.toString.map(_.asDigit)
  val evenCount = digits.count(_ % 2 == 0).toLong
  val oddCount = digits.count(_ % 2 != 0).toLong
  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddCount((7l)).equals(((0l, 1l))));
    assert(evenOddCount((-78l)).equals(((1l, 1l))));
    assert(evenOddCount((3452l)).equals(((2l, 2l))));
    assert(evenOddCount((346211l)).equals(((3l, 3l))));
    assert(evenOddCount((-345821l)).equals(((3l, 3l))));
    assert(evenOddCount((-2l)).equals(((1l, 0l))));
    assert(evenOddCount((-45347l)).equals(((2l, 3l))));
    assert(evenOddCount((0l)).equals(((1l, 0l))));
    }

}
"
HumanEval_156,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady:     //Omezení: 1 <= num <= 1000     //a vrátí ji malými písmeny.    //Pokud je kladné celé číslo, získáme jeho římský ekvivalent jako řetězec,     // >>> intToMiniRoman((19l))
    // (""xix"")
    // >>> intToMiniRoman((152l))
    // (""clii"")
    // >>> intToMiniRoman((426l))
    // (""cdxxvi"")
    def intToMiniRoman(number : Long) : String = {
","import scala.collection.mutable._

object Problem {
  def intToMiniRoman(number: Long): String = {
    val romanMap: List[(Int, String)] = List(
      (1000, ""m""),
      (900, ""cm""),
      (500, ""d""),
      (400, ""cd""),
      (100, ""c""),
      (90, ""xc""),
      (50, ""l""),
      (40, ""xl""),
      (10, ""x""),
      (9, ""ix""),
      (5, ""v""),
      (4, ""iv""),
      (1, ""i"")
    )

    var num = number.toInt
    val stringBuilder = new StringBuilder

    for ((value, roman) <- romanMap) {
      while (num >= value) {
        stringBuilder.append(roman)
        num -= value
      }
    }

    stringBuilder.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(intToMiniRoman((19l)).equals((""xix"")));
    assert(intToMiniRoman((152l)).equals((""clii"")));
    assert(intToMiniRoman((251l)).equals((""ccli"")));
    assert(intToMiniRoman((426l)).equals((""cdxxvi"")));
    assert(intToMiniRoman((500l)).equals((""d"")));
    assert(intToMiniRoman((1l)).equals((""i"")));
    assert(intToMiniRoman((4l)).equals((""iv"")));
    assert(intToMiniRoman((43l)).equals((""xliii"")));
    assert(intToMiniRoman((90l)).equals((""xc"")));
    assert(intToMiniRoman((94l)).equals((""xciv"")));
    assert(intToMiniRoman((532l)).equals((""dxxxii"")));
    assert(intToMiniRoman((900l)).equals((""cm"")));
    assert(intToMiniRoman((994l)).equals((""cmxciv"")));
    assert(intToMiniRoman((1000l)).equals((""m"")));
    }

}
"
HumanEval_157,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //90 stupňů.    //Pravouhlý trojúhelník je trojúhelník, ve kterém je jeden úhel pravouhlý nebo     //Strany tvoří pravouhlý trojúhelník, jinak je to nepravdivé.    //Zpětná hodnota je pravá, pokud jsou tři strany trojúhelníku rovné.    // >>> rightAngleTriangle((3l), (4l), (5l))
    // (true)
    // >>> rightAngleTriangle((1l), (2l), (3l))
    // (false)
    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {
","def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {
        val sides = List(a, b, c).sorted
        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)
    }
}","    }
    def main(args: Array[String]) = {
    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));
    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));
    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));
    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));
    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));
    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));
    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));
    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));
    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));
    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));
    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));
    }

}
"
HumanEval_158,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //znaků, vrátí ten, který je v lexikografickém pořadí na prvním místě.     //Pokud má více řetězců maximální počet jedinečných znaků,    //Seznam obsahuje různá slova. Zpět slovo s maximálním počtem     //Napíšejte funkci, která přijímá seznam řetězců.    // >>> findMax((List[String](""name"", ""of"", ""string"")))
    // (""string"")
    // >>> findMax((List[String](""name"", ""enam"", ""game"")))
    // (""enam"")
    // >>> findMax((List[String](""aaaaaaa"", ""bb"", ""cc"")))
    // (""aaaaaaa"")
    def findMax(words : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findMax(words: List[String]): String = {
    words.maxBy(word => (word.toSet.size, -word.toLowerCase))
  }
}","    }
    def main(args: Array[String]) = {
    assert(findMax((List[String](""name"", ""of"", ""string""))).equals((""string"")));
    assert(findMax((List[String](""name"", ""enam"", ""game""))).equals((""enam"")));
    assert(findMax((List[String](""aaaaaaa"", ""bb"", ""cc""))).equals((""aaaaaaa"")));
    assert(findMax((List[String](""abc"", ""cba""))).equals((""abc"")));
    assert(findMax((List[String](""play"", ""this"", ""game"", ""of"", ""footbott""))).equals((""footbott"")));
    assert(findMax((List[String](""we"", ""are"", ""gonna"", ""rock""))).equals((""gonna"")));
    assert(findMax((List[String](""we"", ""are"", ""a"", ""mad"", ""nation""))).equals((""nation"")));
    assert(findMax((List[String](""this"", ""is"", ""a"", ""prrk""))).equals((""this"")));
    assert(findMax((List[String](""b""))).equals((""b"")));
    assert(findMax((List[String](""play"", ""play"", ""play""))).equals((""play"")));
    }

}
"
HumanEval_159,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklad:     //Pokud nezbylo dostatek mrkve, sníte všechny, ale budete mít hlad.    //počet mrkví, které vám po jídle zbyly]     //[ celkový počet zkonzumovaných mrkví po jídle,     //Ale teď potřebuješ jíst více mrkví, abys dokončila denní jídlo.    //Jsi hladový králík a už jsi snědl určitý počet mrkví.    // >>> eat((5l), (6l), (10l))
    // (List[Long](11l.toLong, 4l.toLong))
    // >>> eat((4l), (8l), (9l))
    // (List[Long](12l.toLong, 1l.toLong))
    // >>> eat((1l), (10l), (10l))
    // (List[Long](11l.toLong, 0l.toLong))
    // >>> eat((2l), (11l), (5l))
    // (List[Long](7l.toLong, 0l.toLong))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def eat(number: Long, need: Long, remaining: Long): List[Long] = {
    val totalNeeded = number + need
    if (remaining >= need) {
      List(totalNeeded, remaining - need)
    } else {
      List(number + remaining, 0)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));
    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));
    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));
    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));
    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));
    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));
    }

}
"
HumanEval_160,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Seznam operátorů má alespoň jednoho operátora a seznam operandů má alespoň dva operandy.    //Operand je seznam ne-záporných celých čísel.    //Délka seznamu operátorů se rovná délce seznamu operandů minus jedna.    //Poznámka:     //=> výsledek = 9     //výsledek = 2 + 3 * 4 - 5     //seznam = [2, 3, 4, 5]     //provozovatel['+', '*', '-']     //Příklad:     //Exponenciální rozdělení (**)     //Podlažní rozdělení ( //)     //Množství (*)     //Odčítání ( - )     //Přidání (+)     //Základní algebraické operace:    //Vyjádření a vrátí hodnocení tohoto výrazu.    //Druhý seznam je seznam celých čísel.    //Dvě listy, operátor a operand.    def doAlgebra(op : List[String], operand : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doAlgebra(op: List[String], operand: List[Long]): Long = {
    var result = operand.head
    for (i <- 0 until op.length) {
      op(i) match {
        case ""+"" => result += operand(i + 1)
        case ""-"" => result -= operand(i + 1)
        case ""*"" => result *= operand(i + 1)
        case ""//"" => result /= operand(i + 1)
        case ""**"" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong
      }
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val operators = List(""+"", ""*"", ""-"")
    val operands = List(2L, 3L, 4L, 5L)
    println(doAlgebra(operators, operands)) // Output: 9
  }
}","    }
    def main(args: Array[String]) = {
    assert(doAlgebra((List[String](""**"", ""*"", ""+"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));
    assert(doAlgebra((List[String](""+"", ""*"", ""-"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));
    assert(doAlgebra((List[String](""//"", ""*"")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));
    }

}
"
HumanEval_161,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Příklady     //Funkce by měla vrátit výsledný řetězec.    //Pokud řetězec neobsahuje žádné písmenka, převrátíme řetězec.    //Jinak to nech tak, jak je.    //pokud je s[i] písmeno, převrátí se jeho příklad od dolní k horní nebo naopak,     //Máte řetězec s.    // >>> solve((""1234""))
    // (""4321"")
    // >>> solve((""ab""))
    // (""AB"")
    // >>> solve((""#a@C""))
    // (""#A@c"")
    def solve(s : String) : String = {
","def solve(s: String): String = {
    if (s.exists(_.isLetter)) {
      s.map {
        case c if c.isLetter && c.isLower => c.toUpper
        case c if c.isLetter && c.isUpper => c.toLower
        case c => c
      }.mkString
    } else {
      s.reverse
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(solve((""AsDf"")).equals((""aSdF"")));
    assert(solve((""1234"")).equals((""4321"")));
    assert(solve((""ab"")).equals((""AB"")));
    assert(solve((""#a@C"")).equals((""#A@c"")));
    assert(solve((""#AsdfW^45"")).equals((""#aSDFw^45"")));
    assert(solve((""#6@2"")).equals((""2@6#"")));
    assert(solve((""#$a^D"")).equals((""#$A^d"")));
    assert(solve((""#ccc"")).equals((""#CCC"")));
    }

}
"
HumanEval_162,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Pokud je 'text' prázdný řetězec, vrátí None.     //Za předpokladu, že je řetězec 'text', vrátíme jeho řetězec md5 hash ekvivalent.     // >>> stringToMd5((""Hello world""))
    // Some(""3e25960a79dbc69b674cd4ec67a72c62"")
    def stringToMd5(text : String) : Option[String] = {
","import java.security.MessageDigest

object Problem {
  def stringToMd5(text: String): Option[String] = {
    if (text.isEmpty) None
    else {
      val md = MessageDigest.getInstance(""MD5"")
      val digest = md.digest(text.getBytes)
      Some(digest.map(""%02x"".format(_)).mkString)
    }
  }
}

// Example usage:
// println(Problem.stringToMd5(""Hello world""))  // Output: Some(""3e25960a79dbc69b674cd4ec67a72c62"")","    }
    def main(args: Array[String]) = {
    assert(stringToMd5((""Hello world"")).equals(Some(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert(stringToMd5(("""")).equals(None));
    assert(stringToMd5((""A B C"")).equals(Some(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert(stringToMd5((""password"")).equals(Some(""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,ces_Latn,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //Například:     //a b, v postupující řadě.     //Za předpokladu, že jsou dvě kladné celé čísla a a b, vraťte párné číslice mezi a     // >>> generateIntegers((2l), (8l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((8l), (2l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((10l), (14l))
    // (List[Long]())
    def generateIntegers(a : Long, b : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def generateIntegers(a: Long, b: Long): List[Long] = {
    val start = min(a, b)
    val end = max(a, b)
    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i
    evenNumbers.map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((17l), (89l)).equals((List[Long]())));
    }

}
"
