task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //عتبة معينة.    //تحقق من أن في قائمة الأرقام المحددة، هل يوجد رقمين أقرب من بعضهما البعض من     // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))
    // (false)
    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))
    // (true)
    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {
","def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {
      val sortedNumbers = numbers.sorted
      for (i <- 1 until sortedNumbers.length) {
        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {
          return true
        }
      }
      false
    }
}","    }
    def main(args: Array[String]) = {
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));
    }

}
"
HumanEval_1,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //تجاهل أي مساحات في سلسلة الإدخال    //المجموعات المنفصلة متوازنة (كل دعامة مفتوحة مغلقة بشكل صحيح) ولا تتداخل مع بعضها البعض.    //فصل تلك المجموعة إلى سلسلة مفصلة وإرجاع قائمة تلك.    //مدخلات هذه الدالة هي سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو     // >>> separateParenGroups((""( ) (( )) (( )( ))""))
    // (List[String](""()"", ""(())"", ""(()())""))
    def separateParenGroups(paren_string : String) : List[String] = {
","def separateParenGroups(paren_string: String): List[String] = {
    val result = ListBuffer[String]()
    val sanitizedInput = paren_string.replaceAll(""\\s"", """")
    var balance = 0
    var currentGroup = new StringBuilder()

    for (char <- sanitizedInput) {
        currentGroup.append(char)
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1

        if (balance == 0 && currentGroup.nonEmpty) {
            result += currentGroup.toString()
            currentGroup = new StringBuilder()
        }
    }

    result.toList
}","    }
    def main(args: Array[String]) = {
    assert(separateParenGroups((""(()()) ((())) () ((())()())"")).equals((List[String](""(()())"", ""((()))"", ""()"", ""((())()())""))));
    assert(separateParenGroups((""() (()) ((())) (((())))"")).equals((List[String](""()"", ""(())"", ""((()))"", ""(((())))""))));
    assert(separateParenGroups((""(()(())((())))"")).equals((List[String](""(()(())((())))""))));
    assert(separateParenGroups((""( ) (( )) (( )( ))"")).equals((List[String](""()"", ""(())"", ""(()())""))));
    }

}
"
HumanEval_2,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ارجع الجزء العشري من الرقم    //(الجزء المتبقي دائماً أصغر من 1)    //و جزء عدد صحيح (أكبر عدد صحيح أصغر من الرقم المحدد) و العشريات     //وبالنظر إلى عدد نقطة العد المتغير الإيجابية، يمكن تحليلها إلى     // >>> truncateNumber((3.5f))
    // (0.5f)
    def truncateNumber(number : Float) : Float = {
","val integerPart = number.floor
        val decimalPart = number - integerPart
        decimalPart.toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(truncateNumber((3.5f)) == (0.5f));
    assert(truncateNumber((1.25f)) == (0.25f));
    assert(truncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //في هذه النقطة يجب أن تعود الدالة إلى صحيح. وإلا يجب أن تعود إلى خاطئ.    //الرصيد الصفري مهمتك هي اكتشاف ما إذا كان في أي نقطة تراكم الحساب يقل عن الصفر، و     //تعطى لك قائمة بالودائع والسحب على حساب مصرفي يبدأ بـ    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (false)
    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))
    // (true)
    def belowZero(operations : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def belowZero(operations: List[Long]): Boolean = {
    var balance: Long = 0
    for (operation <- operations) {
      balance += operation
      if (balance < 0) {
        return true
      }
    }
    false
  }

  def main(args: Array[String]): Unit = {
    println(belowZero(List(1L, 2L, 3L)))         // false
    println(belowZero(List(1L, 2L, -4L, 5L)))    // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowZero((List[Long]())) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));
    }

}
"
HumanEval_4,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //MAD = متوسط. x - x_mean.    //عنصر ونقطة مركزية (المتوسط في هذه الحالة):    //متوسط الانحراف المطلق هو متوسط الفرق المطلق بين كل     //حول متوسط هذه المجموعة من البيانات.    //بالنسبة لقائمة معينة من أرقام المدخلات، قم بحساب متوسط الانحراف المطلق     // >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))
    // (1.0f)
    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {
","val mean = numbers.sum / numbers.size
    val deviations = numbers.map(num => math.abs(num - mean))
    val mad = deviations.sum / deviations.size
    mad
  }
}","    }
    def main(args: Array[String]) = {
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));
    }

}
"
HumanEval_5,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //إدراج رقم ""محدد"" بين كل عنصرين متتاليين من قائمة المدخلات ∀numbers""     // >>> intersperse((List[Long]()), (4l))
    // (List[Long]())
    // >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))
    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {
","if (numbers.isEmpty) {
        List()
      } else {
        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last
      }
    }
}","    }
    def main(args: Array[String]) = {
    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));
    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));
    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    }

}
"
HumanEval_6,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال (() (()) لديها حد أقصى مستويين من التعشيش بينما ((())) لديها ثلاثة.     //لكل مجموعة، قم بإخراج أعمق مستوى من التكامل بين قوسين.    //المدخلات لهذه الدالة هي سلسلة تمثل مجموعات متعددة للقوسين المتداخلين المفصولين عن طريق المساحات.    // >>> parseNestedParens((""(()()) ((())) () ((())()())""))
    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))
    def parseNestedParens(paren_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseNestedParens(paren_string: String): List[Long] = {
    paren_string.split("" "").toList.map { group =>
      var maxDepth = 0
      var currentDepth = 0
      group.foreach {
        case '(' => 
          currentDepth += 1
          maxDepth = max(maxDepth, currentDepth)
        case ')' => 
          currentDepth -= 1
      }
      maxDepth.toLong
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    val result = parseNestedParens(""(()()) ((())) () ((())()())"")
    println(s""Result: ${result.mkString("", "")}"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseNestedParens((""(()()) ((())) () ((())()())"")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(parseNestedParens((""() (()) ((())) (((())))"")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(parseNestedParens((""(()(())((())))"")).equals((List[Long](4l.toLong))));
    }

}
"
HumanEval_7,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //تصفية قائمة المدخلات من السلاسل فقط لأولئك الذين يحتويون على السلسلة الفرعية المعطاة    // >>> filterBySubstring((List[String]()), (""a""))
    // (List[String]())
    // >>> filterBySubstring((List[String](""abc"", ""bacd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""bacd"", ""array""))
    def filterBySubstring(strings : List[String], substring : String) : List[String] = {
","strings.filter(_.contains(substring))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterBySubstring((List[String]()), (""john"")).equals((List[String]())));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xx"")).equals((List[String](""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""grunt"", ""trumpet"", ""prune"", ""gruesome"")), (""run"")).equals((List[String](""grunt"", ""prune""))));
    }

}
"
HumanEval_8,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يجب أن يكون المجموع الفارغ يساوي 0 والناتج الفارغ يساوي 1.    //بالنسبة لقائمة معينة من الأعداد الصحيحة، أعد توبل يتكون من مجموع ومضاعفة جميع الأعداد الصحيحة في القائمة.    // >>> sumProduct((List[Long]()))
    // ((0l, 1l))
    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // ((10l, 24l))
    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {
","def sumProduct(numbers: List[Long]): (Long, Long) = {
        val sum = numbers.sum
        val product = numbers.foldLeft(1L)(_ * _)
        (sum, product)
    }

    def main(args: Array[String]): Unit = {
        // Test examples
        println(sumProduct(List[Long]())) // (0L, 1L)
        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) // (10L, 24L)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumProduct((List[Long]())).equals(((0l, 1l))));
    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));
    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));
    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));
    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));
    }

}
"
HumanEval_9,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //في التسلسل    //من قائمة معينة من الأعداد الصحيحة، قم بإنشاء قائمة من العناصر القصوى المتداولة التي تم العثور عليها حتى اللحظة المحددة     // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))
    def rollingMax(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def rollingMax(numbers: List[Long]): List[Long] = {
        var maxSoFar = Long.MinValue
        numbers.map { num =>
            maxSoFar = max(maxSoFar, num)
            maxSoFar
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(rollingMax((List[Long]())).equals((List[Long]())));
    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));
    }

}
"
HumanEval_10,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //- إضافة إلى نهاية السلسلة العكسية من مقدمة السلسلة التي تأتي قبل النحو المتداخل.    //- ابحث عن أطول متابعة للسلسلة المقدمة والتي هي بالندروم.    //فكرة الخوارزمية بسيطة:    //جد أقصر حزمة متماثلة تبدأ بحزمة مقدمة.     // >>> makePalindrome((""""))
    // ("""")
    // >>> makePalindrome((""cat""))
    // (""catac"")
    // >>> makePalindrome((""cata""))
    // (""catac"")
    def makePalindrome(string : String) : String = {
","def makePalindrome(string: String): String = {
    // Helper function to check if a string is a palindrome
    def isPalindrome(s: String): Boolean = s == s.reverse

    // Find the longest palindromic suffix
    var endIndex = string.length
    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {
      endIndex -= 1
    }

    // Extract the non-palindromic prefix
    val prefix = string.substring(0, endIndex - 1)

    // Append the reverse of the prefix to form the shortest palindrome
    string + prefix.reverse
  }
}","    }
    def main(args: Array[String]) = {
    assert(makePalindrome(("""")).equals(("""")));
    assert(makePalindrome((""x"")).equals((""x"")));
    assert(makePalindrome((""xyz"")).equals((""xyzyx"")));
    assert(makePalindrome((""xyx"")).equals((""xyx"")));
    assert(makePalindrome((""jerry"")).equals((""jerryrrej"")));
    }

}
"
HumanEval_11,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //قم بتنفيذ XOR ثنائي على هذه المدخلات واسترد النتيجة أيضًا كسلسلة.     //المدخلات هي سلسلتين a و b تتكونان فقط من 1 و 0    // >>> stringXor((""010""), (""110""))
    // (""100"")
    def stringXor(a : String, b : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringXor(a: String, b: String): String = {
    (a zip b).map { case (charA, charB) => 
      if (charA == charB) '0' else '1'
    }.mkString
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringXor((""111000""), (""101010"")).equals((""010010"")));
    assert(stringXor((""1""), (""1"")).equals((""0"")));
    assert(stringXor((""0101""), (""0000"")).equals((""0101"")));
    }

}
"
HumanEval_12,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //سلسلة من نفس الطول. لا يعود في حالة القائمة الإدخال فارغة.    //من قائمة السلاسل، أعد أطول واحد. أعد الأول في حالة وجود أكثر من واحد.    // >>> longest((List[String]()))
    // None
    // >>> longest((List[String](""a"", ""b"", ""c"")))
    // Some(""a"")
    // >>> longest((List[String](""a"", ""bb"", ""ccc"")))
    // Some(""ccc"")
    def longest(strings : List[String]) : Option[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Out of list of strings, return the longest one. Return the first one in case of multiple
    // strings of the same length. Return None in case the input list is empty.
    def longest(strings: List[String]): Option[String] = {
        if (strings.isEmpty) None
        else Some(strings.maxBy(_.length))
    }
}","    }
    def main(args: Array[String]) = {
    assert(longest((List[String]())).equals(None));
    assert(longest((List[String](""x"", ""y"", ""z""))).equals(Some(""x"")));
    assert(longest((List[String](""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""))).equals(Some(""zzzz"")));
    }

}
"
HumanEval_13,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أعد أكبر مقسم مشترك لعددين صحيحين a و b     // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return a greatest common divisor of two integers a and b
    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a: Long, b: Long): Long = {
        if (b == 0) a else greatestCommonDivisor(b, a % b)
    }
}","    }
    def main(args: Array[String]) = {
    assert(greatestCommonDivisor((3l), (7l)) == (1l));
    assert(greatestCommonDivisor((10l), (15l)) == (5l));
    assert(greatestCommonDivisor((49l), (14l)) == (7l));
    assert(greatestCommonDivisor((144l), (60l)) == (12l));
    }

}
"
HumanEval_14,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد قائمة بجميع البديلات من أقصر إلى أطول سلسلة الإدخال    // >>> allPrefixes((""abc""))
    // (List[String](""a"", ""ab"", ""abc""))
    def allPrefixes(string : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return list of all prefixes from shortest to longest of the input string
  // >>> allPrefixes((""abc""))
  // (List[String](""a"", ""ab"", ""abc""))
  def allPrefixes(string: String): List[String] = {
    (1 to string.length).map(i => string.substring(0, i)).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(allPrefixes(("""")).equals((List[String]())));
    assert(allPrefixes((""asdfgh"")).equals((List[String](""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""))));
    assert(allPrefixes((""WWW"")).equals((List[String](""W"", ""WW"", ""WWW""))));
    }

}
"
HumanEval_15,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد سلسلة تحتوي على أرقام محددة مساحة تبدأ من 0 حتى n شاملة.     // >>> stringSequence((0l))
    // (""0"")
    // >>> stringSequence((5l))
    // (""0 1 2 3 4 5"")
    def stringSequence(n : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringSequence(n: Long): String = {
    (0L to n).mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringSequence((0l)).equals((""0"")));
    assert(stringSequence((3l)).equals((""0 1 2 3"")));
    assert(stringSequence((10l)).equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //معطاة سلسلة، معرفة عدد الأحرف المتميزة (بغض النظر عن الحالة) هل تتكون من     // >>> countDistinctCharacters((""xyzXYZ""))
    // (3l)
    // >>> countDistinctCharacters((""Jerry""))
    // (4l)
    def countDistinctCharacters(string : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a string, find out how many distinct characters (regardless of case) does it consist of
  // >>> countDistinctCharacters((""xyzXYZ""))
  // (3l)
  // >>> countDistinctCharacters((""Jerry""))
  // (4l)
  def countDistinctCharacters(string: String): Long = {
    string.toLowerCase.toSet.size.toLong
  }
}","    }
    def main(args: Array[String]) = {
    assert(countDistinctCharacters(("""")) == (0l));
    assert(countDistinctCharacters((""abcde"")) == (5l));
    assert(countDistinctCharacters((""abcdecadeCADE"")) == (5l));
    assert(countDistinctCharacters((""aaaaAAAAaaaa"")) == (1l));
    assert(countDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5l));
    }

}
"
HumanEval_17,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //""تعني"" - نوتة رباعية، تستمر لضربة واحدة    //""أو"" - نصف نوتة، يستمر لثانية ضربات    //""أو"" - الملاحظة الكاملة، يستمر أربع ضربات     //هذه أسطورة:    //ليس الأخير    //مهمتك هي تحليل هذه السلسلة وإرجاع قائمة بالأعداد الصحيحة المقابلة لعدد الضربات لكل واحد    //المدخلات لهذه الوظيفة هي سلسلة تمثل الموسيقى الموسيقية في شكل ASCII خاص.    // >>> parseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))
    def parseMusic(music_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseMusic(music_string: String): List[Long] = {
    val noteMap = Map(""o"" -> 4L, ""o|"" -> 2L, "".|"" -> 1L)
    val notes = music_string.split("" "")
    notes.toList.map(note => noteMap(note))
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseMusic(("""")).equals((List[Long]())));
    assert(parseMusic((""o o o o"")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic(("".| .| .| .|"")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));
    assert(parseMusic((""o| o| .| .| o o o o"")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic((""o| .| o| .| o o| o o|"")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));
    }

}
"
HumanEval_18,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //العثور على عدد المرات التي يمكن العثور عليها في سلسلة أسفل معينة في السلسلة الأصلية. عد الحالات المتداخلة.     // >>> howManyTimes((""""), (""a""))
    // (0l)
    // >>> howManyTimes((""aaa""), (""a""))
    // (3l)
    // >>> howManyTimes((""aaaa""), (""aa""))
    // (3l)
    def howManyTimes(string : String, substring : String) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def howManyTimes(string: String, substring: String): Long = {
        if (substring.isEmpty || string.isEmpty) return 0L
        var count: Long = 0L
        for (i <- 0 to (string.length - substring.length)) {
            if (string.substring(i, i + substring.length) == substring) {
                count += 1
            }
        }
        count
    }

    // Test cases
    def main(args: Array[String]): Unit = {
        println(howManyTimes("""", ""a""))    // Output: 0
        println(howManyTimes(""aaa"", ""a"")) // Output: 3
        println(howManyTimes(""aaaa"", ""aa"")) // Output: 3
    }
}","    }
    def main(args: Array[String]) = {
    assert(howManyTimes((""""), (""x"")) == (0l));
    assert(howManyTimes((""xyxyxyx""), (""x"")) == (4l));
    assert(howManyTimes((""cacacacac""), (""cac"")) == (4l));
    assert(howManyTimes((""john doe""), (""john"")) == (1l));
    }

}
"
HumanEval_19,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد السلسلة مع الأرقام مرتبة من أصغر إلى أكبر    //الخيارات الصحيحة هي ""صفر"" و ""واحد"" و ""اثنان"" و ""ثلاثة"" و ""أربعة"" و ""خمسة"" و ""ستة"" و ""سبعة"" و ""ثمانية"" و ""تسعة"".    //المدخل هو سلسلة من الأرقام المحددة مساحة من ""صفر"" إلى ""تسعة"".    // >>> sortNumbers((""three one five""))
    // (""one three five"")
    def sortNumbers(numbers : String) : String = {
","def sortNumbers(numbers: String): String = {
    val numberWords = Map(
      ""zero"" -> 0,
      ""one"" -> 1,
      ""two"" -> 2,
      ""three"" -> 3,
      ""four"" -> 4,
      ""five"" -> 5,
      ""six"" -> 6,
      ""seven"" -> 7,
      ""eight"" -> 8,
      ""nine"" -> 9
    )
    
    numbers.split("" "")
      .sortBy(word => numberWords(word))
      .mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortNumbers(("""")).equals(("""")));
    assert(sortNumbers((""three"")).equals((""three"")));
    assert(sortNumbers((""three five nine"")).equals((""three five nine"")));
    assert(sortNumbers((""five zero four seven nine eight"")).equals((""zero four five seven eight nine"")));
    assert(sortNumbers((""six five four three two one zero"")).equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ويعودونها بالترتيب (الأقل عدد، أكبر عدد).    //من قائمة الأرقام المقدمة (من طول اثنين على الأقل) حدد واسترد اثنين أقرب إلى كل واحد     // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))
    // ((2.0f, 2.2f))
    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))
    // ((2.0f, 2.0f))
    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findClosestElements(numbers: List[Float]): (Float, Float) = {
    require(numbers.length >= 2, ""List must contain at least two elements"")
    val sortedNumbers = numbers.sorted

    var minDiff = Float.MaxValue
    var closestPair = (0.0f, 0.0f)

    for(i <- 0 until sortedNumbers.length - 1) {
      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))
      if(currentDiff < minDiff) {
        minDiff = currentDiff
        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))
      }
    }
    
    closestPair
  }
}","    }
    def main(args: Array[String]) = {
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));
    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));
    }

}
"
HumanEval_21,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //بحيث يصبح أصغر عدد 0 وأكبر عدد 1    //في قائمة من الأرقام (من عنصرين على الأقل) ، قم بتطبيق تحويل خطي على تلك القائمة،    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))
    // (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))
    def rescaleToUnit(numbers : List[Float]) : List[Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given list of numbers (of at least two elements), apply a linear transform to that list,
  // such that the smallest number will become 0 and the largest will become 1
  def rescaleToUnit(numbers: List[Float]): List[Float] = {
    val minVal = numbers.min
    val maxVal = numbers.max
    numbers.map(num => (num - minVal) / (maxVal - minVal))
  }
}

// Usage example
object Main extends App {
  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)
  val rescaledNumbers = Problem.rescaleToUnit(numbers)
  println(rescaledNumbers) // Output: List(0.0, 0.25, 0.5, 0.75, 1.0)
}","    }
    def main(args: Array[String]) = {
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));
    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    }

}
"
HumanEval_22,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //تصفية القائمة المقدمة من أي قيمة scalathon للأعداد الصحيحة فقط    // >>> filterIntegers((List[Any](""a"", 3.14f, 5l)))
    // (List[Long](5l.toLong))
    // >>> filterIntegers((List[Any](1l, 2l, 3l, ""abc"", Map[Long,Long](), List[Long]())))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    def filterIntegers(values : List[Any]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def filterIntegers(values: List[Any]): List[Long] = {
    values.collect {
      case l: Long => l
    }
  }

  def main(args: Array[String]): Unit = {
    println(filterIntegers(List[Any](""a"", 3.14f, 5l))) // List(5)
    println(filterIntegers(List[Any](1l, 2l, 3l, ""abc"", Map[Long, Long](), List[Long]()))) // List(1, 2, 3)
  }
}","    }
    def main(args: Array[String]) = {
    assert(filterIntegers((List[Any]())).equals((List[Long]())));
    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, ""adasd""))).equals((List[Long](4l.toLong, 9l.toLong))));
    assert(filterIntegers((List[Any](3l, ""c"", 3l, 3l, ""a"", ""b""))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_23,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //عودة طول السلسلة المعطاة    // >>> stringLength((""""))
    // (0l)
    // >>> stringLength((""abc""))
    // (3l)
    def strlen(string : String) : Long = {
","def strlen(string: String): Long = {
        string.length.toLong
    }
}","    }
    def main(args: Array[String]) = {
    assert(strlen(("""")) == (0l));
    assert(strlen((""x"")) == (1l));
    assert(strlen((""asdasnakj"")) == (9l));
    }

}
"
HumanEval_24,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //بالنسبة لعدد n، ابحث عن أكبر عدد يقسم n بالتساوي، أصغر من n     // >>> largestDivisor((15l))
    // (5l)
    def largestDivisor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // For a given number n, find the largest number that divides n evenly, smaller than n
    // >>> largestDivisor(15l)
    // (5l)
    def largestDivisor(n: Long): Long = {
        for (i <- (n / 2) to 1 by -1) {
            if (n % i == 0) return i
        }
        1L  // if no divisor found, return 1 (since 1 divides any number)
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestDivisor((3l)) == (1l));
    assert(largestDivisor((7l)) == (1l));
    assert(largestDivisor((10l)) == (5l));
    assert(largestDivisor((100l)) == (50l));
    assert(largestDivisor((49l)) == (7l));
    }

}
"
HumanEval_25,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يجب أن يكون رقم المدخلات مساوياً لمضاعفة جميع العوامل    //يجب أن يتم سرد كل عامل عدد مرات تتوافق مع عدد مرات ظهورها في التصنيف العنصري.    //يعيد قائمة العوامل الأولية للعدد الصحيح المحدد بالترتيب من أصغر إلى أكبر.    // >>> factorize((8l))
    // (List[Long](2l.toLong, 2l.toLong, 2l.toLong))
    // >>> factorize((25l))
    // (List[Long](5l.toLong, 5l.toLong))
    // >>> factorize((70l))
    // (List[Long](2l.toLong, 5l.toLong, 7l.toLong))
    def factorize(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def factorize(n: Long): List[Long] = {
    var num = n
    val factors = ListBuffer[Long]()
    
    var i = 2L
    while (i <= sqrt(num).toLong) {
      while (num % i == 0) {
        factors += i
        num /= i
      }
      i += 1
    }
    
    if (num > 1) {
      factors += num
    }
    
    factors.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(factorize((2l)).equals((List[Long](2l.toLong))));
    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));
    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));
    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_26,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //حافظ على ترتيب العناصر اليسرى كما هو الحال في المدخلات    //من قائمة الأعداد الصحيحة، قم بإزالة جميع العناصر التي تظهر أكثر من مرة.    // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 3l.toLong, 4l.toLong))
    def removeDuplicates(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def removeDuplicates(numbers: List[Long]): List[Long] = {
    val elementCount = numbers.groupBy(identity).mapValues(_.size)
    numbers.filter(num => elementCount(num) == 1)
  }

  def main(args: Array[String]): Unit = {
    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)
    println(removeDuplicates(numbers)) // Output: List(1, 3, 4)
  }
}","    }
    def main(args: Array[String]) = {
    assert(removeDuplicates((List[Long]())).equals((List[Long]())));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));
    }

}
"
HumanEval_27,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //بالنسبة لسلاسل معينة، قم بتحويل الأحرف الصغيرة إلى الأحرف الكبيرة والحروف الكبيرة إلى الأحرف الصغيرة.    // >>> flipCase((""Hello""))
    // (""hELLO"")
    def flipCase(string : String) : String = {
","def flipCase(string: String): String = {
    string.map {
      case c if c.isLower => c.toUpper
      case c if c.isUpper => c.toLower
      case c => c
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(flipCase(("""")).equals(("""")));
    assert(flipCase((""Hello!"")).equals((""hELLO!"")));
    assert(flipCase((""These violent delights have violent ends"")).equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //قم بتجميع قائمة السلاسل في سلاسل واحدة    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Concatenate list of strings into a single string
    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings: List[String]): String = {
        strings.mkString("""")
    }
}","    }
    def main(args: Array[String]) = {
    assert(concatenate((List[String]())).equals(("""")));
    assert(concatenate((List[String](""x"", ""y"", ""z""))).equals((""xyz"")));
    assert(concatenate((List[String](""x"", ""y"", ""z"", ""w"", ""k""))).equals((""xyzwk"")));
    }

}
"
HumanEval_29,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //تصفية قائمة المدخلات من السلاسل فقط لأولئك الذين يبدأون بفتحة معينة.    // >>> filterByPrefix((List[String]()), (""a""))
    // (List[String]())
    // >>> filterByPrefix((List[String](""abc"", ""bcd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""array""))
    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {
","strings.filter(_.startsWith(prefix))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterByPrefix((List[String]()), (""john"")).equals((List[String]())));
    assert(filterByPrefix((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    }

}
"
HumanEval_30,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ارجع فقط الأرقام الإيجابية في القائمة    // >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](2l.toLong, 5l.toLong, 6l.toLong))
    // >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))
    def getPositive(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def getPositive(l: List[Long]): List[Long] = {
        l.filter(_ > 0)
    }
}","    }
    def main(args: Array[String]) = {
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));
    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));
    assert(getPositive((List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_31,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد صحيحاً إذا كان عدد معين عادي، وخطأً خلاف ذلك.    // >>> isPrime((6l))
    // (false)
    // >>> isPrime((101l))
    // (true)
    // >>> isPrime((11l))
    // (true)
    // >>> isPrime((13441l))
    // (true)
    // >>> isPrime((61l))
    // (true)
    // >>> isPrime((4l))
    // (false)
    // >>> isPrime((1l))
    // (false)
    def isPrime(n : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if a given number is prime, and false otherwise.
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPrime((6l)) == (false));
    assert(isPrime((101l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((13441l)) == (true));
    assert(isPrime((61l)) == (true));
    assert(isPrime((4l)) == (false));
    assert(isPrime((1l)) == (false));
    assert(isPrime((5l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((17l)) == (true));
    assert(isPrime((85l)) == (false));
    assert(isPrime((77l)) == (false));
    assert(isPrime((255379l)) == (false));
    }

}
"
HumanEval_33,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //إلى قيم المؤشرات المقابلة لـ l ، ولكن مرتبة.    //l' هو متطابق مع l في المؤشرات التي لا تقسم على ثلاثة، في حين أن قيمها في المؤشرات التي تقسم على ثلاثة متساوية     //هذه الدالة تأخذ قائمة l وتعيد قائمة l' مثل أن     // >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))
    def sortThird(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def sortThird(l: List[Long]): List[Long] = {
    // Get the elements at indices divisible by 3
    val elementsAtThirdIndices = l.zipWithIndex.collect {
      case (value, index) if index % 3 == 0 => value
    }
    
    // Sort the collected elements
    val sortedElements = elementsAtThirdIndices.sorted
    
    // Replace elements at indices divisible by 3 with the sorted ones
    l.zipWithIndex.map {
      case (_, index) if index % 3 == 0 => sortedElements(index / 3)
      case (value, _) => value
    }
  }

  // Example usage:
  def main(args: Array[String]): Unit = {
    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));
    }

}
"
HumanEval_34,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد عناصر فريدة مرتبة في قائمة    // >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))
    def unique(l : List[Long]) : List[Long] = {
","def unique(l: List[Long]): List[Long] = {
    l.toSet.toList.sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));
    }

}
"
HumanEval_35,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد العنصر الأقصى في القائمة    // >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (3l)
    // >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (123l)
    def maxElement(l : List[Long]) : Long = {
","def maxElement(l: List[Long]): Long = {
    l.max
  }
}","    }
    def main(args: Array[String]) = {
    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));
    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));
    }

}
"
HumanEval_36,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد عدد مرات ظهور الرقم 7 في الأعداد الصحيحة الأقل من n القابلة للقسمة على 11 أو 13.     // >>> fizzBuzz((50l))
    // (0l)
    // >>> fizzBuzz((78l))
    // (2l)
    // >>> fizzBuzz((79l))
    // (3l)
    def fizzBuzz(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fizzBuzz(n: Long): Long = {
    var count = 0L
    for (i <- 1L until n) {
      if (i % 11 == 0 || i % 13 == 0) {
        count += i.toString.count(_ == '7')
      }
    }
    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(fizzBuzz((50l)) == (0l));
    assert(fizzBuzz((78l)) == (2l));
    assert(fizzBuzz((79l)) == (3l));
    assert(fizzBuzz((100l)) == (3l));
    assert(fizzBuzz((200l)) == (6l));
    assert(fizzBuzz((4000l)) == (192l));
    assert(fizzBuzz((10000l)) == (639l));
    assert(fizzBuzz((100000l)) == (8026l));
    }

}
"
HumanEval_37,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //إلى قيم المؤشرات الزوجية لـ l ، ولكن مرتبة.    //l' هو متطابق مع l في المؤشرات الفردية، في حين أن قيمها في المؤشرات الزوجية متساوية     //هذه الدالة تأخذ قائمة l وتعيد قائمة l' مثل أن     // >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))
    def sortEven(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // This function takes a list l and returns a list l' such that
  // l' is identical to l in the odd indicies, while its values at the even indicies are equal
  // to the values of the even indicies of l, but sorted.
  def sortEven(l: List[Long]): List[Long] = {
    val evenIndices = l.indices.filter(_ % 2 == 0)
    val sortedEvens = evenIndices.map(l(_)).sorted

    l.indices.map { index =>
      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))
      else l(index)
    }.toList
  }

  // Examples
  def main(args: Array[String]): Unit = {
    println(sortEven(List[Long](1L, 2L, 3L)))
    println(sortEven(List[Long](5L, 6L, 3L, 4L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));
    }

}
"
HumanEval_39,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //prime_fib يعيد رقم nth وهو رقم فيبوناتشي وهو أيضاً عدد أولي.     // >>> primeFib((1l))
    // (2l)
    // >>> primeFib((2l))
    // (3l)
    // >>> primeFib((3l))
    // (5l)
    // >>> primeFib((4l))
    // (13l)
    // >>> primeFib((5l))
    // (89l)
    def primeFib(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeFib(n: Long): Long = {
    // Function to check if a number is prime
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num == 2) return true
      if (num % 2 == 0) return false
      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {
        if (num % i == 0) return false
      }
      true
    }

    // Function to generate Fibonacci numbers
    def fibonacciStream(): Stream[Long] = {
      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)
      fibs(0, 1)
    }

    // Find the n-th Fibonacci number that is also prime
    val primeFibs = fibonacciStream().filter(isPrime)
    primeFibs.take(n.toInt).last
  }

  // Test the function
  def main(args: Array[String]): Unit = {
    println(primeFib(1L)) // 2
    println(primeFib(2L)) // 3
    println(primeFib(3L)) // 5
    println(primeFib(4L)) // 13
    println(primeFib(5L)) // 89
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeFib((1l)) == (2l));
    assert(primeFib((2l)) == (3l));
    assert(primeFib((3l)) == (5l));
    assert(primeFib((4l)) == (13l));
    assert(primeFib((5l)) == (89l));
    assert(primeFib((6l)) == (233l));
    assert(primeFib((7l)) == (1597l));
    assert(primeFib((8l)) == (28657l));
    assert(primeFib((9l)) == (514229l));
    assert(primeFib((10l)) == (433494437l));
    }

}
"
HumanEval_40,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //المجموع إلى الصفر، والكذب خلاف ذلك.    //يعود true إذا كان هناك ثلاثة عناصر متميزة في القائمة التي     //triples_sum_to_zero يأخذ قائمة من الأعداد الصحيحة كمدخل.    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong)))
    // (false)
    def triplesSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // triples_sum_to_zero takes a list of integers as an input.
    // it returns true if there are three distinct elements in the list that
    // sum to zero, and false otherwise.
    def triplesSumToZero(l: List[Long]): Boolean = {
        val n = l.length
        if (n < 3) return false

        // Sort the list to use the two-pointer technique
        val sortedList = l.sorted

        // Iterate over the list
        for (i <- 0 until n - 2) {
            var left = i + 1
            var right = n - 1

            // Use two pointers to find the remaining two numbers
            while (left < right) {
                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)
                if (currentSum == 0) {
                    return true
                } else if (currentSum < 0) {
                    left += 1
                } else {
                    right -= 1
                }
            }
        }

        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    }

}
"
HumanEval_41,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //هذه الدالة تخرج عدد هذه الاصطدامات.    //في مسارهم كما لو أنهم لم يتصادموا    //ومع ذلك، فإن السيارات قوية جداً، ونتيجة لذلك، فإنها تستمر في التحرك.    //عندما تصطدم سيارة تتحرك من اليسار إلى اليمين بسيارة تتحرك من اليمين إلى اليسار    //كل السيارات تتحرك بنفس السرعة، يقال عن سيارتين أنهما تتصادمان    //السيارات تتحرك من اليمين إلى اليسار    //n سيارات تقود من اليسار إلى اليمين؛ في الوقت نفسه، مجموعة مختلفة من n سيارات     //تخيل طريقًا مستقيمًا تمامًا، خطًا طويلًا إلى ما لا نهاية.    def carRaceCollision(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Imagine a road that's a perfectly straight infinitely long line.
  // n cars are driving left to right; simultaneously, a different set of n cars
  // are driving right to left. The two sets of cars start out being very far from
  // each other. All cars move at the same speed. Two cars are said to collide
  // when a car that's moving left to right hits a car that's moving right to left.
  // However, the cars are infinitely sturdy and strong; as a result, they continue moving
  // in their trajectory as if they did not collide.
  // This function outputs the number of such collisions.
  def carRaceCollision(n: Long): Long = {
    n
  }
}","    }
    def main(args: Array[String]) = {
    assert(carRaceCollision((2l)) == (4l));
    assert(carRaceCollision((3l)) == (9l));
    assert(carRaceCollision((4l)) == (16l));
    assert(carRaceCollision((8l)) == (64l));
    assert(carRaceCollision((10l)) == (100l));
    }

}
"
HumanEval_42,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //قائمة العودة مع عناصر زادت بنسبة 1.    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))
    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))
    def incrList(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return list with elements incremented by 1.
    def incrList(l: List[Long]): List[Long] = {
        l.map(_ + 1)
    }
}","    }
    def main(args: Array[String]) = {
    assert(incrList((List[Long]())).equals((List[Long]())));
    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));
    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));
    }

}
"
HumanEval_43,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //المجموع إلى الصفر، والكذب خلاف ذلك.    //يعود true إذا كان هناك عنصرين متميزين في القائمة    //pairs_sum_to_zero يأخذ قائمة من الأعداد الصحيحة كمدخل.    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (true)
    // >>> pairsSumToZero((List[Long](1l.toLong)))
    // (false)
    def pairsSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def pairsSumToZero(l: List[Long]): Boolean = {
        val seen = HashSet[Long]()
        for (num <- l) {
            if (seen.contains(-num)) {
                return true
            }
            seen.add(num)
        }
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));
    }

}
"
HumanEval_44,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أرقام الأساس أقل من 10    //يعيد تمثيل السلسلة بعد التحويل.    //قم بتغيير القاعدة العددية لعدد المدخل x إلى القاعدة    // >>> changeBase((8l), (3l))
    // (""22"")
    // >>> changeBase((8l), (2l))
    // (""1000"")
    // >>> changeBase((7l), (2l))
    // (""111"")
    def changeBase(x : Long, base : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def changeBase(x: Long, base: Long): String = {
        require(base > 1 && base < 10, ""Base must be between 2 and 9"")
        
        if (x == 0) return ""0""

        val result = new StringBuilder()
        var number = x

        while (number > 0) {
            val remainder = number % base
            result.append(remainder.toString)
            number /= base
        }

        result.reverse.toString()
    }
}","    }
    def main(args: Array[String]) = {
    assert(changeBase((8l), (3l)).equals((""22"")));
    assert(changeBase((9l), (3l)).equals((""100"")));
    assert(changeBase((234l), (2l)).equals((""11101010"")));
    assert(changeBase((16l), (2l)).equals((""10000"")));
    assert(changeBase((8l), (2l)).equals((""1000"")));
    assert(changeBase((7l), (2l)).equals((""111"")));
    assert(changeBase((2l), (3l)).equals((""2"")));
    assert(changeBase((3l), (4l)).equals((""3"")));
    assert(changeBase((4l), (5l)).equals((""4"")));
    assert(changeBase((5l), (6l)).equals((""5"")));
    assert(changeBase((6l), (7l)).equals((""6"")));
    assert(changeBase((7l), (8l)).equals((""7"")));
    }

}
"
HumanEval_45,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //معطى طول الجانب و مساحة العودة العالية للمثلث    // >>> triangleArea((5l), (3l))
    // (7.5f)
    def triangleArea(a : Long, h : Long) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> triangleArea(5l, 3l)
    // (7.5f)
    def triangleArea(a: Long, h: Long): Float = {
        (a * h / 2.0).toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((5l), (3l)) == (7.5f));
    assert(triangleArea((2l), (2l)) == (2.0f));
    assert(triangleArea((10l), (8l)) == (40.0f));
    }

}
"
HumanEval_46,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يرجى كتابة دالة لحساب العنصر n من تسلسل الأرقام في fib4 بكفاءة. لا تستخدم التكرار.     //فب4 (ن) -> فب4 (ن-1) + فب4 (ن-2) + فب4 (ن-3) + فب4 (ن-4).    //(فايب 4 ((3) -> 0     //(فايب 4 ((2)) -> 2     //fib4(1) -> 0     //fib4(0) -> 0     //تسلسل الأرقام فيب 4 هو تسلسل مشابه لسلسلة فيبوناتشي والذي يعرف على النحو التالي:    // >>> fib4((5l))
    // (4l)
    // >>> fib4((6l))
    // (8l)
    // >>> fib4((7l))
    // (14l)
    def fib4(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fib4(n: Long): Long = {
    if (n == 0 || n == 1) return 0
    if (n == 2) return 2
    if (n == 3) return 0

    var a: Long = 0
    var b: Long = 0
    var c: Long = 2
    var d: Long = 0
    
    var result: Long = 0
    
    for (i <- 4L to n) {
      result = a + b + c + d
      a = b
      b = c
      c = d
      d = result
    }
    
    result
  }
}","    }
    def main(args: Array[String]) = {
    assert(fib4((5l)) == (4l));
    assert(fib4((8l)) == (28l));
    assert(fib4((10l)) == (104l));
    assert(fib4((12l)) == (386l));
    }

}
"
HumanEval_47,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //العودة الوسيط من العناصر في القائمة l.     // >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // 3l
    // >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))
    // (15.0f)
    def median(l : List[Long]) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return median of elements in the list l.
  def median(l: List[Long]): Float = {
    val sortedList = l.sorted
    val n = sortedList.length
    if (n % 2 == 1) {
      sortedList(n / 2).toFloat
    } else {
      (sortedList(n / 2 - 1) + sortedList(n / 2)).toFloat / 2
    }
  }

  def main(args: Array[String]): Unit = {
    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) // 3.0
    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) // 15.0
  }
}","    }
    def main(args: Array[String]) = {
    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);
    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));
    assert(median((List[Long](5l.toLong))) == 5l);
    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));
    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);
    }

}
"
HumanEval_48,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يتحقق من أن السلسلة المعطاة هي بالندروم    // >>> isPalindrome((""""))
    // (true)
    // >>> isPalindrome((""aba""))
    // (true)
    // >>> isPalindrome((""aaaaa""))
    // (true)
    // >>> isPalindrome((""zbcd""))
    // (false)
    def isPalindrome(text : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Checks if given string is a palindrome
  def isPalindrome(text: String): Boolean = {
    val length = text.length
    for (i <- 0 until length / 2) {
      if (text(i) != text(length - i - 1)) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPalindrome(("""")) == (true));
    assert(isPalindrome((""aba"")) == (true));
    assert(isPalindrome((""aaaaa"")) == (true));
    assert(isPalindrome((""zbcd"")) == (false));
    assert(isPalindrome((""xywyx"")) == (true));
    assert(isPalindrome((""xywyz"")) == (false));
    assert(isPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //عودة 2^n p (كن على علم بالعدد).    // >>> modp((3l), (5l))
    // (3l)
    // >>> modp((1101l), (101l))
    // (2l)
    // >>> modp((0l), (101l))
    // (1l)
    // >>> modp((3l), (11l))
    // (8l)
    // >>> modp((100l), (101l))
    // (1l)
    def modp(n : Long, p : Long) : Long = {
","def modp(n: Long, p: Long): Long = {
    // Calculate 2^n modulo p using iterative exponentiation by squaring.
    def powMod(base: Long, exp: Long, mod: Long): Long = {
      var result = 1L
      var b = base % mod
      var e = exp
      
      while (e > 0) {
        if ((e & 1) == 1) { // Check if e is odd
          result = (result * b) % mod
        }
        e >>= 1
        b = (b * b) % mod
      }

      result
    }

    powMod(2, n, p)
  }
}","    }
    def main(args: Array[String]) = {
    assert(modp((3l), (5l)) == (3l));
    assert(modp((1101l), (101l)) == (2l));
    assert(modp((0l), (101l)) == (1l));
    assert(modp((3l), (11l)) == (8l));
    assert(modp((100l), (101l)) == (1l));
    assert(modp((30l), (5l)) == (4l));
    assert(modp((31l), (5l)) == (3l));
    }

}
"
HumanEval_51,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //remove_vowels هي وظيفة تأخذ السلسلة وتعيد السلسلة بدون حروف العلة.     // >>> removeVowels((""""))
    // ("""")
    // >>> removeVowels((""abcdef""))
    // (""bcdf"")
    // >>> removeVowels((""aaaaa""))
    // ("""")
    // >>> removeVowels((""aaBAA""))
    // (""B"")
    // >>> removeVowels((""zbcd""))
    // (""zbcd"")
    def removeVowels(text : String) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def removeVowels(text: String): String = {
        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        text.filterNot(vowels.contains)
    }
}","    }
    def main(args: Array[String]) = {
    assert(removeVowels(("""")).equals(("""")));
    assert(removeVowels((""abcdef\nghijklm"")).equals((""bcdf\nghjklm"")));
    assert(removeVowels((""fedcba"")).equals((""fdcb"")));
    assert(removeVowels((""eeeee"")).equals(("""")));
    assert(removeVowels((""acBAA"")).equals((""cB"")));
    assert(removeVowels((""EcBOO"")).equals((""cB"")));
    assert(removeVowels((""ybcd"")).equals((""ybcd"")));
    }

}
"
HumanEval_52,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد صحيحاً إذا كانت جميع الأرقام في القائمة l أقل من الحد الأدنى t.     // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
    // (true)
    // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
    // (false)
    def belowThreshold(l : List[Long], t : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if all numbers in the list l are below threshold t.
  // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
  // (true)
  // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
  // (false)
  def belowThreshold(l: List[Long], t: Long): Boolean = {
    l.forall(_ < t)
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));
    }

}
"
HumanEval_53,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أضف عددان x و y    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Add two numbers x and y
    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x: Long, y: Long): Long = {
        x + y
    }
}","    }
    def main(args: Array[String]) = {
    assert(add((0l), (1l)) == (1l));
    assert(add((1l), (0l)) == (1l));
    assert(add((2l), (3l)) == (5l));
    assert(add((5l), (7l)) == (12l));
    assert(add((7l), (5l)) == (12l));
    }

}
"
HumanEval_54,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //تحقق من أن كلمتين لهما نفس الحروف.    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> sameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> sameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> sameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> sameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    def sameChars(s0 : String, s1 : String) : Boolean = {
","import scala.collection.mutable._

object Problem {
  def sameChars(s0: String, s1: String): Boolean = {
    def charSet(s: String): Set[Char] = s.toSet
    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(sameChars((""abcd""), (""dddddddabc"")) == (true));
    assert(sameChars((""dddddddabc""), (""abcd"")) == (true));
    assert(sameChars((""eabcd""), (""dddddddabc"")) == (false));
    assert(sameChars((""abcd""), (""dddddddabcf"")) == (false));
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(sameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أعد رقم فيبوناتشي n.    // >>> fib((10l))
    // (55l)
    // >>> fib((1l))
    // (1l)
    // >>> fib((8l))
    // (21l)
    def fib(n : Long) : Long = {
","def fib(n: Long): Long = {
        if (n <= 1) n
        else {
            var a: Long = 0
            var b: Long = 1
            for (_ <- 2L to n) {
                val temp = a + b
                a = b
                b = temp
            }
            b
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(fib((10l)) == (55l));
    assert(fib((1l)) == (1l));
    assert(fib((8l)) == (21l));
    assert(fib((11l)) == (89l));
    assert(fib((12l)) == (144l));
    }

}
"
HumanEval_56,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعود صحيحاً إذا كان لكل قوس افتتاحي قوس إغلاق متطابق.    //الأقواس هي سلسلة من ""<"" و "">"".    // >>> correctBracketing((""<""))
    // (false)
    // >>> correctBracketing((""<>""))
    // (true)
    // >>> correctBracketing((""<<><>>""))
    // (true)
    // >>> correctBracketing((""><<>""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","import scala.collection.mutable.Stack

object Problem {
  def correctBracketing(brackets: String): Boolean = {
    val stack = new Stack[Char]()
    for (char <- brackets) {
      if (char == '<') {
        stack.push(char)
      } else if (char == '>') {
        if (stack.isEmpty || stack.pop() != '<') {
          return false
        }
      }
    }
    stack.isEmpty
  }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""<>"")) == (true));
    assert(correctBracketing((""<<><>>"")) == (true));
    assert(correctBracketing((""<><><<><>><>"")) == (true));
    assert(correctBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(correctBracketing((""<<<><>>>>"")) == (false));
    assert(correctBracketing((""><<>"")) == (false));
    assert(correctBracketing((""<"")) == (false));
    assert(correctBracketing((""<<<<"")) == (false));
    assert(correctBracketing(("">"")) == (false));
    assert(correctBracketing((""<<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>><<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد صحيحاً إذا كانت عناصر القائمة تزداد أو تنخفض بشكل متواصل.    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
    // (true)
    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
    // (false)
    // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
    // (true)
    def monotonic(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if list elements are monotonically increasing or decreasing.
  // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
  // (true)
  // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
  // (false)
  // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
  // (true)
  def monotonic(l: List[Long]): Boolean = {
    if (l.isEmpty || l.length == 1) return true

    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }
    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }

    increasing || decreasing
  }
}","    }
    def main(args: Array[String]) = {
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));
    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));
    }

}
"
HumanEval_58,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد العناصر المشتركة الفريدة المصنفة لقائمتين.    // >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))
    // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))
    // >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong))
    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return sorted unique common elements for two lists.
  def common(l1: List[Long], l2: List[Long]): List[Long] = {
    (l1.toSet intersect l2.toSet).toList.sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))
    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));
    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_59,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ارجع أكبر عامل أولي لـ n. افترض أن n > 1 وليس أولي.     // >>> largestPrimeFactor((13195l))
    // (29l)
    // >>> largestPrimeFactor((2048l))
    // (2l)
    def largestPrimeFactor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def largestPrimeFactor(n: Long): Long = {
        var number = n
        var largestFactor = 1L

        // Check for number of 2s that divide n
        while (number % 2 == 0) {
            largestFactor = 2L
            number /= 2
        }

        // n must be odd at this point, so a skip of 2 (i = i + 2) can be used
        var i = 3
        while (i <= sqrt(number)) {
            while (number % i == 0) {
                largestFactor = i
                number /= i
            }
            i += 2
        }

        // This condition is to check if number is a prime number greater than 2
        if (number > 2) {
            largestFactor = number
        }

        largestFactor
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestPrimeFactor((15l)) == (5l));
    assert(largestPrimeFactor((27l)) == (3l));
    assert(largestPrimeFactor((63l)) == (7l));
    assert(largestPrimeFactor((330l)) == (11l));
    assert(largestPrimeFactor((13195l)) == (29l));
    }

}
"
HumanEval_60,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //sum_to_n هي وظيفة تضيف الأرقام من 1 إلى n.    // >>> sumToN((30l))
    // (465l)
    // >>> sumToN((100l))
    // (5050l)
    // >>> sumToN((5l))
    // (15l)
    // >>> sumToN((10l))
    // (55l)
    // >>> sumToN((1l))
    // (1l)
    def sumToN(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def sumToN(n: Long): Long = {
        (1L to n).sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumToN((1l)) == (1l));
    assert(sumToN((6l)) == (21l));
    assert(sumToN((11l)) == (66l));
    assert(sumToN((30l)) == (465l));
    assert(sumToN((100l)) == (5050l));
    }

}
"
HumanEval_61,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعود صحيحاً إذا كان لكل قوس افتتاحي قوس إغلاق متطابق.    //الأقواس هي سلسلة من ""("" و "")"".    // >>> correctBracketing((""(""))
    // (false)
    // >>> correctBracketing((""()""))
    // (true)
    // >>> correctBracketing((""(()())""))
    // (true)
    // >>> correctBracketing(("")(()""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","var balance = 0
        for (ch <- brackets) {
            if (ch == '(') balance += 1
            else if (ch == ')') balance -= 1
            
            if (balance < 0) return false
        }
        balance == 0
    }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""()"")) == (true));
    assert(correctBracketing((""(()())"")) == (true));
    assert(correctBracketing((""()()(()())()"")) == (true));
    assert(correctBracketing((""()()((()()())())(()()(()))"")) == (true));
    assert(correctBracketing((""((()())))"")) == (false));
    assert(correctBracketing(("")(()"")) == (false));
    assert(correctBracketing((""("")) == (false));
    assert(correctBracketing((""(((("")) == (false));
    assert(correctBracketing(("")"")) == (false));
    assert(correctBracketing((""(()"")) == (false));
    assert(correctBracketing((""()()(()())())(()"")) == (false));
    assert(correctBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يعيد المشتقة من هذا الحد المتعدد بنفس الشكل.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....     //xs تمثل معامل لعدد متعدد الحدود.    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))
    // >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong))
    def derivative(xs : List[Long]) : List[Long] = {
","import scala.collection.mutable._

object Problem {
  def derivative(xs: List[Long]): List[Long] = {
    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }
  }
}","    }
    def main(args: Array[String]) = {
    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));
    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));
    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_63,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يرجى كتابة دالة لحساب العنصر nth من تسلسل الأرقام فيب فيب بكفاءة.    //(ن) == (ن-1) + (ن-2) + (ن-3)    //(تتتتتتتتتتتتتتتتت)    //({\pos (192,220) })    //0 0    //تسلسل الأرقام فيب فيب هو تسلسل مشابه لسلسلة فيبوناتشي والذي يعرف على النحو التالي:    // >>> fibfib((1l))
    // (0l)
    // >>> fibfib((5l))
    // (4l)
    // >>> fibfib((8l))
    // (24l)
    def fibfib(n : Long) : Long = {
","def fibfib(n: Long): Long = {
    if (n == 0) return 0
    if (n == 1) return 0
    if (n == 2) return 1

    var a: Long = 0
    var b: Long = 0
    var c: Long = 1
    var d: Long = 0

    for (_ <- 3L to n) {
      d = a + b + c
      a = b
      b = c
      c = d
    }
    d
  }
}","    }
    def main(args: Array[String]) = {
    assert(fibfib((2l)) == (1l));
    assert(fibfib((1l)) == (0l));
    assert(fibfib((5l)) == (4l));
    assert(fibfib((8l)) == (24l));
    assert(fibfib((10l)) == (81l));
    assert(fibfib((12l)) == (274l));
    assert(fibfib((14l)) == (927l));
    }

}
"
HumanEval_64,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //لكن فقط عندما يكون في نهاية الكلمة المعطاة    //الحروف العلوية في هذه الحالة هي ""أ"" و ""إي"" و ""إي"" و ""أو"" و ""و"" و ""ي"" هنا أيضاً    //كلمة كمدخل ويعيد عدد الحروف العلوية في السلسلة.    //اكتب دالة vowels_count التي تأخذ سلسلة تمثل     // >>> vowelsCount((""abcde""))
    // (2l)
    // >>> vowelsCount((""ACEDY""))
    // (3l)
    def vowelsCount(s : String) : Long = {
","def vowelsCount(s: String): Long = {
    val vowels = Set('a', 'e', 'i', 'o', 'u')
    val lowerCaseWord = s.toLowerCase
    var count = 0L

    for (i <- lowerCaseWord.indices) {
      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(vowelsCount((""abcde"")) == (2l));
    assert(vowelsCount((""Alone"")) == (3l));
    assert(vowelsCount((""key"")) == (2l));
    assert(vowelsCount((""bye"")) == (1l));
    assert(vowelsCount((""keY"")) == (2l));
    assert(vowelsCount((""bYe"")) == (1l));
    assert(vowelsCount((""ACEDY"")) == (3l));
    }

}
"
HumanEval_65,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //إذا كان التحول > عدد الأرقام، أعد الأرقام معاكسة.    //ويعود النتيجة كسلسلة.    //حلقة حلقة حركة أرقام العدد الصحيح x، حركة الأرقام يميناً بحركة     // >>> circularShift((12l), (1l))
    // (""21"")
    // >>> circularShift((12l), (2l))
    // (""12"")
    def circularShift(x : Long, shift : Long) : String = {
","def circularShift(x: Long, shift: Long): String = {
  val digits = x.toString
  val length = digits.length
  
  if (shift >= length) {
    digits.reverse
  } else {
    val effectiveShift = (length - shift % length).toInt
    (digits.drop(effectiveShift) + digits.take(effectiveShift))
  }
}","    }
    def main(args: Array[String]) = {
    assert(circularShift((100l), (2l)).equals((""001"")));
    assert(circularShift((12l), (2l)).equals((""12"")));
    assert(circularShift((97l), (8l)).equals((""79"")));
    assert(circularShift((12l), (1l)).equals((""21"")));
    assert(circularShift((11l), (101l)).equals((""11"")));
    }

}
"
HumanEval_66,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //رموز ASCII.    //اكتب دالة تأخذ سلسلة كمدخل وتعيد مجموع الحروف العليا فقط    //مهمة    // >>> digitSum((""""))
    // (0l)
    // >>> digitSum((""abAB""))
    // (131l)
    // >>> digitSum((""abcCd""))
    // (67l)
    // >>> digitSum((""helloE""))
    // (69l)
    // >>> digitSum((""woArBld""))
    // (131l)
    // >>> digitSum((""aAaaaXa""))
    // (153l)
    def digitSum(s : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def digitSum(s: String): Long = {
    s.filter(_.isUpper).map(_.toLong).sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(digitSum(("""")) == (0l));
    assert(digitSum((""abAB"")) == (131l));
    assert(digitSum((""abcCd"")) == (67l));
    assert(digitSum((""helloE"")) == (69l));
    assert(digitSum((""woArBld"")) == (131l));
    assert(digitSum((""aAaaaXa"")) == (153l));
    assert(digitSum(("" How are yOu?"")) == (151l));
    assert(digitSum((""You arE Very Smart"")) == (327l));
    }

}
"
HumanEval_67,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //للقراءة:    //في السلة أعد عدد ثمار المانجو في السلة.    //البرتقال والتفاح والعدد الصحيح الذي يمثل العدد الإجمالي للفواكه    //تفاحة، برتقال، و فاكهة مانجو.    //التي يتم توزيعها في سلة من الفواكه هذه السلة تحتوي على     //في هذه المهمة، سيتم إعطائك سلسلة تمثل عدد من التفاح والبرتقال    // >>> fruitDistribution((""5 apples and 6 oranges""), (19l))
    // (8l)
    // >>> fruitDistribution((""0 apples and 1 oranges""), (3l))
    // (2l)
    // >>> fruitDistribution((""2 apples and 3 oranges""), (100l))
    // (95l)
    // >>> fruitDistribution((""100 apples and 1 oranges""), (120l))
    // (19l)
    def fruitDistribution(s : String, n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fruitDistribution(s: String, n: Long): Long = {
    val fruits = s.split("" and "").map(_.split("" "")(0).toLong)
    val totalApplesAndOranges = fruits.sum
    n - totalApplesAndOranges
  }
}","    }
    def main(args: Array[String]) = {
    assert(fruitDistribution((""5 apples and 6 oranges""), (19l)) == (8l));
    assert(fruitDistribution((""5 apples and 6 oranges""), (21l)) == (10l));
    assert(fruitDistribution((""0 apples and 1 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""1 apples and 0 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (100l)) == (95l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (5l)) == (0l));
    assert(fruitDistribution((""1 apples and 100 oranges""), (120l)) == (19l));
    }

}
"
HumanEval_68,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //المثال الأول:    //إذا لم تكن هناك قيم زوجية أو كانت القائمة المحددة فارغة، أعد [].    //يجب إرجاع العقدة المنتزعة في قائمة، [smallest_value، index ]،     //إذا تم العثور على عدة عقد بنفس القيمة الزوجية الأصغر، أعد العقدة التي لديها أصغر مؤشر.     //العقدة المنتزعة يجب أن تكون العقدة ذات أصغر قيمة زوجية.    //مهمتك هي أن تقطف واحدة من العقدة وتعيدها    //""منح قائمة تمثل فرع من شجرة التي لديها عقدة عدد صحيح غير سلبي    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> pluck((List[Long]()))
    // (List[Long]())
    // Example 4:
    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    def pluck(arr : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def pluck(arr: List[Long]): List[Long] = {
    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }
    if (evenNodes.isEmpty) {
      List.empty[Long]
    } else {
      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }
      List(smallestValue, index.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long]())).equals((List[Long]())));
    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));
    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_69,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //إذا لم تكن هناك قيمة كهذه، أعد -1.    //وتردد عدد صحيح هو عدد المرات التي يظهر فيها في القائمة.    //صفر، ولها تردد أكبر من أو يساوي قيمة العدد الصحيح نفسه.    //تم إعطائك قائمة غير فارغة من الأعداد الصحيحة الإيجابية أعد أكبر عدد صحيح أكبر من     // >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))
    // (2l)
    // >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (3l)
    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (-1l)
    def search(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def search(lst: List[Long]): Long = {
    val frequencyMap = lst.groupBy(identity).mapValues(_.size)
    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {
      case x :: _ => x
      case Nil => -1L
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));
    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));
    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));
    assert(search((List[Long](1l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));
    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));
    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));
    assert(search((List[Long](10l.toLong))) == (-1l));
    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));
    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));
    }

}
"
HumanEval_70,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //ثم الحد الأقصى من الأعداد الصحيحة المتبقية، ثم الحد الأدنى وهكذا.    //التفرقة الغريبة، هو عندما تبدأ مع الحد الأدنى من القيمة،     //إذا أعطيت قائمة بالأعداد الصحيحة، أعد القائمة بالترتيب الغريب.    // >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))
    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))
    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))
    // >>> strangeSortList((List[Long]()))
    // (List[Long]())
    def strangeSortList(lst : List[Long]) : List[Long] = {
","def strangeSortList(lst: List[Long]): List[Long] = {
    val buffer = lst.sorted.toBuffer
    val result = ArrayBuffer[Long]()
    var takeMin = true

    while (buffer.nonEmpty) {
      if (takeMin) {
        result += buffer.remove(0) // take the minimum
      } else {
        result += buffer.remove(buffer.length - 1) // take the maximum of the remaining
      }
      takeMin = !takeMin
    }

    result.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long]())).equals((List[Long]())));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));
    }

}
"
HumanEval_71,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //من الجانب الثالث    //ثلاثة جوانب تصنع مثلث صحيح عندما يكون مجموع جانبي أي أكبر    //وإلا ستعود -1    //المثلث المُستديرة إلى نقطتين عشريتين إذا كان الجانبين الثلاثة يشكلون مثلثًا صحيحًا.    //وبالنظر إلى طول الجوانب الثلاثة للمثلث، أعد مساحة    // >>> triangleArea((3l), (4l), (5l))
    // (6.0f)
    // >>> triangleArea((1l), (2l), (10l))
    // -1l
    def triangleArea(a : Long, b : Long, c : Long) : Float = {
","import scala.math._

object Problem {
  def triangleArea(a: Long, b: Long, c: Long): Float = {
    if (a + b > c && a + c > b && b + c > a) {
      val s = (a + b + c) / 2.0
      val area = sqrt(s * (s - a) * (s - b) * (s - c))
      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat
    } else {
      -1f
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((3l), (4l), (5l)) == (6.0f));
    assert(triangleArea((1l), (2l), (10l)) == -1l);
    assert(triangleArea((4l), (8l), (5l)) == (8.18f));
    assert(triangleArea((2l), (2l), (2l)) == (1.73f));
    assert(triangleArea((1l), (2l), (3l)) == -1l);
    assert(triangleArea((10l), (5l), (7l)) == (16.25f));
    assert(triangleArea((2l), (6l), (3l)) == -1l);
    assert(triangleArea((1l), (1l), (1l)) == (0.43f));
    assert(triangleArea((2l), (2l), (10l)) == -1l);
    }

}
"
HumanEval_72,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //سوف يطير الجسم q إذا كان متوازناً (إنه قائمة باليندرومية) ومجموع عناصرها أقل من أو يساوي الحد الأقصى للوزن الممكن w.    //اكتب دالة تعيد صحيحاً إذا كان الكائن q سوف يطير، وخاطئاً خلاف ذلك.     // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> willItFly((List[Long](3l.toLong)), (5l))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    def willItFly(q : List[Long], w : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def willItFly(q: List[Long], w: Long): Boolean = {
    val isPalindromic = q == q.reverse
    val sumOfElements = q.sum
    isPalindromic && sumOfElements <= w
  }

  def main(args: Array[String]): Unit = {
    println(willItFly(List[Long](1L, 2L), 5L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 1L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 9L)) // true
    println(willItFly(List[Long](3L), 5L)) // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));
    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));
    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));
    }

}
"
HumanEval_73,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //يقرأ نفس الشيء للخلف والعكس. في تغيير واحد، يمكنك تغيير عنصر واحد إلى أي عنصر آخر.    //يجب تغييرها لجعل القائمة متكاملة. القائمة المتكاملة هي قائمة     //مع إعطاء قائمة arr من الأعداد الصحيحة، ابحث عن الحد الأدنى من العناصر التي     // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))
    // (4l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))
    // (1l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))
    // (0l)
    def smallestChange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a list arr of integers, find the minimum number of elements that
  // need to be changed to make the list palindromic.

  def smallestChange(arr: List[Long]): Long = {
    var changes: Long = 0

    for (i <- 0 until arr.length / 2) {
      if (arr(i) != arr(arr.length - 1 - i)) {
        changes += 1
      }
    }

    changes
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  // Output: 4
    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  // Output: 1
    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  // Output: 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));
    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));
    assert(smallestChange((List[Long](1l.toLong))) == (0l));
    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));
    }

}
"
HumanEval_74,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //إذا كانت القائمتين لهما نفس عدد الأحرف، أعد القائمة الأولى.    //العدد الإجمالي للخطوط في كل سلسلة من القائمة أقل من القائمة الأخرى.    //اكتب دالة تقبل قائمتين من السلاسل وتعيد القائمة التي لديها     // >>> totalMatch((List[String]()), (List[String]()))
    // (List[String]())
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi"")))
    // (List[String](""hI"", ""Hi""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project"")))
    // (List[String](""hi"", ""admin""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi"")))
    // (List[String](""hI"", ""hi"", ""hi""))
    // >>> totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5"")))
    // (List[String](""4""))
    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {
    val sum1 = lst1.map(_.length).sum
    val sum2 = lst2.map(_.length).sum
    if (sum1 <= sum2) lst1 else lst2
  }
}","    }
    def main(args: Array[String]) = {
    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi""))).equals((List[String](""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5""))).equals((List[String](""4""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi""))).equals((List[String](""hI"", ""Hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi""))).equals((List[String](""hI"", ""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hii""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String]()), (List[String](""this""))).equals((List[String]())));
    assert(totalMatch((List[String](""this"")), (List[String]())).equals((List[String]())));
    }

}
"
HumanEval_75,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //مع العلم بأن (أ) أقل من 100    //و غير ذلك خاطئ    //اكتب دالة تعود بالصواب إذا كان العدد المحدد هو ضرب 3 أرقام أولية    // >>> isMultiplyPrime((30l))
    // (true)
    // 30 = 2 * 3 * 5
    def isMultiplyPrime(a : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isMultiplyPrime(a: Long): Boolean = {
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num <= 3) return true
      if (num % 2 == 0 || num % 3 == 0) return false
      var i = 5
      while (i * i <= num) {
        if (num % i == 0 || num % (i + 2) == 0) return false
        i += 6
      }
      true
    }

    val primes = (2L to 100L).filter(isPrime)
    val primeList = primes.toList

    for {
      i <- primeList.indices
      j <- i until primeList.size
      k <- j until primeList.size
      if primeList(i) * primeList(j) * primeList(k) == a
    } return true

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isMultiplyPrime((5l)) == (false));
    assert(isMultiplyPrime((30l)) == (true));
    assert(isMultiplyPrime((8l)) == (true));
    assert(isMultiplyPrime((10l)) == (false));
    assert(isMultiplyPrime((125l)) == (true));
    assert(isMultiplyPrime((105l)) == (true));
    assert(isMultiplyPrime((126l)) == (false));
    assert(isMultiplyPrime((729l)) == (false));
    assert(isMultiplyPrime((891l)) == (false));
    assert(isMultiplyPrime((1001l)) == (true));
    }

}
"
HumanEval_76,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //x هي قوة بسيطة من n إذا كان n**int=x     //قوة n و false في الحالات الأخرى.    //مهمتك هي كتابة دالة تعيد صحيحاً إذا كان العدد x هو     // >>> isSimplePower((1l), (4l))
    // (true)
    // >>> isSimplePower((2l), (2l))
    // (true)
    // >>> isSimplePower((8l), (2l))
    // (true)
    // >>> isSimplePower((3l), (2l))
    // (false)
    // >>> isSimplePower((3l), (1l))
    // (false)
    // >>> isSimplePower((5l), (3l))
    // (false)
    def isSimplePower(x : Long, n : Long) : Boolean = {
","def isSimplePower(x: Long, n: Long): Boolean = {
        if (n == 1) {
            return x == 1
        }
        
        var value: Long = n
        while (value <= x) {
            if (value == x) {
                return true
            }
            
            if (value > Long.MaxValue / n) {
                return false
            }
            value *= n
        }
        
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(isSimplePower((16l), (2l)) == (true));
    assert(isSimplePower((143214l), (16l)) == (false));
    assert(isSimplePower((4l), (2l)) == (true));
    assert(isSimplePower((9l), (3l)) == (true));
    assert(isSimplePower((16l), (4l)) == (true));
    assert(isSimplePower((24l), (2l)) == (false));
    assert(isSimplePower((128l), (4l)) == (false));
    assert(isSimplePower((12l), (6l)) == (false));
    assert(isSimplePower((1l), (1l)) == (true));
    assert(isSimplePower((1l), (12l)) == (true));
    }

}
"
HumanEval_77,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //ملاحظة: يمكنك أن تفترض أن المدخلات صالحة دائماً.    //إذا كان هذا المكعب مكعب لعدد صحيح    //اكتب دالة تأخذ عدد صحيح a وتعود true    // >>> iscube((1l))
    // (true)
    // >>> iscube((2l))
    // (false)
    // >>> iscube((-1l))
    // (true)
    // >>> iscube((64l))
    // (true)
    // >>> iscube((0l))
    // (true)
    // >>> iscube((180l))
    // (false)
    def iscube(a : Long) : Boolean = {
","def iscube(a: Long): Boolean = {
  val cubeRoot = math.cbrt(a.toDouble).round
  cubeRoot * cubeRoot * cubeRoot == a
}","    }
    def main(args: Array[String]) = {
    assert(iscube((1l)) == (true));
    assert(iscube((2l)) == (false));
    assert(iscube((-1l)) == (true));
    assert(iscube((64l)) == (true));
    assert(iscube((180l)) == (false));
    assert(iscube((1000l)) == (true));
    assert(iscube((0l)) == (true));
    assert(iscube((1729l)) == (false));
    }

}
"
HumanEval_78,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //والرموز A,B,C,D,E,F دائماً كبيرة    //ملاحظة: يمكنك أن تفترض أن المدخلات صحيحة دائماً أو فارغة    //B (= عشري 11) ، D (= عشري 13).    //لذا عليك ان تحدد عدد من الارقام التالية: 2، 3، 5، 7،     //الأعداد الأولية هي 2، 3، 5، 7، 11، 13، 17، ...    //الأرقام السداسية العشرية هي 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، أ، ب، ج، د، إي، ف.    //أكبر من 1 والتي ليست ناتج من عددين طبيعيين أصغر).    //الأرقام التي هي أساسية (عدد أساسي، أو أساسي، هو عدد طبيعي     //رقم عشري عشري كسلسلة ويعد عدد عشري عشري عشري    //لقد تم تكليفك بكتابة دالة تستقبل    // >>> hexKey((""AB""))
    // (1l)
    // >>> hexKey((""1077E""))
    // (2l)
    // >>> hexKey((""ABED1A33""))
    // (4l)
    // >>> hexKey((""123456789ABCDEF0""))
    // (6l)
    // >>> hexKey((""2020""))
    // (2l)
    def hexKey(num : String) : Long = {
","def hexKey(num: String): Long = {
  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')
  num.count(ch => primeHexDigits.contains(ch)).toLong
}","    }
    def main(args: Array[String]) = {
    assert(hexKey((""AB"")) == (1l));
    assert(hexKey((""1077E"")) == (2l));
    assert(hexKey((""ABED1A33"")) == (4l));
    assert(hexKey((""2020"")) == (2l));
    assert(hexKey((""123456789ABCDEF0"")) == (6l));
    assert(hexKey((""112233445566778899AABBCCDDEEFF00"")) == (12l));
    }

}
"
HumanEval_79,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //الحروف الإضافية هناك للمساعدة في التنسيق.    //سيكون هناك زوجين إضافيين من الأحرف ""db"" في بداية و نهاية السلسلة.    //كل حرف في السلسلة سيكون ""0"" أو ""1"".    //النموذج الثنائي. يجب أن تعيد الدالة سلسلة، مع كل حرف يمثل ثنائي     //سيتم إعطائك رقم في شكل عشري و مهمتك هي تحويله إلى     // >>> decimalToBinary((15l))
    // (""db1111db"")
    // >>> decimalToBinary((32l))
    // (""db100000db"")
    def decimalToBinary(decimal : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def decimalToBinary(decimal: Long): String = {
    ""db"" + decimal.toBinaryString + ""db""
  }
}","    }
    def main(args: Array[String]) = {
    assert(decimalToBinary((0l)).equals((""db0db"")));
    assert(decimalToBinary((32l)).equals((""db100000db"")));
    assert(decimalToBinary((103l)).equals((""db1100111db"")));
    assert(decimalToBinary((15l)).equals((""db1111db"")));
    }

}
"
HumanEval_80,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //السلسلة هي هابسكالا إذا كان طولها 3 على الأقل وكل 3 حروف متتالية متميزة    //مهمتك هي التحقق من أن السلسلة هي هابسكالا أم لا.    //تم إعطائك سلسلة من السلاسل    // >>> isHappy((""a""))
    // (false)
    // >>> isHappy((""aa""))
    // (false)
    // >>> isHappy((""abcd""))
    // (true)
    // >>> isHappy((""aabb""))
    // (false)
    // >>> isHappy((""adb""))
    // (true)
    // >>> isHappy((""xyy""))
    // (false)
    def isHappy(s : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isHappy(s: String): Boolean = {
    if (s.length < 3) return false 

    for (i <- 0 until s.length - 2) {
      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {
        return false
      }
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isHappy((""a"")) == (false));
    assert(isHappy((""aa"")) == (false));
    assert(isHappy((""abcd"")) == (true));
    assert(isHappy((""aabb"")) == (false));
    assert(isHappy((""adb"")) == (true));
    assert(isHappy((""xyy"")) == (false));
    assert(isHappy((""iopaxpoi"")) == (true));
    assert(isHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //0.0 E     //> 0.0 D-     //> 0.7 D     //> 1.0 D+     //> 1.3 C-     //> 1.7 درجة مئوية    //> 2.0 C+     //> 2.3 B-     //> 2.7 B     //> 3.0 B+     //> 3.3 A-     //> 3.7 A     //4.0 A+     //معدل المعدل، درجة الحروف    //وظيفة يمكنها إظهار قائمة من درجات الحروف باستخدام الجدول التالي:     //لقد أعطتك قائمة بمعدلات بعض الطلاب وعليك أن تكتب    //المشكلة الوحيدة هي أنها فقدت الرمز الذي استخدمته لتقييمها    //إلى الطلاب. لقد كان المعلم يصنع خوارزميته الخاصة لتقييم.    //إنه الأسبوع الأخير من الفصل الدراسي و المعلم عليه أن يعطي الدرجات    // >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))
    // (List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))
    def numericalLetterGrade(grades : List[Float]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def numericalLetterGrade(grades: List[Float]): List[String] = {
    grades.map { gpa =>
      gpa match {
        case g if g == 4.0 => ""A+""
        case g if g > 3.7 => ""A""
        case g if g > 3.3 => ""A-""
        case g if g > 3.0 => ""B+""
        case g if g > 2.7 => ""B""
        case g if g > 2.3 => ""B-""
        case g if g > 2.0 => ""C+""
        case g if g > 1.7 => ""C""
        case g if g > 1.3 => ""C-""
        case g if g > 1.0 => ""D+""
        case g if g > 0.7 => ""D""
        case g if g > 0.0 => ""D-""
        case _ => ""E""
      }
    }
  }

  def main(args: Array[String]): Unit = {
    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)
    println(numericalLetterGrade(grades)) // Output: List(A+, B, C-, C, A-)
  }
}","    }
    def main(args: Array[String]) = {
    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))));
    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](""D+""))));
    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](""D-""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](""E""))));
    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](""D"", ""D-"", ""C-"", ""B"", ""B+""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](""E"", ""D-""))));
    }

}
"
HumanEval_82,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //طول هو عدد أولي أو خطأ خلاف ذلك    //اكتب دالة تأخذ سلسلة وتعود true إذا كانت السلسلة     // >>> primeLength((""Hello""))
    // (true)
    // >>> primeLength((""abcdcba""))
    // (true)
    // >>> primeLength((""kittens""))
    // (true)
    // >>> primeLength((""orange""))
    // (false)
    def primeLength(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeLength(string: String): Boolean = {
    val length = string.length

    if (length <= 1) return false
    
    for (i <- 2 to sqrt(length).toInt) {
      if (length % i == 0) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeLength((""Hello"")) == (true));
    assert(primeLength((""abcdcba"")) == (true));
    assert(primeLength((""kittens"")) == (true));
    assert(primeLength((""orange"")) == (false));
    assert(primeLength((""wow"")) == (true));
    assert(primeLength((""world"")) == (true));
    assert(primeLength((""MadaM"")) == (true));
    assert(primeLength((""Wow"")) == (true));
    assert(primeLength(("""")) == (false));
    assert(primeLength((""HI"")) == (true));
    assert(primeLength((""go"")) == (true));
    assert(primeLength((""gogo"")) == (false));
    assert(primeLength((""aaaaaaaaaaaaaaa"")) == (false));
    assert(primeLength((""Madam"")) == (true));
    assert(primeLength((""M"")) == (false));
    assert(primeLength((""0"")) == (false));
    }

}
"
HumanEval_83,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //الأعداد الصحيحة الإيجابية التي تبدأ أو تنتهي بـ 1    //مع إعطاء عدد صحيح موجب n، أعد عد الأرقام من n خانة     def startsOneEnds(n : Long) : Long = {
","def startsOneEnds(n: Long): Long = {
        if (n <= 0) return 0
        
        // Calculate numbers starting with 1: 1XX...X (n-1) digits after 1
        val startWithOne: Long = math.pow(10, n - 1).toLong
        
        // Calculate numbers ending with 1: XX...X1 (n-1) digits before 1
        // but without leading zeroes allowed, i.e., the first digit can't be zero
        val endWithOne: Long = math.pow(10, n - 1).toLong
        
        // Reverse counting: numbers starting and ending with 1 (11XX...X)
        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0
        
        // The total numbers starting or ending, or both, with 1
        startWithOne + endWithOne - bothStartAndEndWithOne
    }
}","    }
    def main(args: Array[String]) = {
    assert(startsOneEnds((1l)) == (1l));
    assert(startsOneEnds((2l)) == (18l));
    assert(startsOneEnds((3l)) == (180l));
    assert(startsOneEnds((4l)) == (1800l));
    assert(startsOneEnds((5l)) == (18000l));
    }

}
"
HumanEval_84,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال     //مع إعطاء عدد صحيح إيجابي N، أعد مجموع أرقامه في النموذج الثنائي.     // >>> solve((1000l))
    // (""1"")
    // >>> solve((150l))
    // (""110"")
    // >>> solve((147l))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    def solve(N : Long) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Given a positive integer N, return the total sum of its digits in binary.
    def solve(N: Long): String = {
        val sumOfDigits = N.toString.map(_.asDigit).sum
        sumOfDigits.toBinaryString
    }

    def main(args: Array[String]): Unit = {
        println(solve(1000L))  // should print ""1""
        println(solve(150L))   // should print ""110""
        println(solve(147L))   // should print ""1100""
    }
}","    }
    def main(args: Array[String]) = {
    assert(solve((1000l)).equals((""1"")));
    assert(solve((150l)).equals((""110"")));
    assert(solve((147l)).equals((""1100"")));
    assert(solve((333l)).equals((""1001"")));
    assert(solve((963l)).equals((""10010"")));
    }

}
"
HumanEval_85,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //مع إعطاء قائمة غير فارغة من الأعداد الصحيحة أولاً أضف العناصر الزوجية التي في المؤشرات الفردية    // >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))
    // (2l)
    def add(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a non-empty list of integers lst. add the even elements that are at odd indices.
  def add(lst: List[Long]): Long = {
    lst.zipWithIndex.collect {
      case (value, index) if index % 2 == 1 && value % 2 == 0 => value
    }.sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));
    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));
    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));
    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));
    }

}
"
HumanEval_86,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //ملاحظة: يجب أن تحافظ على ترتيب الكلمات والمساحات الفارغة في الجملة.    //ترتيب تصاعدي بناء على قيمة ASCII    //يتم استبدالها بكلمة جديدة حيث يتم ترتيب جميع الأحرف في    //النسخة المرتبة من السلسلة، هي سلسلة حيث كل الكلمات (مفصولة عن طريق الفراغ)    //اكتب دالة تأخذ سلسلة وأرجع نسخة مرتبة منها.    // >>> antiShuffle((""Hi""))
    // (""Hi"")
    // >>> antiShuffle((""hello""))
    // (""ehllo"")
    // >>> antiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    def antiShuffle(s : String) : String = {
","import scala.collection.mutable.ArrayBuffer

object Problem {
  def antiShuffle(s: String): String = {
    val words = s.split(""(?<=\\s)"")
    val sortedWords = words.map(word => {
      val trimmedWord = word.trim
      val sortedChars = trimmedWord.sorted
      word.replace(trimmedWord, sortedChars)
    })
    sortedWords.mkString("""")
  }

  def main(args: Array[String]): Unit = {
    println(antiShuffle(""Hi""))
    println(antiShuffle(""hello""))
    println(antiShuffle(""Hello World!!!""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(antiShuffle((""Hi"")).equals((""Hi"")));
    assert(antiShuffle((""hello"")).equals((""ehllo"")));
    assert(antiShuffle((""number"")).equals((""bemnru"")));
    assert(antiShuffle((""abcd"")).equals((""abcd"")));
    assert(antiShuffle((""Hello World!!!"")).equals((""Hello !!!Wdlor"")));
    assert(antiShuffle(("""")).equals(("""")));
    assert(antiShuffle((""Hi. My name is Mister Robot. How are you?"")).equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //أيضا، ترتيب إحداثيات الصف من خلال الأعمدة في ترتيب هبوطي.    //ترتيب الإحداثيات في البداية بالصفوف بالترتيب المتصاعد    //كل توبل هو إحداثي - (صف، أعمدة) ، بدءا من 0.    //ويعود قائمة من التوبلات، [(x1، y1، (x2، y2) ...) مثل أن     //مع إعطاء lst، والعدد الصحيح x، ابحث عن الأعداد الصحيحة x في القائمة،     //يمكن لكل صف أن يحتوي على عدد مختلف من الأعمدة.    //وهو مشابه للمصفوفة، ولكن على عكس المصفوفات،    //يتم إعطائك بيانات ثنائية الأبعاد، كقوائم متداخلة،     // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))
    // (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))
    // >>> getRow((List[List[Long]]()), (1l))
    // (List[Tuple2[Long, Long]]())
    // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))
    // (List[Tuple2[Long, Long]]((2l, 2l)))
    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {
    val coordinates = for {
      (row, rowIndex) <- lst.zipWithIndex
      (value, colIndex) <- row.zipWithIndex
      if value == x
    } yield (rowIndex.toLong, colIndex.toLong)

    coordinates
      .groupBy(_._1)
      .toList
      .sortBy(_._1)
      .flatMap { case (rowIndex, coords) =>
        coords.sortBy(-_._2)
      }
  }
}","    }
    def main(args: Array[String]) = {
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));
    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));
    }

}
"
HumanEval_88,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //* لا تغير القائمة المقدمة.    //ملاحظة:    //أو ترتيبها بالترتيب الهبوطي إذا كان مجموع ((قيمة المؤشر الأولى، قيمة المؤشر الأخيرة) زوجية.    //سوف تقوم بتصنيف القائمة المحددة بالترتيب الصاعد إذا كانت مجموع ((قيمة المؤشر الأولى، قيمة المؤشر الأخيرة) غير عادية،     //مع إعطاء قائمة من الأعداد الصحيحة غير السالبة، أعيد كوسكالا من القائمة المحددة بعد فرزها،     // >>> sortArray((List[Long]()))
    // (List[Long]())
    // >>> sortArray((List[Long](5l.toLong)))
    // (List[Long](5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))
    def sortArray(array : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def sortArray(array: List[Long]): List[Long] = {
    if (array.isEmpty) {
      array
    } else {
      val first = array.head
      val last = array.last
      val sum = first + last
      if (sum % 2 == 0) {
        array.sorted(Ordering[Long].reverse)
      } else {
        array.sorted
      }
    }
  }

  def main(args: Array[String]): Unit = {
    println(sortArray(List[Long]())) // (List[Long]())
    println(sortArray(List[Long](5L))) // (List[Long](5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) // (List[Long](0L, 1L, 2L, 3L, 4L, 5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) // (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));
    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));
    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));
    }

}
"
HumanEval_89,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //انخفض بمقدار اثنين مضروبة في مكانين    //يجب أن يتم تدوير الأبجدية بطريقة تجعل الحروف    //يعيد سلسلة مشفرة مع تدوير الأبجدية.    //إنشاء تشفير وظيفة تأخذ سلسلة كحجة و     // >>> encrypt((""hi""))
    // (""lm"")
    // >>> encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> encrypt((""gf""))
    // (""kj"")
    // >>> encrypt((""et""))
    // (""ix"")
    def encrypt(s : String) : String = {
","def encrypt(s: String): String = {
  s.map(c => {
    val rotatedChar = (c - 'a' + 4) % 26 + 'a'
    rotatedChar.toChar
  })
}","    }
    def main(args: Array[String]) = {
    assert(encrypt((""hi"")).equals((""lm"")));
    assert(encrypt((""asdfghjkl"")).equals((""ewhjklnop"")));
    assert(encrypt((""gf"")).equals((""kj"")));
    assert(encrypt((""et"")).equals((""ix"")));
    assert(encrypt((""faewfawefaewg"")).equals((""jeiajeaijeiak"")));
    assert(encrypt((""hellomyfriend"")).equals((""lippsqcjvmirh"")));
    assert(encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    assert(encrypt((""a"")).equals((""e"")));
    }

}
"
HumanEval_90,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ارجع لا شيء إذا لم يكن هناك عنصر من هذا القبيل.    //اكتب دالة next_smallest (() التي تعيد ثاني أصغر عنصر في القائمة.     //تعطى لك قائمة من الأعداد الصحيحة    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long]()))
    // None
    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))
    // None
    def nextSmallest(lst : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def nextSmallest(lst: List[Long]): Option[Long] = {
    if (lst.size < 2) return None

    val distinctSorted = lst.distinct.sorted
    if (distinctSorted.size < 2) None
    else Some(distinctSorted(1))
  }
}","    }
    def main(args: Array[String]) = {
    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long]())).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));
    }

}
"
HumanEval_91,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //يتم تقسيم الجمل بواسطة """"، ""؟"" أو ""!""    //الملل هو جملة تبدأ بكلمة ""أنا""    //سوف تعطى لك سلسلة من الكلمات، ومهمتك هي أن تحسب العدد.    // >>> isBored((""Hello world""))
    // (0l)
    // >>> isBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1l)
    def isBored(S : String) : Long = {
","def isBored(S: String): Long = {
    // Split the input string into sentences using '.', '?' or '!' as delimiters
    val sentences = S.split(""[.!?]"").map(_.trim)

    // Filter sentences that start with 'I' and count them
    sentences.count(sentence => sentence.startsWith(""I""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(isBored((""Hello world"")) == (0l));
    assert(isBored((""Is the sky blue?"")) == (0l));
    assert(isBored((""I love It !"")) == (1l));
    assert(isBored((""bIt"")) == (0l));
    assert(isBored((""I feel good today. I will be productive. will kill It"")) == (2l));
    assert(isBored((""You and I are going for a walk"")) == (0l));
    }

}
"
HumanEval_92,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //يعود خطأ في أي حالات أخرى.    //يعيد صحيحاً إذا كان أحد الأرقام يساوي مجموع الأرقام الأخرى، وجميع الأرقام هي أعداد صحيحة.    //قم بإنشاء دالة تأخذ 3 أرقام    // >>> anyInt(5l, 2l, 7l)
    // (true)
    // >>> anyInt(3l, 2l, 2l)
    // (false)
    // >>> anyInt(3l, -2l, 1l)
    // (true)
    // >>> anyInt((3.6f), (-2.2f), 2l)
    // (false)
    def anyInt(x : Float, y : Float, z : Float) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Create a function that takes 3 numbers.
  // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
  // Returns false in any other cases.
  def anyInt(x: Float, y: Float, z: Float): Boolean = {
    val xLong = x.toLong
    val yLong = y.toLong
    val zLong = z.toLong

    // Check if all inputs are actually integers
    if (xLong == x && yLong == y && zLong == z) {
      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong
    }
    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(anyInt(2l, 3l, 1l) == (true));
    assert(anyInt((2.5f), 2l, 3l) == (false));
    assert(anyInt((1.5f), 5l, (3.5f)) == (false));
    assert(anyInt(2l, 6l, 2l) == (false));
    assert(anyInt(4l, 2l, 2l) == (true));
    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));
    assert(anyInt(-4l, 6l, 2l) == (true));
    assert(anyInt(2l, 1l, 1l) == (true));
    assert(anyInt(3l, 4l, 7l) == (true));
    assert(anyInt((3.0f), 4l, 7l) == (false));
    }

}
"
HumanEval_93,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //افترض الحروف فقط    //حرف في الأبجدية الإنجليزية    //الرسالة التي تحتوي على الحرف الذي يظهر في المرتبة الثانية    //بطريقة تغير الحروف، وتستبدل جميع الحروف العلوية في    //اكتب دالة تأخذ رسالة، وتقوم بتشفيرها في مثل هذه    // >>> encode((""test""))
    // (""TGST"")
    // >>> encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    def encode(message : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def encode(message: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    val vowelMap = Map(
      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',
      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'
    )
    
    message.map { char =>
      if (vowels.contains(char)) {
        vowelMap(char)
      } else if (char.isLetter) {
        if (char.isLower) char.toUpper else char.toLower
      } else {
        char
      }
    }.mkString
  }

  // Test cases
  def main(args: Array[String]): Unit = {
    println(encode(""test""))            // should print ""TGST""
    println(encode(""This is a message"")) // should print ""tHKS KS C MGSSCGG""
  }
}","    }
    def main(args: Array[String]) = {
    assert(encode((""TEST"")).equals((""tgst"")));
    assert(encode((""Mudasir"")).equals((""mWDCSKR"")));
    assert(encode((""YES"")).equals((""ygs"")));
    assert(encode((""This is a message"")).equals((""tHKS KS C MGSSCGG"")));
    assert(encode((""I DoNt KnOw WhAt tO WrItE"")).equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //تحتاج إلى العثور على أكبر قيمة رئيسية وإرجاع مجموع أرقامها.    //تعطى لك قائمة من الأعداد الصحيحة    // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))
    // (10l)
    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))
    // (25l)
    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))
    // (13l)
    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))
    // (11l)
    // >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))
    // (3l)
    // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))
    // (7l)
    def skjkasdkd(lst : List[Long]) : Long = {
","def skjkasdkd(lst: List[Long]): Long = {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) false
    else if (n == 2) true
    else if (n % 2 == 0) false
    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)
  }

  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum

  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)
  sumOfDigits(largestPrime)
}","    }
    def main(args: Array[String]) = {
    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));
    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));
    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));
    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));
    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));
    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));
    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));
    }

}
"
HumanEval_95,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //يجب أن تعيد الدالة false إذا كانت الخريطة المحددة فارغة.     //الحالة أو كل المفاتيح هي سلسلة بحرف كبير، وإلا فإنها تعود false.    //نظراً لخريطة، أعيد صحيح إذا كانت جميع المفاتيح هي سلاسل في أقل     // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""b"" -> ""banana"")))
    // (true)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""A"" -> ""banana"", ""B"" -> ""banana"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", 8l -> ""banana"", ""a"" -> ""apple"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345"")))
    // (true)
    def checkDictCase(dict : Map[String,String]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def checkDictCase(dict: Map[String, String]): Boolean = {
    if (dict.isEmpty) return false

    val keys = dict.keys.toList
    val allLowerCase = keys.forall(key => key == key.toLowerCase)
    val allUpperCase = keys.forall(key => key == key.toUpperCase)

    allLowerCase || allUpperCase
  }
}","    }
    def main(args: Array[String]) = {
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""b"" -> ""banana""))) == (true));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""A"" -> ""banana"", ""B"" -> ""banana""))) == (false));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""5"" -> ""banana"", ""a"" -> ""apple""))) == (false));
    assert(checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston""))) == (false));
    assert(checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345""))) == (true));
    assert(checkDictCase((Map[String,String](""fruit"" -> ""Orange"", ""taste"" -> ""Sweet""))) == (true));
    assert(checkDictCase((Map[String,String]())) == (false));
    }

}
"
HumanEval_96,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //الأعداد الصحيحة التي هي أرقام أولية وأقل من n.    //تنفيذ دالة تأخذ عدداً صحيحاً غير سلبي وتعيد قائمة بأول n     // >>> countUpTo((5l))
    // (List[Long](2l.toLong, 3l.toLong))
    // >>> countUpTo((11l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))
    // >>> countUpTo((0l))
    // (List[Long]())
    // >>> countUpTo((20l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))
    // >>> countUpTo((1l))
    // (List[Long]())
    // >>> countUpTo((18l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))
    def countUpTo(n : Long) : List[Long] = {
","def countUpTo(n: Long): List[Long] = {
    def isPrime(num: Long): Boolean = {
      if (num < 2) return false
      for (i <- 2L to math.sqrt(num).toLong) {
        if (num % i == 0) return false
      }
      true
    }

    (2L until n).filter(isPrime).map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));
    assert(countUpTo((0l)).equals((List[Long]())));
    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));
    assert(countUpTo((1l)).equals((List[Long]())));
    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));
    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));
    }

}
"
HumanEval_97,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //افترض أن المدخلات صالحة دائماً    //ضرب أرقام وحداتهم    //أكمل الدالة التي تأخذ رقمين صحيحين وتعود     // >>> multiply((148l), (412l))
    // (16l)
    // >>> multiply((19l), (28l))
    // (72l)
    // >>> multiply((2020l), (1851l))
    // (0l)
    // >>> multiply((14l), (-15l))
    // (20l)
    def multiply(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def multiply(a: Long, b: Long): Long = {
        val unitDigitA = abs(a % 10)
        val unitDigitB = abs(b % 10)
        unitDigitA * unitDigitB
    }

    def main(args: Array[String]): Unit = {
        println(multiply(148l, 412l))  // 16l
        println(multiply(19l, 28l))    // 72l
        println(multiply(2020l, 1851l)) // 0l
        println(multiply(14l, -15l))   // 20l
    }
}","    }
    def main(args: Array[String]) = {
    assert(multiply((148l), (412l)) == (16l));
    assert(multiply((19l), (28l)) == (72l));
    assert(multiply((2020l), (1851l)) == (0l));
    assert(multiply((14l), (-15l)) == (20l));
    assert(multiply((76l), (67l)) == (42l));
    assert(multiply((17l), (27l)) == (49l));
    assert(multiply((0l), (1l)) == (0l));
    assert(multiply((0l), (0l)) == (0l));
    }

}
"
HumanEval_98,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //مع إعطاء سلسلة s، عد عدد الحروف العليا في الحروف العادية.    // >>> countUpper((""aBCdEf""))
    // (1l)
    // >>> countUpper((""abcdefg""))
    // (0l)
    // >>> countUpper((""dBBE""))
    // (0l)
    def countUpper(s : String) : Long = {
","def countUpper(s: String): Long = {
  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')
  s.zipWithIndex.collect {
    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch
  }.size.toLong
}","    }
    def main(args: Array[String]) = {
    assert(countUpper((""aBCdEf"")) == (1l));
    assert(countUpper((""abcdefg"")) == (0l));
    assert(countUpper((""dBBE"")) == (0l));
    assert(countUpper((""B"")) == (0l));
    assert(countUpper((""U"")) == (1l));
    assert(countUpper(("""")) == (0l));
    assert(countUpper((""EEEE"")) == (2l));
    }

}
"
HumanEval_99,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //من اثنين من الأعداد الصحيحة، تقريب بعيدا عن الصفر.    //ويعود أقرب عدد صحيح له. إذا كان العدد متساوياً    //إنشاء دالة تأخذ قيمة (سلسلة) تمثل رقم     // >>> closestInteger((""10""))
    // (10l)
    // >>> closestInteger((""15.3""))
    // (15l)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    def closestInteger(value : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def closestInteger(value: String): Long = {
    val num = value.toDouble
    val lower = floor(num).toLong
    val upper = ceil(num).toLong
    
    if (abs(num - lower) == abs(num - upper)) {
      if (num > 0) upper else lower
    } else {
      round(num)
    }
  }

  def main(args: Array[String]): Unit = {
    println(closestInteger(""10""))  // 10
    println(closestInteger(""15.3"")) // 15
    println(closestInteger(""14.5"")) // 15
    println(closestInteger(""-14.5"")) // -15
  }
}","    }
    def main(args: Array[String]) = {
    assert(closestInteger((""10"")) == (10l));
    assert(closestInteger((""14.5"")) == (15l));
    assert(closestInteger((""-15.5"")) == (-16l));
    assert(closestInteger((""15.3"")) == (15l));
    assert(closestInteger((""0"")) == (0l));
    }

}
"
HumanEval_100,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //i يمثل عدد الحجارة في المستوى (i+1).    //يعيد عدد الأحجار في كل مستوى في قائمة، حيث عنصر في المؤشر     //- الرقم الزوج التالي إذا كان n زوجاً.    //- العدد الفرد التالي إذا كان n فردياً.    //عدد الأحجار في المستوى التالي هو:    //المستوى الأول له n حجر    //إذا أعطيت عدداً صحيحاً موجباً n، عليك أن تصنع كومة من n مستوى من الحجارة.    // >>> makeAPile((3l))
    // (List[Long](3l.toLong, 5l.toLong, 7l.toLong))
    def makeAPile(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
    def makeAPile(n: Long): List[Long] = {
        val pile = ListBuffer[Long]()
        var currentStones = n
        for (_ <- 0 until n.toInt) {
            pile += currentStones
            currentStones += (if (currentStones % 2 == 0) 2 else 2)
        }
        pile.toList
    }

    def main(args: Array[String]): Unit = {
        val result = makeAPile(3L)
        println(result)
    }
}","    }
    def main(args: Array[String]) = {
    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));
    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));
    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));
    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));
    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));
    }

}
"
HumanEval_101,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //لتقسيم السلسلة إلى كلمات وإرجاع قائمة الكلمات.    //ستحصل على سلسلة من الكلمات مفصولة بالفواصل أو الفراغات    // >>> wordsString((""Hi, my name is John""))
    // (List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))
    // >>> wordsString((""One, two, three, four, five, six""))
    // (List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))
    def wordsString(s : String) : List[String] = {
","def wordsString(s: String): List[String] = {
    s.split(""[, ]+"").toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(wordsString((""Hi, my name is John"")).equals((List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))));
    assert(wordsString((""One, two, three, four, five, six"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString((""Hi, my name"")).equals((List[String](""Hi"", ""my"", ""name""))));
    assert(wordsString((""One,, two, three, four, five, six,"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString(("""")).equals((List[String]())));
    assert(wordsString((""ahmed     , gamal"")).equals((List[String](""ahmed"", ""gamal""))));
    }

}
"
HumanEval_102,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //إذا لم يكن هناك مثل هذا الرقم، فإن الدالة يجب أن تعود -1    //أكبر عدد صحيح زوج في النطاق [x، y] شامل. إذا     //هذه الدالة تأخذ رقمين إيجابيين x و y وتعيد     // >>> chooseNum((12l), (15l))
    // (14l)
    // >>> chooseNum((13l), (12l))
    // (-1l)
    def chooseNum(x : Long, y : Long) : Long = {
","def chooseNum(x: Long, y: Long): Long = {
    // Ensure x is the lesser value and y is the greater value
    val (start, end) = if (x > y) (y, x) else (x, y)
    
    // Start from the end of the range and search backwards for an even number
    for (i <- end to start by -1 if i % 2 == 0) {
      return i
    }
    
    // If no even number is found, return -1
    -1
  }
}","    }
    def main(args: Array[String]) = {
    assert(chooseNum((12l), (15l)) == (14l));
    assert(chooseNum((13l), (12l)) == (-1l));
    assert(chooseNum((33l), (12354l)) == (12354l));
    assert(chooseNum((5234l), (5233l)) == (-1l));
    assert(chooseNum((6l), (29l)) == (28l));
    assert(chooseNum((27l), (10l)) == (-1l));
    assert(chooseNum((7l), (7l)) == (-1l));
    assert(chooseNum((546l), (546l)) == (546l));
    }

}
"
HumanEval_103,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //إذا كان n أكبر من m، أعد -1.    //قم بتقريب الجواب إلى أقرب عدد صحيح و قم بتحويله إلى ثنائي    //متوسط الأعداد الصحيحة من n إلى m (بما في ذلك n و m).    //تم إعطائك عددين صحيحين إيجابيين n و m، ومهمتك هي حساب     // >>> roundedAvg((1l), (5l))
    // ""0b11""
    // >>> roundedAvg((7l), (5l))
    // -1l
    // >>> roundedAvg((10l), (20l))
    // ""0b1111""
    // >>> roundedAvg((20l), (33l))
    // ""0b11010""
    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  // Function to compute the average of the integers from n through m
  def roundedAvg(n: Long, m: Long): Either[String, Long] = {
    if (n > m) {
      Right(-1L)
    } else {
      val count = m - n + 1
      val sum = (n + m) * count / 2
      val average = round(sum.toDouble / count)
      Left(""0b"" + average.toLong.toBinaryString)
    }
  }

  def main(args: Array[String]): Unit = {
    println(roundedAvg(1L, 5L))    // Left(""0b11"")
    println(roundedAvg(7L, 5L))    // Right(-1L)
    println(roundedAvg(10L, 20L))  // Left(""0b1111"")
    println(roundedAvg(20L, 33L))  // Left(""0b11010"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(roundedAvg((1l), (5l)).equals(""0b11""));
    assert(roundedAvg((7l), (13l)).equals(""0b1010""));
    assert(roundedAvg((964l), (977l)).equals(""0b1111001010""));
    assert(roundedAvg((996l), (997l)).equals(""0b1111100100""));
    assert(roundedAvg((560l), (851l)).equals(""0b1011000010""));
    assert(roundedAvg((185l), (546l)).equals(""0b101101110""));
    assert(roundedAvg((362l), (496l)).equals(""0b110101101""));
    assert(roundedAvg((350l), (902l)).equals(""0b1001110010""));
    assert(roundedAvg((197l), (233l)).equals(""0b11010111""));
    assert(roundedAvg((7l), (5l)).equals(-1l));
    assert(roundedAvg((5l), (1l)).equals(-1l));
    assert(roundedAvg((5l), (5l)).equals(""0b101""));
    }

}
"
HumanEval_104,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //ملاحظة: يجب ترتيب القائمة المرجعة بالترتيب المتزايد.    //عناصر ليس لها أي رقم زوج.    //مع إعطاء قائمة من الأعداد الصحيحة الإيجابية x. أعد قائمة مرتبة من جميع     // >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))
    // (List[Long](1l.toLong, 15l.toLong, 33l.toLong))
    // >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))
    // (List[Long]())
    def uniqueDigits(x : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def uniqueDigits(x: List[Long]): List[Long] = {
    def hasEvenDigit(n: Long): Boolean = {
      n.toString.exists(c => (c - '0') % 2 == 0)
    }

    x.filterNot(hasEvenDigit).sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))
    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));
    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));
    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));
    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));
    }

}
"
HumanEval_105,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //واحد، اثنان، ثلاثة، أربعة، خمسة، ستة، سبعة، ثمانية، تسعة    //عكس القائمة الناتجة، ثم استبدال كل رقم باسمه المقابل من     //مع إعطاء قائمة بالأعداد الصحيحة، قم بترتيب الأعداد الصحيحة التي تتراوح بين 1 و 9،    // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))
    // (List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))
    // If the list is empty, return an empty list:
    // >>> byLength((List[Long]()))
    // (List[String]())
    // If the list has any strange number ignore it:
    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))
    // (List[String](""One""))
    def byLength(arr : List[Long]) : List[String] = {
","import scala.collection.mutable._

object Problem {
  def byLength(arr: List[Long]): List[String] = {
    // Map of digit to its corresponding name
    val numToName = Map(
      1L -> ""One"",
      2L -> ""Two"",
      3L -> ""Three"",
      4L -> ""Four"",
      5L -> ""Five"",
      6L -> ""Six"",
      7L -> ""Seven"",
      8L -> ""Eight"",
      9L -> ""Nine""
    )

    // Filter numbers between 1 and 9
    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)
    // Map filtered and sorted numbers to their corresponding names
    filteredAndSorted.map(numToName)
  }
}","    }
    def main(args: Array[String]) = {
    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))));
    assert(byLength((List[Long]())).equals((List[String]())));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](""One""))));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](""Three"", ""Two"", ""One""))));
    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](""Nine"", ""Eight"", ""Four""))));
    }

}
"
HumanEval_106,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //فاعل i هو ضرب الأرقام من 1 إلى i (1 * 2 * ... * i).    //أبدأ من 1    //أو مجموع الأرقام من 1 إلى i    //ويعود قائمة بحجم n، بحيث تكون قيمة العنصر في المؤشر i هي العامل لـ i إذا كان i زوجي     //قم بتنفيذ الدالة f التي تأخذ n كمعلم،     // >>> f((5l))
    // (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))
    def f(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def f(n: Long): List[Long] = {
        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)
        
        (1L to n).map { i =>
            if (i % 2 == 0) factorial(i) else (1L to i).sum
        }.toList
    }
}","    }
    def main(args: Array[String]) = {
    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));
    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));
    assert(f((1l)).equals((List[Long](1l.toLong))));
    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));
    }

}
"
HumanEval_107,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //المثال الأول:    //عدد صحيح من الحلويات التي تقع ضمن النطاق ((1، n) ، بما في ذلك.    //مع إعطاء عدد صحيح إيجابي n، أعد توبل لديه عدد من الزوجية والفردية     // >>> evenOddPalindrome((3l))
    // ((1l, 2l))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> evenOddPalindrome((12l))
    // ((4l, 6l))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {
","def evenOddPalindrome(n: Long): (Long, Long) = {
  def isPalindrome(x: Long): Boolean = {
    val str = x.toString
    str == str.reverse
  }

  var evenCount: Long = 0
  var oddCount: Long = 0

  for (i <- 1L to n) {
    if (isPalindrome(i)) {
      if (i % 2 == 0) evenCount += 1
      else oddCount += 1
    }
  }

  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));
    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));
    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));
    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));
    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));
    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));
    }

}
"
HumanEval_108,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال -123 لديه أرقام -1, 2 و 3.    //إذا كان العدد سالبًا، فإن أول رقم موقّع له سيكون سالبًا:    //عدد العناصر التي لديها مجموع الأرقام > 0.     //اكتب دالة count_nums التي تأخذ قائمة من الأعداد الصحيحة وتعود     // >>> countNums((List[Long]()))
    // (0l)
    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))
    // (1l)
    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))
    // (3l)
    def countNums(arr : List[Long]) : Long = {
","def countNums(arr: List[Long]): Long = {
  arr.count(num => {
    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>
      if (char == '-') acc else acc + (char - '0')
    }
    sumOfDigits > 0
  }).toLong
}","    }
    def main(args: Array[String]) = {
    assert(countNums((List[Long]())) == (0l));
    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));
    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));
    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));
    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));
    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));
    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));
    assert(countNums((List[Long](1l.toLong))) == (1l));
    }

}
"
HumanEval_109,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //ملاحظة: يضمن أن تحتوي القائمة المذكورة على عناصر فريدة من نوعها.    //إذا كانت القائمة المحددة فارغة ثم عودة صحيحة.    //ثم أعد صحيح أو أعد خاطئ    //إذا كان من الممكن الحصول على القائمة المصنفة عن طريق القيام بالعملية المذكورة أعلاه    //الموقع الأولي في القائمة أي المؤشر 0 .    //سيتم نقل العنصر الأخير من القائمة إلى     //عملية نقل واحدة إلى اليمين تعني نقل جميع عناصر القائمة بمقدار واحد    //يُسمح لك بإجراء عملية التحول اليمنى لأي عدد من المرات.    //العملية التالية في القائمة المذكورة:     //من الممكن الحصول على قائمة مرتبة بالترتيب غير المتناقص عن طريق أداء    //الأرقام في القائمة سترتب بشكل عشوائي مهمتك هي تحديد ما إذا كان    //لدينا قائمة 'arr' من N عدد صحيح arr[1], arr[2], ..., arr[N].    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    def moveOneBall(arr : List[Long]) : Boolean = {
","def moveOneBall(arr: List[Long]): Boolean = {
  if (arr.isEmpty) return true

  // Find how many times the array needs to be shifted to become sorted
  val n = arr.length
  var shiftIndex = -1

  for (i <- 0 until n) {
    if (arr(i) > arr((i + 1) % n)) {
      // More than one place where the order breaks means it can't be sorted with a shift
      if (shiftIndex != -1) return false
      shiftIndex = i + 1
    }
  }

  // If no break in order was found, the array is already sorted
  if (shiftIndex == -1) return true

  // Check if shifting by the found index sorts the array
  for (i <- 1 until n) {
    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false
  }
  
  true
}","    }
    def main(args: Array[String]) = {
    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long]())) == (true));
    }

}
"
HumanEval_110,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //وإلا، أعد ""لا"".    //كل عناصر lst1 لتكون حتى، إرجاع ""نعم"".    //إذا كان من الممكن أن تبادل العناصر بين lst1 و lst2 لجعل     //لا يوجد حد لعدد العناصر المتبادلة بين lst1 و lst2.    //بينهم لجعل lst1 قائمة من الأرقام الزوجية فقط.    //ويحدد ما إذا كان من الممكن إجراء تبادل العناصر    //في هذه المشكلة، سوف تنفذ وظيفة التي تأخذ قائمتين من الأرقام،     // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (""YES"")
    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def exchange(lst1: List[Long], lst2: List[Long]): String = {
    // Check if all elements in lst1 are already even
    if (lst1.forall(_ % 2 == 0)) return ""YES""

    // Find if there's any even number in lst2 to exchange with lst1
    val lst2EvensExist = lst2.exists(_ % 2 == 0)

    // Check if there's also at least one odd in lst1 to swap it out
    val lst1OddsExist = lst1.exists(_ % 2 != 0)

    // Only possible if both an even element in lst2 and an odd element in lst1 exist
    if (lst2EvensExist && lst1OddsExist) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((""YES"")));
    }

}
"
HumanEval_111,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //إذا كان هناك عدة أحرف ذات الحالة، أعد كل منها.    //من الحروف الأكثر تكراراً والتي تحتوي على العدد المقابل.    //مع إعطاء سلسلة تمثل حروف صغيرة منفصلة عن الفراغات، أعيد خريطة     // >>> histogram((""a b c""))
    // (Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l))
    // >>> histogram((""a b b a""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""a b c a b""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""b b b b a""))
    // (Map[String,Long](""b"" -> 4l))
    // >>> histogram((""""))
    // (Map[String,Long]())
    def histogram(test : String) : Map[String,Long] = {
","def histogram(test: String): Map[String, Long] = {
        val words = test.split("" "")
        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)

        if (frequencyMap.isEmpty) return Map.empty[String, Long]

        val maxCount = frequencyMap.values.max
        frequencyMap.filter { case (_, count) => count == maxCount }
    }
}","    }
    def main(args: Array[String]) = {
    assert(histogram((""a b b a"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c a b"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c d g"")).equals((Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l, ""d"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""b b b b a"")).equals((Map[String,Long](""b"" -> 4l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram(("""")).equals((Map[String,Long]())));
    assert(histogram((""a"")).equals((Map[String,Long](""a"" -> 1l))));
    }

}
"
HumanEval_112,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال     //يجب عليك إرجاع توبل يحتوي على سلسلة النتيجة والصحيح/الكذب للتحقق.    //تسمى السلسلة بالندروم إذا كانت تقرأ نفس الشيء للخلف كما للأمام.    //ثم تحقق إذا كانت السلسلة الناتجة هي متكاملة.     //لدينا سلسلتين s و c، عليك حذف كل الحروف في s التي تساوي أي حرف في c    //مهمة    // >>> reverseDelete((""abcde""), (""ae""))
    // ((""bcd"", false))
    // >>> reverseDelete((""abcdef""), (""b""))
    // ((""acdef"", false))
    // >>> reverseDelete((""abcdedcba""), (""ab""))
    // ((""cdedc"", true))
    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {
","def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {
    // Convert the characters to be deleted into a set for quick lookup
    val deleteSet = c.toSet
    
    // Filter out characters from s that are present in deleteSet
    val filteredString = s.filterNot(deleteSet.contains)
    
    // Check if the filtered string is a palindrome
    val isPalindrome = filteredString == filteredString.reverse
    
    // Return the tuple with the filtered string and the palindrome check result
    (filteredString, isPalindrome)
  }
}","    }
    def main(args: Array[String]) = {
    assert(reverseDelete((""abcde""), (""ae"")).equals(((""bcd"", false))));
    assert(reverseDelete((""abcdef""), (""b"")).equals(((""acdef"", false))));
    assert(reverseDelete((""abcdedcba""), (""ab"")).equals(((""cdedc"", true))));
    assert(reverseDelete((""dwik""), (""w"")).equals(((""dik"", false))));
    assert(reverseDelete((""a""), (""a"")).equals((("""", true))));
    assert(reverseDelete((""abcdedcba""), ("""")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""abcdedcba""), (""v"")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""vabba""), (""v"")).equals(((""abba"", true))));
    assert(reverseDelete((""mamma""), (""mia"")).equals((("""", true))));
    }

}
"
HumanEval_113,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //من الأرقام الفردية في السلسلة i'th من المدخلات.    //حيث يجب استبدال جميع i بالرقم     //كل عنصر i من الناتج يجب أن يكون ""عدد العناصر الفردية في     //مع إعطاء قائمة من السلاسل، حيث يتكون كل سلاسل من الأرقام فقط، إرجاع قائمة.    // >>> oddCount((List[String](""1234567"")))
    // (List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))
    // >>> oddCount((List[String](""3"", ""11111111"")))
    // (List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))
    def oddCount(lst : List[String]) : List[String] = {
","def oddCount(lst: List[String]): List[String] = {
    lst.map { str =>
      val oddCount = str.count(c => c.asDigit % 2 != 0)
      val replacedString = s""the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.""
      replacedString
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(oddCount(List(""1234567"")))  // List(""the number of odd elements 4n the str4ng 4 of the 4nput."")
    println(oddCount(List(""3"", ""11111111"")))  // List(""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput."")
  }
}","    }
    def main(args: Array[String]) = {
    assert(oddCount((List[String](""1234567""))).equals((List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))));
    assert(oddCount((List[String](""3"", ""11111111""))).equals((List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))));
    assert(oddCount((List[String](""271"", ""137"", ""314""))).equals((List[String](""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""))));
    }

}
"
HumanEval_114,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال     //من العدد    //مع إعطاء قائمة من الأعداد الصحيحة، ابحث عن الحد الأدنى من مجموع أي قائمة فرعية غير فارغة    // >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))
    // (1l)
    // >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))
    // (-6l)
    def minSubArraySum(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minSubArraySum(nums: List[Long]): Long = {
    var minEndingHere = nums.head
    var minSoFar = nums.head
    
    for (i <- 1 until nums.length) {
      minEndingHere = min(nums(i), minEndingHere + nums(i))
      minSoFar = min(minSoFar, minEndingHere)
    }
    
    minSoFar
  }

  // Test Cases
  def main(args: Array[String]): Unit = {
    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) // Output: 1
    println(minSubArraySum(List(-1l, -2l, -3l))) // Output: -6
  }
}","    }
    def main(args: Array[String]) = {
    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));
    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));
    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));
    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));
    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));
    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));
    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));
    }

}
"
HumanEval_115,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //المثال الأول:    //اخرج عدد المرات التي تحتاجها لخفض الدلاء    //مهمتك هي استخدام الدلاء لتفريغ الآبار    //وكل الدلاء لديها نفس القدرة    //كل بئر لديه دلو مماثل يمكن استخراجه لاستخراج الماء منه    //وكل 1 في الصف يمثل وحدة واحدة من الماء.    //تم إعطائك شبكة مستطيلة من الآبار كل صف يمثل بئرًا واحدًا    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))
    // (6l)
    // Example 2:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))
    // (5l)
    // Example 3:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))
    // (0l)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {
","def maxFill(grid: List[List[Long]], capacity: Long): Long = {
  var totalWaterUnits = 0L

  for (row <- grid) {
    totalWaterUnits += row.sum
  }

  // Calculate the number of times you need to lower the buckets
  val bucketOperations = totalWaterUnits / capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)

  bucketOperations
}","    }
    def main(args: Array[String]) = {
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));
    }

}
"
HumanEval_116,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يجب أن يتم تنفيذها هكذا:    //بالنسبة لعدد مماثل من الأحادية، قم بالفرز بناءً على القيمة العشرية.    //عدد الأحادية في التمثيل الثنائي بالترتيب المتصاعد.    //في هذه الكاتا، عليك أن تقوم بترتيب قائمة من الأعداد الصحيحة غير السالبة وفقاً لـ    // >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))
    // (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))
    // >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))
    def sortArray(arr : List[Long]) : List[Long] = {
","def sortArray(arr: List[Long]): List[Long] = {
        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));
    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));
    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    }

}
"
HumanEval_117,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //ملاحظة: يمكنك أن تفترض أن سلسلة الإدخال تحتوي على الحروف والمسافات فقط.    //إذا كانت السلسلة s فارغة، فيجب أن تعيد الدالة قائمة فارغة.    //n حرف متناغم، وذلك لتظهر هذه الكلمات في السلسلة s.    //دالة تعيد قائمة بجميع الكلمات من السلسلة s التي تحتوي على بالضبط     //مع إعطاء سلسلة s ورقم طبيعي n، تم تكليفك بتنفيذ     // >>> selectWords((""Mary had a little lamb""), (4l))
    // (List[String](""little""))
    // >>> selectWords((""Mary had a little lamb""), (3l))
    // (List[String](""Mary"", ""lamb""))
    // >>> selectWords((""simple white space""), (2l))
    // (List[String]())
    // >>> selectWords((""Hello world""), (4l))
    // (List[String](""world""))
    // >>> selectWords((""Uncle sam""), (3l))
    // (List[String](""Uncle""))
    def selectWords(s : String, n : Long) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def selectWords(s: String, n: Long): List[String] = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    def consonantCount(word: String): Int = {
      word.count(c => c.isLetter && !vowels.contains(c))
    }

    if (s.isEmpty) {
      List()
    } else {
      s.split(""\\s+"").filter(word => consonantCount(word) == n).toList
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(selectWords((""Mary had a little lamb""), (4l)).equals((List[String](""little""))));
    assert(selectWords((""Mary had a little lamb""), (3l)).equals((List[String](""Mary"", ""lamb""))));
    assert(selectWords((""simple white space""), (2l)).equals((List[String]())));
    assert(selectWords((""Hello world""), (4l)).equals((List[String](""world""))));
    assert(selectWords((""Uncle sam""), (3l)).equals((List[String](""Uncle""))));
    assert(selectWords((""""), (4l)).equals((List[String]())));
    assert(selectWords((""a b c d e f""), (1l)).equals((List[String](""b"", ""c"", ""d"", ""f""))));
    }

}
"
HumanEval_118,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //يمكنك أن تفترض أن السلسلة المقدمة تحتوي على حرف الإنجليزية فقط.    //أجد أي حرف صوتي يفي بالشرط أعلاه    //لا تُحسب الحروف العلوية في البداية والنهاية. أعد السلسلة الفارغة إذا لم تفعل ذلك.    //مصممين من الجانب الأيمن من الكلمة (حساس للقاعدة).    //تم إعطائك كلمة مهمتك هي إيجاد أقرب حرف صوتي بينهما    // >>> getClosestVowel((""yogurt""))
    // (""u"")
    // >>> getClosestVowel((""FULL""))
    // (""U"")
    // >>> getClosestVowel((""quick""))
    // ("""")
    // >>> getClosestVowel((""ab""))
    // ("""")
    def getClosestVowel(word : String) : String = {
","def getClosestVowel(word: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    for (i <- word.length - 2 until 0 by -1) {
      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {
        return word(i + 1).toString
      }
    }
    
    """"
  }
}","    }
    def main(args: Array[String]) = {
    assert(getClosestVowel((""yogurt"")).equals((""u"")));
    assert(getClosestVowel((""full"")).equals((""u"")));
    assert(getClosestVowel((""easy"")).equals(("""")));
    assert(getClosestVowel((""eAsy"")).equals(("""")));
    assert(getClosestVowel((""ali"")).equals(("""")));
    assert(getClosestVowel((""bad"")).equals((""a"")));
    assert(getClosestVowel((""most"")).equals((""o"")));
    assert(getClosestVowel((""ab"")).equals(("""")));
    assert(getClosestVowel((""ba"")).equals(("""")));
    assert(getClosestVowel((""quick"")).equals(("""")));
    assert(getClosestVowel((""anime"")).equals((""i"")));
    assert(getClosestVowel((""Asia"")).equals(("""")));
    assert(getClosestVowel((""Above"")).equals((""o"")));
    }

}
"
HumanEval_119,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //ارجع ""نعم"" إذا كان هناك طريقة لجعل سلسلة جيدة، وإلا ارجع ""لا""    //"" (()) "" ليس كذلك.    //متوازنة. على سبيل المثال: السلسلة '(()))))) جيدة، في حين أن السلسلة     //تعتبر سلسلة S جيدة إذا وفقط إذا كانت جميع الأقواس في S     //بعض النظام، أن السلسلة الناتجة ستكون جيدة.    //مهمتك هي التحقق من إمكانية ربط السلسلتين معاً    //العقود "" (("" أو العقود الزمنية "")) "" فقط.    //يتم إعطائك قائمة من سلسلتين، كلتا السلسلتين تتكون من مفتوحة     // >>> matchParens((List[String](""()("", "")"")))
    // (""Yes"")
    // >>> matchParens((List[String]("")"", "")"")))
    // (""No"")
    def matchParens(lst : List[String]) : String = {
","def matchParens(lst: List[String]): String = {
    def isBalanced(s: String): Boolean = {
      var balance = 0
      for (char <- s) {
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1
        if (balance < 0) return false
      }
      balance == 0
    }
    
    val combinations = List(
      lst(0) + lst(1),
      lst(1) + lst(0)
    )
    
    if (combinations.exists(isBalanced)) ""Yes"" else ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(matchParens((List[String](""()("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", "")""))).equals((""No"")));
    assert(matchParens((List[String](""(()(())"", ""())())""))).equals((""No"")));
    assert(matchParens((List[String]("")())"", ""(()()(""))).equals((""Yes"")));
    assert(matchParens((List[String](""(())))"", ""(()())((""))).equals((""Yes"")));
    assert(matchParens((List[String](""()"", ""())""))).equals((""No"")));
    assert(matchParens((List[String](""(()("", ""()))()""))).equals((""Yes"")));
    assert(matchParens((List[String](""(((("", ""((())""))).equals((""No"")));
    assert(matchParens((List[String]("")(()"", ""(()(""))).equals((""No"")));
    assert(matchParens((List[String]("")("", "")(""))).equals((""No"")));
    assert(matchParens((List[String](""("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", ""(""))).equals((""Yes"")));
    }

}
"
HumanEval_120,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //المثال الأول:    //من الطول k مع أقصى عدد k في arr.    //مع إعطاء قائمة arr من الأعداد الصحيحة والعدد الصحيح الإيجابي k، أعد قائمة مرتبة     // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))
    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))
    // Example 2:
    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))
    // (List[Long](4l.toLong, 4l.toLong))
    // Example 3:
    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))
    // (List[Long](2l.toLong))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    def maximum(arr : List[Long], k : Long) : List[Long] = {
","def maximum(arr: List[Long], k: Long): List[Long] = {
    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));
    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));
    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));
    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));
    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));
    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));
    }

}
"
HumanEval_121,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //مع إعطاء قائمة غير فارغة من الأعداد الصحيحة، أعد مجموع كل العناصر الفردية التي في مواقع زوجية.    // >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))
    // (12l)
    // >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))
    // (9l)
    // >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))
    // (0l)
    def solution(lst : List[Long]) : Long = {
","def solution(lst: List[Long]): Long = {
  lst.zipWithIndex.collect {
    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num
  }.sum
}","    }
    def main(args: Array[String]) = {
    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));
    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));
    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));
    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));
    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));
    }

}
"
HumanEval_122,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //مجموع العناصر التي تحتوي على رقمين على الأكثر من العناصر الأولى k من arr.    //مع إعطاء قائمة غير فارغة من الأعداد الصحيحة arr والعدد الصحيح k، عودة     // >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))
    // (24l)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    def addElements(arr : List[Long], k : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def addElements(arr: List[Long], k: Long): Long = {
    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum
  }

  def main(args: Array[String]): Unit = {
    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)
    println(result) // Output will be 24L
  }
}","    }
    def main(args: Array[String]) = {
    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));
    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));
    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));
    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));
    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));
    }

}
"
HumanEval_123,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //get_odd_collatz(5) يعيد [1, 5] # تسلسل كولاتز لـ 5 هو [5, 16, 8, 4, 2, 1]، لذلك الأرقام العادية هي فقط 1 و 5.     //على سبيل المثال:    //2. قائمة المرجع مرتبة بالترتيب المتزايد.    //1. Collatz(1) هو [1].     //ملاحظة:    //العبارة زائد 1، والخميس هو أنه بغض النظر عن قيمة n، فإن التسلسل سيصل دائماً إلى 1.    //العبارة السابقة. إذا كانت العبارة السابقة فردية، فإن العبارة التالية هي 3 مرات العبارة السابقة     //العبارة السابقة على النحو التالي: إذا كانت العبارة السابقة زوجية، فإن العبارة التالية هي نصف     //كما يلي: بدءاً بأي عدد صحيح إيجابي n. ثم يتم الحصول على كل مصطلح من     //تخمين كولاتز هو تخمين في الرياضيات يتعلق بتسلسل محدد    //مع إعطاء عدد صحيح إيجابي n، أعد قائمة مرتبة تحتوي على الأرقام الفردية في تسلسل كولاتز.    // >>> getOddCollatz((5l))
    // (List[Long](1l.toLong, 5l.toLong))
    def getOddCollatz(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def getOddCollatz(n: Long): List[Long] = {
    val oddNumbers = ListBuffer[Long]()
    var number = n
    while (number != 1) {
      if (number % 2 == 1) {
        oddNumbers += number
      }
      number = if (number % 2 == 0) number / 2 else 3 * number + 1
    }
    oddNumbers += 1
    oddNumbers.sorted.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));
    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));
    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));
    }

}
"
HumanEval_124,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يجب أن يكون التاريخ في الشكل: مم-د-ي-ييي     //يجب ألا تقل الأشهر عن 1 أو تكون أعلى من 12.    //2. عدد الأيام لا يقل عن 1 أو أعلى من 31 يومًا للأشهر 1,3,5,7,8,10,12. وعدد الأيام لا يقل عن 1 أو أعلى من 30 يومًا للأشهر 4,6,9,11. وعدد الأيام لا يقل عن 1 أو أعلى من 29 يومًا للشهر 2.    //1. سلسلة التاريخ ليست فارغة.    //التاريخ ساري المفعول إذا تم الوفاء بجميع القواعد التالية:     //يعيد صحيحاً إذا كان التاريخ صحيحاً وإلا فانتهى    //عليك كتابة دالة تثبت صحة سلسلة تاريخ معينة و    // >>> validDate((""03-11-2000""))
    // (true)
    // >>> validDate((""15-01-2012""))
    // (false)
    // >>> validDate((""04-0-2040""))
    // (false)
    // >>> validDate((""06-04-2020""))
    // (true)
    // >>> validDate((""06/04/2020""))
    // (false)
    def validDate(date : String) : Boolean = {
","import scala.util.Try

object Problem {
  def validDate(date: String): Boolean = {
    if (date.isEmpty) return false
    
    val datePattern = """"""^(\d{2})-(\d{2})-(\d{4})$"""""".r

    date match {
      case datePattern(monthStr, dayStr, yearStr) => 
        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {
          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>
            month match {
              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31
              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30
              case 2 => day >= 1 && day <= 29
              case _ => false
            }
          case _ => false
        }
      case _ => false
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(validDate((""03-11-2000"")) == (true));
    assert(validDate((""15-01-2012"")) == (false));
    assert(validDate((""04-0-2040"")) == (false));
    assert(validDate((""06-04-2020"")) == (true));
    assert(validDate((""01-01-2007"")) == (true));
    assert(validDate((""03-32-2011"")) == (false));
    assert(validDate(("""")) == (false));
    assert(validDate((""04-31-3000"")) == (false));
    assert(validDate((""06-06-2005"")) == (true));
    assert(validDate((""21-31-2000"")) == (false));
    assert(validDate((""04-12-2003"")) == (true));
    assert(validDate((""04122003"")) == (false));
    assert(validDate((""20030412"")) == (false));
    assert(validDate((""2003-04"")) == (false));
    assert(validDate((""2003-04-12"")) == (false));
    assert(validDate((""04-2003"")) == (false));
    }

}
"
HumanEval_125,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //الحروف الأبجدية، ord (a) = 0، ord (b) = 1، ... ord (z) = 25    //يجب أن تقسم على الفواصل ',' إذا لم تكن هناك فواصل يجب عليك إرجاع عدد الحروف الصغيرة مع ترتيب غريب في     //مع إعطاء سلسلة من الكلمات، إرجع قائمة من الكلمات مقسمة على المساحات البيضاء، إذا لم يكن هناك مساحات بيضاء في النص الذي تريد إرجاعه.    // >>> splitWords((""Hello world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""Hello,world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""abcdef""))
    // 3l
    def splitWords(txt : String) : Either[List[String], Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def splitWords(txt: String): Either[List[String], Long] = {
    if (txt.contains("" "")) {
      Left(txt.split(""\\s+"").toList)
    } else if (txt.contains("","")) {
      Left(txt.split("","").toList)
    } else {
      val oddOrderCount = txt.toCharArray
        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)
      Right(oddOrderCount.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(splitWords((""Hello world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello,world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello world,!"")).equals(List[String](""Hello"", ""world,!"")));
    assert(splitWords((""Hello,Hello,world !"")).equals(List[String](""Hello,Hello,world"", ""!"")));
    assert(splitWords((""abcdef"")).equals(3l));
    assert(splitWords((""aaabb"")).equals(2l));
    assert(splitWords((""aaaBb"")).equals(1l));
    assert(splitWords(("""")).equals(0l));
    }

}
"
HumanEval_126,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //رقم، يعيد false. افترض عدم وجود أرقام سالبة وأعداد صحيحة فقط.    //في ترتيب تصاعدي. إذا كان القائمة لديها أكثر من نسخة واحدة من نفس     //مع إعطاء قائمة بالأرقام، أعد سواء تم فرزها أم لا    // >>> isSorted((List[Long](5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (false)
    def isSorted(lst : List[Long]) : Boolean = {
","def isSorted(lst: List[Long]): Boolean = {
    if (lst.isEmpty || lst.length == 1) return true

    var hasDuplicate = false

    for (i <- 1 until lst.length) {
        if (lst(i) < lst(i - 1)) {
            return false
        }
        if (lst(i) == lst(i - 1)) {
            if (hasDuplicate) return false
            hasDuplicate = true
        } else {
            hasDuplicate = false
        }
    }

    true
}","    }
    def main(args: Array[String]) = {
    assert(isSorted((List[Long](5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));
    assert(isSorted((List[Long]())) == (true));
    assert(isSorted((List[Long](1l.toLong))) == (true));
    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));
    }

}
"
HumanEval_127,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //[إدخال/إخراج] عينات:     //إذا لم تتقاطع الفترتين، أعد ""لا"".    //وإلا، أعد ""لا"".    //إذا كان طول التقاطع هو عدد أولي، أعيد ""نعم""،     //والتي طولها هو 1، والتي ليست عدد أولي.    //مثال، تقاطع الفاصل الزمني (1, 3) ، (2, 4) هو (2, 3)     //فترات هو عدد أولي.    //مهمتك هي تحديد ما إذا كان طول تقاطع هذين    //لكل فترة معينة، يفترض أن بدايتها أقل أو تساوي نهايتها.    //يشمل كل من البداية والنهاية.    //فترات معينة مغلقة مما يعني أن الفاصل الزمني (البداية، نهاية)    //حيث كل فترة هي زوج من الأعداد الصحيحة. على سبيل المثال، فترة = (البداية، النهاية) = (1, 2).    //تم إعطائك فترتين    // >>> intersection(((1l, 2l)), ((2l, 3l)))
    // (""NO"")
    // >>> intersection(((-1l, 1l)), ((0l, 4l)))
    // (""NO"")
    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))
    // (""YES"")
    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {
","import scala.math._

object Problem {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {
    val start = max(interval1._1, interval2._1)
    val end = min(interval1._2, interval2._2)
    if (start > end) return ""NO""

    val length = end - start
    if (isPrime(length)) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((""NO"")));
    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((""NO"")));
    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((""YES"")));
    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((""YES"")));
    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((""NO"")));
    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((""NO"")));
    }

}
"
HumanEval_128,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //ملاحظة: لا يعود أي شيء لـ arr فارغة.    //لكل رقم في القائمة، ممثلة بـ 1، -1 أو 0.    //مجموع مقادير الأعداد الصحيحة مضروبة في ناتج كل العلامات    //تعطى لك قائمة من الأعداد الصحيحة و يجب عليك أن تعود    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))
    // Some(9l)
    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))
    // Some(0l)
    // >>> prodSigns((List[Long]()))
    // None
    def prodSigns(arr : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def prodSigns(arr: List[Long]): Option[Long] = {
    if (arr.isEmpty) return None

    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))
    val sumOfMagnitudes = arr.map(_.abs).sum

    Some(sumOfMagnitudes * productOfSigns)
  }

  private def sign(num: Long): Long = {
    if (num > 0) 1
    else if (num < 0) -1
    else 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));
    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));
    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));
    assert(prodSigns((List[Long]())).equals(None));
    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));
    }

}
"
HumanEval_129,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //يعيد قائمة مرتبة بالقيم على الخلايا التي يمر بها الحد الأدنى من المسار.    //ومن المضمون أن الإجابة فريدة من نوعها.    //lst_A[j] = lst_B[j].    //مثل lst_A[i] < lst_B[i] ولأي j (1 <= j < i) لدينا     //من lst_B، وبعبارة أخرى، هناك وجود مؤشر عدد صحيح i (1 <= i <= k)     //من خلال (دعونا نسميهم lst_A و lst_B) ، lst_A أقل من الناحية المفردة    //بعد أن تقوم بعمل قوائم مرتبة للقيم على الخلايا التي يذهب إليها A و B    //يعتبر المسار A (طول k) أصغر من المسار B (طول k) إذا     //لا يمكنك الخروج من الشبكة    //لا بد أن تكون مختلفة).    //يرجى ملاحظة أن مسار طول k يعني زيارة بالضبط k الخلايا (ليس     //الخلية    //بمعنى آخر، يمكنك الذهاب إلى الخلايا التي تتشارك حافة معك الحالية    //من أي خلية، وفي كل خطوة يمكنك الانتقال إلى أي من الخلايا المجاورة،     //يجب ان نجد الحد الادنى من المسار طول k في الشبكة. يمكنك البدء     //يظهر ""مضمن"" مرة واحدة بالضبط على خلايا الشبكة.    //تحتوي كل خلية من الخلية على قيمة. كل عدد صحيح في النطاق [1, N * N]     //مع وجود شبكة من N صفوف و N عمود (N >= 2) و عدد صحيح k،     // >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))
    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))
    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))
    // (List[Long](1l.toLong))
    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minPath(grid: List[List[Long]], k: Long): List[Long] = {
    val n = grid.length
    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))

    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n

    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {
      if (path.length == k) return path
      var minPath: List[Long] = List.fill(k)(Long.MaxValue)
      for ((dx, dy) <- directions) {
        val nx = x + dx
        val ny = y + dy
        if (isValid(nx, ny)) {
          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))
          if (lexCompare(newPath, minPath)) {
            minPath = newPath
          }
        }
      }
      minPath
    }

    def lexCompare(a: List[Long], b: List[Long]): Boolean = {
      a.zip(b).find { case (x, y) => x != y } match {
        case Some((x, y)) => x < y
        case None => false
      }
    }

    var minPathOverall = List.fill(k)(Long.MaxValue)
    for {
      i <- 0 until n
      j <- 0 until n
    } {
      val startingPath = List(grid(i)(j))
      val currentPath = dfs(i, j, startingPath)
      if (lexCompare(currentPath, minPathOverall)) {
        minPathOverall = currentPath
      }
    }
    minPathOverall
  }
}","    }
    def main(args: Array[String]) = {
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));
    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_130,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //أول n + 1 أعداد من تسلسل تريبوناتشي.    //تم إعطائك عدد صحيح غير سالب n، عليك أن تعيد قائمة من     //= 2 + 3 + 3 = 8     //ثلاثية ((3) = ثلاثية ((2) + ثلاثية ((1) + ثلاثية ((4)     //ثلاثية ((4) = 3     //ثلاثية ((2) = 1 + (2 / 2) = 2     //على سبيل المثال:    //(ثري (ن) = (ثري (ن - 1) + (ثري (ن - 2) + (ثري (ن + 1) ، إذا كان (ن) فردي.    //tri (n) = 1 + n / 2، إذا كان n زوجيًا.    //ثلاثية ((1) = 3     //تسلسل تريبوناتشي محدد من خلال تكرار:    //لكن ما لا يعرفه الناس هو تسلسل تريبوناتشي    //الجميع يعرف تسلسل فيبوناتشي، وقد درس عميقا من قبل علماء الرياضيات في     // >>> tri((3l))
    // (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))
    def tri(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def tri(n: Long): List[Long] = {
    // Initialize list with the first element of the Tribonacci sequence
    val tribonacciSeq = ListBuffer[Long](3)

    // Generate remaining elements up to the nth element
    for (i <- 1L to n) {
      if (i % 2 == 0) {
        // If even, the formula is 1 + n / 2
        tribonacciSeq.append(1 + i / 2)
      } else {
        // If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)
        // tri(n + 1) is handled as we iterate further
        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0
        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0
        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) / 2 else 0 // calculated as if the next is even
        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)
      }
    }

    // Return as a list
    tribonacciSeq.toList
  }

  // Test examples
  def main(args: Array[String]): Unit = {
    println(tri(3)) // List(3, 2, 8)
  }
}","    }
    def main(args: Array[String]) = {
    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));
    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));
    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));
    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));
    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));
    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));
    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));
    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));
    assert(tri((0l)).equals((List[Long](1l.toLong))));
    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_131,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //يعيد 0 إذا كانت جميع الأرقام زوجية.    //مع إعطاء عدد صحيح إيجابي n، أعد ناتج الأرقام الفردية.     // >>> digits((1l))
    // (1l)
    // >>> digits((4l))
    // (0l)
    // >>> digits((235l))
    // (15l)
    def digits(n : Long) : Long = {
","def digits(n: Long): Long = {
    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product
    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product
}","    }
    def main(args: Array[String]) = {
    assert(digits((5l)) == (5l));
    assert(digits((54l)) == (5l));
    assert(digits((120l)) == (1l));
    assert(digits((5014l)) == (5l));
    assert(digits((98765l)) == (315l));
    assert(digits((5576543l)) == (2625l));
    assert(digits((2468l)) == (0l));
    }

}
"
HumanEval_132,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //حيث يوجد على الأقل قوس واحد في التسلسل الفرعي.    //يجب أن تعيد الدالة true إذا كان هناك تسلسل ثانوي صالح من الأقواس     //إنشاء دالة تأخذ سلسلة كمدخلات تحتوي فقط على أقواس مربعة.    // >>> isNested((""[[]]""))
    // (true)
    // >>> isNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> isNested((""[][]""))
    // (false)
    // >>> isNested((""[]""))
    // (false)
    // >>> isNested((""[[][]]""))
    // (true)
    // >>> isNested((""[[]][[""))
    // (true)
    def isNested(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isNested(string: String): Boolean = {
    var stack = new Stack[Char]()
    var nested = false

    for (char <- string) {
      char match {
        case '[' => stack.push(char)
        case ']' =>
          if (stack.nonEmpty) {
            stack.pop()
            if (stack.nonEmpty) {
              nested = true
            }
          }
      }
      if (nested) return true
    }

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isNested((""[[]]"")) == (true));
    assert(isNested((""[]]]]]]][[[[[]"")) == (false));
    assert(isNested((""[][]"")) == (false));
    assert(isNested((""[]"")) == (false));
    assert(isNested((""[[[[]]]]"")) == (true));
    assert(isNested((""[]]]]]]]]]]"")) == (false));
    assert(isNested((""[][][[]]"")) == (true));
    assert(isNested((""[[]"")) == (false));
    assert(isNested((""[]]"")) == (false));
    assert(isNested((""[[]][["")) == (true));
    assert(isNested((""[[][]]"")) == (true));
    assert(isNested(("""")) == (false));
    assert(isNested((""[[[[[[[["")) == (false));
    assert(isNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //قم بتدوير كل عنصر في القائمة إلى أعلى int ((السقف)) أولاً.    //تحتاج إلى إرجاع مجموع الأرقام المربعة في القائمة المقدمة،     //لقد أعطيت قائمة بأرقام    // >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))
    // (14l)
    // >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))
    // (98l)
    // >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))
    // (84l)
    // >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))
    // (29l)
    // >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))
    // (6l)
    def sumSquares(lst : List[Float]) : Long = {
","import scala.math._

object Problem {
  def sumSquares(lst: List[Float]): Long = {
    lst.map(x => ceil(x.toDouble).toLong)
      .map(x => x * x)
      .sum
  }

  // Example usage, you can test the function with the given examples:
  def main(args: Array[String]): Unit = {
    println(sumSquares(List(1.0f, 2.0f, 3.0f))) // Output: 14
    println(sumSquares(List(1.0f, 4.0f, 9.0f))) // Output: 98
    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) // Output: 84
    println(sumSquares(List(1.4f, 4.2f, 0.0f))) // Output: 29
    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) // Output: 6
  }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));
    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));
    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));
    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));
    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));
    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));
    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));
    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));
    }

}
"
HumanEval_134,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //ملاحظة: ""كلمة"" هي مجموعة من الأحرف الفاصلة بالمسافة.    //جزء من كلمة، وكاذبة خلاف ذلك.    //من سلسلة معينة هو حرف أبجدي وليس     //إنشاء دالة تعيد true إذا كانت آخر حرف    // >>> checkIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> checkIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> checkIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> checkIfLastCharIsALetter((""""))
    // (false)
    def checkIfLastCharIsALetter(txt : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def checkIfLastCharIsALetter(txt: String): Boolean = {
        if (txt.isEmpty) return false
        val trimmed = txt.trim
        if (trimmed.isEmpty) return false
        val parts = trimmed.split("" "")
        val lastChars = parts.map(_.last)
        if (lastChars.isEmpty) return false
        val lastChar = trimmed.last
        lastChars.contains(lastChar) && lastChar.isLetter
    }
}","    }
    def main(args: Array[String]) = {
    assert(checkIfLastCharIsALetter((""apple"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e"")) == (true));
    assert(checkIfLastCharIsALetter((""eeeee"")) == (false));
    assert(checkIfLastCharIsALetter((""A"")) == (true));
    assert(checkIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    assert(checkIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    assert(checkIfLastCharIsALetter(("""")) == (false));
    assert(checkIfLastCharIsALetter((""eeeee e "")) == (false));
    assert(checkIfLastCharIsALetter((""apple pie"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //قيم متكررة    //إذا لم يكن هناك عنصر من هذا القبيل، فستعود -1. لن تحتوي القائمة المقدمة على     //لا يزيد عن أو يساوي العنصر الذي يسبقه مباشرة. إذا     //إنشاء دالة تعيد أكبر مؤشر لعنصر     // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))
    // (3l)
    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (-1l)
    def canArrange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  def canArrange(arr: List[Long]): Long = {
    for (i <- arr.indices.drop(1)) {
      if (arr(i) < arr(i - 1)) return i.toLong
    }
    -1L
  }
}","    }
    def main(args: Array[String]) = {
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));
    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));
    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));
    assert(canArrange((List[Long]())) == (-1l));
    }

}
"
HumanEval_136,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //إذا لم يكن هناك عدد صحيح سالب أو إيجابي، أعدهما على أنه لا شيء.    //من الأعداد الصحيحة الإيجابية في قائمة    //أكبر عدد صحيح سالب، و ""ب"" هو أصغر     //إنشاء دالة تعيد التوبل (a، b) ، حيث تكون 'a'     // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (Some(None), Some(1l))
    // >>> largestSmallestIntegers((List[Long]()))
    // (Some(None), Some(None))
    // >>> largestSmallestIntegers((List[Long](0l.toLong)))
    // (Some(None), Some(None))
    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {
    val negativeIntegers = lst.filter(_ < 0)
    val positiveIntegers = lst.filter(_ > 0)

    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None
    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None

    (largestNegative, smallestPositive)
  }
}","    }
    def main(args: Array[String]) = {
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));
    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));
    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));
    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));
    }

}
"
HumanEval_138,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال     //قم بتقييم ما إذا كان يمكن كتابة العدد n كمجموع 4 أرقام زوجية إيجابية بالضبط    // >>> isEqualToSumEven((4l))
    // (false)
    // >>> isEqualToSumEven((6l))
    // (false)
    // >>> isEqualToSumEven((8l))
    // (true)
    def isEqualToSumEven(n : Long) : Boolean = {
","def isEqualToSumEven(n: Long): Boolean = {
    // Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.
    n >= 8 && n % 2 == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(isEqualToSumEven((4l)) == (false));
    assert(isEqualToSumEven((6l)) == (false));
    assert(isEqualToSumEven((8l)) == (true));
    assert(isEqualToSumEven((10l)) == (true));
    assert(isEqualToSumEven((11l)) == (false));
    assert(isEqualToSumEven((12l)) == (true));
    assert(isEqualToSumEven((13l)) == (false));
    assert(isEqualToSumEven((16l)) == (true));
    }

}
"
HumanEval_139,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //حيث n > 0     //برازيلي_فاكتوري ((n) = n! * (n-1)! * (n-2)! * ... * 1!     //يتم تعريف العامل البرازيلي على النحو التالي:    // >>> specialFactorial((4l))
    // (288l)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    def specialFactorial(n : Long) : Long = {
","def specialFactorial(n: Long): Long = {
        def factorial(x: Long): Long = {
            if (x == 0 || x == 1) 1L
            else x * factorial(x - 1)
        }

        (1L to n).map(factorial).product
    }
}","    }
    def main(args: Array[String]) = {
    assert(specialFactorial((4l)) == (288l));
    assert(specialFactorial((5l)) == (34560l));
    assert(specialFactorial((7l)) == (125411328000l));
    assert(specialFactorial((1l)) == (1l));
    }

}
"
HumanEval_140,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ثم استبدال كل المساحات المتتالية بـ -     //وإذا كان السلسلة لديها أكثر من 2 مساحات متتالية،     //مع إعطاء سلسلة نصية، استبدل كل المساحات فيها بالخطوط السفلية،     // >>> fixSpaces(("" Example""))
    // (""Example"")
    // >>> fixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> fixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> fixSpaces(("" Example 3""))
    // (""_Example-3"")
    def fixSpaces(text : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fixSpaces(text: String): String = {
    val result = new StringBuilder()
    var spaceCount = 0
    var leadingSpace = true
    
    for (ch <- text) {
      if (ch == ' ') {
        spaceCount += 1
      } else {
        if (spaceCount > 0) {
          if (leadingSpace && result.isEmpty) {
            result.append('_')
          } else if (spaceCount == 1) {
            result.append('_')
          } else if (spaceCount > 1) {
            result.append('-')
          }
          spaceCount = 0
        }
        result.append(ch)
        leadingSpace = false
      }
    }
    
    if (spaceCount == 1) {
      result.append('_')
    } else if (spaceCount > 1) {
      result.append('-')
    }
    
    result.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(fixSpaces((""Example"")).equals((""Example"")));
    assert(fixSpaces((""Mudasir Hanif "")).equals((""Mudasir_Hanif_"")));
    assert(fixSpaces((""Yellow Yellow  Dirty  Fellow"")).equals((""Yellow_Yellow__Dirty__Fellow"")));
    assert(fixSpaces((""Exa   mple"")).equals((""Exa-mple"")));
    assert(fixSpaces((""   Exa 1 2 2 mple"")).equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //- السلسلة الفرعية بعد النقطة يجب أن تكون واحدة من هذه: ['txt'، 'exe'، 'dll']     //الأبجدية اللاتينية (""a"" - ""z"" و ""A"" - ""Z"").    //- السلسلة الفرعية قبل النقطة يجب ألا تكون فارغة، وتبدأ بحرف من     //- اسم الملف يحتوي على نقطة واحدة بالضبط    //- يجب ألا يكون هناك أكثر من ثلاثة أرقام (""0"" - ""9"") في اسم الملف.    //يتم الوفاء بها:    //يعتبر اسم الملف صالحاً إذا و فقط إذا استوفي جميع الشروط التالية     //""نعم"" إذا كان اسم الملف صحيحاً، وإلا فإنه يعيد ""لا"".    //إنشاء دالة تأخذ سلسلة تمثل اسم الملف، وتعود     // >>> fileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> fileNameCheck((""1example.dll""))
    // (""No"")
    def fileNameCheck(file_name : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fileNameCheck(file_name: String): String = {
    val validExtensions = Set(""txt"", ""exe"", ""dll"")
    val dotIndex = file_name.lastIndexOf('.')

    if (dotIndex == -1) return ""No""

    val beforeDot = file_name.substring(0, dotIndex)
    val afterDot = file_name.substring(dotIndex + 1)

    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return ""No""

    val digitCount = beforeDot.count(_.isDigit)
    if (digitCount > 3) return ""No""

    if (!validExtensions.contains(afterDot)) return ""No""

    ""Yes""
  }

  def main(args: Array[String]): Unit = {
    println(fileNameCheck(""example.txt"")) // ""Yes""
    println(fileNameCheck(""1example.dll"")) // ""No""
    println(fileNameCheck(""test123.exe"")) // ""Yes""
    println(fileNameCheck("".hidden.txt"")) // ""No""
    println(fileNameCheck(""file..txt"")) // ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(fileNameCheck((""example.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""1example.dll"")).equals((""No"")));
    assert(fileNameCheck((""s1sdf3.asd"")).equals((""No"")));
    assert(fileNameCheck((""K.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""MY16FILE3.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""His12FILE94.exe"")).equals((""No"")));
    assert(fileNameCheck((""_Y.txt"")).equals((""No"")));
    assert(fileNameCheck((""?aREYA.exe"")).equals((""No"")));
    assert(fileNameCheck((""/this_is_valid.dll"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.wow"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""this_is_valid.txtexe"")).equals((""No"")));
    assert(fileNameCheck((""#this2_i4s_5valid.ten"")).equals((""No"")));
    assert(fileNameCheck((""@this1_is6_valid.exe"")).equals((""No"")));
    assert(fileNameCheck((""this_is_12valid.6exe4.txt"")).equals((""No"")));
    assert(fileNameCheck((""all.exe.txt"")).equals((""No"")));
    assert(fileNameCheck((""I563_No.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""Is3youfault.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""no_one#knows.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""1I563_Yes3.exe"")).equals((""No"")));
    assert(fileNameCheck((""I563_Yes3.txtt"")).equals((""No"")));
    assert(fileNameCheck((""final..txt"")).equals((""No"")));
    assert(fileNameCheck((""final132"")).equals((""No"")));
    assert(fileNameCheck((""_f4indsartal132."")).equals((""No"")));
    assert(fileNameCheck(("".txt"")).equals((""No"")));
    assert(fileNameCheck((""s."")).equals((""No"")));
    }

}
"
HumanEval_142,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //تغيير الإدخالات في القائمة التي مؤشراتها ليست مضروبة من 3 أو 4. ثم يجب على الدالة إرجاع مجموع جميع الإدخالات.     //مضروبة من 3 وسوف مكعب إدخال عدد صحيح إذا كان مؤشر مضروبة من 4 وليس مضروبة من 3.    //ستأخذ هذه الدالة قائمة من الأعداد الصحيحة. بالنسبة لجميع الإدخالات في القائمة ، يجب على الدالة تربيع إدخال العدد الصحيح إذا كان مؤشرها هو     //""     // >>> lst
    // List[Long](1l.toLong, 2l.toLong, 3l.toLong)
    // >>> lst
    // List[Long]()
    // >>> lst
    // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)
    def sumSquares(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def sumSquares(lst: List[Long]): Long = {
        lst.zipWithIndex.map { case (value, index) =>
            if (index % 3 == 0) {
                value * value
            } else if (index % 4 == 0) {
                value * value * value
            } else {
                value
            }
        }.sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));
    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));
    assert(sumSquares((List[Long]())) == (0l));
    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));
    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));
    assert(sumSquares((List[Long](0l.toLong))) == (0l));
    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));
    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));
    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));
    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));
    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));
    }

}
"
HumanEval_143,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //المثال الأول:    //يجب أن يكون ترتيب الكلمات في السلسلة الجديدة هو نفسه الذي كان في السلسلة الأصلية.    //التي طولها أرقام أولية،     //وعليك أن تعيد سلسلة تحتوي على الكلمات من الجملة الأصلية،     //الجملة تحتوي على بعض الكلمات مفصولة بالفارق،     //يتم إعطائك سلسلة تمثل جملة،     // >>> wordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> wordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    def wordsInSentence(sentence : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isPrime(n: Int): Boolean = {
    if (n < 2) false
    else if (n == 2) true
    else !(2 to sqrt(n).toInt).exists(n % _ == 0)
  }

  def wordsInSentence(sentence: String): String = {
    val words = sentence.split("" "")
    val primeLengthWords = words.filter(word => isPrime(word.length))
    primeLengthWords.mkString("" "")
  }
  
  // Example usage:
  // println(wordsInSentence(""This is a test""))
  // println(wordsInSentence(""lets go for swimming""))
}","    }
    def main(args: Array[String]) = {
    assert(wordsInSentence((""This is a test"")).equals((""is"")));
    assert(wordsInSentence((""lets go for swimming"")).equals((""go for"")));
    assert(wordsInSentence((""there is no place available here"")).equals((""there is no place"")));
    assert(wordsInSentence((""Hi I am Hussein"")).equals((""Hi am Hussein"")));
    assert(wordsInSentence((""go for it"")).equals((""go for it"")));
    assert(wordsInSentence((""here"")).equals(("""")));
    assert(wordsInSentence((""here is"")).equals((""is"")));
    }

}
"
HumanEval_144,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //يمكنك ان تفترض ان x, و n هي كسور صالحة, وليس لها صفر كمقام.    //<المقام>/<المقام> حيث يكون كل من المقام والمقام أعداد صحيحة إيجابية.    //وإلا، فإن x و n، تمثيلات سلسلة للكسر، ولها الشكل التالي،     //x * n. تعود الدالة إلى صحيح إذا x * n تقييم إلى عدد صحيح و false     //مهمتك هي تنفيذ دالة لتبسيط التعبير    // >>> simplify((""1/5""), (""5/1""))
    // (true)
    // >>> simplify((""1/6""), (""2/1""))
    // (false)
    // >>> simplify((""7/10""), (""10/2""))
    // (false)
    def simplify(x : String, n : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def simplify(x: String, n: String): Boolean = {
    def parseFraction(fraction: String): (Int, Int) = {
      val parts = fraction.split(""/"")
      (parts(0).toInt, parts(1).toInt)
    }

    val (numX, denX) = parseFraction(x)
    val (numN, denN) = parseFraction(n)

    val multipliedNumerator = numX * numN
    val multipliedDenominator = denX * denN

    multipliedNumerator % multipliedDenominator == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/6""), (""2/1"")) == (false));
    assert(simplify((""5/1""), (""3/1"")) == (true));
    assert(simplify((""7/10""), (""10/2"")) == (false));
    assert(simplify((""2/10""), (""50/10"")) == (true));
    assert(simplify((""7/2""), (""4/2"")) == (true));
    assert(simplify((""11/6""), (""6/1"")) == (true));
    assert(simplify((""2/3""), (""5/2"")) == (false));
    assert(simplify((""5/2""), (""3/5"")) == (false));
    assert(simplify((""2/4""), (""8/4"")) == (true));
    assert(simplify((""2/4""), (""4/2"")) == (true));
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //ترتيبهم على أساس فهرسهم في القائمة الأصلية.    //ملاحظة: إذا كان هناك عدة بنود مع مجموع مماثل من أرقامها،     //في ترتيب تصاعدي وفقاً لجمع أرقامها    //اكتب دالة تقوم بترتيب قائمة الأعداد الصحيحة المحددة    // >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))
    // (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))
    // >>> orderByPoints((List[Long]()))
    // (List[Long]())
    def orderByPoints(nums : List[Long]) : List[Long] = {
","def orderByPoints(nums: List[Long]): List[Long] = {
    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum
    
    nums.zipWithIndex
      .sortBy { case (num, index) => (digitSum(num), index) }
      .map(_._1)
  }
}","    }
    def main(args: Array[String]) = {
    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));
    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));
    assert(orderByPoints((List[Long]())).equals((List[Long]())));
    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));
    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));
    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));
    }

}
"
HumanEval_146,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //الرقم الأول والأخير من رقم واحد هو فردي (1, 3, 5, 7, 9).    //عدد العناصر في القائمة التي هي أكبر من 10 وكلاهما     //اكتب دالة تأخذ قائمة من الأرقام كمدخل وتعود     // >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))
    // (1l)
    // >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))
    // (2l)
    def specialFilter(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def specialFilter(nums: List[Long]): Long = {
    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
    
    nums.count { num =>
      val absNumStr = num.abs.toString
      val firstDigit = absNumStr.head
      val lastDigit = absNumStr.last
      
      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)
    }.toLong
  }

  def main(args: Array[String]): Unit = {
    println(specialFilter(List(15L, -73L, 14L, -15L))) // Output: 1
    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) // Output: 2
  }
}","    }
    def main(args: Array[String]) = {
    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));
    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));
    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));
    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));
    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));
    assert(specialFilter((List[Long](1l.toLong))) == (0l));
    assert(specialFilter((List[Long]())) == (0l));
    }

}
"
HumanEval_147,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //و a[i] + a[j] + a[k] هو مضاعف لـ 3.    //يعيد عدد الثلاثيات (a[i]، a[j]، a[k]) من a حيث i < j < k،     //لكل i (1 ≤ i ≤ n) ، قيمة a[i] = i * i - i + 1.     //تم إعطائك عدد صحيح إيجابي n. عليك أن تخلق قائمة بأعداد صحيحة a بطول n.    // >>> getMaxTriples((5l))
    // (1l)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    def getMaxTriples(n : Long) : Long = {
","def getMaxTriples(n: Long): Long = {
    val a = (1L to n).map(i => i * i - i + 1).toList
    var count = 0L

    for {
      i <- 0L until n
      j <- i + 1 until n
      k <- j + 1 until n
    } {
      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(getMaxTriples((5l)) == (1l));
    assert(getMaxTriples((6l)) == (4l));
    assert(getMaxTriples((10l)) == (36l));
    assert(getMaxTriples((100l)) == (53361l));
    }

}
"
HumanEval_148,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //ليست أسماء الكواكب الصحيحة    //يجب أن تعيد الدالة توبل فارغ إذا كان planet1 أو planet2     //القرب من الشمس    //تقع بين مدار الكوكب 1 و مدار الكوكب 2 ، مرتبة حسب    //يجب أن تعيد الدالة مجموعة تحتوي على جميع الكواكب التي تكون مداراتها     //اكتب دالة تأخذ اسمين لكوكب كسلسلة planet1 و planet2.    //أورانوس، نبتون    //هو عطارد، والآخر هو الزهرة، ثم الأرض، المريخ، المشتري، زحل،    //هناك ثمانية كواكب في نظامنا الشمسي: أقرب الكواكب إلى الشمس    // >>> bf((""Jupiter""), (""Neptune""))
    // (List[String](""Saturn"", ""Uranus""))
    // >>> bf((""Earth""), (""Mercury""))
    // (List[String](""Venus""))
    // >>> bf((""Mercury""), (""Uranus""))
    // (List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))
    def bf(planet1 : String, planet2 : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def bf(planet1: String, planet2: String): List[String] = {
    val planets = List(""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    
    // Find the indices of the given planets
    val index1Opt = planets.indexOf(planet1)
    val index2Opt = planets.indexOf(planet2)
    
    // If either planet is not found, return an empty list
    if (index1Opt == -1 || index2Opt == -1) {
      return List.empty
    }
    
    // Sort indices to ensure proper traversal direction
    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)
    
    // Get the planets between the indices
    planets.slice(startIndex + 1, endIndex)
  }
}","    }
    def main(args: Array[String]) = {
    assert(bf((""Jupiter""), (""Neptune"")).equals((List[String](""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Mercury"")).equals((List[String](""Venus""))));
    assert(bf((""Mercury""), (""Uranus"")).equals((List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))));
    assert(bf((""Neptune""), (""Venus"")).equals((List[String](""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Earth"")).equals((List[String]())));
    assert(bf((""Mars""), (""Earth"")).equals((List[String]())));
    assert(bf((""Jupiter""), (""Makemake"")).equals((List[String]())));
    }

}
"
HumanEval_149,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //قد تفترض أن كل الكلمات لها نفس الطول.    //يجب أن تعيد الدالة قائمة من السلاسل بترتيب مرتب.    //إذا كان للكلمتين نفس الطول، رتب القائمة حسب الأبجدية.    //يجب أن تعيد القائمة مرتبة حسب هذه القاعدة    //ترتيب القائمة يجب أن يكون صعودي حسب طول كل كلمة، وأنت    //وربما يحتوي على نسخ مكررة    //القائمة هي دائما قائمة من السلاسل وليس قائمة من الأرقام،     //ويعيد القائمة الناتجة مع ترتيب مرتبة،     //يزيل السلاسل التي لها أطوال فردية منه،     //اكتب دالة تقبل قائمة من السلاسل كمعلمة،    // >>> listSort((List[String](""aa"", ""a"", ""aaa"")))
    // (List[String](""aa""))
    // >>> listSort((List[String](""ab"", ""a"", ""aaa"", ""cd"")))
    // (List[String](""ab"", ""cd""))
    def sortedListSum(lst : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def listSort(lst: List[String]): List[String] = {
        lst.filter(_.length % 2 == 0)
           .sorted
           .sortBy(_.length)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortedListSum((List[String](""aa"", ""a"", ""aaa""))).equals((List[String](""aa""))));
    assert(sortedListSum((List[String](""school"", ""AI"", ""asdf"", ""b""))).equals((List[String](""AI"", ""asdf"", ""school""))));
    assert(sortedListSum((List[String](""d"", ""b"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""d"", ""dcba"", ""abcd"", ""a""))).equals((List[String](""abcd"", ""dcba""))));
    assert(sortedListSum((List[String](""AI"", ""ai"", ""au""))).equals((List[String](""AI"", ""ai"", ""au""))));
    assert(sortedListSum((List[String](""a"", ""b"", ""b"", ""c"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""aaaa"", ""bbbb"", ""dd"", ""cc""))).equals((List[String](""cc"", ""dd"", ""aaaa"", ""bbbb""))));
    }

}
"
HumanEval_150,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //عدد أولي ويجب أن يعيد قيمة y خلاف ذلك.    //برنامج بسيط يجب أن يعيد قيمة x إذا كان n هو     // >>> xOrY((7l), (34l), (12l))
    // (34l)
    // >>> xOrY((15l), (8l), (5l))
    // (5l)
    def xOrY(n : Long, x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def isPrime(num: Long): Boolean = {
    if (num <= 1) return false
    if (num <= 3) return true
    if (num % 2 == 0 || num % 3 == 0) return false
    var i = 5
    while (i * i <= num) {
      if (num % i == 0 || num % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def xOrY(n: Long, x: Long, y: Long): Long = {
    if (isPrime(n)) x else y
  }
}","    }
    def main(args: Array[String]) = {
    assert(xOrY((7l), (34l), (12l)) == (34l));
    assert(xOrY((15l), (8l), (5l)) == (5l));
    assert(xOrY((3l), (33l), (5212l)) == (33l));
    assert(xOrY((1259l), (3l), (52l)) == (3l));
    assert(xOrY((7919l), (-1l), (12l)) == (-1l));
    assert(xOrY((3609l), (1245l), (583l)) == (583l));
    assert(xOrY((91l), (56l), (129l)) == (129l));
    assert(xOrY((6l), (34l), (1234l)) == (1234l));
    assert(xOrY((1l), (2l), (0l)) == (0l));
    assert(xOrY((2l), (2l), (0l)) == (2l));
    }

}
"
HumanEval_151,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //في القائمة التي هي فردية. تجاهل الأرقام التي هي سلبية أو غير صحيحة.    //مع إعطاء قائمة من الأرقام، أعد مجموع مربعات الأرقام    // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))
    // (10l)
    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))
    // (0l)
    // >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))
    // (81l)
    // >>> doubleTheDifference((List[Float](0l.toLong)))
    // (0l)
    // If the input list is empty, return 0.
    def doubleTheDifference(lst : List[Float]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doubleTheDifference(lst: List[Float]): Long = {
    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)
      .map(x => x.toLong * x.toLong)
      .sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(doubleTheDifference((List[Float]())) == (0l));
    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));
    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));
    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));
    }

}
"
HumanEval_152,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //القيمة هي 0، وإذا لم تكن، فإن القيمة هي الفرق المطلق بين التخمين والنتيجة.    //يعيد قائمة ذات طول واحد تشير إلى مدى اختلاف كل تخمين. إذا كان التخمين صحيحاً،    //يتم إعطائك قائمتين من النتائج والخمسينات ذات الطول المتساو، حيث يظهر كل مؤشر تطابق.    //مهمتك هي تحديد ما إذا كان الشخص قد خمّن بشكل صحيح نتائج عدد من المباريات.    //بالتأكيد يستحق الإشارة والمقارنة    //الحدث معروف أخيراً المشاعر والأفكار التي لديك في تلك اللحظة هي    //أعتقد أننا جميعاً نتذكر ذلك الشعور عندما نرى نتيجة لبعض الأمور التي طال انتظارها    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))
    // (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))
    // >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))
    // (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))
    def compare(game : List[Long], guess : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def compare(game: List[Long], guess: List[Long]): List[Long] = {
    game.zip(guess).map { case (g, gs) => abs(g - gs) }
  }
}","    }
    def main(args: Array[String]) = {
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));
    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));
    }

}
"
HumanEval_153,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //(قوتها - 1)    //يعود ""Slices.SErviNGSliCes"" لأن ""SErviNGSliCes"" هو أقوى امتداد     //['SERVINGSliCes'، 'Cheese'، 'StuFfed'] ثم يجب عليك     //على سبيل المثال، إذا تم إعطائك ""Slices"" كطبقة وقائمة من     //اختر أول ما في القائمة    //إذا كان هناك اثنين أو أكثر من التمديدات بنفس القوة، يجب عليك    //الصيغة: ClassName.StrongestExtensionName.     //يجب أن تجد أقوى امتداد وترجع سلسلة في هذا    //في اسم التمديد، يتم إعطاء القوة من قبل الكسر CAP - SM.     //الحروف في اسم الإضافة، و SM يكون عدد الحروف الصغيرة     //قوة الإضافة هي كما يلي: دعونا CAP يكون رقم الحرف الكبير     //يجب استخدام التمديدات لتحميل فئات إضافية إلى الفئة.    //سيتم إعطائك اسم الفئة (سلسلة) وقائمة بالامتدادات.    // >>> StrongestExtension((""my_class""), (List[String](""AA"", ""Be"", ""CC"")))
    // (""my_class.AA"")
    def StrongestExtension(class_name : String, extensions : List[String]) : String = {
","def StrongestExtension(class_name: String, extensions: List[String]): String = {
        extensions.map { extension =>
            val capCount = extension.count(_.isUpper)
            val lowerCount = extension.count(_.isLower)
            val strength = capCount - lowerCount
            (extension, strength)
        }.maxBy(_._2)._1
    } match {
        case strongest => s""$class_name.$strongest""
    }
}","    }
    def main(args: Array[String]) = {
    assert(StrongestExtension((""Watashi""), (List[String](""tEN"", ""niNE"", ""eIGHt8OKe""))).equals((""Watashi.eIGHt8OKe"")));
    assert(StrongestExtension((""Boku123""), (List[String](""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""))).equals((""Boku123.YEs.WeCaNe"")));
    assert(StrongestExtension((""__YESIMHERE""), (List[String](""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""))).equals((""__YESIMHERE.NuLl__"")));
    assert(StrongestExtension((""K""), (List[String](""Ta"", ""TAR"", ""t234An"", ""cosSo""))).equals((""K.TAR"")));
    assert(StrongestExtension((""__HAHA""), (List[String](""Tab"", ""123"", ""781345"", ""-_-""))).equals((""__HAHA.123"")));
    assert(StrongestExtension((""YameRore""), (List[String](""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""))).equals((""YameRore.okIWILL123"")));
    assert(StrongestExtension((""finNNalLLly""), (List[String](""Die"", ""NowW"", ""Wow"", ""WoW""))).equals((""finNNalLLly.WoW"")));
    assert(StrongestExtension((""_""), (List[String](""Bb"", ""91245""))).equals((""_.Bb"")));
    assert(StrongestExtension((""Sp""), (List[String](""671235"", ""Bb""))).equals((""Sp.671235"")));
    }

}
"
HumanEval_154,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //تم إعطائك كلمتين. يجب أن تعيد true إذا كانت الكلمة الثانية أو أي من دوراناتها هي سلسلة فرعية في الكلمة الأولى     // >>> cycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> cycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> cycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> cycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> cycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> cycpatternCheck((""himenss""), (""simen""))
    // (true)
    def cycpatternCheck(a : String, b : String) : Boolean = {
","def cycpatternCheck(a: String, b: String): Boolean = {
  val bLength = b.length
  val bDouble = b + b // Create a string with b concatenated with itself to represent all rotations
  for (i <- 0 until bLength) {
    val rotation = bDouble.substring(i, i + bLength) // Get the current rotation
    if (a.contains(rotation)) return true
  }
  false
}","    }
    def main(args: Array[String]) = {
    assert(cycpatternCheck((""xyzw""), (""xyw"")) == (false));
    assert(cycpatternCheck((""yello""), (""ell"")) == (true));
    assert(cycpatternCheck((""whattup""), (""ptut"")) == (false));
    assert(cycpatternCheck((""efef""), (""fee"")) == (true));
    assert(cycpatternCheck((""abab""), (""aabb"")) == (false));
    assert(cycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //مع إعطاء عدد صحيح. يعود توبل الذي يحتوي على عدد من الأرقام الزوجية والفردية على التوالي.     // >>> evenOddCount((-12l))
    // ((1l, 1l))
    // >>> evenOddCount((123l))
    // ((1l, 2l))
    def evenOddCount(num : Long) : Tuple2[Long, Long] = {
","def evenOddCount(num: Long): Tuple2[Long, Long] = {
  val digits = num.abs.toString.map(_.asDigit)
  val evenCount = digits.count(_ % 2 == 0).toLong
  val oddCount = digits.count(_ % 2 != 0).toLong
  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddCount((7l)).equals(((0l, 1l))));
    assert(evenOddCount((-78l)).equals(((1l, 1l))));
    assert(evenOddCount((3452l)).equals(((2l, 2l))));
    assert(evenOddCount((346211l)).equals(((3l, 3l))));
    assert(evenOddCount((-345821l)).equals(((3l, 3l))));
    assert(evenOddCount((-2l)).equals(((1l, 0l))));
    assert(evenOddCount((-45347l)).equals(((2l, 3l))));
    assert(evenOddCount((0l)).equals(((1l, 0l))));
    }

}
"
HumanEval_156,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة:    //القيود: 1 <= num <= 1000     //و أعيديه بحروف صغيرة    //مع إعطاء عدد صحيح إيجابي، احصل على ما يعادله من الأرقام الرومانية كسلسلة،     // >>> intToMiniRoman((19l))
    // (""xix"")
    // >>> intToMiniRoman((152l))
    // (""clii"")
    // >>> intToMiniRoman((426l))
    // (""cdxxvi"")
    def intToMiniRoman(number : Long) : String = {
","import scala.collection.mutable._

object Problem {
  def intToMiniRoman(number: Long): String = {
    val romanMap: List[(Int, String)] = List(
      (1000, ""m""),
      (900, ""cm""),
      (500, ""d""),
      (400, ""cd""),
      (100, ""c""),
      (90, ""xc""),
      (50, ""l""),
      (40, ""xl""),
      (10, ""x""),
      (9, ""ix""),
      (5, ""v""),
      (4, ""iv""),
      (1, ""i"")
    )

    var num = number.toInt
    val stringBuilder = new StringBuilder

    for ((value, roman) <- romanMap) {
      while (num >= value) {
        stringBuilder.append(roman)
        num -= value
      }
    }

    stringBuilder.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(intToMiniRoman((19l)).equals((""xix"")));
    assert(intToMiniRoman((152l)).equals((""clii"")));
    assert(intToMiniRoman((251l)).equals((""ccli"")));
    assert(intToMiniRoman((426l)).equals((""cdxxvi"")));
    assert(intToMiniRoman((500l)).equals((""d"")));
    assert(intToMiniRoman((1l)).equals((""i"")));
    assert(intToMiniRoman((4l)).equals((""iv"")));
    assert(intToMiniRoman((43l)).equals((""xliii"")));
    assert(intToMiniRoman((90l)).equals((""xc"")));
    assert(intToMiniRoman((94l)).equals((""xciv"")));
    assert(intToMiniRoman((532l)).equals((""dxxxii"")));
    assert(intToMiniRoman((900l)).equals((""cm"")));
    assert(intToMiniRoman((994l)).equals((""cmxciv"")));
    assert(intToMiniRoman((1000l)).equals((""m"")));
    }

}
"
HumanEval_157,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //90 درجة    //مثلث ذو زاوية مستقيمة هو مثلث يكون فيه زاوية واحدة زاوية مستقيمة أو    //الجوانب تشكل مثلثًا زاوية مستقيمة، غير صحيح.    //معطياً أطوال الجوانب الثلاثة للمثلث، يعود صحيحاً إذا كانت الثلاثة    // >>> rightAngleTriangle((3l), (4l), (5l))
    // (true)
    // >>> rightAngleTriangle((1l), (2l), (3l))
    // (false)
    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {
","def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {
        val sides = List(a, b, c).sorted
        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)
    }
}","    }
    def main(args: Array[String]) = {
    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));
    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));
    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));
    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));
    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));
    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));
    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));
    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));
    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));
    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));
    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));
    }

}
"
HumanEval_158,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //الحروف، أعيد أول حرف يأتي في الترتيب المفصلي.    //من الأحرف الفريدة. إذا كان هناك عدد من السلاسل فريدة من    //تحتوي القائمة على كلمات مختلفة أعد الكلمة التي تحتوي على أقصى عدد    //اكتب دالة تقبل قائمة من السلاسل.    // >>> findMax((List[String](""name"", ""of"", ""string"")))
    // (""string"")
    // >>> findMax((List[String](""name"", ""enam"", ""game"")))
    // (""enam"")
    // >>> findMax((List[String](""aaaaaaa"", ""bb"", ""cc"")))
    // (""aaaaaaa"")
    def findMax(words : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findMax(words: List[String]): String = {
    words.maxBy(word => (word.toSet.size, -word.toLowerCase))
  }
}","    }
    def main(args: Array[String]) = {
    assert(findMax((List[String](""name"", ""of"", ""string""))).equals((""string"")));
    assert(findMax((List[String](""name"", ""enam"", ""game""))).equals((""enam"")));
    assert(findMax((List[String](""aaaaaaa"", ""bb"", ""cc""))).equals((""aaaaaaa"")));
    assert(findMax((List[String](""abc"", ""cba""))).equals((""abc"")));
    assert(findMax((List[String](""play"", ""this"", ""game"", ""of"", ""footbott""))).equals((""footbott"")));
    assert(findMax((List[String](""we"", ""are"", ""gonna"", ""rock""))).equals((""gonna"")));
    assert(findMax((List[String](""we"", ""are"", ""a"", ""mad"", ""nation""))).equals((""nation"")));
    assert(findMax((List[String](""this"", ""is"", ""a"", ""prrk""))).equals((""this"")));
    assert(findMax((List[String](""b""))).equals((""b"")));
    assert(findMax((List[String](""play"", ""play"", ""play""))).equals((""play"")));
    }

}
"
HumanEval_159,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //مثال:    //إذا لم يكن هناك ما يكفي من الجزر المتبقي، سوف تأكل كل الجزر المتبقي، ولكن سوف لا تزال جائعة.    //عدد الجزر المتبقي بعد وجبات الطعام    //يجب عليك إرجاع قائمة [العدد الإجمالي للجزر الذي أكلته بعد وجبات الطعام،     //ولكن الآن تحتاجين لتناول المزيد من الجزر لتكملي وجبات اليوم    //أنت أرنب جائع، وقد أكلت بالفعل عدد معين من الجزر،    // >>> eat((5l), (6l), (10l))
    // (List[Long](11l.toLong, 4l.toLong))
    // >>> eat((4l), (8l), (9l))
    // (List[Long](12l.toLong, 1l.toLong))
    // >>> eat((1l), (10l), (10l))
    // (List[Long](11l.toLong, 0l.toLong))
    // >>> eat((2l), (11l), (5l))
    // (List[Long](7l.toLong, 0l.toLong))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def eat(number: Long, need: Long, remaining: Long): List[Long] = {
    val totalNeeded = number + need
    if (remaining >= need) {
      List(totalNeeded, remaining - need)
    } else {
      List(number + remaining, 0)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));
    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));
    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));
    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));
    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));
    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));
    }

}
"
HumanEval_160,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //قائمة المشغل لديها على الأقل مشغل واحد، وقائمة العمليات لديها على الأقل اثنين من العمليات.    //أوبراند هو قائمة من الأعداد الصحيحة غير السالبة.    //طول قائمة المشغلات يساوي طول قائمة العاملات ناقص واحد.    //ملاحظة:    //= النتيجة = 9     //النتيجة = 2 + 3 * 4 - 5     //القائمة = [2, 3, 4, 5]     //المفتاح ['+'، '*'، '-']     //مثال:    //التأثير (**)     //قسمة الطابق ( // )     //ضرب (*)     //- - - - - - - - - - - - -    //إضافة (+)     //العمليات الجبرية الأساسية:    //ويعود التقييم لهذا التعبير.    //القائمة الثانية هي قائمة من الأعداد الصحيحة. استخدم القائمتين المقدمتين لبناء الجبر     //مع إعطاء قائمتين للمشغل، والعمليات. القائمة الأولى لديها عمليات الجبر الأساسية، و     def doAlgebra(op : List[String], operand : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doAlgebra(op: List[String], operand: List[Long]): Long = {
    var result = operand.head
    for (i <- 0 until op.length) {
      op(i) match {
        case ""+"" => result += operand(i + 1)
        case ""-"" => result -= operand(i + 1)
        case ""*"" => result *= operand(i + 1)
        case ""//"" => result /= operand(i + 1)
        case ""**"" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong
      }
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val operators = List(""+"", ""*"", ""-"")
    val operands = List(2L, 3L, 4L, 5L)
    println(doAlgebra(operators, operands)) // Output: 9
  }
}","    }
    def main(args: Array[String]) = {
    assert(doAlgebra((List[String](""**"", ""*"", ""+"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));
    assert(doAlgebra((List[String](""+"", ""*"", ""-"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));
    assert(doAlgebra((List[String](""//"", ""*"")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));
    }

}
"
HumanEval_161,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //أمثلة     //يجب أن تعيد الدالة السلسلة الناتجة.    //إذا كانت السلسلة لا تحتوي على أحرف، عكس السلسلة.    //وإلا فلتبقيه كما هو    //إذا كانت s[i] حرفاً، قم بإعادة حروفها من الأسفل إلى الأعلى أو العكس بالعكس،     //تم إعطائك سلسلة من السلاسل    // >>> solve((""1234""))
    // (""4321"")
    // >>> solve((""ab""))
    // (""AB"")
    // >>> solve((""#a@C""))
    // (""#A@c"")
    def solve(s : String) : String = {
","def solve(s: String): String = {
    if (s.exists(_.isLetter)) {
      s.map {
        case c if c.isLetter && c.isLower => c.toUpper
        case c if c.isLetter && c.isUpper => c.toLower
        case c => c
      }.mkString
    } else {
      s.reverse
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(solve((""AsDf"")).equals((""aSdF"")));
    assert(solve((""1234"")).equals((""4321"")));
    assert(solve((""ab"")).equals((""AB"")));
    assert(solve((""#a@C"")).equals((""#A@c"")));
    assert(solve((""#AsdfW^45"")).equals((""#aSDFw^45"")));
    assert(solve((""#6@2"")).equals((""2@6#"")));
    assert(solve((""#$a^D"")).equals((""#$A^d"")));
    assert(solve((""#ccc"")).equals((""#CCC"")));
    }

}
"
HumanEval_162,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //إذا كان 'text' سلسلة فارغة، فيرجع None.    //مع إعطاء سلسلة 'text' ، أعد سلسلة md5 hash المكافئة.     // >>> stringToMd5((""Hello world""))
    // Some(""3e25960a79dbc69b674cd4ec67a72c62"")
    def stringToMd5(text : String) : Option[String] = {
","import java.security.MessageDigest

object Problem {
  def stringToMd5(text: String): Option[String] = {
    if (text.isEmpty) None
    else {
      val md = MessageDigest.getInstance(""MD5"")
      val digest = md.digest(text.getBytes)
      Some(digest.map(""%02x"".format(_)).mkString)
    }
  }
}

// Example usage:
// println(Problem.stringToMd5(""Hello world""))  // Output: Some(""3e25960a79dbc69b674cd4ec67a72c62"")","    }
    def main(args: Array[String]) = {
    assert(stringToMd5((""Hello world"")).equals(Some(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert(stringToMd5(("""")).equals(None));
    assert(stringToMd5((""A B C"")).equals(Some(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert(stringToMd5((""password"")).equals(Some(""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,arb_Arab,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //على سبيل المثال:    //و (ب) ، بالترتيب المتصاعد.    //مع إعطاء عددين صحيحين إيجابيين a و b، أعد الأرقام الزوجية بين a     // >>> generateIntegers((2l), (8l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((8l), (2l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((10l), (14l))
    // (List[Long]())
    def generateIntegers(a : Long, b : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def generateIntegers(a: Long, b: Long): List[Long] = {
    val start = min(a, b)
    val end = max(a, b)
    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i
    evenNumbers.map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((17l), (89l)).equals((List[Long]())));
    }

}
"
