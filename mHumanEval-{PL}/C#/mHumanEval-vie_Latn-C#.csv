task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //    //Kiểm tra xem trong danh sách các số đã cho, có hai số nào gần nhau hơn     // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))
    // (false)
    // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))
    // (true)
    public static bool HasCloseElements(List<float> numbers, float threshold) {
","public static bool HasCloseElements(List<float> numbers, float threshold) {
    numbers.Sort();
    for (int i = 1; i < numbers.Count; i++) {
        if (numbers[i] - numbers[i - 1] < threshold) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
    }

}
"
HumanEval_1,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bỏ qua bất kỳ khoảng trống nào trong chuỗi đầu vào.    //Các nhóm riêng biệt được cân bằng (mỗi miếng đệm mở được đóng đúng cách) và không lồng nhau trong nhau.    //tách nhóm đó thành các chuỗi riêng biệt và trả về danh sách của những người đó.    //Lượng đầu vào của hàm này là một chuỗi chứa nhiều nhóm các dấu ngoặc vị. Mục tiêu của bạn là để     // >>> SeparateParenGroups((""( ) (( )) (( )( ))""))
    // (new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))
    public static List<string> SeparateParenGroups(string paren_string) {
","public static List<string> SeparateParenGroups(string paren_string) {
        List<string> result = new List<string>();
        StringBuilder currentGroup = new StringBuilder();
        int balance = 0;

        foreach (char c in paren_string) {
            if (c == ' ') {
                continue;
            }

            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }

            currentGroup.Append(c);

            // When balance is zero, we have a complete group
            if (balance == 0 && currentGroup.Length > 0) {
                result.Add(currentGroup.ToString());
                currentGroup.Clear();
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SeparateParenGroups((""(()()) ((())) () ((())()())"")).Equals((new List<string>(new string[]{(string)""(()())"", (string)""((()))"", (string)""()"", (string)""((())()())""}))));
    Debug.Assert(SeparateParenGroups((""() (()) ((())) (((())))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""((()))"", (string)""(((())))""}))));
    Debug.Assert(SeparateParenGroups((""(()(())((())))"")).Equals((new List<string>(new string[]{(string)""(()(())((())))""}))));
    Debug.Assert(SeparateParenGroups((""( ) (( )) (( )( ))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))));
    }

}
"
HumanEval_2,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về phần thập phân của số.    //(phần còn lại luôn luôn nhỏ hơn 1).    //và phần số nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và thập phân     //Với một số điểm nổi dương, nó có thể được phân hủy thành     // >>> TruncateNumber((3.5f))
    // (0.5f)
    public static float TruncateNumber(float number) {
","using System;

class Problem {
    // Given a positive floating point number, it can be decomposed into
    // an integer part (largest integer smaller than the given number) and decimals
    // (leftover part always smaller than 1).
    // Return the decimal part of the number.
    public static float TruncateNumber(float number) {
        return number - (float)Math.Floor(number);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TruncateNumber((3.5f)) == (0.5f));
    Debug.Assert(TruncateNumber((1.25f)) == (0.25f));
    Debug.Assert(TruncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //tại điểm đó hàm phải trả về true. Nếu không nó sẽ trả về false.    //n số dư bằng không. n nhiệm vụ của bạn là phát hiện nếu tại bất kỳ thời điểm nào số dư tài khoản giảm xuống dưới số không, và n số dư của bạn là n số dư của tài khoản của bạn.    //Bạn được đưa ra một danh sách các hoạt động gửi và rút tiền trên tài khoản ngân hàng bắt đầu với     // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (false)
    // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L})))
    // (true)
    public static bool BelowZero(List<long> operations) {
","long balance = 0;
    foreach (var operation in operations) {
        balance += operation;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowZero((new List<long>())) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-3L, (long)1L, (long)2L, (long)-3L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-5L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-2L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (true));
    }

}
"
HumanEval_4,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //MAD = trung bình. x - x_mean.     //phần tử và một điểm trung tâm (trong trường hợp này là trung bình):     //Phân tích trung bình là sự khác biệt trung bình giữa mỗi    //khoảng trung bình của bộ dữ liệu này.     //Đối với một danh sách các số đầu vào đã cho, tính toán Phân tích tuyệt đối trung bình     // >>> MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))
    // (1.0f)
    public static float MeanAbsoluteDeviation(List<float> numbers) {
","if (numbers == null || numbers.Count == 0)
    {
        throw new ArgumentException(""The list of numbers must not be null or empty."");
    }
    
    float sum = 0.0f;
    foreach (float number in numbers)
    {
        sum += number;
    }

    float mean = sum / numbers.Count;
    float absoluteDeviationSum = 0.0f;
    
    foreach (float number in numbers)
    {
        absoluteDeviationSum += Math.Abs(number - mean);
    }
    
    float meanAbsoluteDeviation = absoluteDeviationSum / numbers.Count;
    return meanAbsoluteDeviation;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f}))) == (0.5f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
    }

}
"
HumanEval_5,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Chèn một số ""định giới hạn"" giữa mỗi hai phần tử liên tiếp của danh sách đầu vào `số'     // >>> Intersperse((new List<long>()), (4L))
    // (new List<long>())
    // >>> Intersperse((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (4L))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)4L, (long)3L}))
    public static List<long> Intersperse(List<long> numbers, long delimeter) {
","public static List<long> Intersperse(List<long> numbers, long delimeter)
{
    List<long> result = new List<long>();

    if (numbers == null || numbers.Count == 0)
    {
        return result;
    }

    for (int i = 0; i < numbers.Count; i++)
    {
        result.Add(numbers[i]);
        if (i < numbers.Count - 1)
        {
            result.Add(delimeter);
        }
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersperse((new List<long>()), (7L)).Equals((new List<long>())));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)2L})), (8L)).Equals((new List<long>(new long[]{(long)5L, (long)8L, (long)6L, (long)8L, (long)3L, (long)8L, (long)2L}))));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)2L, (long)2L, (long)2L})), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L, (long)2L, (long)2L}))));
    }

}
"
HumanEval_6,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ: (() (()) có tối đa hai cấp độ làm tổ trong khi ((())) có ba.     //Đối với mỗi nhóm, xuất ra mức độ sâu nhất của tổ của dấu ngoặc kép.     //Đầu vào của hàm này là một chuỗi đại diện cho nhiều nhóm cho các dấu ngoặc vị được chia cách bởi các khoảng trống.    // >>> ParseNestedParens((""(()()) ((())) () ((())()())""))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))
    public static List<long> ParseNestedParens(string paren_string) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> ParseNestedParens(string paren_string) {
        List<long> nestingLevels = new List<long>();
        string[] groups = paren_string.Split(' ');

        foreach (string group in groups) {
            long currentLevel = 0;
            long maxLevel = 0;

            foreach (char c in group) {
                if (c == '(') {
                    currentLevel++;
                    if (currentLevel > maxLevel) {
                        maxLevel = currentLevel;
                    }
                } else if (c == ')') {
                    currentLevel--;
                }
            }

            nestingLevels.Add(maxLevel);
        }

        return nestingLevels;
    }

    static void Main(string[] args) {
        string input = ""(()()) ((())) () ((())()())"";
        List<long> result = ParseNestedParens(input);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseNestedParens((""(()()) ((())) () ((())()())"")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(ParseNestedParens((""() (()) ((())) (((())))"")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(ParseNestedParens((""(()(())((())))"")).Equals((new List<long>(new long[]{(long)4L}))));
    }

}
"
HumanEval_7,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bộ lọc một danh sách đầu vào của chuỗi chỉ cho những người có chứa substring     // >>> FilterBySubstring((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterBySubstring((new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""array""}))
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
        List<string> result = new List<string>();
        foreach (string str in strings) {
            if (str.Contains(substring)) {
                result.Add(str);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterBySubstring((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""aaaxxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""aaaxxy"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""grunt"", (string)""trumpet"", (string)""prune"", (string)""gruesome""})), (""run"")).Equals((new List<string>(new string[]{(string)""grunt"", (string)""prune""}))));
    }

}
"
HumanEval_8,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Số rỗng nên bằng 0 và sản phẩm rỗng nên bằng 1.    //Đối với một danh sách các số nguyên nhất định, trả về một tuple bao gồm tổng và sản phẩm của tất cả các số nguyên trong danh sách.     // >>> SumProduct((new List<long>()))
    // (Tuple.Create(0L, 1L))
    // >>> SumProduct((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (Tuple.Create(10L, 24L))
    public static Tuple<long, long> SumProduct(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<long, long> SumProduct(List<long> numbers) {
        long sum = 0L;
        long product = 1L;

        foreach (var number in numbers) {
            sum += number;
            product *= number;
        }

        return Tuple.Create(sum, product);
    }

    static void Main(string[] args) {
        // Test cases
        var result1 = SumProduct(new List<long>());
        Console.WriteLine($""({result1.Item1}, {result1.Item2})""); // Should output (0, 1)

        var result2 = SumProduct(new List<long> { 1L, 2L, 3L, 4L });
        Console.WriteLine($""({result2.Item1}, {result2.Item2})""); // Should output (10, 24)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumProduct((new List<long>())).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)1L, (long)1L, (long)1L}))).Equals((Tuple.Create(3L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)100L, (long)0L}))).Equals((Tuple.Create(100L, 0L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))).Equals((Tuple.Create(15L, 105L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)10L}))).Equals((Tuple.Create(10L, 10L))));
    }

}
"
HumanEval_9,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //trong trình tự.    //Từ một danh sách các số nguyên đã cho, tạo ra một danh sách các phần tử tối đa lăn được tìm thấy cho đến thời điểm nhất định.    // >>> RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L}))
    public static List<long> RollingMax(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> RollingMax(List<long> numbers) {
        List<long> rollingMaxList = new List<long>();
        long currentMax = long.MinValue;

        foreach (var number in numbers) {
            if (number > currentMax) {
                currentMax = number;
            }
            rollingMaxList.Add(currentMax);
        }

        return rollingMaxList;
    }

    public static void Main(string[] args) {
        List<long> numbers = new List<long> { 1L, 2L, 3L, 2L, 3L, 4L, 2L };
        List<long> result = RollingMax(numbers);
        Console.WriteLine(""Rolling Max: "" + string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RollingMax((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)3L, (long)2L, (long)3L, (long)100L, (long)3L}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)100L, (long)100L}))));
    }

}
"
HumanEval_10,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //- Thêm vào cuối chuỗi ngược của một tiền tố chuỗi xuất hiện trước hậu tố palindromic.    //- Tìm postfix dài nhất của chuỗi cung cấp là một palindrome.     //Ý tưởng thuật toán rất đơn giản:    //Tìm palindrome ngắn nhất bắt đầu với một chuỗi được cung cấp.     // >>> MakePalindrome((""""))
    // ("""")
    // >>> MakePalindrome((""cat""))
    // (""catac"")
    // >>> MakePalindrome((""cata""))
    // (""catac"")
    public static string MakePalindrome(string str) {
","if (string.IsNullOrEmpty(str)) return str;

    int maxPalindromeLength = 0;
    for (int i = 0; i < str.Length; i++) {
        if (IsPalindrome(str, i, str.Length - 1)) {
            maxPalindromeLength = str.Length - i;
            break;
        }
    }

    string suffixToPrepend = str.Substring(0, str.Length - maxPalindromeLength);
    char[] reversedPrefix = suffixToPrepend.Reverse().ToArray();
    return str + new string(reversedPrefix);
}

private static bool IsPalindrome(string str, int left, int right) {
    while (left < right) {
        if (str[left] != str[right]) return false;
        left++;
        right--;
    }
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakePalindrome(("""")).Equals(("""")));
    Debug.Assert(MakePalindrome((""x"")).Equals((""x"")));
    Debug.Assert(MakePalindrome((""xyz"")).Equals((""xyzyx"")));
    Debug.Assert(MakePalindrome((""xyx"")).Equals((""xyx"")));
    Debug.Assert(MakePalindrome((""jerry"")).Equals((""jerryrrej"")));
    }

}
"
HumanEval_11,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Thực hiện XOR nhị phân trên các đầu vào này và trả về kết quả cũng như một chuỗi.     //Input là hai chuỗi a và b chỉ bao gồm 1 và 0.    // >>> StringXor((""010""), (""110""))
    // (""100"")
    public static string StringXor(string a, string b) {
","if (a.Length != b.Length) {
        throw new ArgumentException(""Input strings must be of the same length."");
    }

    StringBuilder result = new StringBuilder(a.Length);

    for (int i = 0; i < a.Length; i++) {
        result.Append(a[i] == b[i] ? '0' : '1');
    }

    return result.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringXor((""111000""), (""101010"")).Equals((""010010"")));
    Debug.Assert(StringXor((""1""), (""1"")).Equals((""0"")));
    Debug.Assert(StringXor((""0101""), (""0000"")).Equals((""0101"")));
    }

}
"
HumanEval_12,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //trả về null trong trường hợp danh sách đầu vào là trống.    //Trong danh sách các chuỗi, trả về dài nhất. trả về đầu tiên trong trường hợp nhiều.    // >>> Longest((new List<string>()))
    // null
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""a"")
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""bb"", (string)""ccc""})))
    // (""ccc"")
    public static string Longest(List<string> strings) {
","if (strings == null || strings.Count == 0)
    {
        return null;
    }
    
    string longest = strings[0];
    
    foreach (string str in strings)
    {
        if (str.Length > longest.Length)
        {
            longest = str;
        }
    }
    
    return longest;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Longest((new List<string>())).Equals(null));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""x"")));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""yyy"", (string)""zzzz"", (string)""www"", (string)""kkkk"", (string)""abc""}))).Equals((""zzzz"")));
    }

}
"
HumanEval_13,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về đại chia chung lớn nhất của hai số nguyên a và b     // >>> GreatestCommonDivisor((3L), (5L))
    // (1L)
    // >>> GreatestCommonDivisor((25L), (15L))
    // (5L)
    public static long GreatestCommonDivisor(long a, long b) {
","// Base case: if b is 0, gcd is a
    if (b == 0)
        return a;
    
    // Recursive call: gcd(a, b) = gcd(b, a % b)
    return GreatestCommonDivisor(b, a % b);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GreatestCommonDivisor((3L), (7L)) == (1L));
    Debug.Assert(GreatestCommonDivisor((10L), (15L)) == (5L));
    Debug.Assert(GreatestCommonDivisor((49L), (14L)) == (7L));
    Debug.Assert(GreatestCommonDivisor((144L), (60L)) == (12L));
    }

}
"
HumanEval_14,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về danh sách tất cả các tiền tố từ ngắn nhất đến dài nhất của chuỗi đầu vào     // >>> AllPrefixes((""abc""))
    // (new List<string>(new string[]{(string)""a"", (string)""ab"", (string)""abc""}))
    public static List<string> AllPrefixes(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list of all prefixes from shortest to longest of the input string
    public static List<string> AllPrefixes(string str) {
        List<string> prefixes = new List<string>();
        for (int i = 1; i <= str.Length; i++) {
            prefixes.Add(str.Substring(0, i));
        }
        return prefixes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AllPrefixes(("""")).Equals((new List<string>())));
    Debug.Assert(AllPrefixes((""asdfgh"")).Equals((new List<string>(new string[]{(string)""a"", (string)""as"", (string)""asd"", (string)""asdf"", (string)""asdfg"", (string)""asdfgh""}))));
    Debug.Assert(AllPrefixes((""WWW"")).Equals((new List<string>(new string[]{(string)""W"", (string)""WW"", (string)""WWW""}))));
    }

}
"
HumanEval_15,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về một chuỗi chứa các số giới hạn không gian bắt đầu từ 0 đến n.    // >>> StringSequence((0L))
    // (""0"")
    // >>> StringSequence((5L))
    // (""0 1 2 3 4 5"")
    public static string StringSequence(long n) {
","public static string StringSequence(long n) {
    StringBuilder sb = new StringBuilder();
    for (long i = 0; i <= n; i++) {
        if (i > 0) {
            sb.Append("" "");
        }
        sb.Append(i);
    }
    return sb.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringSequence((0L)).Equals((""0"")));
    Debug.Assert(StringSequence((3L)).Equals((""0 1 2 3"")));
    Debug.Assert(StringSequence((10L)).Equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Cho một chuỗi, tìm ra bao nhiêu ký tự riêng biệt (cho dù trường hợp) nó bao gồm     // >>> CountDistinctCharacters((""xyzXYZ""))
    // (3L)
    // >>> CountDistinctCharacters((""Jerry""))
    // (4L)
    public static long CountDistinctCharacters(string str) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long CountDistinctCharacters(string str) {
        // Convert the string to lower case to handle case insensitivity
        str = str.ToLower();

        // Use a HashSet to store distinct characters
        HashSet<char> distinctChars = new HashSet<char>(str);

        // Return the count of distinct characters
        return distinctChars.Count;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountDistinctCharacters(("""")) == (0L));
    Debug.Assert(CountDistinctCharacters((""abcde"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""abcdecadeCADE"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""aaaaAAAAaaaa"")) == (1L));
    Debug.Assert(CountDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5L));
    }

}
"
HumanEval_17,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //""Hơi"" - một nốt bốn, kéo dài một nhịp.    //'o sa' - nửa nốt, kéo dài hai nhịp.    //'O' - toàn bộ nốt, kéo dài bốn nhịp     //Đây là một truyền thuyết:    //Không phải cuối cùng.    //Nhiệm vụ của bạn là phân tích chuỗi này và trả về danh sách các số nguyên tương ứng với bao nhiêu nhịp mỗi lần     //Đầu vào của hàm này là một chuỗi đại diện cho các nốt nhạc trong định dạng ASCII đặc biệt.    // >>> ParseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (new List<long>(new long[]{(long)4L, (long)2L, (long)1L, (long)2L, (long)2L, (long)1L, (long)1L, (long)1L, (long)1L, (long)4L, (long)4L}))
    public static List<long> ParseMusic(string music_string) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> ParseMusic(string music_string)
    {
        List<long> beats = new List<long>();
        string[] notes = music_string.Split(' ');
        
        foreach (string note in notes)
        {
            switch (note)
            {
                case ""o"":
                    beats.Add(4L);
                    break;
                case ""o|"":
                    beats.Add(2L);
                    break;
                case "".|"":
                    beats.Add(1L);
                    break;
                default:
                    break;
            }
        }
        
        return beats;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseMusic(("""")).Equals((new List<long>())));
    Debug.Assert(ParseMusic((""o o o o"")).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic(("".| .| .| .|"")).Equals((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}))));
    Debug.Assert(ParseMusic((""o| o| .| .| o o o o"")).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)1L, (long)1L, (long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic((""o| .| o| .| o o| o o|"")).Equals((new List<long>(new long[]{(long)2L, (long)1L, (long)2L, (long)1L, (long)4L, (long)2L, (long)4L, (long)2L}))));
    }

}
"
HumanEval_18,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Tìm ra số lần một chuỗi con nhất định có thể được tìm thấy trong chuỗi gốc. Đếm các trường hợp chồng chéo.     // >>> HowManyTimes((""""), (""a""))
    // (0L)
    // >>> HowManyTimes((""aaa""), (""a""))
    // (3L)
    // >>> HowManyTimes((""aaaa""), (""aa""))
    // (3L)
    public static long HowManyTimes(string str, string substring) {
","using System;

class Problem {
    public static long HowManyTimes(string str, string substring) {
        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring)) {
            return 0L;
        }

        long count = 0;
        int index = 0;

        while ((index = str.IndexOf(substring, index)) != -1) {
            count++;
            index++;
        }

        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(HowManyTimes(""aaa"", ""a"")); // Output: 3
        Console.WriteLine(HowManyTimes(""aaaa"", ""aa"")); // Output: 3
        Console.WriteLine(HowManyTimes("""", ""a"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HowManyTimes((""""), (""x"")) == (0L));
    Debug.Assert(HowManyTimes((""xyxyxyx""), (""x"")) == (4L));
    Debug.Assert(HowManyTimes((""cacacacac""), (""cac"")) == (4L));
    Debug.Assert(HowManyTimes((""john doe""), (""john"")) == (1L));
    }

}
"
HumanEval_19,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về chuỗi với các số được sắp xếp từ nhỏ nhất đến lớn nhất     //Các lựa chọn hợp lệ là ""không"", ""một"", ""hai"", ""ba"", ""bốn"", ""năm"", ""sáu"", ""bảy"", ""tám"" và ""chín"".     //Lượng đầu vào là một chuỗi số giới hạn không gian từ 'không' đến 'chín'.    // >>> SortNumbers((""three one five""))
    // (""one three five"")
    public static string SortNumbers(string numbers) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static string SortNumbers(string numbers)
    {
        Dictionary<string, int> numberWords = new Dictionary<string, int>
        {
            { ""zero"", 0 },
            { ""one"", 1 },
            { ""two"", 2 },
            { ""three"", 3 },
            { ""four"", 4 },
            { ""five"", 5 },
            { ""six"", 6 },
            { ""seven"", 7 },
            { ""eight"", 8 },
            { ""nine"", 9 }
        };

        List<string> numberList = new List<string>(numbers.Split(' '));
        numberList.Sort((a, b) => numberWords[a].CompareTo(numberWords[b]));
        return string.Join("" "", numberList);
    }

    static void Main(string[] args)
    {
        Console.WriteLine(SortNumbers(""three one five"")); // Output: ""one three five""
        Console.WriteLine(SortNumbers(""nine eight seven six"")); // Output: ""six seven eight nine""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortNumbers(("""")).Equals(("""")));
    Debug.Assert(SortNumbers((""three"")).Equals((""three"")));
    Debug.Assert(SortNumbers((""three five nine"")).Equals((""three five nine"")));
    Debug.Assert(SortNumbers((""five zero four seven nine eight"")).Equals((""zero four five seven eight nine"")));
    Debug.Assert(SortNumbers((""six five four three two one zero"")).Equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //khác và trả chúng theo thứ tự (số ít hơn, số lớn hơn).    //Từ một danh sách các số được cung cấp (có chiều dài ít nhất là hai) chọn và trả về hai số gần nhất với mỗi số     // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))
    // (Tuple.Create(2.0f, 2.2f))
    // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))
    // (Tuple.Create(2.0f, 2.0f))
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
        if (numbers == null || numbers.Count < 2) {
            throw new ArgumentException(""List must contain at least two numbers."");
        }
        
        numbers.Sort();
        float minDifference = float.MaxValue;
        Tuple<float, float> closestPair = null;

        for (int i = 0; i < numbers.Count - 1; i++) {
            float difference = numbers[i + 1] - numbers[i];
            if (difference < minDifference) {
                minDifference = difference;
                closestPair = Tuple.Create(numbers[i], numbers[i + 1]);
            }
        }

        return closestPair;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(3.9f, 4.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))).Equals((Tuple.Create(5.0f, 5.9f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(2.0f, 2.2f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))).Equals((Tuple.Create(2.0f, 2.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))).Equals((Tuple.Create(2.2f, 3.1f))));
    }

}
"
HumanEval_21,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Như vậy số nhỏ nhất sẽ trở thành 0 và số lớn nhất sẽ trở thành 1     //Cho danh sách các số (ít nhất là hai yếu tố), áp dụng một chuyển đổi tuyến tính cho danh sách đó,     // >>> RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))
    // (new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))
    public static List<float> RescaleToUnit(List<float> numbers) {
","public static List<float> RescaleToUnit(List<float> numbers) {
        if (numbers == null || numbers.Count < 2)
            throw new ArgumentException(""List must contain at least two elements."");

        float min = numbers.Min();
        float max = numbers.Max();

        if (min == max)
            throw new ArgumentException(""All elements are the same. Cannot rescale."");

        return numbers.Select(num => (num - min) / (max - min)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)100.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)1.0f, (float)0.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    }

}
"
HumanEval_22,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bộ lọc danh sách cho bất kỳ giá trị csthon chỉ cho các số nguyên     // >>> FilterIntegers((new List<object>(new string[]{(string)""a"", (string)3.14f, (string)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> FilterIntegers((new List<object>(new object[]{1L, 2L, 3L, ""abc"", new List<object>()})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    public static List<long> FilterIntegers(List<object> values) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> FilterIntegers(List<object> values) {
        List<long> result = new List<long>();
        foreach (var value in values) {
            if (value is long) {
                result.Add((long)value);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterIntegers((new List<object>())).Equals((new List<long>())));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{4L, new List<object>(), 23.2f, 9L, ""adasd""}))).Equals((new List<long>(new long[]{(long)4L, (long)9L}))));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{3L, ""c"", 3L, 3L, ""a"", ""b""}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_23,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trải về chiều dài của chuỗi được cho     // >>> StringLength((""""))
    // (0L)
    // >>> StringLength((""abc""))
    // (3L)
    public static long Strlen(string str) {
","return str.Length;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Strlen(("""")) == (0L));
    Debug.Assert(Strlen((""x"")) == (1L));
    Debug.Assert(Strlen((""asdasnakj"")) == (9L));
    }

}
"
HumanEval_24,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Đối với một số n, tìm số lớn nhất chia n đều, nhỏ hơn n     // >>> LargestDivisor((15L))
    // (5L)
    public static long LargestDivisor(long n) {
","if (n <= 1)
        {
            throw new ArgumentOutOfRangeException(""n must be greater than 1"");
        }
        for (long i = n / 2; i >= 1; i--)
        {
            if (n % i == 0)
            {
                return i;
            }
        }
        return 1; // This line is theoretically unreachable since 1 is always a divisor of n
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestDivisor((3L)) == (1L));
    Debug.Assert(LargestDivisor((7L)) == (1L));
    Debug.Assert(LargestDivisor((10L)) == (5L));
    Debug.Assert(LargestDivisor((100L)) == (50L));
    Debug.Assert(LargestDivisor((49L)) == (7L));
    }

}
"
HumanEval_25,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Số đầu vào phải bằng với sản phẩm của tất cả các yếu tố.    //Mỗi yếu tố nên được liệt kê số lần tương ứng với số lần nó xuất hiện trong phân giải.    //Trả về danh sách các nhân số nguyên tố của số nguyên được đưa ra theo thứ tự từ nhỏ nhất đến lớn nhất.    // >>> Factorize((8L))
    // (new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))
    // >>> Factorize((25L))
    // (new List<long>(new long[]{(long)5L, (long)5L}))
    // >>> Factorize((70L))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)7L}))
    public static List<long> Factorize(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Factorize(long n) {
        List<long> factors = new List<long>();
        for (long i = 2; i * i <= n; i++) {
            while (n % i == 0) {
                factors.Add(i);
                n /= i;
            }
        }
        if (n > 1) {
            factors.Add(n);
        }
        return factors;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Factorize((2L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Factorize((4L)).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Factorize((8L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))));
    Debug.Assert(Factorize((57L)).Equals((new List<long>(new long[]{(long)3L, (long)19L}))));
    Debug.Assert(Factorize((3249L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((185193L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((20577L)).Equals((new List<long>(new long[]{(long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_26,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Giữ thứ tự của các yếu tố trái giống như trong đầu vào.    //Từ một danh sách các số nguyên, loại bỏ tất cả các phần tử xuất hiện nhiều hơn một lần.    // >>> RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)4L}))
    public static List<long> RemoveDuplicates(List<long> numbers) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    // From a list of integers, remove all elements that occur more than once.
    // Keep order of elements left the same as in the input.
    public static List<long> RemoveDuplicates(List<long> numbers)
    {
        var elementCount = numbers.GroupBy(n => n)
                                  .ToDictionary(g => g.Key, g => g.Count());

        return numbers.Where(n => elementCount[n] == 1).ToList();
    }

    static void Main(string[] args)
    {
        List<long> numbers = new List<long> { 1, 2, 3, 2, 4 };
        List<long> result = RemoveDuplicates(numbers);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveDuplicates((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L, (long)3L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)5L}))));
    }

}
"
HumanEval_27,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Đối với một chuỗi được cho, xoay các ký tự chữ cái nhỏ thành chữ cái lớn và chữ cái lớn thành chữ cái nhỏ.     // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
","using System;

class Problem {
    // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
        char[] chars = str.ToCharArray();
        for (int i = 0; i < chars.Length; i++) {
            if (char.IsUpper(chars[i])) {
                chars[i] = char.ToLower(chars[i]);
            } else if (char.IsLower(chars[i])) {
                chars[i] = char.ToUpper(chars[i]);
            }
        }
        return new string(chars);
    }
    
    static void Main(string[] args) {
        Console.WriteLine(FlipCase(""Hello"")); // Output should be ""hELLO""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FlipCase(("""")).Equals(("""")));
    Debug.Assert(FlipCase((""Hello!"")).Equals((""hELLO!"")));
    Debug.Assert(FlipCase((""These violent delights have violent ends"")).Equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Kết hợp một danh sách các chuỗi thành một chuỗi duy nhất    // >>> Concatenate((new List<string>()))
    // ("""")
    // >>> Concatenate((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""abc"")
    public static string Concatenate(List<string> strings) {
","return string.Concat(strings);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Concatenate((new List<string>())).Equals(("""")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""xyz"")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z"", (string)""w"", (string)""k""}))).Equals((""xyzwk"")));
    }

}
"
HumanEval_29,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bộ lọc một danh sách đầu vào của chuỗi chỉ cho những người bắt đầu với một tiền tố nhất định.     // >>> FilterByPrefix((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterByPrefix((new List<string>(new string[]{(string)""abc"", (string)""bcd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""array""}))
    public static List<string> FilterByPrefix(List<string> strings, string prefix) {
","return strings.Where(s => s.StartsWith(prefix)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterByPrefix((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterByPrefix((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    }

}
"
HumanEval_30,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Chỉ trả về các số dương trong danh sách.    // >>> GetPositive((new List<long>(new long[]{(long)-1L, (long)2L, (long)-4L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)6L}))
    // >>> GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)9L, (long)123L, (long)1L}))
    public static List<long> GetPositive(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetPositive(List<long> l)
    {
        List<long> positiveNumbers = new List<long>();
        foreach (long number in l)
        {
            if (number > 0)
            {
                positiveNumbers.Add(number);
            }
        }
        return positiveNumbers;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L, (long)4L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)4L, (long)5L, (long)6L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)3L, (long)9L, (long)123L, (long)1L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L}))).Equals((new List<long>())));
    Debug.Assert(GetPositive((new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_31,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về true nếu một số nhất định là số nguyên tố, và false nếu không.    // >>> IsPrime((6L))
    // (false)
    // >>> IsPrime((101L))
    // (true)
    // >>> IsPrime((11L))
    // (true)
    // >>> IsPrime((13441L))
    // (true)
    // >>> IsPrime((61L))
    // (true)
    // >>> IsPrime((4L))
    // (false)
    // >>> IsPrime((1L))
    // (false)
    public static bool IsPrime(long n) {
","public static bool IsPrime(long n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPrime((6L)) == (false));
    Debug.Assert(IsPrime((101L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((13441L)) == (true));
    Debug.Assert(IsPrime((61L)) == (true));
    Debug.Assert(IsPrime((4L)) == (false));
    Debug.Assert(IsPrime((1L)) == (false));
    Debug.Assert(IsPrime((5L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((17L)) == (true));
    Debug.Assert(IsPrime((85L)) == (false));
    Debug.Assert(IsPrime((77L)) == (false));
    Debug.Assert(IsPrime((255379L)) == (false));
    }

}
"
HumanEval_33,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //cho các giá trị của các chỉ số tương ứng của l, nhưng được sắp xếp.    //l' giống hệt với l trong các chỉ số không thể chia cho ba, trong khi giá trị của nó ở các chỉ số có thể chia cho ba là bằng nhau     //Hàm này lấy một danh sách l và trả về một danh sách l' như vậy mà     // >>> SortThird((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))
    public static List<long> SortThird(List<long> l) {
","public static List<long> SortThird(List<long> l) {
        List<long> sortedValues = new List<long>();

        // Collect values at indices divisible by three
        for (int i = 0; i < l.Count; i++) {
            if (i % 3 == 0) {
                sortedValues.Add(l[i]);
            }
        }

        // Sort the collected values
        sortedValues.Sort();

        // Place sorted values back into their positions
        int sortedIndex = 0;
        List<long> result = new List<long>(l);
        for (int i = 0; i < result.Count; i++) {
            if (i % 3 == 0) {
                result[i] = sortedValues[sortedIndex++];
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L, (long)1L}))));
    }

}
"
HumanEval_34,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về các phần tử duy nhất được sắp xếp trong danh sách    // >>> Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))
    public static List<long> Unique(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return sorted unique elements in a list
    public static List<long> Unique(List<long> l) {
        HashSet<long> uniqueSet = new HashSet<long>(l);
        List<long> uniqueList = new List<long>(uniqueSet);
        uniqueList.Sort();
        return uniqueList;
    }
    
    static void Main(string[] args) {
        List<long> input = new List<long>{5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L};
        List<long> result = Unique(input);
        Console.WriteLine(string.Join("", "", result)); // Output: 0, 2, 3, 5, 9, 123
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))));
    }

}
"
HumanEval_35,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về phần tử tối đa trong danh sách.    // >>> MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (3L)
    // >>> MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (123L)
    public static long MaxElement(List<long> l) {
","return l.Max();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (3L));
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)124L, (long)1L, (long)-10L}))) == (124L));
    }

}
"
HumanEval_36,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về số lần chữ số 7 xuất hiện trong số nguyên nhỏ hơn n mà có thể chia cho 11 hoặc 13.     // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
        long count = 0;
        for (long i = 1; i < n; i++) {
            if (i % 11 == 0 || i % 13 == 0) {
                count += CountSevens(i);
            }
        }
        return count;
    }

    private static int CountSevens(long num) {
        int count = 0;
        while (num > 0) {
            if (num % 10 == 7) {
                count++;
            }
            num /= 10;
        }
        return count;
    }

    // You can test the function with the following main method:
    static void Main(string[] args) {
        Console.WriteLine(FizzBuzz(50));  // Output: 0
        Console.WriteLine(FizzBuzz(78));  // Output: 2
        Console.WriteLine(FizzBuzz(79));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FizzBuzz((50L)) == (0L));
    Debug.Assert(FizzBuzz((78L)) == (2L));
    Debug.Assert(FizzBuzz((79L)) == (3L));
    Debug.Assert(FizzBuzz((100L)) == (3L));
    Debug.Assert(FizzBuzz((200L)) == (6L));
    Debug.Assert(FizzBuzz((4000L)) == (192L));
    Debug.Assert(FizzBuzz((10000L)) == (639L));
    Debug.Assert(FizzBuzz((100000L)) == (8026L));
    }

}
"
HumanEval_37,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //đến các giá trị của các chỉ số chẵn của l, nhưng được sắp xếp.    //l' giống hệt với l trong các chỉ số lẻ, trong khi giá trị của nó ở các chỉ số chẵn là bằng nhau     //Hàm này lấy một danh sách l và trả về một danh sách l' như vậy mà     // >>> SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortEven((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)3L, (long)6L, (long)5L, (long)4L}))
    public static List<long> SortEven(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // This function takes a list l and returns a list l' such that
    // l' is identical to l in the odd indices, while its values at the even indices are equal
    // to the values of the even indices of l, but sorted.
    public static List<long> SortEven(List<long> l) {
        List<long> evenIndicesValues = new List<long>();

        // Collect values from even indices
        for (int i = 0; i < l.Count; i += 2) {
            evenIndicesValues.Add(l[i]);
        }

        // Sort the collected even index values
        evenIndicesValues.Sort();

        // Reconstruct the list with sorted values at even indices
        List<long> result = new List<long>(l);

        for (int i = 0, j = 0; i < result.Count; i += 2, j++) {
            result[i] = evenIndicesValues[j];
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-10L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)5L, (long)0L, (long)9L, (long)1L, (long)123L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)8L, (long)-12L, (long)4L, (long)23L, (long)2L, (long)3L, (long)11L, (long)12L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-12L, (long)8L, (long)3L, (long)4L, (long)5L, (long)2L, (long)12L, (long)11L, (long)23L, (long)-10L}))));
    }

}
"
HumanEval_39,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //prime_fib trả về số n là một số Fibonacci và nó cũng là số nguyên tố.     // >>> PrimeFib((1L))
    // (2L)
    // >>> PrimeFib((2L))
    // (3L)
    // >>> PrimeFib((3L))
    // (5L)
    // >>> PrimeFib((4L))
    // (13L)
    // >>> PrimeFib((5L))
    // (89L)
    public static long PrimeFib(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Method to check if a number is prime
    public static bool IsPrime(long num)
    {
        if (num <= 1) return false;
        if (num == 2) return true;
        if (num % 2 == 0) return false;

        long boundary = (long)Math.Floor(Math.Sqrt(num));

        for (long i = 3; i <= boundary; i += 2)
        {
            if (num % i == 0)
                return false;
        }

        return true;
    }

    // Method to generate Fibonacci numbers and find the n-th prime Fibonacci
    public static long PrimeFib(long n)
    {
        long a = 1, b = 1;
        long primeFibCount = 0;

        while (true)
        {
            long temp = a;
            a = b;
            b = temp + b;

            if (IsPrime(a))
            {
                primeFibCount++;
                if (primeFibCount == n)
                {
                    return a;
                }
            }
        }
    }

    static void Main(string[] args)
    {
        Console.WriteLine(PrimeFib(1)); // Output: 2
        Console.WriteLine(PrimeFib(2)); // Output: 3
        Console.WriteLine(PrimeFib(3)); // Output: 5
        Console.WriteLine(PrimeFib(4)); // Output: 13
        Console.WriteLine(PrimeFib(5)); // Output: 89
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeFib((1L)) == (2L));
    Debug.Assert(PrimeFib((2L)) == (3L));
    Debug.Assert(PrimeFib((3L)) == (5L));
    Debug.Assert(PrimeFib((4L)) == (13L));
    Debug.Assert(PrimeFib((5L)) == (89L));
    Debug.Assert(PrimeFib((6L)) == (233L));
    Debug.Assert(PrimeFib((7L)) == (1597L));
    Debug.Assert(PrimeFib((8L)) == (28657L));
    Debug.Assert(PrimeFib((9L)) == (514229L));
    Debug.Assert(PrimeFib((10L)) == (433494437L));
    }

}
"
HumanEval_40,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //tổng bằng không, và sai nếu không.    //nó trả về true nếu có ba yếu tố khác nhau trong danh sách mà     //triple_sum_to_zero lấy một danh sách các số nguyên làm đầu vào.    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool TriplesSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool TriplesSumToZero(List<long> l)
    {
        if (l.Count < 3)
            return false;

        l.Sort();

        for (int i = 0; i < l.Count - 2; i++)
        {
            if (i > 0 && l[i] == l[i - 1])
                continue;

            int left = i + 1;
            int right = l.Count - 1;

            while (left < right)
            {
                long sum = l[i] + l[left] + l[right];
                if (sum == 0)
                    return true;
                else if (sum < 0)
                    left++;
                else
                    right--;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)5L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-100L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)100L, (long)3L, (long)5L, (long)-100L}))) == (false));
    }

}
"
HumanEval_41,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Hàm này đưa ra số lượng va chạm như vậy.    //trên đường đi của chúng như thể chúng không va chạm.    //Tuy nhiên, những chiếc xe này rất mạnh mẽ và bền vững, kết quả là chúng vẫn tiếp tục di chuyển.    //khi một chiếc xe đang di chuyển từ trái sang phải đâm vào một chiếc xe đang di chuyển từ phải sang trái.    //Tất cả xe di chuyển với cùng tốc độ. Hai xe được cho là va chạm.    //Hai cặp xe bắt đầu từ rất xa    //n xe đang lái xe từ trái sang phải; đồng thời, một bộ khác nhau của n xe     //Hãy tưởng tượng một con đường là một đường thẳng vô cùng dài.    public static long CarRaceCollision(long n) {
","// Each car moving left to right will collide with each car moving right to left.
        // So the total number of collisions is n * n.
        return n * n;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CarRaceCollision(5));  // Example usage
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CarRaceCollision((2L)) == (4L));
    Debug.Assert(CarRaceCollision((3L)) == (9L));
    Debug.Assert(CarRaceCollision((4L)) == (16L));
    Debug.Assert(CarRaceCollision((8L)) == (64L));
    Debug.Assert(CarRaceCollision((10L)) == (100L));
    }

}
"
HumanEval_42,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Danh sách trả lại với các yếu tố tăng lên 1.    // >>> IncrList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))
    // >>> IncrList((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)6L, (long)4L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))
    public static List<long> IncrList(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list with elements incremented by 1.
    public static List<long> IncrList(List<long> l) {
        return l.Select(x => x + 1).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IncrList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)3L, (long)2L}))));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)5L, (long)2L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)6L, (long)3L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))));
    }

}
"
HumanEval_43,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //tổng bằng không, và sai nếu không.    //nó trả về true nếu có hai phần tử khác nhau trong danh sách mà     //pairs_sum_to_zero lấy danh sách các số nguyên làm đầu vào.    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L})))
    // (true)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool PairsSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool PairsSumToZero(List<long> l)
    {
        HashSet<long> seenNumbers = new HashSet<long>();

        foreach (long number in l)
        {
            if (seenNumbers.Contains(-number))
            {
                return true;
            }
            seenNumbers.Add(number);
        }

        return false;
    }

    public static void Main(string[] args)
    {
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, 5L, 0L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, -2L, 1L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 2L, 3L, 7L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 2L, 4L, -5L, 3L, 5L, 7L })); // true
        Console.WriteLine(PairsSumToZero(new List<long> { 1L })); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)30L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)31L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)30L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)31L}))) == (false));
    }

}
"
HumanEval_44,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //số cơ sở nhỏ hơn 10.    //trả về biểu diễn chuỗi sau khi chuyển đổi.    //Thay đổi cơ sở số của số đầu vào x thành cơ sở.    // >>> ChangeBase((8L), (3L))
    // (""22"")
    // >>> ChangeBase((8L), (2L))
    // (""1000"")
    // >>> ChangeBase((7L), (2L))
    // (""111"")
    public static string ChangeBase(long x, long numBase) {
","using System;
using System.Collections.Generic;

class Problem {
    // Change numerical base of input number x to base.
    // return string representation after the conversion.
    // base numbers are less than 10.
    public static string ChangeBase(long x, long numBase) {
        if (numBase < 2 || numBase > 9) 
            throw new ArgumentException(""Base must be between 2 and 9."");

        if (x < 0) 
            throw new ArgumentException(""Number must be non-negative."");

        if (x == 0) 
            return ""0"";

        string result = string.Empty;
        while (x > 0) {
            long remainder = x % numBase;
            result = remainder + result;
            x /= numBase;
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChangeBase((8L), (3L)).Equals((""22"")));
    Debug.Assert(ChangeBase((9L), (3L)).Equals((""100"")));
    Debug.Assert(ChangeBase((234L), (2L)).Equals((""11101010"")));
    Debug.Assert(ChangeBase((16L), (2L)).Equals((""10000"")));
    Debug.Assert(ChangeBase((8L), (2L)).Equals((""1000"")));
    Debug.Assert(ChangeBase((7L), (2L)).Equals((""111"")));
    Debug.Assert(ChangeBase((2L), (3L)).Equals((""2"")));
    Debug.Assert(ChangeBase((3L), (4L)).Equals((""3"")));
    Debug.Assert(ChangeBase((4L), (5L)).Equals((""4"")));
    Debug.Assert(ChangeBase((5L), (6L)).Equals((""5"")));
    Debug.Assert(ChangeBase((6L), (7L)).Equals((""6"")));
    Debug.Assert(ChangeBase((7L), (8L)).Equals((""7"")));
    }

}
"
HumanEval_45,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Với chiều dài của một bên và cao trở lại khu vực cho một tam giác.    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
","using System;

class Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
        return (a * h) / 2.0f;
    }

    static void Main(string[] args) {
        Console.WriteLine(TriangleArea(5L, 3L)); // Output: 7.5
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((5L), (3L)) == (7.5f));
    Debug.Assert(TriangleArea((2L), (2L)) == (2.0f));
    Debug.Assert(TriangleArea((10L), (8L)) == (40.0f));
    }

}
"
HumanEval_46,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Vui lòng viết một hàm để tính toán hiệu quả phần tử n-th của chuỗi số fib4. Không sử dụng quy trình.     //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).    //fib4(3) -> 0     //fib4(2) -> 2     //fib4(1) -> 0     //fib4(0) -> 0     //Dòng số Fib4 là một chuỗi tương tự như chuỗi Fibbonacci được định nghĩa như sau:     // >>> Fib4((5L))
    // (4L)
    // >>> Fib4((6L))
    // (8L)
    // >>> Fib4((7L))
    // (14L)
    public static long Fib4(long n) {
","public static long Fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    long[] fib4Seq = new long[n + 1];
    fib4Seq[0] = 0;
    fib4Seq[1] = 0;
    fib4Seq[2] = 2;
    fib4Seq[3] = 0;

    for (long i = 4; i <= n; i++) {
        fib4Seq[i] = fib4Seq[i - 1] + fib4Seq[i - 2] + fib4Seq[i - 3] + fib4Seq[i - 4];
    }

    return fib4Seq[n];
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib4((5L)) == (4L));
    Debug.Assert(Fib4((8L)) == (28L));
    Debug.Assert(Fib4((10L)) == (104L));
    Debug.Assert(Fib4((12L)) == (386L));
    }

}
"
HumanEval_47,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trọng số trả về của các phần tử trong danh sách l.     // >>> Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (float)3L
    // >>> Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L})))
    // (15.0f)
    public static float Median(List<long> l) {
","public static float Median(List<long> l) {
        l.Sort();
        int count = l.Count;
        if (count % 2 == 1) {
            return (float)l[count / 2];
        } else {
            long mid1 = l[(count / 2) - 1];
            long mid2 = l[count / 2];
            return (mid1 + mid2) / 2.0f;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) == (float)3L);
    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));
    Debug.Assert(Median((new List<long>(new long[]{(long)5L}))) == (float)5L);
    Debug.Assert(Median((new List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));
    Debug.Assert(Median((new List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L, (long)7L}))) == (float)7L);
    }

}
"
HumanEval_48,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Kiểm tra xem chuỗi được cho là palindrome     // >>> IsPalindrome((""""))
    // (true)
    // >>> IsPalindrome((""aba""))
    // (true)
    // >>> IsPalindrome((""aaaaa""))
    // (true)
    // >>> IsPalindrome((""zbcd""))
    // (false)
    public static bool IsPalindrome(string text) {
","public static bool IsPalindrome(string text) {
    if (string.IsNullOrEmpty(text))
        return true;

    int left = 0;
    int right = text.Length - 1;

    while (left < right) {
        if (text[left] != text[right])
            return false;
        left++;
        right--;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPalindrome(("""")) == (true));
    Debug.Assert(IsPalindrome((""aba"")) == (true));
    Debug.Assert(IsPalindrome((""aaaaa"")) == (true));
    Debug.Assert(IsPalindrome((""zbcd"")) == (false));
    Debug.Assert(IsPalindrome((""xywyx"")) == (true));
    Debug.Assert(IsPalindrome((""xywyz"")) == (false));
    Debug.Assert(IsPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về 2^n mô-đun p (lưu ý về số liệu).    // >>> Modp((3L), (5L))
    // (3L)
    // >>> Modp((1101L), (101L))
    // (2L)
    // >>> Modp((0L), (101L))
    // (1L)
    // >>> Modp((3L), (11L))
    // (8L)
    // >>> Modp((100L), (101L))
    // (1L)
    public static long Modp(long n, long p) {
","using System;
using System.Numerics;

class Problem {
    public static long Modp(long n, long p) {
        // Using the property of modular arithmetic: (a^b) % c = ((a % c)^b) % c
        // We are calculating (2^n) % p
        BigInteger baseNum = 2;
        BigInteger result = BigInteger.ModPow(baseNum, n, p);
        return (long)result;
    }

    static void Main(string[] args) {
        Console.WriteLine(Modp(3L, 5L));   // (3L)
        Console.WriteLine(Modp(1101L, 101L)); // (2L)
        Console.WriteLine(Modp(0L, 101L));   // (1L)
        Console.WriteLine(Modp(3L, 11L));   // (8L)
        Console.WriteLine(Modp(100L, 101L));  // (1L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Modp((3L), (5L)) == (3L));
    Debug.Assert(Modp((1101L), (101L)) == (2L));
    Debug.Assert(Modp((0L), (101L)) == (1L));
    Debug.Assert(Modp((3L), (11L)) == (8L));
    Debug.Assert(Modp((100L), (101L)) == (1L));
    Debug.Assert(Modp((30L), (5L)) == (4L));
    Debug.Assert(Modp((31L), (5L)) == (3L));
    }

}
"
HumanEval_51,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //remove_vowels là một hàm lấy chuỗi và trả về chuỗi không có nguyên âm.     // >>> RemoveVowels((""""))
    // ("""")
    // >>> RemoveVowels((""abcdef""))
    // (""bcdf"")
    // >>> RemoveVowels((""aaaaa""))
    // ("""")
    // >>> RemoveVowels((""aaBAA""))
    // (""B"")
    // >>> RemoveVowels((""zbcd""))
    // (""zbcd"")
    public static string RemoveVowels(string text) {
","HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        StringBuilder result = new StringBuilder();

        foreach (char c in text) {
            if (!vowels.Contains(c)) {
                result.Append(c);
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveVowels(("""")).Equals(("""")));
    Debug.Assert(RemoveVowels((""abcdef\nghijklm"")).Equals((""bcdf\nghjklm"")));
    Debug.Assert(RemoveVowels((""fedcba"")).Equals((""fdcb"")));
    Debug.Assert(RemoveVowels((""eeeee"")).Equals(("""")));
    Debug.Assert(RemoveVowels((""acBAA"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""EcBOO"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""ybcd"")).Equals((""ybcd"")));
    }

}
"
HumanEval_52,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về true nếu tất cả các số trong danh sách l dưới ngưỡng t.     // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L))
    // (true)
    // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L))
    // (false)
    public static bool BelowThreshold(List<long> l, long t) {
","return l.All(x => x < t);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L)) == (false));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (21L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (22L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (11L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (10L)) == (false));
    }

}
"
HumanEval_53,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Thêm hai số x và y     // >>> Add((2L), (3L))
    // (5L)
    // >>> Add((5L), (7L))
    // (12L)
    public static long Add(long x, long y) {
","return x + y;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((0L), (1L)) == (1L));
    Debug.Assert(Add((1L), (0L)) == (1L));
    Debug.Assert(Add((2L), (3L)) == (5L));
    Debug.Assert(Add((5L), (7L)) == (12L));
    Debug.Assert(Add((7L), (5L)) == (12L));
    }

}
"
HumanEval_54,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Kiểm tra xem hai từ có cùng ký tự không.    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> SameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> SameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> SameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> SameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    public static bool SameChars(string s0, string s1) {
","public static bool SameChars(string s0, string s1) {
        // Return true if s1 contains all characters of s0
        return s0.All(c => s1.Contains(c)) && s1.All(c => s0.Contains(c));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    Debug.Assert(SameChars((""abcd""), (""dddddddabc"")) == (true));
    Debug.Assert(SameChars((""dddddddabc""), (""abcd"")) == (true));
    Debug.Assert(SameChars((""eabcd""), (""dddddddabc"")) == (false));
    Debug.Assert(SameChars((""abcd""), (""dddddddabcf"")) == (false));
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    Debug.Assert(SameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về số Fibonacci n-th.     // >>> Fib((10L))
    // (55L)
    // >>> Fib((1L))
    // (1L)
    // >>> Fib((8L))
    // (21L)
    public static long Fib(long n) {
","if (n <= 0) return 0;
    if (n == 1) return 1;

    long a = 0;
    long b = 1;

    for (long i = 2; i <= n; i++)
    {
        long temp = a + b;
        a = b;
        b = temp;
    }

    return b;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib((10L)) == (55L));
    Debug.Assert(Fib((1L)) == (1L));
    Debug.Assert(Fib((8L)) == (21L));
    Debug.Assert(Fib((11L)) == (89L));
    Debug.Assert(Fib((12L)) == (144L));
    }

}
"
HumanEval_56,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //return true nếu mỗi bracket mở có một bracket đóng tương ứng.     //brackets là một chuỗi của ""<"" và "">"".     // >>> CorrectBracketing((""<""))
    // (false)
    // >>> CorrectBracketing((""<>""))
    // (true)
    // >>> CorrectBracketing((""<<><>>""))
    // (true)
    // >>> CorrectBracketing((""><<>""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","public static bool CorrectBracketing(string brackets) 
{
    int balance = 0;
    foreach (char c in brackets) 
    {
        if (c == '<') 
        {
            balance++;
        } 
        else if (c == '>') 
        {
            balance--;
        }
        
        if (balance < 0) 
        {
            return false;
        }
    }

    return balance == 0;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""<>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<><>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<><>><>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<<><>>>>"")) == (false));
    Debug.Assert(CorrectBracketing((""><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<"")) == (false));
    Debug.Assert(CorrectBracketing((""<<<<"")) == (false));
    Debug.Assert(CorrectBracketing(("">"")) == (false));
    Debug.Assert(CorrectBracketing((""<<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về true là các phần tử danh sách đang tăng hoặc giảm một cách đơn điệu.    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L})))
    // (true)
    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})))
    // (false)
    // >>> Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L})))
    // (true)
    public static bool Monotonic(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return true if list elements are monotonically increasing or decreasing.
    public static bool Monotonic(List<long> l) {
        if (l.Count < 2) return true; // Lists with less than 2 elements are trivially monotonic.
        
        bool increasing = true;
        bool decreasing = true;

        for (int i = 1; i < l.Count; i++) {
            if (l[i] > l[i - 1]) {
                decreasing = false;
            } else if (l[i] < l[i - 1]) {
                increasing = false;
            }

            // If both flags are false, the list is not monotonic.
            if (!increasing && !decreasing) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)5L, (long)60L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)60L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)9L, (long)9L, (long)9L, (long)9L}))) == (true));
    }

}
"
HumanEval_58,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về các phần tử chung duy nhất được sắp xếp cho hai danh sách.    // >>> Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L})))
    // (new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))
    // >>> Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    public static List<long> Common(List<long> l1, List<long> l2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> Common(List<long> l1, List<long> l2)
    {
        // Use HashSet to store unique elements of l1
        var set1 = new HashSet<long>(l1);

        // Use HashSet to store unique elements of l2 and filter common elements
        var commonSet = new HashSet<long>(l2.Where(x => set1.Contains(x)));

        // Convert to a list, sort it and return
        var result = commonSet.ToList();
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_59,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về nhân số nguyên tố lớn nhất của n. Giả sử n > 1 và không phải là số nguyên tố.     // >>> LargestPrimeFactor((13195L))
    // (29L)
    // >>> LargestPrimeFactor((2048L))
    // (2L)
    public static long LargestPrimeFactor(long n) {
","using System;

class Problem {
    public static long LargestPrimeFactor(long n) {
        long largestFactor = -1;
        
        // Remove the factor of 2
        while (n % 2 == 0) {
            largestFactor = 2;
            n /= 2;
        }

        // Check odd factors from 3 upwards
        for (long i = 3; i <= Math.Sqrt(n); i += 2) {
            while (n % i == 0) {
                largestFactor = i;
                n /= i;
            }
        }

        // If n becomes a prime number greater than 2
        if (n > 2) {
            largestFactor = n;
        }

        return largestFactor;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestPrimeFactor((15L)) == (5L));
    Debug.Assert(LargestPrimeFactor((27L)) == (3L));
    Debug.Assert(LargestPrimeFactor((63L)) == (7L));
    Debug.Assert(LargestPrimeFactor((330L)) == (11L));
    Debug.Assert(LargestPrimeFactor((13195L)) == (29L));
    }

}
"
HumanEval_60,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //sum_to_n là một hàm tổng số từ 1 đến n.     // >>> SumToN((30L))
    // (465L)
    // >>> SumToN((100L))
    // (5050L)
    // >>> SumToN((5L))
    // (15L)
    // >>> SumToN((10L))
    // (55L)
    // >>> SumToN((1L))
    // (1L)
    public static long SumToN(long n) {
","return n * (n + 1) / 2;
}
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumToN((1L)) == (1L));
    Debug.Assert(SumToN((6L)) == (21L));
    Debug.Assert(SumToN((11L)) == (66L));
    Debug.Assert(SumToN((30L)) == (465L));
    Debug.Assert(SumToN((100L)) == (5050L));
    }

}
"
HumanEval_61,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //return true nếu mỗi bracket mở có một bracket đóng tương ứng.     //brackets là một chuỗi của ""("" và "")"".     // >>> CorrectBracketing((""(""))
    // (false)
    // >>> CorrectBracketing((""()""))
    // (true)
    // >>> CorrectBracketing((""(()())""))
    // (true)
    // >>> CorrectBracketing(("")(()""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","using System;

class Problem {
    public static bool CorrectBracketing(string brackets) {
        int balance = 0;
        foreach (char c in brackets) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false;
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""()"")) == (true));
    Debug.Assert(CorrectBracketing((""(()())"")) == (true));
    Debug.Assert(CorrectBracketing((""()()(()())()"")) == (true));
    Debug.Assert(CorrectBracketing((""()()((()()())())(()()(()))"")) == (true));
    Debug.Assert(CorrectBracketing((""((()())))"")) == (false));
    Debug.Assert(CorrectBracketing(("")(()"")) == (false));
    Debug.Assert(CorrectBracketing((""("")) == (false));
    Debug.Assert(CorrectBracketing((""(((("")) == (false));
    Debug.Assert(CorrectBracketing(("")"")) == (false));
    Debug.Assert(CorrectBracketing((""(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())())(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về dẫn xuất của đa thức này trong cùng một hình thức.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....     //xs đại diện cho hệ số của một đa thức.    // >>> Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))
    // >>> Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)6L}))
    public static List<long> Derivative(List<long> xs) {
","public static List<long> Derivative(List<long> xs) {
        List<long> derivative = new List<long>();
        for (int i = 1; i < xs.Count; i++) {
            derivative.Add(xs[i] * i);
        }
        return derivative;
    }

    static void Main(string[] args) {
        List<long> poly1 = new List<long>{3L, 1L, 2L, 4L, 5L};
        List<long> result1 = Derivative(poly1);
        Console.WriteLine(string.Join("", "", result1));

        List<long> poly2 = new List<long>{1L, 2L, 3L};
        List<long> result2 = Derivative(poly2);
        Console.WriteLine(string.Join("", "", result2));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L, (long)0L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)0L, (long)16L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_63,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Vui lòng viết một hàm để tính toán hiệu quả phần tử thứ n của chuỗi số fibfib.     //fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3).     //fibfib(2) == 1     //fibfib(1) == 0     //fibfib(0) == 0     //Dòng số FibFib là một chuỗi tương tự như chuỗi Fibbonacci được định nghĩa như sau:     // >>> Fibfib((1L))
    // (0L)
    // >>> Fibfib((5L))
    // (4L)
    // >>> Fibfib((8L))
    // (24L)
    public static long Fibfib(long n) {
","public static long Fibfib(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 1;

    long a = 0, b = 0, c = 1;
    long result = 0;

    for (long i = 3; i <= n; i++) {
        result = a + b + c;
        a = b;
        b = c;
        c = result;
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fibfib((2L)) == (1L));
    Debug.Assert(Fibfib((1L)) == (0L));
    Debug.Assert(Fibfib((5L)) == (4L));
    Debug.Assert(Fibfib((8L)) == (24L));
    Debug.Assert(Fibfib((10L)) == (81L));
    Debug.Assert(Fibfib((12L)) == (274L));
    Debug.Assert(Fibfib((14L)) == (927L));
    }

}
"
HumanEval_64,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //nguyên âm, nhưng chỉ khi nó ở cuối từ được đưa ra.    //Các nguyên âm trong trường hợp này là ""a"", ""e"", ""i"", ""o"", ""u"". Ở đây, ""y"" cũng là a     //một từ như đầu vào và trả về số lượng các nguyên âm trong chuỗi.     //Viết hàm vowels_count dùng chuỗi đại diện cho     // >>> VowelsCount((""abcde""))
    // (2L)
    // >>> VowelsCount((""ACEDY""))
    // (3L)
    public static long VowelsCount(string s) {
","using System;

class Problem {
    public static long VowelsCount(string s) {
        if (s == null) return 0;

        s = s.ToLower();
        long count = 0;
        
        for (int i = 0; i < s.Length; i++) {
            char c = s[i];
            if (""aeiou"".Contains(c) || (c == 'y' && i == s.Length - 1)) {
                count++;
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(VowelsCount(""abcde""));  // Output: 2
        Console.WriteLine(VowelsCount(""ACEDY""));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(VowelsCount((""abcde"")) == (2L));
    Debug.Assert(VowelsCount((""Alone"")) == (3L));
    Debug.Assert(VowelsCount((""key"")) == (2L));
    Debug.Assert(VowelsCount((""bye"")) == (1L));
    Debug.Assert(VowelsCount((""keY"")) == (2L));
    Debug.Assert(VowelsCount((""bYe"")) == (1L));
    Debug.Assert(VowelsCount((""ACEDY"")) == (3L));
    }

}
"
HumanEval_65,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Nếu shift > số chữ số, số chữ số trở lại đảo ngược.    //và trả về kết quả như một chuỗi.     //Chuyển động tròn các chữ số của số nguyên x, di chuyển các chữ số bên phải bằng cách di chuyển     // >>> CircularShift((12L), (1L))
    // (""21"")
    // >>> CircularShift((12L), (2L))
    // (""12"")
    public static string CircularShift(long x, long shift) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Circular shift the digits of the integer x, shift the digits right by shift
    // and return the result as a string.
    // If shift > number of digits, return digits reversed.
    
    public static string CircularShift(long x, long shift) {
        string digits = x.ToString();
        int length = digits.Length;
        
        if (shift > length) {
            char[] reversedDigits = digits.ToCharArray();
            Array.Reverse(reversedDigits);
            return new string(reversedDigits);
        }

        shift = shift % length;  // Normalize shift
        string shiftedPart = digits.Substring(length - (int)shift);
        string remainingPart = digits.Substring(0, length - (int)shift);
        return shiftedPart + remainingPart;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CircularShift((100L), (2L)).Equals((""001"")));
    Debug.Assert(CircularShift((12L), (2L)).Equals((""12"")));
    Debug.Assert(CircularShift((97L), (8L)).Equals((""79"")));
    Debug.Assert(CircularShift((12L), (1L)).Equals((""21"")));
    Debug.Assert(CircularShift((11L), (101L)).Equals((""11"")));
    }

}
"
HumanEval_66,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Mã ASCII.    //Viết một hàm lấy một chuỗi như đầu vào và chỉ trả về tổng các ký tự trên cùng'     //Nhiệm vụ     // >>> Digitsum((""""))
    // (0L)
    // >>> Digitsum((""abAB""))
    // (131L)
    // >>> Digitsum((""abcCd""))
    // (67L)
    // >>> Digitsum((""helloE""))
    // (69L)
    // >>> Digitsum((""woArBld""))
    // (131L)
    // >>> Digitsum((""aAaaaXa""))
    // (153L)
    public static long Digitsum(string s) {
","public static long Digitsum(string s) {
    long sum = 0;
    foreach (char c in s) {
        if (char.IsUpper(c)) {
            sum += c; // Add ASCII value of the upper case letters.
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digitsum(("""")) == (0L));
    Debug.Assert(Digitsum((""abAB"")) == (131L));
    Debug.Assert(Digitsum((""abcCd"")) == (67L));
    Debug.Assert(Digitsum((""helloE"")) == (69L));
    Debug.Assert(Digitsum((""woArBld"")) == (131L));
    Debug.Assert(Digitsum((""aAaaaXa"")) == (153L));
    Debug.Assert(Digitsum(("" How are yOu?"")) == (151L));
    Debug.Assert(Digitsum((""You arE Very Smart"")) == (327L));
    }

}
"
HumanEval_67,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //cho examble:     //trong giỏ trả về số lượng trái xoài trong giỏ.     //cam và táo và một số nguyên đại diện cho tổng số trái cây     //táo, cam, và trái cây xoài. cho chuỗi đại diện cho tổng số     //được phân phối trong một giỏ trái cây giỏ này chứa     //Trong nhiệm vụ này, bạn sẽ được cung cấp một chuỗi đại diện cho một số táo và cam.    // >>> FruitDistribution((""5 apples and 6 oranges""), (19L))
    // (8L)
    // >>> FruitDistribution((""0 apples and 1 oranges""), (3L))
    // (2L)
    // >>> FruitDistribution((""2 apples and 3 oranges""), (100L))
    // (95L)
    // >>> FruitDistribution((""100 apples and 1 oranges""), (120L))
    // (19L)
    public static long FruitDistribution(string s, long n) {
","using System;

class Problem {
    public static long FruitDistribution(string s, long n) {
        var parts = s.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        long apples = long.Parse(parts[0]);
        long oranges = long.Parse(parts[3]);

        long totalApplesAndOranges = apples + oranges;
        long mangoes = n - totalApplesAndOranges;
        
        return mangoes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (19L)) == (8L));
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (21L)) == (10L));
    Debug.Assert(FruitDistribution((""0 apples and 1 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""1 apples and 0 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (100L)) == (95L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (5L)) == (0L));
    Debug.Assert(FruitDistribution((""1 apples and 100 oranges""), (120L)) == (19L));
    }

}
"
HumanEval_68,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ 1:     //Nếu không có giá trị chẵn hoặc danh sách được cung cấp là trống, trả về [].     //Các nút nhặt nên được trả về trong một danh sách, [smallest_value, index của nó ],     //Nếu tìm thấy nhiều nút có cùng giá trị thậm chí nhỏ nhất, trả về nút có chỉ số nhỏ nhất.     //Góp được nhặt nên là nút có giá trị chẵn nhỏ nhất.    //nhiệm vụ của bạn là để nhổ một trong những nút và trả lại nó.    //""Được cho một danh sách đại diện cho một nhánh của một cây có các nút số nguyên không âm     // >>> Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> Pluck((new List<long>()))
    // (new List<long>())
    // Example 4:
    // >>> Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)0L, (long)1L}))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    public static List<long> Pluck(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Pluck(List<long> arr)
    {
        long smallestEven = long.MaxValue;
        int indexOfSmallest = -1;

        for (int i = 0; i < arr.Count; i++)
        {
            if (arr[i] % 2 == 0 && arr[i] < smallestEven)
            {
                smallestEven = arr[i];
                indexOfSmallest = i;
            }
        }

        if (indexOfSmallest == -1)
        {
            return new List<long>();
        }
        else
        {
            return new List<long> { smallestEven, indexOfSmallest };
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>())).Equals((new List<long>())));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)0L, (long)5L, (long)3L}))).Equals((new List<long>(new long[]{(long)0L, (long)3L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)4L, (long)8L, (long)4L, (long)8L}))).Equals((new List<long>(new long[]{(long)4L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)6L, (long)7L, (long)1L}))).Equals((new List<long>(new long[]{(long)6L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)9L, (long)7L, (long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_69,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Nếu không có giá trị như vậy tồn tại, trả về -1.    //Tần suất của một số nguyên là số lần nó xuất hiện trong danh sách.    //không, và có tần số lớn hơn hoặc bằng giá trị của chính số nguyên.     //Bạn được đưa ra một danh sách không trống của các số nguyên dương. Trả về số nguyên lớn nhất lớn hơn     // >>> Search((new List<long>(new long[]{(long)4L, (long)1L, (long)2L, (long)2L, (long)3L, (long)1L})))
    // (2L)
    // >>> Search((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L, (long)4L})))
    // (3L)
    // >>> Search((new List<long>(new long[]{(long)5L, (long)5L, (long)4L, (long)4L, (long)4L})))
    // (-1L)
    public static long Search(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static long Search(List<long> lst)
    {
        // Create a dictionary to store the frequency of each number
        Dictionary<long, long> frequency = new Dictionary<long, long>();

        // Count the frequency of each number in the list
        foreach (long num in lst)
        {
            if (frequency.ContainsKey(num))
            {
                frequency[num]++;
            }
            else
            {
                frequency[num] = 1;
            }
        }

        // Variable to store the greatest integer found
        long result = -1;

        // Go through each item in the frequency dictionary
        foreach (var kvp in frequency)
        {
            long number = kvp.Key;
            long freq = kvp.Value;

            // Check if the number's frequency is greater than or equal to the number itself
            if (freq >= number && number > 0)
            {
                // Update the result if this number is greater than the current result
                result = Math.Max(result, number);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)4L, (long)1L, (long)4L, (long)1L, (long)4L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)3L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L}))) == (8L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)3L, (long)3L, (long)2L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)7L, (long)8L, (long)8L, (long)4L, (long)8L, (long)7L, (long)3L, (long)9L, (long)6L, (long)5L, (long)10L, (long)4L, (long)3L, (long)6L, (long)7L, (long)1L, (long)7L, (long)4L, (long)10L, (long)8L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)2L, (long)8L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)7L, (long)1L, (long)8L, (long)8L, (long)10L, (long)5L, (long)8L, (long)5L, (long)3L, (long)10L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)3L, (long)6L, (long)5L, (long)6L, (long)4L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)6L, (long)7L, (long)1L, (long)4L, (long)7L, (long)1L, (long)8L, (long)8L, (long)9L, (long)8L, (long)10L, (long)10L, (long)8L, (long)4L, (long)10L, (long)4L, (long)10L, (long)1L, (long)2L, (long)9L, (long)5L, (long)7L, (long)9L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)9L, (long)10L, (long)1L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)7L, (long)5L, (long)8L, (long)7L, (long)5L, (long)3L, (long)7L, (long)5L, (long)10L, (long)10L, (long)3L, (long)6L, (long)10L, (long)2L, (long)8L, (long)6L, (long)5L, (long)4L, (long)9L, (long)5L, (long)3L, (long)10L}))) == (5L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)10L, (long)6L, (long)4L, (long)3L, (long)5L, (long)8L, (long)2L, (long)4L, (long)2L, (long)8L, (long)4L, (long)6L, (long)10L, (long)4L, (long)2L, (long)1L, (long)10L, (long)2L, (long)1L, (long)1L, (long)5L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)10L, (long)4L, (long)8L, (long)2L, (long)10L, (long)5L, (long)1L, (long)2L, (long)9L, (long)5L, (long)5L, (long)6L, (long)3L, (long)8L, (long)6L, (long)4L, (long)10L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)6L, (long)10L, (long)1L, (long)6L, (long)9L, (long)10L, (long)8L, (long)6L, (long)8L, (long)7L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)2L, (long)4L, (long)1L, (long)5L, (long)1L, (long)5L, (long)2L, (long)5L, (long)7L, (long)7L, (long)7L, (long)3L, (long)10L, (long)1L, (long)5L, (long)4L, (long)2L, (long)8L, (long)4L, (long)1L, (long)9L, (long)10L, (long)7L, (long)10L, (long)2L, (long)8L, (long)10L, (long)9L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)6L, (long)4L, (long)2L, (long)8L, (long)7L, (long)5L, (long)6L, (long)4L, (long)10L, (long)4L, (long)6L, (long)3L, (long)7L, (long)8L, (long)8L, (long)3L, (long)1L, (long)4L, (long)2L, (long)2L, (long)10L, (long)7L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)8L, (long)6L, (long)10L, (long)2L, (long)6L, (long)10L, (long)2L, (long)7L, (long)8L, (long)10L, (long)3L, (long)8L, (long)2L, (long)6L, (long)2L, (long)3L, (long)1L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)3L, (long)9L, (long)5L, (long)6L, (long)3L, (long)2L, (long)8L, (long)5L, (long)6L, (long)10L, (long)10L, (long)6L, (long)8L, (long)4L, (long)10L, (long)7L, (long)7L, (long)10L, (long)8L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)10L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)7L, (long)7L, (long)2L, (long)4L, (long)7L, (long)2L, (long)10L, (long)9L, (long)7L, (long)5L, (long)7L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)4L, (long)10L, (long)2L, (long)1L, (long)1L, (long)10L, (long)3L, (long)6L, (long)1L, (long)8L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)7L, (long)9L, (long)9L, (long)9L, (long)3L, (long)4L, (long)1L, (long)5L, (long)9L, (long)1L, (long)2L, (long)1L, (long)1L, (long)10L, (long)7L, (long)5L, (long)6L, (long)7L, (long)6L, (long)7L, (long)7L, (long)6L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)10L, (long)10L, (long)9L, (long)2L}))) == (-1L));
    }

}
"
HumanEval_70,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //sau đó là tối đa của các số nguyên còn lại, sau đó là tối thiểu và vân vân.    //Lập loại kỳ lạ, là khi bạn bắt đầu với giá trị tối thiểu,     //Cho danh sách các số nguyên, trả về danh sách theo thứ tự kỳ lạ.    // >>> StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))
    // >>> StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L})))
    // (new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))
    // >>> StrangeSortList((new List<long>()))
    // (new List<long>())
    public static List<long> StrangeSortList(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> StrangeSortList(List<long> lst) {
        List<long> result = new List<long>();
        lst.Sort();
        int start = 0;
        int end = lst.Count - 1;
        
        while (start <= end) {
            if (start <= end) {
                result.Add(lst[start]);
                start++;
            }
            if (start <= end) {
                result.Add(lst[end]);
                end--;
            }
        }
        
        return result;
    }
    
    static void Main(string[] args) {
        var example1 = StrangeSortList(new List<long> { 1L, 2L, 3L, 4L });
        var example2 = StrangeSortList(new List<long> { 5L, 5L, 5L, 5L });
        var example3 = StrangeSortList(new List<long>());

        Console.WriteLine(string.Join("", "", example1)); // Output: 1, 4, 2, 3
        Console.WriteLine(string.Join("", "", example2)); // Output: 5, 5, 5, 5
        Console.WriteLine(string.Join("", "", example3)); // Output: (empty line)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))).Equals((new List<long>(new long[]{(long)5L, (long)9L, (long)6L, (long)8L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)9L, (long)5L, (long)8L, (long)6L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))).Equals((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L}))).Equals((new List<long>(new long[]{(long)1L, (long)8L, (long)2L, (long)7L, (long)3L, (long)6L, (long)4L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)0L, (long)2L, (long)2L, (long)2L, (long)5L, (long)5L, (long)-5L, (long)-5L}))).Equals((new List<long>(new long[]{(long)-5L, (long)5L, (long)-5L, (long)5L, (long)0L, (long)2L, (long)2L, (long)2L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)111111L}))).Equals((new List<long>(new long[]{(long)111111L}))));
    }

}
"
HumanEval_71,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //hơn là bên thứ ba.    //Ba bên tạo thành một tam giác hợp lệ khi tổng của bất kỳ hai bên nào lớn hơn.    //Nếu không trả về -1     //tam giác tròn đến 2 điểm thập phân nếu ba mặt tạo thành một tam giác hợp lệ.     //Với chiều dài của ba cạnh của một tam giác. trả về diện tích của     // >>> TriangleArea((3L), (4L), (5L))
    // (6.0f)
    // >>> TriangleArea((1L), (2L), (10L))
    // (float)-1L
    public static float TriangleArea(long a, long b, long c) {
","public static float TriangleArea(long a, long b, long c) {
    // Check if the sides form a valid triangle using the triangle inequality theorem
    if (a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area of the triangle
        double s = (a + b + c) / 2.0;
        double area = Math.Sqrt(s * (s - a) * (s - b) * (s - c));
        return (float)Math.Round(area, 2);
    }
    return -1;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((3L), (4L), (5L)) == (6.0f));
    Debug.Assert(TriangleArea((1L), (2L), (10L)) == (float)-1L);
    Debug.Assert(TriangleArea((4L), (8L), (5L)) == (8.18f));
    Debug.Assert(TriangleArea((2L), (2L), (2L)) == (1.73f));
    Debug.Assert(TriangleArea((1L), (2L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((10L), (5L), (7L)) == (16.25f));
    Debug.Assert(TriangleArea((2L), (6L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((1L), (1L), (1L)) == (0.43f));
    Debug.Assert(TriangleArea((2L), (2L), (10L)) == (float)-1L);
    }

}
"
HumanEval_72,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Đối tượng q sẽ bay nếu nó cân bằng (nó là một danh sách palindromic) và tổng các yếu tố của nó nhỏ hơn hoặc bằng trọng lượng tối đa có thể w.    //Viết một hàm trả về true nếu đối tượng q sẽ bay, và false nếu không.     // >>> WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L})), (5L))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    public static bool WillItFly(List<long> q, long w) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool WillItFly(List<long> q, long w)
    {
        if (IsPalindromic(q) && SumIsLessThanOrEqual(q, w))
        {
            return true;
        }
        return false;
    }

    private static bool IsPalindromic(List<long> q)
    {
        int count = q.Count;
        for (int i = 0; i < count / 2; i++)
        {
            if (q[i] != q[count - i - 1])
            {
                return false;
            }
        }
        return true;
    }

    private static bool SumIsLessThanOrEqual(List<long> q, long w)
    {
        long sum = 0;
        foreach (var item in q)
        {
            sum += item;
            if (sum > w)
            {
                return false;
            }
        }
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L})), (5L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (6L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)5L})), (5L)) == (true));
    }

}
"
HumanEval_73,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //là đọc giống nhau từ trước sang sau. Trong một thay đổi, bạn có thể thay đổi một yếu tố cho bất kỳ yếu tố khác.    //cần phải được thay đổi để làm cho danh sách palindromic. Một danh sách palindromic là một danh sách mà     //Cho một danh sách arr của số nguyên, tìm số lượng tối thiểu của các yếu tố mà     // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L})))
    // (4L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L})))
    // (1L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L})))
    // (0L)
    public static long SmallestChange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SmallestChange(List<long> arr)
    {
        long changes = 0;
        int left = 0;
        int right = arr.Count - 1;

        while (left < right)
        {
            if (arr[left] != arr[right])
            {
                changes++;
            }
            left++;
            right--;
        }

        return changes;
    }

    static void Main()
    {
        // Example usage:
        List<long> list1 = new List<long> { 1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L };
        Console.WriteLine(SmallestChange(list1)); // Output: 4

        List<long> list2 = new List<long> { 1L, 2L, 3L, 4L, 3L, 2L, 2L };
        Console.WriteLine(SmallestChange(list2)); // Output: 1

        List<long> list3 = new List<long> { 1L, 2L, 3L, 2L, 1L };
        Console.WriteLine(SmallestChange(list3)); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L}))) == (4L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)3L, (long)1L, (long)1L, (long)3L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    }

}
"
HumanEval_74,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //nếu hai danh sách có cùng số ký tự, trả về danh sách đầu tiên.    //tổng số ký tự trong tất cả các chuỗi của danh sách ít hơn danh sách khác.    //Viết một hàm chấp nhận hai danh sách chuỗi và trả về danh sách có     // >>> TotalMatch((new List<string>()), (new List<string>()))
    // (new List<string>())
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""})))
    // (new List<string>(new string[]{(string)""hi"", (string)""admin""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""})))
    // (new List<string>(new string[]{(string)""4""}))
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2)
    {
        int totalCharsLst1 = lst1.Sum(s => s.Length);
        int totalCharsLst2 = lst2.Sum(s => s.Length);

        if (totalCharsLst1 <= totalCharsLst2)
        {
            return lst1;
        }
        else
        {
            return lst2;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>())).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""}))).Equals((new List<string>(new string[]{(string)""4""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""Hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hii""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>(new string[]{(string)""this""}))).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""this""})), (new List<string>())).Equals((new List<string>())));
    }

}
"
HumanEval_75,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Biết rằng (a) nhỏ hơn 100.    //và sai nếu không.    //Viết một hàm trả về true nếu số được đưa ra là phép nhân của 3 số nguyên tố     // >>> IsMultiplyPrime((30L))
    // (true)
    // 30 = 2 * 3 * 5
    public static bool IsMultiplyPrime(long a) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsMultiplyPrime(long a) {
        if (a >= 100) return false;
        
        List<long> primes = GeneratePrimes(100);
        
        int count = 0;
        foreach (long prime in primes) {
            while (a % prime == 0) {
                a /= prime;
                count++;
            }
            if (count > 3) break;
        }
        
        return a == 1 && count == 3;
    }

    private static List<long> GeneratePrimes(int max) {
        List<long> primes = new List<long>();
        bool[] isPrime = new bool[max + 1];
        for (int i = 2; i <= max; i++) isPrime[i] = true;

        for (int i = 2; i * i <= max; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= max; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        for (int i = 2; i <= max; i++) {
            if (isPrime[i]) primes.Add(i);
        }

        return primes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsMultiplyPrime((5L)) == (false));
    Debug.Assert(IsMultiplyPrime((30L)) == (true));
    Debug.Assert(IsMultiplyPrime((8L)) == (true));
    Debug.Assert(IsMultiplyPrime((10L)) == (false));
    Debug.Assert(IsMultiplyPrime((125L)) == (true));
    Debug.Assert(IsMultiplyPrime((105L)) == (true));
    Debug.Assert(IsMultiplyPrime((126L)) == (false));
    Debug.Assert(IsMultiplyPrime((729L)) == (false));
    Debug.Assert(IsMultiplyPrime((891L)) == (false));
    Debug.Assert(IsMultiplyPrime((1001L)) == (true));
    }

}
"
HumanEval_76,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //x là một bậc đơn của n nếu n**int=x     //sức mạnh của n và false trong các trường hợp khác.    //Nhiệm vụ của bạn là viết một hàm trả về true nếu một số x là một đơn giản     // >>> IsSimplePower((1L), (4L))
    // (true)
    // >>> IsSimplePower((2L), (2L))
    // (true)
    // >>> IsSimplePower((8L), (2L))
    // (true)
    // >>> IsSimplePower((3L), (2L))
    // (false)
    // >>> IsSimplePower((3L), (1L))
    // (false)
    // >>> IsSimplePower((5L), (3L))
    // (false)
    public static bool IsSimplePower(long x, long n) {
","if (x < 1 || n < 2)
        return false;

    while (x > 1)
    {
        if (x % n != 0)
            return false;
        x /= n;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSimplePower((16L), (2L)) == (true));
    Debug.Assert(IsSimplePower((143214L), (16L)) == (false));
    Debug.Assert(IsSimplePower((4L), (2L)) == (true));
    Debug.Assert(IsSimplePower((9L), (3L)) == (true));
    Debug.Assert(IsSimplePower((16L), (4L)) == (true));
    Debug.Assert(IsSimplePower((24L), (2L)) == (false));
    Debug.Assert(IsSimplePower((128L), (4L)) == (false));
    Debug.Assert(IsSimplePower((12L), (6L)) == (false));
    Debug.Assert(IsSimplePower((1L), (1L)) == (true));
    Debug.Assert(IsSimplePower((1L), (12L)) == (true));
    }

}
"
HumanEval_77,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Lưu ý: bạn có thể giả định đầu vào luôn luôn hợp lệ.    //nếu số này là một khối của một số nguyên.    //Viết một hàm lấy một số nguyên a và trả về true    // >>> Iscube((1L))
    // (true)
    // >>> Iscube((2L))
    // (false)
    // >>> Iscube((-1L))
    // (true)
    // >>> Iscube((64L))
    // (true)
    // >>> Iscube((0L))
    // (true)
    // >>> Iscube((180L))
    // (false)
    public static bool Iscube(long a) {
","using System;

class Problem {
    public static bool Iscube(long a) {
        if (a == 0) return true;
        long absA = Math.Abs(a);
        long cubeRoot = (long)Math.Round(Math.Pow(absA, 1.0 / 3.0));
        return cubeRoot * cubeRoot * cubeRoot == absA;
    }

    static void Main(string[] args) {
        Console.WriteLine(Iscube(1L));    // true
        Console.WriteLine(Iscube(2L));    // false
        Console.WriteLine(Iscube(-1L));   // true
        Console.WriteLine(Iscube(64L));   // true
        Console.WriteLine(Iscube(0L));    // true
        Console.WriteLine(Iscube(180L));  // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Iscube((1L)) == (true));
    Debug.Assert(Iscube((2L)) == (false));
    Debug.Assert(Iscube((-1L)) == (true));
    Debug.Assert(Iscube((64L)) == (true));
    Debug.Assert(Iscube((180L)) == (false));
    Debug.Assert(Iscube((1000L)) == (true));
    Debug.Assert(Iscube((0L)) == (true));
    Debug.Assert(Iscube((1729L)) == (false));
    }

}
"
HumanEval_78,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //và ký hiệu A, B, C, D, E, F luôn luôn là chữ cái lớn.    //Lưu ý: bạn có thể giả định đầu vào luôn luôn là đúng hoặc chuỗi trống,     //B (= thập phân 11), D (= thập phân 13).     //Vì vậy, bạn phải xác định một số các chữ số sau đây: 2, 3, 5, 7,     //Các số nguyên tố là 2, 3, 5, 7, 11, 13, 17,...    //Các chữ số thập niên lục là 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.    //lớn hơn 1 mà không phải là một sản phẩm của hai số tự nhiên nhỏ hơn).    //số nguyên tố (số nguyên tố, hoặc một số nguyên tố, là một số tự nhiên     //một số thập niên sáu như một chuỗi và đếm số lượng của thập niên sáu     //Bạn đã được giao nhiệm vụ viết một hàm nhận .    // >>> HexKey((""AB""))
    // (1L)
    // >>> HexKey((""1077E""))
    // (2L)
    // >>> HexKey((""ABED1A33""))
    // (4L)
    // >>> HexKey((""123456789ABCDEF0""))
    // (6L)
    // >>> HexKey((""2020""))
    // (2L)
    public static long HexKey(string num) {
","public static long HexKey(string num) {
    // Define a set of prime hexadecimal digits
    HashSet<char> primeHexDigits = new HashSet<char> { '2', '3', '5', '7', 'B', 'D' };

    long primeCount = 0;

    // Iterate through each character in the input string
    foreach (char c in num) {
        // If the character is in the set of prime hex digits, increase the count
        if (primeHexDigits.Contains(c)) {
            primeCount++;
        }
    }

    return primeCount;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HexKey((""AB"")) == (1L));
    Debug.Assert(HexKey((""1077E"")) == (2L));
    Debug.Assert(HexKey((""ABED1A33"")) == (4L));
    Debug.Assert(HexKey((""2020"")) == (2L));
    Debug.Assert(HexKey((""123456789ABCDEF0"")) == (6L));
    Debug.Assert(HexKey((""112233445566778899AABBCCDDEEFF00"")) == (12L));
    }

}
"
HumanEval_79,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Các ký tự bổ sung có ở đó để giúp với định dạng.    //Sẽ có thêm một vài ký tự 'db' ở đầu và cuối chuỗi.    //Mỗi ký tự trong chuỗi sẽ là ""0"" hoặc ""1"".    //định dạng nhị phân. Chức năng sẽ trả về một chuỗi, với mỗi ký tự đại diện cho một nhị phân     //Bạn sẽ được đưa ra một số dưới dạng thập phân và nhiệm vụ của bạn là chuyển đổi nó thành     // >>> DecimalToBinary((15L))
    // (""db1111db"")
    // >>> DecimalToBinary((32L))
    // (""db100000db"")
    public static string DecimalToBinary(long decimalNum) {
","public static string DecimalToBinary(long decimalNum) {
    string binary = Convert.ToString(decimalNum, 2);
    return ""db"" + binary + ""db"";
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DecimalToBinary((0L)).Equals((""db0db"")));
    Debug.Assert(DecimalToBinary((32L)).Equals((""db100000db"")));
    Debug.Assert(DecimalToBinary((103L)).Equals((""db1100111db"")));
    Debug.Assert(DecimalToBinary((15L)).Equals((""db1111db"")));
    }

}
"
HumanEval_80,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Một chuỗi là hapcs nếu chiều dài của nó ít nhất là 3 và mỗi 3 chữ cái liên tiếp là khác nhau     //Nhiệm vụ của bạn là kiểm tra xem chuỗi là hapcs hay không.    //Bạn được cho một chuỗi s.    // >>> IsHappy((""a""))
    // (false)
    // >>> IsHappy((""aa""))
    // (false)
    // >>> IsHappy((""abcd""))
    // (true)
    // >>> IsHappy((""aabb""))
    // (false)
    // >>> IsHappy((""adb""))
    // (true)
    // >>> IsHappy((""xyy""))
    // (false)
    public static bool IsHappy(string s) {
","if (s.Length < 3) {
        return false;
    }

    for (int i = 0; i <= s.Length - 3; i++) {
        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsHappy((""a"")) == (false));
    Debug.Assert(IsHappy((""aa"")) == (false));
    Debug.Assert(IsHappy((""abcd"")) == (true));
    Debug.Assert(IsHappy((""aabb"")) == (false));
    Debug.Assert(IsHappy((""adb"")) == (true));
    Debug.Assert(IsHappy((""xyy"")) == (false));
    Debug.Assert(IsHappy((""iopaxpoi"")) == (true));
    Debug.Assert(IsHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //0.0 E     //> 0.0 D-     //> 0,7 D     //> 1,0 D+     //> 1.3 C-     //> 1,7 C     //> 2.0 C+     //> 2.3 B-     //> 2,7 B     //> 3.0 B+     //> 3.3 A-     //> 3.7 A     //4.0 A+     //GPA. Điểm chữ.    //một hàm có thể xuất ra danh sách các cấp chữ cái bằng cách sử dụng bảng sau:     //Cô ấy đã cho anh một danh sách điểm trung bình của một số học sinh và anh phải viết.    //Vấn đề duy nhất là, cô ấy đã mất mã mà cô ấy sử dụng để đánh giá.    //Giáo viên đã tạo ra thuật toán riêng của mình để đánh giá.    //Đây là tuần cuối của học kỳ và giáo viên phải đưa ra điểm số.    // >>> GradeEquation((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f})))
    // (new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))
    public static List<string> NumericalLetterGrade(List<float> grades) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> NumericalLetterGrade(List<float> grades)
    {
        List<string> letterGrades = new List<string>();

        foreach (var gpa in grades)
        {
            if (gpa == 4.0f)
                letterGrades.Add(""A+"");
            else if (gpa > 3.7f)
                letterGrades.Add(""A"");
            else if (gpa > 3.3f)
                letterGrades.Add(""A-"");
            else if (gpa > 3.0f)
                letterGrades.Add(""B+"");
            else if (gpa > 2.7f)
                letterGrades.Add(""B"");
            else if (gpa > 2.3f)
                letterGrades.Add(""B-"");
            else if (gpa > 2.0f)
                letterGrades.Add(""C+"");
            else if (gpa > 1.7f)
                letterGrades.Add(""C"");
            else if (gpa > 1.3f)
                letterGrades.Add(""C-"");
            else if (gpa > 1.0f)
                letterGrades.Add(""D+"");
            else if (gpa > 0.7f)
                letterGrades.Add(""D"");
            else if (gpa > 0.0f)
                letterGrades.Add(""D-"");
            else
                letterGrades.Add(""E"");
        }

        return letterGrades;
    }

    static void Main(string[] args)
    {
        List<float> gpas = new List<float> { 4.0f, 3.0f, 1.7f, 2.0f, 3.5f };
        List<string> grades = NumericalLetterGrade(gpas);
        Console.WriteLine(string.Join("", "", grades));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f}))).Equals((new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.2f}))).Equals((new List<string>(new string[]{(string)""D+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.5f}))).Equals((new List<string>(new string[]{(string)""D-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f}))).Equals((new List<string>(new string[]{(string)""E""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))).Equals((new List<string>(new string[]{(string)""D"", (string)""D-"", (string)""C-"", (string)""B"", (string)""B+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f, (float)0.7f}))).Equals((new List<string>(new string[]{(string)""E"", (string)""D-""}))));
    }

}
"
HumanEval_82,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //length là một số nguyên tố hoặc sai nếu không     //Viết một hàm lấy một chuỗi và trả về true nếu chuỗi     // >>> PrimeLength((""Hello""))
    // (true)
    // >>> PrimeLength((""abcdcba""))
    // (true)
    // >>> PrimeLength((""kittens""))
    // (true)
    // >>> PrimeLength((""orange""))
    // (false)
    public static bool PrimeLength(string str) {
","using System;

class Problem {
    public static bool PrimeLength(string str) {
        int length = str.Length;
        if (length < 2) return false;
        
        for (int i = 2; i <= Math.Sqrt(length); i++) {
            if (length % i == 0) return false;
        }
        
        return true;
    }
    
    // Example usage
    public static void Main() {
        Console.WriteLine(PrimeLength(""Hello""));    // true
        Console.WriteLine(PrimeLength(""abcdcba""));  // true
        Console.WriteLine(PrimeLength(""kittens""));  // true
        Console.WriteLine(PrimeLength(""orange""));   // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeLength((""Hello"")) == (true));
    Debug.Assert(PrimeLength((""abcdcba"")) == (true));
    Debug.Assert(PrimeLength((""kittens"")) == (true));
    Debug.Assert(PrimeLength((""orange"")) == (false));
    Debug.Assert(PrimeLength((""wow"")) == (true));
    Debug.Assert(PrimeLength((""world"")) == (true));
    Debug.Assert(PrimeLength((""MadaM"")) == (true));
    Debug.Assert(PrimeLength((""Wow"")) == (true));
    Debug.Assert(PrimeLength(("""")) == (false));
    Debug.Assert(PrimeLength((""HI"")) == (true));
    Debug.Assert(PrimeLength((""go"")) == (true));
    Debug.Assert(PrimeLength((""gogo"")) == (false));
    Debug.Assert(PrimeLength((""aaaaaaaaaaaaaaa"")) == (false));
    Debug.Assert(PrimeLength((""Madam"")) == (true));
    Debug.Assert(PrimeLength((""M"")) == (false));
    Debug.Assert(PrimeLength((""0"")) == (false));
    }

}
"
HumanEval_83,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Các số nguyên dương bắt đầu hoặc kết thúc bằng 1.    //Cho một số nguyên dương n, trả về số lượng các số n chữ số     public static long StartsOneEnds(long n) {
","if (n == 1) return 1;
        return (long)Math.Pow(10, n - 1) + 9 * (long)Math.Pow(10, n - 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StartsOneEnds((1L)) == (1L));
    Debug.Assert(StartsOneEnds((2L)) == (18L));
    Debug.Assert(StartsOneEnds((3L)) == (180L));
    Debug.Assert(StartsOneEnds((4L)) == (1800L));
    Debug.Assert(StartsOneEnds((5L)) == (18000L));
    }

}
"
HumanEval_84,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //Cho một số nguyên dương N, trả về tổng số các chữ số của nó bằng nhị phân.     // >>> Solve((1000L))
    // (""1"")
    // >>> Solve((150L))
    // (""110"")
    // >>> Solve((147L))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    public static string Solve(long N) {
","public static string Solve(long N) {
        int sumOfDigits = 0;
        while (N > 0) {
            sumOfDigits += (int)(N % 10);
            N /= 10;
        }
        return Convert.ToString(sumOfDigits, 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((1000L)).Equals((""1"")));
    Debug.Assert(Solve((150L)).Equals((""110"")));
    Debug.Assert(Solve((147L)).Equals((""1100"")));
    Debug.Assert(Solve((333L)).Equals((""1001"")));
    Debug.Assert(Solve((963L)).Equals((""10010"")));
    }

}
"
HumanEval_85,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Cho một danh sách không trống của số nguyên lst. thêm các yếu tố thậm chí mà là ở chỉ số lẻ ..     // >>> Add((new List<long>(new long[]{(long)4L, (long)2L, (long)6L, (long)7L})))
    // (2L)
    public static long Add(List<long> lst) {
","long sum = 0;
    for (int i = 1; i < lst.Count; i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)88L}))) == (88L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)5L, (long)6L, (long)7L, (long)2L, (long)122L}))) == (122L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)0L, (long)6L, (long)7L}))) == (0L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)4L, (long)6L, (long)8L}))) == (12L));
    }

}
"
HumanEval_86,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Lưu ý: Bạn nên giữ trật tự của từ và khoảng trống trong câu.    //thứ tự tăng dựa trên giá trị ascii.    //được thay thế bằng một từ mới trong đó tất cả các ký tự được sắp xếp trong     //Phiên bản được sắp xếp của chuỗi, là một chuỗi trong đó tất cả các từ (được tách bằng không gian)     //Viết một hàm lấy một chuỗi và trả về một phiên bản được sắp xếp của nó.     // >>> AntiShuffle((""Hi""))
    // (""Hi"")
    // >>> AntiShuffle((""hello""))
    // (""ehllo"")
    // >>> AntiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    public static string AntiShuffle(string s) {
","using System;
using System.Linq;

class Problem
{
    public static string AntiShuffle(string s)
    {
        return string.Join("" "", s.Split(' ')
            .Select(word => string.Concat(word.OrderBy(c => c))));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AntiShuffle((""Hi"")).Equals((""Hi"")));
    Debug.Assert(AntiShuffle((""hello"")).Equals((""ehllo"")));
    Debug.Assert(AntiShuffle((""number"")).Equals((""bemnru"")));
    Debug.Assert(AntiShuffle((""abcd"")).Equals((""abcd"")));
    Debug.Assert(AntiShuffle((""Hello World!!!"")).Equals((""Hello !!!Wdlor"")));
    Debug.Assert(AntiShuffle(("""")).Equals(("""")));
    Debug.Assert(AntiShuffle((""Hi. My name is Mister Robot. How are you?"")).Equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Ngoài ra, sắp xếp tọa độ của hàng theo cột theo thứ tự giảm dần.    //Xếp các tọa độ ban đầu theo hàng theo thứ tự tăng dần.    //mỗi tuple là một tọa độ - (dòng, cột), bắt đầu với 0.     //và trả về danh sách các tuples, [(x1, y1), (x2, y2) ...] như vậy mà     //Cho lst, và số nguyên x, tìm số nguyên x trong danh sách,     //mỗi hàng có thể chứa một số lượng cột khác nhau.    //mà là tương tự như ma trận, tuy nhiên, không giống như ma trận,     //Bạn được cung cấp một dữ liệu 2 chiều, như là một danh sách lồng,     // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))
    // >>> GetRow((new List<List<long>>()), (1L))
    // (new List<Tuple<long, long>>())
    // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
        var result = new List<Tuple<long, long>>();
        
        for (long row = 0; row < lst.Count; row++) {
            List<long> currentRow = lst[(int)row];
            var foundIndices = new List<long>();
            
            for (long col = 0; col < currentRow.Count; col++) {
                if (currentRow[(int)col] == x) {
                    foundIndices.Add(col);
                }
            }
            
            foundIndices.Sort((a, b) => b.CompareTo(a)); // Sort columns in descending order
            
            foreach (var col in foundIndices) {
                result.Add(Tuple.Create(row, col));
            }
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})})), (2L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 1L), (Tuple<long, long>)Tuple.Create(1L, 1L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(3L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(5L, 1L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)1L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(2L, 0L), (Tuple<long, long>)Tuple.Create(3L, 2L), (Tuple<long, long>)Tuple.Create(3L, 0L), (Tuple<long, long>)Tuple.Create(4L, 3L), (Tuple<long, long>)Tuple.Create(4L, 0L), (Tuple<long, long>)Tuple.Create(5L, 4L), (Tuple<long, long>)Tuple.Create(5L, 0L), (Tuple<long, long>)Tuple.Create(6L, 5L), (Tuple<long, long>)Tuple.Create(6L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>()), (1L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L})})), (2L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))));
    }

}
"
HumanEval_88,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //* Đừng thay đổi danh sách đã được đưa ra.    //Lưu ý:    //hoặc sắp xếp theo thứ tự giảm dần nếu tổng số ((giá trị chỉ số đầu tiên, giá trị chỉ số cuối cùng) là chẵn.     //bạn sẽ sắp xếp danh sách được đưa ra theo thứ tự tăng dần nếu tổng số ((giá trị chỉ số đầu tiên, giá trị chỉ số cuối cùng) là lẻ,     //Cho một danh sách các số nguyên không âm, trả về một cocs của danh sách được đưa ra sau khi sắp xếp,     // >>> SortArray((new List<long>()))
    // (new List<long>())
    // >>> SortArray((new List<long>(new long[]{(long)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))
    public static List<long> SortArray(List<long> array) {
","public static List<long> SortArray(List<long> array) {
        if (array == null || array.Count <= 1) {
            return new List<long>(array);
        }
        
        long firstValue = array[0];
        long lastValue = array[array.Count - 1];
        long sum = firstValue + lastValue;

        List<long> sortedArray = new List<long>(array);

        if (sum % 2 != 0) { // sum is odd, sort ascending
            sortedArray.Sort();
        } else { // sum is even, sort descending
            sortedArray.Sort();
            sortedArray.Reverse();
        }

        return sortedArray;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)5L}))).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)15L, (long)42L, (long)87L, (long)32L, (long)11L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)11L, (long)15L, (long)32L, (long)42L, (long)87L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)21L, (long)14L, (long)23L, (long)11L}))).Equals((new List<long>(new long[]{(long)23L, (long)21L, (long)14L, (long)11L}))));
    }

}
"
HumanEval_89,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //chuyển xuống bằng hai nhân với hai vị trí.    //Bảng chữ cái nên được xoay theo cách mà các chữ cái     //trả về một chuỗi được mã hóa với chữ cái được xoay.    //Tạo một hàm mã hóa dùng chuỗi như một đối số và     // >>> Encrypt((""hi""))
    // (""lm"")
    // >>> Encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> Encrypt((""gf""))
    // (""kj"")
    // >>> Encrypt((""et""))
    // (""ix"")
    public static string Encrypt(string s) {
","const int shiftAmount = 4; // 2 multiplied by 2 equals 4.

    StringBuilder encrypted = new StringBuilder();

    foreach (char c in s) {
        if (char.IsLetter(c)) {
            char start = char.IsUpper(c) ? 'A' : 'a';
            char encryptedChar = (char)(start + (c - start + shiftAmount) % 26);
            encrypted.Append(encryptedChar);
        } else {
            encrypted.Append(c); // Non-letter characters are not encrypted.
        }
    }

    return encrypted.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encrypt((""hi"")).Equals((""lm"")));
    Debug.Assert(Encrypt((""asdfghjkl"")).Equals((""ewhjklnop"")));
    Debug.Assert(Encrypt((""gf"")).Equals((""kj"")));
    Debug.Assert(Encrypt((""et"")).Equals((""ix"")));
    Debug.Assert(Encrypt((""faewfawefaewg"")).Equals((""jeiajeaijeiak"")));
    Debug.Assert(Encrypt((""hellomyfriend"")).Equals((""lippsqcjvmirh"")));
    Debug.Assert(Encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).Equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    Debug.Assert(Encrypt((""a"")).Equals((""e"")));
    }

}
"
HumanEval_90,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Trả về null nếu không có yếu tố như vậy.     //Viết hàm next_smallest (thì là nhỏ nhất) trả về phần tử nhỏ thứ 2 trong danh sách.     //Bạn được đưa ra một danh sách các số nguyên.    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // 2L
    // >>> NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L})))
    // 2L
    // >>> NextSmallest((new List<long>()))
    // null
    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)1L})))
    // null
    public static Nullable<long> NextSmallest(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Nullable<long> NextSmallest(List<long> lst) {
        if (lst == null || lst.Count < 2) {
            return null;
        }

        HashSet<long> uniqueElements = new HashSet<long>(lst);
        if (uniqueElements.Count < 2) {
            return null;
        }

        List<long> sortedUniqueElements = uniqueElements.ToList();
        sortedUniqueElements.Sort();

        return sortedUniqueElements[1];
    }

    static void Main(string[] args) {
        Console.WriteLine(NextSmallest(new List<long> {1, 2, 3, 4, 5})); // 2
        Console.WriteLine(NextSmallest(new List<long> {5, 1, 4, 3, 2})); // 2
        Console.WriteLine(NextSmallest(new List<long>())); // null
        Console.WriteLine(NextSmallest(new List<long> {1, 1})); // null
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>())).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)0L}))).Equals(1L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));
    }

}
"
HumanEval_91,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Các câu được phân chia bởi """", ""?"" hoặc ""! "".    //Một câu chán là một câu bắt đầu bằng từ ""I"".    //Bạn sẽ được cho một chuỗi từ, và nhiệm vụ của bạn là đếm số.    // >>> IsBored((""Hello world""))
    // (0L)
    // >>> IsBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1L)
    public static long IsBored(string S) {
","using System;

class Problem {
    public static long IsBored(string S) {
        // Split the input string into sentences based on delimiters '.', '?', '!'
        char[] delimiters = new char[] { '.', '?', '!' };
        string[] sentences = S.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);

        // Count sentences that start with 'I' after trimming leading whitespaces
        long boredomCount = 0;
        foreach (string sentence in sentences) {
            if (sentence.TrimStart().StartsWith(""I"")) {
                boredomCount++;
            }
        }

        return boredomCount;
    }

    static void Main(string[] args) {
        // Example usage:
        Console.WriteLine(IsBored(""Hello world"")); // Output: 0
        Console.WriteLine(IsBored(""The sky is blue. The sun is shining. I love this weather"")); // Output: 1
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsBored((""Hello world"")) == (0L));
    Debug.Assert(IsBored((""Is the sky blue?"")) == (0L));
    Debug.Assert(IsBored((""I love It !"")) == (1L));
    Debug.Assert(IsBored((""bIt"")) == (0L));
    Debug.Assert(IsBored((""I feel good today. I will be productive. will kill It"")) == (2L));
    Debug.Assert(IsBored((""You and I are going for a walk"")) == (0L));
    }

}
"
HumanEval_92,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //Trả về false trong mọi trường hợp khác.    //Trả về true nếu một trong các số bằng tổng của hai số khác, và tất cả các số là số nguyên.    //Tạo một hàm có 3 số.    // >>> AnyInt((float)5L, (float)2L, (float)7L)
    // (true)
    // >>> AnyInt((float)3L, (float)2L, (float)2L)
    // (false)
    // >>> AnyInt((float)3L, (float)-2L, (float)1L)
    // (true)
    // >>> AnyInt((3.6f), (-2.2f), (float)2L)
    // (false)
    public static bool AnyInt(float x, float y, float z) {
","public static bool AnyInt(float x, float y, float z) {
        if (x == Math.Round(x) && y == Math.Round(y) && z == Math.Round(z)) {
            if (x == y + z || y == x + z || z == x + y) {
                return true;
            }
        }
        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AnyInt((float)2L, (float)3L, (float)1L) == (true));
    Debug.Assert(AnyInt((2.5f), (float)2L, (float)3L) == (false));
    Debug.Assert(AnyInt((1.5f), (float)5L, (3.5f)) == (false));
    Debug.Assert(AnyInt((float)2L, (float)6L, (float)2L) == (false));
    Debug.Assert(AnyInt((float)4L, (float)2L, (float)2L) == (true));
    Debug.Assert(AnyInt((2.2f), (2.2f), (2.2f)) == (false));
    Debug.Assert(AnyInt((float)-4L, (float)6L, (float)2L) == (true));
    Debug.Assert(AnyInt((float)2L, (float)1L, (float)1L) == (true));
    Debug.Assert(AnyInt((float)3L, (float)4L, (float)7L) == (true));
    Debug.Assert(AnyInt((3.0f), (float)4L, (float)7L) == (false));
    }

}
"
HumanEval_93,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Chỉ giả định chữ cái.    //Một nguyên âm trong bảng chữ cái tiếng Anh.    //thông điệp với chữ cái xuất hiện 2 vị trí trước đó     //cách mà nó swaps trường hợp của tất cả các chữ cái, thay thế tất cả các nguyên âm trong     //Viết một hàm mà có một thông điệp, và mã hóa trong một như vậy     // >>> Encode((""test""))
    // (""TGST"")
    // >>> Encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    public static string Encode(string message) {
","public static string Encode(string message) {
    // Define vowels and their replacements
    Dictionary<char, char> vowelReplacement = new Dictionary<char, char>
    {
        { 'a', 'c' },
        { 'e', 'g' },
        { 'i', 'k' },
        { 'o', 'q' },
        { 'u', 'w' },
        { 'A', 'C' },
        { 'E', 'G' },
        { 'I', 'K' },
        { 'O', 'Q' },
        { 'U', 'W' }
    };

    StringBuilder encodedMessage = new StringBuilder();

    foreach (char c in message) {
        if (char.IsLetter(c)) {
            // Swap case
            char swappedCaseChar = char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c);

            // Replace vowels according to the defined map
            if (vowelReplacement.ContainsKey(swappedCaseChar)) {
                encodedMessage.Append(vowelReplacement[swappedCaseChar]);
            } else {
                encodedMessage.Append(swappedCaseChar);
            }
        } else {
            // Non-letter characters should be appended as-is (if necessary)
            encodedMessage.Append(c);
        }
    }

    return encodedMessage.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encode((""TEST"")).Equals((""tgst"")));
    Debug.Assert(Encode((""Mudasir"")).Equals((""mWDCSKR"")));
    Debug.Assert(Encode((""YES"")).Equals((""ygs"")));
    Debug.Assert(Encode((""This is a message"")).Equals((""tHKS KS C MGSSCGG"")));
    Debug.Assert(Encode((""I DoNt KnOw WhAt tO WrItE"")).Equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Bạn cần tìm giá trị nguyên tố lớn nhất và trả về tổng số chữ số của nó.    //Bạn được đưa ra một danh sách các số nguyên.    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L})))
    // (10L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L})))
    // (25L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L})))
    // (13L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L})))
    // (11L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L})))
    // (3L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L})))
    // (7L)
    public static long Skjkasdkd(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long Skjkasdkd(List<long> lst) {
        long largestPrime = -1;

        foreach (var num in lst) {
            if (IsPrime(num) && num > largestPrime) {
                largestPrime = num;
            }
        }

        if (largestPrime == -1) return 0;

        return SumOfDigits(largestPrime);
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;

        if (number % 2 == 0 || number % 3 == 0) return false;

        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }

        return true;
    }

    private static long SumOfDigits(long number) {
        long sum = 0;
        while (number != 0) {
            sum += number % 10;
            number /= 10;
        }
        return sum;
    }
}

// Example of usage:
// var result = Problem.Skjkasdkd(new List<long> {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3});
// Console.WriteLine(result); // Output will be 10","    }
    public static void Main(string[] args) {
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L}))) == (10L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L}))) == (25L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L}))) == (13L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L}))) == (11L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L}))) == (3L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L}))) == (7L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L, (long)123456L, (long)127L, (long)7L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)127L, (long)97L, (long)8192L}))) == (10L));
    }

}
"
HumanEval_95,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Hàm sẽ trả về false nếu từ điển được đưa ra là trống.     //case hoặc tất cả các khóa là chuỗi trong chữ cái lớn, nếu không trả về false.     //Cho một từ điển, trả về đúng nếu tất cả các phím là chuỗi trong lower     // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""b"", ""banana""}}))
    // (true)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""A"", ""banana""}, {""B"", ""banana""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {8L, ""banana""}, {""a"", ""apple""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))
    // (true)
    public static bool CheckDictCase(Dictionary<string,string> dict) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool CheckDictCase(Dictionary<string, string> dict)
    {
        if (dict.Count == 0)
            return false;

        bool allLower = true;
        bool allUpper = true;

        foreach (var key in dict.Keys)
        {
            if (key != key.ToLower())
                allLower = false;
            if (key != key.ToUpper())
                allUpper = false;
        }

        return allLower || allUpper;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""b"", ""banana""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""fruit"", ""Orange""}, {""taste"", ""Sweet""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>())) == (false));
    }

}
"
HumanEval_96,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //là số nguyên và nhỏ hơn n.    //Thực hiện một hàm lấy một số nguyên không âm và trả về một danh sách các số đầu tiên n     // >>> CountUpTo((5L))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    // >>> CountUpTo((11L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))
    // >>> CountUpTo((0L))
    // (new List<long>())
    // >>> CountUpTo((20L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))
    // >>> CountUpTo((1L))
    // (new List<long>())
    // >>> CountUpTo((18L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))
    public static List<long> CountUpTo(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> CountUpTo(long n) {
        List<long> primes = new List<long>();
        if (n <= 2) return primes;

        // Check for prime numbers from 2 up to n-1
        for (long i = 2; i < n; i++) {
            if (IsPrime(i)) {
                primes.Add(i);
            }
        }

        return primes;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number == 2) return true;

        long boundary = (long)Math.Sqrt(number);

        for (long i = 2; i <= boundary; i++) {
            if (number % i == 0) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpTo((5L)).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(CountUpTo((6L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((7L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((10L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))));
    Debug.Assert(CountUpTo((0L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((22L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))));
    Debug.Assert(CountUpTo((1L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(CountUpTo((47L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L}))));
    Debug.Assert(CountUpTo((101L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L, (long)47L, (long)53L, (long)59L, (long)61L, (long)67L, (long)71L, (long)73L, (long)79L, (long)83L, (long)89L, (long)97L}))));
    }

}
"
HumanEval_97,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Giả sử đầu vào luôn luôn hợp lệ.    //là sản phẩm của các chữ số đơn vị của chúng.    //Hoàn thành hàm lấy hai số nguyên và trả về     // >>> Multiply((148L), (412L))
    // (16L)
    // >>> Multiply((19L), (28L))
    // (72L)
    // >>> Multiply((2020L), (1851L))
    // (0L)
    // >>> Multiply((14L), (-15L))
    // (20L)
    public static long Multiply(long a, long b) {
","public static long Multiply(long a, long b) {
    int unitDigitA = (int)(Math.Abs(a) % 10);
    int unitDigitB = (int)(Math.Abs(b) % 10);
    return (long)(unitDigitA * unitDigitB);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Multiply((148L), (412L)) == (16L));
    Debug.Assert(Multiply((19L), (28L)) == (72L));
    Debug.Assert(Multiply((2020L), (1851L)) == (0L));
    Debug.Assert(Multiply((14L), (-15L)) == (20L));
    Debug.Assert(Multiply((76L), (67L)) == (42L));
    Debug.Assert(Multiply((17L), (27L)) == (49L));
    Debug.Assert(Multiply((0L), (1L)) == (0L));
    Debug.Assert(Multiply((0L), (0L)) == (0L));
    }

}
"
HumanEval_98,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Với một chuỗi s, đếm số nguyên âm lớn trong chỉ số chẵn.    // >>> CountUpper((""aBCdEf""))
    // (1L)
    // >>> CountUpper((""abcdefg""))
    // (0L)
    // >>> CountUpper((""dBBE""))
    // (0L)
    public static long CountUpper(string s) {
","using System;

class Problem {
    public static long CountUpper(string s) {
        long count = 0;
        for (int i = 0; i < s.Length; i += 2) {
            if (""AEIOU"".Contains(s[i])) {
                count++;
            }
        }
        return count;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CountUpper(""aBCdEf"")); // Output: 1
        Console.WriteLine(CountUpper(""abcdefg"")); // Output: 0
        Console.WriteLine(CountUpper(""dBBE"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpper((""aBCdEf"")) == (1L));
    Debug.Assert(CountUpper((""abcdefg"")) == (0L));
    Debug.Assert(CountUpper((""dBBE"")) == (0L));
    Debug.Assert(CountUpper((""B"")) == (0L));
    Debug.Assert(CountUpper((""U"")) == (1L));
    Debug.Assert(CountUpper(("""")) == (0L));
    Debug.Assert(CountUpper((""EEEE"")) == (2L));
    }

}
"
HumanEval_99,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //từ hai số nguyên, làm tròn nó đi từ không.    //và trả về số nguyên gần nhất với nó. Nếu số là bằng nhau    //Tạo hàm lấy giá trị (string) đại diện cho một số     // >>> ClosestInteger((""10""))
    // (10L)
    // >>> ClosestInteger((""15.3""))
    // (15L)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    public static long ClosestInteger(string value) {
","public static long ClosestInteger(string value) {
    double number = double.Parse(value);
    return (long)Math.Round(number, MidpointRounding.AwayFromZero);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ClosestInteger((""10"")) == (10L));
    Debug.Assert(ClosestInteger((""14.5"")) == (15L));
    Debug.Assert(ClosestInteger((""-15.5"")) == (-16L));
    Debug.Assert(ClosestInteger((""15.3"")) == (15L));
    Debug.Assert(ClosestInteger((""0"")) == (0L));
    }

}
"
HumanEval_100,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //i là số lượng đá trong cấp độ (i + 1).    //Trả về số lượng đá trong mỗi cấp trong một danh sách, trong đó phần tử tại chỉ mục     //- số chẵn tiếp theo nếu n là số chẵn.    //- số lẻ tiếp theo nếu n là số lẻ.     //Số lượng đá ở tầng tiếp theo là:    //Cấp đầu tiên có n viên đá.    //Cho một số nguyên dương n, bạn phải làm một đống n cấp đá.    // >>> MakeAPile((3L))
    // (new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))
    public static List<long> MakeAPile(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> MakeAPile(long n) {
        List<long> pile = new List<long>();
        long currentStones = n;
        
        for (long i = 0; i < n; i++) {
            pile.Add(currentStones);
            currentStones += (n % 2 == 0) ? 2 : 2;
        }

        return pile;
    }
    
    static void Main(string[] args) {
        List<long> result = MakeAPile(3L);
        Console.WriteLine(string.Join("", "", result));  // Output: 3, 5, 7
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakeAPile((3L)).Equals((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))));
    Debug.Assert(MakeAPile((4L)).Equals((new List<long>(new long[]{(long)4L, (long)6L, (long)8L, (long)10L}))));
    Debug.Assert(MakeAPile((5L)).Equals((new List<long>(new long[]{(long)5L, (long)7L, (long)9L, (long)11L, (long)13L}))));
    Debug.Assert(MakeAPile((6L)).Equals((new List<long>(new long[]{(long)6L, (long)8L, (long)10L, (long)12L, (long)14L, (long)16L}))));
    Debug.Assert(MakeAPile((8L)).Equals((new List<long>(new long[]{(long)8L, (long)10L, (long)12L, (long)14L, (long)16L, (long)18L, (long)20L, (long)22L}))));
    }

}
"
HumanEval_101,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //để chia chuỗi thành các từ và trả về một danh sách các từ.    //Bạn sẽ được cung cấp một chuỗi từ được tách ra bởi dấu phẩy hoặc khoảng trống.    // >>> WordsString((""Hi, my name is John""))
    // (new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))
    // >>> WordsString((""One, two, three, four, five, six""))
    // (new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))
    public static List<string> WordsString(string s) {
","public static List<string> WordsString(string s) {
    char[] separators = new char[] { ' ', ',' };
    var words = s.Split(separators, StringSplitOptions.RemoveEmptyEntries);
    return new List<string>(words);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsString((""Hi, my name is John"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))));
    Debug.Assert(WordsString((""One, two, three, four, five, six"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString((""Hi, my name"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name""}))));
    Debug.Assert(WordsString((""One,, two, three, four, five, six,"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString(("""")).Equals((new List<string>())));
    Debug.Assert(WordsString((""ahmed     , gamal"")).Equals((new List<string>(new string[]{(string)""ahmed"", (string)""gamal""}))));
    }

}
"
HumanEval_102,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //không có số như vậy, sau đó các chức năng nên trả về -1.    //số nguyên chẵn lớn nhất nằm trong phạm vi [x, y] bao gồm. Nếu     //Hàm này lấy hai số dương x và y và trả về     // >>> ChooseNum((12L), (15L))
    // (14L)
    // >>> ChooseNum((13L), (12L))
    // (-1L)
    public static long ChooseNum(long x, long y) {
","if (x > y) {
            return -1;
        }
        
        // Ensure x is the bigger one for simplicity
        if (x > y) {
            long temp = x;
            x = y;
            y = temp;
        }
        
        // Start searching from y down to x
        for (long i = y; i >= x; i--) {
            if (i % 2 == 0) {
                return i;
            }
        }
        
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChooseNum((12L), (15L)) == (14L));
    Debug.Assert(ChooseNum((13L), (12L)) == (-1L));
    Debug.Assert(ChooseNum((33L), (12354L)) == (12354L));
    Debug.Assert(ChooseNum((5234L), (5233L)) == (-1L));
    Debug.Assert(ChooseNum((6L), (29L)) == (28L));
    Debug.Assert(ChooseNum((27L), (10L)) == (-1L));
    Debug.Assert(ChooseNum((7L), (7L)) == (-1L));
    Debug.Assert(ChooseNum((546L), (546L)) == (546L));
    }

}
"
HumanEval_104,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Lưu ý: Danh sách được trả lại nên được sắp xếp theo thứ tự tăng dần.    //các phần tử không có bất kỳ chữ số chẵn nào.    //Cho một danh sách các số nguyên dương x. trả về một danh sách được sắp xếp của tất cả     // >>> UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L})))
    // (new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))
    // >>> UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L})))
    // (new List<long>())
    public static List<long> UniqueDigits(List<long> x) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> UniqueDigits(List<long> x) {
        return x.Where(n => !n.ToString().Any(c => ""02468"".Contains(c)))
                .OrderBy(n => n)
                .ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L}))).Equals((new List<long>())));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)12345L, (long)2033L, (long)111L, (long)151L}))).Equals((new List<long>(new long[]{(long)111L, (long)151L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)135L, (long)103L, (long)31L}))).Equals((new List<long>(new long[]{(long)31L, (long)135L}))));
    }

}
"
HumanEval_105,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Một, hai, ba, bốn, năm, sáu, bảy, tám, chín.    //đảo ngược danh sách kết quả, và sau đó thay thế mỗi chữ số bằng tên tương ứng của nó từ     //Với một danh sách các số nguyên, sắp xếp các số nguyên nằm trong khoảng từ 1 đến 9 bao gồm,     // >>> ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L})))
    // (new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))
    // If the list is empty, return an empty list:
    // >>> ByLength((new List<long>()))
    // (new List<string>())
    // If the list has any strange number ignore it:
    // >>> ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L})))
    // (new List<string>(new string[]{(string)""One""}))
    public static List<string> ByLength(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ByLength(List<long> arr) {
        // Define a dictionary to map numbers to their names.
        var digitToName = new Dictionary<long, string> {
            {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""},
            {5, ""Five""}, {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}
        };

        // Filter the numbers that are between 1 and 9.
        var filtered = arr.Where(x => digitToName.ContainsKey(x)).ToList();

        // Sort the filtered numbers.
        filtered.Sort();

        // Reverse the list.
        filtered.Reverse();

        // Map the numbers to their names using the dictionary.
        return filtered.Select(x => digitToName[x]).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L}))).Equals((new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>())).Equals((new List<string>())));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L}))).Equals((new List<string>(new string[]{(string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)3L, (long)2L}))).Equals((new List<string>(new string[]{(string)""Three"", (string)""Two"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)9L, (long)4L, (long)8L}))).Equals((new List<string>(new string[]{(string)""Nine"", (string)""Eight"", (string)""Four""}))));
    }

}
"
HumanEval_106,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //hàm số của i là nhân các số từ 1 đến i (1 * 2 * ... * i).    //i bắt đầu từ 1.    //hoặc tổng các số từ 1 đến i.     //và trả về một danh sách kích thước n, như vậy là giá trị của các yếu tố tại chỉ số i là hàm số của i nếu i là thậm chí     //Thực hiện hàm f mà có n là một tham số,     // >>> F((5L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))
    public static List<long> F(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> F(long n) {
        List<long> result = new List<long>();

        for (long i = 1; i <= n; i++) {
            if (i % 2 == 0) {
                result.Add(Factorial(i));
            } else {
                result.Add(SumUpTo(i));
            }
        }
        
        return result;
    }

    private static long Factorial(long number) {
        if (number == 0) return 1;
        long factorial = 1;
        for (long i = 1; i <= number; i++) {
            factorial *= i;
        }
        return factorial;
    }

    private static long SumUpTo(long number) {
        return (number * (number + 1)) / 2;
    }

    static void Main(string[] args) {
        List<long> result = F(5);
        foreach (long val in result) {
            Console.WriteLine(val);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(F((5L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))));
    Debug.Assert(F((7L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L, (long)720L, (long)28L}))));
    Debug.Assert(F((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(F((3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L}))));
    }

}
"
HumanEval_107,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ 1:     //palindrom số nguyên nằm trong phạm vi ((1, n), bao gồm.     //Cho một số nguyên dương n, trả về một tuple có số chẵn và lẻ     // >>> EvenOddPalindrome((3L))
    // (Tuple.Create(1L, 2L))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> EvenOddPalindrome((12L))
    // (Tuple.Create(4L, 6L))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    public static Tuple<long, long> EvenOddPalindrome(long n) {
","public static Tuple<long, long> EvenOddPalindrome(long n) {
    long evenCount = 0;
    long oddCount = 0;

    for (long i = 1; i <= n; i++) {
        if (IsPalindrome(i)) {
            if (i % 2 == 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return Tuple.Create(evenCount, oddCount);
}

private static bool IsPalindrome(long number) {
    long original = number;
    long reversed = 0;

    while (number > 0) {
        long digit = number % 10;
        reversed = reversed * 10 + digit;
        number /= 10;
    }

    return original == reversed;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddPalindrome((123L)).Equals((Tuple.Create(8L, 13L))));
    Debug.Assert(EvenOddPalindrome((12L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((3L)).Equals((Tuple.Create(1L, 2L))));
    Debug.Assert(EvenOddPalindrome((63L)).Equals((Tuple.Create(6L, 8L))));
    Debug.Assert(EvenOddPalindrome((25L)).Equals((Tuple.Create(5L, 6L))));
    Debug.Assert(EvenOddPalindrome((19L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((9L)).Equals((Tuple.Create(4L, 5L))));
    Debug.Assert(EvenOddPalindrome((1L)).Equals((Tuple.Create(0L, 1L))));
    }

}
"
HumanEval_108,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ: -123 có ký số -1, 2 và 3.    //Nếu một số là âm, thì chữ số đầu tiên được ký của nó sẽ là âm:     //số các phần tử có tổng số chữ số > 0.     //Viết hàm count_nums lấy danh sách các số nguyên và trả về     // >>> CountNums((new List<long>()))
    // (0L)
    // >>> CountNums((new List<long>(new long[]{(long)-1L, (long)11L, (long)-11L})))
    // (1L)
    // >>> CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L})))
    // (3L)
    public static long CountNums(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long CountNums(List<long> arr) {
        long count = 0;

        foreach (long number in arr) {
            long sumOfDigits = 0;
            long num = number;
            
            while (num != 0) {
                long digit = num % 10;
                sumOfDigits += digit;
                num /= 10;
            }

            if (sumOfDigits > 0) {
                count++;
            }
        }

        return count;
    }

    static void Main(string[] args) {
        // Test cases
        Console.WriteLine(CountNums(new List<long>())); // (0L)
        Console.WriteLine(CountNums(new List<long> { -1L, 11L, -11L })); // (1L)
        Console.WriteLine(CountNums(new List<long> { 1L, 1L, 2L })); // (3L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountNums((new List<long>())) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)-1L, (long)-2L, (long)0L}))) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L, (long)-2L, (long)3L, (long)4L, (long)5L}))) == (6L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)6L, (long)9L, (long)-6L, (long)0L, (long)1L, (long)5L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)100L, (long)98L, (long)-7L, (long)1L, (long)-1L}))) == (4L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)12L, (long)23L, (long)34L, (long)-45L, (long)-56L, (long)0L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L}))) == (1L));
    }

}
"
HumanEval_109,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Lưu ý: Danh sách được đưa ra được đảm bảo có các yếu tố duy nhất.    //Nếu danh sách được đưa ra là trống thì trả về true.     //then return true hoặc return false.    //Nếu có thể có được danh sách được sắp xếp bằng cách thực hiện hoạt động trên     //vị trí bắt đầu trong danh sách, tức là chỉ số 0th.    //Vị trí cuối cùng của danh sách sẽ được di chuyển đến     //Một thao tác di chuyển sang phải có nghĩa là di chuyển tất cả các phần tử của danh sách bằng một.    //Bạn được phép thực hiện chuyển đổi bên phải bất kỳ số lần nào.    //hoạt động sau đây trong danh sách được đưa ra:     //có thể sắp xếp một danh sách theo thứ tự không giảm bằng cách thực hiện     //Các số trong danh sách sẽ được sắp xếp ngẫu nhiên.    //Chúng ta có một danh sách 'arr' của N số nguyên arr[1], arr[2], ..., arr[N].    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L})))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L})))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    public static bool MoveOneBall(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool MoveOneBall(List<long> arr) {
        if (arr.Count == 0) return true;

        int n = arr.Count;
        int descentCount = 0;
        int indexOfDescent = -1;

        // Find number of descents in the array
        for (int i = 0; i < n; i++) {
            if (arr[i] > arr[(i + 1) % n]) {
                descentCount++;
                indexOfDescent = (i + 1) % n;
            }
            if (descentCount > 1) {
                return false;
            }
        }

        // No descents means the array is already sorted
        if (descentCount == 0) {
            return true;
        }

        // Check if the single descent allows a circular sorted order
        for (int i = 0; i < n; i++) {
            if (arr[(indexOfDescent + i) % n] > arr[(indexOfDescent + i + 1) % n]) {
                return false;
            }
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)10L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)4L, (long)3L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>())) == (true));
    }

}
"
HumanEval_110,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Nếu không, trả về ""Không"".    //tất cả các phần tử của lst1 là thậm chí, trả về ""YES"".     //Nếu có thể trao đổi các yếu tố giữa lst1 và lst2 để tạo ra     //Không có giới hạn về số lượng các yếu tố được trao đổi giữa lst1 và lst2.    //giữa chúng để làm lst1 một danh sách chỉ có số chẵn.    //và xác định liệu có thể thực hiện một sự trao đổi các yếu tố     //Trong vấn đề này, bạn sẽ thực hiện một hàm mà có hai danh sách các số,     // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (""YES"")
    // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L})))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    public static string Exchange(List<long> lst1, List<long> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string Exchange(List<long> lst1, List<long> lst2)
    {
        int countOfOddsInLst1 = lst1.Count(x => x % 2 != 0);
        int countOfEvensInLst2 = lst2.Count(x => x % 2 == 0);

        return countOfOddsInLst1 <= countOfEvensInLst2 ? ""YES"" : ""NO"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)2L, (long)1L, (long)4L, (long)3L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)3L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)3L, (long)2L, (long)6L, (long)1L, (long)8L, (long)9L})), (new List<long>(new long[]{(long)3L, (long)5L, (long)5L, (long)1L, (long)1L, (long)1L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)100L, (long)200L})), (new List<long>(new long[]{(long)200L, (long)200L}))).Equals((""YES"")));
    }

}
"
HumanEval_111,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Nếu một số chữ cái có cùng một sự xuất hiện, hãy trả lại tất cả chúng.    //của chữ cái với nhiều lần lặp lại nhất và chứa số tương ứng.     //Với một chuỗi đại diện cho một chữ cái nhỏ tách biệt không gian, trả về một từ điển     // >>> Histogram((""a b c""))
    // (new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}})
    // >>> Histogram((""a b b a""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""a b c a b""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""b b b b a""))
    // (new Dictionary<string,long>(){{""b"", 4L}})
    // >>> Histogram((""""))
    // (new Dictionary<string,long>())
    public static Dictionary<string,long> Histogram(string test) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Dictionary<string, long> Histogram(string test) {
        if (string.IsNullOrWhiteSpace(test)) {
            return new Dictionary<string, long>();
        }

        var words = test.Split(' ');
        var letterCounts = new Dictionary<string, long>();

        // Count the occurrences of each letter
        foreach (var word in words) {
            if (letterCounts.ContainsKey(word)) {
                letterCounts[word]++;
            } else {
                letterCounts[word] = 1;
            }
        }

        // Determine the maximum count
        long maxCount = letterCounts.Values.Max();

        // Create a dictionary for letters with the maximum count
        var result = letterCounts.Where(pair => pair.Value == maxCount)
                                 .ToDictionary(pair => pair.Key, pair => pair.Value);

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Histogram((""a b b a"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c a b"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c d g"")).Equals((new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}, {""d"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""b b b b a"")).Equals((new Dictionary<string,long>(){{""b"", 4L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram(("""")).Equals((new Dictionary<string,long>())));
    Debug.Assert(Histogram((""a"")).Equals((new Dictionary<string,long>(){{""a"", 1L}})));
    }

}
"
HumanEval_112,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //Bạn nên trả về một tuple chứa chuỗi kết quả và true/false cho kiểm tra.    //Một chuỗi được gọi là palindrome nếu nó đọc ngược cùng với phía trước.    //sau đó kiểm tra xem chuỗi kết quả có phải là palindrome hay không.    //Chúng ta được cung cấp hai chuỗi s và c, bạn phải xóa tất cả các ký tự trong s bằng bất kỳ ký tự trong c     //Nhiệm vụ     // >>> ReverseDelete((""abcde""), (""ae""))
    // (Tuple.Create(""bcd"", false))
    // >>> ReverseDelete((""abcdef""), (""b""))
    // (Tuple.Create(""acdef"", false))
    // >>> ReverseDelete((""abcdedcba""), (""ab""))
    // (Tuple.Create(""cdedc"", true))
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
","using System;
using System.Linq;

class Problem {
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
        // Remove characters from 's' that are in 'c'
        string resultString = new string(s.Where(ch => !c.Contains(ch)).ToArray());
        
        // Check if the result string is a palindrome
        bool isPalindrome = resultString.SequenceEqual(resultString.Reverse());

        // Return the result string and palindrome check as a tuple
        return Tuple.Create(resultString, isPalindrome);
    }

    // Example usage
    static void Main(string[] args) {
        var example1 = ReverseDelete(""abcde"", ""ae"");
        Console.WriteLine($""(\""bcd\"", false) == ({example1.Item1}, {example1.Item2})"");

        var example2 = ReverseDelete(""abcdef"", ""b"");
        Console.WriteLine($""(\""acdef\"", false) == ({example2.Item1}, {example2.Item2})"");

        var example3 = ReverseDelete(""abcdedcba"", ""ab"");
        Console.WriteLine($""(\""cdedc\"", true) == ({example3.Item1}, {example3.Item2})"");
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ReverseDelete((""abcde""), (""ae"")).Equals((Tuple.Create(""bcd"", false))));
    Debug.Assert(ReverseDelete((""abcdef""), (""b"")).Equals((Tuple.Create(""acdef"", false))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""ab"")).Equals((Tuple.Create(""cdedc"", true))));
    Debug.Assert(ReverseDelete((""dwik""), (""w"")).Equals((Tuple.Create(""dik"", false))));
    Debug.Assert(ReverseDelete((""a""), (""a"")).Equals((Tuple.Create("""", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), ("""")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""v"")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""vabba""), (""v"")).Equals((Tuple.Create(""abba"", true))));
    Debug.Assert(ReverseDelete((""mamma""), (""mia"")).Equals((Tuple.Create("""", true))));
    }

}
"
HumanEval_113,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //của các chữ số lẻ trong chuỗi i'th của đầu vào.     //string i của đầu vào. "" nơi tất cả các i nên được thay thế bằng số     //Mỗi phần tử i của đầu ra phải là số phần tử lẻ trong     //Cho một danh sách các chuỗi, trong đó mỗi chuỗi chỉ bao gồm các chữ số, trả về một danh sách.    // >>> OddCount((new List<string>(new string[]{(string)""1234567""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))
    // >>> OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))
    public static List<string> OddCount(List<string> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> OddCount(List<string> lst)
    {
        List<string> result = new List<string>();
        foreach (var str in lst)
        {
            int oddCount = 0;
            foreach (var c in str)
            {
                if ((c - '0') % 2 != 0) // Check if the digit is odd
                {
                    oddCount++;
                }
            }

            string output = $""the number of odd elements {oddCount}n the str{oddCount}ng {oddCount} of the {oddCount}nput."";
            result.Add(output);
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""1234567""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""271"", (string)""137"", (string)""314""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (string)""the number of odd elements 2n the str2ng 2 of the 2nput.""}))));
    }

}
"
HumanEval_114,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //của nums.     //Cho một danh sách các số nguyên, tìm tổng tối thiểu của bất kỳ danh sách con không rỗng nào     // >>> Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L})))
    // (1L)
    // >>> Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L})))
    // (-6L)
    public static long Minsubarraysum(List<long> nums) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Minsubarraysum(List<long> nums) {
        long minSum = nums[0], currentSum = nums[0];
        
        for (int i = 1; i < nums.Count; i++) {
            currentSum = Math.Min(nums[i], currentSum + nums[i]);
            minSum = Math.Min(minSum, currentSum);
        }
        
        return minSum;
    }

    // Example usage
    public static void Main() {
        Console.WriteLine(Minsubarraysum(new List<long> { 2L, 3L, 4L, 1L, 2L, 4L })); // Output: 1L
        Console.WriteLine(Minsubarraysum(new List<long> { -1L, -2L, -3L }));         // Output: -6L
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L}))) == (1L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)2L, (long)-10L}))) == (-14L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-9999999999999999L}))) == (-9999999999999999L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)0L, (long)10L, (long)20L, (long)1000000L}))) == (0L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)10L, (long)11L, (long)13L, (long)8L, (long)3L, (long)4L}))) == (3L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-33L, (long)32L, (long)-1L, (long)0L, (long)-2L}))) == (-33L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-10L}))) == (-10L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)7L}))) == (7L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)1L, (long)-1L}))) == (-1L));
    }

}
"
HumanEval_115,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ 1:     //Xuất số lần bạn cần để hạ các thùng.    //Nhiệm vụ của các bạn là sử dụng các thùng để làm trống giếng.    //và tất cả các thùng có cùng dung lượng.    //Mỗi giếng có một cái xô tương ứng có thể được sử dụng để lấy nước từ nó,    //và mỗi 1 trong một hàng đại diện cho một đơn vị nước.    //Bạn được đưa ra một lưới hình chữ nhật của giếng. Mỗi hàng đại diện cho một giếng duy nhất,     // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L))
    // (6L)
    // Example 2:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L))
    // (5L)
    // Example 3:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L))
    // (0L)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    public static long MaxFill(List<List<long>> grid, long capacity) {
","public static long MaxFill(List<List<long>> grid, long capacity) {
    long operations = 0;

    foreach (var row in grid) {
        long waterUnits = row.Sum();
        operations += waterUnits / capacity;
        if (waterUnits % capacity != 0) {
            operations++;
        }
    }

    return operations;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L)) == (6L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L)) == (5L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L)) == (0L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (2L)) == (4L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (9L)) == (2L));
    }

}
"
HumanEval_116,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Nó phải được thực hiện như sau:    //Đối với số lượng tương tự của số một, sắp xếp dựa trên giá trị thập phân.    //số lượng một trong đại diện nhị phân của họ theo thứ tự tăng dần.    //Trong Kata này, bạn phải sắp xếp một danh sách các số nguyên không âm theo     // >>> SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))
    // (new List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))
    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))
    public static List<long> SortArray(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> SortArray(List<long> arr) {
        return arr.OrderBy(num => CountOnesInBinary(num))
                  .ThenBy(num => num)
                  .ToList();
    }

    private static int CountOnesInBinary(long num) {
        return Convert.ToString(num, 2).Count(c => c == '1');
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    }

}
"
HumanEval_117,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Lưu ý: bạn có thể giả định chuỗi đầu vào chỉ chứa các chữ cái và khoảng trống.    //Nếu chuỗi s là trống thì hàm sẽ trả về một danh sách trống.     //n phụ âm, theo thứ tự những từ này xuất hiện trong chuỗi s.     //một hàm trả về danh sách tất cả các từ từ chuỗi s có chứa chính xác     //Với một chuỗi s và một số tự nhiên n, bạn đã được giao nhiệm vụ thực hiện     // >>> SelectWords((""Mary had a little lamb""), (4L))
    // (new List<string>(new string[]{(string)""little""}))
    // >>> SelectWords((""Mary had a little lamb""), (3L))
    // (new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))
    // >>> SelectWords((""simple white space""), (2L))
    // (new List<string>())
    // >>> SelectWords((""Hello world""), (4L))
    // (new List<string>(new string[]{(string)""world""}))
    // >>> SelectWords((""Uncle sam""), (3L))
    // (new List<string>(new string[]{(string)""Uncle""}))
    public static List<string> SelectWords(string s, long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> SelectWords(string s, long n) {
        List<string> result = new List<string>();
        if (string.IsNullOrEmpty(s)) 
            return result;

        string[] words = s.Split(' ');
        string consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";

        foreach (string word in words) {
            int consonantCount = 0;
            foreach (char c in word) {
                if (consonants.Contains(c)) {
                    consonantCount++;
                }
            }

            if (consonantCount == n) {
                result.Add(word);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SelectWords((""Mary had a little lamb""), (4L)).Equals((new List<string>(new string[]{(string)""little""}))));
    Debug.Assert(SelectWords((""Mary had a little lamb""), (3L)).Equals((new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))));
    Debug.Assert(SelectWords((""simple white space""), (2L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""Hello world""), (4L)).Equals((new List<string>(new string[]{(string)""world""}))));
    Debug.Assert(SelectWords((""Uncle sam""), (3L)).Equals((new List<string>(new string[]{(string)""Uncle""}))));
    Debug.Assert(SelectWords((""""), (4L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""a b c d e f""), (1L)).Equals((new List<string>(new string[]{(string)""b"", (string)""c"", (string)""d"", (string)""f""}))));
    }

}
"
HumanEval_118,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Bạn có thể giả định rằng chuỗi được đưa ra chỉ chứa chữ cái tiếng Anh.    //tìm bất kỳ nguyên âm nào đáp ứng điều kiện trên.    //Các nguyên âm ở đầu và cuối không được tính. Trả về chuỗi trống nếu bạn không có.    //hai phụ âm từ bên phải của từ (có tính nhạy cảm).    //Bạn được cho một từ. Nhiệm vụ của bạn là tìm ra nguyên âm gần nhất nằm giữa     // >>> GetClosestVowel((""yogurt""))
    // (""u"")
    // >>> GetClosestVowel((""FULL""))
    // (""U"")
    // >>> GetClosestVowel((""quick""))
    // ("""")
    // >>> GetClosestVowel((""ab""))
    // ("""")
    public static string GetClosestVowel(string word) {
","using System;

class Problem {
    public static string GetClosestVowel(string word) {
        if (string.IsNullOrWhiteSpace(word) || word.Length < 3) {
            return """";
        }
        
        HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        
        for (int i = word.Length - 2; i > 0; i--) {
            if (vowels.Contains(word[i]) && 
                !vowels.Contains(word[i - 1]) && !vowels.Contains(word[i + 1])) {
                return word[i].ToString();
            }
        }
        return """";
    }

    static void Main(string[] args) {
        Console.WriteLine(GetClosestVowel(""yogurt"")); // Output: ""u""
        Console.WriteLine(GetClosestVowel(""FULL""));   // Output: ""U""
        Console.WriteLine(GetClosestVowel(""quick""));  // Output: """"
        Console.WriteLine(GetClosestVowel(""ab""));     // Output: """"
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetClosestVowel((""yogurt"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""full"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""easy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""eAsy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ali"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""bad"")).Equals((""a"")));
    Debug.Assert(GetClosestVowel((""most"")).Equals((""o"")));
    Debug.Assert(GetClosestVowel((""ab"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ba"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""quick"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""anime"")).Equals((""i"")));
    Debug.Assert(GetClosestVowel((""Asia"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""Above"")).Equals((""o"")));
    }

}
"
HumanEval_119,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Trả về 'Vâng' nếu có một cách để tạo một chuỗi tốt, và trả về 'Không' nếu không.    //""()) "" không phải là.    //được cân bằng. Ví dụ: chuỗi '(())))' là tốt, trong khi chuỗi     //Một chuỗi S được coi là tốt nếu và chỉ khi tất cả các dấu ngoặc trong S     //một số thứ tự, rằng chuỗi kết quả sẽ là tốt.    //Công việc của bạn là kiểm tra xem có thể kết nối hai chuỗi vào trong không.    //chỉ có dấu ngoặc ' ((' hoặc dấu ngoặc gần ') '.    //Bạn được đưa ra một danh sách hai chuỗi, cả hai chuỗi bao gồm mở     // >>> MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""})))
    // (""Yes"")
    // >>> MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""})))
    // (""No"")
    public static string MatchParens(List<string> lst) {
","public static string MatchParens(List<string> lst) {
        if (lst.Count != 2) return ""No"";

        string str1 = lst[0];
        string str2 = lst[1];

        // Check both possible concatenations
        if (IsValidParentheses(str1 + str2) || IsValidParentheses(str2 + str1))
            return ""Yes"";
        
        return ""No"";
    }

    private static bool IsValidParentheses(string s) {
        int balance = 0;
        foreach (char c in s) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false; // More closing parens than opening
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()(())"", (string)""())())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")())"", (string)""(()()(""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(())))"", (string)""(()())((""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()"", (string)""())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()("", (string)""()))()""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(((("", (string)""((())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")(()"", (string)""(()(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")("", (string)"")(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)""(""}))).Equals((""Yes"")));
    }

}
"
HumanEval_120,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ 1:     //của chiều dài k với số k tối đa trong arr.     //Cho một danh sách arr của số nguyên và một số nguyên dương k, trả về một danh sách được sắp xếp     // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L))
    // (new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))
    // Example 2:
    // >>> Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L))
    // (new List<long>(new long[]{(long)4L, (long)4L}))
    // Example 3:
    // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))
    // (new List<long>(new long[]{(long)2L}))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    public static List<long> Maximum(List<long> arr, long k) {
","public static List<long> Maximum(List<long> arr, long k) {
    return arr.OrderByDescending(n => n).Take((int)k).OrderBy(n => n).ToList();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L)).Equals((new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L)).Equals((new List<long>(new long[]{(long)4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)123L, (long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (3L)).Equals((new List<long>(new long[]{(long)2L, (long)20L, (long)123L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (4L)).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)20L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)5L, (long)15L, (long)0L, (long)3L, (long)-13L, (long)-8L, (long)0L})), (7L)).Equals((new List<long>(new long[]{(long)-13L, (long)-8L, (long)0L, (long)0L, (long)3L, (long)5L, (long)15L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-1L, (long)0L, (long)2L, (long)5L, (long)3L, (long)-10L})), (2L)).Equals((new List<long>(new long[]{(long)3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)0L, (long)5L, (long)-7L})), (1L)).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L})), (2L)).Equals((new List<long>(new long[]{(long)-4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-10L, (long)10L})), (2L)).Equals((new List<long>(new long[]{(long)-10L, (long)10L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)-23L, (long)243L, (long)-400L, (long)0L})), (0L)).Equals((new List<long>())));
    }

}
"
HumanEval_121,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //Cho một danh sách không trống của số nguyên, trả về tổng của tất cả các yếu tố lẻ mà là ở vị trí chẵn.     // >>> Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L})))
    // (12L)
    // >>> Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L})))
    // (9L)
    // >>> Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L})))
    // (0L)
    public static long Solution(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Solution(List<long> lst) {
        long sum = 0;
        for (int i = 0; i < lst.Count; i += 2) { // Iterate over even indices
            if (lst[i] % 2 != 0) { // Check if the element is odd
                sum += lst[i];
            }
        }
        return sum;
    }
    
    static void Main() {
        Console.WriteLine(Solution(new List<long>{5L, 8L, 7L, 1L})); // Output: 12
        Console.WriteLine(Solution(new List<long>{3L, 3L, 3L, 3L, 3L})); // Output: 9
        Console.WriteLine(Solution(new List<long>{30L, 13L, 24L, 321L})); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L}))) == (12L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L}))) == (9L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)9L}))) == (5L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)2L, (long)4L, (long)8L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)23L, (long)32L}))) == (23L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)13L, (long)2L, (long)9L}))) == (3L));
    }

}
"
HumanEval_122,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //tổng các phần tử có tối đa hai chữ số từ k phần tử đầu tiên của arr.     //Với một danh sách không rỗng của các số nguyên arr và một số nguyên k, trả về     // >>> AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L))
    // (24L)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    public static long AddElements(List<long> arr, long k) {
","public static long AddElements(List<long> arr, long k) {
        long sum = 0;
        for (int i = 0; i < k; i++) {
            if (arr[i] >= -99 && arr[i] <= 99) {
                sum += arr[i];
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L, (long)-2L, (long)-3L, (long)41L, (long)57L, (long)76L, (long)87L, (long)88L, (long)99L})), (3L)) == (-4L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)121L, (long)3L, (long)4000L, (long)5L, (long)6L})), (2L)) == (0L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)11L, (long)21L, (long)3L, (long)90L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (125L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (24L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L})), (1L)) == (1L));
    }

}
"
HumanEval_123,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //get_odd_collatz(5) trả về [1, 5] # Dòng collatz cho 5 là [5, 16, 8, 4, 2, 1], vì vậy các số lẻ chỉ là 1, và 5.     //Ví dụ:     //2. danh sách trả về được sắp xếp theo thứ tự tăng dần.    //1. Collatz(1) là [1].     //Lưu ý:    //thuật ngữ cộng với 1. Giả thuyết là bất kể giá trị của n là gì, chuỗi sẽ luôn đạt đến 1.     //Nếu thuật ngữ trước là lẻ, thuật ngữ tiếp theo là 3 lần trước     //thuật ngữ trước như sau: nếu thuật ngữ trước là chẵn, thuật ngữ tiếp theo là một nửa của     //như sau: bắt đầu với bất kỳ số nguyên dương n. Sau đó mỗi thuật ngữ được lấy từ     //Giả thuyết Collatz là một giả thuyết trong toán học liên quan đến một chuỗi được xác định.    //Với một số nguyên dương n, trả về một danh sách được sắp xếp có các số lẻ trong trình tự collatz.     // >>> GetOddCollatz((5L))
    // (new List<long>(new long[]{(long)1L, (long)5L}))
    public static List<long> GetOddCollatz(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetOddCollatz(long n)
    {
        HashSet<long> oddNumbers = new HashSet<long>();

        while (n != 1)
        {
            if (n % 2 != 0)
            {
                oddNumbers.Add(n);
            }

            if (n % 2 == 0)
            {
                n /= 2;
            }
            else
            {
                n = 3 * n + 1;
            }
        }

        oddNumbers.Add(1); // Add 1 to the set as per problem statement

        List<long> result = new List<long>(oddNumbers);
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetOddCollatz((14L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(GetOddCollatz((5L)).Equals((new List<long>(new long[]{(long)1L, (long)5L}))));
    Debug.Assert(GetOddCollatz((12L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)5L}))));
    Debug.Assert(GetOddCollatz((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    }

}
"
HumanEval_124,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ngày nên được trong định dạng: mm-dd-yyyy     //3. Số tháng không nên ít hơn 1 hoặc cao hơn 12.    //Số ngày không ít hơn 1 hoặc cao hơn 31 ngày cho tháng 1,3,5,7,8,10,12. Và số ngày không ít hơn 1 hoặc cao hơn 30 ngày cho tháng 4,6,9,11. Và, số ngày không ít hơn 1 hoặc cao hơn 29 cho tháng 2.    //1. Dãy ngày không trống.    //Ngày này có giá trị nếu tất cả các quy tắc sau đây được đáp ứng:     //trả về true nếu ngày là hợp lệ nếu không thì false.     //Bạn phải viết một hàm xác nhận một chuỗi ngày đã cho và     // >>> ValidDate((""03-11-2000""))
    // (true)
    // >>> ValidDate((""15-01-2012""))
    // (false)
    // >>> ValidDate((""04-0-2040""))
    // (false)
    // >>> ValidDate((""06-04-2020""))
    // (true)
    // >>> ValidDate((""06/04/2020""))
    // (false)
    public static bool ValidDate(string date) {
","public static bool ValidDate(string date)
{
    if (string.IsNullOrEmpty(date) || date.Length != 10) return false;

    string[] dateParts = date.Split('-');
    if (dateParts.Length != 3) return false;

    if (!int.TryParse(dateParts[0], out int month) || !int.TryParse(dateParts[1], out int day) || !int.TryParse(dateParts[2], out int year))
    {
        return false;
    }

    if (month < 1 || month > 12) return false;

    if (year < 1) return false;

    bool isValidDay = false;

    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day >= 1 && day <= 31)
    {
        isValidDay = true;
    }
    else if ((month == 4 || month == 6 || month == 9 || month == 11) && day >= 1 && day <= 30)
    {
        isValidDay = true;
    }
    else if (month == 2 && day >= 1 && day <= 29)
    {
        isValidDay = true;
    }

    return isValidDay;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ValidDate((""03-11-2000"")) == (true));
    Debug.Assert(ValidDate((""15-01-2012"")) == (false));
    Debug.Assert(ValidDate((""04-0-2040"")) == (false));
    Debug.Assert(ValidDate((""06-04-2020"")) == (true));
    Debug.Assert(ValidDate((""01-01-2007"")) == (true));
    Debug.Assert(ValidDate((""03-32-2011"")) == (false));
    Debug.Assert(ValidDate(("""")) == (false));
    Debug.Assert(ValidDate((""04-31-3000"")) == (false));
    Debug.Assert(ValidDate((""06-06-2005"")) == (true));
    Debug.Assert(ValidDate((""21-31-2000"")) == (false));
    Debug.Assert(ValidDate((""04-12-2003"")) == (true));
    Debug.Assert(ValidDate((""04122003"")) == (false));
    Debug.Assert(ValidDate((""20030412"")) == (false));
    Debug.Assert(ValidDate((""2003-04"")) == (false));
    Debug.Assert(ValidDate((""2003-04-12"")) == (false));
    Debug.Assert(ValidDate((""04-2003"")) == (false));
    }

}
"
HumanEval_126,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //số, trả về false. Giả sử không có số âm và chỉ số nguyên.    //Nếu danh sách có nhiều hơn 1 bản sao của cùng một    //Cho một danh sách các số, trả về cho dù chúng được sắp xếp hay không.    // >>> IsSorted((new List<long>(new long[]{(long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L})))
    // (false)
    public static bool IsSorted(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static bool IsSorted(List<long> lst) {
        if (lst.Count == 0) return true;

        // To store the occurrence of each number
        var occurrences = new Dictionary<long, int>();

        for (int i = 0; i < lst.Count - 1; i++) {
            // Check if the current number is greater than the next number
            if (lst[i] > lst[i + 1]) {
                return false;
            }

            // Count the occurrences of each number
            if (occurrences.ContainsKey(lst[i])) {
                occurrences[lst[i]]++;
            } else {
                occurrences[lst[i]] = 1;
            }

            // If any number occurs more than twice
            if (occurrences[lst[i]] > 2) {
                return false;
            }
        }

        // Check the last element in the list for more than two occurrences
        if (occurrences.ContainsKey(lst[lst.Count - 1])) {
            occurrences[lst[lst.Count - 1]]++;
            if (occurrences[lst[lst.Count - 1]] > 2) {
                return false;
            }
        } else {
            occurrences[lst[lst.Count - 1]] = 1;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (false));
    Debug.Assert(IsSorted((new List<long>())) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))) == (true));
    }

}
"
HumanEval_127,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //[input/output] mẫu:     //Nếu hai khoảng không giao nhau, trả về ""NO"".    //Nếu không, trả về ""NO"".    //Nếu chiều dài của giao điểm là một số nguyên tố, trả về ""YES"",     //mà chiều dài của nó là 1, mà không phải là một số nguyên tố.    //Ví dụ, điểm cắt của các khoảng (1, 3), (2, 4) là (2, 3)     //khoảng là một số nguyên tố.    //Nhiệm vụ của bạn là xác định xem chiều dài của giao điểm của hai     //Đối với mỗi khoảng thời gian nhất định, giả định rằng khởi đầu của nó nhỏ hơn hoặc bằng cuối của nó.    //bao gồm cả bắt đầu và kết thúc.    //Các khoảng thời gian được đưa ra là đóng, có nghĩa là khoảng thời gian (bắt đầu, kết thúc)     //trong đó mỗi khoảng là một cặp số nguyên. Ví dụ, khoảng = (bắt đầu, kết thúc) = (1, 2).    //Bạn được cho hai khoảng thời gian,     // >>> Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L)))
    // (""YES"")
    public static string Intersection(Tuple<long, long> interval1, Tuple<long, long> interval2) {
","long start1 = interval1.Item1;
    long end1 = interval1.Item2;
    long start2 = interval2.Item1;
    long end2 = interval2.Item2;

    long intersectStart = Math.Max(start1, start2);
    long intersectEnd = Math.Min(end1, end2);

    if (intersectStart > intersectEnd) {
        return ""NO"";
    }

    long intersectionLength = intersectEnd - intersectStart + 1;

    if (IsPrime(intersectionLength)) {
        return ""YES"";
    } else {
        return ""NO"";
    }
}

private static bool IsPrime(long number) {
    if (number < 2) return false;
    if (number == 2) return true;
    if (number % 2 == 0) return false;

    long boundary = (long)Math.Floor(Math.Sqrt(number));

    for (long i = 3; i <= boundary; i += 2) {
        if (number % i == 0) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, 2L)), (Tuple.Create(-4L, 0L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-11L, 2L)), (Tuple.Create(-1L, -1L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(3L, 5L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(1L, 2L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, -2L)), (Tuple.Create(-3L, -2L))).Equals((""NO"")));
    }

}
"
HumanEval_128,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Lưu ý: trả về null cho arr trống.     //của mỗi số trong danh sách, được biểu thị bằng 1, -1 hoặc 0.     //Tổng số lượng của các số nguyên nhân nhân với sản phẩm của tất cả các dấu hiệu     //Bạn được đưa ra một danh sách arr của số nguyên và bạn cần phải trở lại.    // >>> ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L})))
    // 9L
    // >>> ProdSigns((new List<long>(new long[]{(long)0L, (long)1L})))
    // 0L
    // >>> ProdSigns((new List<long>()))
    // null
    public static Nullable<long> ProdSigns(List<long> arr) {
","public static Nullable<long> ProdSigns(List<long> arr) {
        if (arr == null || arr.Count == 0) return null;

        long sumOfMagnitudes = 0;
        long productOfSigns = 1;

        foreach (var num in arr) {
            sumOfMagnitudes += Math.Abs(num);

            if (num > 0) {
                productOfSigns *= 1;
            } else if (num < 0) {
                productOfSigns *= -1;
            } else {
                productOfSigns = 0;
                break;
            }
        }

        return sumOfMagnitudes * productOfSigns;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L}))).Equals(-9L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)0L, (long)1L}))).Equals(0L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)2L, (long)3L, (long)-1L, (long)1L}))).Equals(-10L));
    Debug.Assert(ProdSigns((new List<long>())).Equals(null));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)2L, (long)-1L, (long)-1L, (long)9L}))).Equals(20L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)-1L, (long)1L}))).Equals(4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)1L}))).Equals(-4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)0L}))).Equals(0L));
    }

}
"
HumanEval_129,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Trả về một danh sách thứ tự các giá trị trên các ô mà đường dẫn tối thiểu đi qua.     //Nó được đảm bảo rằng câu trả lời là duy nhất.    //lst_A[j] = lst_B[j].    //như lst_A[i] < lst_B[i] và cho bất kỳ j (1 <= j < i) chúng ta có     //hơn lst_B, nói cách khác, có tồn tại một chỉ số số nguyên i (1 <= i <= k)     //thông qua (chúng ta hãy gọi chúng là lst_A và lst_B), lst_A là ít hơn về mặt từ điển     //sau khi làm các danh sách được sắp xếp của các giá trị trên các ô mà A và B đi     //Một đường A (dài k) được coi là nhỏ hơn đường B (dài k) nếu     //Bạn không thể đi ra khỏi mạng lưới.    //nhất thiết phải khác nhau).    //Xin lưu ý rằng một đường dẫn có chiều dài k có nghĩa là truy cập chính xác k ô (không phải     //    //Nói cách khác, bạn có thể đi đến các tế bào mà chia sẻ một cạnh với bạn hiện tại     //từ bất kỳ tế bào, và trong mỗi bước bạn có thể di chuyển đến bất kỳ của các tế bào hàng xóm,     //Bạn phải tìm đường đi tối thiểu của chiều dài k trong lưới. Bạn có thể bắt đầu.    //inclusive xuất hiện chính xác một lần trên các ô của lưới.     //mỗi ô của lưới chứa một giá trị. Mỗi số nguyên trong phạm vi [1, N * N]     //Với một lưới với N hàng và N cột (N >= 2) và một số nguyên dương k,     // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))
    // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L))
    // (new List<long>(new long[]{(long)1L}))
    public static List<long> Minpath(List<List<long>> grid, long k) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Minpath(List<List<long>> grid, long k) {
        int n = grid.Count;
        List<long> result = new List<long>();
        long[,] dp = new long[n, n];
        (int, int)[,] parent = new (int, int)[n, n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = long.MaxValue;
            }
        }

        var directions = new List<(int, int)>() { (0, 1), (1, 0), (0, -1), (-1, 0) };
        SortedSet<(long, int, int)> pq = new SortedSet<(long, int, int)>((a, b) => a.Item1 == b.Item1 ? (a.Item2 == b.Item2 ? a.Item3.CompareTo(b.Item3) : a.Item2.CompareTo(b.Item2)) : a.Item1.CompareTo(b.Item1));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = grid[i][j];
                pq.Add((grid[i][j], i, j));
            }
        }

        while (pq.Count > 0) {
            var curr = pq.Min;
            pq.Remove(curr);
            long currValue = curr.Item1;
            int x = curr.Item2;
            int y = curr.Item3;

            foreach (var dir in directions) {
                int newX = x + dir.Item1;
                int newY = y + dir.Item2;
                if (newX >= 0 && newX < n && newY >= 0 && newY < n) {
                    long newCost = currValue + grid[newX][newY];
                    if (dp[newX, newY] > newCost) {
                        if (dp[newX, newY] != long.MaxValue) {
                            pq.Remove((dp[newX, newY], newX, newY));
                        }
                        dp[newX, newY] = newCost;
                        parent[newX, newY] = (x, y);
                        pq.Add((dp[newX, newY], newX, newY));
                    }
                }
            }
        }

        (int, int) end = (0, 0);
        long minPathSum = long.MaxValue;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (minPathSum > dp[i, j]) {
                    minPathSum = dp[i, j];
                    end = (i, j);
                }
            }
        }

        Stack<long> pathStack = new Stack<long>();
        (int, int) node = end;
        for (int step = 0; step < k; step++) {
            pathStack.Push(grid[node.Item1][node.Item2]);
            node = parent[node.Item1, node.Item2];
        }

        while (pathStack.Count > 0) {
            result.Add(pathStack.Pop());
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L}), (List<long>)new List<long>(new long[]{(long)9L, (long)10L, (long)11L, (long)12L}), (List<long>)new List<long>(new long[]{(long)13L, (long)14L, (long)15L, (long)16L})})), (4L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)10L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)12L, (long)1L}), (List<long>)new List<long>(new long[]{(long)3L, (long)16L, (long)11L, (long)15L}), (List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L})})), (7L)).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)1L, (long)10L, (long)1L, (long)10L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L}), (List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)15L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)12L}), (List<long>)new List<long>(new long[]{(long)3L, (long)10L, (long)11L, (long)16L})})), (5L)).Equals((new List<long>(new long[]{(long)1L, (long)7L, (long)1L, (long)7L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L})})), (9L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L})})), (12L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)6L, (long)8L, (long)9L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)3L, (long)8L, (long)9L}), (List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)3L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    }

}
"
HumanEval_130,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //n + 1 số đầu tiên của chuỗi Tribonacci.    //Bạn được cho một số nguyên không âm n, bạn phải trả về một danh sách các     //= 2 + 3 + 3 = 8     //tri(3) = tri(2) + tri(1) + tri(4)     //tri(4) = 3     //tri(2) = 1 + (2 / 2) = 2     //Ví dụ:     //tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), nếu n là lẻ.     //tri (n) = 1 + n / 2, nếu n là chẵn.     //tri(1) = 3     //Dòng dõi Tribonacci được xác định bởi sự tái phát:     //Tuy nhiên, những gì mọi người không biết là trình tự Tribonacci.    //Mọi người đều biết chuỗi Fibonacci, nó đã được nghiên cứu sâu sắc bởi các nhà toán học trong     // >>> Tri((3L))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))
    public static List<long> Tri(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Tri(long n)
    {
        List<long> tribonacci = new List<long>(new long[n + 1]);

        for (long i = 0; i <= n; i++)
        {
            if (i == 0)
                tribonacci[(int)i] = 1;
            else if (i == 1)
                tribonacci[(int)i] = 3;
            else if (i % 2 == 0)
                tribonacci[(int)i] = 1 + i / 2;
            else
                tribonacci[(int)i] = tribonacci[(int)(i - 1)] + tribonacci[(int)(i - 2)] + tribonacci[(int)(i + 1)];
        }
        
        return tribonacci;
    }
    
    static void Main(string[] args)
    {
        // Example usage:
        Console.WriteLine(string.Join("", "", Tri(3)));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Tri((3L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))));
    Debug.Assert(Tri((4L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L}))));
    Debug.Assert(Tri((5L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L}))));
    Debug.Assert(Tri((6L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L}))));
    Debug.Assert(Tri((7L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L}))));
    Debug.Assert(Tri((8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L}))));
    Debug.Assert(Tri((9L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L}))));
    Debug.Assert(Tri((20L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L, (long)6L, (long)48L, (long)7L, (long)63L, (long)8L, (long)80L, (long)9L, (long)99L, (long)10L, (long)120L, (long)11L}))));
    Debug.Assert(Tri((0L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Tri((1L)).Equals((new List<long>(new long[]{(long)1L, (long)3L}))));
    }

}
"
HumanEval_131,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Trả về 0 nếu tất cả các chữ số là chẵn.     //Cho một số nguyên dương n, trả về sản phẩm của các chữ số lẻ.     // >>> Digits((1L))
    // (1L)
    // >>> Digits((4L))
    // (0L)
    // >>> Digits((235L))
    // (15L)
    public static long Digits(long n) {
","using System;

class Problem {
    public static long Digits(long n) {
        long product = 1;
        bool hasOdd = false;

        while (n > 0) {
            long digit = n % 10;
            if (digit % 2 != 0) {
                product *= digit;
                hasOdd = true;
            }
            n /= 10;
        }

        return hasOdd ? product : 0;
    }

    static void Main(string[] args) {
        Console.WriteLine(Digits(1L));    // Output: 1
        Console.WriteLine(Digits(4L));    // Output: 0
        Console.WriteLine(Digits(235L));  // Output: 15
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digits((5L)) == (5L));
    Debug.Assert(Digits((54L)) == (5L));
    Debug.Assert(Digits((120L)) == (1L));
    Debug.Assert(Digits((5014L)) == (5L));
    Debug.Assert(Digits((98765L)) == (315L));
    Debug.Assert(Digits((5576543L)) == (2625L));
    Debug.Assert(Digits((2468L)) == (0L));
    }

}
"
HumanEval_132,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //trong đó ít nhất một bracket trong chuỗi con được lồng.    //Hàm sẽ trả về true nếu và chỉ khi có một chuỗi phụ hợp lệ của các dấu ngoặc     //Tạo một hàm lấy một chuỗi như đầu vào chỉ chứa các dấu ngoặc vuông.     // >>> IsNested((""[[]]""))
    // (true)
    // >>> IsNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> IsNested((""[][]""))
    // (false)
    // >>> IsNested((""[]""))
    // (false)
    // >>> IsNested((""[[][]]""))
    // (true)
    // >>> IsNested((""[[]][[""))
    // (true)
    public static bool IsNested(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsNested(string str) {
        Stack<char> stack = new Stack<char>();
        bool hasNested = false;
        
        foreach (char ch in str) {
            if (ch == '[') {
                stack.Push(ch);
            } else if (ch == ']') {
                if (stack.Count > 0) {
                    stack.Pop();
                    hasNested = true;
                } else {
                    return false; // More closing brackets than opening
                }
            }

            // Check for nesting
            if (stack.Count > 1) {
                hasNested = true;
            }
        }
        
        return stack.Count == 0 && hasNested;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsNested((""[[]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]][[[[[]"")) == (false));
    Debug.Assert(IsNested((""[][]"")) == (false));
    Debug.Assert(IsNested((""[]"")) == (false));
    Debug.Assert(IsNested((""[[[[]]]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]]]]]"")) == (false));
    Debug.Assert(IsNested((""[][][[]]"")) == (true));
    Debug.Assert(IsNested((""[[]"")) == (false));
    Debug.Assert(IsNested((""[]]"")) == (false));
    Debug.Assert(IsNested((""[[]][["")) == (true));
    Debug.Assert(IsNested((""[[][]]"")) == (true));
    Debug.Assert(IsNested(("""")) == (false));
    Debug.Assert(IsNested((""[[[[[[[["")) == (false));
    Debug.Assert(IsNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //tròn mỗi yếu tố trong danh sách đến int trên ((Chỉ) đầu tiên.     //Bạn cần phải trả về tổng số bình phương trong danh sách được đưa ra,     //Bạn được đưa ra một danh sách các số.    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})))
    // (14L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)4.0f, (float)9.0f})))
    // (98L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))
    // (84L)
    // >>> Lst((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f})))
    // (29L)
    // >>> Lst((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f})))
    // (6L)
    public static long SumSquares(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<float> lst)
    {
        long sum = 0;
        foreach (float num in lst)
        {
            int roundedNum = (int)Math.Ceiling(num);
            sum += (long)(roundedNum * roundedNum);
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f}))) == (29L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)10000.0f, (float)10000.0f}))) == (200000000L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)0.0f}))) == (0L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f}))) == (1L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2L));
    }

}
"
HumanEval_134,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Lưu ý: ""word"" là một nhóm các ký tự được tách ra bởi không gian.    //một phần của một từ, và sai nếu không.    //của một chuỗi được cho là một ký tự bảng chữ cái và không phải là     //Tạo hàm trả về true nếu ký tự cuối cùng là     // >>> CheckIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> CheckIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""""))
    // (false)
    public static bool CheckIfLastCharIsALetter(string txt) {
","public static bool CheckIfLastCharIsALetter(string txt) {
        if (string.IsNullOrWhiteSpace(txt)) {
            return false;
        }

        txt = txt.Trim();
        if (txt.Length == 0) {
            return false;
        }

        int lastIndex = txt.Length - 1;
        char lastChar = txt[lastIndex];

        if (!char.IsLetter(lastChar)) {
            return false;
        }

        if (lastIndex == 0 || char.IsWhiteSpace(txt[lastIndex - 1])) {
            return true;
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckIfLastCharIsALetter((""apple"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""A"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter(("""")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee e "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pie"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //giá trị trùng lặp.    //không có yếu tố như vậy tồn tại thì trả về -1. Danh sách được đưa ra sẽ không chứa     //không lớn hơn hoặc bằng phần tử ngay trước nó. Nếu     //Tạo một hàm trả về chỉ số lớn nhất của một phần tử mà     // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L})))
    // (3L)
    // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (-1L)
    public static long CanArrange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    // Create a function which returns the largest index of an element which
    // is not greater than or equal to the element immediately preceding it.
    // If no such element exists, then return -1.
    public static long CanArrange(List<long> arr) {
        for (int i = arr.Count - 1; i > 0; i--) {
            if (arr[i] < arr[i - 1]) {
                return i;
            }
        }
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))) == (3L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)5L}))) == (-1L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L}))) == (2L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)4L, (long)8L, (long)5L, (long)7L, (long)3L}))) == (4L));
    Debug.Assert(CanArrange((new List<long>())) == (-1L));
    }

}
"
HumanEval_136,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Nếu không có số nguyên âm hoặc dương, trả về chúng là null.    //của các số nguyên dương trong một danh sách.    //lớn nhất của số nguyên âm, và 'b' là nhỏ nhất     //Tạo một hàm trả về một tuple (a, b), trong đó 'a' là     // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L})))
    // Tuple.Create((Nullable<long>)null, 1L)
    // >>> LargestSmallestIntegers((new List<long>()))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)0L})))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
","public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
        Nullable<long> largestNegative = null;
        Nullable<long> smallestPositive = null;

        foreach (var number in lst) {
            if (number < 0) {
                if (largestNegative == null || number > largestNegative) {
                    largestNegative = number;
                }
            } else if (number > 0) {
                if (smallestPositive == null || number < smallestPositive) {
                    smallestPositive = number;
                }
            }
        }

        return Tuple.Create(largestNegative, smallestPositive);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L, (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L, (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    }

}
"
HumanEval_138,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //Đánh giá xem số n có thể được viết như là tổng của chính xác 4 số dương chẵn hay không.    // >>> IsEqualToSumEven((4L))
    // (false)
    // >>> IsEqualToSumEven((6L))
    // (false)
    // >>> IsEqualToSumEven((8L))
    // (true)
    public static bool IsEqualToSumEven(long n) {
","using System;

class Problem {
    // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
    public static bool IsEqualToSumEven(long n) {
        // Check if n is at least the sum of the smallest 4 positive even numbers (2 + 2 + 2 + 2 = 8)
        return n >= 8 && n % 2 == 0;
    }
    
    static void Main() {
        Console.WriteLine(IsEqualToSumEven(4L));  // false
        Console.WriteLine(IsEqualToSumEven(6L));  // false
        Console.WriteLine(IsEqualToSumEven(8L));  // true
        Console.WriteLine(IsEqualToSumEven(10L)); // true
        Console.WriteLine(IsEqualToSumEven(12L)); // true
        Console.WriteLine(IsEqualToSumEven(15L)); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsEqualToSumEven((4L)) == (false));
    Debug.Assert(IsEqualToSumEven((6L)) == (false));
    Debug.Assert(IsEqualToSumEven((8L)) == (true));
    Debug.Assert(IsEqualToSumEven((10L)) == (true));
    Debug.Assert(IsEqualToSumEven((11L)) == (false));
    Debug.Assert(IsEqualToSumEven((12L)) == (true));
    Debug.Assert(IsEqualToSumEven((13L)) == (false));
    Debug.Assert(IsEqualToSumEven((16L)) == (true));
    }

}
"
HumanEval_139,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //trong đó n > 0     //brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1!     //Các hệ số Brazil được định nghĩa là:     // >>> SpecialFactorial((4L))
    // (288L)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    public static long SpecialFactorial(long n) {
","using System;
using System.Numerics;

class Problem {
    public static long SpecialFactorial(long n) {
        if (n <= 0)
            throw new ArgumentException(""n must be greater than 0"");
        
        BigInteger brazilianFactorial = 1;
        
        for (long i = 1; i <= n; i++) {
            brazilianFactorial *= Factorial(i);
        }
        
        return (long)brazilianFactorial;
    }
    
    private static BigInteger Factorial(long num) {
        BigInteger result = 1;
        for (long i = 1; i <= num; i++) {
            result *= i;
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SpecialFactorial((4L)) == (288L));
    Debug.Assert(SpecialFactorial((5L)) == (34560L));
    Debug.Assert(SpecialFactorial((7L)) == (125411328000L));
    Debug.Assert(SpecialFactorial((1L)) == (1L));
    }

}
"
HumanEval_140,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //sau đó thay thế tất cả các dấu cách liên tiếp bằng -     //và nếu một chuỗi có nhiều hơn 2 khoảng trống liên tiếp,     //Với một chuỗi văn bản, thay thế tất cả các khoảng trống trong đó bằng dấu gạch dưới,     // >>> FixSpaces(("" Example""))
    // (""Example"")
    // >>> FixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> FixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> FixSpaces(("" Example 3""))
    // (""_Example-3"")
    public static string FixSpaces(string text) {
","public static string FixSpaces(string text) {
        StringBuilder result = new StringBuilder();
        int spaceCount = 0;

        for (int i = 0; i < text.Length; i++) {
            if (text[i] == ' ') {
                spaceCount++;
            } else {
                if (spaceCount > 2) {
                    result.Append('-');
                } else {
                    for (int j = 0; j < spaceCount; j++) {
                        result.Append('_');
                    }
                }
                result.Append(text[i]);
                spaceCount = 0;
            }
        }

        if (spaceCount > 2) {
            result.Append('-');
        } else {
            for (int j = 0; j < spaceCount; j++) {
                result.Append('_');
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FixSpaces((""Example"")).Equals((""Example"")));
    Debug.Assert(FixSpaces((""Mudasir Hanif "")).Equals((""Mudasir_Hanif_"")));
    Debug.Assert(FixSpaces((""Yellow Yellow  Dirty  Fellow"")).Equals((""Yellow_Yellow__Dirty__Fellow"")));
    Debug.Assert(FixSpaces((""Exa   mple"")).Equals((""Exa-mple"")));
    Debug.Assert(FixSpaces((""   Exa 1 2 2 mple"")).Equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //- Dòng phụ sau dấu chấm phải là một trong những thứ này: ['txt', 'exe', 'dll']     //chữ cái Latinh ('a'-'z' và 'A'-'Z').     //- Các chuỗi con trước khi chấm không nên trống, và nó bắt đầu với một chữ cái từ     //- Tên tập tin có chính xác một dấu chấm '.'    //- Tên tập tin không được nhiều hơn ba chữ số ('0'-'9').     //được đáp ứng:     //Tên của tập tin được coi là hợp lệ nếu và chỉ khi tất cả các điều kiện sau đây được đáp ứng.    //'Vâng' nếu tên của tệp là hợp lệ, và trả về 'Không' nếu không.    //Tạo một hàm lấy một chuỗi đại diện cho tên của tệp và trả về     // >>> FileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> FileNameCheck((""1example.dll""))
    // (""No"")
    public static string FileNameCheck(string file_name) {
","using System;
using System.Text.RegularExpressions;

class Problem {
    public static string FileNameCheck(string file_name) {
        // Regular expression to validate the file name
        string pattern = @""^[a-zA-Z][^.]*\.[^.]+$"";
        
        // Check if there is exactly one dot and matches the overall pattern
        if (Regex.IsMatch(file_name, pattern)) {
            string[] parts = file_name.Split('.');
            
            // Check if the file extension is one of the allowed values
            if (new[] { ""txt"", ""exe"", ""dll"" }.Contains(parts[1])) {
                // Count the number of digits in the file name
                int digitCount = file_name.Count(char.IsDigit);
                
                // Validate the digit count
                if (digitCount <= 3) {
                    return ""Yes"";
                }
            }
        }
        
        return ""No"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FileNameCheck((""example.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1example.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s1sdf3.asd"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""K.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""MY16FILE3.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""His12FILE94.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_Y.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""?aREYA.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""/this_is_valid.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.wow"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txtexe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""#this2_i4s_5valid.ten"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""@this1_is6_valid.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_12valid.6exe4.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""all.exe.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_No.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""Is3youfault.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""no_one#knows.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1I563_Yes3.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_Yes3.txtt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final..txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final132"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_f4indsartal132."")).Equals((""No"")));
    Debug.Assert(FileNameCheck(("".txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s."")).Equals((""No"")));
    }

}
"
HumanEval_142,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //thay đổi các mục trong danh sách có chỉ mục không phải là bội số của 3 hoặc 4. hàm sau đó sẽ trả về tổng của tất cả các mục.     //nhiều của 3 và sẽ lập phương cho mục nguyên nếu chỉ số của nó là nhiều của 4 và không phải là nhiều của 3.    //Hàm này sẽ lấy một danh sách các số nguyên. Đối với tất cả các mục trong danh sách, hàm sẽ bình phương các mục số nguyên nếu chỉ số của nó là một     //""     // >>> lst
    // (long)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})
    // >>> lst
    // (long)new List<long>()
    // >>> lst
    // (long)new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L})
    public static long SumSquares(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<long> lst)
    {
        for (int i = 0; i < lst.Count; i++)
        {
            if (i % 3 == 0)
            {
                lst[i] = lst[i] * lst[i];
            }
            else if (i % 4 == 0)
            {
                lst[i] = lst[i] * lst[i] * lst[i];
            }
        }
        long sum = 0;
        foreach (long number in lst)
        {
            sum += number;
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (6L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)4L, (long)9L}))) == (14L));
    Debug.Assert(SumSquares((new List<long>())) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L}))) == (9L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L}))) == (-3L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)0L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L}))) == (-126L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-56L, (long)-99L, (long)1L, (long)0L, (long)-2L}))) == (3030L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)-1L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-16L, (long)-9L, (long)-2L, (long)36L, (long)36L, (long)26L, (long)-20L, (long)25L, (long)-40L, (long)20L, (long)-4L, (long)12L, (long)-26L, (long)35L, (long)37L}))) == (-14196L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-3L, (long)17L, (long)-1L, (long)-15L, (long)13L, (long)-1L, (long)14L, (long)-14L, (long)-12L, (long)-5L, (long)14L, (long)-14L, (long)6L, (long)13L, (long)11L, (long)16L, (long)16L, (long)4L, (long)10L}))) == (-1448L));
    }

}
"
HumanEval_143,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ 1:     //thứ tự của các từ trong chuỗi mới phải giống như chuỗi ban đầu.    //có chiều dài là số nguyên tố,     //và bạn phải trả về một chuỗi chứa các từ từ câu ban đầu,     //câu có chứa một số từ được tách ra bằng một khoảng trống,     //Bạn được cho một chuỗi đại diện cho một câu,     // >>> WordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> WordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    public static string WordsInSentence(string sentence) {
","using System;
using System.Collections.Generic;

class Problem {
    public static string WordsInSentence(string sentence) {
        bool IsPrime(int number) {
            if (number <= 1) return false;
            if (number == 2) return true;
            for (int i = 2; i * i <= number; i++) {
                if (number % i == 0) return false;
            }
            return true;
        }

        string[] words = sentence.Split(' ');
        List<string> primeLengthWords = new List<string>();

        foreach (string word in words) {
            if (IsPrime(word.Length)) {
                primeLengthWords.Add(word);
            }
        }

        return string.Join("" "", primeLengthWords);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsInSentence((""This is a test"")).Equals((""is"")));
    Debug.Assert(WordsInSentence((""lets go for swimming"")).Equals((""go for"")));
    Debug.Assert(WordsInSentence((""there is no place available here"")).Equals((""there is no place"")));
    Debug.Assert(WordsInSentence((""Hi I am Hussein"")).Equals((""Hi am Hussein"")));
    Debug.Assert(WordsInSentence((""go for it"")).Equals((""go for it"")));
    Debug.Assert(WordsInSentence((""here"")).Equals(("""")));
    Debug.Assert(WordsInSentence((""here is"")).Equals((""is"")));
    }

}
"
HumanEval_144,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bạn có thể giả định rằng x, và n là phân số hợp lệ, và không có số 0 làm số gọi.    //< số>/< mệnh số> trong đó cả số và mệnh số đều là số nguyên dương.    //cả x và n, là biểu diễn chuỗi của một phân số, và có định dạng sau,     //x * n. Hàm trả về true nếu x * n được định giá là một số nguyên và false     //Nhiệm vụ của bạn là thực hiện một hàm sẽ đơn giản hóa biểu thức     // >>> Simplify((""1/5""), (""5/1""))
    // (true)
    // >>> Simplify((""1/6""), (""2/1""))
    // (false)
    // >>> Simplify((""7/10""), (""10/2""))
    // (false)
    public static bool Simplify(string x, string n) {
","using System;

class Problem {
    public static bool Simplify(string x, string n) {
        var xParts = x.Split('/');
        var nParts = n.Split('/');
        
        int xNumerator = int.Parse(xParts[0]);
        int xDenominator = int.Parse(xParts[1]);
        
        int nNumerator = int.Parse(nParts[0]);
        int nDenominator = int.Parse(nParts[1]);
        
        // Calculate the resulting fraction for x * n
        int resultNumerator = xNumerator * nNumerator;
        int resultDenominator = xDenominator * nDenominator;
        
        // Simplify the fraction by finding the gcd
        int gcd = GCD(resultNumerator, resultDenominator);
        resultNumerator /= gcd;
        resultDenominator /= gcd;
        
        // It is a whole number if the simplified denominator is 1
        return resultDenominator == 1;
    }
    
    private static int GCD(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/6""), (""2/1"")) == (false));
    Debug.Assert(Simplify((""5/1""), (""3/1"")) == (true));
    Debug.Assert(Simplify((""7/10""), (""10/2"")) == (false));
    Debug.Assert(Simplify((""2/10""), (""50/10"")) == (true));
    Debug.Assert(Simplify((""7/2""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""11/6""), (""6/1"")) == (true));
    Debug.Assert(Simplify((""2/3""), (""5/2"")) == (false));
    Debug.Assert(Simplify((""5/2""), (""3/5"")) == (false));
    Debug.Assert(Simplify((""2/4""), (""8/4"")) == (true));
    Debug.Assert(Simplify((""2/4""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //sắp xếp chúng dựa trên chỉ mục của chúng trong danh sách ban đầu.    //Lưu ý: nếu có một số mục có tổng số chữ số tương tự,     //theo thứ tự tăng dần theo tổng số chữ số của chúng.    //Viết một hàm sắp xếp danh sách các số nguyên     // >>> OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L})))
    // (new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))
    // >>> OrderByPoints((new List<long>()))
    // (new List<long>())
    public static List<long> OrderByPoints(List<long> nums) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> OrderByPoints(List<long> nums)
    {
        return nums.Select((num, index) => new { Number = num, Index = index, DigitSum = SumOfDigits(num) })
                   .OrderBy(item => item.DigitSum)
                   .ThenBy(item => item.Index)
                   .Select(item => item.Number)
                   .ToList();
    }

    private static int SumOfDigits(long number)
    {
        number = Math.Abs(number);
        int sum = 0;
        while (number > 0)
        {
            sum += (int)(number % 10);
            number /= 10;
        }
        return sum;
    }

    static void Main(string[] args)
    {
        var sortedList = OrderByPoints(new List<long> { 1L, 11L, -1L, -11L, -12L });
        Console.WriteLine(string.Join("", "", sortedList));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L}))).Equals((new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1234L, (long)423L, (long)463L, (long)145L, (long)2L, (long)423L, (long)423L, (long)53L, (long)6L, (long)37L, (long)3457L, (long)3L, (long)56L, (long)0L, (long)46L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)6L, (long)53L, (long)423L, (long)423L, (long)423L, (long)1234L, (long)145L, (long)37L, (long)46L, (long)56L, (long)463L, (long)3457L}))));
    Debug.Assert(OrderByPoints((new List<long>())).Equals((new List<long>())));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)-11L, (long)-32L, (long)43L, (long)54L, (long)-98L, (long)2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)-3L, (long)-32L, (long)-98L, (long)-11L, (long)1L, (long)2L, (long)43L, (long)54L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L, (long)11L}))).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)2L, (long)11L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)0L, (long)6L, (long)6L, (long)-76L, (long)-21L, (long)23L, (long)4L}))).Equals((new List<long>(new long[]{(long)-76L, (long)-21L, (long)0L, (long)4L, (long)23L, (long)6L, (long)6L}))));
    }

}
"
HumanEval_146,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //chữ số đầu tiên và cuối cùng của một số là lẻ (1, 3, 5, 7, 9).    //số lượng các phần tử trong danh sách lớn hơn 10 và cả hai     //Viết một hàm lấy một danh sách các số như đầu vào và trả về     // >>> Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L})))
    // (1L)
    // >>> Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L})))
    // (2L)
    public static long Specialfilter(List<long> nums) {
","public static long Specialfilter(List<long> nums) {
        return nums.Count(num => {
            if (num <= 10) return false;
            long positiveNum = Math.Abs(num);
            string numStr = positiveNum.ToString();
            char firstDigit = numStr[0];
            char lastDigit = numStr[numStr.Length - 1];
            return IsOddDigit(firstDigit) && IsOddDigit(lastDigit);
        });
    }

    private static bool IsOddDigit(char digit) {
        return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9';
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)5L, (long)-2L, (long)1L, (long)-5L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L}))) == (1L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L}))) == (2L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)43L, (long)-12L, (long)93L, (long)125L, (long)121L, (long)109L}))) == (4L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)71L, (long)-2L, (long)-33L, (long)75L, (long)21L, (long)19L}))) == (3L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>())) == (0L));
    }

}
"
HumanEval_147,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:    //và a[i] + a[j] + a[k] là bội số của 3.     //Trả về số lượng ba (a[i], a[j], a[k]) của a trong đó i < j < k,     //Đối với mỗi i (1 ≤ i ≤ n), giá trị của a[i] = i * i - i + 1.     //Bạn được cho một số nguyên dương n. Bạn phải tạo một danh sách số nguyên a có chiều dài n.     // >>> GetMaxTriples((5L))
    // (1L)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    public static long GetMaxTriples(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long GetMaxTriples(long n) {
        List<long> a = new List<long>();
        for (long i = 1; i <= n; i++) {
            a.Add(i * i - i + 1);
        }

        long count = 0;
        for (int i = 0; i < a.Count; i++) {
            for (int j = i + 1; j < a.Count; j++) {
                for (int k = j + 1; k < a.Count; k++) {
                    if ((a[i] + a[j] + a[k]) % 3 == 0) {
                        count++;
                    }
                }
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        long n = 5; // Example input
        Console.WriteLine(GetMaxTriples(n)); // Should output 1 based on the example given
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetMaxTriples((5L)) == (1L));
    Debug.Assert(GetMaxTriples((6L)) == (4L));
    Debug.Assert(GetMaxTriples((10L)) == (36L));
    Debug.Assert(GetMaxTriples((100L)) == (53361L));
    }

}
"
HumanEval_148,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //không phải là tên đúng của hành tinh.    //Hàm sẽ trả về một tuple trống nếu planet1 hoặc planet2     //gần mặt trời.    //nằm giữa quỹ đạo của hành tinh 1 và quỹ đạo của hành tinh 2, được sắp xếp theo     //Hàm sẽ trả về một tuple chứa tất cả các hành tinh có quỹ đạo là     //Viết một hàm mà có hai tên hành tinh như chuỗi planet1 và planet2.     //Sao Thiên Vương, Sao Hải Vương.    //là sao Thủy, tiếp theo là sao Kim, sau đó là Trái đất, sao Hỏa, sao Mộc, sao Thổ,    //Có tám hành tinh trong hệ mặt trời của chúng ta: gần Mặt trời nhất.    // >>> Bf((""Jupiter""), (""Neptune""))
    // (new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))
    // >>> Bf((""Earth""), (""Mercury""))
    // (List<string>(""Venus""))
    // >>> Bf((""Mercury""), (""Uranus""))
    // (new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))
    public static List<string> Bf(string planet1, string planet2) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> Bf(string planet1, string planet2) {
        List<string> planets = new List<string> { ""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"" };
        int index1 = planets.IndexOf(planet1);
        int index2 = planets.IndexOf(planet2);

        if (index1 == -1 || index2 == -1) {
            return new List<string>();
        }
        
        List<string> result = new List<string>();
        int start = Math.Min(index1, index2);
        int end = Math.Max(index1, index2);

        for (int i = start + 1; i < end; i++) {
            result.Add(planets[i]);
        }

        return result;
    }

    public static void Main() {
        Console.WriteLine(string.Join("", "", Bf(""Jupiter"", ""Neptune""))); // Output: Saturn, Uranus
        Console.WriteLine(string.Join("", "", Bf(""Earth"", ""Mercury"")));   // Output: Venus
        Console.WriteLine(string.Join("", "", Bf(""Mercury"", ""Uranus""))); // Output: Venus, Earth, Mars, Jupiter, Saturn
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Bf((""Jupiter""), (""Neptune"")).Equals((new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Mercury"")).Equals((new List<string>(new string[]{(string)""Venus""}))));
    Debug.Assert(Bf((""Mercury""), (""Uranus"")).Equals((new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))));
    Debug.Assert(Bf((""Neptune""), (""Venus"")).Equals((new List<string>(new string[]{(string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Mars""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Jupiter""), (""Makemake"")).Equals((new List<string>())));
    }

}
"
HumanEval_149,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Bạn có thể giả định rằng tất cả các từ sẽ có cùng chiều dài.    //Hàm sẽ trả về một danh sách các chuỗi theo thứ tự được sắp xếp.    //Nếu hai từ có cùng chiều dài, sắp xếp danh sách theo thứ tự bảng chữ cái.     //nên trả lại danh sách được sắp xếp theo quy tắc đó.    //Lệnh của danh sách nên được tăng theo chiều dài của mỗi từ, và bạn     //và nó có thể chứa các bản sao.    //Danh sách luôn luôn là một danh sách các chuỗi và không bao giờ là một danh sách các số,     //và trả về danh sách kết quả với thứ tự được sắp xếp,     //xóa các chuỗi có chiều dài lẻ từ nó,     //Viết một hàm chấp nhận một danh sách các chuỗi như một tham số,     // >>> ListSort((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""})))
    // (new List<string>(new string[]{(string)""aa""}))
    // >>> ListSort((new List<string>(new string[]{(string)""ab"", (string)""a"", (string)""aaa"", (string)""cd""})))
    // (new List<string>(new string[]{(string)""ab"", (string)""cd""}))
    public static List<string> SortedListSum(List<string> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ListSort(List<string> lst) {
        return lst.Where(x => x.Length % 2 == 0)
                  .OrderBy(x => x.Length)
                  .ThenBy(x => x)
                  .ToList();
    }
    
    static void Main() {
        var result1 = ListSort(new List<string> { ""aa"", ""a"", ""aaa"" });
        Console.WriteLine(string.Join("", "", result1)); // Output: aa

        var result2 = ListSort(new List<string> { ""ab"", ""a"", ""aaa"", ""cd"" });
        Console.WriteLine(string.Join("", "", result2)); // Output: ab, cd
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""}))).Equals((new List<string>(new string[]{(string)""aa""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""school"", (string)""AI"", (string)""asdf"", (string)""b""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""asdf"", (string)""school""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""b"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""dcba"", (string)""abcd"", (string)""a""}))).Equals((new List<string>(new string[]{(string)""abcd"", (string)""dcba""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""b"", (string)""c"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aaaa"", (string)""bbbb"", (string)""dd"", (string)""cc""}))).Equals((new List<string>(new string[]{(string)""cc"", (string)""dd"", (string)""aaaa"", (string)""bbbb""}))));
    }

}
"
HumanEval_150,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //một số nguyên tố và sẽ trả về giá trị của y nếu không.    //Một chương trình đơn giản sẽ trả về giá trị của x nếu n là     // >>> XOrY((7L), (34L), (12L))
    // (34L)
    // >>> XOrY((15L), (8L), (5L))
    // (5L)
    public static long XOrY(long n, long x, long y) {
","using System;

class Problem {
    public static long XOrY(long n, long x, long y) {
        return IsPrime(n) ? x : y;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;
        if (number % 2 == 0 || number % 3 == 0) return false;
        
        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }
        
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(XOrY((7L), (34L), (12L)) == (34L));
    Debug.Assert(XOrY((15L), (8L), (5L)) == (5L));
    Debug.Assert(XOrY((3L), (33L), (5212L)) == (33L));
    Debug.Assert(XOrY((1259L), (3L), (52L)) == (3L));
    Debug.Assert(XOrY((7919L), (-1L), (12L)) == (-1L));
    Debug.Assert(XOrY((3609L), (1245L), (583L)) == (583L));
    Debug.Assert(XOrY((91L), (56L), (129L)) == (129L));
    Debug.Assert(XOrY((6L), (34L), (1234L)) == (1234L));
    Debug.Assert(XOrY((1L), (2L), (0L)) == (0L));
    Debug.Assert(XOrY((2L), (2L), (0L)) == (2L));
    }

}
"
HumanEval_151,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //bỏ qua những số âm hoặc không phải là số nguyên.    //Cho một danh sách các số, trả về tổng số vuông của các số     // >>> DoubleTheDifference((new List<float>(new long[]{(long)1L, (long)3L, (long)2L, (long)0L})))
    // (10L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)-1L, (long)-2L, (long)0L})))
    // (0L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)9L, (long)-2L})))
    // (81L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)0L})))
    // (0L)
    // If the input list is empty, return 0.
    public static long DoubleTheDifference(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    // Given a list of numbers, return the sum of squares of the numbers
    // in the list that are odd. Ignore numbers that are negative or not integers.
    public static long DoubleTheDifference(List<float> lst) {
        long sum = 0;
        foreach (var num in lst) {
            if (num >= 0 && num == (long)num && ((long)num % 2) != 0) {
                sum += (long)num * (long)num;
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoubleTheDifference((new List<float>())) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)5.0f, (float)4.0f}))) == (25L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.1f, (float)0.2f, (float)0.3f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.2f, (float)3.0f, (float)5.0f}))) == (34L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165L));
    }

}
"
HumanEval_152,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ví dụ:     //giá trị là 0, và nếu không, giá trị là sự khác biệt tuyệt đối giữa phỏng đoán và điểm số.     //Trả về một danh sách cùng chiều dài biểu thị cách xa của mỗi phỏng đoán. Nếu họ đã đoán đúng,     //Bạn được đưa ra hai danh sách điểm số và đoán có chiều dài bằng nhau, trong đó mỗi chỉ số cho thấy một trận đấu.    //Nhiệm vụ của bạn là xác định xem một người đã đoán đúng kết quả của một số trận đấu.    //Chắc chắn đáng để ghi lại và so sánh.    //Những cảm xúc và suy nghĩ của bạn vào thời điểm đó là những gì bạn đang nghĩ.    //Tôi nghĩ tất cả chúng ta đều nhớ cảm giác đó khi kết quả của một số điều được chờ đợi từ lâu    // >>> Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L})))
    // (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))
    // >>> Compare((new List<long>(new long[]{(long)0L, (long)5L, (long)0L, (long)0L, (long)0L, (long)4L})), (new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L, (long)0L, (long)-2L})))
    // (new List<long>(new long[]{(long)4L, (long)4L, (long)1L, (long)0L, (long)0L, (long)6L}))
    public static List<long> Compare(List<long> game, List<long> guess) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Compare(List<long> game, List<long> guess)
    {
        List<long> differences = new List<long>();
        for (int i = 0; i < game.Count; i++)
        {
            differences.Add(Math.Abs(game[i] - guess[i]));
        }
        return differences;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L})), (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L})), (new List<long>(new long[]{(long)-1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)0L, (long)0L, (long)1L}))));
    }

}
"
HumanEval_153,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //(cường độ của nó là -1).    //trả về ""Slices.SErviNGSliCes"" vì ""SErviNGSliCes"" là phần mở rộng mạnh nhất     //extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] thì bạn nên     //Ví dụ, nếu bạn được cung cấp ""Slices"" như là lớp và một danh sách các     //chọn cái đầu tiên trong danh sách.    //Nếu có hai hoặc nhiều phần mở rộng với cùng một sức mạnh, bạn nên    //format: ClassName.StrongestExtensionName.     //Bạn nên tìm phần mở rộng mạnh nhất và trả về một chuỗi trong này.    //trong tên của phần mở rộng, cường độ được đưa ra bằng phân số CAP - SM.     //chữ cái trong tên của phần mở rộng, và hãy để SM là số chữ cái nhỏ     //sức mạnh của phần mở rộng như sau: Hãy để CAP là số của chữ cái lớn     //Các phần mở rộng được sử dụng để tải các lớp bổ sung cho lớp.    //Bạn sẽ được cung cấp tên của một lớp (một chuỗi) và một danh sách các phần mở rộng.    // >>> StrongestExtension((""my_class""), (new List<string>(new string[]{(string)""AA"", (string)""Be"", (string)""CC""})))
    // (""my_class.AA"")
    public static string StrongestExtension(string class_name, List<string> extensions) {
","public static string StrongestExtension(string class_name, List<string> extensions) {
        string strongestExtension = null;
        int maxStrength = int.MinValue;

        foreach (var extension in extensions) {
            int countUpper = extension.Count(char.IsUpper);
            int countLower = extension.Count(char.IsLower);
            int strength = countUpper - countLower;

            if (strength > maxStrength) {
                maxStrength = strength;
                strongestExtension = extension;
            }
        }

        return $""{class_name}.{strongestExtension}"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrongestExtension((""Watashi""), (new List<string>(new string[]{(string)""tEN"", (string)""niNE"", (string)""eIGHt8OKe""}))).Equals((""Watashi.eIGHt8OKe"")));
    Debug.Assert(StrongestExtension((""Boku123""), (new List<string>(new string[]{(string)""nani"", (string)""NazeDa"", (string)""YEs.WeCaNe"", (string)""32145tggg""}))).Equals((""Boku123.YEs.WeCaNe"")));
    Debug.Assert(StrongestExtension((""__YESIMHERE""), (new List<string>(new string[]{(string)""t"", (string)""eMptY"", (string)""nothing"", (string)""zeR00"", (string)""NuLl__"", (string)""123NoooneB321""}))).Equals((""__YESIMHERE.NuLl__"")));
    Debug.Assert(StrongestExtension((""K""), (new List<string>(new string[]{(string)""Ta"", (string)""TAR"", (string)""t234An"", (string)""cosSo""}))).Equals((""K.TAR"")));
    Debug.Assert(StrongestExtension((""__HAHA""), (new List<string>(new string[]{(string)""Tab"", (string)""123"", (string)""781345"", (string)""-_-""}))).Equals((""__HAHA.123"")));
    Debug.Assert(StrongestExtension((""YameRore""), (new List<string>(new string[]{(string)""HhAas"", (string)""okIWILL123"", (string)""WorkOut"", (string)""Fails"", (string)""-_-""}))).Equals((""YameRore.okIWILL123"")));
    Debug.Assert(StrongestExtension((""finNNalLLly""), (new List<string>(new string[]{(string)""Die"", (string)""NowW"", (string)""Wow"", (string)""WoW""}))).Equals((""finNNalLLly.WoW"")));
    Debug.Assert(StrongestExtension((""_""), (new List<string>(new string[]{(string)""Bb"", (string)""91245""}))).Equals((""_.Bb"")));
    Debug.Assert(StrongestExtension((""Sp""), (new List<string>(new string[]{(string)""671235"", (string)""Bb""}))).Equals((""Sp.671235"")));
    }

}
"
HumanEval_154,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bạn được cung cấp 2 từ. Bạn cần phải trả về đúng nếu từ thứ hai hoặc bất kỳ vòng quay của nó là một chuỗi con trong từ đầu tiên.    // >>> CycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> CycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> CycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> CycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> CycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> CycpatternCheck((""himenss""), (""simen""))
    // (true)
    public static bool CycpatternCheck(string a, string b) {
","using System;

class Problem {
    public static bool CycpatternCheck(string a, string b) {
        if (a.Length < b.Length) {
            return false;
        }

        string combinedB = b + b;
        for (int i = 0; i < b.Length; i++) {
            string rotation = combinedB.Substring(i, b.Length);
            if (a.Contains(rotation)) {
                return true;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CycpatternCheck((""xyzw""), (""xyw"")) == (false));
    Debug.Assert(CycpatternCheck((""yello""), (""ell"")) == (true));
    Debug.Assert(CycpatternCheck((""whattup""), (""ptut"")) == (false));
    Debug.Assert(CycpatternCheck((""efef""), (""fee"")) == (true));
    Debug.Assert(CycpatternCheck((""abab""), (""aabb"")) == (false));
    Debug.Assert(CycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Cho một số nguyên. trả về một tuple có số chữ số chẵn và lẻ tương ứng.     // >>> EvenOddCount((-12L))
    // (Tuple.Create(1L, 1L))
    // >>> EvenOddCount((123L))
    // (Tuple.Create(1L, 2L))
    public static Tuple<long, long> EvenOddCount(long num) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    public static Tuple<long, long> EvenOddCount(long num) {
        // Convert the number to positive to handle negative numbers
        num = Math.Abs(num);
        long evenCount = 0;
        long oddCount = 0;
        
        while (num > 0) {
            long digit = num % 10;
            if (digit % 2 == 0)
                evenCount++;
            else
                oddCount++;
            num /= 10;
        }
        
        return Tuple.Create(evenCount, oddCount);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddCount((7L)).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(EvenOddCount((-78L)).Equals((Tuple.Create(1L, 1L))));
    Debug.Assert(EvenOddCount((3452L)).Equals((Tuple.Create(2L, 2L))));
    Debug.Assert(EvenOddCount((346211L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-345821L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-2L)).Equals((Tuple.Create(1L, 0L))));
    Debug.Assert(EvenOddCount((-45347L)).Equals((Tuple.Create(2L, 3L))));
    Debug.Assert(EvenOddCount((0L)).Equals((Tuple.Create(1L, 0L))));
    }

}
"
HumanEval_156,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //Hạn chế: 1 <= số <= 1000     //và trả về nó bằng chữ cái nhỏ.    //Cho một số nguyên dương, lấy số La Mã tương đương của nó như một chuỗi,     // >>> IntToMiniRoman((19L))
    // (""xix"")
    // >>> IntToMiniRoman((152L))
    // (""clii"")
    // >>> IntToMiniRoman((426L))
    // (""cdxxvi"")
    public static string IntToMiniRoman(long number) {
","if (number < 1 || number > 1000)
            throw new ArgumentOutOfRangeException(""number"", ""Input must be between 1 and 1000"");

        // Mapping of Roman numerals
        var romanNumerals = new List<(int value, string numeral)>
        {
            (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
            (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
            (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
            (1, ""i"")
        };

        var sb = new StringBuilder();

        foreach (var (value, numeral) in romanNumerals)
        {
            while (number >= value)
            {
                sb.Append(numeral);
                number -= value;
            }
        }

        return sb.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IntToMiniRoman((19L)).Equals((""xix"")));
    Debug.Assert(IntToMiniRoman((152L)).Equals((""clii"")));
    Debug.Assert(IntToMiniRoman((251L)).Equals((""ccli"")));
    Debug.Assert(IntToMiniRoman((426L)).Equals((""cdxxvi"")));
    Debug.Assert(IntToMiniRoman((500L)).Equals((""d"")));
    Debug.Assert(IntToMiniRoman((1L)).Equals((""i"")));
    Debug.Assert(IntToMiniRoman((4L)).Equals((""iv"")));
    Debug.Assert(IntToMiniRoman((43L)).Equals((""xliii"")));
    Debug.Assert(IntToMiniRoman((90L)).Equals((""xc"")));
    Debug.Assert(IntToMiniRoman((94L)).Equals((""xciv"")));
    Debug.Assert(IntToMiniRoman((532L)).Equals((""dxxxii"")));
    Debug.Assert(IntToMiniRoman((900L)).Equals((""cm"")));
    Debug.Assert(IntToMiniRoman((994L)).Equals((""cmxciv"")));
    Debug.Assert(IntToMiniRoman((1000L)).Equals((""m"")));
    }

}
"
HumanEval_157,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //90 độ.    //Một tam giác góc phải là một tam giác trong đó một góc là góc phải hoặc     //các bên tạo thành một tam giác góc phải, sai nếu không.    //Cho các chiều dài của ba bên của một tam giác. trả về đúng nếu ba     // >>> RightAngleTriangle((3L), (4L), (5L))
    // (true)
    // >>> RightAngleTriangle((1L), (2L), (3L))
    // (false)
    public static bool RightAngleTriangle(long a, long b, long c) {
","using System;

class Problem
{
    public static bool RightAngleTriangle(long a, long b, long c)
    {
        // Sort the sides to make it easier to apply the Pythagorean theorem.
        long[] sides = { a, b, c };
        Array.Sort(sides);

        // Check if the sum of the squares of the smaller two sides equals the square of the largest side.
        return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RightAngleTriangle((3L), (4L), (5L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (2L), (3L)) == (false));
    Debug.Assert(RightAngleTriangle((10L), (6L), (8L)) == (true));
    Debug.Assert(RightAngleTriangle((2L), (2L), (2L)) == (false));
    Debug.Assert(RightAngleTriangle((7L), (24L), (25L)) == (true));
    Debug.Assert(RightAngleTriangle((10L), (5L), (7L)) == (false));
    Debug.Assert(RightAngleTriangle((5L), (12L), (13L)) == (true));
    Debug.Assert(RightAngleTriangle((15L), (8L), (17L)) == (true));
    Debug.Assert(RightAngleTriangle((48L), (55L), (73L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (1L), (1L)) == (false));
    Debug.Assert(RightAngleTriangle((2L), (2L), (10L)) == (false));
    }

}
"
HumanEval_158,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ký tự, trả về một trong những thứ tự xuất hiện đầu tiên trong bảng từ vựng.     //của các ký tự duy nhất. Nếu nhiều chuỗi có số lượng tối đa của các độc đáo     //Danh sách chứa nhiều từ khác nhau. Trả về từ với số lượng tối đa     //Viết một hàm chấp nhận một danh sách các chuỗi.     // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""})))
    // (""string"")
    // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""})))
    // (""enam"")
    // >>> FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""})))
    // (""aaaaaaa"")
    public static string FindMax(List<string> words) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string FindMax(List<string> words)
    {
        string result = string.Empty;
        int maxUniqueChars = 0;

        foreach (var word in words)
        {
            var uniqueChars = word.ToCharArray().Distinct().Count();

            if (uniqueChars > maxUniqueChars || (uniqueChars == maxUniqueChars && string.Compare(word, result, StringComparison.Ordinal) < 0))
            {
                maxUniqueChars = uniqueChars;
                result = word;
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""}))).Equals((""string"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""}))).Equals((""enam"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""}))).Equals((""aaaaaaa"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""abc"", (string)""cba""}))).Equals((""abc"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""this"", (string)""game"", (string)""of"", (string)""footbott""}))).Equals((""footbott"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""gonna"", (string)""rock""}))).Equals((""gonna"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""a"", (string)""mad"", (string)""nation""}))).Equals((""nation"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""this"", (string)""is"", (string)""a"", (string)""prrk""}))).Equals((""this"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""b""}))).Equals((""b"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""play"", (string)""play""}))).Equals((""play"")));
    }

}
"
HumanEval_159,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //nếu không có đủ cà rốt còn lại, bạn sẽ ăn tất cả cà rốt còn lại, nhưng vẫn sẽ đói.    //số cà rốt còn lại sau bữa ăn của bạn ]     //bạn nên trả lại một danh sách [tổng số cà rốt ăn sau bữa ăn của bạn,     //Nhưng bây giờ bạn cần ăn nhiều cà rốt hơn để hoàn thành bữa ăn trong ngày.    //Anh là một con thỏ đói, và anh đã ăn một số cà rốt nhất định,    // >>> Eat((5L), (6L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)4L}))
    // >>> Eat((4L), (8L), (9L))
    // (new List<long>(new long[]{(long)12L, (long)1L}))
    // >>> Eat((1L), (10L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)0L}))
    // >>> Eat((2L), (11L), (5L))
    // (new List<long>(new long[]{(long)7L, (long)0L}))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    public static List<long> Eat(long number, long need, long remaining) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Eat(long number, long need, long remaining) {
        long totalEaten = number;
        long leftAfterMeals;

        if(remaining >= need) {
            totalEaten += need;
            leftAfterMeals = remaining - need;
        } else {
            totalEaten += remaining;
            leftAfterMeals = 0;
        }
        
        return new List<long>{ totalEaten, leftAfterMeals };
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Eat((5L), (6L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)4L}))));
    Debug.Assert(Eat((4L), (8L), (9L)).Equals((new List<long>(new long[]{(long)12L, (long)1L}))));
    Debug.Assert(Eat((1L), (10L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)0L}))));
    Debug.Assert(Eat((2L), (11L), (5L)).Equals((new List<long>(new long[]{(long)7L, (long)0L}))));
    Debug.Assert(Eat((4L), (5L), (7L)).Equals((new List<long>(new long[]{(long)9L, (long)2L}))));
    Debug.Assert(Eat((4L), (5L), (1L)).Equals((new List<long>(new long[]{(long)5L, (long)0L}))));
    }

}
"
HumanEval_160,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Danh sách nhà khai thác có ít nhất một nhà khai thác và danh sách operand có ít nhất hai operand.    //Operand là một danh sách các số nguyên không âm.    //Chiều dài của danh sách nhà điều hành bằng chiều dài của danh sách operand trừ một.    //Lưu ý:    //=> kết quả = 9     //kết quả = 2 + 3 * 4 - 5     //danh sách = [2, 3, 4, 5]     //nhà điều hành['+', '*', '-']     //Ví dụ:     //Tăng gấp đôi (**)     //Phân chia tầng ( //)     //Nhân (*)     //Bước trừ ( - )     //Thêm (+)     //Các phép toán đại số cơ bản:    //biểu thức và trả về đánh giá của biểu thức này.    //danh sách thứ hai là một danh sách các số nguyên. Sử dụng hai danh sách được đưa ra để xây dựng đại số     //Cho hai danh sách nhà điều hành, và operand. Danh sách đầu tiên có các hoạt động đại số cơ bản, và     public static long DoAlgebra(List<string> op, List<long> operand) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long DoAlgebra(List<string> op, List<long> operand)
    {
        if (op.Count + 1 != operand.Count || operand.Count < 2)
        {
            throw new ArgumentException(""Invalid input lists."");
        }

        long result = operand[0];

        for (int i = 0; i < op.Count; i++)
        {
            string currentOp = op[i];
            long currentOperand = operand[i + 1];

            switch (currentOp)
            {
                case ""+"":
                    result += currentOperand;
                    break;
                case ""-"":
                    result -= currentOperand;
                    break;
                case ""*"":
                    result *= currentOperand;
                    break;
                case ""//"":
                    result /= currentOperand;
                    break;
                case ""**"":
                    result = (long)Math.Pow(result, currentOperand);
                    break;
                default:
                    throw new InvalidOperationException($""Unsupported operator: {currentOp}"");
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""**"", (string)""*"", (string)""+""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (37L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""+"", (string)""*"", (string)""-""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (9L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""//"", (string)""*""})), (new List<long>(new long[]{(long)7L, (long)3L, (long)4L}))) == (8L));
    }

}
"
HumanEval_161,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ     //Hàm sẽ trả về chuỗi kết quả.    //Nếu chuỗi không có chữ cái, hãy đảo ngược chuỗi.    //Nếu không thì cứ giữ nguyên.    //nếu s[i] là một chữ cái, hãy đảo ngược trường hợp của nó từ dưới lên trên hoặc ngược lại,     //Bạn được cho một chuỗi s.    // >>> Solve((""1234""))
    // (""4321"")
    // >>> Solve((""ab""))
    // (""AB"")
    // >>> Solve((""#a@C""))
    // (""#A@c"")
    public static string Solve(string s) {
","public static string Solve(string s) {
        bool hasLetter = s.Any(char.IsLetter);
        if (hasLetter) {
            var result = new StringBuilder(s.Length);
            foreach (char c in s) {
                if (char.IsLetter(c)) {
                    result.Append(char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c));
                } else {
                    result.Append(c);
                }
            }
            return result.ToString();
        } else {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((""AsDf"")).Equals((""aSdF"")));
    Debug.Assert(Solve((""1234"")).Equals((""4321"")));
    Debug.Assert(Solve((""ab"")).Equals((""AB"")));
    Debug.Assert(Solve((""#a@C"")).Equals((""#A@c"")));
    Debug.Assert(Solve((""#AsdfW^45"")).Equals((""#aSDFw^45"")));
    Debug.Assert(Solve((""#6@2"")).Equals((""2@6#"")));
    Debug.Assert(Solve((""#$a^D"")).Equals((""#$A^d"")));
    Debug.Assert(Solve((""#ccc"")).Equals((""#CCC"")));
    }

}
"
HumanEval_162,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Nếu 'text' là một chuỗi trống, trả về null.     //Với một chuỗi 'text', trả về chuỗi tương đương md5 hash của nó.     // >>> StringToMd5((""Hello world""))
    // (""3e25960a79dbc69b674cd4ec67a72c62"")
    public static string StringToMd5(string text) {
","using System;
using System.Security.Cryptography;
using System.Text;

class Problem {
    public static string StringToMd5(string text) {
        if (string.IsNullOrEmpty(text)) {
            return null;
        }
        
        using (MD5 md5 = MD5.Create()) {
            byte[] inputBytes = Encoding.UTF8.GetBytes(text);
            byte[] hashBytes = md5.ComputeHash(inputBytes);
            
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < hashBytes.Length; i++) {
                sb.Append(hashBytes[i].ToString(""x2""));
            }
            return sb.ToString();
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringToMd5((""Hello world"")).Equals((""3e25960a79dbc69b674cd4ec67a72c62"")));
    Debug.Assert(StringToMd5(("""")).Equals(null));
    Debug.Assert(StringToMd5((""A B C"")).Equals((""0ef78513b0cb8cef12743f5aeb35f888"")));
    Debug.Assert(StringToMd5((""password"")).Equals((""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,vie_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ví dụ:     //và b, theo thứ tự tăng dần.    //Cho hai số nguyên dương a và b, trả về các chữ số chẵn giữa a     // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    public static List<long> GenerateIntegers(long a, long b) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Given two positive integers a and b, return the even digits between a
    // and b, in ascending order.
    // For example:
    // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    
    public static List<long> GenerateIntegers(long a, long b)
    {
        List<long> evenDigits = new List<long> { 2, 4, 6, 8 };
        List<long> result = new List<long>();

        if (a > b)
        {
            // Swap values if a is greater than b to ensure ascending order
            long temp = a;
            a = b;
            b = temp;
        }

        foreach (var even in evenDigits)
        {
            if (even >= a && even <= b)
            {
                result.Add(even);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GenerateIntegers((2L), (10L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((10L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((132L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((17L), (89L)).Equals((new List<long>())));
    }

}
"
