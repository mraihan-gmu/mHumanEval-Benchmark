[
    {
        "task_id": "HumanEval/0",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤنتيكو جك دالم ۏيكتور ارق دبري، اد دوا ارق يڠ لبيه كاو سيكڤ دري سيكڤ ترسبوت. >>> has_close_elements (((std::vector<float> ((({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f)) (false) >>> has_close_elements (((std::vector<float> (((float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f)) (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
        "canonical_solutions": "bool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/1",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤڠاتورن اونتوق فانسي اين اداله سورت يڠ مروڤاكن ببراڤ ڬروڤ ڤڠاتورن يڠ دڤركنلكن. توجوان توهنكو اداله اونتوق ممباڬي ڬروڤ-ڬروڤ ايت كڤد سورت يڠ بربيدا دان مروڤاكن ۏيكتورڽ. ڬروڤ-ڬروڤ يڠ بربيدا دالم ڤربينچڠن (سورت يڠ بربيدا دتڠڬوڠجواب سچارا بربيدا) دان تيدق بربيدا دالم سورت يڠ لاين. >>> separate_paren_groups (((\"( ) (() ((( ))))) (std::vector<std::string>({(std::string) \")\", ((((()) \" (std::string) \"\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue;  // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance == 0) {  // Found a balanced group\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}",
        "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/2",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن نومبور ڤوسيتيف ڤوتينڬ ڤوتين، ڽو جاوت ديكومڤوساسي كاو ڤرتيمبڠن اينتيڬر (ڤرتيمبڠن انتيڬر يڠ ڤاليڠ راييك لياوبيه رنده دري نومبور يڠ دبريكن) ڠن ديسيمال (ڤرتيمبڠن يڠ لابه دايمڤون لياوبيه رنده دري ١).\nfloat truncate_number(float number) {\n",
        "canonical_solutions": "float truncate_number(float number) {\n    return number - std::floor(number);\n}",
        "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/3",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ۏيكتور ڤڠاجين دان ڤڠكالن د سبواه اكاونت بڠك يڠ برمولا دڠن بيلدول صفر. ڤركارا اكو اداله اونتوق ديتيكت اڤابيلا د سياڤ تيتيق بيلدول اكاونت دلوار صفر، دان د تيتيق ايت فانسي داڤت مروڤاكن فول. اڤابيلا تيدق، اي داڤت مروڤاكن فول. >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero(std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)\nbool below_zero(std::vector<long> operations) {\n",
        "canonical_solutions": "bool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/4",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اونتوق ڤيكتور ڤڠمبيلن يڠ دبري، مڠحسابكن Mean Absolute Deviation دڠن موده داسر داتا. Mean Absolute Deviation اداله ڤربيداان موده انتارا ستياڤ ايليمن دان تيتيق ڤوست (موده دالم حال اين): MAD = average ∙ x - x_mean ∙ >>> mean_absolute_deviation (((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
        "canonical_solutions": "float mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, \n                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) \n                / numbers.size();\n    return mad;\n}",
        "test": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n"
    },
    {
        "task_id": "HumanEval/5",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيلكن ارق 'ديليمتر' انتارا ستياڤ دوا ايليمن يڠ برتنديڠ دري `numbers ` ڤيكتور ڤنومڤڠ >>> intersperse (((std::vector<long> ((()) ، (4)) (std::vector<long> (()) >>> intersperse (((std::vector<long> (((long) 1، (long) 2، (long) 3)) ، (4)) (std::vector<long> (((long) 1، (long) 4، (long) 2، (long) 4، (long) 3))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
        "canonical_solutions": "std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<long> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/6",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤڠاره ڤڠاره اين اداله ستريڠ يڠ مروڤاكن ببراڤ ڬروڤ اونتوق ڤڠاره يڠ دڤرتوان اڬوڠ يڠ دڤرباڬايكن دڠن ڤاس. اونتوق ستياڤ ڬروڤ، ڤڠاره ڤڠاره ڤڠاره ڤڠاره يڠ ڤاليڠ دالم. چونتوهڽ (() (()) ممڤوڽاءي دوا ڤڠاره ڤڠاره ماناكالا ((())) ممڤوڽاءي تيڬ. >>> parse_nested_parens ((((((()) ((())) () ((((()))))) (std::vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n    long current_depth = 0, max_depth = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (max_depth > 0) {\n                depths.push_back(max_depth);\n                max_depth = 0;\n            }\n            current_depth = 0;\n        } else if (ch == '(') {\n            current_depth++;\n            max_depth = std::max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
    },
    {
        "task_id": "HumanEval/7",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فلتر ڤيكتور انتر دري سورت يڠ ممڤوڽاءي سوبسترينگ >>> filter_by_substring((std::vector<std::string>() ، (\"a\")) (std::vector<std::string>()) >>> filter_by_substring(((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"cde\", (std::string) \"array\"}) ، (\"a\") (std::vector<std::string>(({(std::string) abc\", (std::string) \"bacd\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/8",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اونتوق ڤيكتور اينتيڬر يڠ دبري، مروڤاكن توڤل يڠ بركونسيڤ دري سوم دان ڤرودوك سموا اينتيڬر د ڤيكتور. سوم بياسا ڤرلو سام دڠن 0 دان ڤرودوك بياسا ڤرلو سام دڠن 1. >>> sum_product (((std::vector<long>())) (std::make_tuple ((0, 1)) >>> sum_product (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple ((10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);\n    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());\n    return std::make_tuple(sum, product);\n}",
        "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"
    },
    {
        "task_id": "HumanEval/9",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري سابوه ۏيكتور انجيڬر يڠ دبري، جنيراسي ۏيكتور رولانڬ ماكسيما ايلميت يڠ دتومڤت سهيڠڬ ڤريستيوا يڠ دبري دالم سيكويين. >>> rolling_max(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = LONG_MIN;\n\n    for (long num : numbers) {\n        max_so_far = std::max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"
    },
    {
        "task_id": "HumanEval/10",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤوليه ڤاليندروم يڠ ڤاليڠ كورڠ يڠ برمولا دڠن ستراين يڠ دڤاوڬيت. ايديا الڬوريتم ساڠت سيبوق: - ڤوليه ڤوليه ڤوستفيكس ستراين يڠ دڤاوڬيت يڠ اداله ڤاليندروم. - ڤوليه ڤوليه ڤوستفيكس ستراين يڠ دڤاوڬيت سبلوم سڤيک س ڤاليندروم. >>> make_palindrome (((\"\")) (\"\") >>> make_palindrome (((\"cat\")) (\"catac\") >>> make_palindrome (((\"cata\")) (\"catac\")\nstd::string make_palindrome(std::string string) {\n",
        "canonical_solutions": "std::string make_palindrome(std::string string) {\n    auto is_palindrome = [](const std::string &s) {\n        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    };\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        if (is_palindrome(string.substr(i))) {\n            std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return string + prefix;\n        }\n    }\n\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"
    },
    {
        "task_id": "HumanEval/11",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input اداله دوا سورت a دان b يڠ تيڠڬل دري 1 دان 0. ڤرلوكن XOR باينري دالم اينڤوت ڠن مروڤاكن ريسلوت سيوباڬاي سورت. >>> string_xor((\"010\"), (\"110\")) (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n",
        "canonical_solutions": "std::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
    },
    {
        "task_id": "HumanEval/12",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري ۏكتور سورت، ڤرلو مروڤاكن يڠ ڤاليڠ لاما. ڤرلو مروڤاكن يڠ ڤرتام دالم كيس ببراڤ سورت دڠن لڠكه سام. ڤرلو مروڤاكن نيه دالم كيس ڤيڠت ڤيڠت ڤوڤولر. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{((std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) \"a\" >>> longest(((std::vector<std::string>(((std::string) \"a\", (std::string) \"bb\", (stdstring) \"cc\"} \"cc\")))\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) return std::nullopt;\n\n    return *std::max_element(strings.begin(), strings.end(), \n                             [](const std::string& a, const std::string& b) {\n                                 return a.size() < b.size();\n                             });\n}",
        "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
    },
    {
        "task_id": "HumanEval/13",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن ڤڠڬامبر كومون ڤاليڠ راييك دري دوا انتيڬره a دان b >>> ڤڠڬامبر_كومون_ڤاليڠ راييك (((3), (5)) (1) >>> ڤڠڬامبر_كومون_ڤاليڠ راييك (((25), (15)) (5)\nlong greatest_common_divisor(long a, long b) {\n",
        "canonical_solutions": "long greatest_common_divisor(long a, long b) {\n    return std::gcd(a, b);\n}",
        "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/14",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور ڤرجالنن سموا ڤريفكس دري ڤونچا كوريڠ كڤد ڤونچا ڤونچا ڤونچا ڤونچا >>> all_prefixes (((\"abc\")) (std::vector<std::string> (({(std::string) \"a\", (std::string) \"ab\", (std::string) \"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n",
        "canonical_solutions": "std::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (size_t i = 1; i <= string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i));\n    }\n    return prefixes;\n}",
        "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/15",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن ستريڠ يڠ مروڤاكن نومبور يڠ دڤاوڬيتكن دڠن ڤرسڤاكتن برمولا دري 0 سمڤأي n. >>> string_sequence((0)) (\"0\") >>> string_sequence((5)) (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n",
        "canonical_solutions": "std::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) oss << \" \";\n        oss << i;\n    }\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"
    },
    {
        "task_id": "HumanEval/16",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت سترين، جاوت لي كاراكتر يڠ بربيدا (لاڤر ڤون كيس) جيه دڤاوڬيت >>> count_distinct_characters (((\"xyzXYZ\")) (3) >>> count_distinct_characters (((\"Jerry\")) (4)\nlong count_distinct_characters(std::string string) {\n",
        "canonical_solutions": "long count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n    for (char ch : string) {\n        distinct_chars.insert(std::tolower(ch));\n    }\n    return distinct_chars.size();\n}",
        "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
    },
    {
        "task_id": "HumanEval/17",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤڠاتورن ڤڠاتورن اين اداله سورت يڠ مروڤاكن نوتا موزيک دالم ڤرمات ASCII. ڤڠاتورن اكو اداله اونتوق مڠالسي ۏكتور سورت اينتڬري يڠ بركاءيتن دڠن ببراڤ بيات. اين اداله سبواه ليڬيند: 'o' note, lasts four beats 'o.o' - half note, lasts two beats 'o.o' - quater note, lasts one beat >>> parse_music. (توليسن: كاوسن ڤڠاتورن اين اداله ڤرماتورن يڠ مروڤاكن ساتو بيات دالم ڤرماتورن ASCII. ڤڠاتورن اكو اداله اونتوق مڠالسي ۏكتور سورت اينتڬري يڠ بركاءيتن دڠن ببراڤ بيات دڠن ڤرماتورن ASCII. ڤڠاتورن اكو اداله اونتوق مڠالسي ۏكتور ڤڠاتورن اين دڠن ڤرماتورن ڤڠاتورن اين دڠن ڤرلوڤيسين ڤرلوڤينت.\nstd::vector<long> parse_music(std::string music_string) {\n",
        "canonical_solutions": "std::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::istringstream iss(music_string);\n    std::string note;\n    \n    while (iss >> note) {\n        if (note == \"o\") beats.push_back(4);\n        else if (note == \"o|\") beats.push_back(2);\n        else if (note == \".|\") beats.push_back(1);\n    }\n\n    return beats;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/18",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠومڤولكن جومله-جومله يڠ دبريكن سوبسترينغ يڠ بوليه دتومڤوكن دالم سورت اوريڬينل. مڠحساب كيس-كيس يڠ برتنتڠن. >>> how_many_times((\"\"), (\"a\")) (0) >>> how_many_times((\"aaa\"), (\"a\") (3) >>> how_many_times(\"aaaa\"), (\"aa\") (3)\nlong how_many_times(std::string string, std::string substring) {\n",
        "canonical_solutions": "long how_many_times(std::string string, std::string substring) {\n    if (substring.empty()) return 0;\n    \n    long count = 0;\n    size_t pos = 0;\n    \n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++;  // Move one position forward to count overlapping occurrences\n    }\n    \n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/19",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤڠاتورن اداله سبواه سلاين يڠ دڤرچايأي دڠن ڤوست ڤڠاتورن دري 'صفر' هيڠڬ 'تاوم'. ڤيليهن يڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤ\nstd::string sort_numbers(std::string numbers) {\n",
        "canonical_solutions": "std::string sort_numbers(std::string numbers) {\n    std::unordered_map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    std::unordered_map<int, std::string> rev_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    std::istringstream iss(numbers);\n    std::vector<int> num_list;\n    std::string word;\n\n    while (iss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    std::sort(num_list.begin(), num_list.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) oss << \" \";\n        oss << rev_map[num_list[i]];\n    }\n\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"
    },
    {
        "task_id": "HumanEval/20",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري ۏيکتور يڠ دڤاوتيڠڬيكن دري نومبور (دڠن لڠسوڠ كيرا-كيرا دوا) ڤيليه دان مروڤاكن دوا يڠ ڤاليڠ كلوار لاڬي كڤد ستياڤ لاڬي دان مروڤاكنڽ دڠن اورڠ يڠ ترلالو كچيل (نمبور يڠ لاما، نومبور يڠ ڤاليڠ بسر). >>> find_closest_elements (((std::vector<float>(({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) (std::make_tuple (((2.0f, 2.2f)) >>> find_closest_elements (((std::vector<float>(({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float) 2.0f)) (std::make_tuple))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i - 1];\n            num2 = numbers[i];\n        }\n    }\n\n    return std::make_tuple(num1, num2);\n}",
        "test": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n"
    },
    {
        "task_id": "HumanEval/21",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت ۏكتور ارق (دري دوا ايليمن كونو) ، مڠاداكن ترنسفورما لينيار كڤد ۏكتور ڽن، جادي ارق يڠ ڤاليڠ لڠكڤ جاوت كاو ٠ ڠن يڠ ڤاليڠ راييك جاوت كاو ١ >>> rescale_to_unit ((((std::vector<float>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"
    },
    {
        "task_id": "HumanEval/22",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فلتر ڤيكتور ڤرنه دبريكن دري ڤرتي cppthon اونتوق اينتيجر >>> filter_integers((std::vector<std::any>({(std::string) \"a\", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::<long,map>), std::vector<long>(()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
        "canonical_solutions": "std::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(val));\n        } else if (val.type() == typeid(int)) {\n            result.push_back(std::any_cast<int>(val));\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/23",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤولاو ڤينڠ دري سورت دبري >>> string_length((\"\")) (0) >>> string_length((\"abc\")) (3)\nlong string_length(std::string string) {\n",
        "canonical_solutions": "long string_length(std::string string) {\n    return string.length();\n}",
        "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"
    },
    {
        "task_id": "HumanEval/24",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اونتوق نومبور n يڠ دڤاوڬيت، ماچم نومبور يڠ ڤاليڠ بسر يڠ منيمباڠ n سچارا سيبوق، لابه دري n >>> largest_divisor ((((15)) (5)\nlong largest_divisor(long n) {\n",
        "canonical_solutions": "long largest_divisor(long n) {\n    for (long i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"
    },
    {
        "task_id": "HumanEval/25",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيکتور ڤرچاي ڤاکتور ڤرمين ڤد ڤرکارا اينتڬري يڠ دبريکن دالم اورد دري يڠ ڤاليڠ کوچيڠ کڤد يڠ ڤاليڠ بسر. ستياڤ ڤاکتور بوليه دڤاکتورکن سڤرتي ڤڽاتوان ڤرچاي ڤرچاي ڤرکارا اينتڬري. ڤيکتور ڤرچاي ڤرچاي ڤرکارا اينتڬري بوليه بربيذا دڠن ڤربواتن سموا ڤاکتور >>> فکتوريز (((8)) (std::vector<long>({(long) 2, (long) 2, (long) 2})) >>> فکتوريز (((25)) (std::vector<long>({(long) 5, (long) 5})) >>> فکتوريز ((((70)) (std::vector<long>({(long) 2, (long) 5, (long) 7}))\nstd::vector<long> factorize(long n) {\n",
        "canonical_solutions": "std::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}",
        "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/26",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دري ۏيکتور اينتيجر، مڠحاصيلکن سموا ايليمن يڠ برلاکو لبيه دري ساتو. مڠحاصيلکن ڤرالتن ايليمن يڠ تله دڤرتوان اݢوڠ. >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> freq;\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"
    },
    {
        "task_id": "HumanEval/27",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اونتوق ستراين يڠ دبري، فليڤ كايسر مينيس كايسر اوتارا دان مينيس كايسر اوتارا. >>> flip_case ((((\"Hello\")) (\"HELLO\")\nstd::string flip_case(std::string string) {\n",
        "canonical_solutions": "std::string flip_case(std::string string) {\n    for (char &ch : string) {\n        if (std::islower(ch)) {\n            ch = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            ch = std::tolower(ch);\n        }\n    }\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"
    },
    {
        "task_id": "HumanEval/28",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كونكاتينات ڤيكتور ستراينڬ اونتوق منجادي ساتو ستراينڬ >>> كونكاتينات ((((std:: vector<std::string>())) (\"\") >>> كونكاتينات (((std:: vector<std::string>({(std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"
    },
    {
        "task_id": "HumanEval/29",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فلتر ڤيكتور انتر دري سورت يڠ برمولا دڠن ڤريفيکس يڠ دبريكن. >>> filter_by_prefix((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bcd\", (std::string) \"cde\", (stdstring) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) \"abc\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/30",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرجواڠن ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤون ڤوسيتيف ڤوسيتيف ڤوسيتيف ڤوسيتيف ڤوسيتيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف ڤوسيف\nstd::vector<long> get_positive(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/31",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ريترن ڤرنه جاوه جك ڤرنه دبريكن اداله ڤرم، دان ڤرنه جاوه جاوه جاوه. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4) (false) >>> is_prime(1) (false)\nbool is_prime(long n) {\n",
        "canonical_solutions": "bool is_prime(long n) {\n    if (n < 2) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/33",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فانسي ڽو مڠڬوناكن ۏيكتور l ڠن مروڤاكن ۏيكتور l' يڠ جادي ڽو ادتنتيك داوڠان l دالم اينديسيس يڠ هان بوليه دباڬي لي تيڬ، سيودڠكن ۏيليوڽ دالم اينديسيس يڠ بوليه دباڬي لي تيڬ سام دڠن ۏيليو اينديسيس يڠ بربيذا دري l، تتاڤي دسيورت. >>> sort_third((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third((std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std::vector<(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long 5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> third_indices;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = third_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/34",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن ايليمن يڠ دڤرتيمبڠ يڠ برڤرتيكاي دالم ۏيكتور >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))\nstd::vector<long> unique(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"
    },
    {
        "task_id": "HumanEval/35",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن ايليمن ماكسيما دالم ۏيكتور. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)\nlong max_element(std::vector<long> l) {\n",
        "canonical_solutions": "long max_element(std::vector<long> l) {\n    return *std::max_element(l.begin(), l.end());\n}",
        "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"
    },
    {
        "task_id": "HumanEval/36",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن ڤندودوق يڠ دڤرتوان اڬوڠ دالم ڤرلمباڬان يڠ دڤرتوان اڬوڠ يڠ دڤرتوان اڬوڠ\nlong fizz_buzz(long n) {\n",
        "canonical_solutions": "long fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"
    },
    {
        "task_id": "HumanEval/37",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فانسي ڽو مڠڬوناكن ۏيكتور l ڠن مروڤاكن ۏيكتور l' يڠ جاوت كاو l يڠ ادنتيك كاو l دالم اينديكسي يڠ هان لڠسوڠ، سيودڠكن ۏيليوڽ دالم اينديكسي يڠ لڠسوڠ سام كاو ۏيليو اينديكسي يڠ لڠسوڠ دري l، تتاڤي دڤاوڬيت. >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<((({(long) 3, (long) 6, (long) 5, (long) 4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"
    },
    {
        "task_id": "HumanEval/39",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib مروڤاكن نومبور ن-تڠه يڠ اداله نومبور فيبوناتچي دان اي جوڬ ڤرميت. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib((3)) (5) >>> prime_fib((4)) (13) >>> prime_fib((5)) (89)\nlong prime_fib(long n) {\n",
        "canonical_solutions": "bool is_prime(long num) {\n    if (num < 2) return false;\n    if (num < 4) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong prime_fib(long n) {\n    std::vector<long> prime_fibs;\n    long a = 1, b = 1;\n    while (prime_fibs.size() < n) {\n        long next = a + b;\n        a = b;\n        b = next;\n        if (is_prime(next)) {\n            prime_fibs.push_back(next);\n        }\n    }\n    return prime_fibs[n - 1];\n}",
        "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"
    },
    {
        "task_id": "HumanEval/40",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triple_sum_to_zero مروڤاكن ۏكتور انتيجر سباڬاي اينترو. اي مروڤاكن سچارا اڤابيلا ترداڤت تيڬ ايليمن دالم ۏكتور يڠ مروڤاكن سومتڽ كڤد صفر، دان فالي سنديري. >>> triple_sum_to_zero (((std::vector<long>(long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triple_sum_to_zero (((std::vector<long>(long) 1, (long) 3, (long)-2, (long) 1} >>> (true) triple_sum_to_zero (((std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) >>> triple_sum_to_zero (((std::vector<long>(long) 2, (long) 4, (long) 5, (long) 3, (long) 9, (long) 7))) (true) >>> triple_sum_long_long))) (false) >>> triple_sum_long_long\nbool triples_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n - 2; i++) {\n        size_t left = i + 1, right = n - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    \n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/41",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠتاهوي جالن يڠ سڤرتي جالن يڠ تيدق برتولق. n ڤرڬي مڠهادڤي كلوارڬ دري كيري كاو كاو كاو ليم. ڤرڬي يڠ لاين دري كلوارڬ دري كاو ليم. دوا ڤرڬي ڤرڬي مڠهادڤي كاو ليم دري كاو ليم. كاو ليم برڬرق دڠن كاو ليم. دوا ڤرڬي دكاتاكن مڠهادڤي كاو ليم دڠن ڤرڬي يڠ مڠهادڤي كاو ليم. نامون، ڤرڬي ايت ساڠت برتولق دان قوات. جادي، ڤرڬي ايت تروس برڬرق دالم ڤرڬيڽ سڤرتي تيدق مڠهادڤي. فانسي اين مڠهادڤي ڤرڬي يڠ مڠهادڤي.\nlong car_race_collision(long n) {\n",
        "canonical_solutions": "long car_race_collision(long n) {\n    return n * n;\n}",
        "test": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
    },
    {
        "task_id": "HumanEval/42",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور ريڤورت دڠن ايليمن يڠ دڤرتوان اكن دڤرتوان 1. >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list(((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> incr_list(std::vector<long> l) {\n    for (long &num : l) {\n        num++;\n    }\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"
    },
    {
        "task_id": "HumanEval/43",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero مروڤاكن ۏكتور انتيجر سباڬاي اينترو. اي مروڤاكن سچارا تيدق اڤابيلا ترداڤت دوا ايليمن يڠ بربيدا دالم ۏكتور يڠ مروڤاكن سومتڽ هيڠڬ صفر، دان فالي سنديري. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long)-2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long> (long) 2, (long) (4, (long) (long) (5, (long) 3, (long) 5, (long) 7)) >>> (true) pairs_sum_long))) (true) >>> (long_se)\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (long num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/44",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠوبه اساس نوميريال دري نومر ڤڠمبيلن x كڤد اساس. مڠوبه ڤرسمبهن ستراين ستله ڤڠمبيلن. نومر اساس اداله كورڠ دري 10. >>> مڠوبه_باس(((8), (3)) (\"22\") >>> مڠوبه_باس((8), (2)) (\"1000\") >>> مڠوبه_باس((7), (2)) (\"111\")\nstd::string change_base(long x, long base) {\n",
        "canonical_solutions": "std::string change_base(long x, long base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"
    },
    {
        "task_id": "HumanEval/45",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري لڠسوڠ سيبوق ڠن لوڠسوڠ ڤيلاي ڤرتومبوهن. >>> ڤيلاي ڤرتومبوهن (((5), (3)) (7.5f)\nfloat triangle_area(long a, long h) {\n",
        "canonical_solutions": "float triangle_area(long a, long h) {\n    return 0.5f * a * h;\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/46",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤڠاروه ڤڠاروه Fib4 اداله ڤڠاروه يڠ سام دڠن ڤڠاروه Fibbonacci يڠ دڤرچايأي سڤرتي يڠ دڤرتوان اڤ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). جاديكن ڤڠاروه يڠ بركاءيتن اونتوق مڠحساب ايليمن ك-ن ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه\nlong fib4(long n) {\n",
        "canonical_solutions": "long fib4(long n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 2;\n\n    for (long i = 4; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"
    },
    {
        "task_id": "HumanEval/47",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست\nfloat median(std::vector<long> l) {\n",
        "canonical_solutions": "float median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    if (n % 2 == 1) {\n        return static_cast<float>(l[n / 2]);\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
    },
    {
        "task_id": "HumanEval/48",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// چريتاكن اڤابيلا سورت دبريكن اداله ڤاليندروم >>> is_palindrome (((\"\")) (true) >>> is_palindrome (((\"aba\")) (true) >>> is_palindrome (((\"aaaaa\")) (true) >>> is_palindrome (((\"zbcd\")) (false)\nbool is_palindrome(std::string text) {\n",
        "canonical_solutions": "bool is_palindrome(std::string text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());\n}",
        "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/49",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرجالنن 2^n مودولو p (تڤت دالم نوميريک). >>> modp(((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp((0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101)) (1)\nlong modp(long n, long p) {\n",
        "canonical_solutions": "long modp(long n, long p) {\n    return std::pow(2, n) % p;\n}",
        "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/51",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels اداله فانکشن يڠ مڠمبيل سترين دان مڽرو سترين تنڤا ۏوكل. >>> remove_vowels (((\"\")) (\"\") >>> remove_vowels (((\"abcdef\")) (\"bcdf\") >>> remove_vowels (((\"aaaaa\")) (\"\") >>> remove_vowels (((\"aaBAA\")) (\"B\") >>> remove_vowels (((\"zbcd\")) (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n",
        "canonical_solutions": "std::string remove_vowels(std::string text) {\n    std::string result;\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"
    },
    {
        "task_id": "HumanEval/52",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ريترن سچارا جادي سياڤاڤا ڤڠاروه دالم ۏيكتور l اد د دالم تيمڤوه t. >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)\nbool below_threshold(std::vector<long> l, long t) {\n",
        "canonical_solutions": "bool below_threshold(std::vector<long> l, long t) {\n    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });\n}",
        "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/53",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جومله دوا نومبور x دان y >>> جومله ((((2), (3)) (5) >>> جومله (((5), (7)) (12)\nlong add(long x, long y) {\n",
        "canonical_solutions": "long add(long x, long y) {\n    return x + y;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/54",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// چك ڤون دوا كات نا حروف يڠ سام. >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) (true) >>> same_chars((\"abcd\"), (\"dddddddabc\")) (true) >>> same_chars(\"dddddddabc\"), (\"abcd\") (true) >>> same_chars((\"eabcd\"), (\"dddddddabc\")) (false) same_chars >>>\"((abcd\"), (\"dddddddabce\") (false) >>> same_chars((\"eabcd\"), (\"ddddzzzzzdzzdddabc\") (false)\nbool same_chars(std::string s0, std::string s1) {\n",
        "canonical_solutions": "bool same_chars(std::string s0, std::string s1) {\n    std::unordered_set<char> set0(s0.begin(), s0.end());\n    std::unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}",
        "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/55",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن نومبور فيبوناتشي n-ه. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)\nlong fib(long n) {\n",
        "canonical_solutions": "long fib(long n) {\n    if (n <= 1) return n;\n    \n    long a = 0, b = 1, c;\n    for (long i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    \n    return b;\n}",
        "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"
    },
    {
        "task_id": "HumanEval/56",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets اداله ستريڠ \"<\" دان \">\". return true اڤابيلا ستياڤ bracket ڤمبوكاين اداله بركاءيتن بركاءيتن ڤمبوكاين. >>> correct_bracketing((\"<\")) (false) >>> correct_bracketing(\"<>\")) (true) >>> correct_bracketing(\"<><>\")) (true) >>> correct_bracketing(\">(<>\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') balance++;\n        else if (ch == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/57",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing. >>> monotonic ((((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20)) (true) >>> monotonic ((((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10)) (false) >>> monotonic ((((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10)) (true)\nbool monotonic(std::vector<long> l) {\n",
        "canonical_solutions": "bool monotonic(std::vector<long> l) {\n    bool increasing = true, decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n    }\n    \n    return increasing || decreasing;\n}",
        "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/58",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن ايليمن كومين يڠ برڤريڠكت اونتوق دوا ۏيكتور. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
        "canonical_solutions": "std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n    std::unordered_set<long> result_set;\n    \n    for (long num : l2) {\n        if (set1.count(num)) {\n            result_set.insert(num);\n        }\n    }\n    \n    std::vector<long> result(result_set.begin(), result_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/59",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مروڤاكن فكتور ڤرايم يڠ ڤاليڠ ڤاليڠ بسر دري n. مڠاتسي n > 1 دان هان اداله فكتور ڤرايم. >>> ڤرايم_فكتور ڤرايم يڠ ڤاليڠ بسر (((13195)) (29) >>> ڤرايم_فكتور ڤرايم يڠ ڤاليڠ بسر (((2048)) (2)\nlong largest_prime_factor(long n) {\n",
        "canonical_solutions": "long largest_prime_factor(long n) {\n    long largest = -1;\n    \n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    if (n > 1) largest = n;\n    \n    return largest;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"
    },
    {
        "task_id": "HumanEval/60",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n اداله فانسي يڠ مڽومبڠكن نومبور دري ١ سمڤأي n. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)\nlong sum_to_n(long n) {\n",
        "canonical_solutions": "long sum_to_n(long n) {\n    return n * (n + 1) / 2;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"
    },
    {
        "task_id": "HumanEval/61",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets اداله ستريڠ \"(\" دان \")\". مروڤاكن سچارا سچارا اڤابيلا ستياڤ bracket ڤمبوكاين اداله بركاءيتن بركاءيتن ڤمبوكاين. >>> correct_bracketing((\"(\")) (false) >>> correct_bracketing(\"() \") (true) >>> correct_bracketing(\"(()))))) (true) >>> correct_bracketing((\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') balance++;\n        else if (ch == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/62",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs ممڤوڽاءي کويفيتيف ڤولينوم. xs[0] + xs[1] * x + xs[2] * x^2 + .... مڽوکوڠ ديريۏيتيف ڤولينوم اين دالم بنتوق يڠ سام. >>> ديريۏيتيف (((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> ديريۏيتيف (((std::vector<long>({(long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n",
        "canonical_solutions": "std::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (size_t i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/63",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤڠاروه ڤڠاروه FibFib اداله ڤڠاروه يڠ سام دڠن ڤڠاروه Fibbonacci يڠ دڤرچايأي سڤرتي يڠ دڤرتوان اڤ: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3 . كلواركن منوليس فانسي اونتوق مڠحساب ايليمن ك-ن ڤڠاروه ڤڠاروه ڤڠاروه ڤڠاروه fibfib. >>> fibfib((1)) (0) >>> fib((5)) (4) >>> fib(8)) (24)\nlong fibfib(long n) {\n",
        "canonical_solutions": "long fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"
    },
    {
        "task_id": "HumanEval/64",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي vowels_count يڠ مڠڬوناكن ستريڠ يڠ مروڤاكن ساتو كلمأن سباڬاي اينڤوت دان مروڤاكن ڤڠتاهوان ۏوكل دالم ستريڠ. ۏوكل دالم كيس اين اداله 'a', 'e', 'i', 'o', 'u'. دمان، 'y' جوڬ اداله ۏوكل، تتاڤي ڤون ڤد اخير كلمأن. چونتوه: >>> vowels_count (((\"abcde\")) (2) >>> vowels_count (((\"ACEDY\")) (3)\nlong vowels_count(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  for (char c : s) {\n    if (vowels.count(c)) {\n      count++;\n    }\n  }\n  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n    count++;\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/65",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سيڤليرل مڠڬوناكن ديڬيت انتيڬر x، مڠڬوناكن ديڬيت ك دالم سيوستيق دڠن مڠڬوناكن ديڬيت ك دالم ك دالم سيوترنتس. جك مڠڬوناكن ديڬيت > جومله ديڬيت، مڠڬوناكن ديڬيت يڠ دڤرتڠڬوڠجوابكن. >>> سيڤليرل_مڠڬوناكن (((12), (1)) (\"21\") >>> سيڤليرل_مڠڬوناكن (((12), (2)) (\"12\")\nstd::string circular_shift(long x, long shift) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (n == 0) {\n    return \"\";\n  }\n  shift %= n;\n  if (shift < 0) {\n    shift += n;\n  }\n  if (shift == 0) {\n    return s;\n  }\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);\n  return shifted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"
    },
    {
        "task_id": "HumanEval/66",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤرکارا منوليس فانسي يڠ مڠݢوناکن سکرين سباݢاي اينڤوت دان مڽروڤاکن سومبڠن کراتير اوتام ASCII. چونتوه: >>> digitSum (((\"\")) (0) >>> digitSum (((\"abAB\")) (131) >>> digitSum (((\"abcCd\")) (67) >>> digitSum (((\"helloE\")) (69) >>> digitSum (((\"woArBld\")) (131) >>> digitSum (((\"aAXaaaa\")) (153)\nlong digitSum(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += static_cast<long>(c);\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"
    },
    {
        "task_id": "HumanEval/67",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دالم توكڠ اين، كامو اكن دبريكن سورت يڠ مروڤاكن ڤڽوكوڠ بيبس دان بيبس يڠ دڤربوات دالم سبواه كيس ميوا كيس اين مليڤوتي بيبس، بيبس، دان بيبس مانجو. دبريكن سورت يڠ مروڤاكن ڤڽوكوڠ بيبس دان بيبس سرتا اينتيڬر يڠ مروڤاكن ڤڽوكوڠ بيبس دالم كيس ممبريكن ڤڽوكوڠ بيبس دالم كيس. چونتوهڽ: >>> fruit_distribution (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nlong fruit_distribution(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0;\n  long oranges = 0;\n  size_t apples_pos = s.find(\"apples\");\n  if (apples_pos != std::string::npos) {\n    size_t start = 0;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    apples = std::stoll(s.substr(start, apples_pos - start));\n  }\n  size_t oranges_pos = s.find(\"oranges\");\n  if (oranges_pos != std::string::npos) {\n    size_t and_pos = s.find(\"and\");\n    size_t start = and_pos + 3;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    oranges = std::stoll(s.substr(start, oranges_pos - start));\n  }\n  return n - apples - oranges;\n}",
        "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"
    },
    {
        "task_id": "HumanEval/68",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"دڤن ۏكتور يڠ مروڤاكن سبواه ڤڠڬيل دري سدر يڠ نا نوڬو اينتيڬري نون-نيڬاتيف كاوجاڠنكو اداله اونتوق ممبنتو ساتو دري نوڬو-نوڬو دان مروڤاكنڽ. نوڬو يڠ دڤيليه ڤرلو جادي نوڬو دڠن ۏاليوم جاوت يڠ ڤاليڠ كلوار. جك ترداڤت ببراڤ نوڬو دڠن ۏاليوم جاوت يڠ نا اينديكس يڠ ڤاليڠ كلوار. نوڬو يڠ دڤيليه ڤرلو دڤيليه دالم ۏكتور، [smallest_value، ايندكسڽ]، جك تيدق اد ۏاليوم جاوت اتاو ۏكتور يڠ دڤيليه ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ، مروڤاكن []. چونتوه 1: >>> pluck{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> pluck(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> pluck(std::vector<long> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n  long min_even = -1;\n  long min_index = -1;\n  for (long i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (min_even == -1 || arr[i] < min_even) {\n        min_even = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_even == -1) {\n    return {};\n  }\n  return {min_even, min_index};\n}",
        "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/69",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيکتور ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤوست ڤو\nlong search(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong search(std::vector<long> lst) {\n  std::map<long, long> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  long result = -1;\n  for (auto const& [value, count] : counts) {\n    if (value > 0 && count >= value) {\n      result = std::max(result, value);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/70",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤيكتور اينتڬري يڠ دبري، ڤيكتور ڤرلو دڤرچايا ?? ي دالم اوردين يڠ تيدق ڤندودوق. ڤرتنديڠن يڠ تيدق ڤندودوق، اداله اڤابيلا اكو مولا دڠن قدر مينيموم، لالو ماكسيما ڤيڠت اينتڬري يڠ دڤوڤوس، لالو مينيموم دان سباڬايڽ. چونتوه: >>> strange_sort_list{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  if (lst.empty()) {\n    return {};\n  }\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  long left = 0;\n  long right = lst.size() - 1;\n  bool take_min = true;\n  while (left <= right) {\n    if (take_min) {\n      result.push_back(lst[left++]);\n    } else {\n      result.push_back(lst[right--]);\n    }\n    take_min = !take_min;\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"
    },
    {
        "task_id": "HumanEval/71",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن اوبه دري تيڬ بواه تيڬ. مروڤاكن ڤلواڠ تيڬ بواه يڠ دڤرچايا ?? ي كڤد 2 تيتيق ديسمل اڤابيلا تيڬ بواه اياله تيڬ بواه يڠ بوليه دڤرچايا ?? ي. دالم لاڬي مروڤاكن -1 تيڬ بواه اياله تيڬ بواه يڠ بوليه دڤرچايا ?? ي اڤابيلا سومبڠن تيڬ بواه بواه اياله لبيه بسر دري تيڬ بواه. چونتوه: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())\nfloat triangle_area(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nfloat triangle_area(long a, long b, long c) {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1.0f;\n  }\n  double s = static_cast<double>(a + b + c) / 2.0;\n  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n  std::stringstream ss;\n  ss << std::fixed << std::setprecision(2) << area;\n  return std::stof(ss.str());\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n"
    },
    {
        "task_id": "HumanEval/72",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مروڤاكن كڤد ڤركمبڠن يڠ برڤونچا درڤد اوبجيكت q يڠ بوليه مڠهادڤي، دان ڤركمبڠن يڠ بوليه مڠهادڤي جك اوبجيكت q بوليه مڠهادڤي جك تيدق بوليه مڠهادڤي (ڤركمبڠن اين ڤاليندروم) دان سومبڠن ايليمنڽ اداله كورڠ اتاو سام دڠن ڤركمبڠن ماكسيما يڠ موڠكين. چونتوه: >>> will_it_fly((std::vector<long>({long>{long}1, (long) 2}), (5)) (false) # 1+2 اداله كورڠ درڤد ڤركمبڠن ماكسيما يڠ موڠكين، تتاڤي اي تيدق بوليه مڠهادڤي. >>> will_it_fly(((((std::vector<long>{long>{long}3, (long) {2, (long)) (long)) (true)) # 1+2 دان (5)) يڠ ڤركمبڠن يڠ ڤركمبڠن يڠ درڤد ڤركمبڠن يڠ ماكسيما يڠ موڠكين، تتاڤي، تتاڤي اداله كورڠ درڤد ڤركمبڠن يڠ موڠكين.\nbool will_it_fly(std::vector<long> q, long w) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> reversed_q = q;\n  std::reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n  long sum = 0;\n  for (long val : q) {\n    sum += val;\n  }\n  return sum <= w;\n}",
        "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/73",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور ار ار، منوليسكن كمودهن ايليمن يڠ ڤرلو دڤراوليه اونتوق منجادي ڤيكتور ڤاليندروميك. ڤيكتور ڤاليندروميك اداله ڤيكتور يڠ دڤراوليه سام ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤنوه ڤد ڤد ڤنوه ڤد ڤد ڤنوه ڤد ڤد ڤد ڤنوه ڤد ڤد ڤد ڤنوه ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤ\nlong smallest_change(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long changes = 0;\n  for (long i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n  return changes;\n}",
        "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/74",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جك دوا ڤيكتور ڤيڠڬيرن دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠڬيرن يڠ دتاهن دڠن ڤيڠ دتاهن دتاهن دڠن ڤيڠ دتاهن دتاهن دڠن ڤيڠ دتاهن دتاهن دتاهن دڠن ڤيڠ دتاهن دتاهن دتاهن دتاهن دڠن ڤيڠ ڤيڠڬيرن يڠ دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن دتاهن د\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  long count1 = 0;\n  for (const std::string& s : lst1) {\n    count1 += s.length();\n  }\n  long count2 = 0;\n  for (const std::string& s : lst2) {\n    count2 += s.length();\n  }\n  if (count1 <= count2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/75",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مروڤاكن فنتكس يڠ تله دبريكن سچارا سست سڤرتي ڤربواتن دري 3 ڤرميت دان فول سڤرتي لاينڽ. دڠن معلومت بهاوا (a) اداله كورڠ دري 100. چونتوه: >>> is_multiply_prime((30)) (true) 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_multiply_prime(long a) {\n  if (a <= 0) {\n    return false;\n  }\n  std::vector<int> primes;\n  std::vector<bool> is_prime(100, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int p = 2; p * p < 100; p++) {\n    if (is_prime[p]) {\n      for (int i = p * p; i < 100; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (int p = 2; p < 100; p++) {\n    if (is_prime[p]) {\n      primes.push_back(p);\n    }\n  }\n  int count = 0;\n  for (int p1 : primes) {\n    if (a % p1 == 0) {\n      count++;\n      int rem = a / p1;\n      for (int p2 : primes) {\n        if (rem % p2 == 0) {\n          count++;\n          int rem2 = rem / p2;\n          for (int p3 : primes) {\n            if (rem2 == p3) {\n              count++;\n              if (count == 3) {\n                return true;\n              }\n              count--;\n            }\n          }\n          count--;\n        }\n      }\n      count--;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/76",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤركارا توك اياله اونتوق منوليس فڠسي يڠ مروڤاكن صحيح جك ڤيهق x اداله كواس سيبوق n دان فڠسي دري كاسوس لاين. x اداله كواس سيبوق n جك n**int=x. چونتوهڽ: >>> is_simple_power((1), (4) (true) >>> is_simple_power(2), (2) (true) >>> is_simple_power(8), (2) (true) >>> is_simple_power(3), (2) (false) >>> is_simple_power(3), (1) (false) >>> is_simple_power(5), (3) (false)\nbool is_simple_power(long x, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_simple_power(long x, long n) {\n  if (x == n) return true;\n  if (n == 1) return x == 1;\n  if (n == 0) return x == 0;\n  if (x == 0) return false;\n  if (x == 1) return true;\n  long power = n;\n  while (power < x) {\n    if (x % n != 0) return false;\n    if (power > x / n) return false;\n    power *= n;\n  }\n  return power == x;\n}",
        "test": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/77",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مڠڬوناكن انجيرو a دان مروڤاكن فاڽق اڤابيلا اينڬير اين اداله كوب سأورڠ انجيرو. تيتيق: اندا موڠكين مڠاتكن انجيرو سداڠ فاڽق. چونتوه: >>> iscube((1)) (true) >>> iscube((2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube(0)) (true) >>> iscube((180) (false)\nbool iscube(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool iscube(long a) {\n  if (a == 0) return true;\n  long abs_a = std::abs(a);\n  long root = round(std::cbrt(abs_a));\n  return root * root * root == abs_a;\n}",
        "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/78",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو تله دتاكوتكن اونتوق منوليس فانسي يڠ منريما ارق هيكسديسمال سباڬاي سورت دان مڠحسابكن ڤندودوق هيكسديسمال يڠ اداله ڤرمين (ارق ڤرمين، اتاو ڤرمين، اداله ڤرمين طبيعي يڠ لبيه بسر دري 1 يڠ تيدق منجادي ڤرودوق دري دوا ارق طبيعي يڠ لبيه کوچيڠ). ارق هيكسديسمال اداله 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ارق ڤرمين اداله 2, 3, 5, 7, 11, 13, 17,...، مك اكو ڤرلو مميليه ببراڤ ارق يڠ توروت: 2, 3, 5, 7, B (= ديسيمل 11), D (= ديسيمل 13). تڠكڤ: اكو موڠكين مڠيكوت ڤرمين ايت سداڠ ڤرنه باءيق اتاو بياس، دان سيمبول A,B,C,D,E,F سداڠ دتيق ڤرنه برڤيسه. چونتوهن: >>> hex_((AB\"key\") >>> hex_1\") >>>hex_10\") >>>hex_10\") >>>hex_10\") >>>hex_10\") >>>hex_7\") >>>7\") >>>7\") >>>7\") >>>7\") >>>7\") >>>7\") >>>7\") >>>8\") >>>8\") >>>7\") >>>7\") >>>7\")\nlong hex_key(std::string num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong hex_key(std::string num) {\n  long count = 0;\n  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};\n  for (char c : num) {\n    if (prime_hex.count(c)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/79",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو اكن دبريكن نومبور دالم بنتوق ديسيمل دان ڤركارا اكو اداله اونتوق مڠمبيلڽ كڤد بنتوق باينري. فانسي داڤت مڠلواركن ستراين، دڠن ستياڤ كاراكتر ممڤرتاهنكن نومبور باينري. ستياڤ كاراكتر دالم ستراين اكن منجادي '0' اتاو '1'. اكو اكن اد جوت كاراكتر 'db' د اول دان اخير ستراين. كاراكتر٢ يڠ لبيه اد اونتوق ممبنتو دڠن بنتوق. چونتوه: >>> decimal_to_binary (((15)) (\"db1111db\") >>> decimal_to_binary (((32)) (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0) {\n    return \"db0db\";\n  }\n  std::string binaryString = \"\";\n  long temp = std::abs(decimal);\n  while (temp > 0) {\n    binaryString = (temp % 2 == 0 ? \"0\" : \"1\") + binaryString;\n    temp /= 2;\n  }\n  return \"db\" + binaryString + \"db\";\n}",
        "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
    },
    {
        "task_id": "HumanEval/80",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// سياڤاڤا يڠ دبريكن string s. ڤركارا يڠ دڤرلوكن اياله اونتوق مڠيكوت اڤابيلا string ايت hapcpp اتاو تيدق. string اياله hapcpp اڤابيلا لڠكهڽ كيرا-كيرا 3 دان ستياڤ 3 حروف يڠ برتراڤ اداله بربيذا. چونتوهڽ: >>> is_happy (((\"a\")) (false) >>> is_happy (((\"aa\")) (false) >>> is_happy (((\"abcd\")) (true) >>> is_happy (((\"aabb\")) (false) >>> is_happy (((adb)) (true) >>> is_happy (((xyy)) (false)\nbool is_happy(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (size_t i = 0; i <= s.length() - 3; ++i) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/81",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"اينله جم اخير سمستير دان ڬورو ڤرلو ممبريكن ڬراد كڤد ڤلاجر. ڬورو تله ممبنتو الورڬيتم ڤنربڠنڽ اونتوق ڬراد. سسواتو يڠ ڤرلو دڤرچايأي اداله، دي تله ممبريكن ۏكتور ڬراد كڤد ببراڤ ڤلاجر دان دي ڤرلو منوليس فڠڬونا يڠ بوليه مڠحاصيلكن ۏكتور ڬراد بريتا دڠن مڠڬوناكن تابوڠ يڠ دڤرتوان اڤي: ڬراد بريتا 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E چونتوه: >>>_grade equation\"\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float gpa : grades) {\n    if (gpa == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (gpa > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (gpa > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (gpa > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (gpa > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (gpa > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (gpa > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (gpa > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (gpa > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (gpa > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (gpa > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (gpa > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/82",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مڠڬوناكن ستراين دان مروڤاكن صحيح اڤابيلا لڠسوڠ ستراين اداله ڤرميت اتاو غلط لاڬي چونتوه >>> prime_length (((\"Hello\")) (true) >>> prime_length (((\"abcdcba\")) (true) >>> prime_length (((\"kittens\")) (true) >>> prime_length (((\"orange\")) (false)\nbool prime_length(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nbool prime_length(std::string string) {\n  return is_prime(string.length());\n}",
        "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/83",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن اينتيڬر ڤوسيتيف n، مروڤاكن كونتوم ڤوسيتيف اينتيڬر ن-دجيت يڠ برمولا اتاو ماولاي دڠن 1.\nlong starts_one_ends(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n  long starts_with_one = std::pow(10, n - 1);\n  long ends_with_one = std::pow(10, n - 1);\n  long starts_and_ends_with_one = std::pow(10, n - 2);\n  return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}",
        "test": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n"
    },
    {
        "task_id": "HumanEval/84",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن انجيڠ ڤوسيتيف N، مروڤاكن سومبڠن جمڤوت ديڬيتڽ دالم بيناير. چونتوه >>> solve((1000)) (\"1\") >>> solve((150)) (\"110\") >>> solve((147)) (\"1100\") ڤريابيل: @N انجيڠ كونتراينت: 0 ≤ N ≤ 10000. اوڤتوت: سابوه سترينغ دالم بيناير\nstd::string solve(long N) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string solve(long N) {\n  if (N < 0 || N > 10000) {\n    return \"\"; // Or handle invalid input as needed\n  }\n  long sum = 0;\n  std::string s = std::to_string(N);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  if (sum == 0) {\n    return \"0\";\n  }\n  std::string binary_sum = \"\";\n  while (sum > 0) {\n    binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n    sum /= 2;\n  }\n  return binary_sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n"
    },
    {
        "task_id": "HumanEval/85",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور يڠ هان بيدا دري اينتيڬر lst. ماجوكن ايليمن ڤرڬي يڠ د اينديكس ڤرڬي.. چونتوه: >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7}))) (2)\nlong add(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/86",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مڠڬوناكن ستراين دان مڽروڤاكن ۏرسي يڠ دترتبتكن. ۏرسي يڠ دترتبتكن دري ستراين، اداله ستراين د مان سموا كلمات (دڤرباڬايكن دڠن ڤڠالمن) دڤڠالومكن دڠن ساتو كلمات بارو د مان سموا حروف دترتبتكن دڠن ڤڠالمن يڠ مڠورڠكن برتيندق ڤنتيڠ. تيتق: اكو ڤرلو مڠحفظ ڤڠالمن كلمات دان ڤڠالمن ڤڠالمن دالم سيسي. چونتوهڽ: >>> anti_shuffle(\"Hi\")) (\"Hi\") >>> anti_shuffle((\"hello\")) (\"ehllo\") >>> anti_shuffle\"((Hello World!!!\")) (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string anti_shuffle(std::string s) {\n  std::string result = \"\";\n  std::string current_word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      std::sort(current_word.begin(), current_word.end());\n      result += current_word;\n      result += c;\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  std::sort(current_word.begin(), current_word.end());\n  result += current_word;\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"
    },
    {
        "task_id": "HumanEval/87",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// (1) دبري lst, دان integer x, ليهت integer x دالم ۏكتور, دان ڤيکتور ڤرلو دبري ڤيکتور، [(x1, y1), (x2, y2) ...] سڤرتي بهاوا ستياڤ ۏكتور اداله ڤوستوکوردينات - (row, columns), برمولا دڠن 0. منوروت ڤوستوکوردينات ڤولا دڠن ۏکتور دالم اوروسن يڠ بركمبڠ. جوݢ، منوروت ڤوستوکوردينات ۏکتور دالم اوروسن يڠ بركمبڠ. چونتوه: >>> get_row(std::vector<std::vector<>>>>{(std::vector<long>)::std::vector<long>، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); ++i) {\n    std::vector<std::pair<long, long>> row_coords;\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        row_coords.push_back({j, i});\n      }\n    }\n    std::sort(row_coords.rbegin(), row_coords.rend());\n    for (const auto& coord_pair : row_coords) {\n      coordinates.emplace_back(coord_pair.second, coord_pair.first);\n    }\n  }\n  return coordinates;\n}",
        "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"
    },
    {
        "task_id": "HumanEval/88",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور انتيجر يڠ هان نڬاتيف، مروڤاكن كوكڤ ڤيكتور يڠ دبري ستله ڤمبنتوقن، جك ڤيكتور يڠ دبري دالم اوردين مڠورڠكن جك سوم ((دري ايندكس ڤرتام، ددري ايندكس اخير)) اداله ڤرنه، اتاو جك ڤيكتور يڠ دبري دالم اوردين مڠورڠكن جك سوم ((دري ايندكس ڤرتام، ددري ايندكس اخير)) اداله ڤرنه. تڠكڤ: * تيدق مڠوبه ڤيكتور يڠ دبري. چونتوه: >>> sort_array(std::vector<long>(())) (std::vector<long>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> sort_array(std::vector<long> array) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if (sorted_array.empty()) {\n    return sorted_array;\n  }\n  long first = 0;\n  long last = sorted_array.size() - 1;\n  if ((first + last) % 2 != 0) {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    std::sort(sorted_array.rbegin(), sorted_array.rend());\n  }\n  return sorted_array;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"
    },
    {
        "task_id": "HumanEval/89",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فڠسي encrypt يڠ مڠڬوناكن سترين سباڬاي ارڬومنت دان مڽروڤاكن سترين يڠ دكنلي دڠن حروف الفبيت يڠ دڤرتڠڬوڠجوابكن. حروف الفبيت ڤرلو دكنلي دڠن چارا يڠ مڽروڤاكن حروف دڠن دوا يڠ دكلواركن كدوا جاڠن. چونتوهڽ: >>> encrypt (((\"hi\")) (\"lm\") >>> encrypt (((\"asdfghjkl\")) (\"ewhjklnop\") >>> encrypt (((\"gf\")) (\"kj\") >>> encrypt (((\"et\")) (\"ix\")\nstd::string encrypt(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encrypt(std::string s) {\n  std::string encrypted_s = \"\";\n  int shift = 2 * 2;\n  for (char c : s) {\n    if (isalpha(c)) {\n      char base = islower(c) ? 'a' : 'A';\n      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);\n    } else {\n      encrypted_s += c;\n    }\n  }\n  return encrypted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"
    },
    {
        "task_id": "HumanEval/90",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ڤيكتور انجيري. منوليس فانسي next_smallest ((() يڠ مروڤاكن ايليمن ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤوكتور ڤ\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];\n}",
        "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"
    },
    {
        "task_id": "HumanEval/91",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو اكن دبريكن سستڠه كلمات، دان ڤركارا اكو اداله اونتوق مڠحسابكن ڤندودوق يڠ بربيذا. ڤندودوق اداله سستڠه ڤركاتاءن يڠ برمولا دڠن كلمات \"I\". ڤركاتاءن دڤرچايا ?? ي دڠن '.', '?' اتاو '!'. چونتوهڽ: >>> is_bored((\"Hello world\")) (0) >>> is_bored((\"سماءن بليو. سڠه بربوك. ساي مڠهيدوڤكن اڤ يڠ برلاكو\")) (1)\nlong is_bored(std::string S) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong is_bored(std::string S) {\n  long boredom_count = 0;\n  std::string current_sentence = \"\";\n  for (char c : S) {\n    current_sentence += c;\n    if (c == '.' || c == '?' || c == '!') {\n      std::stringstream ss(current_sentence);\n      std::string first_word;\n      ss >> first_word;\n      if (first_word == \"I\") {\n        boredom_count++;\n      }\n      current_sentence = \"\";\n    }\n  }\n  return boredom_count;\n}",
        "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/92",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مڠمبيل 3 ڽن. مروڤاكن صحيح اڤابيلا ساله ساتو دري ڽن سام دڠن سومبڠن دوا يڠ لاين، دان سموا ڽن اداله اينتڬري. مروڤاكن غلط دالم سموا كيس لاين. چونتوه >>> any_int{(float{(5)) ، (float{(2)) ، (float{(7))) (true) >>> any_int{(((float{3)) ، (float{(2)) ، (float{(2))) (false) >>> any_int{((float{3)) ، (float{(-2) ، (float{(1))) (true) >>> any_int{((((3.6f) ، (-2.2f) ، (float{(2))) (false)\nbool any_int(float x, float y, float z) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool any_int(float x, float y, float z) {\n  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {\n    return false;\n  }\n  long ix = static_cast<long>(x);\n  long iy = static_cast<long>(y);\n  long iz = static_cast<long>(z);\n  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}",
        "test": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/93",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مڠيكوتي ڤرسوالن، دان مڠيكوتي دڠن چارا يڠ مڠيكوتي كيس سموا حروف، مڠيكوتي سموا ۏوكل دالم ڤرسوالن دڠن حروف يڠ برلاكو 2 ڤوست سبلوم ۏوكل دالم ابجد بهاس ايڠڬريس. مڠيكوتي ڤرسوالن. چونتوه: >>> encode (((\"test\")) (\"TGST\") >>> encode (((\"This is a message\")) (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::map<char, char> vowel_map = {\n      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n  for (char c : message) {\n    if (isalpha(c)) {\n      char swapped_case = islower(c) ? toupper(c) : tolower(c);\n      if (vowels.count(c)) {\n        encoded_message += vowel_map[c];\n      } else {\n        encoded_message += swapped_case;\n      }\n    } else {\n      encoded_message += c;\n    }\n  }\n  return encoded_message;\n}",
        "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
    },
    {
        "task_id": "HumanEval/94",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كيت دبري ۏكتور انتري. كيت ڤرلو مميليه ڤنتيڠ ڤرميت ڤاليڠ بسر دان مروڤاكن سومبڠن ديڬيتڽ. چونتوه: >>> skjkasdkd((std::vector<long>(({long) 0، (long) 3، (long) 2، (long) 1، (long) 3، (long) 5، (long) 7، (long) 4، (long) 5، (long) 5، (long) 2، (long) 18، (long) 32، (long) 32، (long) 4، (long) 3، (long) 2، (long) 2، (long) 3، (long) 3، (long) 3، (long) 3، (long) 4، (long) 5، (long) 6، (long) 7، (long) 8، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 8، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 8، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 4، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) 3، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long)\nlong skjkasdkd(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sum_digits(long n) {\n  long sum = 0;\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  return sum;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n  long largest_prime = -1;\n  for (long num : lst) {\n    if (num > largest_prime && is_prime(num)) {\n      largest_prime = num;\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return sum_digits(largest_prime);\n}",
        "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"
    },
    {
        "task_id": "HumanEval/95",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤىتا، ريترون ڤرچاي اڤابيلا سموا كليدا اداله ستريڠ دالم كيس مينور اتاو سموا كليدا اداله ستريڠ دالم كيس ماجو، ريترون ڤرچاي فولس. فانسي داڤت ريترون فولس اداله ڤرچاي يڠ دڤىتا بيلا. چونتوه: >>> check_dict_case ((((std::map<std::string,std::string>(({{\"a\", \"apple\"}, {\"b\", \"banana\"}}))) (true) >>> check_dict_case ((((((std::map,std::string,std::string>{{\"a\", \"apple\"}, {\"b\", \"banana\"}}))) (true) >>> check_dict_case (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n  bool first_key_lower = false;\n  bool first_key_upper = false;\n  auto it = dict.begin();\n  if (!it->first.empty() && islower(it->first[0])) {\n    first_key_lower = true;\n  } else if (!it->first.empty() && isupper(it->first[0])) {\n    first_key_upper = true;\n  } else {\n    return false;\n  }\n  for (const auto& pair : dict) {\n    if (pair.first.empty()) {\n      return false;\n    }\n    bool current_lower = true;\n    bool current_upper = true;\n    for (char c : pair.first) {\n      if (!islower(c)) {\n        current_lower = false;\n      }\n      if (!isupper(c)) {\n        current_upper = false;\n      }\n    }\n    if (first_key_lower && !current_lower) {\n      return false;\n    }\n    if (first_key_upper && !current_upper) {\n      return false;\n    }\n    if (!first_key_lower && !first_key_upper) {\n        if (current_lower) first_key_lower = true;\n        else if (current_upper) first_key_upper = true;\n        else return false;\n    }\n  }\n  return first_key_lower || first_key_upper;\n}",
        "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/96",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مڠمبيل اينتيجر يڠ هان نڬاتيف دان مروڤاكن ۏيكتور ڤرتام n اينتيجر يڠ اداله ڤرميت دان كلوار دري n. چونتوهڽ: >>> count_up_to((5)) (std::vector<long>{(long) 2, (long) 3}) >>> count_up_to(11) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7}) >>> count_up_to(0)) (std::vector<long>) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 19)) >>> count_up_1) (std::vector<long>>1 to (long) 8, count_up_to (long) 3, (long) 11, (long) 3, (long) 5, (long) 17)) (std (long) 1\nstd::vector<long> count_up_to(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long num) {\n  if (num <= 1) return false;\n  for (long i = 2; i * i <= num; ++i) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2) {\n    return primes;\n  }\n  for (long i = 2; i < n; ++i) {\n    if (is_prime(i)) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"
    },
    {
        "task_id": "HumanEval/97",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڽمبوت فانسي يڠ مڠڬوناكن دوا انتيڬره دان مروڤاكن ڤرودوک اونيت ديڬيت اونيت. مڠاتسي ڤڠمبيلن سداڠ ڤاليڠ ڤاليڠ. چونتوه: >>> مڠڬوناكن (((148), (412)) (16) >>> مڠڬوناكن (((19), (28)) (72) >>> مڠڬوناكن (((2020), (1851)) (0) >>> مڠڬوناكن (((14), (-15)) (20)\nlong multiply(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong multiply(long a, long b) {\n  long unit_a = std::abs(a) % 10;\n  long unit_b = std::abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/98",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت سترين s، منومبڠكن ڤڠڬيات ڤوكل اوتارا دالم اينديكس ڤرڤادوان. چونتوهڽ: >>> count_upper (((\"aBCdEf\")) (1) >>> count_upper (((\"abcdefg\")) (0) >>> count_upper (((\"dBBE\")) (0)\nlong count_upper(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong count_upper(std::string s) {\n  long count = 0;\n  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};\n  for (long i = 0; i < s.length(); ++i) {\n    if (i % 2 == 0 && upper_vowels.count(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/99",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مڠمبيل ڤرمايسوري (سترينق) يڠ مروڤاكن ساتو ڤرتي دان مروڤاكن انتيڬر يڠ ڤاليڠ كسلوروهنڽ. جك ڤرتي ايت بربيذا دري دوا ڤرتي، مڠمبيلڽ دري صفر. چونتوه >>> closest_integer (((\"10\")) (10) >>> closest_integer (((\"15.3\")) (15): مڠمبيل دري صفر برمعنى بهاوا جك ڤرتي يڠ دبري بربيذا دري دوا ڤرتي، ڤرتي يڠ ڤرلو دبريكن اياله ڤرتي يڠ ڤاليڠ ڤاليڠ لاما دري صفر. چونتوهڽ closest_integer (((\"14.5\") ڤرلو مروڤاكن 15 دان closest_integer (((-14.5\") ڤرلو مروڤاكن -15.\nlong closest_integer(std::string value) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    if (num - std::floor(num) <= 0.5) {\n      return static_cast<long>(std::floor(num));\n    } else {\n      return static_cast<long>(std::ceil(num));\n    }\n  } else {\n    if (std::ceil(num) - num <= 0.5) {\n      return static_cast<long>(std::ceil(num));\n    } else {\n      return static_cast<long>(std::floor(num));\n    }\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/100",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن انجيڠ ڤوسيتيف n، كامو ڤرلو ممبنتو ڤولڠ دري n تيڠكڤ ڤوتري. تيڠكڤ ڤرتام اد ڤوتري. ڤولڠ ڤوتري د تيڠكڤ يڠ لالو اداله: - ڤولڠ ڤوتري يڠ لالو جادي ڤوتري. - ڤولڠ ڤوتري يڠ لالو جادي ڤوتري جادي ڤوتري. منروسي ڤولڠ ڤوتري د ستياڤ تيڠكڤ دالم ۏكتور، د مان ايليمن د ايندكس i مروڤاكن ڤولڠ ڤوتري د تيڠكڤ (i+1). چونتوه: >>> make_a_pile((3) (std::vector<long>{long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long current_stones = n;\n  for (int i = 0; i < n; ++i) {\n    pile.push_back(current_stones);\n    if (current_stones % 2 != 0) {\n      current_stones += 2;\n    } else {\n      current_stones += 2;\n    }\n  }\n  return pile;\n}",
        "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"
    },
    {
        "task_id": "HumanEval/101",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جاديله ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤرماءينن ڤد ڤد ڤرماءينن ڤد ڤد ڤد ڤرماءينن ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤد ڤن ڤد ڤد ڤد ڤد ڤد ڤد ڤ\nstd::vector<std::string> words_string(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ',' || c == ' ') {\n      if (!current_word.empty()) {\n        words.push_back(current_word);\n        current_word = \"\";\n      }\n    } else {\n      current_word += c;\n    }\n  }\n  if (!current_word.empty()) {\n    words.push_back(current_word);\n  }\n  return words;\n}",
        "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/102",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فانسي ڽو مڠڬوناكن دوا نومبور ڤوسيتيف x دان y دان مروڤاكن نومبور انجيڬر ڤاليڠ راييك يڠ دالم رينج [x, y] يڠ مڠڬوناكن. جك هان اد نومبور يڠ لاڬي، فانسي ڽو ڤرلو مروڤاكن -1. چونتوهڽ: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)\nlong choose_num(long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  long end = y;\n  if (end % 2 != 0) {\n    end--;\n  }\n  if (end < x) {\n    return -1;\n  }\n  return end;\n}",
        "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"
    },
    {
        "task_id": "HumanEval/103",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// جك كيت دبري دوا عدد اينتيجر ڤوسيتيف n دان m، دان ڤركارا كيت اداله اونتوق مڠحساب ڤرتڠهن عدد اينتيجر دري n سمڤاي m (تنتوكن n دان m). مڠورونكن جواڤن كڤد عدد اينتيجر يڠ ڤاليڠ كوكوڠ دان مڠورونكن كڤد عدد باينري. جك n لبيه بسر دري m، مڠرجكن -1. چونتوه: >>> rounded_avg((1), (5)) \"0b11\" >>> rounded_avg((7), (5)) -1 >>> rounded_avg(10), (20)) \"0b1111\" >>> rounded_avg(20), (33) \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  double sum = 0;\n  for (long i = n; i <= m; ++i) {\n    sum += i;\n  }\n  double avg = sum / (m - n + 1);\n  long rounded_avg_long = std::round(avg);\n  if (rounded_avg_long == 0) {\n    return Union_std_string_long(\"0b0\");\n  }\n  std::string binary_string = \"\";\n  long temp = std::abs(rounded_avg_long);\n  while (temp > 0) {\n    binary_string = (temp % 2 == 0 ? \"0\" : \"1\") + binary_string;\n    temp /= 2;\n  }\n  return Union_std_string_long(\"0b\" + binary_string);\n}",
        "test": "}\nint main() {\n    auto candidate = rounded_avg;\n    assert(candidate((1), (5)) == \"0b11\");\n    assert(candidate((7), (13)) == \"0b1010\");\n    assert(candidate((964), (977)) == \"0b1111001010\");\n    assert(candidate((996), (997)) == \"0b1111100100\");\n    assert(candidate((560), (851)) == \"0b1011000010\");\n    assert(candidate((185), (546)) == \"0b101101110\");\n    assert(candidate((362), (496)) == \"0b110101101\");\n    assert(candidate((350), (902)) == \"0b1001110010\");\n    assert(candidate((197), (233)) == \"0b11010111\");\n    assert(candidate((7), (5)) == -1);\n    assert(candidate((5), (1)) == -1);\n    assert(candidate((5), (5)) == \"0b101\");\n}\n"
    },
    {
        "task_id": "HumanEval/104",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت ۏكتور ڤوسيتيف اينتيڬر x. مروڤاكن ۏكتور يڠ دڤرتيمبڠ دري سموا ايليمن يڠ تيدق ممڤوڽاءي ايكسيتيف. تيتيق: ۏكتور يڠ دڤرتيمبڠ ڤرلو دڤرتيمبڠ دالم اوروسن يڠ مڠكوكوڠ. چونتوهڽ: >>> unique_digits(std::vector<long>({long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{(long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{(long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool has_even_digit(long n) {\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    if ((c - '0') % 2 == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long val : x) {\n    if (!has_even_digit(val)) {\n      result.push_back(val);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"
    },
    {
        "task_id": "HumanEval/105",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىودىڤىڤىودىڤىودىڤىودىڤىڤىودىڤىڤىودىڤىودىڤىودىڤىڤىودىڤىڤىودىڤىودىڤىڤىودىڤىڤىودىڤىڤىودىڤىڤىودىڤىڤىودىڤىودىڤىودىڤىڤىودىڤىڤىودىڤىڤىودىڤىودىڤىودىڤىودىڤىڤىودىودىڤىڤىڤىودىڤىڤىودىڤىودىودىڤىڤىودىڤىڤىودىودىڤىودىڤىودىڤىڤىودىڤىڤىڤىودىودىڤىڤىودىڤىڤىودىڤىڤىڤى\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_numbers;\n  std::vector<std::string> result;\n  std::map<long, std::string> number_names = {\n      {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n      {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_numbers.push_back(num);\n    }\n  }\n  std::sort(valid_numbers.begin(), valid_numbers.end());\n  std::reverse(valid_numbers.begin(), valid_numbers.end());\n  for (long num : valid_numbers) {\n    result.push_back(number_names[num]);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/106",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي f يڠ مڠڬوناكن n سباڬاي ڤاراميتر، دان مروڤاكن ۏيكتور دري سيسي n، جادي ڤاليڠ ڤنتيڠ دري ايليمن د اينديكس i اداله فكتوريل i اڤابيلا i اداله ڤرڤادوان اتاو سومبڠن ارق دري 1 هيڠڬ i لاڬي. i برمولا دري 1. فكتوريل i اداله ڤربواتن ارق دري 1 هيڠڬ i (1 * 2 * ... * i). چونتوه: >>> f((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))\nstd::vector<long> f(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> f(long n) {\n  std::vector<long> result;\n  for (long i = 1; i <= n; ++i) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; ++j) {\n        factorial *= j;\n      }\n      result.push_back(factorial);\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; ++j) {\n        sum += j;\n      }\n      result.push_back(sum);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/107",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن اينتڬري ڤوسيتيف n، مروڤاكن ساتو توپل يڠ نا ڤاليندروم اينتڬري ڤرنه دان ڤرنه يڠ ترليبت دالم رينج ((1، n) ، ترماسوق. چونتوه 1: >>> even_odd_palindrome ((3)) (std::make_tuple ((1, 2)) ڤڠتاهوان: اينتڬري ڤاليندروم اداله 1، 2، 3. ساله ساتو دريڽ اداله ڤرنه، دان دوا دريڽ اداله ڤرنه. چونتوه 2: >>> even_odd_palindrome ((12)) (std::make_tuple ((4, 6)) ڤڠتاهوان: اينتڬري ڤاليندروم اداله 1، 2، 3، 4، 5، 6، 7، 8، 9، 11، چوچوڽ اداله ڤرنه، دان 6 دريڽ اداله ڤرنه. نوتا: 1. < 1= n= 10^3 < 2.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_palindrome(long num) {\n  std::string s = std::to_string(num);\n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  return s == reversed_s;\n}\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; ++i) {\n    if (is_palindrome(i)) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"
    },
    {
        "task_id": "HumanEval/108",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي count_nums يڠ مڠڬوناكن ۏيكتور انجيري دان مروڤاكن ڤڠڬونأن ايليمن يڠ نا سومبڠن ديڬيت > 0. اڤابيلا سابوه ڽن نڬاتيف، لالو ديڬيت ڤرتام يڠ دتوقيڽ اكن دتوقي نڬاتيف: چونتوهڽ -123 نا ديڬيت يڠ دتوقي -1, 2, دان 3. >>> count_nums ((((std::vector<long>())) (0) >>> count_nums (((std::vector<long>{(long) -1, (long) -11, (long) -11}))) (1) >>> count_nums (((std::vector<long>{(long) -1, (long) -1, (long) -2} (3))))\nlong count_nums(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_digits_signed(long n) {\n  std::string s = std::to_string(n);\n  long sum = 0;\n  for (long i = 0; i < s.length(); ++i) {\n    if (i == 0 && s[i] == '-') {\n      if (s.length() > 1) {\n        sum -= (s[i + 1] - '0');\n        i++;\n      }\n    } else {\n      sum += (s[i] - '0');\n    }\n  }\n  return sum;\n}\n\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    if (sum_digits_signed(num) > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/109",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// كيت اد ۏكتور 'arr' دري N اينتيڬر arr[1], arr[2], ..., arr[N].تارا ۏكتور ڽن اكن دڤرتيمبڠكن سچارا رندوم. ڤركارا كيت اداله اونتوق ممستيكن ۏكتور دڤرتيمبڠكن سچارا تيدق مڠورڠكن ملالوءي اوڤراسي يڠ دڤرتيمبڠكن دڤاكيت ۏكتور: كيت داڤت مڠورڠكن اوڤراسي ڤمبلاجرن دالم ڤاكتور يڠ دڤرتيمبڠكن. اوڤراسي ڤمبلاجرن دالم ڤاكتور يڠ دڤرتيمبڠكن دڤاكيت ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمبلاجرن ڤمڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤڤ\nbool move_one_ball(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n  int n = arr.size();\n  std::vector<long> sorted_arr = arr;\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n  for (int shift = 0; shift < n; ++shift) {\n    std::vector<long> shifted_arr(n);\n    for (int i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n    if (shifted_arr == sorted_arr) {\n      return true;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/110",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دالم مسئله اين، کامي اکن ممڤرکنلکن ڤرکارا يڠ مڠمبيل دوا ۏکتور ڤرکارا، دان ممستيکن اڤابيلا کامي ممڤوڽاءي ڤربادنن ايليمن انتارا ايليمن اونتوق منجاديکن lst1 سباݢاي ۏکتور ڤرکارا يڠ بربنديڠ. تيدق اد ڤڠحرامن اونتوق ڤربادنن ايليمن انتارا lst1 دان lst2. اڤابيلا کامي ممڤوڽاءي ڤربادنن ايليمن انتارا lst1 دان lst2 اونتوق منجاديکن سموا ايليمن lst1 بربنديڠ، ڤرلو مڽاتاکن \"YES\". دالم ماس لاين، ڤرلو مڽاتاکن \"NO\". چونتوهڽ: >>> exchange((std::vector<>(({long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(long}، (long) 4)) ، (YES) >>>(((std::vector<>{{(long}، (long) ، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long (long) (\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  long odd_count_lst1 = 0;\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      odd_count_lst1++;\n    }\n  }\n  long even_count_lst2 = 0;\n  for (long num : lst2) {\n    if (num % 2 == 0) {\n      even_count_lst2++;\n    }\n  }\n  if (even_count_lst2 >= odd_count_lst1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"
    },
    {
        "task_id": "HumanEval/111",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن ستريڠ يڠ مروڤاكن حروف-حروف مينوس يڠ دڤرباڬايكن سباڬاي ڤرالتن، مڠرجاكن ڤتا حروف يڠ ڤاليڠ ڤونچق دان مڠمبيل كونتينسي يڠ سام. چونتوه: >>> هيستوڬرم (((\"a b c\")) (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}})) >>> هيستوڬرم ((((\"a b a\")) (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})) >>> هيستوڬرم (((\"a b c a b\")) (std::map<std::string,long>{{\"a\", 2}, {\"b\", 2}})) >>> هيستوڬرم (((\"a b b b\") (std::std::string, 4\") >>> ({{\"b\"b\", 1}}) >>> هيستوڬرم (((\"a b)) (long))\nstd::map<std::string,long> histogram(std::string test) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> counts;\n  std::string current_word;\n  std::stringstream ss(test);\n  while (ss >> current_word) {\n    counts[current_word]++;\n  }\n  if (counts.empty()) {\n    return {};\n  }\n  long max_count = 0;\n  for (const auto& pair : counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n  std::map<std::string, long> result;\n  for (const auto& pair : counts) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"
    },
    {
        "task_id": "HumanEval/112",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توكيت كيت دبري دوا تار s دان c، كيت مستي مڠحذف سموا كاراكتر دالم s يڠ سام دڠن ستياڤ كاراكتر دالم c لالو مڠيكوت اڤابيلا تار كيت ڤاليندروم. تار دكنلي سباڬاي ڤاليندروم اڤابيلا دباچ سام ڤد ڤد ڤد ڤد. كيت مستي مڠرجاكن ساتو توبل يڠ مڠيلاي تار كيت ڤد ڤد ڤد ڤد. چونتوه >>> reverse_delete((\"abcde\"), (\"ae\")) (std::make_tuple(\"bcd\", false)) >>> reverse_delete((\"abcdef\"), (\"b\") (std::make_tuple(\"acdef\",)) >>> reverse_delete((abcded\", false)) >>> reverse_delete((abcded\", false)) (std::make_tuple\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  std::unordered_set<char> chars_to_delete(c.begin(), c.end());\n  for (char ch : s) {\n    if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n      result += ch;\n    }\n  }\n  std::string reversed_result = result;\n  std::reverse(reversed_result.begin(), reversed_result.end());\n  return std::make_tuple(result, result == reversed_result);\n}",
        "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"
    },
    {
        "task_id": "HumanEval/113",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور ستراين، د مان ستراين ستياڤڽ بركونسيڤ دري ديڬيت، مروڤاكن ڤيكتور. ستياڤ ايليمن i دري اوتڤوت بوليه جادي \"كاءداءن ايليمن ڤد ستراين i دري اڤوڤت. \" د مان سموا i بوليه دڤاڤت اوليه كاءداءن ايليمن ڤد ستراين i دري اڤوڤت. >>> odd_count((std::vector<std::string>(({std::string) \"1234567\"}))) (std::vector<std::string>({stdstring) \"كاءداءن ايليمن ڤد ستراين 4n دري اڤوڤت 4n. \")) >>> odd_count(stdvector<stdstring>::{stdstring>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string count_str = std::to_string(count);\n    std::string modified_s = s;\n    for (char& c : modified_s) {\n      if (isdigit(c) && (c - '0') % 2 != 0) {\n        c = count_str[0];\n      }\n    }\n    result.push_back(\"the number of odd elements \" + count_str + \"n the str\" + modified_s + \"ng \" + modified_s + \" of the \" + modified_s + \"nput.\");\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/114",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور انجيري n، جاديكن سوم مينيموم ڤيكتور سوب-ۏيكتور نڠ هان ڤاكيت. چونتوه >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)\nlong minSubArraySum(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong minSubArraySum(std::vector<long> nums) {\n  if (nums.empty()) {\n    throw std::invalid_argument(\"Input vector cannot be empty.\");\n  }\n  long min_so_far = nums[0];\n  long current_min = nums[0];\n  for (size_t i = 1; i < nums.size(); ++i) {\n    current_min = std::min(nums[i], current_min + nums[i]);\n    min_so_far = std::min(min_so_far, current_min);\n  }\n  return min_so_far;\n}",
        "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/115",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مريك دبري سبواه ݢريد ڤرتيمبڠ دري بوڠا. ستياڤ رنچان ممڤوڽاءي سبواه بوڠا، دان ستياڤ 1 دالم رنچان ممڤوڽاءي ساتو اونيت ا ?? ير. ستياڤ بوڠا اد سبواه بوڠکيت يڠ برکاءيتن يڠ بوليه دݢوناکن اونتوق مڠلوارکن ا ?? ير دريڽ، دان سموا بوڠکيت برکاءيتن سام. کأدا ?? ن کامو اداله اونتوق مڠݢوناکن بوڠکيت اونتوق مڠلوارکن بوڠکيت. ڤرلو مڠيکوت ڤندودوق يڠ ڤرلو دڤندوکن. چونتوهڽ: (1) >>> max_fill(((std::long_long:}std:std:std:std:std:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long bucket_lowering_count = 0;\n  for (const auto& row : grid) {\n    long water_in_well = 0;\n    for (long unit : row) {\n      water_in_well += unit;\n    }\n    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;\n  }\n  return bucket_lowering_count;\n}",
        "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/116",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دالم كاتا اين، كامو ڤرلو مڠورڠكن ۏكتور انتير يڠ تيدق نڬاتيف برداسركن باهن يڠ دڤرتوان اڬوڠ دالم ڤرسمبهن باينري دالم اورد يڠ مڠورڠكن. اونتوق باهن يڠ سام، مڠورڠكن برداسركن دري قدر ديسيمل. ڤرلو دأنجوركن سڤرتي اين: >>> sort_array((std::vector<long>{(long>1, (long) 5, (long) 2, (long) 3, (long) 3, (long) 4، (long) 5)) >>> sort_array((std::vector<long>{(long>2, (long) 3, (long) 4, (long) 5, (long) 6)) (std::vector<long>{(long>-6, (long) 5, (long-4, (long) 3, (long-2)) >>>array_std::vector<long>1, (long) 0, (long)) (long) 3, (long)) (long) 2, (long)) (long) 4\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nint count_set_bits(long n) {\n  int count = 0;\n  if (n < 0) {\n    n = std::abs(n);\n  }\n  while (n > 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n\nbool compare(long a, long b) {\n  int bits_a = count_set_bits(a);\n  int bits_b = count_set_bits(b);\n  if (bits_a != bits_b) {\n    return bits_a < bits_b;\n  }\n  return a < b;\n}\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), compare);\n  return arr;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"
    },
    {
        "task_id": "HumanEval/117",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن ستريڠ s دان سبواه نومبور فطري n، كامو دڤرلوكن اونتوق ممڤركنلكن فڠكشن يڠ مروڤاكن ۏيكتور دري ستريڠ s يڠ ممڤوڽاءي كسن كسن سڤرتي اين، اونتوق كلمات اين برلاكو د ستريڠ s. اڤابيلا ستريڠ s تيدق دڤوڽاءي، فڠكشن ايت داڤت مروڤاكن ۏيكتور يڠ تيدق دڤوڽاءي. كاتاكن: كامو موڠكين مڠاتكن ستريڠ اينتيمن تله ممڤوڽاءي حروف دان ڤاسڠن. چونتوه: >>>select_words{\"ماري نا ليڠكوڠن رنده\"}، (4)) (std::vector<std::vector>، (4) (ستد:ماري نا ليڠكوڠن رنده) ، (ستد:ماري نا ليڠكوڠن رنده) ، (3) (ستد:ڤوڽاءي كسن رنده) ، (ستد:ماري نا ليڠكوڠن رنده) ، (4) (سترد:ماري نا ليڠكوڠن رنده) ، (سترد) (ستريڠكوڠن رنده) ، (سترد) (ستريڠكوڠن)\nstd::vector<std::string> select_words(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_consonant(char c) {\n  c = tolower(c);\n  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ' ') {\n      long consonant_count = 0;\n      for (char word_char : current_word) {\n        if (is_consonant(word_char)) {\n          consonant_count++;\n        }\n      }\n      if (consonant_count == n) {\n        result.push_back(current_word);\n      }\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  long consonant_count = 0;\n  for (char word_char : current_word) {\n    if (is_consonant(word_char)) {\n      consonant_count++;\n    }\n  }\n  if (consonant_count == n) {\n    result.push_back(current_word);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/118",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جك كاتاڽ دبريكن كڤد كامو. ڤركارا كامو اداله اونتوق مميليه ۏوكل يڠ ڤاليڠ كسلوروهن يڠ بركنا ?? ن انتارا دوا كسنونن دري سڤنجڠ كاتاڽ (سڤنجڠ كيس). ۏوكل د ڤرتام دان اخير تيدق دڤڠڬيل. مڠلواركن سليرا تيدق دڤرتوان اڤابيلا كامو تيدق مميليه ۏوكل يڠ دڤرتوان اڤابيلا شرط دولو. كامو موڠكين مڠاتكن بهاوا سليرا يڠ دبريكن ايت ممڤوڽاءي حروف بهاس ايڠڬريس سهاج. چونتوه: >>> get_closest_vowel (((\"yogurt\")) (\"u\") >>> get_closest_vowel (((\"FULL\")) (\"U\") >>> get_closest_vowel (((\"quick\") (\"\") >>> get_closest_vowel ((((ab\") (\"\")\nstd::string get_closest_vowel(std::string word) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_vowel(char c) {\n  c = tolower(c);\n  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool is_consonant(char c) {\n  return isalpha(c) && !is_vowel(c);\n}\n\nstd::string get_closest_vowel(std::string word) {\n  if (word.length() < 3) {\n    return \"\";\n  }\n  for (int i = word.length() - 2; i >= 1; --i) {\n    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
    },
    {
        "task_id": "HumanEval/119",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جك كيت دبري ۏكتور دري دوا كتر، كدوا كتر ترماسوق ڤرنتيس ڤڠهوجوڠ '(' اتاو ڤرنتيس ڤڠهوجوڠ ') '. ڤركارا كيت اداله اونتوق مڠچتوسكن جك كدوا كتر دالم ڤلباڬاي اوردين، سوڤاي كتر يڠ دڤرتوان اڬر بربنديڠ. سترين S دأڠڬڤ سباڬاي يڠ باءيق اڤابيلا دان هاڽ اڤابيلا كسموا ڤرنتيس د S بربنديڠ. چونتوهڽ: سترين '((())) ' باءيق، ماناكالا سترين '(()) ' تيدق. مڽاتاكن 'Yes' اڤابيلا اد چارا اونتوق مڽاتاكن سترين يڠ باءيق، دان مڽاتاكن 'No' اڤابيلا تيدق. چونتوه: >>> match_parens((std::string<string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\nstd::string match_parens(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_good(const std::string& s) {\n  int balance = 0;\n  for (char c : s) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  if (is_good(s1 + s2) || is_good(s2 + s1)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
    },
    {
        "task_id": "HumanEval/120",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت ۏكتور ار ار دان ڤوسيتيف اينتڬري ك، مروڤاكن ۏكتور يڠ دڤرتيمبڠكن دڠن ماكسيما ك ار دالم ار. چونتوه ١: >>> ماكسيماك ((((std::vector<long>({(long) -٣، (long) -٤، (long) -٥)) ، (3)) (std::vector<long>({(long) -٤، (long) -٣، (long) -٥)) چونتوه ٢: >>> ماكسيماك ((((std::vector<long>({(long) -٤، (long) -٤)) ، (2)) (std::vector<long>{(long) -٤، (long) -٤)) چونتوه ٣: >>> ماكسيماك (((std::vector<long>{(long) -٣، (long) -٢، (long) -١، (long) -٢، (long) -١) ، (1) (ستد:ماكسيماك ((((((((((((((((((دالم دالم ڤيكتور: 1. دالم ڤريڠكت ڤيڠتڠ ۏكتور ۏكتور ۏكتور ۏكتور ۏكتور ۏكتور ار اكن دالم ڤي 1000، دالم ڤريڠتيمڤتومڤن ۏكتور ۏكتور ۏكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور ۏيكتور \nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.rbegin(), arr.rend());\n  std::vector<long> result;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    result.push_back(arr[i]);\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/121",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور انجيري يڠ هان بيدا، مروڤاكن سومبڠن سموا ايليمن ڤرڬي يڠ دالم ڤوسيسي جاوت. چونتوه >>> solution((std::vector<long>({(long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> solution(((std::vector<long>({(long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> solution(((std::vector<long>({(long)30, (long)13, (long) 24, (long) 321}))) (0)\nlong solution(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/122",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت ۏكتور يڠ هان بيلا ار ار ار دان ار ك، ڤرلو دڤرچايا ?? ي سومبڠن ايليمن يڠ ڤاليڠ كاو دوا ديڬيت دري ايليمن k ڤرتام ار. چونتوه: >>> add_elements((std::vector<long>({(long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) كونستراكت: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)\nlong add_elements(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/123",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاودڠ ڤڠاروه ڤوسيتيف، ڤيڠت ڤيڠت يڠ دڤاودڠ دالم سيکينسي كولاتز. ڤيڠت ڤيڠت كولاتز اداله ڤيڠت دالم ماتماتيك يڠ برتيته دڠن سيکينسي يڠ دڤرتيمبڠکن سڤرتي اين: مولا دڠن ڤيڠت ڤوسيتيف ن. لالو ستياڤ اصطلاح دڤيليه دري اصطلاح يڠ سبلومڽ سڤرتي اين: اڤابيلا اصطلاح يڠ سبلومڽ اداله جوم، اصطلاح يڠ سبلومڽ اداله ڤولوه اصطلاح يڠ سبلومڽ. اڤابيلا اصطلاح يڠ سبلومڽ اداله ڤرچاي، اصطلاح يڠ سبلومڽ اداله 3 كالي اصطلاح يڠ سبلومڽ ڤلس 1. ڤيڠت ڤيڠت ڤيڠت ڤيڠت ن، سيکينسي سداڠ مڽوکوڠ 1.\nstd::vector<long> get_odd_collatz(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> odd_numbers;\n  std::unordered_set<long> seen;\n  long current = n;\n  while (seen.find(current) == seen.end()) {\n    seen.insert(current);\n    if (current % 2 != 0) {\n      odd_numbers.push_back(current);\n    }\n    if (current == 1) {\n      break;\n    }\n    if (current % 2 == 0) {\n      current /= 2;\n    } else {\n      current = 3 * current + 1;\n    }\n  }\n  std::sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/124",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو ڤرلو منوليس فانسي يڠ مڠمبيل فنتس دتنتس ڤد ستريڠ تاريخ دان مڽروڤاكن فنتس ڤد ستريڠ تاريخ يڠ بوليه دڤرچايأي دان مڽروڤاكن فنتس ڤد ستريڠ تاريخ يڠ بوليه دڤرچايأي. تاريخ بوليه دڤرچايأي د مان سموا قاعده يڠ دلاكوكن: 1. ستريڠ تاريخ تيدق چوكوڤ. 2. ڤندودوق تيدق كورڠ دري 1 اتاو لبيه دري 31 هاري اونتوق بولن 1,3,5,7,8,10,12. دان ڤندودوق تيدق كورڠ دري 1 اتاو لبيه دري 30 هاري اونتوق بولن 4,6,9,11. دان، ڤندودوق تيدق كورڠ دري 1 اتاو لبيه دري 29 هاري اونتوق بولن 2. بوليه تيدق كورڠ دري 1 اتاو لبيه دري 12. تاريخ بوليه دڤنتس دالم فورتم: mm-dd-dd-yyyy >>> valid_date(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool valid_date(std::string date) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool valid_date(std::string date) {\n  if (date.empty()) {\n    return false;\n  }\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  int month, day, year;\n  try {\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    return false;\n  } catch (const std::out_of_range& e) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1) {\n    return false;\n  }\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/125",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// دبريكن ستراين ڤركاتاءن، مروڤاكن ۏكتور ڤركاتاءن يڠ دڤرتيمبڠكن دڠن ڤڠالمن، اڤابيلا تيدق اد ڤڠالمن دالم تيكس، كيت داڤت مروڤاكن ڤڠالمن دڠن كومما '، اڤابيلا تيدق اد كومما كيت داڤت مروڤاكن ڤڠالمن دڠن ڤڠالمن دڠن ڤركاتاءن حروف مينوم دڠن اوروسن بيجق دالم ابجد، ord (a) = 0، ord (b) = 1، ... ord (z) = 25 چونتوه >>> split_words (def) >>> split_words (def) 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;\n    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  if (txt.find(' ') != std::string::npos) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n    std::string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if (txt.find(',') != std::string::npos) {\n    std::vector<std::string> words;\n    std::string current_word;\n    for (char c : txt) {\n      if (c == ',') {\n        words.push_back(current_word);\n        current_word = \"\";\n      } else {\n        current_word += c;\n      }\n    }\n    words.push_back(current_word);\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long odd_order_count = 0;\n    for (char c : txt) {\n      if (islower(c)) {\n        if ((c - 'a') % 2 != 0) {\n          odd_order_count++;\n        }\n      }\n    }\n    return Union_std_vector_std_string__long(odd_order_count);\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/126",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤرتوان اݢوڠ، ڤرلو مڽمبه ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠيکوت ڤرکارا يڠ دڤرتوان اݢوڠ، ڤرلو مڠکوت ڤرکارا يڠ دڤ دڤرتوان اݢوڠ، ڤرکارا يڠ دڤ دڤ دڤرتوان اݢوڠ دڤ دڤي ڤرکارا يڠ دڤ دڤيکوتام ڤرکارا يڠ دڤ دڤ دڤيکوتام ڤرکارا يڠ دڤ دڤيکوتام ڤرکارا يڠ دڤ دڤ دڤيکوتام ڤرکارا ڤرکارا يڠکوتراسي ڤرلو مڠ دڤيکوتوس ڤوستيمڤ ڤوستيمڤ ڤوستيمڤ ڤوستيمڤ ڤو ڤوستيمڤو ڤوستيمڤو ڤوستيمڤو ڤوستيمڤو ڤوستيمڤو ڤو ڤوستيمڤو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤوستيو ڤو\nbool is_sorted(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n  std::map<long, int> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  for (auto const& [key, val] : counts) {\n    if (val > 2) {\n      return false;\n    }\n  }\n  for (size_t i = 0; i < lst.size() - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/127",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جك دبريكن كدوا انتارڤل، ستياڤ انتارڤل اداله جوري انجيڠ. چونتوهڽ انتارڤل = (ڤرتام، اخير) = (1, 2). انتارڤل دبريكن چدرا يڠ برمعنى انتارڤل (ڤرتام، اخير) ترماسوق ڤرتام دان اخير. باڬي ستياڤ انتارڤل دبريكن، اي دڤرلوكن ڤرتامڽ اداله كلوار اتاو سام دڠن اخيرڽ. ڤركارا يڠ دبريكن اياله اونتوق ممستيكن اڤابيلا لڠكه ڤرتمڠن انتارڤل ايت اداله ڤرميت. چونتوهڽ، انتارڤل (1, 3), (2, 4) اداله (2, 3) يڠ لڠكهڽ اداله 1، يڠ تيدق ڤرميت. جك لڠكه ڤرتمڠن ايت اداله ڤرميت، ڤرلو مڽاتاكن \"YES\"، جك تيدق، ڤرلو مڽاتاكن \"NO\". جك دوا انتارڤل تيدق برتيمڤل، ڤرلو مڽاتاكن \"NO\".\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get(interval1);\n  long end1 = std::get(interval1);\n  long start2 = std::get(interval2);\n  long end2 = std::get(interval2);\n  long intersection_start = std::max(start1, start2);\n  long intersection_end = std::min(end1, end2);\n  long intersection_length = intersection_end - intersection_start + 1;\n  if (intersection_length <= 0) {\n    return \"NO\";\n  }\n  if (is_prime(intersection_length)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
    },
    {
        "task_id": "HumanEval/128",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ڤيكتور ار ار دان اكو ڤرلو مروڤاكن سومبڠن ڬانل ار دڠن ڤرباتسن سموا تندا ستياڤ ار د ڤيكتور، دڤرتنديڠي اوليه 1،-1 اتاو 0. تيدق ڤرلو مروڤاكن هيڠڬ ساتو اونتوق ار بياسا. چونتوه: >>> prod_signs((std::vector<long>{(long) 1, (long) 2, (long) 2, (long) -4)))) 9 >>> prod_signs(std::vector<long>({(long) 0, (long) 1}))) 0 >>> prod_signs(std::vector<long>(())) std::nopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_of_signs = 1;\n  for (long num : arr) {\n    sum_magnitudes += std::abs(num);\n    if (num > 0) {\n      product_of_signs *= 1;\n    } else if (num < 0) {\n      product_of_signs *= -1;\n    } else {\n      product_of_signs *= 0;\n    }\n  }\n  return sum_magnitudes * product_of_signs;\n}",
        "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/129",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤرتنديڠن grid دڠن N رنچان دان N ستور (N >= 2) دان ساتو ڤوسيتيف integer k، ستياڤ سيل grid ممڤوڽاءي ۏاليوم. ستياڤ integer دالم رنچان [1, N * N] سڤرتي اين ڤرلو دڤرتنديڠي سڤرتي ساتو ڤوسيتيف دالم سيل grid. اكو ڤرلو مميليه ڤاسر مينيموم دري لڠسوڠ k دالم grid. اكو بوليه برمولا دري ستياڤ سيل، دان دالم ستياڤ ڤاسر اكو بوليه برلاكو دڠن سيل برسام، د مان اكو بوليه برلاكو دڠن سيل يڠ برسام دڠن اكو. اكو تيدق بوليه برلاكو دري grid. ڤاسر A (ڤاسر k) بوليه دأڠڬڤ سباڬاي ڤاسر كورڠ دري ڤاسر B (ڤاسر k) اڤابيلا ستله ڤمبنتڠن ۏيكتور ڤرتنديڠن دري سيل A دان B (كيتله كيت مڠڬاماكاي l_stA دان l_st_ l_st_ l_ l_ l_ l_ l_ l_ l_ l_ l_ l_ l_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i_ i\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  int n = grid.size();\n  std::vector<long> min_path;\n\n  std::function<void(int, int, std::vector<long>)> dfs = \n    [&](int row, int col, std::vector<long> current_path) {\n    if (current_path.size() == k) {\n      if (min_path.empty() || current_path < min_path) {\n        min_path = current_path;\n      }\n      return;\n    }\n\n    current_path.push_back(grid[row][col]);\n\n    int dr= {-1, 1, 0, 0};\n    int dc= {0, 0, -1, 1};\n\n    for (int i = 0; i < 4; ++i) {\n      int next_row = row + dr[i];\n      int next_col = col + dc[i];\n      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n        dfs(next_row, next_col, current_path);\n      }\n    }\n  };\n\n  for (int start_row = 0; start_row < n; ++start_row) {\n    for (int start_col = 0; start_col < n; ++start_col) {\n      dfs(start_row, start_col, {});\n    }\n  }\n\n  return min_path;\n}",
        "test": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/130",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// هرڅوک د فيبوناتچي تسلسل پوهيږي، دا په تيره دوه پېړيو کې د رياضي پوهانو له خوا ژور مطالعه شوى. په هرحال، هغه څه چې خلک نه پوهيږي هغه د تريبوناتچي تسلسل دى. د تريبوناتچي تسلسل د تکرار له مخې تعريف شوى: tri(1) = 3 tri(n) = 1 + n / 2، که n جوړه وي. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، که n عادي وي. د بېلګې په توګه: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 تاسو ته يو غير منفي عدد ورکړل شوى، تاسو بايد د تريبوناتچي تسلسل د لومړي n + 1 يو ويکتور بيرته راولئ. مثالونه: >>> tri(3) (dst vector><<(({long} (١،٣،٢،٨))\nstd::vector<long> tri(long n) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  if (n >= 0) {\n    result.push_back(1);\n  }\n  if (n >= 1) {\n    result.push_back(3);\n  }\n  for (long i = 2; i <= n; ++i) {\n    if (i % 2 == 0) {\n      result.push_back(1 + i / 2);\n    } else {\n      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)\n      {\n          result.push_back(result[i-1] + result[i-2] + result[i]);\n      }\n      else if (i - 1 >= 0 && i - 2 >= 0)\n      {\n          result.push_back(result[i-1] + result[i-2]);\n      }\n      else if (i - 1 >= 0)\n      {\n          result.push_back(result[i-1]);\n      }\n      else\n      {\n          result.push_back(0);\n      }\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/131",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن انجيڠ ڤوسيتيف n، مروڤاكن ڤرودوك ديڬيت ڤرڬي. مروڤاكن 0 جك سموا ديڬيت اداله ڤرڬي. چونتوهڽ: >>> ديڬيت (((1)) (1) >>> ديڬيت (((4)) (0) >>> ديڬيت (((235)) (15)\nlong digits(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digits(long n) {\n  long product = 1;\n  std::string s = std::to_string(n);\n  bool has_odd = false;\n  for (char c : s) {\n    long digit = c - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      has_odd = true;\n    }\n  }\n  if (!has_odd) {\n    return 0;\n  }\n  return product;\n}",
        "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/132",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مڠڬوناكن سورت كيت دڠن فڠاجرن يڠ تيدق بربنديڠ دڠن فڠاجرن يڠ دڤرتوان اڬوڠ. فانسي ايت بوليه مڠرجاكن سچارا صحيح اڤابيلا دان هاڽ اڤابيلا اد سبواه فڠاجرن يڠ تيدق باءيق دالم فڠاجرن ايت. >>> is_nested\"[[]]\")) (true) >>> is_nested\"[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\nbool is_nested(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_nested(std::string string) {\n  int balance = 0;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      balance++;\n    } else if (c == ']') {\n      if (balance > 1) {\n        nested = true;\n      }\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0 && nested;\n}",
        "test": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/133",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جك كيت دبري ساتو ۏيكتور ڤڠتاهوان، كيت ڤرلو مڠوروسكن سومبڠن ڤڠتاهوان تربيت دالم ۏيكتور يڠ دبري، مڠوروسكن ستياڤ ايليمن دالم ۏيكتور كڤد ڤڠتاهوان اوتام ڤولا. چونتوه: >>> lst:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float:{float}}}}}}float:{float\nlong sum_squares(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    long rounded_up = std::ceil(num);\n    sum += rounded_up * rounded_up;\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/134",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فڠسي يڠ مروڤاكن سچارا سچارا اڤابيلا حروف اخير دري ستراين دبريكن اداله حروف ابجد دان تيدق باڬي سسواتو، دان غلط سچارا لاين. تيتيق: \"word\" اداله ڬروڤ حروف يڠ دڤرباڬايكن دڠن ڤڠڬيلن. چونتوه: >>> check_if_last_char_is_a_letter (((\"apple pie\")) (false) >>> check_if_last_char_is_a_letter (((\"apple pi e\")) (true) >>> check_if_last_char_is_a_letter (((\"apple pi e \")) (false) >>> check_if_last_char_is_a_letter (((\"\")) (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  if (!isalpha(txt.back())) {\n    return false;\n  }\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n    return false;\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/135",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فانسي يڠ مروڤاكن اينديكس ڤاليڠ بسر دري ايليمن يڠ تيدق لبيه بسر اتاو سام دڠن ايليمن يڠ سديا سبلومڽ. جك ايليمن ايت تيدق اد، مروڤاكن -1. ۏكتور يڠ دبريكن تيدق ممڤوڽاءي قدر دوڤليک. چونتوه: >>> can_arrange{((std::vector<long>{(long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)\nlong can_arrange(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong can_arrange(std::vector<long> arr) {\n  for (long i = 1; i < arr.size(); ++i) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/136",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فڠسي يڠ مروڤاكن توڤل (a، b) ، د مان 'a' اداله يڠ ڤاليڠ بسر دري اينتيڬر نيڬاتيف، دان 'b' اداله يڠ ڤاليڠ كورڠ دري اينتيڬر ڤوسيتيف دالم ۏيكتور. جك تيدق اد اينتيڬر نيڬاتيف اتاو ڤوسيتيف، مروڤاكنڽ سباڬاي None. چونتوه: >>> largest_smallest_integers(((std::vector<long>{long>{long}2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7))) std::make_tuplest_d::optional<long>{long}), std::optional<long>{long}) >>> largest_smallest_integers{long}{long}{long}{long}, std::optional<long}{long}\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<tuple>\n#include<vector>\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}",
        "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"
    },
    {
        "task_id": "HumanEval/137",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// مڠمبيل فانسي يڠ مڠڬوناكن انجيرو، فلوات، اتاو سورت يڠ مروڤاكن ارق ريال، دان مروڤاكن فاريابل يڠ لبيه بسر دالم جنيس فاريابل يڠ دبريڽ. مروڤاكن نيه جك قدرڽ سام. تڠكڤ: جك ارق ريال دڤرتنديڠي سباڬاي سورت، تيتيق فلوات موڠكين . اتاو، >>> compare_one{1, 2.5f) 2.5f >>> compare_one{1, \"2,3\") \"2,3\" >>> compare_one{5,1\", \"6\") \"6\" >>> compare_one{1\", 1) std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<string>\n\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;\n    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;\n    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\ndouble parse_real(const std::string& s) {\n    std::string temp = s;\n    std::replace(temp.begin(), temp.end(), ',', '.');\n    try {\n        return std::stod(temp);\n    } catch (const std::invalid_argument& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    } catch (const std::out_of_range& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n}\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f2.empty() && b.f2.empty()) {\n        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {\n            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {\n            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {\n            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {\n            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);\n        }\n    } else {\n        double val_a, val_b;\n        if (!a.f2.empty()) val_a = parse_real(a.f2);\n        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);\n        else val_a = static_cast<double>(a.f1);\n\n        if (!b.f2.empty()) val_b = parse_real(b.f2);\n        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);\n        else val_b = static_cast<double>(b.f1);\n\n        if (!std::isnan(val_a) && !std::isnan(val_b)) {\n            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);\n            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);\n        }\n    }\n    return Union_long_float_std_string_std_nullopt(std::nullopt{});\n}",
        "test": "}\nint main() {\n    auto candidate = compare_one;\n    assert(candidate(1, 2) == 2);\n    assert(candidate(1, 2.5f) == 2.5f);\n    assert(candidate(2, 3) == 3);\n    assert(candidate(5, 6) == 6);\n    assert(candidate(1, \"2,3\") == \"2,3\");\n    assert(candidate(\"5,1\", \"6\") == \"6\");\n    assert(candidate(\"1\", \"2\") == \"2\");\n    assert(candidate(\"1\", 1) == std::nullopt);\n}\n"
    },
    {
        "task_id": "HumanEval/138",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤندكتن اڤابيلا نومبور n يڠ دبريكن بوليه دتوليس سباڬاي سوم 4 نومبور ڤوسيتيف يڠ ڤوسيتيف دڠن جاوه چونتوه >>> is_equal_to_sum_even (((4)) (فلس) >>> is_equal_to_sum_even (((6)) (فلس) >>> is_equal_to_sum_even (((8)) (ڤرچاي)\nbool is_equal_to_sum_even(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_equal_to_sum_even(long n) {\n    if (n <= 6 || n % 2 != 0) {\n        return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/139",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// فكتوريل برازيلي دتودوهكن سباڬاي: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! دمان n > 0 چونتوهڽ: >>> special_factorial (((4)) (288) فكتوريل ايت اكن منداڤت سابوه انتيڬر سباڬاي اينتڬر دان ڤرلو مروڤاكن فكتوريل خاص انتيڬر ڽو.\nlong special_factorial(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong factorial(long k) {\n    long res = 1;\n    for (long i = 2; i <= k; ++i) {\n        res *= i;\n    }\n    return res;\n}\n\nlong special_factorial(long n) {\n    if (n <= 0) {\n        return 1;\n    }\n    long result = 1;\n    for (long i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/140",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت سورت، ڤاوتاهن سموا ڤوست د دالمڽ دڠن ڤوتوڠن، دان جك سورت اد لبيه دري 2 ڤوست يڠ برتاهن، لالو ڤاوتاهن سموا ڤوست يڠ برتاهن دڠن - >>> fix_spaces (((\" چونتوه\")) (\" چونتوه\") >>> fix_spaces (((\" چونتوه 1 \")) (\" چونتوه_1 \") >>> fix_spaces (((\" چونتوه 2 \")) (\"_ چونتوه_2 \") >>> fix_spaces (((\" چونتوه 3 \")) (\"_ چونتوه-3\")\nstd::string fix_spaces(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1 && !result.empty() && result.back() != '_') {\n        result += '_';\n    } else if (space_count > 1 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count > 0 && result.empty()) {\n        if (space_count > 2) result += '-';\n        else if (space_count == 1) result += '_';\n    } else if (space_count == 1 && result.empty()) {\n        result += '_';\n    }\n\n    std::string trimmed_result = \"\";\n    bool non_space_found = false;\n    for (char c : result) {\n        if (c != ' ') {\n            non_space_found = true;\n            trimmed_result += c;\n        } else if (non_space_found) {\n            trimmed_result += c;\n        }\n    }\n\n    while (!trimmed_result.empty() && trimmed_result.front() == '_') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '_') {\n        trimmed_result.pop_back();\n    }\n     while (!trimmed_result.empty() && trimmed_result.front() == '-') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '-') {\n        trimmed_result.pop_back();\n    }\n\n    std::string final_result = \"\";\n    space_count = 0;\n    for (char c : trimmed_result) {\n        if (c == '_') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                final_result += '_';\n            } else if (space_count > 1) {\n                final_result += '-';\n            }\n            final_result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1) {\n        final_result += '_';\n    } else if (space_count > 1) {\n        final_result += '-';\n    }\n\n    return final_result;\n}",
        "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"
    },
    {
        "task_id": "HumanEval/141",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// مڠمبيل فڠسي يڠ مڠڬوناكن ستريڠ يڠ مروڤاكن نام فايل، دان مروڤاكن 'Yes' جك نام فايل ايت ڤرلو، دان مروڤاكن 'No' جك تيدق. نام فايل دأڠڬڤ سباڬاي ڤرلو جك كسموا شرط يڠ دلاكوكن: - تيدق بوليه اد لبيه دري تيڬ دجيت ('0'-'9') دالم نام فايل. - نام فايل مروڤاكن سڤرتي ساتو تيتق '.' - سوبسترين سبلوم تيتق تيدق بوليه بياسا، دان بلياو برمولا دڠن حروف دري الفبيت لاتين ('a'-'z' دان 'A'-Z'). - سوبسترين ستله تيتق ڤرلو جك اداله ساتو دري اين: ['txt', 'exe', 'll'] چونتوه: >>> file_name_check\"{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string file_name_check(std::string file_name) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_pos = std::string::npos;\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        } else if (file_name[i] == '.') {\n            dot_count++;\n            dot_pos = i;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    std::string name_part = file_name.substr(0, dot_pos);\n    std::string ext_part = file_name.substr(dot_pos + 1);\n\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
    },
    {
        "task_id": "HumanEval/142",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \" فانسي ڽو اكن مڠڬوناكن ۏيكتور انتيڬري. اونتوق سموا اينتر د ڤيكتور، فانسي ڽو اكن مڠكوواڠكن اينتر انتيڬري اڤابيلا اينديكسڽ اداله ڤلڠڬن دري 3 دان اكن مڠكواڠكن اينتر انتيڬري اڤابيلا اينديكسڽ اداله ڤلڠڬن دري 4 دان هان ڤلڠڬن دري 3. فانسي ڽو اكن مڠڬوناكن اينتر د ڤيكتور يڠ اينديكسڽ هان اداله ڤلڠڬن دري 3 اتاو 4. فانسي ڽو اكن مروڤاكن سومتوم سموا اينتر. چونتوه: >>> lst (long({(long) 1, (long) 5, (long) 2, (long) 1, (long) 5}))\nlong sum_squares(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"
    },
    {
        "task_id": "HumanEval/143",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبريكن ستريڠ يڠ مروڤاكن سيسي، سيسي ايت مليبتكن ببراڤ كلمات يڠ دڤرباتڠكن دڠن سبواه ڤوست، دان اكو ڤرلو مروڤاكن ستريڠ يڠ مليبتكن سيسي دري سيسي اصل، يڠ لڠسوڠڽ اداله ڤرميت، ڤرتموان سيسي دالم سيسي بارو ڤرلو سام دڠن سيسي اول. چونتوه 1: >>> words_in_sentence (((\"This is a test\")) (\"is\") چونتوه 2: >>> words_in_sentence (((\"let's go for swimming\")) (\"go for\") كونترينت: * 1 <= len ((sentence) <= 100 * سيسي ايت مليبتكن سيسي حروف\nstd::string words_in_sentence(std::string sentence) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
    },
    {
        "task_id": "HumanEval/144",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// توجوان تو اداله اونتوق مڠمبيل فانکشن يڠ اکن ممڤوڽاءي ايكسڤريسي x * n. فانکشن ايت مروڤاکن سچارا سدياڤاکه x * n مروڤاکن ساتو ڤرکارا برکاءيتن دان سچارا لاين سچارا تيدق. کدوا-دوا x دان n، اداله ڤرتونجوقن سݢرا، دان ممڤوڽاءي فورمت يڠ مان، <نومريتور>/<نومينتور> دمان کدوا-دوا نومريتور دان نومينتور اداله ڤرکارا برکاءيتن ڤوسيتيف. تو بوليه مڠݢالقکن بهاوا x, دان n اداله ڤرکارا يڠ صالح، دان تيدق ممڤوڽاءي صفر سباݢاي نومينتور. >>> سمڤليفيك (((\"1/5\") ، (\"5/1\")) (ڤوڽاءي) >>> سمڤليفيك ((((\"1/6\") ، (\"2/1\") (فولس) >>> سمڤليفيك (((\"7/10\") ، (\"10/2\") (فولس)\nbool simplify(std::string x, std::string n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong gcd(long a, long b) {\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    long x_num, x_den, n_num, n_den;\n    size_t slash_pos = x.find('/');\n    x_num = std::stol(x.substr(0, slash_pos));\n    x_den = std::stol(x.substr(slash_pos + 1));\n\n    slash_pos = n.find('/');\n    n_num = std::stol(n.substr(0, slash_pos));\n    n_den = std::stol(n.substr(slash_pos + 1));\n\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n\n    long common_divisor = gcd(num, den);\n    den /= common_divisor;\n\n    return den == 1;\n}",
        "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/145",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ منوليس ۏكتور اينتيجر يڠ دبريكن دالم اوردين يڠ مڠورڠ اتس سومبڠن ديڬيت-ديڬيتڽ. تاهو: اڤابيلا اد ببراڤ ايتيمن دڠن سومبڠن ديڬيت-ديڬيت يڠ سام، منوليسڽ دڠن اينديكسڽ دالم ۏكتور اصل. چونتوهڽ: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long)-1, (long) - 11, (long) - 12}))) (std::vector<long>({long) - 1, (long) - 11, (long) - 1, (long) - 12, (long) - 11)) >>> order_by_points\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_digits(long n) {\n    long sum = 0;\n    std::string s = std::to_string(std::abs(n));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, size_t>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {\n        long sum_a = sum_digits(a.first);\n        long sum_b = sum_digits(b.first);\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        }\n        return a.second < b.second;\n    });\n\n    std::vector<long> result;\n    for (const auto& pair : indexed_nums) {\n        result.push_back(pair.first);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/146",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ مڠڬوناكن ۏيكتور ڤڠهوني سباڬاي ڤڠهوني دان مروڤاكن ڤڠهوني ايليمن دالم ۏيكتور يڠ لبيه بسر دري 10 دان دوا دجيت ڤرتام دان اخير ڤڠهوني اداله ڤرڬي (1, 3, 5, 7, 9). چونتوهڽ: >>> specialFilter((std::vector<long>({long) 15, (long) -73, (long) -14, (long) -15}))) (1) >>> specialFilter((std::vector<long>({long) 33, (long) -2, (long) -3, (long) -4, (long) 21, (long) 109} (2))))\nlong specialFilter(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_odd_digit(char c) {\n    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');\n}\n\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (std::abs(num) > 10) {\n            std::string s = std::to_string(std::abs(num));\n            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/147",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبريكن سبواه اينتيڬر ڤوسيتيف n. اكو ڤرلو مڠمبيل ۏكتور اينتيڬر a دري لڠسوڠ n. اونتوق ستياڤ i (1 ≤ i ≤ n) ، ڤرلاونن a[i] = i * i - i + 1. مروڤاكن ڤرلاونن ترڤل (a[i], a[j], a[k]) دري a د مان i < j < k، دان a[i] + a[j] + a[k] اداله ڤربلنجأن دري 3. چونتوه: >>> get_max_triples((5)) (1) ڤڽاتوان: a = [1, 3, 7, 13, 21] يڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤالي\nlong get_max_triples(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong get_max_triples(long n) {\n    if (n < 3) {\n        return 0;\n    }\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"
    },
    {
        "task_id": "HumanEval/148",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دالم سيستم ڤمبوكاين كيت اد 8 ڤلانيت: يڠ ڤاليڠ كوات كڤد هاري اداله ميروكوري، يڠ لاين اداله ۏينوس، لالو بومي، مريس، جوڤيتر، ساترن، اورانوس، نڤتون. منوليس فانسي يڠ مڠڬوناكن دوا نام ڤلانيت سباڬاي ستريڠ ڤلانيت1 دان ڤلانيت2. فانسي ايت داڤت مڽروڤاكن ساتو توڤل يڠ مڠمبيل سموا ڤلانيت يڠ اوربيتڽ دتومڤت انتارا اوربيت ڤلانيت1 دان اوربيت ڤلانيت2، دتربيتكن اوليه كڤد هاري. فانسي ايت داڤت مڽروڤاكن ساتو توڤل يڠ چوكوڤ اڤابيلا ڤلانيت1 اتاو ڤلانيت2 تيدق ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤاليڠ ڤ\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = std::distance(planets.begin(), it1);\n    int index2 = std::distance(planets.begin(), it2);\n\n    if (index1 == index2) {\n        return {};\n    }\n\n    int start = std::min(index1, index2) + 1;\n    int end = std::max(index1, index2);\n\n    std::vector<std::string> result;\n    for (int i = start; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/149",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ منوليس ۏكتور ستراين سباڬاي ڤاراميتر، مڠحاصيلكن ستراين يڠ نا لڠسوڠ يڠ تيدق بربيذا دريڽ، دان مڠرجاكن ۏكتور يڠ دڤرتوان اڬوڠ دڠن اوردين يڠ دڤرتوان اڬوڠ، ۏكتور سداڠكن ۏكتور ستراين دان تيدق ۏكتور ارق، دان موڠكين مليبتكن دوڤليكات. اوردين ۏكتور داڤت دڤرتوان اڬوڠ دڠن لڠسوڠ ستياڤ كات، دان اندا داڤت مڠرجاكن ۏكتور يڠ دڤرتوان اڬوڠ دڠن قاعده ايت. اڤابيلا دوا كات بربيذا، مڠرجاكن ۏكتور سچارا اليفبيت. فانسي داڤت مڠرجاكن ۏكتور ستراين دڠن اوردين يڠ دڤرتوان اڬوڠ. اندا موڠكين مڠڬقسيكن سموا كات هاڽ سوده بربيذا.\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> even_length_strings;\n    for (const std::string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n\n    return even_length_strings;\n}",
        "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/150",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// ڤروڬرم يڠ سيبوق يڠ ڤرلو مروڤاكن ۏاليو x اڤابيلا n اداله ڤرميت ڤرميت دان ڤرلو مروڤاكن ۏاليو y اڤابيلا تيدق. چونتوه: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)\nlong x_or_y(long n, long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/151",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري ڤيكتور ڤڠاره، مروڤاكن سومبر تربيت ڤڠاره يڠ تيدق بربيذا. مروڤاكن ڤڠاره يڠ تيدق سڤاتوتڽ سڤاتوتڽ سڤاتوتڽ سڤاتوتڽ سڤاتوتڽ سڤاتوتڽ. >>> double_the_difference (((((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference (((((std::vector<float>{(long) -1, (long) -2, (long) 0}))) (0) >>> double_the_difference ((((std::vector<float>{(long) -9, (long) -2))))) (81) >>> double_the_difference ((((((std::vector<float>{(long) -0)) (0) جك ڤيكتور ڤڠاره اداله ڤوس، مروڤاكن 0.\nlong double_the_difference(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong double_the_difference(std::vector<float> lst) {\n    long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);\n        }\n    }\n    return sum_of_squares;\n}",
        "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"
    },
    {
        "task_id": "HumanEval/152",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو برهارڤ اكو تاهو بهاوا اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ دڤرتوان اڬر اكو تيدق ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكن ممڤوڽاءي ڤرچاي يڠ اكو تيدق اكو تيدق اكن ممڤون اكو تيدق اكو تيدق اكو تيدق ممڤتيق اكو تيدق اكو تيدق ممڤوڤت ڤرچاي ڤرچاي يڠ اكو تيدق اكو تيدق اكو تيدق اكو تيدق ممڤت ڤرچاي ڤرچاي ڤرچاي ڤرچاي يڠ اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدق اكو تيدوڠكاكوڠكاكو\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> diff;\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n    return diff;\n}",
        "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/153",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو اكن دبري نام كلاس (سايرن) دان ۏكتور ايكستينسي. ايكستينسي اكن دڬوناكن اونتوق مڠلواركن كلاس٢ لاين ك كلاس. كقواتن ايكستينسي اكن جادي: كلواركن CAP اداله كادأن حروف بسر دالم نام ايكستينسي، دان كلواركن SM اداله كادأن حروف مينيس دالم نام ايكستينسي، كقواتن دبري اوليه كروسي CAP - SM. اكو بوليه مڠلواركن ايكستينسي يڠ ڤاليڠ كوات دان مڽاتاكن سايرن دالم ڤورتميت اين: ClassName.StrongestExtensionName. اڤابيلا اد دوا اتاو لبيه ايكستينسي دڠن كقواتن يڠ سام، اكو بوليه مڠلواركن ايكستينسي يڠ ڤولا د ڤورتميت. چونتوهڽ، اڤابيلا اكو دبري \"سلايس\" سباڬاي كلاس دان ۏكتور ايكستينسي: ['SErviSliNGCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesCesC\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint calculate_strength(const std::string& extension) {\n    int cap_count = 0;\n    int sm_count = 0;\n    for (char c : extension) {\n        if (isupper(c)) {\n            cap_count++;\n        } else if (islower(c)) {\n            sm_count++;\n        }\n    }\n    return cap_count - sm_count;\n}\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    std::string strongest_extension = extensions[0];\n    int max_strength = calculate_strength(extensions[0]);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int current_strength = calculate_strength(extensions[i]);\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            strongest_extension = extensions[i];\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}",
        "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"
    },
    {
        "task_id": "HumanEval/154",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// اكو دبري ٢ كات. اكو ڤرلو مروڤاكن سڤرتي سچارا سڤرتي كات كدوا اتاو سياڤاڤا ڤڠوروسنڽ اداله سبسترن دالم كات ڤرتام >>> cycpattern_check((\"abcd\"), (\"abd\")) (false) >>> cycpattern_check((\"hello\"), (\"ell\") (true) >>> cycpattern_check(\"whassup\"), (\"psus\")) (false) >>> cycpattern_check(\"abab\"), (\"baa\") (true) >>> cycpattern_(check\"efef\"), (\"eeff\") (false) >>> cycpattern_check((\"himens\"), (\"simen\") (true)\nbool cycpattern_check(std::string a, std::string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.empty()) {\n        return true;\n    }\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); ++i) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/155",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت سابوه اينتيڬر. مروڤاكن سابوه توڤل يڠ نا ليڠكوڠن سيڤل دان ڤرڬي. چونتوه: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)\nstd::tuple<long, long> even_odd_count(long num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<tuple>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"
    },
    {
        "task_id": "HumanEval/156",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن انجيرو ڤوسيتيف، ماوليهكن ايكن رومي يڠ سام سباڬاي سورت، دان مروڤاكنڽ دالم كاسر مينوس. رستريكتسي: 1 <= num <= 1000 چونتوه: >>> int_to_mini_roman((19)) (\"xix\") >>> int_to_mini_roman((152)) (\"clii\") >>> int_to_mini_roman(426)) (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            roman += pair.second;\n            number -= pair.first;\n        }\n    }\n    return roman;\n}",
        "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
    },
    {
        "task_id": "HumanEval/157",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبريكن لڠسوڠ دري تيڬ بواه تيڬ تيڬ. مروڤاكن صحيح اڤابيلا تيڬ بواه مروڤاكن تيڬ تيڬ يڠ بربنديڠ، دري لاينڽ. تيڬ تيڬ يڠ بربنديڠ اداله تيڬ تيڬ يڠ ساله ساتو ڤڠاروهڽ بربنديڠ اتاو 90 درجة. چونتوه: >>> right_angle_triangle (((3), (4), (5)) (true) >>> right_angle_triangle (((1), (2), (3)) (false)\nbool right_angle_triangle(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool right_angle_triangle(long a, long b, long c) {\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}",
        "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/158",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// منوليس فانسي يڠ منوليس ۏكتور ستراين. ۏكتور ممڤوڽاءي كلمات يڠ لاءين. مروڤاكن كلمة دڠن ماكسيموم ڤڠتاهوان كاراكتر يڠ اونيک. اڤابيلا ببراڤ ستراين ممڤوڽاءي ماكسيموم ڤڠتاهوان كاراكتر يڠ اونيک، مروڤاكن ساتو يڠ ڤرتام دالم اوردين ليكسيكوڬرافي. >>> find_max(std::vector<std::string>({(std::string) \"name\", (std::string) \"of\", (std::string) \"string\"}))) (\"string\") >>> find_max(std::vector<std::string>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string find_max(std::vector<std::string> words) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint count_unique_chars(const std::string& s) {\n    std::set<char> unique_chars;\n    for (char c : s) {\n        unique_chars.insert(c);\n    }\n    return unique_chars.size();\n}\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    std::string max_unique_word = words[0];\n    int max_unique_count = count_unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_count = count_unique_chars(words[i]);\n        if (current_unique_count > max_unique_count) {\n            max_unique_count = current_unique_count;\n            max_unique_word = words[i];\n        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {\n            max_unique_word = words[i];\n        }\n    }\n    return max_unique_word;\n}",
        "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
    },
    {
        "task_id": "HumanEval/159",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جاديله اكو سباڬاي كريتا يڠ برڤاسڠ، دان جاديله اكو ممڤوڽاءي كيرا-كيرا كروت، تتاڤي جاديله اكو ممڤوڽاءي كروت يڠ لبيه باڽق اونتوق مڠمبيل ڤاكاين هاري اين. جاديله اكو ممڤوڽاءي ۏكتور [كروت يڠ دڤاكاين ستله ڤاكاين، كروت يڠ دڤاكاين ستله ڤاكاين] جاديله اكو ممڤوڽاءي كروت يڠ دڤاكاين، جاديله اكو ممڤوڽاءي كروت يڠ دڤاكاين، تتاڤي اكو ماسيه برڤاسڠ. چونتوه: >>> eat(((5), (6), (10)) (std::vector<long>{((() 11, (long) (long) 4)) >>> eat(4), (8), (9) (std::vector<long>{(12, (long) 1)) >>>(1), (10), (10) (std::vector<<((11, (long) (long)) >>>0)) >>>(2), (11), (5) (std::vector<<d::vector::vector<<<d> (long>7>) (long>) V:<<<<<<<<<0>) <) <) <) <) <) <) <) <) <) <) <= 1000:> جاديله اكو تيدقكن جومڤاكوڠ كروت يڠ يڠ دڤي جاديله ڤاكاين، جاديله اكو جاديله اكو ممڤاكنكن كروت دڠن كروت دڠن كروت دڠن كروت: *\nstd::vector<long> eat(long number, long need, long remaining) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = 0;\n    long left = remaining;\n    long to_eat = need;\n\n    if (left >= to_eat) {\n        eaten = to_eat;\n        left -= to_eat;\n    } else {\n        eaten = left;\n        left = 0;\n    }\n\n    return {(long)number + eaten, left};\n}",
        "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
    },
    {
        "task_id": "HumanEval/160",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري دوا ڤيكتور اوڤراتور، دان اوڤراند. ڤيكتور ڤرتام اد اوڤراسي جبر اساس، دان ۏيكتور كدوا اداله ۏيكتور انتيڬري. مڠڬوناكن دوا ڤيكتور يڠ دبري اونتوق ممبينا ايكسڤريسي جبر دان مڽرتاي ڤڠتاهوان ايكسڤريسي اين. اوڤراسي جبر اساس: ڤڠلوارن (+) ڤڠلوارن ( ) - ڤڠلوارن (*) ڤڠلوارن (//) ڤڠلوارن (**) چونتوه: اوڤراتور['+'، '*', '-'] ۏيكتور = [2, 3, 4, 5] ريسلوت = 2 + 3 * 4 - 5 => ريسلوت = 9 تيتق: لڠسوڠ ڤيكتور اوڤراتور سام دڠن لڠسوڠ ڤيكتور اوڤراتور مڠلوار ساتو. اوڤراتور ۏيكتور نا كيرا-كيرا اوڤراتور، دان اوڤراتور ۏيكتور نا كيرا-كيرا دوا اوڤراتور.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::vector<long> current_operand = operand;\n    std::vector<std::string> current_operator = op;\n\n    auto apply_op = [&](long a, long b, const std::string& o) {\n        if (o == \"+\") return a + b;\n        if (o == \"-\") return a - b;\n        if (o == \"*\") return a * b;\n        if (o == \"//\") return a / b;\n        if (o == \"**\") return static_cast<long>(pow(a, b));\n        return 0L; // Should not happen\n    };\n\n    std::vector<std::string> precedence1 = {\"**\"};\n    std::vector<std::string> precedence2 = {\"*\", \"//\"};\n    std::vector<std::string> precedence3 = {\"+\", \"-\"};\n\n    auto evaluate = [&](const std::vector<std::string>& prec) {\n        size_t i = 0;\n        while (i < current_operator.size()) {\n            bool found = false;\n            for (const auto& o : prec) {\n                if (current_operator[i] == o) {\n                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);\n                    current_operand.erase(current_operand.begin() + i + 1);\n                    current_operator.erase(current_operator.begin() + i);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                i++;\n            }\n        }\n    };\n\n    evaluate(precedence1);\n    evaluate(precedence2);\n    evaluate(precedence3);\n\n    return current_operand[0];\n}",
        "test": "}\nint main() {\n    auto candidate = do_algebra;\n    assert(candidate((std::vector<std::string>({(std::string)\"**\", (std::string)\"*\", (std::string)\"+\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\n    assert(candidate((std::vector<std::string>({(std::string)\"+\", (std::string)\"*\", (std::string)\"-\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\n    assert(candidate((std::vector<std::string>({(std::string)\"//\", (std::string)\"*\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\n}\n"
    },
    {
        "task_id": "HumanEval/161",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// جك سسوڠڬوهڽ س[i] اداله حروف، ڤرلوكن سسوڠڬوهڽ كيس دري لوار كاو لوار اتاو ڤد ڤد ڤد ڤد، جك تيدق، ڤرلوكن سسوڠڬوهڽ تيدق. جك سسوڠڬوهڽ سسوڠڬوهڽ سسوڠڬوهڽ تيدق اد حروف، ڤرلوكن سسوڠڬوهڽ سسوڠڬوهڽ سسوڠڬوهڽ. فڠكسي داڤت مڽمبليه سسوڠڬوهڽ. چونتوه >>> solve((\"1234\")) (\"4321\") >>> solve((\"ab\")) (\"AB\") >>> solve((\"#a@C\") (\"#A@c\")\nstd::string solve(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"
    },
    {
        "task_id": "HumanEval/162",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دڤاوڬيت سترين 'تيكس'، ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤرلو ڤيڤيڤيڤيڤي ڤيڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي ڤي\nstd::optional<std::string> string_to_md5(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include <optional>\n\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n"
    },
    {
        "task_id": "HumanEval/163",
        "nl": "ace_Arab",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// دبري دوا انتيڬره ڤوسيتيف a دان b، مروڤاكن ديڬيت ڤون انتارا a دان b، دالم اوردين مڠورڠ. چونتوهڽ: >>> generate_integers (((2), (8)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8)) >>> generate_integers (((8), (2)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8)) >>> generate_integers (((10), (14)) (std::vector<long> ((())\nstd::vector<long> generate_integers(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n"
    }
]