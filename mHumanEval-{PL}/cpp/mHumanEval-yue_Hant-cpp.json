[
    {
        "task_id": "HumanEval/0",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 檢查在數字向量中,有沒有兩個數字相近而不是相近的值. >>> has_close_elements (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_元素) (有_接近_接近_元素) (有_接近_接近_元素) (有_接近_接近_元素) (有_接近_接近_元素) (有_接近_接近_接近_元素) (有_接近_接近_接近_元素)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
        "canonical_solutions": "bool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = has_close_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/1",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 輸入到這個函數嘅字符串包含多個嵌套括號組.你的目標是將呢啲組分成獨立嘅字符串,並返回呢啲組嘅向量.獨立嘅組係平衡嘅 (每個開放括號都被正確地關閉),並唔系彼此嵌套嘅.忽略輸入字符串裡嘅任何空格. >>> separate_paren_groups(\"( ) (() ) ((( ) \") (std::vector<std::string>({(std::string) \")\", ((((())\", (std::string) \"((())))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int balance = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') continue;  // Ignore spaces\n\n        current_group += ch;\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance == 0) {  // Found a balanced group\n                groups.push_back(current_group);\n                current_group.clear();\n            }\n        }\n    }\n\n    return groups;\n}",
        "test": "}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"(()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/2",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正的浮点数,它可以分解成整数部分 (最大的整数小于给定数) 和小数点 (剩余部分总是小于1).返回数的小数点部分. >>> truncate_number((3.5f)) (0.5f)\nfloat truncate_number(float number) {\n",
        "canonical_solutions": "float truncate_number(float number) {\n    return number - std::floor(number);\n}",
        "test": "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5f)) == (0.5f));\n    assert(candidate((1.25f)) == (0.25f));\n    assert(candidate((123.0f)) == (0.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/3",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 您可以用一個一個銀行帳戶的存款和提款操作向量,而這個向量開始於零餘額.您的任務是檢測是否在任何一個點,帳戶餘額跌到零,在那個點,函數應該返回 true.否則它應該返回 false. >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)\nbool below_zero(std::vector<long> operations) {\n",
        "canonical_solutions": "bool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = below_zero;\n    assert(candidate((std::vector<long>())) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/4",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 对于给定的输入数向量,计算这个数据集的平均值周围的平均绝对偏差.平均绝对偏差是每个元素和中心点 (在这种情况下的平均值) 之间的平均绝对差异:MAD = 平均值 x - x_mean >>> mean_absolute_deviation (((std::vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f}))) (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
        "canonical_solutions": "float mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, \n                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) \n                / numbers.size();\n    return mad;\n}",
        "test": "}\nint main() {\n    auto candidate = mean_absolute_deviation;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n}\n"
    },
    {
        "task_id": "HumanEval/5",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 輸入向量每兩個連續元素之間輸入一個數字\"分隔線\" `numbers' >>> intersperse((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1, (long) 2, (long) 3}), (4)) (std::vector<long>({long) 1, (long) 4, (long) 2, (long) 4, (long) 3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
        "canonical_solutions": "std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<long> result;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = intersperse;\n    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));\n    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/6",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 函數的輸入是一個字符串,代表多個組為以空格分隔的嵌套括號.對每個組,輸出括號的最深層嵌套.例如 (() (()) 有最多兩層嵌套而 ((())) 有三層. >>> parse_nested_parens (((\"(())) ((())) () ((()))))))) (std::vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
        "canonical_solutions": "std::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> depths;\n    long current_depth = 0, max_depth = 0;\n\n    for (char ch : paren_string) {\n        if (ch == ' ') {\n            if (max_depth > 0) {\n                depths.push_back(max_depth);\n                max_depth = 0;\n            }\n            current_depth = 0;\n        } else if (ch == '(') {\n            current_depth++;\n            max_depth = std::max(max_depth, current_depth);\n        } else if (ch == ')') {\n            current_depth--;\n        }\n    }\n\n    if (max_depth > 0) {\n        depths.push_back(max_depth);\n    }\n\n    return depths;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
    },
    {
        "task_id": "HumanEval/7",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 出一個輸入字串向量,只出包含特定子字串嘅字串 >>> filter_by_substring((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_substring(((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bacd\", (std::string) \"cde\", (std::string) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) abc\", (std::string) \"bac\"d\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_substring;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"aaaxxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"aaaxxy\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"grunt\", (std::string)\"trumpet\", (std::string)\"prune\", (std::string)\"gruesome\"})), (\"run\")) == (std::vector<std::string>({(std::string)\"grunt\", (std::string)\"prune\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/8",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 对于给定的整数向量,返回一个由向量中的所有整数的和和乘积组成的元组.空的和应等于0而空的乘积应等于1. >>> sum_product (((std::vector<long>())) (std::make_tuple ((0, 1)) >>> sum_product (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple ((10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);\n    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());\n    return std::make_tuple(sum, product);\n}",
        "test": "}\nint main() {\n    auto candidate = sum_product;\n    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));\n    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));\n    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));\n}\n"
    },
    {
        "task_id": "HumanEval/9",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 從一個數整數的向量,生成一個向量,以至於序列中所謂的時刻,找到的最大元素. >>> rolling_max((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = LONG_MIN;\n\n    for (long num : numbers) {\n        max_so_far = std::max(max_so_far, num);\n        result.push_back(max_so_far);\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = rolling_max;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));\n}\n"
    },
    {
        "task_id": "HumanEval/10",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 尋找以一個已提供字符串開始的最短的複數.算法概念簡單: - 尋找已提供字符串中最長的複數後附加詞,而這個字符串為複數. - 將一個在複數後尾之前的字符串前附加到字符串末尾的逆向. >>> make_palindrome((\"\")) (\"\") >>> make_palindrome((\"cat\")) (\"catac\") >>> make_palindrome((\"cata\")) (\"catac\")\nstd::string make_palindrome(std::string string) {\n",
        "canonical_solutions": "std::string make_palindrome(std::string string) {\n    auto is_palindrome = [](const std::string &s) {\n        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    };\n\n    for (size_t i = 0; i < string.size(); ++i) {\n        if (is_palindrome(string.substr(i))) {\n            std::string prefix = string.substr(0, i);\n            std::reverse(prefix.begin(), prefix.end());\n            return string + prefix;\n        }\n    }\n\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"jerry\")) == (\"jerryrrej\"));\n}\n"
    },
    {
        "task_id": "HumanEval/11",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 入力是兩個字符串 a 和 b 只包含 1s 和 0s.對這些輸入進行二進制 XOR,並將結果還成字符串.\nstd::string string_xor(std::string a, std::string b) {\n",
        "canonical_solutions": "std::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\")) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n}\n"
    },
    {
        "task_id": "HumanEval/12",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 喺字符串向量裡面,返回最長嘅. 如果有同長嘅多個字符串,返回第一個. 如果輸入向量係空嘅,返回無. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest(((std::vector<std::string>{((std::string) \"a\", (std::string) \"b\", (std::string) \"c\"}))) \"a\" >>> longest((((std::vector<std::string>(({(std::string) \"a\", (std::string) \"bb\", (std::string) \"ccc\"}))) \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) return std::nullopt;\n\n    return *std::max_element(strings.begin(), strings.end(), \n                             [](const std::string& a, const std::string& b) {\n                                 return a.size() < b.size();\n                             });\n}",
        "test": "}\nint main() {\n    auto candidate = longest;\n    assert(candidate((std::vector<std::string>())) == std::nullopt);\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == \"x\");\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"yyy\", (std::string)\"zzzz\", (std::string)\"www\", (std::string)\"kkkk\", (std::string)\"abc\"}))) == \"zzzz\");\n}\n"
    },
    {
        "task_id": "HumanEval/13",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回两个整数 a 和 b 的最大公分数 >>> 最大_公分数 (greatest_common_divisor) (((3), (5)) (1) >>> 最大_公分数 (greatest_common_divisor) (((25), (15)) (5)\nlong greatest_common_divisor(long a, long b) {\n",
        "canonical_solutions": "long greatest_common_divisor(long a, long b) {\n    return std::gcd(a, b);\n}",
        "test": "}\nint main() {\n    auto candidate = greatest_common_divisor;\n    assert(candidate((3), (7)) == (1));\n    assert(candidate((10), (15)) == (5));\n    assert(candidate((49), (14)) == (7));\n    assert(candidate((144), (60)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/14",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回所有前从输入字符串中最短到最长的前 >>> all_prefixes (((\"abc\")) (std::vector<std::string>({(std::string) \"a\", (std::string) \"ab\", (std::string) \"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n",
        "canonical_solutions": "std::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (size_t i = 1; i <= string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i));\n    }\n    return prefixes;\n}",
        "test": "}\nint main() {\n    auto candidate = all_prefixes;\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"asdfgh\")) == (std::vector<std::string>({(std::string)\"a\", (std::string)\"as\", (std::string)\"asd\", (std::string)\"asdf\", (std::string)\"asdfg\", (std::string)\"asdfgh\"})));\n    assert(candidate((\"WWW\")) == (std::vector<std::string>({(std::string)\"W\", (std::string)\"WW\", (std::string)\"WWW\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/15",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回包含由 0 到 n 包含的空格划分数的字符串. >>> string_sequence((0)) (\"0\") >>> string_sequence((5)) (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n",
        "canonical_solutions": "std::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) oss << \" \";\n        oss << i;\n    }\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_sequence;\n    assert(candidate((0)) == (\"0\"));\n    assert(candidate((3)) == (\"0 1 2 3\"));\n    assert(candidate((10)) == (\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"
    },
    {
        "task_id": "HumanEval/16",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个字符串,找出它有多少个不同字符 (不论大小写) >>> count_distinct_characters (((\"xyzXYZ\")) (3) >>> count_distinct_characters (((\"Jerry\")) (4)\nlong count_distinct_characters(std::string string) {\n",
        "canonical_solutions": "long count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n    for (char ch : string) {\n        distinct_chars.insert(std::tolower(ch));\n    }\n    return distinct_chars.size();\n}",
        "test": "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
    },
    {
        "task_id": "HumanEval/17",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 輸入到這個函數是一個以 ASCII 格式表示音樂音符的弦.你的任務是解析對應於多少節拍的整數弦向量.以下是一個字典: 'o' note, lasts four beats 'o.r' - lasts half note, lasts two beats 'o.r' - lasts one beat >>> parse_music. () () () () () () () () () () () () () () () () () () () ()) (stdvector<(long>{(long) 4, (long) 2, (long) 1, (long) 2, (long) 2, (long) 1, (long) 1, (long) 1, (long) 1, (long) 4, (long) 4}) 返回每個個個任務並沒有整數,這個特殊任務是如何完成?\nstd::vector<long> parse_music(std::string music_string) {\n",
        "canonical_solutions": "std::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::istringstream iss(music_string);\n    std::string note;\n    \n    while (iss >> note) {\n        if (note == \"o\") beats.push_back(4);\n        else if (note == \"o|\") beats.push_back(2);\n        else if (note == \".|\") beats.push_back(1);\n    }\n\n    return beats;\n}",
        "test": "}\nint main() {\n    auto candidate = parse_music;\n    assert(candidate((\"\")) == (std::vector<long>()));\n    assert(candidate((\"o o o o\")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\".| .| .| .|\")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));\n    assert(candidate((\"o| o| .| .| o o o o\")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));\n    assert(candidate((\"o| .| o| .| o o| o o|\")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));\n}\n"
    },
    {
        "task_id": "HumanEval/18",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 求出某個字符串可以喺原始字符串中找到幾次.數個重覆嘅情況. >>> how_many_times((\"\"), (\"a\")) (0) >>> how_many_times(\"aaa\"), (\"a\") (3) >>> how_many_times(\"aaaa\"), (\"aa\") (3)\nlong how_many_times(std::string string, std::string substring) {\n",
        "canonical_solutions": "long how_many_times(std::string string, std::string substring) {\n    if (substring.empty()) return 0;\n    \n    long count = 0;\n    size_t pos = 0;\n    \n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos++;  // Move one position forward to count overlapping occurrences\n    }\n    \n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"john doe\"), (\"john\")) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/19",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 入力是由\"零\"到\"九\"的數字字串. 有效選擇是\"零\"\",一\"\",二\"\",三\"\",四\"\",五\"\",六\"\",七\"\",八\"和\"九\". 返回從最小到最大排序的數字串 >>> sort_numbers((\"三一五\")) (\"一三五\")\nstd::string sort_numbers(std::string numbers) {\n",
        "canonical_solutions": "std::string sort_numbers(std::string numbers) {\n    std::unordered_map<std::string, int> num_map = {\n        {\"zero\", 0}, {\"one\", 1}, {\"two\", 2}, {\"three\", 3}, {\"four\", 4},\n        {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9}\n    };\n\n    std::unordered_map<int, std::string> rev_map = {\n        {0, \"zero\"}, {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"},\n        {5, \"five\"}, {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"}\n    };\n\n    std::istringstream iss(numbers);\n    std::vector<int> num_list;\n    std::string word;\n\n    while (iss >> word) {\n        num_list.push_back(num_map[word]);\n    }\n\n    std::sort(num_list.begin(), num_list.end());\n\n    std::ostringstream oss;\n    for (size_t i = 0; i < num_list.size(); ++i) {\n        if (i > 0) oss << \" \";\n        oss << rev_map[num_list[i]];\n    }\n\n    return oss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = sort_numbers;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"three\")) == (\"three\"));\n    assert(candidate((\"three five nine\")) == (\"three five nine\"));\n    assert(candidate((\"five zero four seven nine eight\")) == (\"zero four five seven eight nine\"));\n    assert(candidate((\"six five four three two one zero\")) == (\"zero one two three four five six\"));\n}\n"
    },
    {
        "task_id": "HumanEval/20",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 從數字向量 (長度至少兩) 中選擇並返回兩個最接近彼此的數字並按順序返回 (小數字,大數字). >>> find_closest_elements (找到_最近_元素)\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i - 1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i - 1];\n            num2 = numbers[i];\n        }\n    }\n\n    return std::make_tuple(num1, num2);\n}",
        "test": "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));\n    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));\n}\n"
    },
    {
        "task_id": "HumanEval/21",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定数向量 (至少有两个元素),将线性变换应用到该向量上,使最小的数变为0和最大的数变为1 >>> rescale_to_unit (转换尺度为单位)\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
        "canonical_solutions": "std::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    for (float &num : numbers) {\n        num = (num - min_val) / (max_val - min_val);\n    }\n\n    return numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));\n    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));\n}\n"
    },
    {
        "task_id": "HumanEval/22",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 除任何cppthon值的给定向量,只对整数 >>> filter_integers((std::vector<std::any>({(std::string) \"a\", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::<long,map>),((((long>)))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
        "canonical_solutions": "std::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (const auto& val : values) {\n        if (val.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(val));\n        } else if (val.type() == typeid(int)) {\n            result.push_back(std::any_cast<int>(val));\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_integers;\n    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));\n    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, \"adasd\"}))) == (std::vector<long>({(long)4, (long)9})));\n    assert(candidate((std::vector<std::any>({3, \"c\", 3, 3, \"a\", \"b\"}))) == (std::vector<long>({(long)3, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/23",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回给定的字符串的长度 >>> string_length((\"\")) (0) >>> string_length((\"abc\")) (3)\nlong string_length(std::string string) {\n",
        "canonical_solutions": "long string_length(std::string string) {\n    return string.length();\n}",
        "test": "}\nint main() {\n    auto candidate = string_length;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"x\")) == (1));\n    assert(candidate((\"asdasnakj\")) == (9));\n}\n"
    },
    {
        "task_id": "HumanEval/24",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个数 n,求最大的数,除以 n,小于 n >>>最大_除法数 (最大_除法数)\nlong largest_divisor(long n) {\n",
        "canonical_solutions": "long largest_divisor(long n) {\n    for (long i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_divisor;\n    assert(candidate((3)) == (1));\n    assert(candidate((7)) == (1));\n    assert(candidate((10)) == (5));\n    assert(candidate((100)) == (50));\n    assert(candidate((49)) == (7));\n}\n"
    },
    {
        "task_id": "HumanEval/25",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回由最小到最大的顺序按一整數的素因子的向量.每一個因子應由因子數的次數對應於它在因子化中出現的次數.輸入數應等於所有因子的積 >>> 分因子化 ((8)) (std::vector<long>({(long) 2, (long) 2, (long) 2})) >>> 分因子化 ((25)) (std::vector<long>({(long) 5, (long) 5})) >>> 分因子化 ((((70)) (std::vector<long>({(long) 2, (long) 5, (long) 7}))\nstd::vector<long> factorize(long n) {\n",
        "canonical_solutions": "std::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}",
        "test": "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2)) == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/26",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 從一個整數向量中,將所有多過一次出現嘅元素除.保持元素嘅排序與輸入一樣. >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
        "canonical_solutions": "std::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> freq;\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));\n}\n"
    },
    {
        "task_id": "HumanEval/27",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 轉換小寫字符串,轉換大寫字符串,轉換大寫字符串.\nstd::string flip_case(std::string string) {\n",
        "canonical_solutions": "std::string flip_case(std::string string) {\n    for (char &ch : string) {\n        if (std::islower(ch)) {\n            ch = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            ch = std::tolower(ch);\n        }\n    }\n    return string;\n}",
        "test": "}\nint main() {\n    auto candidate = flip_case;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hello!\")) == (\"hELLO!\"));\n    assert(candidate((\"These violent delights have violent ends\")) == (\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"
    },
    {
        "task_id": "HumanEval/28",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串串\nstd::string concatenate(std::vector<std::string> strings) {\n",
        "canonical_solutions": "std::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = concatenate;\n    assert(candidate((std::vector<std::string>())) == (\"\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\"}))) == (\"xyz\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"x\", (std::string)\"y\", (std::string)\"z\", (std::string)\"w\", (std::string)\"k\"}))) == (\"xyzwk\"));\n}\n"
    },
    {
        "task_id": "HumanEval/29",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 出一個輸入字串向量,只出以一個特定前開始嘅字串. >>> filter_by_prefix((std::vector<std::string>()), (\"a\")) (std::vector<std::string>()) >>> filter_by_prefix((std::vector<std::string>({(std::string) \"abc\", (std::string) \"bcd\", (std::string)::\"cde\", (stdstring) \"array\"})), (\"a\") (std::vector<std::string>(({(std::string) \"abc\", (std::string) \"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
        "canonical_solutions": "std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (const auto& str : strings) {\n        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'\n            result.push_back(str);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"xxx\", (std::string)\"asd\", (std::string)\"xxy\", (std::string)\"john doe\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})), (\"xxx\")) == (std::vector<std::string>({(std::string)\"xxx\", (std::string)\"xxxAAA\", (std::string)\"xxx\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/30",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回矢量中只有正數. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive((std::vector<long>({long) -5, (long) -5, (long) -2, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1)))\nstd::vector<long> get_positive(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = get_positive;\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/31",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 如果某個數字係素數,返回真,如果唔係,返回錯. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4) (false) >>> is_prime(1) (false)\nbool is_prime(long n) {\n",
        "canonical_solutions": "bool is_prime(long n) {\n    if (n < 2) return false;\n    if (n < 4) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_prime;\n    assert(candidate((6)) == (false));\n    assert(candidate((101)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((13441)) == (true));\n    assert(candidate((61)) == (true));\n    assert(candidate((4)) == (false));\n    assert(candidate((1)) == (false));\n    assert(candidate((5)) == (true));\n    assert(candidate((11)) == (true));\n    assert(candidate((17)) == (true));\n    assert(candidate((85)) == (false));\n    assert(candidate((77)) == (false));\n    assert(candidate((255379)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/33",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 呢個函數取一個向量l,並返回一個向量l',使得在未能以三除的指標中,l與l相同,而在以三除的指標中,它的值等於l對應的指標的值,但已被排序. >>> sort_third(((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third((std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std::vector<(long>{(long) 2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> third_indices;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_indices.push_back(l[i]);\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = third_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_third;\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/34",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回向量中排序的唯一元素 >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))\nstd::vector<long> unique(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = unique;\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));\n}\n"
    },
    {
        "task_id": "HumanEval/35",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回向量中最大元素. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) - 10}))) (123)\nlong max_element(std::vector<long> l) {\n",
        "canonical_solutions": "long max_element(std::vector<long> l) {\n    return *std::max_element(l.begin(), l.end());\n}",
        "test": "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));\n}\n"
    },
    {
        "task_id": "HumanEval/36",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回数字7在小于n的整数中出现的次数,这些整数可被11或13除以. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)\nlong fizz_buzz(long n) {\n",
        "canonical_solutions": "long fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            long temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = fizz_buzz;\n    assert(candidate((50)) == (0));\n    assert(candidate((78)) == (2));\n    assert(candidate((79)) == (3));\n    assert(candidate((100)) == (3));\n    assert(candidate((200)) == (6));\n    assert(candidate((4000)) == (192));\n    assert(candidate((10000)) == (639));\n    assert(candidate((100000)) == (8026));\n}\n"
    },
    {
        "task_id": "HumanEval/37",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 呢個函數取一個向量l,並返回一個向量l',使得在奇數的指標中,l與l相同,而在偶數的指標中,它的值等於l的偶數的值,但已被排序. >>> sort_even{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_even}{\\displaystyle {sort_{{even}}}{\\displaystyle {sort_{sort_{even}}}}{sort_{sort_{sort_{even}}{sort_{sort_{sort_{sort_{sort_}}}}}}}}}}}}}}}}}}}}\nstd::vector<long> sort_even(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    \n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices[idx++];\n    }\n    \n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_even;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));\n}\n"
    },
    {
        "task_id": "HumanEval/39",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib返回第n個數字,即一個斐波那契數字,而且也是一個prime數字. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib((3)) (5) >>> prime_fib((4)) (13) >>> prime_fib(5) (89)\nlong prime_fib(long n) {\n",
        "canonical_solutions": "bool is_prime(long num) {\n    if (num < 2) return false;\n    if (num < 4) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (long i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nlong prime_fib(long n) {\n    std::vector<long> prime_fibs;\n    long a = 1, b = 1;\n    while (prime_fibs.size() < n) {\n        long next = a + b;\n        a = b;\n        b = next;\n        if (is_prime(next)) {\n            prime_fibs.push_back(next);\n        }\n    }\n    return prime_fibs[n - 1];\n}",
        "test": "}\nint main() {\n    auto candidate = prime_fib;\n    assert(candidate((1)) == (2));\n    assert(candidate((2)) == (3));\n    assert(candidate((3)) == (5));\n    assert(candidate((4)) == (13));\n    assert(candidate((5)) == (89));\n    assert(candidate((6)) == (233));\n    assert(candidate((7)) == (1597));\n    assert(candidate((8)) == (28657));\n    assert(candidate((9)) == (514229));\n    assert(candidate((10)) == (433494437));\n}\n"
    },
    {
        "task_id": "HumanEval/40",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero 取整數向量作為輸入.如果向量中有三個不同元素的總和為零,則返回 true,否則返回 false. >>> triples_sum_to_zero (三個不同元素的總和為零,否則返回 true. >>> triples_sum_to_zero (三個不同元素的總和為零,否則返回 false. >>> triples_sum_to_zero (三個不同元素的總和為零,否則返回 true.\nbool triples_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n - 2; i++) {\n        size_t left = i + 1, right = n - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    \n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = triples_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));\n    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/41",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 想像一條完全直嘅無限長嘅路線.有 n 輛車從左到右行駛;同時,有另一組 n 輛車從右到左行駛.兩組車開始時相距非常遠.所有車嘅速度都係一樣.當一輛從左到右行駛嘅車撞到從右到左行駛嘅車時,有兩輛車被稱為相撞.但車係無限堅固嘅,強大嘅;結果,佢地繼續喺佢地嘅軌道上行駛,好似唔相撞咁.呢個函數輸出咗咁多次嘅碰撞.\nlong car_race_collision(long n) {\n",
        "canonical_solutions": "long car_race_collision(long n) {\n    return n * n;\n}",
        "test": "}\nint main() {\n    auto candidate = car_race_collision;\n    assert(candidate((2)) == (4));\n    assert(candidate((3)) == (9));\n    assert(candidate((4)) == (16));\n    assert(candidate((8)) == (64));\n    assert(candidate((10)) == (100));\n}\n"
    },
    {
        "task_id": "HumanEval/42",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回元素增量為 1. >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>({long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>({long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>({long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n",
        "canonical_solutions": "std::vector<long> incr_list(std::vector<long> l) {\n    for (long &num : l) {\n        num++;\n    }\n    return l;\n}",
        "test": "}\nint main() {\n    auto candidate = incr_list;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));\n    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));\n}\n"
    },
    {
        "task_id": "HumanEval/43",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero 取整數向量作為輸入.如果向量中有兩個不同元素的總和為零,它會返回 true,否則 false. >>> pairs_sum_to_zero (), (long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero (), (long) 1, (long) 3, (long) 2, (long) 1} (false) >>> pairs_sum_to_zero (,), (long) 3, (long) 3, (long) 7} (false) >>> pairs_sum_to_zero (,long) 2, (long) 5, (long) 3, (long) 5, (long) 7} (false) >>> pairs_sum_to_zero (,long) 6, (long) 6, (long) 7, (long) 8, (long) 9, (long) 9, (long) 10, (long) 10, (long) 10, (long) 10, (long) 11, (long) 11, (long) 12, (long) 11, (long) 11, (long) 12, (long) 11, (long) 11, (long 12, (long) 11, (long 12, (long 13) >>> pairs_sum_to_zero (, (, (long)\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
        "canonical_solutions": "bool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> seen;\n    for (long num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = pairs_sum_to_zero;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));\n    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/44",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 改輸入數字x的數值底座為底座. 轉換後返回字符串表示.底數小於10. >>> change_base((8), (3)) (\"22\") >>> change_base(8), (2)) (\"1000\") >>> change_base((7), (2)) (\"111\")\nstd::string change_base(long x, long base) {\n",
        "canonical_solutions": "std::string change_base(long x, long base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8), (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234), (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n    assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) == (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3), (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5), (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7), (8)) == (\"7\"));\n}\n"
    },
    {
        "task_id": "HumanEval/45",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定三角形的边长和高回归面积. >>> triangle_area((5), (3)) (7.5f)\nfloat triangle_area(long a, long h) {\n",
        "canonical_solutions": "float triangle_area(long a, long h) {\n    return 0.5f * a * h;\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((5), (3)) == (7.5f));\n    assert(candidate((2), (2)) == (2.0f));\n    assert(candidate((10), (8)) == (40.0f));\n}\n"
    },
    {
        "task_id": "HumanEval/46",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Fib4數字序列係類似Fibbonacci數字序列嘅序列,定義係咁: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).請寫一個函數,有效計算 fib4數字序列嘅第n個元素.唔好用復習. >>> fib4((5)) (4) >>> fib4(6)) (8) >>> fib4((7)) (14)\nlong fib4(long n) {\n",
        "canonical_solutions": "long fib4(long n) {\n    if (n == 0 || n == 1 || n == 3) return 0;\n    if (n == 2) return 2;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 2;\n\n    for (long i = 4; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fib4;\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (28));\n    assert(candidate((10)) == (104));\n    assert(candidate((12)) == (386));\n}\n"
    },
    {
        "task_id": "HumanEval/47",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回向量 l 中位數. >>> 中位數((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (浮數(3)) >>> 中位數((std::vector<long>({(long) -10, (long) 4, (long) 6, (long) 1000, (long) 10, (long) 20}))) (15.0f)\nfloat median(std::vector<long> l) {\n",
        "canonical_solutions": "float median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    size_t n = l.size();\n    \n    if (n % 2 == 1) {\n        return static_cast<float>(l[n / 2]);\n    } else {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));\n    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
    },
    {
        "task_id": "HumanEval/48",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 檢查是否給定的字符串是一個平行符號 >>> is_palindrome (((\"\")) (true) >>> is_palindrome (((\"aba\")) (true) >>> is_palindrome (((\"aaaaa\")) (true) >>> is_palindrome (((\"zbcd\")) (false)\nbool is_palindrome(std::string text) {\n",
        "canonical_solutions": "bool is_palindrome(std::string text) {\n    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());\n}",
        "test": "}\nint main() {\n    auto candidate = is_palindrome;\n    assert(candidate((\"\")) == (true));\n    assert(candidate((\"aba\")) == (true));\n    assert(candidate((\"aaaaa\")) == (true));\n    assert(candidate((\"zbcd\")) == (false));\n    assert(candidate((\"xywyx\")) == (true));\n    assert(candidate((\"xywyz\")) == (false));\n    assert(candidate((\"xywzx\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/49",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回2^n模块p (注意数字). >>> modp((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp((0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101)) (1)\nlong modp(long n, long p) {\n",
        "canonical_solutions": "long modp(long n, long p) {\n    return std::pow(2, n) % p;\n}",
        "test": "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/51",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels係一個函數,可以取字串並返回無母音嘅字串. >>> remove_vowels(\"\")) (\"\") >>> remove_vowels(\"abcdef\")) (\"bcdf\") >>> remove_vowels(\"aaaaa\")) (\"\") >>> remove_vowels(\"aaBAA\")) (\"B\") >>> remove_vowels(\"zbcd\")) (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n",
        "canonical_solutions": "std::string remove_vowels(std::string text) {\n    std::string result;\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    \n    for (char ch : text) {\n        if (vowels.find(ch) == vowels.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = remove_vowels;\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"abcdef\\nghijklm\")) == (\"bcdf\\nghjklm\"));\n    assert(candidate((\"fedcba\")) == (\"fdcb\"));\n    assert(candidate((\"eeeee\")) == (\"\"));\n    assert(candidate((\"acBAA\")) == (\"cB\"));\n    assert(candidate((\"EcBOO\")) == (\"cB\"));\n    assert(candidate((\"ybcd\")) == (\"ybcd\"));\n}\n"
    },
    {
        "task_id": "HumanEval/52",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 如果向量l中的所有数都低于值t,则返回true. >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)\nbool below_threshold(std::vector<long> l, long t) {\n",
        "canonical_solutions": "bool below_threshold(std::vector<long> l, long t) {\n    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });\n}",
        "test": "}\nint main() {\n    auto candidate = below_threshold;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/53",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 兩個數字x和y加起來,加上 (x,y) 來,加上 (x,y) 來,加上 (x,y) 來,加上 (x,y) 來,加上 (x,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,\nlong add(long x, long y) {\n",
        "canonical_solutions": "long add(long x, long y) {\n    return x + y;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((0), (1)) == (1));\n    assert(candidate((1), (0)) == (1));\n    assert(candidate((2), (3)) == (5));\n    assert(candidate((5), (7)) == (12));\n    assert(candidate((7), (5)) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/54",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 檢查兩個詞是否有相同的字符. >>> same_chars(\"eabcdzzzz\"), (\"dddzzzzzzdeddabc\")) (真實) >>> same_chars((\"abcd\"), (\"dddddddabc\")) (真實) >>> same_chars(\"dddddddabc\"), (\"abcd\") (真實) >>> same_chars((\"eabcd\"), (\"dddddddabc\")) (錯誤) same_chars >>>\"(abcd\"), (\"dddddddabce\") (錯誤) >>> same_chars(\"eabcd\"), (\"ddddzzzzzddddddabc\") (錯誤)\nbool same_chars(std::string s0, std::string s1) {\n",
        "canonical_solutions": "bool same_chars(std::string s0, std::string s1) {\n    std::unordered_set<char> set0(s0.begin(), s0.end());\n    std::unordered_set<char> set1(s1.begin(), s1.end());\n    return set0 == set1;\n}",
        "test": "}\nint main() {\n    auto candidate = same_chars;\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(candidate((\"abcd\"), (\"dddddddabc\")) == (true));\n    assert(candidate((\"dddddddabc\"), (\"abcd\")) == (true));\n    assert(candidate((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(candidate((\"abcd\"), (\"dddddddabcf\")) == (false));\n    assert(candidate((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    assert(candidate((\"aabb\"), (\"aaccc\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/55",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回第 n 个斐波那契数. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)\nlong fib(long n) {\n",
        "canonical_solutions": "long fib(long n) {\n    if (n <= 1) return n;\n    \n    long a = 0, b = 1, c;\n    for (long i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    \n    return b;\n}",
        "test": "}\nint main() {\n    auto candidate = fib;\n    assert(candidate((10)) == (55));\n    assert(candidate((1)) == (1));\n    assert(candidate((8)) == (21));\n    assert(candidate((11)) == (89));\n    assert(candidate((12)) == (144));\n}\n"
    },
    {
        "task_id": "HumanEval/56",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets 是一個字符串\"<\"和\">\". 如果每個開啟的括號都有相應的關閉括號,則返回 true. >>> correct_bracketing((\"<\")) (false) >>> correct_bracketing(\"<>\")) (true) >>> correct_bracketing(\"<><>\")) (true) >>> correct_bracketing(\">(<>\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') balance++;\n        else if (ch == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"<>\")) == (true));\n    assert(candidate((\"<<><>>\")) == (true));\n    assert(candidate((\"<><><<><>><>\")) == (true));\n    assert(candidate((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(candidate((\"<<<><>>>>\")) == (false));\n    assert(candidate((\"><<>\")) == (false));\n    assert(candidate((\"<\")) == (false));\n    assert(candidate((\"<<<<\")) == (false));\n    assert(candidate((\">\")) == (false));\n    assert(candidate((\"<<>\")) == (false));\n    assert(candidate((\"<><><<><>><>><<>\")) == (false));\n    assert(candidate((\"<><><<><>><>>><>\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/57",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回true 是向量元素均增长或减少. >>> monotonic(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (true) >>> monotonic(((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (false) >>> monotonic(((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (true)\nbool monotonic(std::vector<long> l) {\n",
        "canonical_solutions": "bool monotonic(std::vector<long> l) {\n    bool increasing = true, decreasing = true;\n    \n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) decreasing = false;\n        if (l[i] < l[i - 1]) increasing = false;\n    }\n    \n    return increasing || decreasing;\n}",
        "test": "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/58",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回兩個向量排序的獨特的共同元素. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
        "canonical_solutions": "std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::unordered_set<long> set1(l1.begin(), l1.end());\n    std::unordered_set<long> result_set;\n    \n    for (long num : l2) {\n        if (set1.count(num)) {\n            result_set.insert(num);\n        }\n    }\n    \n    std::vector<long> result(result_set.begin(), result_set.end());\n    std::sort(result.begin(), result.end());\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));\n    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/59",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 返回n的最大素因子.假设n > 1且不是素因子. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)\nlong largest_prime_factor(long n) {\n",
        "canonical_solutions": "long largest_prime_factor(long n) {\n    long largest = -1;\n    \n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    \n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    \n    if (n > 1) largest = n;\n    \n    return largest;\n}",
        "test": "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15)) == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n}\n"
    },
    {
        "task_id": "HumanEval/60",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n係一個函數,可以從 1 到 n 總結數字. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)\nlong sum_to_n(long n) {\n",
        "canonical_solutions": "long sum_to_n(long n) {\n    return n * (n + 1) / 2;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_to_n;\n    assert(candidate((1)) == (1));\n    assert(candidate((6)) == (21));\n    assert(candidate((11)) == (66));\n    assert(candidate((30)) == (465));\n    assert(candidate((100)) == (5050));\n}\n"
    },
    {
        "task_id": "HumanEval/61",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\". return true if every opening bracket has a corresponding closing bracket. >>> correct_bracketing((\"(\")) (false) >>> correct_bracketing(\"() \") (true) >>> correct_bracketing(\"(()))) (true) >>> correct_bracketing((\") (false)\nbool correct_bracketing(std::string brackets) {\n",
        "canonical_solutions": "bool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') balance++;\n        else if (ch == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}",
        "test": "}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/62",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs 表示多項式的系數. xs[0] + xs[1] * x + xs[2] * x^2 + .... 返回這個多項式的導數以相同的形式. >>> 導數:{(std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> 導數:{(std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n",
        "canonical_solutions": "std::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (size_t i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = derivative;\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));\n    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/63",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// FibFib數列係類似Fibbonacci數列嘅數列,定義係咁: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).請寫一個函數,有效計算 fibfib數列嘅第n個元素. >>> fibfib((1)) (0) >>> fib((5)) (4) >>> fib(8)) (24)\nlong fibfib(long n) {\n",
        "canonical_solutions": "long fibfib(long n) {\n    if (n == 0 || n == 1) return 0;\n    if (n == 2) return 1;\n\n    std::vector<long> dp(n + 1, 0);\n    dp[2] = 1;\n\n    for (long i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n\n    return dp[n];\n}",
        "test": "}\nint main() {\n    auto candidate = fibfib;\n    assert(candidate((2)) == (1));\n    assert(candidate((1)) == (0));\n    assert(candidate((5)) == (4));\n    assert(candidate((8)) == (24));\n    assert(candidate((10)) == (81));\n    assert(candidate((12)) == (274));\n    assert(candidate((14)) == (927));\n}\n"
    },
    {
        "task_id": "HumanEval/64",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數vowels_count,它會用一條代表單詞的字串作為輸入,並返回字串中母音的數量.在這個例子中,母音是'a', 'e', 'i', 'o', 'u'.在這裡,'y'也是一個母音,但只有在它在該詞的結尾時.範例: >>> vowels_count (((\"abcde\")) (2) >>> vowels_count ((\"ACEDY\") (3)\nlong vowels_count(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong vowels_count(std::string s) {\n  long count = 0;\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  for (char c : s) {\n    if (vowels.count(c)) {\n      count++;\n    }\n  }\n  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n    count++;\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = vowels_count;\n    assert(candidate((\"abcde\")) == (2));\n    assert(candidate((\"Alone\")) == (3));\n    assert(candidate((\"key\")) == (2));\n    assert(candidate((\"bye\")) == (1));\n    assert(candidate((\"keY\")) == (2));\n    assert(candidate((\"bYe\")) == (1));\n    assert(candidate((\"ACEDY\")) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/65",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 轉換整數 x 轉換成一個圓,轉換成右轉換成一個字符串.如果轉換 > 數字數,轉換成反轉換. >>> circular_shift (((12), (1)) (\"21\") >>> circular_shift (((12), (2)) (\"12\")\nstd::string circular_shift(long x, long shift) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string circular_shift(long x, long shift) {\n  std::string s = std::to_string(x);\n  long n = s.length();\n  if (n == 0) {\n    return \"\";\n  }\n  shift %= n;\n  if (shift < 0) {\n    shift += n;\n  }\n  if (shift == 0) {\n    return s;\n  }\n  if (shift > n) {\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);\n  return shifted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100), (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97), (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11), (101)) == (\"11\"));\n}\n"
    },
    {
        "task_id": "HumanEval/66",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 任務 寫一個函數,以字符串為輸入,並返回上方字符的總和. 範例: >>> digitSum (((\"\")) (0) >>> digitSum (((\"abAB\")) (131) >>> digitSum (((\"abcCd\")) (67) >>> digitSum (((\"helloE\")) (69) >>> digitSum (((\"woArBld\")) (131) >>> digitSum (((\"aAXaaaa\")) (153)\nlong digitSum(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += static_cast<long>(c);\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = digitSum;\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"abAB\")) == (131));\n    assert(candidate((\"abcCd\")) == (67));\n    assert(candidate((\"helloE\")) == (69));\n    assert(candidate((\"woArBld\")) == (131));\n    assert(candidate((\"aAaaaXa\")) == (153));\n    assert(candidate((\" How are yOu?\")) == (151));\n    assert(candidate((\"You arE Very Smart\")) == (327));\n}\n"
    },
    {
        "task_id": "HumanEval/67",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 在这个任务中,你会得到一个字符串,表示一个数量的果和子,这些果分布在一个水果篮中.这个篮包含果,子和果.给定一个字符串,表示果和果的总数和一个整数,表示篮子中的水果的总数,返回篮子中的果的数量.例如: >>> fruit_distribution (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nlong fruit_distribution(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong fruit_distribution(std::string s, long n) {\n  long apples = 0;\n  long oranges = 0;\n  size_t apples_pos = s.find(\"apples\");\n  if (apples_pos != std::string::npos) {\n    size_t start = 0;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    apples = std::stoll(s.substr(start, apples_pos - start));\n  }\n  size_t oranges_pos = s.find(\"oranges\");\n  if (oranges_pos != std::string::npos) {\n    size_t and_pos = s.find(\"and\");\n    size_t start = and_pos + 3;\n    while (!isdigit(s[start])) {\n      start++;\n    }\n    oranges = std::stoll(s.substr(start, oranges_pos - start));\n  }\n  return n - apples - oranges;\n}",
        "test": "}\nint main() {\n    auto candidate = fruit_distribution;\n    assert(candidate((\"5 apples and 6 oranges\"), (19)) == (8));\n    assert(candidate((\"5 apples and 6 oranges\"), (21)) == (10));\n    assert(candidate((\"0 apples and 1 oranges\"), (3)) == (2));\n    assert(candidate((\"1 apples and 0 oranges\"), (3)) == (2));\n    assert(candidate((\"2 apples and 3 oranges\"), (100)) == (95));\n    assert(candidate((\"2 apples and 3 oranges\"), (5)) == (0));\n    assert(candidate((\"1 apples and 100 oranges\"), (120)) == (19));\n}\n"
    },
    {
        "task_id": "HumanEval/68",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"如果一個向量代表一個樹的分支,有非負整數節點,你的任務是摘取一個節點並返回它.摘取的節點應該是具有最小偶數值的節點.如果發現有多個具有相同最小偶數值的節點,則返回具有最小索引的節點.摘取的節點應該在一個向量中返回, [最小_值,其索引], 如果沒有偶數值或該向量是空的,則返回 []. 例 1: >>> 摘取:{((((dddvector<<(long>{(long) 4, (long) 2, (long) 3}))) (stdvector::<((long>{(long}2, (long) 1})) 解釋: 2具有最小值,甚至 2具有最小值. 例 2: >>> 摘取:{(((((dvector{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> pluck(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> pluck(std::vector<long> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n  long min_even = -1;\n  long min_index = -1;\n  for (long i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (min_even == -1 || arr[i] < min_even) {\n        min_even = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_even == -1) {\n    return {};\n  }\n  return {min_even, min_index};\n}",
        "test": "}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/69",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给你一个非空的正整数向量.返回最大的整数大于零,且其频率大于或等于整数本身的值.整数的频率是它在向量中出现的次数.如果没有这样的值,返回-1. 例: >>> search(((std::vector<long>({(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> search((std::vector<(long>1, (long) 2, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4, (long) 4} (3)))) >>>((std::vector<(long>{(long) 5, (long) 5, (long) 4, (long) 4, (long) 4} (long-1))\nlong search(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong search(std::vector<long> lst) {\n  std::map<long, long> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  long result = -1;\n  for (auto const& [value, count] : counts) {\n    if (value > 0 && count >= value) {\n      result = std::max(result, value);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/70",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定整数向量,返回向量以奇怪的顺序.奇怪排序,是从最小值开始,然后是剩余的整数的最大值,然后是最小值,等等. 例: >>> strange_sort_list{}, (long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list{(((std::vector<long>{(long) 5, (long) 5, (long) 5}))) (std::vector<long>{(long) 5, (long) 5, (long) 5, (long) 5}))) (std::vector<long>{(long) 5, (long) 5, (long) 5, (long) 5} >>> strange_sort_list{}, (long) 5, (long) 5, (long) 5, (long) 5} >>> strange_sort_list{}\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  if (lst.empty()) {\n    return {};\n  }\n  std::sort(lst.begin(), lst.end());\n  std::vector<long> result;\n  long left = 0;\n  long right = lst.size() - 1;\n  bool take_min = true;\n  while (left <= right) {\n    if (take_min) {\n      result.push_back(lst[left++]);\n    } else {\n      result.push_back(lst[right--]);\n    }\n    take_min = !take_min;\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = strange_sort_list;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));\n    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));\n}\n"
    },
    {
        "task_id": "HumanEval/71",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定三角形三边的长度.如果三边构成一个有效的三角形,则返回三角形的面积,将其圆为小数点.否则返回-1 如果任何两边的和大于第三边,则三个边构成一个有效的三角形. 例: >>> triangle_area(3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())\nfloat triangle_area(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nfloat triangle_area(long a, long b, long c) {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1.0f;\n  }\n  double s = static_cast<double>(a + b + c) / 2.0;\n  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));\n  std::stringstream ss;\n  ss << std::fixed << std::setprecision(2) << area;\n  return std::stof(ss.str());\n}",
        "test": "}\nint main() {\n    auto candidate = triangle_area;\n    assert(candidate((3), (4), (5)) == (6.0f));\n    assert(candidate((1), (2), (10)) == (float(-1)));\n    assert(candidate((4), (8), (5)) == (8.18f));\n    assert(candidate((2), (2), (2)) == (1.73f));\n    assert(candidate((1), (2), (3)) == (float(-1)));\n    assert(candidate((10), (5), (7)) == (16.25f));\n    assert(candidate((2), (6), (3)) == (float(-1)));\n    assert(candidate((1), (1), (1)) == (0.43f));\n    assert(candidate((2), (2), (10)) == (float(-1)));\n}\n"
    },
    {
        "task_id": "HumanEval/72",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,如果物體q會飛,返回true,如果物體q會飛,如果其他話返回false. 如果物體q平衡 (它是一個平行向量),而且它的元素總和小於或等於最大可能的重量w. 例如: >>> will_it_fly((std::vector<long>({long) 1, (long) 2}), (5)) (false) # 1+2小於最大可能的重量,但它是不平衡的. >>> will_it_fly(((std::vector<long>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool will_it_fly(std::vector<long> q, long w) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> reversed_q = q;\n  std::reverse(reversed_q.begin(), reversed_q.end());\n  if (q != reversed_q) {\n    return false;\n  }\n  long sum = 0;\n  for (long val : q) {\n    sum += val;\n  }\n  return sum <= w;\n}",
        "test": "}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/73",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个整数的向量数组,求出需要更改的元素的最小数量,使向量变异.一个变异向量是向量,向后和向前读取相同.在一个变化中,你可以将一个元素更改为任何其他元素.例如: >>> smallest_change(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1} (1) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1)))\nlong smallest_change(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long changes = 0;\n  for (long i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n  return changes;\n}",
        "test": "}\nint main() {\n    auto candidate = smallest_change;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/74",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,接受兩個字符串的向量,並返回向量,其中所有字符串的總數小於另一項向量.如果兩項向量有相同的字符,返回第一個向量. 例如 >>> total_match (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), ( (), ( (), (), (), (), ( (), (), (), (), ( ( (), (), (), ( (), (), ( ( (), ( (), (), (), ( ( (), (), (), ( (), ( (), (), ( (), ( (), (), ( (), ( (), (), ( (), ( ( (), (), (), ( ( ( (), (), (), (), ( ( (), (), (), ( (), (), (), ( ( (), (), ( ( ( (), (), ( ( ( (), (), (), ( (), ( (), (), ( (), ( ( (), (), ( (), ( (), ( ( (), (), ( (), ( ( (), ( ( (), (), ( ( ( (), (), (), ( (), ( ( (), (), (), (), ( (), ( ( ( (), ( (), ( (), (), ( (), ( (), ( (\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  long count1 = 0;\n  for (const std::string& s : lst1) {\n    count1 += s.length();\n  }\n  long count2 = 0;\n  for (const std::string& s : lst2) {\n    count2 += s.length();\n  }\n  if (count1 <= count2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = total_match;\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"}))) == (std::vector<std::string>({(std::string)\"4\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))) == (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hii\"}))) == (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})));\n    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)\"this\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\"})), (std::vector<std::string>())) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/75",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,如果數字係3個素數嘅乘法,則返回真,否則返回錯. 知道 (a) 小於100. 例: >>> is_multiply_prime((30)) (true) 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_multiply_prime(long a) {\n  if (a <= 0) {\n    return false;\n  }\n  std::vector<int> primes;\n  std::vector<bool> is_prime(100, true);\n  is_prime[0] = is_prime[1] = false;\n  for (int p = 2; p * p < 100; p++) {\n    if (is_prime[p]) {\n      for (int i = p * p; i < 100; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (int p = 2; p < 100; p++) {\n    if (is_prime[p]) {\n      primes.push_back(p);\n    }\n  }\n  int count = 0;\n  for (int p1 : primes) {\n    if (a % p1 == 0) {\n      count++;\n      int rem = a / p1;\n      for (int p2 : primes) {\n        if (rem % p2 == 0) {\n          count++;\n          int rem2 = rem / p2;\n          for (int p3 : primes) {\n            if (rem2 == p3) {\n              count++;\n              if (count == 3) {\n                return true;\n              }\n              count--;\n            }\n          }\n          count--;\n        }\n      }\n      count--;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = is_multiply_prime;\n    assert(candidate((5)) == (false));\n    assert(candidate((30)) == (true));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (false));\n    assert(candidate((125)) == (true));\n    assert(candidate((105)) == (true));\n    assert(candidate((126)) == (false));\n    assert(candidate((729)) == (false));\n    assert(candidate((891)) == (false));\n    assert(candidate((1001)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/76",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你嘅任務係寫一個函數,如果一個數字 x 係n嘅簡單級數,其他情況下返回 true. 如果 n**int=x, x 係n嘅簡單級數 例如: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)\nbool is_simple_power(long x, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_simple_power(long x, long n) {\n  if (x == n) return true;\n  if (n == 1) return x == 1;\n  if (n == 0) return x == 0;\n  if (x == 0) return false;\n  if (x == 1) return true;\n  long power = n;\n  while (power < x) {\n    if (x % n != 0) return false;\n    if (power > x / n) return false;\n    power *= n;\n  }\n  return power == x;\n}",
        "test": "}\nint main() {\n    auto candidate = is_simple_power;\n    assert(candidate((16), (2)) == (true));\n    assert(candidate((143214), (16)) == (false));\n    assert(candidate((4), (2)) == (true));\n    assert(candidate((9), (3)) == (true));\n    assert(candidate((16), (4)) == (true));\n    assert(candidate((24), (2)) == (false));\n    assert(candidate((128), (4)) == (false));\n    assert(candidate((12), (6)) == (false));\n    assert(candidate((1), (1)) == (true));\n    assert(candidate((1), (12)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/77",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,如果這個數字係某個整數的立方體,則會返回 true. 注意:你可以假設輸入值永遠係有效. 例如: >>> iscube((1)) (true) >>> iscube((2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube(0)) (true) >>> iscube((180)) (false)\nbool iscube(long a) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool iscube(long a) {\n  if (a == 0) return true;\n  long abs_a = std::abs(a);\n  long root = round(std::cbrt(abs_a));\n  return root * root * root == abs_a;\n}",
        "test": "}\nint main() {\n    auto candidate = iscube;\n    assert(candidate((1)) == (true));\n    assert(candidate((2)) == (false));\n    assert(candidate((-1)) == (true));\n    assert(candidate((64)) == (true));\n    assert(candidate((180)) == (false));\n    assert(candidate((1000)) == (true));\n    assert(candidate((0)) == (true));\n    assert(candidate((1729)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/78",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你被要求寫一個函數,以十六進制數字為字串,並計數十六進制數字為素數的數量 (素數,或一個素數,是一個大於1且不是兩個小自然數字的積的自然數).十六進制數字是0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F. 素數字是2,3,5,7,11,13,17,... 所以你必須確定以下數字的數量: 2,3,5,7,B (=十進制11),D (=十進制13). 注意:你可能認為輸入總是正確或空字串,符號A,B,C,D,E,F總是大寫. 例如: >>> hex_((AB\"key\") (1) >>> hex_((((10\"E77\") (2) >>> hex_(AB\"key\") (4) >>> hex_(ABC\"33\") >>> hex_((ABC\"123\") >>> hex_(A67\" ()) >>> hex_ (EF) (6) >>> (2020)\nlong hex_key(std::string num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong hex_key(std::string num) {\n  long count = 0;\n  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};\n  for (char c : num) {\n    if (prime_hex.count(c)) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = hex_key;\n    assert(candidate((\"AB\")) == (1));\n    assert(candidate((\"1077E\")) == (2));\n    assert(candidate((\"ABED1A33\")) == (4));\n    assert(candidate((\"2020\")) == (2));\n    assert(candidate((\"123456789ABCDEF0\")) == (6));\n    assert(candidate((\"112233445566778899AABBCCDDEEFF00\")) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/79",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你會得到一個數字以小數字形式,你的任務是將它轉換成二進制格式.函數應該返回一個字符串,每個字符代表一個二進制數字.字符串中的每一個字符將是'0'或'1'.字符串的開始和結束將有額外的字符對'db'. 額外的字符是為了幫助格式. 例如: >>> decimal_to_binary((15)) (\"db1111db\") >>> decimal_to_binary(32) (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0) {\n    return \"db0db\";\n  }\n  std::string binaryString = \"\";\n  long temp = std::abs(decimal);\n  while (temp > 0) {\n    binaryString = (temp % 2 == 0 ? \"0\" : \"1\") + binaryString;\n    temp /= 2;\n  }\n  return \"db\" + binaryString + \"db\";\n}",
        "test": "}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
    },
    {
        "task_id": "HumanEval/80",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你得到一個字符串 s. 你嘅任務係檢查字符串係唔係 hapcpp. 一個字符串係 hapcpp 如果長度至少係 3 個,每 3 個連續嘅字母都唔同 例如: >>> is_happy(\"a\")) (false) >>> is_happy(\"aa\")) (false) >>> is_happy(\"abcd\")) (true) >>> is_happy(\"aabb\")) (false) >>> is_happy\"adb\")) (true) >>> is_happy\"xyy\") (false)\nbool is_happy(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_happy(std::string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (size_t i = 0; i <= s.length() - 3; ++i) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_happy;\n    assert(candidate((\"a\")) == (false));\n    assert(candidate((\"aa\")) == (false));\n    assert(candidate((\"abcd\")) == (true));\n    assert(candidate((\"aabb\")) == (false));\n    assert(candidate((\"adb\")) == (true));\n    assert(candidate((\"xyy\")) == (false));\n    assert(candidate((\"iopaxpoi\")) == (true));\n    assert(candidate((\"iopaxioi\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/81",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 學期嘅最後一個禮拜,老師要分數學生.老師自己做咗個算法.唯一嘅問題係,佢唔記得佢用嚟分數嘅代碼.佢畀咗你學生嘅 GPA 矢量,你就需要寫一個函數,用下面嘅表,輸入一個字母嘅 GPA 矢量: GPA 字母 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E 範例: >>>_grade_equation(std::vector<float>({(float) 4.0f, (float) 3, (float) 1.7f, (float) 2, (float) 3.5f))) (std:\" vector::std::std::string::std::string::std::string::std::string::std::string::A+ (string) \" (A\"C\"C\"C) \" (string) ()) (C\"C\")\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n  std::vector<std::string> letter_grades;\n  for (float gpa : grades) {\n    if (gpa == 4.0f) {\n      letter_grades.push_back(\"A+\");\n    } else if (gpa > 3.7f) {\n      letter_grades.push_back(\"A\");\n    } else if (gpa > 3.3f) {\n      letter_grades.push_back(\"A-\");\n    } else if (gpa > 3.0f) {\n      letter_grades.push_back(\"B+\");\n    } else if (gpa > 2.7f) {\n      letter_grades.push_back(\"B\");\n    } else if (gpa > 2.3f) {\n      letter_grades.push_back(\"B-\");\n    } else if (gpa > 2.0f) {\n      letter_grades.push_back(\"C+\");\n    } else if (gpa > 1.7f) {\n      letter_grades.push_back(\"C\");\n    } else if (gpa > 1.3f) {\n      letter_grades.push_back(\"C-\");\n    } else if (gpa > 1.0f) {\n      letter_grades.push_back(\"D+\");\n    } else if (gpa > 0.7f) {\n      letter_grades.push_back(\"D\");\n    } else if (gpa > 0.0f) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
        "test": "}\nint main() {\n    auto candidate = numerical_letter_grade;\n    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"})));\n    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)\"D+\"})));\n    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)\"D-\"})));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)\"E\"})));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)\"D\", (std::string)\"D-\", (std::string)\"C-\", (std::string)\"B\", (std::string)\"B+\"})));\n    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)\"E\", (std::string)\"D-\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/82",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,如果 string 長度係一個素數,則返回 true 或者 false 其他例子 >>> prime_length () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()\nbool prime_length(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(int n) {\n  if (n <= 1) return false;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nbool prime_length(std::string string) {\n  return is_prime(string.length());\n}",
        "test": "}\nint main() {\n    auto candidate = prime_length;\n    assert(candidate((\"Hello\")) == (true));\n    assert(candidate((\"abcdcba\")) == (true));\n    assert(candidate((\"kittens\")) == (true));\n    assert(candidate((\"orange\")) == (false));\n    assert(candidate((\"wow\")) == (true));\n    assert(candidate((\"world\")) == (true));\n    assert(candidate((\"MadaM\")) == (true));\n    assert(candidate((\"Wow\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"HI\")) == (true));\n    assert(candidate((\"go\")) == (true));\n    assert(candidate((\"gogo\")) == (false));\n    assert(candidate((\"aaaaaaaaaaaaaaa\")) == (false));\n    assert(candidate((\"Madam\")) == (true));\n    assert(candidate((\"M\")) == (false));\n    assert(candidate((\"0\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/83",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正整数 n,返回以 1 开始或以 1 结束的 n 位正整数数的数.\nlong starts_one_ends(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong starts_one_ends(long n) {\n  if (n <= 0) {\n    return 0;\n  }\n  if (n == 1) {\n    return 1;\n  }\n  long starts_with_one = std::pow(10, n - 1);\n  long ends_with_one = std::pow(10, n - 1);\n  long starts_and_ends_with_one = std::pow(10, n - 2);\n  return starts_with_one + ends_with_one - starts_and_ends_with_one;\n}",
        "test": "}\nint main() {\n    auto candidate = starts_one_ends;\n    assert(candidate((1)) == (1));\n    assert(candidate((2)) == (18));\n    assert(candidate((3)) == (180));\n    assert(candidate((4)) == (1800));\n    assert(candidate((5)) == (18000));\n}\n"
    },
    {
        "task_id": "HumanEval/84",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正整数 N,返回其二进制数字的总和. 例 >>> solve((1000)) (\"1\") >>> solve((150)) (\"110\") >>> solve((147)) (\"1100\") 变量: @N整数 约束: 0 ≤ N ≤ 10000. 输出:一串二进制数字\nstd::string solve(long N) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string solve(long N) {\n  if (N < 0 || N > 10000) {\n    return \"\"; // Or handle invalid input as needed\n  }\n  long sum = 0;\n  std::string s = std::to_string(N);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  if (sum == 0) {\n    return \"0\";\n  }\n  std::string binary_sum = \"\";\n  while (sum > 0) {\n    binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n    sum /= 2;\n  }\n  return binary_sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((1000)) == (\"1\"));\n    assert(candidate((150)) == (\"110\"));\n    assert(candidate((147)) == (\"1100\"));\n    assert(candidate((333)) == (\"1001\"));\n    assert(candidate((963)) == (\"10010\"));\n}\n"
    },
    {
        "task_id": "HumanEval/85",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个非空的整数向量,先加上偶数元素,它们的奇数指数. 例子: >>> add((std::vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)\nlong add(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add;\n    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));\n    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));\n    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));\n}\n"
    },
    {
        "task_id": "HumanEval/86",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,取一個字符串並返回一個有序版本.有序版本的字符串,是一個字符串,所有字 (用空格分隔) 都被一個新字詞取代,所有字符都根據ascii值排列成上升順序. 注意:你應該保留句子中的單詞和空格的順序.例如: >>> anti_shuffle((\"Hi\")) (\"Hi\") >>> anti_shuffle((\"hello\")) (\"ehllo\") >>> anti_shuffle\"(Hello World!!!\")) (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string anti_shuffle(std::string s) {\n  std::string result = \"\";\n  std::string current_word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      std::sort(current_word.begin(), current_word.end());\n      result += current_word;\n      result += c;\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  std::sort(current_word.begin(), current_word.end());\n  result += current_word;\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = anti_shuffle;\n    assert(candidate((\"Hi\")) == (\"Hi\"));\n    assert(candidate((\"hello\")) == (\"ehllo\"));\n    assert(candidate((\"number\")) == (\"bemnru\"));\n    assert(candidate((\"abcd\")) == (\"abcd\"));\n    assert(candidate((\"Hello World!!!\")) == (\"Hello !!!Wdlor\"));\n    assert(candidate((\"\")) == (\"\"));\n    assert(candidate((\"Hi. My name is Mister Robot. How are you?\")) == (\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"
    },
    {
        "task_id": "HumanEval/87",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 您得到一個2維數據,作為一個嵌套向量,類似矩陣,然而,不同於矩陣,每行可能包含不同數量的列. 給 lst,和整數 x,在向量中找到整數 x,並返回向量的 tuples, [(x1, y1), (x2, y2) ...]這樣每個元組是一個坐標 - (row, columns),從 0開始. 開始從 起始順序排序坐標. 也,排序列的坐標順序下降. 例如: >>> get_row(std::vector<std::vector<<std::vector, long (long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long) {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long}} {long} {long}} {long} long {long} {long} {long} {long} {long} {long} {long}} {long} {long}} {long} {long} {long} {long}}} {long} {long} {long}}}} {long} {long} {long} {long} {long} {long}} {long} {long} {long}} {long} {long} {long} {long} {long} {long} {long} {long}} {long\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n  std::vector<std::tuple<long, long>> coordinates;\n  for (long i = 0; i < lst.size(); ++i) {\n    std::vector<std::pair<long, long>> row_coords;\n    for (long j = 0; j < lst[i].size(); ++j) {\n      if (lst[i][j] == x) {\n        row_coords.push_back({j, i});\n      }\n    }\n    std::sort(row_coords.rbegin(), row_coords.rend());\n    for (const auto& coord_pair : row_coords) {\n      coordinates.emplace_back(coord_pair.second, coord_pair.first);\n    }\n  }\n  return coordinates;\n}",
        "test": "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));\n}\n"
    },
    {
        "task_id": "HumanEval/88",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个非负数整数的向量,在排序后返回给定的向量的cocpp,如果和 (第一索引值,最后索引值) 是奇数,你会以上升顺序排序给定向量,或者如果和 (第一索引值,最后索引值) 是偶数,则以下降顺序排序. 注意: *不要改变给定的向量. 例: >>> sort_array(std::vector<long>())) (std::vector<long>) >>> sort_array((std::vector<long>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> sort_array(std::vector<long> array) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> sort_array(std::vector<long> array) {\n  std::vector<long> sorted_array = array;\n  if (sorted_array.empty()) {\n    return sorted_array;\n  }\n  long first = 0;\n  long last = sorted_array.size() - 1;\n  if ((first + last) % 2 != 0) {\n    std::sort(sorted_array.begin(), sorted_array.end());\n  } else {\n    std::sort(sorted_array.rbegin(), sorted_array.rend());\n  }\n  return sorted_array;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));\n    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));\n    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));\n    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));\n}\n"
    },
    {
        "task_id": "HumanEval/89",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數encrypt,用字符串作為參數,並用字母轉換返回一個字符串.字母轉換應該以一種方式使字母向下移動兩倍到兩個位.例如: >>> encrypt((\"hi\")) (\"lm\") >>> encrypt((\"asdfghjkl\")) (\"ewhjklnop\") >>> encrypt((\"gf\")) (\"kj\") >>> encrypt((\"et\")) (\"ix\")\nstd::string encrypt(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encrypt(std::string s) {\n  std::string encrypted_s = \"\";\n  int shift = 2 * 2;\n  for (char c : s) {\n    if (isalpha(c)) {\n      char base = islower(c) ? 'a' : 'A';\n      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);\n    } else {\n      encrypted_s += c;\n    }\n  }\n  return encrypted_s;\n}",
        "test": "}\nint main() {\n    auto candidate = encrypt;\n    assert(candidate((\"hi\")) == (\"lm\"));\n    assert(candidate((\"asdfghjkl\")) == (\"ewhjklnop\"));\n    assert(candidate((\"gf\")) == (\"kj\"));\n    assert(candidate((\"et\")) == (\"ix\"));\n    assert(candidate((\"faewfawefaewg\")) == (\"jeiajeaijeiak\"));\n    assert(candidate((\"hellomyfriend\")) == (\"lippsqcjvmirh\"));\n    assert(candidate((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")) == (\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert(candidate((\"a\")) == (\"e\"));\n}\n"
    },
    {
        "task_id": "HumanEval/90",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你得到一個整數向量.寫一個函數 next_smallest() 返回向量的第二個最小元素. 如果沒有這樣的元素,返回無. >>> next_smallest(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest((std::vector<long>({long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest(std::vector<long>(())) std::nullopt >>> next_smallest(std::vector<long>{(long) 1, (long) 1))) std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  std::sort(lst.begin(), lst.end());\n  if (lst[0] == lst[1]) {\n    return std::nullopt;\n  }\n  return lst[1];\n}",
        "test": "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);\n}\n"
    },
    {
        "task_id": "HumanEval/91",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你會得到一串字,你嘅任務就係數字. 悶係一個以\"I\"開始嘅句子.句子嘅邊界係以\".', '?',或者\"!\". 例如: >>> is_bored((\"Hello world\")) (0) >>> is_bored((\"天空藍.太陽喺度閃.我好鍾意天氣\")) (1)\nlong is_bored(std::string S) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong is_bored(std::string S) {\n  long boredom_count = 0;\n  std::string current_sentence = \"\";\n  for (char c : S) {\n    current_sentence += c;\n    if (c == '.' || c == '?' || c == '!') {\n      std::stringstream ss(current_sentence);\n      std::string first_word;\n      ss >> first_word;\n      if (first_word == \"I\") {\n        boredom_count++;\n      }\n      current_sentence = \"\";\n    }\n  }\n  return boredom_count;\n}",
        "test": "}\nint main() {\n    auto candidate = is_bored;\n    assert(candidate((\"Hello world\")) == (0));\n    assert(candidate((\"Is the sky blue?\")) == (0));\n    assert(candidate((\"I love It !\")) == (1));\n    assert(candidate((\"bIt\")) == (0));\n    assert(candidate((\"I feel good today. I will be productive. will kill It\")) == (2));\n    assert(candidate((\"You and I are going for a walk\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/92",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數,需要3個數字. 如果其中一個數字等於其他兩個數字的總和,所有數字都是整數,則返回真. 如果其他情況返回錯. 例如: >>> any_int{\\displaystyle {}{\\displaystyle {}{\\displaystyle {}{\\displaystyle {}{\\displaystyle {}{\\displaystyle {}}{\\displaystyle {}}{\\displaystyle {}}{\\displaystyle {}{\\displaystyle {}{\\displaystyle {}}{\\displaystyle {}}{\\displaystyle {}}{\\displaystyle {}}}{\\displaystyle {}}}{\\displaystyle {}}}}{\\displaystyle {}}}}{\\displaystyle {}}}{\\displaystyle {}}}}{\\displaystyle {}}}{\\displaystyle {}}}{\\displaystyle {}}{\\displaystyle {}}}{\\displaystyle {}}}\nbool any_int(float x, float y, float z) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool any_int(float x, float y, float z) {\n  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {\n    return false;\n  }\n  long ix = static_cast<long>(x);\n  long iy = static_cast<long>(y);\n  long iz = static_cast<long>(z);\n  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);\n}",
        "test": "}\nint main() {\n    auto candidate = any_int;\n    assert(candidate((float(2)), (float(3)), (float(1))) == (true));\n    assert(candidate((2.5f), (float(2)), (float(3))) == (false));\n    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));\n    assert(candidate((float(2)), (float(6)), (float(2))) == (false));\n    assert(candidate((float(4)), (float(2)), (float(2))) == (true));\n    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));\n    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));\n    assert(candidate((float(2)), (float(1)), (float(1))) == (true));\n    assert(candidate((float(3)), (float(4)), (float(7))) == (true));\n    assert(candidate((3.0f), (float(4)), (float(7))) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/93",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,它會取一個訊息,並以一種方式編碼,它會換取所有字母的大小,將訊息中的所有元音替換成英文字母中出現於元音前的2個位的字母.假設只有字母. 例如: >>> encode (((\"test\")) (\"TGST\") >>> encode (((\"This is a message\")) (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string encode(std::string message) {\n  std::string encoded_message = \"\";\n  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n  std::map<char, char> vowel_map = {\n      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},\n      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};\n  for (char c : message) {\n    if (isalpha(c)) {\n      char swapped_case = islower(c) ? toupper(c) : tolower(c);\n      if (vowels.count(c)) {\n        encoded_message += vowel_map[c];\n      } else {\n        encoded_message += swapped_case;\n      }\n    } else {\n      encoded_message += c;\n    }\n  }\n  return encoded_message;\n}",
        "test": "}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
    },
    {
        "task_id": "HumanEval/94",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 您被赋予一个整数向量.您需要找到最大的素数值并返回其数字的和. 例如: >>> skjkasdkd((std::vector<long>((long) 0, (long) 3, (long) 2, (long) 1, (long) 3, (long) 5, (long) 7, (long) 4, (long) 5, (long) 5, (long) 2, (long) 181, (long) 32, (long) 4, (long) 32, (long) 2, (long) 32, (long) 324, (long) 3))) (10) >>> skjkasdkd::vector<<(long>{(long) 1, (long) 0, (long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nlong skjkasdkd(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nlong sum_digits(long n) {\n  long sum = 0;\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    sum += c - '0';\n  }\n  return sum;\n}\n\nlong skjkasdkd(std::vector<long> lst) {\n  long largest_prime = -1;\n  for (long num : lst) {\n    if (num > largest_prime && is_prime(num)) {\n      largest_prime = num;\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return sum_digits(largest_prime);\n}",
        "test": "}\nint main() {\n    auto candidate = skjkasdkd;\n    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));\n    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));\n    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));\n    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)8191}))) == (19));\n    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));\n    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));\n}\n"
    },
    {
        "task_id": "HumanEval/95",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 如果一個圖有個字符串,返回 true 如果所有鍵係小寫嘅字符串,或者所有鍵係大寫嘅字符串,否則返回 false. 函數應該返回 false 既有嘅圖係空嘅. 例如: >>> check_dict_case, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,\nbool check_dict_case(std::map<std::string,std::string> dict) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n  bool first_key_lower = false;\n  bool first_key_upper = false;\n  auto it = dict.begin();\n  if (!it->first.empty() && islower(it->first[0])) {\n    first_key_lower = true;\n  } else if (!it->first.empty() && isupper(it->first[0])) {\n    first_key_upper = true;\n  } else {\n    return false;\n  }\n  for (const auto& pair : dict) {\n    if (pair.first.empty()) {\n      return false;\n    }\n    bool current_lower = true;\n    bool current_upper = true;\n    for (char c : pair.first) {\n      if (!islower(c)) {\n        current_lower = false;\n      }\n      if (!isupper(c)) {\n        current_upper = false;\n      }\n    }\n    if (first_key_lower && !current_lower) {\n      return false;\n    }\n    if (first_key_upper && !current_upper) {\n      return false;\n    }\n    if (!first_key_lower && !first_key_upper) {\n        if (current_lower) first_key_lower = true;\n        else if (current_upper) first_key_upper = true;\n        else return false;\n    }\n  }\n  return first_key_lower || first_key_upper;\n}",
        "test": "}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>())) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/96",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 實現一個函數,取一個非負整數,並返回第一個n個整數的向量,即小於n個數,例如: >>> count_up_to((5)) (std::vector<long>{(long) 2, (long) 3})) >>> count_up_to(11) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7})) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 13, (long) 17, (long) 19} >>> count_up_1) (std::vector<long>>>>>1 to (long) 8, count_up_to (long) 3, (long) 11, (long) 3, (long) 5, (long) 17)) (std:vector<long>1 to (long) 3, (long) 11, (long) 1, (long) (long) 2, (long) (long)\nstd::vector<long> count_up_to(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long num) {\n  if (num <= 1) return false;\n  for (long i = 2; i * i <= num; ++i) {\n    if (num % i == 0) return false;\n  }\n  return true;\n}\n\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2) {\n    return primes;\n  }\n  for (long i = 2; i < n; ++i) {\n    if (is_prime(i)) {\n      primes.push_back(i);\n    }\n  }\n  return primes;\n}",
        "test": "}\nint main() {\n    auto candidate = count_up_to;\n    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));\n    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));\n    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));\n    assert(candidate((0)) == (std::vector<long>()));\n    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));\n    assert(candidate((1)) == (std::vector<long>()));\n    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));\n    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));\n}\n"
    },
    {
        "task_id": "HumanEval/97",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 填寫一個函數,取兩個整數,然後返回單位數的積分.假設輸入值永遠係正確.例子: >>>乘數((148), (412)) (16) >>>乘數(19), (28)) (72) >>>乘數(2020), (1851)) (0) >>>乘數(14), (-15)) (20)\nlong multiply(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong multiply(long a, long b) {\n  long unit_a = std::abs(a) % 10;\n  long unit_b = std::abs(b) % 10;\n  return unit_a * unit_b;\n}",
        "test": "}\nint main() {\n    auto candidate = multiply;\n    assert(candidate((148), (412)) == (16));\n    assert(candidate((19), (28)) == (72));\n    assert(candidate((2020), (1851)) == (0));\n    assert(candidate((14), (-15)) == (20));\n    assert(candidate((76), (67)) == (42));\n    assert(candidate((17), (27)) == (49));\n    assert(candidate((0), (1)) == (0));\n    assert(candidate((0), (0)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/98",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个字符串 s,以偶数的单词数量.例如: >>> count_upper (((\"aBCdEf\")) (1) >>> count_upper (((\"abcdefg\")) (0) >>> count_upper (((\"dBBE\")) (0)\nlong count_upper(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong count_upper(std::string s) {\n  long count = 0;\n  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};\n  for (long i = 0; i < s.length(); ++i) {\n    if (i % 2 == 0 && upper_vowels.count(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_upper;\n    assert(candidate((\"aBCdEf\")) == (1));\n    assert(candidate((\"abcdefg\")) == (0));\n    assert(candidate((\"dBBE\")) == (0));\n    assert(candidate((\"B\")) == (0));\n    assert(candidate((\"U\")) == (1));\n    assert(candidate((\"\")) == (0));\n    assert(candidate((\"EEEE\")) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/99",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數,取一個數值 (字串),表示一個數字,並返回最接近數字的整數.如果數字與兩個整數相差,請將其從零除.範例 >>> closest_integer (((\"10\")) (10) >>> closest_integer (((\"15.3\")) (15) 注意:將數字從零除意味著如果數字與兩個整數相差,則應返回最離零的數字.例如 closest_integer (((\"14.5\") 應返回15 而 closest_integer (((-14.5\") 應返回-15.\nlong closest_integer(std::string value) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  if (num >= 0) {\n    if (num - std::floor(num) <= 0.5) {\n      return static_cast<long>(std::floor(num));\n    } else {\n      return static_cast<long>(std::ceil(num));\n    }\n  } else {\n    if (std::ceil(num) - num <= 0.5) {\n      return static_cast<long>(std::ceil(num));\n    } else {\n      return static_cast<long>(std::floor(num));\n    }\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/100",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正整数 n,你必须做一堆 n 个层的石头.第一个层有 n 个石头.下一个层的石头数是: - 如果 n 是奇数,则是下一个奇数. - 如果 n 是偶数,则是下一个偶数.返回每个层的石头数以向量形式,其中元素在索引 i 代表层中的石头数 (i+1). 例: >>> make_a_pile(3) (std::vector<long>{long) 3, (long) 5, (long) 7}))\nstd::vector<long> make_a_pile(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> pile;\n  long current_stones = n;\n  for (int i = 0; i < n; ++i) {\n    pile.push_back(current_stones);\n    if (current_stones % 2 != 0) {\n      current_stones += 2;\n    } else {\n      current_stones += 2;\n    }\n  }\n  return pile;\n}",
        "test": "}\nint main() {\n    auto candidate = make_a_pile;\n    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));\n    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));\n    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));\n    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));\n    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));\n}\n"
    },
    {
        "task_id": "HumanEval/101",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你會得到一個用逗號或空格分隔的字串.你的任務是將字串分成幾個字並返回一個字的向量.例如: >>> words_string (((\"Hi, my name is John\")) (std::vector<std::string>({(std::string) \"Hi\", (std::string) \"my\", (std::string) \"name\", (std::string) \"is\", (std::string) \"John\"}) >>> words_string (((\"一,二,三,四,五,六\")) (std::vector<std::string>(({(stdstring) \"One\", (std::string) \"two\", (std::string) \"three\", (std::string) \"four\", (std::string) \"five\", (std::string) \"six\"})\nstd::vector<std::string> words_string(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ',' || c == ' ') {\n      if (!current_word.empty()) {\n        words.push_back(current_word);\n        current_word = \"\";\n      }\n    } else {\n      current_word += c;\n    }\n  }\n  if (!current_word.empty()) {\n    words.push_back(current_word);\n  }\n  return words;\n}",
        "test": "}\nint main() {\n    auto candidate = words_string;\n    assert(candidate((\"Hi, my name is John\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"})));\n    assert(candidate((\"One, two, three, four, five, six\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"Hi, my name\")) == (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\"})));\n    assert(candidate((\"One,, two, three, four, five, six,\")) == (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"})));\n    assert(candidate((\"\")) == (std::vector<std::string>()));\n    assert(candidate((\"ahmed     , gamal\")) == (std::vector<std::string>({(std::string)\"ahmed\", (std::string)\"gamal\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/102",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 函數取兩個正數 x 和 y,並返回最大的連整數,即在 [x,y] 範圍內.如果沒有這樣的數字,函數應該返回 -1.例如: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)\nlong choose_num(long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong choose_num(long x, long y) {\n  if (x > y) {\n    return -1;\n  }\n  long end = y;\n  if (end % 2 != 0) {\n    end--;\n  }\n  if (end < x) {\n    return -1;\n  }\n  return end;\n}",
        "test": "}\nint main() {\n    auto candidate = choose_num;\n    assert(candidate((12), (15)) == (14));\n    assert(candidate((13), (12)) == (-1));\n    assert(candidate((33), (12354)) == (12354));\n    assert(candidate((5234), (5233)) == (-1));\n    assert(candidate((6), (29)) == (28));\n    assert(candidate((27), (10)) == (-1));\n    assert(candidate((7), (7)) == (-1));\n    assert(candidate((546), (546)) == (546));\n}\n"
    },
    {
        "task_id": "HumanEval/103",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// 你有兩個正整數 n 和 m,你的任務是計算從 n 到 m (包括 n 和 m) 的整數的平均數.將答案圓到最近的整數,然後將其轉換為二進制.如果 n 大於 m,返回 -1. 例: >>> rounded_avg (((1), (5)) \"0b11\" >>> rounded_avg (((7), (5)) -1 >>> rounded_avg (((10), (20)) \"0b1111\" >>> rounded_avg (((20), (33)) \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;\n    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_string_long rounded_avg(long n, long m) {\n  if (n > m) {\n    return Union_std_string_long(-1);\n  }\n  double sum = 0;\n  for (long i = n; i <= m; ++i) {\n    sum += i;\n  }\n  double avg = sum / (m - n + 1);\n  long rounded_avg_long = std::round(avg);\n  if (rounded_avg_long == 0) {\n    return Union_std_string_long(\"0b0\");\n  }\n  std::string binary_string = \"\";\n  long temp = std::abs(rounded_avg_long);\n  while (temp > 0) {\n    binary_string = (temp % 2 == 0 ? \"0\" : \"1\") + binary_string;\n    temp /= 2;\n  }\n  return Union_std_string_long(\"0b\" + binary_string);\n}",
        "test": "}\nint main() {\n    auto candidate = rounded_avg;\n    assert(candidate((1), (5)) == \"0b11\");\n    assert(candidate((7), (13)) == \"0b1010\");\n    assert(candidate((964), (977)) == \"0b1111001010\");\n    assert(candidate((996), (997)) == \"0b1111100100\");\n    assert(candidate((560), (851)) == \"0b1011000010\");\n    assert(candidate((185), (546)) == \"0b101101110\");\n    assert(candidate((362), (496)) == \"0b110101101\");\n    assert(candidate((350), (902)) == \"0b1001110010\");\n    assert(candidate((197), (233)) == \"0b11010111\");\n    assert(candidate((7), (5)) == -1);\n    assert(candidate((5), (1)) == -1);\n    assert(candidate((5), (5)) == \"0b101\");\n}\n"
    },
    {
        "task_id": "HumanEval/104",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正整数x的向量,返回所有没有偶数位数的元素的排序向量. 注意:返回的向量应该以增加顺序排序.例如: >>> unique_digits(std::vector<long>({(long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{(long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{(long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool has_even_digit(long n) {\n  std::string s = std::to_string(n);\n  for (char c : s) {\n    if ((c - '0') % 2 == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstd::vector<long> unique_digits(std::vector<long> x) {\n  std::vector<long> result;\n  for (long val : x) {\n    if (!has_even_digit(val)) {\n      result.push_back(val);\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = unique_digits;\n    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));\n    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));\n    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));\n}\n"
    },
    {
        "task_id": "HumanEval/105",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个整数向量,把1到9的整数排序,反转得到的向量,然后用\"一\"\",二\"\",三\"\",四\"\",五\"\",六\"\",七\"\",八\"\",九\"的对应名称取代每位数. 例如: >>> by_length(std::string<(long>{long) 2, (long) 1, (long) 1, (long) 4, (long) 5, (long) 8, (long) 2, (long) 3}))) (std::vector<std::string>{(std::string) \"Eight\", (std::string) \"Five\", (std::string) \"Four\", (std::string) \"Three\", (std::string) \"Two\", (std::string) \"Two\", (std::string) \"Four\", (std::string) \"Five\", (std::string) \"Three\", (std::string) \"Two\", (std::string) \"Three\", (std::string) \"Two\", (std::string) \"Four\", (std::string) \"Five\", (std::string::string::string::std::string::std::string::st::string::st::st::string) \"Six\", (std::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::string::str:string::string::string::string::str:string\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<long> valid_numbers;\n  std::vector<std::string> result;\n  std::map<long, std::string> number_names = {\n      {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n      {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n  for (long num : arr) {\n    if (num >= 1 && num <= 9) {\n      valid_numbers.push_back(num);\n    }\n  }\n  std::sort(valid_numbers.begin(), valid_numbers.end());\n  std::reverse(valid_numbers.begin(), valid_numbers.end());\n  for (long num : valid_numbers) {\n    result.push_back(number_names[num]);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = by_length;\n    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)\"Three\", (std::string)\"Two\", (std::string)\"One\"})));\n    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)\"Nine\", (std::string)\"Eight\", (std::string)\"Four\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/106",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 實現函數 f 取 n 為參數,並返回一個 n 大小的向量,如果 i 是偶數,則元素 i 的值是 i 的因數,否則則則是 1 到 i 的數的總和. i 從 1 開始. i 的因數是 1 到 i 的數的乘法 (1 * 2 * ... * i). 例: >>> f((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))\nstd::vector<long> f(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> f(long n) {\n  std::vector<long> result;\n  for (long i = 1; i <= n; ++i) {\n    if (i % 2 == 0) {\n      long factorial = 1;\n      for (long j = 1; j <= i; ++j) {\n        factorial *= j;\n      }\n      result.push_back(factorial);\n    } else {\n      long sum = 0;\n      for (long j = 1; j <= i; ++j) {\n        sum += j;\n      }\n      result.push_back(sum);\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = f;\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/107",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正整数 n,返回一个组,其中包含在范围内的偶数和奇数整数二重复数. 例1: >>> even_odd_palindrome (((3)) (std::make_tuple ((1, 2)) 解释:整数二重复数是 1, 2, 3.其中一个是偶数,其中两个是奇数. 例2: >>> even_odd_palindrome (((12)) (std::make_tuple ((4, 6)) 解释:整数二重复数是 1, 2, 3, 4, 5, 6, 7, 8, 9, 11.其中四个是偶数,其中六个是奇数. 注意: 1. < 1= n= 10^3 2.返回的组分别有偶数和奇数整数二重复数.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_palindrome(long num) {\n  std::string s = std::to_string(num);\n  std::string reversed_s = s;\n  std::reverse(reversed_s.begin(), reversed_s.end());\n  return s == reversed_s;\n}\n\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; ++i) {\n    if (is_palindrome(i)) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n  return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_palindrome;\n    assert(candidate((123)) == (std::make_tuple(8, 13)));\n    assert(candidate((12)) == (std::make_tuple(4, 6)));\n    assert(candidate((3)) == (std::make_tuple(1, 2)));\n    assert(candidate((63)) == (std::make_tuple(6, 8)));\n    assert(candidate((25)) == (std::make_tuple(5, 6)));\n    assert(candidate((19)) == (std::make_tuple(4, 6)));\n    assert(candidate((9)) == (std::make_tuple(4, 5)));\n    assert(candidate((1)) == (std::make_tuple(0, 1)));\n}\n"
    },
    {
        "task_id": "HumanEval/108",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數 count_nums,它取一個整數向量,並返回元素數,其數字總和為 > 0. 如果一個數字是負數,那麼它的第一個簽名數字將是負數字:例如 -123有簽名數字 -1,2,和3. >>> count_nums (long) -1, (long) -1, (long) -11))) (1) >>> count_nums (long) -2, (long) -3, (long) -4, (long) -5, (long) -6, (long) -7, (long) -8, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long) -9, (long)\nlong count_nums(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_digits_signed(long n) {\n  std::string s = std::to_string(n);\n  long sum = 0;\n  for (long i = 0; i < s.length(); ++i) {\n    if (i == 0 && s[i] == '-') {\n      if (s.length() > 1) {\n        sum -= (s[i + 1] - '0');\n        i++;\n      }\n    } else {\n      sum += (s[i] - '0');\n    }\n  }\n  return sum;\n}\n\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    if (sum_digits_signed(num) > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
        "test": "}\nint main() {\n    auto candidate = count_nums;\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));\n    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));\n    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)1}))) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/109",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 我們有一個 vector 'arr' 由 N 個整數 arr[1], arr[2], ..., arr[N].向量中的數字會隨機排序.你的任務是確定是否有可能在給定的向量上執行以下操作來得到一個向量並列不減少的順序:你被允許在給定的向量上執行任意數次右移動作.一個右移動作意味著向量的所有元素在一個位置向右移.向量的最後一個元素將被移到向量中的起始位置即第 0 位指數.如果有可能通過執行上述操作來獲得並列的向量,則返回 true,否則返回 false.如果給定的向量是空的,則返回 true. 注意:給定的向量有保證有獨特的元素.例如: >>> move_oneball_{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nbool move_one_ball(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool move_one_ball(std::vector<long> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n  int n = arr.size();\n  std::vector<long> sorted_arr = arr;\n  std::sort(sorted_arr.begin(), sorted_arr.end());\n  for (int shift = 0; shift < n; ++shift) {\n    std::vector<long> shifted_arr(n);\n    for (int i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n    if (shifted_arr == sorted_arr) {\n      return true;\n    }\n  }\n  return false;\n}",
        "test": "}\nint main() {\n    auto candidate = move_one_ball;\n    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));\n    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/110",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 喺呢個問題,你會實現一個函數,用兩個數的向量,並決定是否可以進行兩者之間的元素交換,使得lst1變成單數的向量. lst1和lst2之間的元素交換數量無限制. 如果有可能在lst1和lst2之間交換元素,使得lst1的所有元素都單數,返回\"YES\". 否則返回\"NO\". 例如: >>> exchange((std::vector<>(long) {1, (long) 2, (long) 3, (long) 4})), (std::vector<>(long) {1, (long) 2, (long) 3, (long) 4}) \", (YES\") >>> exchange::{dd}<< vector>{1, (long) 2, (long) 3, (long) 4}\", (std::vector<>(long) {1, (long) 3, (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  long odd_count_lst1 = 0;\n  for (long num : lst1) {\n    if (num % 2 != 0) {\n      odd_count_lst1++;\n    }\n  }\n  long even_count_lst2 = 0;\n  for (long num : lst2) {\n    if (num % 2 == 0) {\n      even_count_lst2++;\n    }\n  }\n  if (even_count_lst2 >= odd_count_lst1) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = exchange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (\"YES\"));\n    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (\"NO\"));\n    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (\"YES\"));\n}\n"
    },
    {
        "task_id": "HumanEval/111",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一条代表一个空格分隔的小写字母的字符串,返回一个字母的地图,其中包含最多重复和相应的数量.如果有几个字母有相同的出现,返回它们全部. 例如: >>> histogram (((\"a b c\")) (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}})) >>> histogram (((\"a b a\")) (std::map<std::string,>({{\"a\", 2}, {\"b\", 2}})) >>> histogram (((\"a b c a b\")) (std::map<std::string,long>{{\"a\", 2}, {\"b\", 2}})) >>> histogram (http://www.histogram.com/map/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/maps/s/s/maps/s/s/map/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/s/\nstd::map<std::string,long> histogram(std::string test) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string, long> counts;\n  std::string current_word;\n  std::stringstream ss(test);\n  while (ss >> current_word) {\n    counts[current_word]++;\n  }\n  if (counts.empty()) {\n    return {};\n  }\n  long max_count = 0;\n  for (const auto& pair : counts) {\n    if (pair.second > max_count) {\n      max_count = pair.second;\n    }\n  }\n  std::map<std::string, long> result;\n  for (const auto& pair : counts) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = histogram;\n    assert(candidate((\"a b b a\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c a b\")) == (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}})));\n    assert(candidate((\"a b c d g\")) == (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}, {\"d\", 1}, {\"g\", 1}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"b b b b a\")) == (std::map<std::string,long>({{\"b\", 4}})));\n    assert(candidate((\"r t g\")) == (std::map<std::string,long>({{\"r\", 1}, {\"t\", 1}, {\"g\", 1}})));\n    assert(candidate((\"\")) == (std::map<std::string,long>()));\n    assert(candidate((\"a\")) == (std::map<std::string,long>({{\"a\", 1}})));\n}\n"
    },
    {
        "task_id": "HumanEval/112",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 任務 給我們兩個字符串 s 和 c,你必須除 s 中所有等於 c 中任何一個字符的字符,然後檢查結果字符串是否是平行符.字符串如果向前讀相同,則稱為平行符串.你應該返回包含結果字符串和 true/false 的元組來進行檢查. 例 >>> reverse_delete((\"abcde\"), (\"ae\")) (std::make_tuple(\"bcd\", false)) >>> reverse_delete(\"abcdef\"), (\"b\") (std::make_tuple(\"acdef\",)) >>> reverse_delete(\"abcded\", false)) >>> reverse_delete(abcded\", false)) (std::make_tuple\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result = \"\";\n  std::unordered_set<char> chars_to_delete(c.begin(), c.end());\n  for (char ch : s) {\n    if (chars_to_delete.find(ch) == chars_to_delete.end()) {\n      result += ch;\n    }\n  }\n  std::string reversed_result = result;\n  std::reverse(reversed_result.begin(), reversed_result.end());\n  return std::make_tuple(result, result == reversed_result);\n}",
        "test": "}\nint main() {\n    auto candidate = reverse_delete;\n    assert(candidate((\"abcde\"), (\"ae\")) == (std::make_tuple(\"bcd\", false)));\n    assert(candidate((\"abcdef\"), (\"b\")) == (std::make_tuple(\"acdef\", false)));\n    assert(candidate((\"abcdedcba\"), (\"ab\")) == (std::make_tuple(\"cdedc\", true)));\n    assert(candidate((\"dwik\"), (\"w\")) == (std::make_tuple(\"dik\", false)));\n    assert(candidate((\"a\"), (\"a\")) == (std::make_tuple(\"\", true)));\n    assert(candidate((\"abcdedcba\"), (\"\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"abcdedcba\"), (\"v\")) == (std::make_tuple(\"abcdedcba\", true)));\n    assert(candidate((\"vabba\"), (\"v\")) == (std::make_tuple(\"abba\", true)));\n    assert(candidate((\"mamma\"), (\"mia\")) == (std::make_tuple(\"\", true)));\n}\n"
    },
    {
        "task_id": "HumanEval/113",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个字符串的向量,每一个字符串只包含数字,返回一个向量.输出中的每个元素i应该是\"输入字符串i中的奇数元素. \"其中所有i都应该被输入字符串i中的奇数数字所取代. >>> odd_count((std::vector<std::string>(({std::string) \"1234567\"}))) (std::vector<std::string>({stdstring)::\"奇数元素4n 4n 4n 4n. \")) >>> odd_count(stdvector<stdstring>::{(stdstring) \",\"3 (stdstring)::\"\"1111\"}))) (std::vector<stdstring::n>) 1n: 1n: 1n: 1n: 1n: 1n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 8n: 9n:\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string count_str = std::to_string(count);\n    std::string modified_s = s;\n    for (char& c : modified_s) {\n      if (isdigit(c) && (c - '0') % 2 != 0) {\n        c = count_str[0];\n      }\n    }\n    result.push_back(\"the number of odd elements \" + count_str + \"n the str\" + modified_s + \"ng \" + modified_s + \" of the \" + modified_s + \"nput.\");\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = odd_count;\n    assert(candidate((std::vector<std::string>({(std::string)\"1234567\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"271\", (std::string)\"137\", (std::string)\"314\"}))) == (std::vector<std::string>({(std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (std::string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (std::string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/114",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个整数 n 的向量,求出任何非空的小向量的最小和. 例 >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)\nlong minSubArraySum(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong minSubArraySum(std::vector<long> nums) {\n  if (nums.empty()) {\n    throw std::invalid_argument(\"Input vector cannot be empty.\");\n  }\n  long min_so_far = nums[0];\n  long current_min = nums[0];\n  for (size_t i = 1; i < nums.size(); ++i) {\n    current_min = std::min(nums[i], current_min + nums[i]);\n    min_so_far = std::min(min_so_far, current_min);\n  }\n  return min_so_far;\n}",
        "test": "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10}))) == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/115",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你有個矩形嘅井格.每一行代表一個井,每一行嘅 1 代表一個水份單位.每個井都有一個可以用嚟提取水嘅桶,所有桶都同一個容量. 你嘅任務係用桶去排水. 輸入你需要下桶嘅次數. 例 1: >>> max_fill((std::vector<std::vector<std::vector<long>, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long bucket_lowering_count = 0;\n  for (const auto& row : grid) {\n    long water_in_well = 0;\n    for (long unit : row) {\n      water_in_well += unit;\n    }\n    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;\n  }\n  return bucket_lowering_count;\n}",
        "test": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/116",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 喺呢個 Kata 中,你必須根據二進制表示嘅 1 數排序一個非負整數嘅向量.類似嘅 1 數,根據小數值排序.佢必須係咁實現: >>> sort_array((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5})) >>> sort_array(std::vector<long>{(long) 2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std::vector<long>{(long>{-6, (long) 5, (long) 4, (long) 3, (long) 2} >>> sort_array:d::vector<long>{(long>1, (long) 3, (long) 4, (long) 1, (long)) (long) 2, (long) 3, (long) 4)) (long)\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nint count_set_bits(long n) {\n  int count = 0;\n  if (n < 0) {\n    n = std::abs(n);\n  }\n  while (n > 0) {\n    n &= (n - 1);\n    count++;\n  }\n  return count;\n}\n\nbool compare(long a, long b) {\n  int bits_a = count_set_bits(a);\n  int bits_b = count_set_bits(b);\n  if (bits_a != bits_b) {\n    return bits_a < bits_b;\n  }\n  return a < b;\n}\n\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), compare);\n  return arr;\n}",
        "test": "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));\n    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));\n}\n"
    },
    {
        "task_id": "HumanEval/117",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个字符串 s 和一个自然数 n,你被要求实现一个函数,返回字符串 s 中包含完全 n 个辅音的所有单词的向量,以便这些单词出现在字符串 s 中.如果字符串 s 是空的,则函数应该返回一个空向量. 注意:你可以假设输入字符串只包含字母和空格. 例如: >>> select_words ((\"Mary had a little lamb\"), (4)) (std::vector<std::string>({(std::string) \"小\"} >>> select_words ((((\"Mary had a little lamb\"), (3)) (std::vector<std::string>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<std::string> select_words(std::string s, long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_consonant(char c) {\n  c = tolower(c);\n  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');\n}\n\nstd::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string> result;\n  std::string current_word;\n  for (char c : s) {\n    if (c == ' ') {\n      long consonant_count = 0;\n      for (char word_char : current_word) {\n        if (is_consonant(word_char)) {\n          consonant_count++;\n        }\n      }\n      if (consonant_count == n) {\n        result.push_back(current_word);\n      }\n      current_word = \"\";\n    } else {\n      current_word += c;\n    }\n  }\n  long consonant_count = 0;\n  for (char word_char : current_word) {\n    if (is_consonant(word_char)) {\n      consonant_count++;\n    }\n  }\n  if (consonant_count == n) {\n    result.push_back(current_word);\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/118",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你得到一個詞.你的任務是要找到最接近的元音,它在詞的右側 (大小寫字敏感) 兩個輔音之間.在開始和結束的元音不算.如果你沒有找到任何元音符合上述條件,返回空字串.你可以假設該字串只包含英文字母. 例如: >>> get_closest_vowel((\"yogurt\")) (\"u\") >>> get_closest_vowel(\"FULL\")) (\"U\") >>> get_closest_vowel(\"quick\") (\"\") >>> get_closest_vowel(\"ab\") (\"\")\nstd::string get_closest_vowel(std::string word) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_vowel(char c) {\n  c = tolower(c);\n  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nbool is_consonant(char c) {\n  return isalpha(c) && !is_vowel(c);\n}\n\nstd::string get_closest_vowel(std::string word) {\n  if (word.length() < 3) {\n    return \"\";\n  }\n  for (int i = word.length() - 2; i >= 1; --i) {\n    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {\n      return std::string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
        "test": "}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
    },
    {
        "task_id": "HumanEval/119",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你有兩條字符串,兩條字符串都由開括號 '(' 或者閉括號 ') ' 組成. 你的工作是檢查是否可以將兩條字符串串連成某個順序,以使得得得出的字符串是好的.一個字符串 S 只會被認為是好的,如果 S 中所有括號都平衡.例如:字符串 '(())) '是好的,而字符串 '()) '不是.如果有辦法做出一個好字符串,返回'yes',如果沒有的話返回'no'. 例如: >>> match_parens(std::vector<std::string>{((stdstring) \") \", ((std::string) \"))) \"} (\"Yes\") >>> match_parens<std::string>{(stdstring>\" (\"No\"))))\nstd::string match_parens(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_good(const std::string& s) {\n  int balance = 0;\n  for (char c : s) {\n    if (c == '(') {\n      balance++;\n    } else if (c == ')') {\n      balance--;\n    }\n    if (balance < 0) {\n      return false;\n    }\n  }\n  return balance == 0;\n}\n\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  if (is_good(s1 + s2) || is_good(s2 + s1)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(())\", (std::string)\"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")())\", (std::string)\"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(())))\", (std::string)\"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"()\", (std::string)\"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(()(\", (std::string)\"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"((((\", (std::string)\"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(()\", (std::string)\"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")(\", (std::string)\")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"(\", (std::string)\")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({(std::string)\")\", (std::string)\"(\"}))) == (\"Yes\"));\n}\n"
    },
    {
        "task_id": "HumanEval/120",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个整数和正整数k的向量arr,返回一个长度k的排序向量arr中最大k个数. 例1: >>>最大((std::vector<long>({long) -3, (long) -4, (long) -5}), (3)) (std::vector<long>({long) -4, (long) -3, (long) -5}) 例2: >>>最大((std::vector<long>({long) -4, (long) -4, (long) -4}), (2)) (std::vector<long>({long) -4, (long) -4}) 例3: >>>最大((std::vector<long>{(long) -3, (long) -2, (long) -1, (long) -2, (long) -1, (long) -2, (long) -1, (long) -1, (long) (1) 个向量arr: 1.长度向量arr的元素将在1000的范围内. 参数: len=1000 参数: len=1000 参数: len=1000 参数: len=1000 参数: len=1000 参数: len=1000 参数: len=1000\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::sort(arr.rbegin(), arr.rend());\n  std::vector<long> result;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    result.push_back(arr[i]);\n  }\n  std::sort(result.begin(), result.end());\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = maximum;\n    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));\n    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));\n    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));\n    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));\n    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));\n    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));\n    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));\n}\n"
    },
    {
        "task_id": "HumanEval/121",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个非空整数向量,返回所有偶位的奇数元素的和. 例 >>> 解: (((std::vector<long>({long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> 解: (((std::vector<long>({long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> 解: (((std::vector<long>({long) 30, (long) 13, (long) 24, (long) 321}))) (0)\nlong solution(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong solution(std::vector<long> lst) {\n  long sum = 0;\n  for (long i = 0; i < lst.size(); i += 2) {\n    if (lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = solution;\n    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));\n    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));\n    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));\n    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));\n    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));\n}\n"
    },
    {
        "task_id": "HumanEval/122",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个非空的整数向量arr和一个整数k,返回从arr的第一个k个元素中最多有两个位数的元素的和. 例: >>> add_elements((std::vector<long>({long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) 约束: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr()\nlong add_elements(std::vector<long> arr, long k) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {\n    if (arr[i] >= -99 && arr[i] <= 99) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = add_elements;\n    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));\n    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));\n    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));\n    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));\n    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/123",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正整数 n,返回一个有奇数序列的排序向量. 科拉茨推测是数学中的一个推测,涉及以下定义的序列:从任何正整数 n 开始. 然后每个项从前项得到:如果前项是偶数,下一个项是前项的一半. 如果前项是奇数,下一个项是前项的3倍加 1. 推测是,无论 n 的值如何,序列总是达到 1. 注意: 1. Collatz(1) 是 [1]. 2.返回的向量按增长顺序排序. 例如: get_odd_collatz5) 返回 [1, 5] 5 的 科拉茨序列是 [5, 8, 16, 4, 2, 1],所以奇数只有 1, 5. >>> get_odd_collatz ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> get_odd_collatz(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nstd::vector<long> get_odd_collatz(long n) {\n  std::vector<long> odd_numbers;\n  std::unordered_set<long> seen;\n  long current = n;\n  while (seen.find(current) == seen.end()) {\n    seen.insert(current);\n    if (current % 2 != 0) {\n      odd_numbers.push_back(current);\n    }\n    if (current == 1) {\n      break;\n    }\n    if (current % 2 == 0) {\n      current /= 2;\n    } else {\n      current = 3 * current + 1;\n    }\n  }\n  std::sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
        "test": "}\nint main() {\n    auto candidate = get_odd_collatz;\n    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));\n    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));\n    assert(candidate((1)) == (std::vector<long>({(long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/124",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你需要寫一個函數,如果某一日期字符串係有效,則判定為真,如果日期係錯,則判定為錯. 如果所有以下條款都滿足,日期係有效: 1.日期字符串係空嘅. 2.日數係 1,3,5,7,8,10,12 個月嘅 1 個或以上 31 天,而日數係 4,6,9,11 個月嘅 1 個或以上 30 天. 而且,日數係 2,3 個月嘅 1 個或以上 29 天. 3.月份唔應該少於 1 個或以上 12 個. 4.日期應該係以mm-dd-yyyy >>> valid_date((103-11-2000\")) (true >>> valid_date(15-01-2012\")) (false) >>> valid_date (((04-040-20\") (false) >>> valid_date (((06-2020) (true >>> valid_date (((06/2020) (false)) 格式嘅\nbool valid_date(std::string date) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool valid_date(std::string date) {\n  if (date.empty()) {\n    return false;\n  }\n  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {\n    return false;\n  }\n  int month, day, year;\n  try {\n    month = std::stoi(date.substr(0, 2));\n    day = std::stoi(date.substr(3, 2));\n    year = std::stoi(date.substr(6, 4));\n  } catch (const std::invalid_argument& e) {\n    return false;\n  } catch (const std::out_of_range& e) {\n    return false;\n  }\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1) {\n    return false;\n  }\n  if (month == 2) {\n    if (day > 29) {\n      return false;\n    }\n  } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n    if (day > 30) {\n      return false;\n    }\n  } else {\n    if (day > 31) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = valid_date;\n    assert(candidate((\"03-11-2000\")) == (true));\n    assert(candidate((\"15-01-2012\")) == (false));\n    assert(candidate((\"04-0-2040\")) == (false));\n    assert(candidate((\"06-04-2020\")) == (true));\n    assert(candidate((\"01-01-2007\")) == (true));\n    assert(candidate((\"03-32-2011\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"04-31-3000\")) == (false));\n    assert(candidate((\"06-06-2005\")) == (true));\n    assert(candidate((\"21-31-2000\")) == (false));\n    assert(candidate((\"04-12-2003\")) == (true));\n    assert(candidate((\"04122003\")) == (false));\n    assert(candidate((\"20030412\")) == (false));\n    assert(candidate((\"2003-04\")) == (false));\n    assert(candidate((\"2003-04-12\")) == (false));\n    assert(candidate((\"04-2003\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/125",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// 给定一串单词,返回一个单词的向量 分成空格,如果文本中没有空格,你应该分成逗号,','如果没有逗号,你应该返回字母表中奇数顺序的小写字母数,ord (a) = 0,ord (b) = 1,...ord (z) = 25 例 >>> split_words (分_词) >>> (def) 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;\n    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }\n    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\nUnion_std_vector_std_string__long split_words(std::string txt) {\n  if (txt.find(' ') != std::string::npos) {\n    std::vector<std::string> words;\n    std::stringstream ss(txt);\n    std::string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n    return Union_std_vector_std_string__long(words);\n  } else if (txt.find(',') != std::string::npos) {\n    std::vector<std::string> words;\n    std::string current_word;\n    for (char c : txt) {\n      if (c == ',') {\n        words.push_back(current_word);\n        current_word = \"\";\n      } else {\n        current_word += c;\n      }\n    }\n    words.push_back(current_word);\n    return Union_std_vector_std_string__long(words);\n  } else {\n    long odd_order_count = 0;\n    for (char c : txt) {\n      if (islower(c)) {\n        if ((c - 'a') % 2 != 0) {\n          odd_order_count++;\n        }\n      }\n    }\n    return Union_std_vector_std_string__long(odd_order_count);\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = split_words;\n    assert(candidate((\"Hello world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello,world!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"}));\n    assert(candidate((\"Hello world,!\")) == std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world,!\"}));\n    assert(candidate((\"Hello,Hello,world !\")) == std::vector<std::string>({(std::string)\"Hello,Hello,world\", (std::string)\"!\"}));\n    assert(candidate((\"abcdef\")) == 3);\n    assert(candidate((\"aaabb\")) == 2);\n    assert(candidate((\"aaaBb\")) == 1);\n    assert(candidate((\"\")) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/126",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 根據一個數量向量,返回是否他們是按上升順序排序. 如果向量有超過 1 同一個數字的重複,返回錯誤. 假設沒有負數字,只有整數. 例如 >>> is_sorted (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)\nbool is_sorted(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_sorted(std::vector<long> lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n  std::map<long, int> counts;\n  for (long x : lst) {\n    counts[x]++;\n  }\n  for (auto const& [key, val] : counts) {\n    if (val > 2) {\n      return false;\n    }\n  }\n  for (size_t i = 0; i < lst.size() - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_sorted;\n    assert(candidate((std::vector<long>({(long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));\n    assert(candidate((std::vector<long>())) == (true));\n    assert(candidate((std::vector<long>({(long)1}))) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/127",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给你两个间隔,每一个间隔都是整数对.例如,间隔= (开始,结束) = (1,2).给定的间隔是闭的,这意味着间隔 (开始,结束) 包括开始和结束.对于每一个给定的间隔,假定它的开始小于或等于它的结束.你的任务是确定这两个间隔的交叉长度是否是个素数.例如,间隔的交叉长度 (1, 3), (2, 4) 是 (2, 3) 其长度是1,而不是一个素数.如果交叉长度是个素数,返回\"YES\",否则返回\"NO\".如果两个间隔不交叉,返回\"NO\". [输入/输出] 样本: >>> 交叉长度: ((((dmake_tuple1,)) 2) (dmake_tuple2,3) (\"NO\": ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_prime(long n) {\n  if (n <= 1) return false;\n  for (long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\n\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n  long start1 = std::get(interval1);\n  long end1 = std::get(interval1);\n  long start2 = std::get(interval2);\n  long end2 = std::get(interval2);\n  long intersection_start = std::max(start1, start2);\n  long intersection_end = std::min(end1, end2);\n  long intersection_length = intersection_end - intersection_start + 1;\n  if (intersection_length <= 0) {\n    return \"NO\";\n  }\n  if (is_prime(intersection_length)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
        "test": "}\nint main() {\n    auto candidate = intersection;\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (\"YES\"));\n    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (\"NO\"));\n    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (\"NO\"));\n    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (\"NO\"));\n}\n"
    },
    {
        "task_id": "HumanEval/128",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你得到一個整數的向量,你需要用向量中每個數的所有符號的乘法乘以整數的總和,表示為1,-1或0. 注意:返回空的arr. 範例: >>> prod_signs(((std::vector<long>{(long) 1, (long) 2, (long) 2, (long) - 4}))) 9 >>> prod_signs(std::vector<long>({(long) 0, (long) 1}))) 0 >>> prod_signs((std::vector<long>(())) std::nopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long sum_magnitudes = 0;\n  long product_of_signs = 1;\n  for (long num : arr) {\n    sum_magnitudes += std::abs(num);\n    if (num > 0) {\n      product_of_signs *= 1;\n    } else if (num < 0) {\n      product_of_signs *= -1;\n    } else {\n      product_of_signs *= 0;\n    }\n  }\n  return sum_magnitudes * product_of_signs;\n}",
        "test": "}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>())) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);\n}\n"
    },
    {
        "task_id": "HumanEval/129",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个有N行和N列 (N >=2) 的网格,并且每一个是正整数k的网格单元格都包含一个值.在 [1,N * N] 范围内的每一个整数都在网格单元格中出现一次.你必须在网格中找到长度k的最小路径.你可以从任何单元格开始,在每一步中你可以移动到任何邻近的单元格,换句话说,你可以去与你当前单元格共享边缘的单元格.请注意,长度k的路径意味着访问确切k个单元格 (不一定是不同的).你不能离开网格.如果在做出 A 和 B 单元格上的值的顺序向量之后 (让我们称它们为 l_stA 和 l_stB),则路径A (长度k) 被认为小于路径B (长度k).返回路径A (长度k) 被认为小于路径B (长度k) 如果我们在做出 A 和 B 单元格上的值的顺序向量向量 (让我们称它们为 l_stA 和 l_stA),则词法上每一个整数小于 l_stA_stB,换句话说,你必须从任何单元格中找到长度k的最小路径.你可以从任何单元格中开始,并且在每一步上你可以移动到任何邻近的单元格中都可以移动到任何一个单元格,换句话说,你可以去任何边的单元格的单元格的边都有边的边的边的边,换句话,你可以去任何边都有 k_i= i_i_i_i_i_i_i_i_i_i_i_j_i_i_i_i_i_i_j_i_i_i_i_i_i_j_i_i_i_i_i_i_j_i_i_i_i_i_i_i_j_i_i_i_i_i_j_i_i_i_i_i_i_i_i_j_i_i_i_i_i_\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n  int n = grid.size();\n  std::vector<long> min_path;\n\n  std::function<void(int, int, std::vector<long>)> dfs = \n    [&](int row, int col, std::vector<long> current_path) {\n    if (current_path.size() == k) {\n      if (min_path.empty() || current_path < min_path) {\n        min_path = current_path;\n      }\n      return;\n    }\n\n    current_path.push_back(grid[row][col]);\n\n    int dr= {-1, 1, 0, 0};\n    int dc= {0, 0, -1, 1};\n\n    for (int i = 0; i < 4; ++i) {\n      int next_row = row + dr[i];\n      int next_col = col + dc[i];\n      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n        dfs(next_row, next_col, current_path);\n      }\n    }\n  };\n\n  for (int start_row = 0; start_row < n; ++start_row) {\n    for (int start_col = 0; start_col < n; ++start_col) {\n      dfs(start_row, start_col, {});\n    }\n  }\n\n  return min_path;\n}",
        "test": "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/130",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 每個人都知道斐波那契序列,數學家在過去幾百年深入研究過.然而,人們不知道的是,Tribonacci序列.Tribonacci序列是由重複定義的:tri(1) = 3tri(n) = 1 + n / 2,如果n是偶數.tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1),如果n是奇數.例如:tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 你得到一個非負整數n,你必須返回Tribonacci序列第一個n + 1的向量.例如: >>> ((((3) (dst) < (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::vector<long> tri(long n) {\n",
        "canonical_solutions": "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<long> tri(long n) {\n  std::vector<long> result;\n  if (n >= 0) {\n    result.push_back(1);\n  }\n  if (n >= 1) {\n    result.push_back(3);\n  }\n  for (long i = 2; i <= n; ++i) {\n    if (i % 2 == 0) {\n      result.push_back(1 + i / 2);\n    } else {\n      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)\n      {\n          result.push_back(result[i-1] + result[i-2] + result[i]);\n      }\n      else if (i - 1 >= 0 && i - 2 >= 0)\n      {\n          result.push_back(result[i-1] + result[i-2]);\n      }\n      else if (i - 1 >= 0)\n      {\n          result.push_back(result[i-1]);\n      }\n      else\n      {\n          result.push_back(0);\n      }\n    }\n  }\n  return result;\n}",
        "test": "}\nint main() {\n    auto candidate = tri;\n    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));\n    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));\n    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));\n    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));\n    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));\n    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));\n    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));\n    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));\n    assert(candidate((0)) == (std::vector<long>({(long)1})));\n    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));\n}\n"
    },
    {
        "task_id": "HumanEval/131",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个正整数 n,返回奇数的乘积.如果所有数字都是偶数,返回 0.例如: >>> digits (((1)) (1) >>> digits (((4)) (0) >>> digits (((235)) (15)\nlong digits(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong digits(long n) {\n  long product = 1;\n  std::string s = std::to_string(n);\n  bool has_odd = false;\n  for (char c : s) {\n    long digit = c - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      has_odd = true;\n    }\n  }\n  if (!has_odd) {\n    return 0;\n  }\n  return product;\n}",
        "test": "}\nint main() {\n    auto candidate = digits;\n    assert(candidate((5)) == (5));\n    assert(candidate((54)) == (5));\n    assert(candidate((120)) == (1));\n    assert(candidate((5014)) == (5));\n    assert(candidate((98765)) == (315));\n    assert(candidate((5576543)) == (2625));\n    assert(candidate((2468)) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/132",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數以字符串為輸入,而字符串只包含方括號.函數應返回true,如果且只有當有至少一個括號嵌入的有效括號序列. >>> is_nested\"[[]]\")) (true) >>> is_nested\"[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] (false) >>> is_nested\"[[]]\")) (false) >>> is_nested\"[[]]\")) (false) >>> is_nested\"[[]]]]\") (true) >>> is_nested\"[[]]\") (true)\nbool is_nested(std::string string) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool is_nested(std::string string) {\n  int balance = 0;\n  bool nested = false;\n  for (char c : string) {\n    if (c == '[') {\n      balance++;\n    } else if (c == ']') {\n      if (balance > 1) {\n        nested = true;\n      }\n      balance--;\n      if (balance < 0) {\n        return false;\n      }\n    }\n  }\n  return balance == 0 && nested;\n}",
        "test": "}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/133",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你需要返回给定的向量中二次数的和,先将向量中的每个元素圆到上方的int{}} 顶部. 例子: >>> lst{}:st{:st{:st{:st}:vector<float>{((float) 1.0f, (float) 2.0f, (float) 3.0f}))) (14) >>> lst{:st{:st{:vector<float>{(float) 1.0f, (float) 4.0f, (float) 9.0f}))) (98) lst{:st{:st{:vector<float>{(float) 1.0f, (float) 3.0f, (float) 5.0f, (float) 7.0f} (84) >>> lst{:st{:st{:st}:vector<float>{{{(float}1.0f, (float) 2.0f, (float) 2.0f, (float) 3.0f} (14) >>> lst{:st{:vector<float>{(float>{{{{0.0f} (1.0f, (float) 2.0f, (float) 2.0f)) (6) >>>\nlong sum_squares(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (float num : lst) {\n    long rounded_up = std::ceil(num);\n    sum += rounded_up * rounded_up;\n  }\n  return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));\n    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));\n    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));\n    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));\n    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));\n    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));\n    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));\n    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/134",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數,如果某個字符串的最後一個字符是字母表字符,而不是一個詞的一部分,否則則則為錯誤. 注意: \"word\"是用空格隔開的字符組. 例: >>> check_if_last_char_is_a_letter ((((\"apple pie\")) (false) >>> check_if_last_char_is_a_letter (((\"apple pi e\")) (true) >>> check_if_last_char_is_a_letter (((\"apple pi e \")) (false) >>> check_if_last_char_is_a_letter (((\"\")) (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty()) {\n    return false;\n  }\n  if (!isalpha(txt.back())) {\n    return false;\n  }\n  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {\n    return false;\n  }\n  return true;\n}",
        "test": "}\nint main() {\n    auto candidate = check_if_last_char_is_a_letter;\n    assert(candidate((\"apple\")) == (false));\n    assert(candidate((\"apple pi e\")) == (true));\n    assert(candidate((\"eeeee\")) == (false));\n    assert(candidate((\"A\")) == (true));\n    assert(candidate((\"Pumpkin pie \")) == (false));\n    assert(candidate((\"Pumpkin pie 1\")) == (false));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"eeeee e \")) == (false));\n    assert(candidate((\"apple pie\")) == (false));\n    assert(candidate((\"apple pi e \")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/135",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數,返回一個元素最大的索引,而這個索引不大於或等於它之前的元素.如果沒有這樣的元素,則返回 -1. 給出的向量不會包含重複值. 例: >>> can_arrange((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)\nlong can_arrange(std::vector<long> arr) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\nlong can_arrange(std::vector<long> arr) {\n  for (long i = 1; i < arr.size(); ++i) {\n    if (arr[i] < arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "test": "}\nint main() {\n    auto candidate = can_arrange;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));\n    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));\n    assert(candidate((std::vector<long>())) == (-1));\n}\n"
    },
    {
        "task_id": "HumanEval/136",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數,返回一個元組 (a,b),其中 'a' 是負整數中最大的數,而 'b' 是向量中正整數中最小的數.如果沒有負數或正數,返回他們是None. 例如: >>> largest_smallest_integers((std::vector<long>{long) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7}))) std::make_tuplestd::optional<long>{long}), std::optional<long>{long}) >>> largest_smallest_integers{long}::std vector<long>{long}),<opt_long><opt_long><opt_long><opt_long>\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<tuple>\n#include<vector>\n\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative.has_value() || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive.has_value() || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n    return std::make_tuple(largest_negative, smallest_positive);\n}",
        "test": "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));\n}\n"
    },
    {
        "task_id": "HumanEval/137",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// 建立一個函數,取整數,浮數,或代表實數嘅字串,並以其所應有的變量類型返回較大變量. 如果值係等,返回無. 注意:如果一個實數係用字串表示,浮點可能係 . 或 , >>> compare_one(1,2.5f) 2.5f >>> compare_one(1, \"2,3\") \"2,3\" >>> compare_one(\"5,1\", \"6\") \"6\" >>> compare_one(\"1\", 1) std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<optional>\n#include<string>\n\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;\n    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;\n    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }\n    bool operator==(float f) {\n        return f1 == f ;\n    }\n    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n\ndouble parse_real(const std::string& s) {\n    std::string temp = s;\n    std::replace(temp.begin(), temp.end(), ',', '.');\n    try {\n        return std::stod(temp);\n    } catch (const std::invalid_argument& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    } catch (const std::out_of_range& e) {\n        return std::numeric_limits<double>::quiet_NaN();\n    }\n}\n\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a.f2.empty() && b.f2.empty()) {\n        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {\n            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {\n            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {\n            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);\n            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);\n        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {\n            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);\n            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);\n        }\n    } else {\n        double val_a, val_b;\n        if (!a.f2.empty()) val_a = parse_real(a.f2);\n        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);\n        else val_a = static_cast<double>(a.f1);\n\n        if (!b.f2.empty()) val_b = parse_real(b.f2);\n        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);\n        else val_b = static_cast<double>(b.f1);\n\n        if (!std::isnan(val_a) && !std::isnan(val_b)) {\n            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);\n            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);\n        }\n    }\n    return Union_long_float_std_string_std_nullopt(std::nullopt{});\n}",
        "test": "}\nint main() {\n    auto candidate = compare_one;\n    assert(candidate(1, 2) == 2);\n    assert(candidate(1, 2.5f) == 2.5f);\n    assert(candidate(2, 3) == 3);\n    assert(candidate(5, 6) == 6);\n    assert(candidate(1, \"2,3\") == \"2,3\");\n    assert(candidate(\"5,1\", \"6\") == \"6\");\n    assert(candidate(\"1\", \"2\") == \"2\");\n    assert(candidate(\"1\", 1) == std::nullopt);\n}\n"
    },
    {
        "task_id": "HumanEval/138",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 估算是否可以把给定的数 n 写成正数 4 个偶数的和 例: >>> is_equal_to_sum_even ((4)) (错误) >>> is_equal_to_sum_even ((6)) (错误) >>> is_equal_to_sum_even ((8) (真实)\nbool is_equal_to_sum_even(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_equal_to_sum_even(long n) {\n    if (n <= 6 || n % 2 != 0) {\n        return false;\n    }\n    return true;\n}",
        "test": "}\nint main() {\n    auto candidate = is_equal_to_sum_even;\n    assert(candidate((4)) == (false));\n    assert(candidate((6)) == (false));\n    assert(candidate((8)) == (true));\n    assert(candidate((10)) == (true));\n    assert(candidate((11)) == (false));\n    assert(candidate((12)) == (true));\n    assert(candidate((13)) == (false));\n    assert(candidate((16)) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/139",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 巴西因數系數嘅定義係: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! 其中 n > 0 例如: >>> special_factorial (((4)) (288) 函數會收到一個整數作為輸入,應該返回這個整數嘅特殊因數.\nlong special_factorial(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong factorial(long k) {\n    long res = 1;\n    for (long i = 2; i <= k; ++i) {\n        res *= i;\n    }\n    return res;\n}\n\nlong special_factorial(long n) {\n    if (n <= 0) {\n        return 1;\n    }\n    long result = 1;\n    for (long i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = special_factorial;\n    assert(candidate((4)) == (288));\n    assert(candidate((5)) == (34560));\n    assert(candidate((7)) == (125411328000));\n    assert(candidate((1)) == (1));\n}\n"
    },
    {
        "task_id": "HumanEval/140",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定字符串文字,用底线符代替所有空格,如果字符串有超过2个连续空格,则用 - >>> fix_spaces (((\"例\")) (\"例\") >>> fix_spaces (((\"例1\")) (\"例1\") >>> fix_spaces (((\"例2\")) (\"_例2\") >>> fix_spaces (((\"例3\")) (\"_例-3\")\nstd::string fix_spaces(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string fix_spaces(std::string text) {\n    std::string result = \"\";\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                result += '_';\n            } else if (space_count > 1) {\n                result += '-';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1 && !result.empty() && result.back() != '_') {\n        result += '_';\n    } else if (space_count > 1 && !result.empty() && result.back() != '-') {\n        result += '-';\n    } else if (space_count > 0 && result.empty()) {\n        if (space_count > 2) result += '-';\n        else if (space_count == 1) result += '_';\n    } else if (space_count == 1 && result.empty()) {\n        result += '_';\n    }\n\n    std::string trimmed_result = \"\";\n    bool non_space_found = false;\n    for (char c : result) {\n        if (c != ' ') {\n            non_space_found = true;\n            trimmed_result += c;\n        } else if (non_space_found) {\n            trimmed_result += c;\n        }\n    }\n\n    while (!trimmed_result.empty() && trimmed_result.front() == '_') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '_') {\n        trimmed_result.pop_back();\n    }\n     while (!trimmed_result.empty() && trimmed_result.front() == '-') {\n        trimmed_result.erase(trimmed_result.begin());\n    }\n    while (!trimmed_result.empty() && trimmed_result.back() == '-') {\n        trimmed_result.pop_back();\n    }\n\n    std::string final_result = \"\";\n    space_count = 0;\n    for (char c : trimmed_result) {\n        if (c == '_') {\n            space_count++;\n        } else {\n            if (space_count == 1) {\n                final_result += '_';\n            } else if (space_count > 1) {\n                final_result += '-';\n            }\n            final_result += c;\n            space_count = 0;\n        }\n    }\n    if (space_count == 1) {\n        final_result += '_';\n    } else if (space_count > 1) {\n        final_result += '-';\n    }\n\n    return final_result;\n}",
        "test": "}\nint main() {\n    auto candidate = fix_spaces;\n    assert(candidate((\"Example\")) == (\"Example\"));\n    assert(candidate((\"Mudasir Hanif \")) == (\"Mudasir_Hanif_\"));\n    assert(candidate((\"Yellow Yellow  Dirty  Fellow\")) == (\"Yellow_Yellow__Dirty__Fellow\"));\n    assert(candidate((\"Exa   mple\")) == (\"Exa-mple\"));\n    assert(candidate((\"   Exa 1 2 2 mple\")) == (\"-Exa_1_2_2_mple\"));\n}\n"
    },
    {
        "task_id": "HumanEval/141",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 建立一個函數,如果檔案名稱為有效,則取一個字符串來表示檔案名稱,如果檔案名稱為有效,則返回\"是\",如果檔案名稱為有效,則返回\"否\".一個檔案名稱被認為是有效的,如果且只有如下所有條件都滿足: - 檔案名稱中不應有超過三個數字 ('0'-'9'). - 檔案名稱包含正確一個點 '.' - 點前的子字符串不應空,且以拉丁字母的字母開始 ('a'-'z'和'A'-Z'). - 點後的子字符串應是以下一個: ['txt', 'exe', 'll'd'] 例: >>> file_name_check\"((example.txt\") (\"是\") >>> file_name_check\"((example.dll\" (\"不\")\nstd::string file_name_check(std::string file_name) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    size_t dot_pos = std::string::npos;\n\n    for (size_t i = 0; i < file_name.length(); ++i) {\n        if (isdigit(file_name[i])) {\n            digit_count++;\n        } else if (file_name[i] == '.') {\n            dot_count++;\n            dot_pos = i;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {\n        return \"No\";\n    }\n\n    std::string name_part = file_name.substr(0, dot_pos);\n    std::string ext_part = file_name.substr(dot_pos + 1);\n\n    if (name_part.empty() || !isalpha(name_part[0])) {\n        return \"No\";\n    }\n\n    if (ext_part == \"txt\" || ext_part == \"exe\" || ext_part == \"dll\") {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) == (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n    assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"_f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
    },
    {
        "task_id": "HumanEval/142",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"這個函數會取一個整數向量. 對於向量的所有輸入,如果它的索引是3的倍數,函數會將整數輸入方正,如果它的索引是4的倍數而不是3的倍數,函數不會改變向量的輸入,其索引不是3或4的倍數. 函數會返回所有輸入的總和. 例: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst (long) >>> lst ({(long) -1, (long) -5, (long) -2, (long) -1, (long) -5}))\nlong sum_squares(std::vector<long> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}",
        "test": "}\nint main() {\n    auto candidate = sum_squares;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));\n    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));\n    assert(candidate((std::vector<long>())) == (0));\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));\n    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));\n    assert(candidate((std::vector<long>({(long)0}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));\n    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));\n    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));\n    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));\n    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));\n}\n"
    },
    {
        "task_id": "HumanEval/143",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你得到一個字符串代表一個句子,句子包含一些用空格分隔的單詞,你必須返回一個字符串,包含原始句子裡的單詞,其長度是素數,新字符串裡的單詞的順序應該與原始字符串相同. 例1: >>> words_in_sentence () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()\nstd::string words_in_sentence(std::string sentence) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nstd::string words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        if (is_prime(word.length())) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
    },
    {
        "task_id": "HumanEval/144",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你嘅任務係實現一個函數,令表達式 x*n 變簡單.如果 x*n 變整數,則函數返回 true,如果 x*n 變整數,則返回 false.x同 n 都係一個分數嘅字串表示,有以下嘅格式,<數字>/<分數>,其中分數同分數都係正整數.你可以假設 x 同 n 都係有效嘅分數,而分數唔包括零. >>> simplify (((\"1/5\"), (\"5/1\")) (true) >>> simplify (((\"1/6\"), (\"2/1\")) (false) >>> simplify (((\"7/10\"), (\"10/2\")) (false)\nbool simplify(std::string x, std::string n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong gcd(long a, long b) {\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\nbool simplify(std::string x, std::string n) {\n    long x_num, x_den, n_num, n_den;\n    size_t slash_pos = x.find('/');\n    x_num = std::stol(x.substr(0, slash_pos));\n    x_den = std::stol(x.substr(slash_pos + 1));\n\n    slash_pos = n.find('/');\n    n_num = std::stol(n.substr(0, slash_pos));\n    n_den = std::stol(n.substr(slash_pos + 1));\n\n    long num = x_num * n_num;\n    long den = x_den * n_den;\n\n    long common_divisor = gcd(num, den);\n    den /= common_divisor;\n\n    return den == 1;\n}",
        "test": "}\nint main() {\n    auto candidate = simplify;\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/6\"), (\"2/1\")) == (false));\n    assert(candidate((\"5/1\"), (\"3/1\")) == (true));\n    assert(candidate((\"7/10\"), (\"10/2\")) == (false));\n    assert(candidate((\"2/10\"), (\"50/10\")) == (true));\n    assert(candidate((\"7/2\"), (\"4/2\")) == (true));\n    assert(candidate((\"11/6\"), (\"6/1\")) == (true));\n    assert(candidate((\"2/3\"), (\"5/2\")) == (false));\n    assert(candidate((\"5/2\"), (\"3/5\")) == (false));\n    assert(candidate((\"2/4\"), (\"8/4\")) == (true));\n    assert(candidate((\"2/4\"), (\"4/2\")) == (true));\n    assert(candidate((\"1/5\"), (\"5/1\")) == (true));\n    assert(candidate((\"1/5\"), (\"1/5\")) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/145",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,按數位和的總和排序整數的向量. 注意:如果有幾個項有相同的數位和,請根據原始向量的索引排序.例如: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long)-1, (long) - 11, (long) - 12}))) (std::vector<long>({long) - 1, (long) - 11, (long) - 1, (long) - 12, (long) - 11)) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong sum_digits(long n) {\n    long sum = 0;\n    std::string s = std::to_string(std::abs(n));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return sum;\n}\n\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, size_t>> indexed_nums;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        indexed_nums.push_back({nums[i], i});\n    }\n\n    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {\n        long sum_a = sum_digits(a.first);\n        long sum_b = sum_digits(b.first);\n        if (sum_a != sum_b) {\n            return sum_a < sum_b;\n        }\n        return a.second < b.second;\n    });\n\n    std::vector<long> result;\n    for (const auto& pair : indexed_nums) {\n        result.push_back(pair.first);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = order_by_points;\n    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));\n    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));\n    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));\n}\n"
    },
    {
        "task_id": "HumanEval/146",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,以數字向量為輸入,並返回向量中元素數量大於 10 而數字的前位數和最後位數都是奇數 (1, 3, 5, 7, 9).例如: >>> specialFilter(((std::vector<long>({(long) 15, (long) -73, (long) -14 , (long) -15}))) (1) >>> specialFilter((std::vector<long>({(long) -2, (long) -3, (long) -4, (long) -21, (long) -109} (2))))\nlong specialFilter(std::vector<long> nums) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_odd_digit(char c) {\n    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');\n}\n\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (std::abs(num) > 10) {\n            std::string s = std::to_string(std::abs(num));\n            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = specialFilter;\n    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));\n    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));\n    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));\n    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));\n    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));\n    assert(candidate((std::vector<long>({(long)1}))) == (0));\n    assert(candidate((std::vector<long>())) == (0));\n}\n"
    },
    {
        "task_id": "HumanEval/147",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给你一个正整数 n.你必须创建一个长度为 n 的整数向量 a.对于每一个 i (1 ≤ i ≤ n),a[i] = i * i - i + 1.返回三倍数 (a[i],a[j],a[k]) 的数目,其中 i < j < k,a[i] + a[j] + a[k] 是 3 的倍数. 例: >>> get_max_triples((5)) (1) 解释:a = [1, 3, 7, 13, 21] 唯一有效的三倍数是 (1, 7, 13).\nlong get_max_triples(long n) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong get_max_triples(long n) {\n    if (n < 3) {\n        return 0;\n    }\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
        "test": "}\nint main() {\n    auto candidate = get_max_triples;\n    assert(candidate((5)) == (1));\n    assert(candidate((6)) == (4));\n    assert(candidate((10)) == (36));\n    assert(candidate((100)) == (53361));\n}\n"
    },
    {
        "task_id": "HumanEval/148",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 我哋太陽系有八個行星:最接近太陽嘅係水星,接住係金星,接住係地球,火星,木星,土星,天王星,海王星.寫一個函數,用兩個行星名做串 planet1 同 planet2. 函數應該返回一個包含所有行星嘅串,其軌道位於 planet1 同 planet2 之間,並按太陽嘅距離排序. 如果 planet1 或者 planet2 唔喺正確嘅行星名,函數應該返回一個空串. 例如: >>> bf((\"木星\"), (\"海王星\") (std::vector<std::string>{(std::string) \"土星\", (stdstring) \"天王星\"} (std::string)) >>> bf(\"地球\"), (\"水星\") (std::vector<std::string>) (Jupiter) (string) \" (Mars, Mercury) \" (string) (string) (string) (string) (string) (string) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str (str) (str) (str) (str) (\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return {};\n    }\n\n    int index1 = std::distance(planets.begin(), it1);\n    int index2 = std::distance(planets.begin(), it2);\n\n    if (index1 == index2) {\n        return {};\n    }\n\n    int start = std::min(index1, index2) + 1;\n    int end = std::max(index1, index2);\n\n    std::vector<std::string> result;\n    for (int i = start; i < end; ++i) {\n        result.push_back(planets[i]);\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == (std::vector<std::string>({(std::string)\"Venus\"})));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"})));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == (std::vector<std::string>({(std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\", (std::string)\"Uranus\"})));\n    assert(candidate((\"Earth\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Mars\"), (\"Earth\")) == (std::vector<std::string>()));\n    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::vector<std::string>()));\n}\n"
    },
    {
        "task_id": "HumanEval/149",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,接受一個字符串向量作為參數,從中除有奇數長度的字符串,並用排序序列返回得到的向量.向量永遠是字符串的向量,而從來不是數的向量,而且可能包含重複.向量的序列應該按每個單詞長度上升,你應該按這個規則返回排序的向量.如果兩個單詞長度相同,請按字母順序排序向量.函數應該按排序序返回一個字符串的向量.你可以假設所有單詞長度都一樣.例如: >>> list_sort{\"}std:: vector<stdstring>{\"}stdstring>{\"}stdstring\" (a\"}stdstring (a\"}stdstring (a\"}stdstring (a\"}stdstring (a\"}stdstring (a\"}stdstring (a\"}ststring (a\")) (a\" (a\"}stdstring (a\" (a\")) (a\" (a\"string) (a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a)) (a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"a\"\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> even_length_strings;\n    for (const std::string& s : lst) {\n        if (s.length() % 2 == 0) {\n            even_length_strings.push_back(s);\n        }\n    }\n\n    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n\n    return even_length_strings;\n}",
        "test": "}\nint main() {\n    auto candidate = sorted_list_sum;\n    assert(candidate((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"}))) == (std::vector<std::string>({(std::string)\"aa\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"school\", (std::string)\"AI\", (std::string)\"asdf\", (std::string)\"b\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"asdf\", (std::string)\"school\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"b\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"d\", (std::string)\"dcba\", (std::string)\"abcd\", (std::string)\"a\"}))) == (std::vector<std::string>({(std::string)\"abcd\", (std::string)\"dcba\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"}))) == (std::vector<std::string>({(std::string)\"AI\", (std::string)\"ai\", (std::string)\"au\"})));\n    assert(candidate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"b\", (std::string)\"c\", (std::string)\"c\", (std::string)\"a\"}))) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaa\", (std::string)\"bbbb\", (std::string)\"dd\", (std::string)\"cc\"}))) == (std::vector<std::string>({(std::string)\"cc\", (std::string)\"dd\", (std::string)\"aaaa\", (std::string)\"bbbb\"})));\n}\n"
    },
    {
        "task_id": "HumanEval/150",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 一個簡單嘅程序,如果n係個素數,應該返回x嘅值,如果唔係,應該返回y嘅值.例子: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)\nlong x_or_y(long n, long x, long y) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_prime(long n) {\n    if (n <= 1) return false;\n    for (long i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nlong x_or_y(long n, long x, long y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}",
        "test": "}\nint main() {\n    auto candidate = x_or_y;\n    assert(candidate((7), (34), (12)) == (34));\n    assert(candidate((15), (8), (5)) == (5));\n    assert(candidate((3), (33), (5212)) == (33));\n    assert(candidate((1259), (3), (52)) == (3));\n    assert(candidate((7919), (-1), (12)) == (-1));\n    assert(candidate((3609), (1245), (583)) == (583));\n    assert(candidate((91), (56), (129)) == (129));\n    assert(candidate((6), (34), (1234)) == (1234));\n    assert(candidate((1), (2), (0)) == (0));\n    assert(candidate((2), (2), (0)) == (2));\n}\n"
    },
    {
        "task_id": "HumanEval/151",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个数向量,返回该向量中奇数的数的平方和.忽略负数或非整数的数. >>> double_the_difference (二次差异) std::vector<float> (长) 1, (长) 3, (长) 2, (长) 0}))) (10) >>> double_the_difference (二次差异) std::vector<float> (长) -1, (长) -2, (长) 0}))) (0) >>> double_the_difference (二次差异) std::vector<float> (长) -9, (长) -2)))) (81) >>> double_the_difference (二次差异) std::vector<float> (长) -0))) (0) 如果输入向量是空,返回0.\nlong double_the_difference(std::vector<float> lst) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong double_the_difference(std::vector<float> lst) {\n    long sum_of_squares = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {\n            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);\n        }\n    }\n    return sum_of_squares;\n}",
        "test": "}\nint main() {\n    auto candidate = double_the_difference;\n    assert(candidate((std::vector<float>())) == (0));\n    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));\n    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));\n    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));\n    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));\n}\n"
    },
    {
        "task_id": "HumanEval/152",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 我覺得我哋都記得當我哋終於知道某個長期等待嘅事件嘅結果時嘅感覺. 你嗰一刻嘅感覺同想法,絕對值得記錄下去同埋比較. 你嘅任務係決定一個人係咪正確地猜出一系列對比嘅結果. 你俾咗兩個等長度嘅得分同猜測向量,每個指數都顯示咗一個對比. 返返一個同長度嘅向量,表示每一個猜測嘅差距. 如果佢哋猜得啱,值係0,如果唔係,值係猜測同得分之間嘅絕對差異. 例如: 比較: >>>(longd::longd vector<(long>{long) 1, (long) 2, (long) 3, (long) 4, (longd vector) 1, (longd vector) 4, (longd vector) 6, (longd vector) 6, (longd vector) 7, (longd vector) 8, (longd vector) 9, (longd vector) 10, (longd vector) 10, (longd vector) 10, (longd vector) 10, (longd vector) 10, (long vector) 10, (long vector 1) (longd vector (longd vector)\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    std::vector<long> diff;\n    for (size_t i = 0; i < game.size(); ++i) {\n        diff.push_back(std::abs(game[i] - guess[i]));\n    }\n    return diff;\n}",
        "test": "}\nint main() {\n    auto candidate = compare;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));\n    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));\n}\n"
    },
    {
        "task_id": "HumanEval/153",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你會得到一個類 (一個字符串) 的名稱和一個擴展的向量.擴展的強度如下:讓CAP是擴展名稱中大字母的數量,讓SM是擴展名稱中小字母的數量,強度由CAP - SM分數來表示.你應該找到最強的擴展,並以這個格式返回一個字符串:ClassName.StrongestExtensionName.如果有兩個或多個具有相同強度的擴展,你應該選擇向量中首先出現的一個.例如,如果你得到\"Slices\"作為類和擴展的向量:['SErviSliCes','Cheese',StuFed']那麼你應該返回'Slices.SliCes'::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliCes::SliC::SliCes::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::SliC::Sli::SliC::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::Sli::\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint calculate_strength(const std::string& extension) {\n    int cap_count = 0;\n    int sm_count = 0;\n    for (char c : extension) {\n        if (isupper(c)) {\n            cap_count++;\n        } else if (islower(c)) {\n            sm_count++;\n        }\n    }\n    return cap_count - sm_count;\n}\n\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    if (extensions.empty()) {\n        return class_name;\n    }\n\n    std::string strongest_extension = extensions[0];\n    int max_strength = calculate_strength(extensions[0]);\n\n    for (size_t i = 1; i < extensions.size(); ++i) {\n        int current_strength = calculate_strength(extensions[i]);\n        if (current_strength > max_strength) {\n            max_strength = current_strength;\n            strongest_extension = extensions[i];\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;\n}",
        "test": "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"}))) == (\"Sp.671235\"));\n}\n"
    },
    {
        "task_id": "HumanEval/154",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 您有兩個單詞.您需要返 true 如果第二個單詞或其任何轉換是第一個單詞的子字串 >>> cycpattern_check((\"abcd\"), (\"abd\")) (false) >>> cycpattern_check((\"hello\"), (\"ell\") (true) >>> cycpattern_check((\"whassup\"), (\"psus\")) (false) >>> cycpattern_check((\"abab\"), (\"baa\")) (true) >>> cycpattern_(check\"efef\"), (\"eeff\") (false) >>> cycpattern_check((\"himens\"), (\"simen\") (true)\nbool cycpattern_check(std::string a, std::string b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool cycpattern_check(std::string a, std::string b) {\n    if (b.empty()) {\n        return true;\n    }\n    if (a.length() < b.length()) {\n        return false;\n    }\n    for (int i = 0; i < b.length(); ++i) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}",
        "test": "}\nint main() {\n    auto candidate = cycpattern_check;\n    assert(candidate((\"xyzw\"), (\"xyw\")) == (false));\n    assert(candidate((\"yello\"), (\"ell\")) == (true));\n    assert(candidate((\"whattup\"), (\"ptut\")) == (false));\n    assert(candidate((\"efef\"), (\"fee\")) == (true));\n    assert(candidate((\"abab\"), (\"aabb\")) == (false));\n    assert(candidate((\"winemtt\"), (\"tinem\")) == (true));\n}\n"
    },
    {
        "task_id": "HumanEval/155",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定一个整数,返回一个分别有偶数和奇数的元组. 例: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)\nstd::tuple<long, long> even_odd_count(long num) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include<tuple>\n\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        int digit = c - '0';\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);\n}",
        "test": "}\nint main() {\n    auto candidate = even_odd_count;\n    assert(candidate((7)) == (std::make_tuple(0, 1)));\n    assert(candidate((-78)) == (std::make_tuple(1, 1)));\n    assert(candidate((3452)) == (std::make_tuple(2, 2)));\n    assert(candidate((346211)) == (std::make_tuple(3, 3)));\n    assert(candidate((-345821)) == (std::make_tuple(3, 3)));\n    assert(candidate((-2)) == (std::make_tuple(1, 0)));\n    assert(candidate((-45347)) == (std::make_tuple(2, 3)));\n    assert(candidate((0)) == (std::make_tuple(1, 0)));\n}\n"
    },
    {
        "task_id": "HumanEval/156",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 給定一個正整數,以羅馬數字等價值來計算,並以小寫返來.限制: 1 <= num <= 1000 例: >>> int_to_mini_roman((19)) (\"xix\") >>> int_to_mini_roman((152)) (\"clii\") >>> int_to_mini_roman((426)) (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n        {4, \"iv\"}, {1, \"i\"}\n    };\n\n    for (const auto& pair : roman_map) {\n        while (number >= pair.first) {\n            roman += pair.second;\n            number -= pair.first;\n        }\n    }\n    return roman;\n}",
        "test": "}\nint main() {\n    auto candidate = int_to_mini_roman;\n    assert(candidate((19)) == (\"xix\"));\n    assert(candidate((152)) == (\"clii\"));\n    assert(candidate((251)) == (\"ccli\"));\n    assert(candidate((426)) == (\"cdxxvi\"));\n    assert(candidate((500)) == (\"d\"));\n    assert(candidate((1)) == (\"i\"));\n    assert(candidate((4)) == (\"iv\"));\n    assert(candidate((43)) == (\"xliii\"));\n    assert(candidate((90)) == (\"xc\"));\n    assert(candidate((94)) == (\"xciv\"));\n    assert(candidate((532)) == (\"dxxxii\"));\n    assert(candidate((900)) == (\"cm\"));\n    assert(candidate((994)) == (\"cmxciv\"));\n    assert(candidate((1000)) == (\"m\"));\n}\n"
    },
    {
        "task_id": "HumanEval/157",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定三角形三边的长度. 如果三边形成一个直角三角形,返回true,否则返回false. 一个直角三角形是一个三角形,其中一个角是直角或90度. 例: >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)\nbool right_angle_triangle(long a, long b, long c) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool right_angle_triangle(long a, long b, long c) {\n    std::vector<long> sides = {a, b, c};\n    std::sort(sides.begin(), sides.end());\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n}",
        "test": "}\nint main() {\n    auto candidate = right_angle_triangle;\n    assert(candidate((3), (4), (5)) == (true));\n    assert(candidate((1), (2), (3)) == (false));\n    assert(candidate((10), (6), (8)) == (true));\n    assert(candidate((2), (2), (2)) == (false));\n    assert(candidate((7), (24), (25)) == (true));\n    assert(candidate((10), (5), (7)) == (false));\n    assert(candidate((5), (12), (13)) == (true));\n    assert(candidate((15), (8), (17)) == (true));\n    assert(candidate((48), (55), (73)) == (true));\n    assert(candidate((1), (1), (1)) == (false));\n    assert(candidate((2), (2), (10)) == (false));\n}\n"
    },
    {
        "task_id": "HumanEval/158",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 寫一個函數,可以接受一個字符串的向量. 這個向量包含不同單詞. 返回最多獨一無二字符的單詞. 如果多個字符串有最多獨一無二字符,請按詞典編排排序返回第一個. >>> find_max((std::vector<std::string>({(std::string) \"name\", (std::string) \"of\", (std::string) \"string\"}))) (\"string\") >>> find_max{(std::vector<std::string>({(std::string) \"name\", (std::string) \"enam\") >>> find_max{(std::vector<std::string>{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\nstd::string find_max(std::vector<std::string> words) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nint count_unique_chars(const std::string& s) {\n    std::set<char> unique_chars;\n    for (char c : s) {\n        unique_chars.insert(c);\n    }\n    return unique_chars.size();\n}\n\nstd::string find_max(std::vector<std::string> words) {\n    if (words.empty()) {\n        return \"\";\n    }\n\n    std::string max_unique_word = words[0];\n    int max_unique_count = count_unique_chars(words[0]);\n\n    for (size_t i = 1; i < words.size(); ++i) {\n        int current_unique_count = count_unique_chars(words[i]);\n        if (current_unique_count > max_unique_count) {\n            max_unique_count = current_unique_count;\n            max_unique_word = words[i];\n        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {\n            max_unique_word = words[i];\n        }\n    }\n    return max_unique_word;\n}",
        "test": "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"abc\", (std::string)\"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"this\", (std::string)\"game\", (std::string)\"of\", (std::string)\"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"gonna\", (std::string)\"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"we\", (std::string)\"are\", (std::string)\"a\", (std::string)\"mad\", (std::string)\"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"this\", (std::string)\"is\", (std::string)\"a\", (std::string)\"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({(std::string)\"play\", (std::string)\"play\", (std::string)\"play\"}))) == (\"play\"));\n}\n"
    },
    {
        "task_id": "HumanEval/159",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 你係個餓,已經食咗一定數嘅胡卜,但你需要多啲胡卜去完成一日嘅食物.你應該返一個向量 [ 剩餘嘅胡卜數,食完之後剩餘嘅胡卜數 ] 如果剩餘嘅胡卜唔夠,你就會食咗剩餘嘅胡卜,但你依然會餓. 範例: >>> eat((5), (6), (10)) (std::vector<long>{(()11, (long) 4})) >>> eat(4), (8), (9) (std::vector<long>{(()12, ( () 1})) >>> eat(1), (10), (10) (std::vector<long>{() 11, ()) eat0)) >>>(2), (5) (std::vector<long>{() 7, ()))) V:need: int number of remaining carrots that you need to eat in the current stock: 1000 * 0 = 整數: 0 @ 數量: 剩餘嘅胡卜你需要吃到 1000 剩餘嘅數量: 0\nstd::vector<long> eat(long number, long need, long remaining) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = 0;\n    long left = remaining;\n    long to_eat = need;\n\n    if (left >= to_eat) {\n        eaten = to_eat;\n        left -= to_eat;\n    } else {\n        eaten = left;\n        left = 0;\n    }\n\n    return {(long)number + eaten, left};\n}",
        "test": "}\nint main() {\n    auto candidate = eat;\n    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));\n    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));\n    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));\n    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));\n    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));\n    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));\n}\n"
    },
    {
        "task_id": "HumanEval/160",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定两个向量运算符,和运算符.第一个向量有基本代数运算,第二个向量是整数的向量.用给定的两个向量来构建代数式,并返回这个表达式的估值.基本代数运算:加法 (+) 减法 ( ) -乘法 (*) 底部除法 ( //) 乘积 (**) 例:运算符['+', '*', '-']向量 = [2, 3, 4, 5]结果 = 2 + 3 * 4 - 5 =>结果 = 9 注意:运算符向量的长度等于运算符向量减去一个的长度.运算符向量是非负数整数的向量.运算符向量至少有一个运算符,运算符向量至少有两个运算符.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::vector<long> current_operand = operand;\n    std::vector<std::string> current_operator = op;\n\n    auto apply_op = [&](long a, long b, const std::string& o) {\n        if (o == \"+\") return a + b;\n        if (o == \"-\") return a - b;\n        if (o == \"*\") return a * b;\n        if (o == \"//\") return a / b;\n        if (o == \"**\") return static_cast<long>(pow(a, b));\n        return 0L; // Should not happen\n    };\n\n    std::vector<std::string> precedence1 = {\"**\"};\n    std::vector<std::string> precedence2 = {\"*\", \"//\"};\n    std::vector<std::string> precedence3 = {\"+\", \"-\"};\n\n    auto evaluate = [&](const std::vector<std::string>& prec) {\n        size_t i = 0;\n        while (i < current_operator.size()) {\n            bool found = false;\n            for (const auto& o : prec) {\n                if (current_operator[i] == o) {\n                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);\n                    current_operand.erase(current_operand.begin() + i + 1);\n                    current_operator.erase(current_operator.begin() + i);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                i++;\n            }\n        }\n    };\n\n    evaluate(precedence1);\n    evaluate(precedence2);\n    evaluate(precedence3);\n\n    return current_operand[0];\n}",
        "test": "}\nint main() {\n    auto candidate = do_algebra;\n    assert(candidate((std::vector<std::string>({(std::string)\"**\", (std::string)\"*\", (std::string)\"+\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));\n    assert(candidate((std::vector<std::string>({(std::string)\"+\", (std::string)\"*\", (std::string)\"-\"})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));\n    assert(candidate((std::vector<std::string>({(std::string)\"//\", (std::string)\"*\"})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));\n}\n"
    },
    {
        "task_id": "HumanEval/161",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 函數應返回得到嘅字串. 例如 >>> solve((\"1234\")) (\"4321\") >>> solve((\"ab\")) (\"AB\") >>> solve(\"#a@C\")) (\"#A@c\")\nstd::string solve(std::string s) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (islower(c)) {\n                c = toupper(c);\n            } else if (isupper(c)) {\n                c = tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;\n}",
        "test": "}\nint main() {\n    auto candidate = solve;\n    assert(candidate((\"AsDf\")) == (\"aSdF\"));\n    assert(candidate((\"1234\")) == (\"4321\"));\n    assert(candidate((\"ab\")) == (\"AB\"));\n    assert(candidate((\"#a@C\")) == (\"#A@c\"));\n    assert(candidate((\"#AsdfW^45\")) == (\"#aSDFw^45\"));\n    assert(candidate((\"#6@2\")) == (\"2@6#\"));\n    assert(candidate((\"#$a^D\")) == (\"#$A^d\"));\n    assert(candidate((\"#ccc\")) == (\"#CCC\"));\n}\n"
    },
    {
        "task_id": "HumanEval/162",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 如果有個字符串 'text', 返回同等嘅 md5 值字符串.如果'text' 係一個空字符串,返回 None. >>> string_to_md5 ((((\"Hello world\")) \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n#include <optional>\n\n#include <openssl/md5.h>\n#include <iomanip>\n#include <sstream>\n\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}",
        "test": "}\nint main() {\n    auto candidate = string_to_md5;\n    assert(candidate((\"Hello world\")) == \"3e25960a79dbc69b674cd4ec67a72c62\");\n    assert(candidate((\"\")) == std::nullopt);\n    assert(candidate((\"A B C\")) == \"0ef78513b0cb8cef12743f5aeb35f888\");\n    assert(candidate((\"password\")) == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n"
    },
    {
        "task_id": "HumanEval/163",
        "nl": "yue_Hant",
        "pl": "cpp",
        "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// 给定两个正整数 a 和 b,以上升顺序返回 a 和 b 之间的偶数.例如: >>> generate_integers((2), (8)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n",
        "canonical_solutions": "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}",
        "test": "}\nint main() {\n    auto candidate = generate_integers;\n    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));\n    assert(candidate((17), (89)) == (std::vector<long>()));\n}\n"
    }
]