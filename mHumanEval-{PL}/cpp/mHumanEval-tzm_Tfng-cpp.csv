task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵉⵔⵉⴷ ⴳ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⴱⴰⵢⵢⵓⵕ, ⵎⴽⵍⵍⵉ ⴳⴰⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵉⴹⴰⵏⵏ ⵉⵏⴳⴳⵓⴳⵏ ⴳⵔⵙⵏ ⵓⴳⴳⴰⵔ ⵏ ⵓⴱⴰⵢⵢⵓⵕ. >>> has_close_elements{(std::vector<float>{((float)1.0f, (float)2.0f, (float)3.0f})), (0.5f)) (false) >>> has_close_elements{(std::vector<float>{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f)) (true)
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵙⴽⵛⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵎ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⵔⴳⴰⵍⵉⵏ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ ⵜⴱⴹⵉⴷ ⵜⵔⵓⴱⴱⴰ ⴰⴷ ⵙ ⵜⵔⴳⴰⵍⵉⵏ ⵉⵥⵍⵉⵏ ⴷ ⴰⴷ ⵜⵔⵣⴷ ⵜⴰⵡⴰⵍⵜ ⵏ ⵜⵔⴳⴰⵍⵉⵏ ⴰⴷ. ⵜⵔⵓⴱⴱⴰ ⵉⵥⵍⵉⵏ ⴳⴰⵏⵉⵏ ⵜⵉⵎⵙⴰⵙⴰⵏⵉⵏ (ⵢⴰⵜ ⵜⴰⵔⴳⴰⵍⵜ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵖⵓⴷⴰⵏ) ⴷ ⵓⵔ ⴳⵉⵏⵜ ⵜⵔⴳⴰⵍⵉⵏ ⴳ ⵓⴳⵏⵙⵓ ⵏ ⴽⵔⴰ ⵢⴳⴰⵜⵜ ⵢⴰⵏ. ⵜⵙⵙⵓⴷⴷⵉⴷ ⴽⵔⴰ ⵏ ⵡⴰⵏⵙⴰ ⴳ ⵜⵔⴳⴰⵍⵜ ⵏ ⵓⵙⴽⵛⵎ. >>> separate_paren_groups(""(( ) (() ((( ) ))) (std::vector<std::string>(({((((())))))
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵟⵟⵓⵏ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⴼⵍⴷ ⴰⵎⵏⵉⴳ, ⵉⵖⵢ ⴰⴷ ⵜ ⵜⴱⴹⵓ ⵅⴼ ⵓⴳⵣⵣⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ (ⴰⴳⵣⵣⵓⵎ ⴰⵎⵇⵇⵔⴰⵏ ⵉⵎⵥⵥⵉⵏ ⵏ ⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵢⴰⴽⴽⴰⵏ) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵔⴰⵡⵏ (ⴰⴳⵣⵣⵓⵎ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⴼⵍⴷ ⴰⵀⴰ ⵉⵎⵥⵥⵉⵏ ⵏ 1). ⵙⵙⵓⴼⵖ ⵓⴳⵣⵣⵓⵎ ⴰⵎⵔⴰⵡ ⵏ ⵓⵟⵟⵓⵏ. >>> truncate_number((3.5f)) (0.5f)
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵢⴰⵏ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⴷ ⵓⴽⵛⵛⵓⵎ ⵏ ⵓⵥⵕⴼ ⴳ ⵓⴽⵓⵏⵟⵓⵔ ⵏ ⵍⴱⴰⵏⴽ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵓⵎⵢⴰ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍ ⵎⴽⵍⵍⵉ ⵜⵣⵔⵉ ⵜⵣⵕⴼⵜ ⵏ ⵓⴽⵓⵏⵟⵓⵔ ⴷⴷⴰⵡ ⵓⵎⵢⴰ, ⴷ ⴳ ⵓⵙⴰⵜⵉ ⴷⵖ, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ true. ⵎⴽ ⵓⵔ ⵜⵣⵔⵉ ⵜⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⴰⵔ false. >>> below_zero(((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ, ⵙⵙⵉⴹⵏ ⴰⵎⵏⵣⴰⵢ ⴰⵖⴰⵔⴰⵏ ⴰⵖⴰⵔⴰⵏ ⵅⴼ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵏⴰⴼⵓⵜ. ⴰⵎⵏⵣⴰⵢ ⴰⵖⴰⵔⴰⵏ ⴰⵖⴰⵔⴰⵏ ⵉⴳⴰ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵖⴰⵔⴰⵏ ⴳⵔ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⴷ ⵜⵏⵇⵇⵉⴹⵜ ⵜⴰⵏⴰⵎⵎⴰⵙⵜ (ⴰⵎⵏⵣⴰⵢ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ): MAD = average ∙ x - x_mean ∙ >>> mean_absolute_deviation (((std::vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⴽⵛⵎ ⴰⵎⴹⴰⵏ ""ⴷⵉⵍⵉⵜⵔ"" ⴳⵔ ⴽⵓ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⴹⴼⴰⵕⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ `numbers' >>> intersperse(((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse(((std::vector<long>({(long)1, (long)2, (long)3})), (4)) (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵙⴽⵛⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵎ ⵉⵙⵎⴷⵢⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵉ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ ⵙ ⵉⵎⵏⵖⵉ. ⵉ ⴽⵓ ⵜⴰⵔⴰⴱⴱⵓⵜ, ⵙⴽⵛⵎ ⴰⵙⵡⵉⵔ ⵏ ⵓⵙⴽⵛⵎ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ. ⵙ ⵓⵎⴷⵢⴰ (() (()) ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵓⵙⴽⵛⵎ ⴳ ⵜⵉⵣⵉ ((())) ⵖⵓⵔⵙ ⴽⵕⴰⴹ. >>> parse_nested_parens ((((((()) ((())) () (((()))))) (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⴼⵉⵍⵜⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵙⵎ ⵏ ⵜⵔⴳⴰⵍⵜ >>> filter_by_substring(((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""})), (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⵔⵔⴰⵢⵜ ⵏ ⵜⵓⵏⵖⵉⵍⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⵎⵓⵏ ⴷ ⵓⵙⴼⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⴽⵜⵓⵔ. ⵜⴰⵔⵔⴰⵢⵜ ⵜⵓⵏⵖⵉⵍⵜ ⴰⴷ ⵜⴳⴰⵜ 0 ⴷ ⵓⵙⴼⴰⵔ ⵜⵓⵏⵖⵉⵍⵜ ⴰⴷ ⵜⴳⴰⵜ 1. >>> sum_product{}{std::vector<long>{}} (std::make_tuple{0, 1)) >>> sum_product{std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple{10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴰⵔ ⵜⵉⵣⵉ ⵏ ⵓⴽⵙⴰⵢ. >>> rolling_max(((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2}))) (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)3, (long)4, (long)4}))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵥⴹⴰⵕⵖ ⴰⴷ ⵙⵙⵏⵖ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ ⵜⴰⵔⵓⵙⵜ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⵏ ⵙ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ. ⵜⴰⵡⵏⴳⵉⵎⵜ ⵏ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵜⴳⴰ ⵜⵓⵏⵏⵓⵜ: - ⵥⴹⴰⵕⵖ ⴰⴷ ⵙⵙⵏⵖ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ ⵜⴰⵔⵓⵙⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ. - ⵥⴹⴰⵕⵖ ⴰⴷ ⵙⵙⵏⵖ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵓⵖⵉⵍⵓⴼ ⴰⵏⵏⴰⵍ ⵏ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵔⵉⵏ ⴷⴰⵜ ⵏ ⵓⵖⵉⵍⵓⴼ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ. >>> make_palindrome(("""")) ("""") >>> make_palindrome((""cat"")) (""catac"") >>> make_palindrome((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵏⴽⵛⵓⵎⵏ ⴳⴰⵏ ⵙⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ a ⴷ b ⴳ ⵍⵍⴰⵏ 1 ⴷ 0 ⵅⴰⵙ. ⵙⴽⵔ XOR ⴱⵉⵏⴰⵔⵉ ⵅⴼ ⵉⵏⴽⵛⵓⵎⵏ ⴰⴷ ⴷ ⵜⵔⴰⵔⵓⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⴰⵡⴷ ⵏⵜⵜⴰⵜ ⴰⵎⵎ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⵡⵔⵉⴽ. >>> string_xor((""010""), (""110"")) (""100"")
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⴱⴰⵢⵢⵓⵕ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⴽⵔ ⴰⵖⵣⵉⴼ. ⵙⴽⵔ ⴰⵖⵣⵉⴼ ⴰⵎⵣⵡⴰⵔⵓ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ⵓⵖⵣⵉⴼ ⴰⵎⵎ ⵢⴰⵏ. ⵙⴽⵔ None ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⴱⴰⵢⵢⵓⵕ ⵏ ⵓⴽⵛⵛⵓⵎ ⵉⴳⴰ ⵜ ⵡⴰⴽⴰⵍ. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{((std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest(((std::vector<std::string>({(std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⴰⵎⵟⵟⵓ ⴰⵎⵢⵉⵡⵏ ⴰⵅⴰⵜⴰⵔ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b >>> greatest_common_divisor (((3), (5)) (1) >>> greatest_common_divisor (((25), (15)) (5)
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵓⵎⵙⵙⴼⵜⵉ ⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵏⴼⴰⵔⵏ ⵙⴳ ⵓⵥⵥⵉⴹⵕ ⴰⵔ ⵓⵣⵉⵍ ⵏ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ >>> all_prefixes (((""abc"")) (std::vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵜⵜⵓⵙⵏⴽⴷⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⴳⵔ 0 ⴷ n. >>> string_sequence((0)) (""0"") >>> string_sequence((5)) (""0 1 2 3 4 5"")
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵢⴰⵜ ⵜⴽⵔⵔⴰⵢⵜ, ⵙⵙⵏⵖ ⵎⵏⵏⴰⵡ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ (ⵓⵔ ⵏⵙⵙⵉⵏ ⵎⴰⵏⵉ ⵉⴳⴰ ⵡⴰⴷⴷⴰⴷ) ⵉⵙ ⴷⵉⴳⵙ >>> count_distinct_characters (((""xyzXYZ"")) (3) >>> count_distinct_characters (((""Jerry"")) (4)
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⴷ ⵜⵙⵙⴽⵛⵎⴷ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⴳ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵓⵙⵎⵉⵍ ASCII. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴼⵙⵉ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵖⵉⵍⵓⴼ ⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⴽⵉⴳⴰⵏ ⵏ ⵉⵎⵉⴽⴽ. ⴷⵉ ⴷⴷⴰⵡ ⵏ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ: 'o' note, lasts four beats 'o 112' - last half note, lasts two beats 'o 112' - quater note, lasts one beat >>> parse_music. (((o o o o o o o o o o o o o o o o o o o))::: (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵥⵕ ⵎⵏⵏⴰⵡⵜ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵔⴰⴷ ⵉⵍⵉⵏⵜ ⵜⵉⴼⵔⴽⵉⵏ ⵏ ⵜⵣⵍⵖⴰ ⴳ ⵜⵣⵍⵖⴰ ⵏ ⵓⵣⵡⵍ. ⵥⵕ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵔⴰⴷ ⵉⵍⵉⵏⵜ. >>> how_many_times((""""), (""a"")) (0) >>> how_many_times(""aaa""), (""a"") (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵙⴽⵛⵎ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ""ⵙⵢⴰ"" ⴰⵔ ""ⵜⵥⴰ"". ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ ""ⵙⵢⴰ"", ""ⵢⵉⵡⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", ""ⴽⴽⵓⵥ"", ""ⵎⵎⵓⵙ"", ""ⵚⴹⵉⵚ"", ""ⴰⵙⵙⴰ"", ""ⴰⵙⴰ"" ⴷ ""ⵜⵥⴰ"". ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵓⴽⵛⵛⵓⵎ ⵙ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵉⵎⵥⵥⵢⴰⵏⵏ ⴰⵔ ⵉⵎⵇⵇⵔⴰⵏⵏ >>> sort_numbers ((("" ⴽⵕⴰⴹ ⵢⴰⵏ ⵙⵎⵎⵓⵙ"")) (""ⵢⵉⵡⵏ ⴽⵕⴰⴹ ⵙⵎⵎⵓⵙ"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ (ⵙ ⵓⵖⵣⵣⵉⴼ ⵏ ⵙⵉⵏ) ⵙⵜⴰⵢ ⴷ ⵜⵓⵖⴰⵍ ⵙⵉⵏ ⵡⵉⵏⵏⴰ ⴳⴰⵏ ⵉⵎⵉⴽⴽⵏ ⴷ ⵡⵉⵏⵏⴰ ⵢⴰⴹⵏⵉⵏ ⴷ ⵜⵓⵖⴰⵍ ⵙ ⵓⵙⵓⴷⵙ (ⵉⴹ ⴰⵎⵥⵥⵢⴰⵏ, ⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ). >>> find_closest_elements (((std::vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.2f}))) (std::make_tuple (((2.0f, 2.2f)) >>> find_closest_elements (((std::vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f)) (std::mple_tuple: 2.0f, (float) 2.0f))
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⵎⵉⴹⴰⵏ ⵏ ⵓⴽⵜⵓⵔ (ⵙ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ), ⵙⵙⵎⵔⵙ ⵜⴰⵙⵏⴼⵍⵜ ⵜⴰⵍⵉⵎⴰⵏⵜ ⵉ ⵓⵎⵉⴹⴰⵏ ⴰⴷ, ⴰⴱⵔⵉⴷ ⵏⵏⴰ ⵔⴰⴷ ⵉⴳ ⵓⴽⵜⵓⵔ ⴰⵎⵥⵥⵢⴰⵏ 0 ⴷ ⵓⴽⵜⵓⵔ ⴰⵎⵇⵔⴰⵏ 1 >>> rescale_to_unit{((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⴼⵉⵍⵜⵔ ⴼⵉⴽⵜⵓⵔ ⵏ ⴽⵓ ⵡⴰⵜⵉⴳ ⵏ cppthon ⵖⴰⵙ ⵉ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string)3.14f, (std::string)5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>(()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⵖⵣⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ >>> string_length(("""")) (0) >>> string_length((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵓⵎⴹⴰⵏ n, ⵙⵙⵏ ⴰⵎⴹⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵉⵜⵜⴱⴹⵓⵏ n ⵙ ⵓⵖⵣⵓ, ⴷ ⵉⵎⵥⵥⵉⵏ ⵙⴳ n >>> largest_divisor ((((15)) (5)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⵙⴼⵍⴷ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⴱⵔⵉⴷ ⵙⴳ ⵉⵎⵥⵥⵉⵏ ⴰⵔ ⵉⵎⵇⵇⵓⵔⵏ. ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵎⴳⴳⵉⵜⵏ ⴰⴷ ⵉⵇⵇⵏ ⵙ ⵓⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵢⴰⴷ ⵉⵍⵍⴰ ⴳ ⵓⵙⴼⵍⵍⴷ. ⵉⵎⴹⴰⵏ ⵏ ⵓⵙⴽⵛⵎ ⵉⵇⵇⵏ ⵙ ⵓⵙⴼⵍⴷ ⵏ ⵉⵎⴳⴳⵉⵜⵏ >>> ⵉⵙⴼⵍⴷ (((8)) (std::vector<long>({(long)2, (long)2, (long)2})) >>> ⵉⵙⴼⵍⴷ (((25)) (std::vector<long>({(long)5, (long)5})) >>> ⵉⵙⴼⵍⴷ ((((70)) (std::vector<long>({(long)2, (long)5, (long)7}))
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴰⴽⴽⵡ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵜⵜⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ. ⵃⴹⵓ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵇⵇⵉⵎⵏ ⴰⵎⵎ ⵡⵉⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⴽⵣⵏ. >>> remove_duplicates(((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4}))) (std::vector<long>({(long)1, (long)3, (long)4}))
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⵙⵙⴼⵍⴷ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵉⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴷ ⵉⵎⵇⵔⴰⵏⵏ ⵙ ⵉⵎⵥⵥⵉⵏⵏ. >>> flip_case (((""Hello"")) (""hELLO"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵙⵎⵓⵏ ⵏ ⵓⴱⴰⵢⵢⵓⵕ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⴳ ⵢⴰⵏ ⵓⵙⴽⴽⵉⵍ >>> concatenate(((std::vector<std::string>())) ("""") >>> concatenate(((std::vector<std::string>({(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) (""abc"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⴼⵉⵍⵜⵔ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ ⵢⴰⵏ ⵓⵣⵡⵍ. >>> filter_by_prefix((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string) ""cde"", (stdstring) ""array""})), (""a"") (std::vector<std::string>({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⴷⴰⵢ ⵉⵎⴹⴰⵏⵏ ⵉⴳⴳⵓⵜⵏ ⴳ ⵓⴱⵉⴽⵜⵓⵔ. >>> get_positive((std::vector<long>({long)-1, (long)2, (long)-4, (long)-4, (long)5, (long)6}))) (std::vector<long>({long)2, (long)5, (long)6})) >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (), (0, (long)123, (long)1, (long)-10}))) (std::vector<long>{(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long) 1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⴽⴽⵡ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1)) (false)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⴷⴰ ⵜⴻⵜⵜⵓⵎⵥ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l ⴰⵔ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l' ⵣⵓⵏⴷ l' ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵏⵏⴰ ⵓⵔ ⵏⵣⴹⴰⵕ ⴰⴷ ⵏⴱⴹⵓ ⵙ ⴽⵕⴰⴹ, ⵎⴰⵛⴰ ⵜⵉⵏⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵏⵏⴰ ⵉⵜⵜⵣⴹⴰⵕⵏ ⴰⴷ ⵏⴱⴹⵓ ⵙ ⴽⵕⴰⴹ ⴳⴰⵏⵉⵏ ⵜⵉⵏⵉⴳⵉⵏ ⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⵏ l, ⵎⴰⵛⴰ ⵜⵜⵓⵙⵎⵉⵍⵏⵜ. >>> sort_third:{((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third:{(std::vector<long>{(long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 9, (long) 2}))) (std::vector<(long>{(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long5}))
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) (std::vector<long>{(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⴳⴳⵓⵜⵏ ⴳ ⵓⵎⵙⵙⵓⴷⵙ. >>> max_element((std::vector<long>({(long)1, (long)2, (long)3}))) (3) >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵉⵍⵉⵏ n ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵔⴰⵏ ⵙ 11 ⵏⵖ 13. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⴷⴰ ⵜⴻⵜⵜⵓⵎⵥ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l ⴰⵔ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵏ ⵓⴽⵜⵓⵔ l' ⵣⵓⵏⴷ l' ⴳ ⵉⵙⵓⵎⴰⵔ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵎⴰⵛⴰ ⵡⴰⵜⵉⴳⵏ ⵏⵏⵙ ⴳ ⵉⵙⵓⵎⴰⵔ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳⴰⵏ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵓⵎⴰⵔ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏ l, ⵎⴰⵛⴰ ⵜⵜⵓⵙⵎⵉⵍⵏ. >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<((long>{((long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib ⴷⴰ ⵢⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ n-ⵜⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⴷ ⵉⴳⴰ ⴰⵡⴷ ⴰⵎⵣⵡⴰⵔⵓ. >>> prime_fib((1)) (2) >>> prime_fib(2) (3) >>> prime_fib(3)) (5) >>> prime_fib(4)) (13) >>> prime_fib(5) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// triple_sum_to_zero ⴷⴰ ⵉⵜⵜⴰⵎⵥ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ. ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵥⵍⵉⵏ ⴳ ⵓⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏⵏ ⵙ ⵓⵎⵢⴰ, ⴷ ⵜⵉⴱⵔⵙⴳⴳⵡⴰⴷⵜ ⵎⴽ ⵏⵏ ⵓⵔ ⵉⵍⵍⵉ. >>> triple_sum_to_zero((std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triple_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (true) triple_sum_to_zero(std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) >>> triple_sum_to_zero(std::vector<long> (long) 2, (long) 4, (long) 5, (long) 3, (long) 9, (long) 7))) (true) >>> triple_sum_long_vector >>> (long_false) >>> triple_sum_false
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵏⵎⴷ ⵜⴰⴱⵔⵉⴷⵜ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⴰⵖⴰⵔⴰⵙⵜ ⵜⴰⵣⵣⵉⴳⵣⵜ ⵜⴰⵖⴰⵔⴰⵙⵜ. n ⵏ ⵉⵎⵓⴷⴰⵔ ⴰⵔ ⵙⵙⵓⴷⵙⵏ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵙ ⵓⵥⵍⵎⴰⴹ; ⴳ ⵢⴰⵜ ⵜⵉⵣⵉ, ⵢⴰⵜ ⵜⵔⴰⴱⴱⵓⵜ ⵢⴰⴹⵏ ⵏ n ⵏ ⵉⵎⵓⴷⴰⵔ ⴰⵔ ⵙⵙⵓⴷⵙⵏ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵙ ⵓⵥⵍⵎⴰⴹ. ⵙⵏⴰⵜ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵏ ⵉⵎⵓⴷⴰⵔ ⴰⵔ ⵜⵜⴱⴰⵢⴰⵏ ⵙⴳ ⵢⴰⵏ ⵙ ⵡⴰⵢⵢⴰⴹ. ⴽⵓⵍⵍⵓ ⵉⵎⵓⴷⴰⵔ ⴰⵔ ⵙⵙⵓⴷⵙⵏ ⵙ ⵢⴰⵜ ⵜⵉⵣⵣⵍⴰ. ⴷⴰ ⵜⵜⵉⵏⵉⵏ ⵙⵏⴰⵜ ⵏ ⵉⵎⵓⴷⴰⵔ ⴰⵔ ⵜⵜⵎⵓⵏⵏ ⴽⵓⴷⴷⵉ ⵜⵙⵙⵓⴷⵙ ⵢⴰⵜ ⵜⴽⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵙⵙⵓⴷⵙⵏ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵙ ⵓⵥⵍⵎⴰⴹ ⵢⴰⵜ ⵜⴽⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵙⵙⵓⴷⵙⵏ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵙ ⵓⵥⵍⵎⴰⴹ. ⵎⴰⵛⴰ, ⵉⵎⵓⴷⴰⵔ ⴰⴷ ⴳⴰⵏ ⵉⵅⴰⵜⴰⵔⵏ ⴱⴰⵀⵔⴰ ⴷ ⵉⴷⵓⵙⵏ; ⵙ ⵎⴽⴰ, ⴰⵔ ⵙⵙⵓⴷⵙⵏ ⴳ ⵓⴱⵔⵉⴷ ⵏⵏⵙⵏ ⴰⵎⵎⴽⵍⵍⵉ ⵓⵔ ⵜⵜⵎⵓⵏ. ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⴰⵔ ⵜⵙⵙⵓⴼⴽⴰⵔ ⵉⵎⴹⴰⵏ ⵏ ⵉⵎⵎⴽⴰⵔⴰⵙⵏ.
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴻⴽⴽⴰ ⵓⵎⵓⴷⴰⵔ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵢⴷⵔⵏ ⵙ 1. >>> incr_list((std::vector<long>({long)1, (long)2, (long)3}))) (std::vector<long>({long)2, (long)3, (long)4})) >>> incr_list((std::vector<long>({long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) (std::vector<long>({long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// pairs_sum_to_zero ⴷⴰ ⵉⵜⵜⴰⵎⵥ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ. ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏⵏ ⵙ ⵓⵎⵢⴰ, ⴷ ⵜⵉⴱⵔⵙⴳⴳⵡⴰⴷⵜ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>(long) 1, (long) 3, (long) 2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long> (long) 2, (long) 4, (long) 5, (long) 3, (long) 5, (long) 7))) (true))) pairs_sum_long))) (true) >>> (long_se) >>> (long_vector) >>>
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵏⴼⵍ ⵜⴰⵙⵉⵍⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ x ⵙ ⵜⴰⵙⵉⵍⴰ. ⵙⵏⴼⵍ ⴰⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵏⴼⵍ. ⵉⵎⴹⴰⵏⵏ ⵏ ⵜⵙⵉⵍⴰ ⵎⵥⵥⵉⵢⵏ ⵙⴳ 10. >>> change_base((8), (3)) (""22"") >>> change_base((8), (2)) (""1000"") >>> change_base((7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵖⵣⵉ ⵏ ⵓⴳⴰⴼⴰ ⴷ ⵢⵉⴳⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎⵇⵔⴰⵏ ⵉ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. >>> triangle_area((5), (3)) (7.5f)
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵏ Fib4 ⵜⴳⴰ ⵢⴰⵜ ⵜⴰⵍⴳⴰⵎⵜ ⵣⵓⵏⴷ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵜⵉⵙⵙ n ⵏ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵉⵎⴹⴰⵏ ⵏ fib4. ⵓⵔ ⵜⵙⵙⵎⵔⵙⴷ ⴰⵙⵏⴼⵍ. >>> fib4((5)) (4) >>> fib4((6)) (8) >>>4((7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⴰⴽⵡⵍ ⵓⵏⴰⵎⵎⴰⵙ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⴱⴰⵢⵢⵓⵕ l. >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) (float(3) >>> median((std::vector<long>({(long) -10, (long) 4, (long) 6, (long) 1000, (long) 10, (long) 20}))) (15.0f)
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⴰⴷ ⵉⴳ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵜⵜⵓⵢⴰⴽⴽⴰⵏ ⵢⴰⵏ ⵓⴱⴰⵍⵉⵏⴷⵔⵓⵎ >>> is_palindrome ((("""")) (true) >>> is_palindrome (((""aba"")) (true) >>> is_palindrome (((""aaaaa"")) (true) >>> is_palindrome (((""zbcd"")) (false)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵏⵜⵜⴰⴼⴰ 2^n modulo p (ⴰⴷ ⵏⵙⵙⵏ ⵉⵎⴹⴰⵏⵏ). >>> modp(((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp((0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels ⵜⴳⴰ ⵢⴰⵜ ⵜⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷ ⴰⵔ ⵢⴰⴽⴽⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴱⵍⴰ ⵉⵎⵙⵍⵉ. >>> remove_vowels(("""")) ("""") >>> remove_vowels((""abcdef"")) (""bcdf"") >>> remove_vowels((""aaaaa"")) ("""") >>> remove_vowels(""aaBAA"")) (""B"") >>> remove_vowels((""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔ true ⵎⴽ ⴷⴰ ⵜⵜⴳⵡⴷⵏ ⵉⵎⴹⴰⵏⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ l ⴷⴷⴰⵡ ⵏ ⵓⵖⵣⵓ t. >>> below_threshold(((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) (true) >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵎⵓⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏⵏ x ⴷ y >>> ⵙⵙⵎⵓⵏ ((((2), (3)) (5) >>> ⵙⵙⵎⵓⵏ (((5), (7)) (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵉⵔⵉⴷ ⵎⴽ ⴳⴰⵏ ⵙⵉⵏ ⵡⴰⵡⴰⵍⵏ ⵖⵓⵔⵙⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ. >>> same_chars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) (true) >>> same_chars((""abcd""), (""dddddddddabc"")) (true) >>> same_chars(""dddddddabc""), (""abcd"") (true) >>> same_chars((""eabcd""), (""dddddddabc"")) (false) same_chars >>>""((abcd""), (""dddddddddabce"") (false) >>> same_chars((""eabcd""), (""ddddzzzzzdzzdddabc"") (false)
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵡⵉⵙⵙ n. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ ""<"" ⴷ "">"". return true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⴰⵥⵕⵓ ⵏ ⵓⵥⵕⵓ ⵢⴰⵏ ⵓⵥⵕⵓ ⵏ ⵓⵇⵇⵏ. >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>"")) (true) >>> correct_bracketing("">(<>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Return true ⵉⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴷⴰ ⵙⵙⴽⵔⵏ ⵏⵖⴷ ⴷⴰ ⵙⵙⴽⵔⵏ ⵙ ⵜⴰⵍⵖⴰ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ. >>> monotonic(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (true) >>> monotonic(((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (false) >>> monotonic(((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (true)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⴰⵏⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵉ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ. >>> common((std::vector<long>({(long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({(long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({(long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long>{(long} 2, (long) 3))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⴰⵎⴳⴳⴰⵔⵓ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// sum_to_n ⵜⴳⴰ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏⵏ ⵉⵎⴹⴰⵏⵏ ⵙⴳ 1 ⴰⵔ n. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⵏ ""("" ⴷ "")"". ⴰⵔ ⵉⵜⵜⵔⴰⵔ true ⵎⴽ ⴷⴰ ⵉⵜⵜⴳⴳ ⴽⵓ bracket ⵉⵕⵥⵎⵏ ⵢⴰⵏ bracket ⵉⵇⵇⵏⵏ. >>> correct_bracketing((""("")) (false) >>> correct_bracketing(""()) (true) >>> correct_bracketing(""(()))) (true) >>> correct_bracketing(("") ((())) (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs ⴷⴰ ⵉⵙⵎⴷⵢⴰ ⵉⵎⵢⴰⴼⵓⵜⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ. xs[0] + xs[1] * x + xs[2] * x^2 + .... ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⵜⴰⵙⵏⴼⵍⵓⵍⵜ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵢⴰⵜ ⵜⴰⵍⵖⴰ. >>> derivative(((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> derivative::std::vector<(long>{(long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵔⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴱⵓⴱⵉⴱ ⵜⴳⴰ ⵢⴰⵜ ⵜⴰⵔⵔⴰ ⵢⴰⴽⵙⵓⵍⵏ ⵙ ⵜⴰⵔⵔⴰ ⵏ ⴼⵉⴱⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ: ⴼⵉⴱⴱⵓⴱⵉⴱ ((0) == 0 ⴼⵉⴱⴱⵓⴱⵉⴱ ((1) == 0 ⴼⵉⴱⴱⵓⴱⵉⴱ ((2) == 1 ⴼⵉⴱⴱⴱⵉⵏ ((n) == ⴼⵉⴱⴱⵉⵏ ((n-1) + ⴼⵉⴱⴱⵉⵏ ((n-2) + ⴼⵉⴱⴱⴱⵉⵏ ((n-3). ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵉⴹⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵜⵔⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴱⵓⴱⵉⴱ ⵙ ⵢⴰⵜ ⵜⵏⴰⴼⵓⵜ ⵉⴼⵓⵍⴽⵉⵏ. >>> ⴼⵉⴱⴱⵉⵏ (((1)) (0) >>> ⴼⵉⴱⴱⵉⵏ (((5)) (4) >>> ⴼⵉⴱⴱⵉⵏ (((8)) (24)
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ vowels_count ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵜ ⵜⴳⵓⵔⵉ ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⴳ ⵓⴽⵛⵛⵓⵎ. ⵉⵎⵓⵙⵙⵓⵜⵏ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ ⴳⴰⵏ 'a', 'e', 'i', 'o', 'u'. ⴷⵖⵉ, 'y' ⵉⴳⴰ ⴰⵡⴷ ⵢⴰⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ, ⵎⴰⵛⴰ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵖ ⵜⴳⵉⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵉⵜⵜⵓⴼⴽⴰⵏ. ⴰⵎⴷⵢⴰ: >>> vowels_count (((""abcde"")) (2) >>> vowels_count (((""ACEDY"")) (3)
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵓⵜⵍ ⴰⵎⵎ ⵜⵙⵓⵜⵍⵜ ⵉⵎⵉⴹⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏ x, ⵙⵙⵓⵜⵍ ⵉⵎⵉⴹⵏ ⵙ ⵓⵥⵍⵎⴰⴹ ⵙ ⵓⵙⵓⵜⵍ ⴷ ⵙⵙⵓⵜⵍ ⵜⴰⵢⴰⴼⵓⵜ ⴰⵎⵎ ⵜⴰⵡⴰⵍⵜ. ⵎⴽ ⵜⵙⵙⵓⵜⵍ > ⵉⵎⴹⴰⵏ ⵏ ⵉⵎⵉⴹⴰⵏ, ⵙⵙⵓⵜⵍ ⵉⵎⵉⴹⴰⵏ ⵙ ⵓⴱⵔⴰⵔⴳ. >>> circular_shift (((12), (1)) (""21"") >>> circular_shift (((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⵙⵔⵙⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵜⵙⵙⴽⵛⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵓⴼⵍⵍⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵏ ASCII. ⵉⵎⴷⵢⴰⵜⵏ: >>> digitSum(("""")) (0) >>> digitSum((""abAB"")) (131) >>> digitSum((""abcCd"")) (67) >>> digitSum((""helloE"")) (69) >>> digitSum((""woArBld"")) (131) >>> digitSum((""aAXaaaa"") (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⵉⵙⵉ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵉⵎⴹⴰⵏ ⵏ ⵜⴱⵔⵔⵜⵜⵉⵏ ⴷ ⵜⴱⵓⵕⵜⵓⵖⴰⵍⵉⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⴳ ⵢⴰⵜ ⵜⴽⵕⴹⴰ ⵏ ⵜⴽⵕⴹⴰ ⴰⴷ ⴳ ⵍⵍⴰⵏⵜ ⵜⴱⵔⵜⵜⵉⵏ ⴷ ⵜⴱⵓⵕⵜⵓⵖⴰⵍⵉⵏ ⴷ ⵜⴽⵕⴹⴰ ⵏ ⵍⵎⴰⵏⴳⵓ. ⴷⴼⴼⵉⵔ ⵏ ⵜⵉⵙⵉ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵉⵎⴹⴰⵏ ⵏ ⵜⴱⵓⵕⵜⵓⵖⴰⵍⵉⵏ ⴷ ⵜⴱⵔⵔⵜⵜⵉⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵉⵎⴹⴰⵏ ⵏ ⵜⴽⵕⴹⴰ ⵏ ⵜⴽⵕⴹⴰ, ⵙⵙⵓⴼⵖ ⴰⵎⴹⴰⵏ ⵏ ⵜⴽⵕⴹⴰ ⵏ ⵍⵎⴰⵏⴳⵓ ⴳ ⵜⴽⵕⴹⴰ. ⵙ ⵓⵎⴷⵢⴰ: >>> fruit_distribution ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ⴰⴽⵓⴷ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴳⵓⵜ ⵏ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⴳⵓⵜⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵜⵔ ⵢⴰⵜ ⵙⴳ ⵜⵓⵏⵏⵓⵜⵉⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵜⵔ. ⵜⴰⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵓⵙⴽⵜⵔ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴳ ⵜⴰⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵢⴰⵏ. ⵎⴽ ⵜⵜⵢⴰⴼⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵢⴰⵏ ⴰⵎⵎ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵢⴰⵏ, ⵙⴽⵜⵔ ⵜⴰⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵢⴰⵏ ⴰⵎⵥⵢⴰⵏ. ⵜⴰⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵓⵙⴽⵜⵔ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⴽⵜⵔ ⴳ ⵓⵡⵉⴽⵜⵓⵔ, [smallest_value, its index], ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵥⵢⴰⵏⵏ ⵏⵖⴷ ⵉⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵓⵙⴽⵜⵔ ⵉⵍⵍⴰ ⵡⴰⵔ, ⵙⴽⵜⵔ []. ⴰⵎⴷⵢⴰⴷ 1: >>> pluck{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵏ ⵡⴰⴽⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⴷⵉⵢⵏ. ⵔⵎⵙⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⴰⴽⴽⵡ ⵏⵏⴰ ⵢⵓⴳⵔⵏ ⵥⵕⵓ, ⴷ ⵏⵏⴰ ⴷⴰⵔ ⵜⴽⵍⵉⵜ ⵏⵏⵙ ⵓⴳⴳⴰⵔ ⵏ ⵏⵖ ⴰⵎⴽⵏ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ. ⵔⵎⵙⵏⵜ -1.
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵙⵎⵉⵍ ⴰⵎⵣⴳⵓⵏⴰⵏ, ⵉⴳⴰ ⴰⵙⵎⵉⵍ ⵍⵍⵉⵖ ⴷⴰ ⵜⵜⴱⴷⵓⴷ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, ⴷⴼⴼⵉⵔ ⴰⴷ ⴷⴰ ⵜⵜⵓⵙⵎⵉⵍⴷⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⴳⵓⵏⵏ ⵢⴰⴹⵏⵉⵏ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, ⴷⴼⴼⵉⵔ ⴰⴷ ⴷⴰ ⵜⵜⵓⵙⵎⵉⵍⴷⵏ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵢⴰⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> strange_sort_list{(((std::vector<long>(({(long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list<((std::vector<(long>{(long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5}))) >>> strange_sort_list<(((std::vector<(long))) (std: vector<(long))
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳⴰⵏ ⵓⵖⵣⵓ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. ⵙⵙⵓⴼⵖ ⵜⴰⵊⵓⵎⵎⴰ ⵏ ⵓⴽⵕⴰⴹ ⵙ 2 ⵏ ⵜⵏⵇⵇⵉⴹⵉⵏ ⵏ ⴷⴰⵔ ⵉⵎⵉⴹⴰⵏⵏ ⵎⴽⵍⵍⵉ ⴳⴰⵏⵜ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ ⵉⵣⴷⵉⵢⵏ. ⵙ ⵡⵉⵢⴰⴹ, ⵙⵙⵓⴼⵖ -1 ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⴷⴰ ⵙⵙⵓⴼⵖⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ ⵉⵣⴷⵉⵢⵏ ⵎⴽⵍⵍⵉ ⵜⴳⴰ ⵜⵓⵎⴰⵏⵜ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵜⴼⵓⵍⵜ ⵜⵉⵙⵙ ⴽⵕⴰⴹⵜ. ⴰⵎⴷⵢⴰ: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽⵍⵍⵉ ⵔⴰⴷ ⵉⵢⵉ ⵜⴱⴰⵢⵉ ⵓⴷⵎ q, ⴷ ⵜⵉⴷⵜ ⵎⴽⵍⵍⵉ ⵔⴰⴷ ⵜⴱⴰⵢⵉ ⵓⴷⵎ q ⵎⴽⵍⵍⵉ ⵉⴳⴰ ⴰⵎⵙⴰⵙⴰ (ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵏⵉⴽ ⵏ ⵓⴱⴰⵍⵉⵏⴷⵔⵓⵎ) ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⵙ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ w. ⴰⵎⴷⵢⴰ: >>> will_it_fly(((std::vector<long>(({long) 1, (long) 2}), (5)) (false) # 1+2 ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ, ⵎⴰⵛ ⵓⵔ ⵉⴳⵉ ⴰⵎⵙⴰⵙⴰ. >>> will_it_fly((((std::vector<long>((({long>3, (long) 2, (long) 3}) (1) (false) # ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ, ⵎⴰⵛ 3+3 ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ, ⵎⴰⵛ ⵓⵔ ⵉⴳⵉ ⴰⵎⵙⴰⵙⴰ. >>> will_it_long> (true) # 3+3 ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⴽⵙⴰⵢ ⴰⵎⵇⵔⴰⵏ, ⵎⴰⵛ ⵓⵔ ⵉⴳⵉ ⴰⵎⵙⴰⵙⴰ.
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴹⴼⴰⵕ ⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵔⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷⵔⵓⵏ ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⴰⴼⴰⴷ ⴰⴷ ⵉⴳ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ. ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵔⵡⴰⵙⵏ ⵙ ⵓⵎⵏⵉⴷ ⴷ ⵙ ⵓⵖⵣⴷⵉⵙ. ⴳ ⵢⴰⵏ ⵓⵙⵏⴼⵍ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴼⵍ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⵙ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⵢⴰⴹⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> smallest_change{(std::vector<long>(({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) (4) >>> smallest_change{((std::vector<long>{(long>{(long)1, (long)2, (long)3, (long)2, (long) (1))))
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵉⵙⵉⴹⵏⵏ ⴷ ⴰⵔ ⵙⴽⴰⵔⵏ ⴰⵎⵓⵙⵙⵓ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⴳ ⴽⵓⵍⵍⵓ ⵉⵙⵉⴹⵏⵏ ⵏ ⵓⵎⵓⵙⵙⵓ ⵏⵏⴰ ⵢⴰⴳⴳⵓⴳⵏ ⵙⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵢⴰⴹⵏⵉⵏ. ⵎⴽ ⴷⴰⵔ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵙⵉⴹⵏⵏ, ⴰⵔ ⵙⴽⴰⵔⵏ ⴰⵎⵓⵙⵙⵓ ⴰⵎⵣⵡⴰⵔⵓ. ⴰⵎⴷⵢⴰ: >>> total_match (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜⴰⵎⵎⴰⴽⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⵏⵏⴰ ⵉⵜⵜⵓⴼⴽⴰⵏ ⴰⵙⴼⵙⵔ ⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵏⵙⵙⵏ ⵎⴰⵙⴷ (ⴰ) ⵉⴳⴰ ⵓⴳⴳⴰⵔ ⵏ 100. ⴰⵎⴷⵢⴰ: >>> is_multiply_prime((30)) (ⵜⴰⵏⵜⵜⵉⵜ) 30 = 2 * 3 * 5
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵔⵔⴰ ⵢⴰⵜ ⵜⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ x ⵜⴰⵣⴷⵓⵖⵜ ⵜⴰⵣⴷⵓⵖⵜ ⵏ n ⴷ ⵜⵉⴷⵜ ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ. x ⵜⴳⴰ ⵜⴰⵣⴷⵓⵖⵜ ⵜⴰⵣⴷⵓⵖⵜ ⵏ n ⵎⴽ n**int=x ⵙ ⵓⵎⴷⵢⴰ: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ a ⴰⵔ ⵉⵜⵜⴰⴽⵣ true ⵎⴽ ⵉⴳⴰ ingeger ⴰⴷ ⴰⵎⴷⵢⴰ ⴰⵎⴷⴷⴰⴷ ⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ. ⵜⴰⵖⴹⴼⵜ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵉⵙ ⵉⴳⴰ ⵡⴰⵏⵙⴰ ⵏ ⵓⵙⴽⵛⵎ ⴰⵀⴰ ⵉⴳⴰ ⵡⵉⵏ ⵜⵣⵎⵔⵜ. ⵉⵎⴷⵢⴰⵜⵏ: >>> iscube((1)) (true) >>> iscube((2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube((0)) (true) >>> iscube((180)) (false)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⴰⵔⵉⵜ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍ ⴰⵎⵎ ⵜⴰⵔⵔⴰⵢⵜ ⴷ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍ ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ (ⵉⴹ ⴰⵎⵣⵡⴰⵔⵓ, ⵏⵖ ⴰⵎⵣⵡⴰⵔⵓ, ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵙⴳ 1 ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⴰⵙⵢⴰⴼⵓ ⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵉⵎⵥⵥⵉⵏ). ⵡⵓⵟⵟⵓⵏⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍ ⴳⴰⵏ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳⴰⵏ 2, 3, 5, 7, 11, 13, 17,... ⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵙⵙⵏⵎⴹⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴰⴷ: 2, 3, 5, 7, B (= ⴰⵀⵉⵊⴰⴷ 11), D (= ⴰⵀⵉⵊⴰⴷ 13). ⵜⵣⵎⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴹ ⵎⴰⵙ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵀⵉⵊⴰⴷⵉⵛⵎⴰⵍ ⴰⵣⵔⴼⴰⵏ ⵏⵖ ⵓⵍⴰⵡⴰⵏ, ⴷ ⵉⵙⵎⵎⴰⵍⵏ A,B,C,D,E,F,E,ⵀⴰ ⴰⵀⴰ ⴰⵀⴰ ⴰⵀⴰ ⴳⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ.
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵜⵓⵙⴷⵉⴷⵜ ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵜⵓⵙⴷⵉⴷⵜ. ⵔⴰⴷ ⵜⵕⵓⵃ ⵜⴰⵡⵓⵔⵉ ⵢⴰⵜ ⵜⵉⴼⵔⵜ, ⴷ ⴽⵓ ⵉⵙⴽⴽⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵓⵙⴷⵉⴷⵜ. ⴽⵓ ⵉⵙⴽⴽⵉⵍ ⴳ ⵜⵉⴼⵔⵜ ⵔⴰⴷ ⵉⴳ '0' ⵏⵖ '1'. ⵔⴰⴷ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵢⴰⴹⵏⵉⵏ 'db' ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ ⵏ ⵜⵉⴼⵔⵜ. ⵉⵙⴽⴽⵉⵍⵏ ⵢⴰⴹⵏⵉⵏ ⵔⴰⴷ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵙ ⵜⴰⵍⵖⴰ. ⵉⵎⴷⵢⴰⵜⵏ: >>> decimal_to_binary((15)) (""db1111db"") >>> decimal_to_binary(32) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ s. ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕ ⵉⵙ ⵉⴳⴰ ⵓⵡⵉⴽⵉ ⴰⴷ hapcpp ⵏⵖ ⵓⵔ ⵉⴳⵉ. ⵉⴳⴰ ⵓⵡⵉⴽⵉ ⴰⴷ hapcpp ⵉⵖ ⴷⴰⵔⵙ 3 ⵏ ⵜⵉⵔⵔⴰ ⴷ ⴽⵓ 3 ⵏ ⵡⵓⴽⴽⵓⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵙ ⵓⵎⴷⵢⴰ: >>> is_happy((""a"")) (false) >>> is_happy((""aa"")) (false) >>> is_happy((""abcd"")) (true) >>> is_happy((""aabb"")) (false) >>> is_happy(""adb"")) (true) >>> is_happy((""xyy"") (false)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳⴰ ⵡⴰⵢⵢⵓⵔ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵓⴽⵓⴷ ⵏ ⵜⵓⵙⵎⵉⵍⵜ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴼⴽ ⵓⵙⵍⵎⴰⴷ/ⵜⴰⵙⵍⵎⴰⴷⵜ ⵉ ⵉⵏⵍⵎⴰⴷⵏ ⴷ ⵜⵏⵍⵎⴰⴷⵉⵏ ⴰⵙⵡⵉⵔ ⵏⵏⵙⵏ. ⵉⵙⴽⵔ ⵓⵙⵍⵎⴰⴷ/ⵜⴰⵙⵍⵎⴰⴷⵜ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵏⵏⵙ ⵏ ⵓⵙⵡⵉⵔ. ⴰⵙⵡⵉⵔ ⵏ ⵓⵙⵡⵉⵔ ⵏ ⵓⵙⵍⵎⴰⴷ/ⵜⴰⵙⵍⵎⴰⴷⵜ ⵓⵔ ⵢⴰⴷ ⵉⵍⵍⵉ. ⵜⵙⴽⵔ ⴰⵙⵡⵉⵔ ⵏ ⵓⵙⵡⵉⵔ ⵏ ⵓⵙⵡⵉⵔ ⵏ ⴽⵔⴰ ⵏ ⵉⵏⵍⵎⴰⴷⵏ ⴷ ⵜⵏⵍⵎⴰⴷⵉⵏ, ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵔⴰⵎ ⵢⴰⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵥⴹⴰⵕⵏ ⴰⴷ ⵉⴼⴽ ⴰⵙⵡⵉⵔ ⵏ ⵓⵙⵡⵉⵔ ⵏ ⵜⵉⵔⵔⴰ ⵙ ⵓⵙⵎⵔⵙ ⵏ ⵜⴽⴰⴷⵉ ⵢⴰⴷ: GPA.
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⵡⵍ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵓⵖⵉⵍⵓⴼ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵖⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵎⴷⵢⴰ: >>> prime_length(((""Hello"")) (true) >>> prime_length(((""abcdcba"")) (true) >>> prime_length((""kittens"")) (true) >>> prime_length((""orange"")) (false)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⴽⵔ ⴰⵙⵉⴹⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵉⴳⵏ ⵏ n ⵡⵓⵟⵟⵓⵏ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵏⵖⴷ ⵉⵜⵜⵎⵜⵉⵏ ⵙ 1.
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ N, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⵙ ⵜⴱⵉⵏⴰⵔⵉⵜ. ⴰⵎⴷⵢⴰ >>> solve((1000)) (""1"") >>> solve((150)) (""110"") >>> solve((147)) (""1100"") ⵉⵎⵙⵏⴼⴰⵍⵏ: @N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ: 0 ≤ N ≤ 10000. ⴰⵙⵓⴼⵖ: ⵜⴰⵔⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵏⴹⴰⵏ
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵏ ⵡⴰⴽⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⵏⴼⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⴳⴰⵏⵉⵏ ⴳ ⵉⵙⵓⴹⴰⴼ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵏⴰⴹ ⴷ ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ. ⵜⴰⵡⵉⴽⵉ ⴰⵏⵎⵏⴰⴹ ⵏ ⵓⵡⵉⴽⵉ, ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴳ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ (ⵜⵓⵙⴱⴹⴰⵏⵜ ⵙ ⵓⵙⴰⵢⵔⴰⵔ) ⵙ ⵢⴰⵜ ⵜⴳⵓⵔⵉ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴳ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ ⵅⴼ ⵡⴰⵜⵉⴳ ⵏ ascii. ⵜⴰⵖⴹⴼⵜ: ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵃⴹⵓ ⵜⴰⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⵉⵙⴰⵢⵔⴰⵔⵏ ⴳ ⵜⴳⵓⵔⵉ. ⵙ ⵓⵎⴷⵢⴰ: >>> anti_shuffle((""Hi"")) (""Hi"") >>> anti_shuffle((""hello"")) (""ehllo"") >>> anti_shuffle""((Hello World!!)) (""Hello !!!Wdlor"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⵏⵖⵎⵉⵙⵏ ⵏ ⵙⵉⵏ ⵡⵓⴳⴳⵓⴳⵏ, ⵙ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵉⵜⵜⵓⵙⵎⴳⴰⵍⵏ, ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⴷⵏ ⵙ ⵜⵎⵜⵜⵉ, ⵎⴰⵛⴰ, ⵓⵔ ⵉⵎⴽⵉⵏ ⵉⵎⵜⵜⵉⵢⵏ, ⴽⵓ ⵜⴰⵡⵔⵉⵔⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⵟⵟⴰⴼ ⴰⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⴷⴰⵜ lst, ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ x, ⵥⵕ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ x ⴳ ⵓⵎⵓⵙⵙⵓ, ⴷ ⵜⵔⴰⵔⵓⵜ ⵏ ⵓⵎⵓⵙⵙⵓ ⵏ ⵜⵔⵙⴰⵍ, [(x1, y1), (x2, y2) ...] ⵣⵓⵏⴷ ⵎⴰⵙ ⴽⵓ ⵜⴰⴱⵍⵜ ⵜⴳⴰ ⵢⴰⵜ ⵜⵎⵏⴷⴰⵡⵜ - (ⵜⴰⵙⵉⴹ, ⵜⵔⵙⴰⵍ), ⵜⴱⴷⴰ ⵙ 0. ⵙⵙⵓⴷⵙ ⵜⵉⵙⵖⵏⵉⵏ ⴳ ⵓⵎⵏⵉⴷ ⴰⵎⵣⵡⴰⵔⵓ ⵙ ⵜⵔⵙⴰⵍ ⴳ ⵓⵏⵎⴰⵍⴰ ⵏ ⵓⴽⵛⵛⵓⵎ. ⴰⵡⴷ, ⵙⵙⵓⴷⵙ ⵜⵉⵙⵖⵏⵉⵏ ⵏ ⵜⵔⵙⴰⵍ ⴳ ⵓⵏⵎⴰⵍⴰ ⵏ ⵓⴽⵛⵛⵓⵎ. ⵉⵎⴷⵢⴰⵡⵏ: >>> get_row(std::vector<std::vector<st:d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⴳⵓⵜⵏ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵙⵎⵉⵍ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵙⴰⵙⴰ, ⵔⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⵍⴽⴰⵎ ⵉⵖ ⵉⴳⴰ ⵓⵖⵔⵓⵎ (((ⵜⵉⴳⵜ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ ⵏ ⵓⵡⵉⴽⵜⵓⵔ, ⵜⴰⴳⵜⵉⴳⵜ ⵜⴰⵎⴳⴳⴰⵔⵓⵜ ⵏ ⵓⵡⵉⴽⵜⵓⵔ) ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ, ⵏⵖⴷ ⵙ ⵓⵍⴽⴰⵎ ⵉⵖ ⵉⴳⴰ ⵓⵖⵔⵓⵎ (((ⵜⵉⴳⵜ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ ⵏ ⵓⵡⵉⴽⵜⵓⵔ, ⵜⴰⴳⵜⵉⴳⵜ ⵜⴰⵎⴳⴳⴰⵔⵓⵜ ⵏ ⵓⵡⵉⴽⵜⵓⵔ) ⵜⴰⴳⵜⵉⴳⵜ. ⵜⴰⵖⴹⴼⵜ: * ⵓⵔ ⵜⵙⵙⵓⴷⵙⴷ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴽ. ⴰⵎⴷⵢⴰ: >>> sort_array((std::vector<long>(())) (std::vector<long>) >>> sort_array((std::vector<long>{(long>{long} (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long)
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ encrypt ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⴰⵎⵎ ⵓⵎⵏⵣⴰⵖ ⴷ ⴰⵔ ⵉⵜⵜⵔ ⵢⴰⵜ ⵜⴽⵙⵉⵍⵜ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵙ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵙ ⵓⵙⵙⵓⵜⵍ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⵜⵜⵓⵣⵎⵎⴻⵎ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵙⵙⵓⵜⵍⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵙⵏⴰⵜ ⵙ ⵙⵏⴰⵜ. ⵙ ⵓⵎⴷⵢⴰ: >>> encrypt((""hi"")) (""lm"") >>> encrypt((""asdfghjkl"")) (""ewhjklnop"") >>> encrypt((""gf"")) (""kj"") >>> encrypt((""et"")) (""ix"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵢⴰⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ next_smallest ((() ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵙⴽⴽⵉⵍ ⵡⵉⵙⵙ ⵙⵉⵏ ⴳ ⵉⵎⴹⴰⵏⵏ. ⵔⴰⴷ ⵏⵔⴰⵔ None ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵓⵙⴽⴽⵉⵍ ⴰⴷ. >>> next_smallest (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest (((std::vector<long>({long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest (((std::vector<long>())) std::nullopt >>> next_smallest (((std::vector<long>{(long) 1, (long) 1))) std::nullopt
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⵍⴳⴰⵎⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⵉⵎⵉⴹⵏ ⵏ ⵜⵔⴳⴰⵍⵉⵏ. ⵜⴰⵔⴳⴰⵍⵜ ⵜⴳⴰ ⵢⴰⵜ ⵜⴳⵓⵔⵉ ⵏⵏⴰ ⵢⴱⴷⴰⵏ ⵙ ⵜⴳⵓⵔⵉ ""ⵉ"". ⴷⴰ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏⵜ ⵜⵉⴳⵓⵔⵉⵡⵉⵏ ⵙ '.', '?' ⵏⵖ '!'. ⵙ ⵓⵎⴷⵢⴰ: >>> is_bored((""Hello world"")) (0) >>> is_bored((""ⵙⵖⵏ ⵉⴳⵏⵡⴰⵏ. ⵜⴰⴼⵓⴽⵜ ⵜⵔⵥⵥⵥⵉ. ⵔⵉⵖ ⵓⵏⵣⵡⵉ ⴰⴷ"")) (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ. ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⵉ ⵉⴳⴰ ⵢⴰⵏ ⵙⴳ ⵡⵓⵟⵟⵓⵏⵏ ⴰⵎⵎ ⵓⵖⵣⵓⵔ ⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵢⴰⴹⵏⵉⵏ, ⴷ ⵡⵓⵟⵟⵓⵏⵏ ⴰⴽⴽⵡ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⴷⴰ ⵢⴰⴽⴽⴰ ⵜⵉⴷⵜ ⴳ ⴽⵔⴰ ⵏ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ. ⵉⵎⴷⵢⴰⵜⵏ >>> ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ({int}{{{float}{5)), ({float}{2}), ({float}{7}) (ⵜⴰⴷⵜ) >>> ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ({int}{float}{3}), ({float}{2}), ({float}{2}))) (ⵜⴰⴷⵜ) >>> ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ({int}{float}{3}), ({float}{2})), ({float}{2}) ({float}{2}) (false))
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⴰⵔ ⵜⵙⵙⵓⴷⵙ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵉⵙⵏⴼⵍⵏ ⵜⵉⴽⴽⵍⵜ ⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵔⵔⴰ, ⴰⵔ ⵉⵙⵎⵓⵜⵜⴳ ⴽⵓⵍⵍⵓ ⵉⵎⵙⵍⵉ ⴳ ⵜⴱⵔⴰⵜ ⵙ ⵜⵉⵔⵔⴰ ⵏⵏⴰ ⵢⴰⴷ ⵉⵍⵍⴰⵏ ⵙ 2 ⵏ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵓⵎⵙⵍⵉ ⴳ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⴼⵉⵏⴰⵖ. ⵙⵙⵓⵎⵔ ⴷⴰⵢ ⵜⵉⵔⵔⴰ. ⵉⵎⴷⵢⴰⵜⵏ: >>> encode((""test"")) (""TGST"") >>> encode((""This is a message"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⴷⴰ ⵜⵜⴰⴼⴰ ⵡⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⴷ ⴷⴰ ⵜⵜⴰⴽⵛⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏⵏⵙ. ⴰⵎⴷⵢⴰ: >>> skjkasdkd{(std::vector<long>(({(long) 0, (long) 3, (long) 2, (long) 1, (long) 1, (long) 3, (long) 5, (long) 7, (long) 4, (long) 5, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) 3, (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⵜⵍⵍⴰ ⵜⴽⴰⵕⴹⴰ, ⵔⵉⵜⵔⵏ true ⵎⴽ ⵜⴳⴰ ⴽⵓⵍⵍⵓ ⵜⵉⵙⵍⵉⵜⵉⵏ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⴳ ⵜⵉⵔⵔⴰ ⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵏⵖ ⴽⵓⵍⵍⵓ ⵜⵉⵙⵍⵉⵜⵉⵏ ⴳ ⵜⵉⵔⵔⴰ ⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ, ⵔⵉⵜⵔⵏ false. ⵜⴰⵡⵓⵔⵉ ⵔⴰⴷ ⵜⵔⵉⵜⵔⵏ false ⵉⴳ ⵜⴽⴰⵕⴹⴰ ⵜⵓⵎⵥⵜ ⵜⴳⴰ ⵜⵍⵍⵉⵜ. ⴰⵎⴷⵢⴰ: >>> check_dict_case,{((std::map<std::string,std::string>,{""a"", ""apple""}, {""b"", ""banana""}}))) (true) >>> check_dict_case,{(((std::string,{""a"", ""apple""}, {""a"", ""banana""}, {""a"", ""Z"") >>> check_dict_case,{""a"", ""apple""}, {""a"", ""apple""}, {""a"", ""apple""}:{""a"", ""apple""}:<std::string,{""a"", ""apple""}: {""a"", ""apple""}: {""a"", ""apple""}:std:std:string, {""a"", ""apple""a"", ""apple""}: ""{""a"", ""apple""a"", ""apple""std"": ""std"": ""std"": ""std"": ""std"": ""std"": ""std"": ""std"": ""std"": ""std"": ""std"": ""st:string"", ""st: ""st: ""st: ""st: ""st: ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"": ""st"":
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⵔⵉⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵉⵎⵥⵥⵉⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> count_up_to((5)) (std::vector<long>(({long) 2, (long) 3})) >>> count_up_to((11) (std::vector<long>(({long) 2, (long) 3, (long) 5, (long) 7)) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{((2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 13, (long) 17, (long) 19)) >>> count_up_1) (std::vector<long> >>> count_up_to(18) (std:vector<long>(3, (long)) 11, (long) 5, (long) 17)) (std (long) 1
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵎⵓⵜⵜⵉⴷ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏⵏⵙⵏ. ⵏⵙⵙⵏ ⵉⵙ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴷ ⴰⵀⴰ ⵉⴳⴰ ⵡⵉⵏⵙ. ⵉⵎⴷⵢⴰⵜⵏ: >>> ⵙⵙⵓⴷⴷⵓⵏ (((148), (412)) (16) >>> ⵙⵙⵓⴷⴷⵓⵏ (((19), (28)) (72) >>> ⵙⵙⵓⴷⴷⵓⵏ (((2020), (1851)) (0) >>> ⵙⵙⵓⴷⴷⵓⵏ (((14), (-15)) (20)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙ ⵓⵎⴷⵢⴰ: >>> count_upper (((""aBCdEf"")) (1) >>> count_upper (((""abcdefg"")) (0) >>> count_upper (((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵡⴰⵜⵉⴳ (ⵜⴰⵏⴳⴰⵍⵜ) ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵏⵏⴰ ⵢⴰⴷ ⵉⴳⴳⵓⴳⵏ. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴷ ⴰⵎⵣⴰⵔⴰⵢ ⴰⴽⴷ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵓⵏ ⴰⵙ ⵙⴳ ⵓⵎⵢⴰ. ⴰⵎⴷⵢⴰ >>> closest_integer((""10"")) (10) >>> closest_integer((""15.3"")) Note (15): ⴰⵙⵎⵓⵜⵜⴳ ⵙⴳ ⵓⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴰⴽⴷ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵎⴹⴰⵏ ⴰⴷ ⵉⴳⴰⵏ ⵡⴰⵏⵏⴰ ⵢⴰⴷ ⵉⴳⴳⵓⴳⵏ ⵙⴳ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ. ⵙ ⵓⵎⴷⵢⴰ closest_integer (((""14.5"") ⴰⴷ ⵉⴽⴽⴰ 15 ⴷ closest_integer ((-14.5"") ⴰⴷ ⵉⴽⴽⴰ -15.
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⵙⴽⵔⴷ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵏ n ⵉⵙⵡⵉⵔⵏ ⵏ ⵉⵔⴱⴰⵏ. ⴰⵙⵡⵉⵔ ⴰⵎⵣⵡⴰⵔⵓ ⴷⴰⵔⵙ n ⵉⵔⴱⴰⵏ. ⴰⵎⴹⴰⵏ ⵏ ⵉⵔⴱⴰⵏ ⴳ ⵓⵙⵡⵉⵔ ⴰⴹⵏⵉⵏ ⵉⴳⴰ: - ⴰⵎⴹⴰⵏ ⴰⵎⴳⴳⴰⵔⵓ ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ ⵉⵖ ⵉⴳⴰ n ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ. - ⴰⵎⴹⴰⵏ ⴰⵎⴳⴳⴰⵔⵓ ⵉⵎⵢⴰⵏⴰⵡⵏ ⵉⵖ ⵉⴳⴰ n ⵉⵎⵢⴰⵏⴰⵡⵏ. ⵙⴽⵔⴷ ⴰⵎⴹⴰⵏ ⵏ ⵉⵔⴱⴰⵏ ⴳ ⴽⵓ ⴰⵙⵡⵉⵔ ⴳ ⵢⴰⵏ ⵓⴽⵜⵓⵔ, ⴳ ⵉⵍⵍⴰ ⵉⴼⵔⴷⵉⵙ ⴳ ⵓⵙⵏⵎⵍ i ⵉⵙⵎⴷⵢⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵔⴱⴰⵏ ⴳ ⵓⵙⵡⵉⵔ (ⵉ+1). ⴰⵎⴷⵢⴰ: >>> make_a_pile(3) (std::vector<long>{long) 3, (long) 5, (long) 7}))
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵢⵙⴱⴹⵏ ⵙ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵖ ⴷ ⵉⵙⴰⵢⵔⴰⵔ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴱⴹ ⵜⴰⵡⵓⵔⵉ ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> words_string ((((""Hi, my name is John"")) (ⵜⴰⵎⵙⵉⵔⴷⵜ:ⵜⴰⵎⵙⵉⵔⴷⵜ<std::string>({(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⴷⴰ ⵜⴻⵜⵜⵓⵎ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⴽⵙⵡⴰⵜⵏ x ⴷ y ⴰⵔ ⵜⵙⵙⴽⵛⵎ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵇⵇⵔⴰⵏ ⴳ ⵓⵙⵏⴼⴰⵔ [x, y] ⴳ ⵓⵎⵏⵉⴷ. ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⵓⵟⵟⵓⵏ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵛⵎ -1. ⵙ ⵓⵎⴷⵢⴰ: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵙⵡⴰⵜⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ n ⴷ m, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⴹⵏ ⴰⵎⵎⴰⵙ ⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙⴳ n ⴰⵔ m (ⵙ ⵓⵙⵙⴽⵛⵎ ⵏ n ⴷ m). ⵙⵙⵓⴷⵓⵏ ⵜⴰⵔⴰⵔⵓⵜ ⵙ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⴽⴽⵡ ⵢⵓⵛⴽⴰⵏ ⴷ ⵙⵙⴼⵍⴷⵏ ⴳ ⵓⵎⴹⴰⵏ ⴰⵎⵉⵏⵉ. ⵎⴽ n ⵢⵓⴳⵔ m, ⵙⵙⵓⴷⵓⵏ -1. ⴰⵎⴷⵢⴰ: >>> rounded_avg((1), (5)) ""0b11"" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) ""0b1111"" >>> rounded_avg(20), (33) ""0b11010""
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵥⵉⵢⵏ x, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵓⵥⵏ. ⵜⴰⵖⴹⴼⵜ: ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵓⴼⵖ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵎ: >>> unique_digits((std::vector<long>({(long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{(long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{(long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙ ⵓⵎⴷⵢⴰ: >>> by_length{""ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ""}, (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) 1,2,3,4,5,8,3, (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ)) (ⵜⴰⵎⵉⴹⵉⴹⵜ ⵜⴰⵎⵇⵇⵔⴰⵏⵜ) (ⵜⴰⵎⵉⴹⵉⴹⵜ ⵜⴰⵎⵉⴹⵜ ⵜⴰⵎⵉⴹⵜⵉⵎⵇⵇⵔⴰⵏⵜ) (ⵜⵉⵎⵉⴹⵉⴹⵜ ⵜⴰⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹⵜ) (ⵜⵉⵎⵉⴹ) (ⵜⵉⵎⵉⴹⵜⵉⵎⵉⴹ) (ⵜ (ⵜⵉⵎⵉⴹ) (ⵜⵉⵎⵉⴹ) (ⵜ (ⵜⵉⵎⵉⴹ) (ⵜⵉⵎⵉⴹ) (ⵜ (ⵜⵉⵎⵉⴹ) (ⵜⵉⵎⵉⴹ) (ⵜ (ⵜⵉⵎⵉⴹ) (ⵜ (ⵜ) (ⵜⵉⵎⵉⴹ) (ⵜ (ⵜⵉⵎⵉⴹ) (ⵜ) (ⵜ) (ⵜ (ⵜ) (ⵜ (ⵜ) (ⵜ) (ⵜ (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ) (ⵜ
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵎⵔⵙ ⵜⴰⵡⵓⵔⵉ f ⵏⵏⴰ ⵢⵓⵎⵥⵏ n ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ, ⴰⵔ ⵉⵙⴽⴰⵔ ⵢⴰⵏ ⵓⴱⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ n, ⵣⵓⵏⴷ ⴰⵜⵉⴳ ⵏ ⵓⵏⴰⵡ ⵏ ⵓⵏⴰⵡ i ⵉⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ i ⵎⴽ ⵜⴳⴰ i ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵉⵎⴹⴰⵏⵏ ⵙⴳ 1 ⴰⵔ i ⵎⴽ ⵓⵔ ⵜⴳⵉ. i ⴰⵔ ⵉⵜⵜⴱⴷⵓ ⵙⴳ 1. ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵉⵎⴹⴰⵏⵏ ⵏ i ⵜⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵉⵎⴹⴰⵏⵏ ⵙⴳ 1 ⴰⵔ i (1 * 2 * ... * i). ⴰⵎⴷⵢⴰ: >>> f((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵙⵙⵓⴼⵖ ⵜⴰⴱⵍⵜ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵓⵙⵏⴼⵍⵓⵍ ((1, n), ⵙⵍⴰⵡⴰⵏ ⴰⴽⴽⵡ. ⴰⵎⴷⵢⴰ 1: >>> even_odd_palindrome (((3)) (std::make_tuple ((1, 2)) ⴰⵙⴼⵔⵓ: ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⴰⵏ 1, 2, 3. ⵢⴰⵏ ⴳⵉⵙⵏ ⵉⴳⴰ ⴰⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⵙⵉⵏ ⴳⵉⵙⵏ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⴰⵎⴷⵢⴰ 2: >>> even_odd_palindrome (((12)) (std::make_tuple ((4, 6)) ⴰⵙⴼⵔⵓ: ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⴰⵏ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ⴽⴽⵓⵥ ⴳⵉⵙⵏ ⴳⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ 6 ⴳⵉⵙⵏ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵜⴰⵖⴹⴼⵜ: 1 <= n= 10^3 < 3 2.
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ count_nums ⵏⵏⴰ ⵢⵓⵎⴰⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⵖⵍ ⵏ ⵡⵓⵟⵟⵓⵏ > 0. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵔⵏⴰⵢ, ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⵔⵏⴰⵢ: ⵙ ⵓⵎⴷⵢⴰ -123 ⵖⵓⵔⵙ ⵡⵓⵟⵟⵓⵏⵏ -1,2, ⴷ 3. >>> count_nums{((std::vector<long>())) (0) >>> count_nums{(std::vector<long>{(long)-1, (long)11, (long)-11}))) (1) >>> count_nums::(std::vector<long>{(long)1, (long)1, (long)2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵏⵍⵍⴰ ⴷⴰⵔⴽ ⵢⴰⵏ ⵓⴽⵜⵓⵔ 'ⴰⵔⵔ' ⵏ N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr[1], arr[2], ..., arr[N].ⴰⴷ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ ⵉⵎⴹⴰⵏⵏ ⴳ ⵓⴽⵜⵓⵔ ⵙ ⵓⵙⵖⵓⴷⵓ ⴰⴱⵔⵙⴳⴳⵡⴰⴷ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴰⵢⴷ ⵉⴳⴰⵏ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⵎⵉⵍ ⵏ ⵓⴽⵜⵓⵔ ⵙ ⵓⴱⵔⵉⴷ ⵓⵔ ⵉⵜⵜⵓⵣⴷⵉⵢⵏ ⵙ ⵓⵙⴽⴰⵔ ⵏ ⵜⵎⵀⵍⵜ ⴰⴷ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⴽⵔⴷ ⵜⵉⵙⴽⵔⵜ ⵏ ⵓⵙⵎⵉⵍ ⵙ ⵓⵣⵔⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ. ⵢⴰⵜ ⵜⵎⵀⵍⵜ ⵏ ⵓⵙⵎⵉⵍ ⵙ ⵓⵣⵔⴼ ⵜⵔⵏⴰ ⴰⴷ ⵜⵙⵙⴽⵔⴷ ⴽⵓⵍⵍⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⴽⵜⵓⵔ ⵙ ⵢⴰⵜ ⵜⴷⵖⵉ ⴳ ⵓⴽⵜⵓⵔ ⵙ ⵓⴱⵔⵉⴷ ⵓⵣⵔⴼ. ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⴽⵜⵓⵔ ⴰⵎⴳⴳⴰⵔⵓ ⵔⴰⴷ ⵜⵜⵓⵙⴽⵔⵏ ⵙ ⵓⴷⵖⴰⵔ ⵏ ⵓⵙⵎⵉⵍ ⴳ ⵓⴽⵜⵓⵔ ⵙ ⵓⴱⵔⵉⴷ ⵙ ⵓⵣⵔⴼ, ⵉⴳⴰⵏ 0th ⴰⵏⵎⵉⵍ. ⵎⴽⵓⴷ ⵉⵖ ⵜⵣⵎⵔⴷ ⴰⴷ ⵏ ⵓⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ ⵙ ⵓⵙⴽⵜⵓⵔ ⵏ ⵜⵎⵀⵍⵜ ⵏⵏⴽⵜ ⴷⴰⵜ. ⵎⴽⵜⵓⵔ ⵏ ⵓⴽⵜⵓⵔ ⴰⴷ ⵓⵔ ⵉⵜⵜⵓⵣⴷⵉⵍⵉ. ⴰⵎⴷ ⵓⵎⴷⵢⴰ: >>>plan_one_ⵜⵓⵔ_ⵜⵓⵔ_ⵜⵓⵔ_ⵜⵓⵔ_ⵜⵓⵔ_ⵜⴰⵔⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰⴳ_ⴰ
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵢⵓⵎⴰⵏ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ, ⴷ ⴰⵔ ⵉⵜⵜⵉⵔⵉ ⴰⴷ ⵉⵙⴽⵔ ⵓⵎⵙⴼⵍⴷ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔⵙⵏ ⴰⴼⴰⴷ ⴰⴷ ⵉⴳ lst1 ⵢⴰⵏ ⵓⵎⵓⵙⵙⵓ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵎⵓⵇⵇⴰⵔⵏ. ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⴽⵜⵜⴰⵢ ⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴳⵔ lst1 ⴷ lst2. ⵎⴽ ⵉⴳⴰ ⵜ ⵜⵣⵎⵔ ⴰⴷ ⵉⵙⵏⴼⵍ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔ lst1 ⴷ lst2 ⴰⴼⴰⴷ ⴰⴷ ⴳⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ lst1 ⵉⵎⵎⵓⵇⵇⴰⵔⵏ, ⵙⵙⵓⴼⵖ ""YES"". ⵎⴽ ⵓⵔ ⵉⴳ ⵜⵣⵎⵔⴷ, ⵙⵙⵓⴼⵖ ""NO"". ⵙ ⵓⵎⴷⵢⴰ: >>> exchange((std::vector<>({long) 1, (long) 2, (long) 3, (long) 4}), (std::vector<>(long) 3, (long) 4} (""YES"") >>>(((std::vector<>{(long>{1, (long) 2, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long (long) (long) (long) (long) (long) (long) (long) (long) (long) (long (long) (long (long) (long) (long) (long) (long) (long (long) (long
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵢⴰⵜ ⵜⵉⴼⵔⵜ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵜⵉⵥⵥⵉⵏ ⵉⵜⵜⵓⵢⴼⴼⴰⵖⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ, ⵙⵙⵓⴼⵖ ⵢⴰⵜ ⵜⴰⴽⴰⵕⴹⴰ ⵏ ⵜⵉⵔⵔⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵓⴳⵜⵜ ⵏ ⵜⵉⴽⴽⴰⵍ ⴷ ⵉⵍⵍⴰ ⴳⵉⵙ ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ. ⵎⴽ ⴷⴰⵔⴽ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⵔⵔⴰ, ⵙⵙⵓⴼⵖ ⴰⴽⴽⵡ ⵏⵏⵙⵏⵜ. ⴰⵎⴷⵢⴰ: >>> histogram{""a"", 1}, {""b"", 1}, {""c"", 1}}) >>> histogram{""a"", 2}, {""b"", 2}})) >>> histogram{""a, b, c, b"")) (std::map{""a, b, b"", 2}) >>> histogram{""a, b, b"", b, b"") >>> (std::map{""a, b"", 2}, {""b"", 2}} >>> (std:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⵏⵜⵜⴰ ⴷⴰⵔⵙ ⵙⵉⵏ ⵉⵙⴽⴽⵉⵍⵏ s ⴷ c, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ s ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ ⴷ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ c, ⴷ ⵔⴰⴷ ⵜⵥⵕⵎ ⵉⵙ ⵉⴳⴰ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵢⴰⴼⵓⵜ ⵢⴰⵏ ⵓⴷⵎ ⵏ ⵓⵎⵙⴰⵙⴰ. ⴰⵙⴽⴽⵉⵍ ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵙ ⵓⴷⵎ ⵏ ⵓⵎⵙⴰⵙⴰ ⵉⵖ ⵉⴳⴰ ⵓⴷⵎ ⵏ ⵓⵎⵙⴰⵙⴰ ⵙ ⵓⵎⵙⴰⵙⴰ ⵙ ⵓⵎⵏⵉⴷ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔⵎ ⵢⴰⵏ ⵓⴷⵎ ⵏ ⵓⵎⵙⴰⵙⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵢⴰⴼⵓⵜ ⴷ true/false ⵉ ⵓⵣⵣⵔⴰⵢ. ⴰⵎⴷⵢⴰ >>> reverse_delete{""abcde""), (""ae"")) (std::make_tuple{""bcd"", false)) >>> reverse_delete{""abcdef"", (""b"") (std::make_tuple{""acdef"", false)) >>> reverse_delete{""abcdef"", false"") >>> reverse{""abcdelete{""abcdef"", false"")
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴽⵓ ⵢⴰⵏ ⵙⴳ ⵉⴼⵔⴷⵉⵙⵏ i ⵏ ⵜⵏⴰⴼⵓⵜ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴳ ""ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴳ ⵜⵏⴰⴼⵓⵜ i ⵏ ⵓⵙⴽⵛⵎ"". ⴳ ⵎⴰⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ i ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⴰⵍ ⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴳ ⵜⵏⴰⴼⵓⵜ i. >>> odd_count((std::vector<std::string>(({std::string) ""1234567""}))) (std::vector<std::string>({stdstring)::""ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ 4n ⵏ str4ng 4 ⵏ 4n.put""})) >>> odd_count(stdvector<stdstring>::{(stdstring)::"",""3 (stdstring)::1111""11""))) (stdvector<stdstring::n>: 1st: 1st: 1n)::""ⵉⴹ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ 1 ⵏ str4ng 8"" (string) 8"" (string)
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⵎⴷⵢⴰ ⵏ ⵓⵎⵙⴽⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴰⴷ ⵏⴰⴼ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⵡⴰⵏ. ⴰⵎⴷⵢⴰ >>> minSubArraySum((((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) (1) >>> minSubArraySum((std::vector<long>{(long)-1, (long)-2, (long)-3}))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵢⴰⵏ ⵓⴽⵡⴰⵍ ⵏ ⵉⵙⴳⴳⵡⵔⵏ. ⴽⵓ ⵜⴰⵡⵔⵉⵔⵜ ⴷⴰ ⵜⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⴽⵡⴰⵍ, ⴷ ⴽⵓ 1 ⴳ ⵜⴰⵡⵔⵉⵔⵜ ⴷⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵜ ⵜⴰⵢⵎⵓⵏⵜ ⵏ ⵡⴰⵎⴰⵏ. ⴽⵓ ⵓⴽⵡⴰⵍ ⵖⵓⵔⵙ ⵢⴰⵏ ⵍⴱⵓⵅⵜ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⵏⵏⴰ ⵉⵖⵉⵢ ⴰⴷ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⴳ ⵓⵙⵙⴰⵢ ⵏ ⵡⴰⵎⴰⵏ ⵙⴳ ⴷⵉⴳⵙ, ⴷ ⴽⵓ ⵍⴱⵓⵅⵜ ⵖⵓⵔⵙ ⵢⴰⵜ ⵜⵣⵎⵔⵜ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵎⵔⵙⴷ ⵉ ⵍⴱⵓⵅⵜⵏ ⴰⴷ ⵃⵎⵎⵍⵏ ⵉⵙⴳⴳⵡⵔⵏ. ⵜⵕⵥⵎ ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵅⵚⵚⴰⵏ ⴰⴷ ⵜⵣⴷⵉⴷ ⵉ ⵍⴱⵓⵅⵜⵏ. ⴰⵎⴷⵢⴰ 1: >>> max_fill((long_long:st:{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}}{long}{long}}{long}{long}}{long}{long}}{long}}{long}{long}}{long}{long}}{long}{long}}{long}}{long}}{long}}{long}{long}}}{long}{long}{long}{long}}}{long}}}{long}{long}}{long}{long}{long}}{long}{long}}}{long}{long}}{long}}
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⴽⴰⵜⴰ ⴰⴷ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵢⴰⵏ ⵓⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⵔⵉⵏⵉⵏ ⵙ ⵓⵟⵟⵓⵏ ⵏ ⵡⵉⵏⵏⴰ ⴳ ⵜⵓⵙⴷⵉⴷⵜ ⵏⵏⵙⵏⵜ ⵜⴰⴱⵉⵏⴰⵔⵉⵜ ⵙ ⵓⵙⵙⵓⴷⵙ ⵏ ⵓⴽⵛⵛⵓⵎ. ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵉⵏⵏⴰ ⵉⵔⵡⴰⵙⵏ, ⵙ ⵓⵙⵙⵓⴷⵙ ⵅⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵔⴰⵡ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵉⵜⵜⵓⵙⵎⵔⵙ ⵣⵓⵏⴷ ⴰⴷ: >>> sort_array(((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5})) >>> sort_array((std::vector<long>{(long>{(long}-2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std::vector<(long>{(long>-6, (long) 5, (long) 4, (long) 3, (long) 2} >>>array_std::vector<(long>{(long>1, (long) 3, (long)) (long) 4, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long))
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵉⵕ s ⴷ ⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ n, ⵜⵙⵙⵓⵜⵔ ⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉⵕ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ ⵙⴳ ⵓⵡⵉⴽⵉⵕ s ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ n ⵏ ⵜⵓⵏⵙⵉⵏ, ⴰⴼⴰⴷ ⴰⴷ ⵜⵜⵉⵍⵉⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴷ ⴳ ⵓⵡⵉⴽⵉⵕ s. ⵎⴽ ⵜⴳⴰ ⵓⵡⵉⴽⵉⵕ s ⵜⴰⵍⵍⵉⵜ, ⵔⴰⴷ ⵜⵙⵙⴽⵔ ⵜⵡⵓⵔⵉ ⵢⴰⵏ ⵓⵡⵉⴽⵉⵕ ⵉⵅⵡⴰⵏ. ⵜⴰⵖⴹⴼⵜ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⴽⵔ ⴰⵙⵡⵉⴽⵉⵕ ⵏ ⵓⴽⵛⵛⵓⵎ ⵖⴰⵙ ⵜⵉⵔⵔⴰ ⴷ ⵉⵙⴰⵢⵔⴰⵔⵏ. ⴰⵎⴷⵢⴰ: >>> select_words{""ⵎⵔⵉⵎ ⵖⵓⵔⵙ ⵜⴰⵔⵔⴰ ⵜⴰⵥⵥⵉⴹ""), (4)) (std::vector<std::string>), (4) (std::vector<std::string>), (5) (std::vector<std>) ({""ⵎⵔⵉⵎ ⵖⵓⵔⵙ ⵜⴰⵔⵔⴰ ⵜⴰⵥⵉⴹ""), (6) (std::vector<std>) ({""ⵎⵔⵉ ⵖⵓⵔⵙ ⵜⴰⵔⵔⴰ ⵜⴰⵥⵉⴹ"") ({""ⵎⵔⵉⵎⵔⵉⵎⵔⵉ ⵖⵓⵔⵙⵜ""}) ({""ⵎⵔⵉⵎⵔⵉⵎⵔⵉⵎⵔⵉⵎⵔⵉ""}) ({""ⵎⵔⵉ""ⵎⵔⵉ""ⵎⵔⵉ""ⵎⵔⵉ""ⵎⵔⵉ""}) (<br>) >>>
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵜ ⵜⴳⵓⵔⵉ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⴼⴷ ⵓⵖⵔⵉ ⴰⵎⴳⴳⵓⴳ ⵏⵏⴰ ⵢⵍⵍⴰⵏ ⴳⵔ ⵙⵏⴰⵜ ⵜⵓⵏⵙⵉⵏ ⵙⴳ ⵜⵙⴳⴰ ⵏ ⵡⴰⴷⴼ ⵏ ⵜⴳⵓⵔⵉ (ⴰⵙⵙⴰⵖ ⵏ ⵡⴰⴷⴷⴰⴷ ⴰⵎⵣⵡⴰⵔⵓ). ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⵎⴽⴽⴰⵍⵓⵜⵏ ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ. ⵔⵎⵙⵏ ⵜⴰⴳⵓⵔⵉ ⵜⴰⵅⵅⴰⵔⵜ ⵎⴽ ⵓⵔ ⵜⵢⴰⴼⴰ ⴽⵔⴰ ⵏ ⵓⵎⴽⴽⴰⵍⵓ ⵏⵏⴰ ⵢⵍⵍⴰⵏ ⴳ ⵓⵙⵡⵉⵔ ⵏⵏⵉⴳ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵙⴷ ⵉⵙ ⵜⴰⴳⵓⵔⵉ ⵜⴰⵡⵡⵓⵔⵜ ⵜⵍⵍⴰ ⵖⴰⵙ ⴳ ⵡⴰⵔⵔⴰⵜⵏ ⵏ ⵜⵓⵜⵍⴰⵢⵜ ⵜⴰⵏⴳⵍⵉⵣⵉⵜ. ⴰⵎⴷⵢⴰ: >>> get_closest_vowel (((""yogurt"")) (""u"") >>> get_closest_vowel (((""FULL"")) (""U"") >>> get_closest_vowel (((""quick"")) ("""") >>> get_closest_vowel ((((ab"") ("""")
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵢⴰⵏ ⵓⵎⵉⴹⴰⵏ ⵏ ⵙⵉⵏ ⵉⵙⵓⴳⴰⵎ, ⵙⵉⵏ ⵉⵙⵓⴳⴰⵎ ⴰⴷ ⴳⴰⵏ ⵉⵊⵊ ⵏ ⵓⴱⵕⴰⵏⴽⵉⵙ "" (((' ⵏⵖ ⵉⵊⵊⵏ ⵏ ⵓⴱⵕⴰⵏⴽⵉⵙ "")) "". ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕ ⵉⵙ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵙⵉⵏ ⵉⵙⵓⴳⴰⵎ ⴰⴷ ⵙ ⴽⵔⴰ ⵏ ⵓⴽⵓⴷ, ⵔⴰⴷ ⵉⴳ ⵓⵙⵓⴳⴰⵎ ⴰⴷ ⵉⴼⵓⵍⴽⵉ. ⴰⵙⵓⴳⴰⵎ S ⴷⴰ ⵉⵜⵜⵓⵙⵎⴳⴰⵍ ⵙ ⵉⵖⵓⴷⴰⵏ ⵎⴽ ⴷ ⵖⴰⵙ ⵎⴽ ⴷ ⴽⵓⵍⵍⵓ ⵉⵊⵊⵏ ⵏ ⵓⴱⵕⴰⵏⴽⵉⵙ ⴳ S ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: ⴰⵙⵓⴳⴰⵎ "" ((((()))) "" ⵉⴳⴰ ⵉⵖⵓⴷⴰⵏ, ⵎⴰⵛ ⴰⵙⵓⴳⴰⵎ "" (((()) "" ⵓⵔ ⵉⴳ. ⵔⴰⵔ "" ⵢⴰⴽ "" ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⵓⴳⴰⵎ ⵉⵖⵓⴷⴰⵏ, ⴷ ⵔⴰⵔ "" ⵓⵔ "" ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ. ⴰⵎⴷⵢⴰ: >>> match_parens (((std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵓⵡⵉⴽⵜⵓⵔ k ⴰⵎⵏⵉⴳ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵜⵉⵖⵣⵉ k ⴷ ⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏⵏ k ⴳ arr. ⴰⵎⴷⵢⴰ 1: >>> maximum((std::vector<long>({(long) -3, (long) -4, (long) -5})), (3)) (std::vector<long>({(long) -4, (long) -3, (long) -5}) ⴰⵎⴷⵢⴰ 2: >>> maximum(std::vector<long>({(long) -4, (long) -4})), (2)) (std::vector<long>({(long) -4, (long) -4})) ⴰⵎⴷⵢⴰ 3: >>> maximum(std::vector<(long>{(long) -3, (long) -2, (long) -1, (long) -2, (long) -1, (long) -2, (long) -1}) (1) (std::vector<(arr:}) 1. ⵜⵉⵖⵣⵉ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵔ ⵜⵍⵍⵉ ⴳ ⵓⵙⵏⴼⵔⴰⵔ ⵏ 1000 ⵏ ⵉⴼⵔⴷⵉⵙⵏ. [ len=1, len= 1 ] ]
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵏ ⵡⴰⴽⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵓⵜ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⴰⵏⵙⴰ ⵉⵎⵎⵔⵡⴰⵙⵏ. ⵉⵎⴷⵢⴰⵜⵏ >>> solution(((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) (12) >>> solution((((std::vector<long>({(long)3, (long)3, (long)3, (long)3}))) (9) >>> solution((((std::vector<>(({(long)30, (long)13, (long)24, (long)321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ ⵓⵔ ⵉⴳⵏ ⵡⴰⴽⴰⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ arr ⴷ ⵓⵡⵉⴽⵜⵓⵔ k, ⵙⵙⵓⴼⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵙ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴳ ⵓⴳⴳⴰⵔ ⵙⴳ ⵉⴼⵔⴷⵉⵙⵏ ⵏ arr ⵉⵎⵣⵡⵓⵔⴰ. ⴰⵎⴷⵢⴰ: >>> add_elements{(std::vector<long>{(long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) ⵜⵉⵎⵥⴰ: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵙⵏⵙⵍ ⵏ ⴽⵓⵍⴰⵜⵣ. ⵜⴰⵡⵉⴽⵜⵓⵔⵜ ⵏ ⴽⵓⵍⴰⵜⵣ ⵜⴳⴰ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵎⵍⵏ ⵙ: ⵕⵥⵎ ⵙ ⴽⵓ ⵓⵟⵟⵓⵏ ⴰⵎⵏⵉⴳ n. ⴷⴼⴼⵉⵔ ⴰⴷ, ⴽⵓ ⵓⵡⵉⴽⵜⵓⵔ ⴷⴰ ⵉⵜⵜⵓⵎⵥ ⵙⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵣⵔⵉⵏ ⵙ: ⵉⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵣⵔⵉⵏ ⵉⴳⴰ ⴰⵎⵎ, ⵡⵡⵉⴽⵜⵓⵔ ⴰⴹⵏⵉⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵣⵔⵉⵏ. ⵉⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵣⵔⵉⵏ ⵉⴳⴰ ⴰⵎⵎ, ⵡⵡⵉⴽⵜⵓⵔ ⴰⴹⵏⵉⵏ ⵉⴳⴰ 3 ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵣⵔⵉⵏ ⵓⴳⴳⴰⵔ 1. ⵜⴰⵡⵉⴽⵜⵓⵔⵜ ⵏ ⴽⵓⵍⴰⵜⵣ ⵜⴳⴰ ⴰⵀⴰ ⵓⵔ ⵜⵅⵙⵉ ⴰⴷ ⵏⵙⵎ 1.
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⵔⵉ ⵢⴰⵜ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴷⵊⴰⵏ ⵢⴰⵏ ⵓⴽⴰⴱⴰⵕ ⵏ ⵡⴰⵙⵙ ⴰⴷ ⴷ ⴰⵔ ⵉⵜⵜⴰⵊⵊⴰ ⴰⴷ ⵉⴳ ⵜⵉⴷⵜ ⵉⵖ ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⴷ ⵜⵉⴷⵜ, ⵎⴽⵍⵍⵉ ⵉⴳⴰ ⵜⵉⴷⵜ ⵉⵖ ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⴷ ⵜⵉⴷⵜ. ⴷⴰ ⵉⵜⵜⴰⴷⵊⴰ ⵡⴰⵙⵙ ⴰⴷ ⵉⵖ ⴽⵓⵍⵍⵓ ⵉⵍⵍⴰ ⵓⵙⵍⴳⵏ ⴰⴷ: 1. ⵓⵔ ⵉⴳⵉ ⵓⴽⴰⴱⴰⵕ ⵏ ⵡⴰⵙⵙ ⴰⴷ ⴰⵣⴳⵣⴰⵡ. 2. ⵓⵔ ⵉⴳⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⴳⴳⴰⵔ ⵏ 31 ⵏ ⵡⴰⵙⵙ ⴳ ⵡⴰⵢⵢⵓⵔⵏ 1,3,5,7,8,10,12. ⴷ ⵓⵔ ⵉⴳⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⴳⴳⴰⵔ ⵏ 1 ⵏ ⵡⴰⵙⵙ ⴳ ⵡⴰⵢⵢⵓⵔⵏ 4,6,9,11. ⴷ ⵓⵔ ⵉⴳⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⴳⴳⴰⵔ ⵏ 1 ⵏ ⵡⴰⵙⵙ ⴳ ⵡⴰⵢⵢⵓⵔ 2. ⵓⵔ ⵉⵇⵇⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵙⵙⴰⵏ ⵓⴳⴳⴰⵔ ⵏ 1 ⵏ ⵡⴰⵙⵙ ⴳ ⵡⴰⵢⵢⵓⵔ 4. ⴷⴰ ⵉⵜⵜⴰⴷⵊⴰ ⵡⴰⵙⵙ ⴰⴷ ⵉⴳ ⴳ ⵓⵙⴽⵙⵓ: mm-dd-yyyy >>> valid_(date((((15-01-2012"")) (ⵜⴰⴷⵊⴰ) >>> valid_date_((((04-01-2020"") (ⵜⴰⴷⵊⴰ) >>> valid_(((((((06/06/06/2020)
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ⵉⴳ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⴽⵓⵎⵉ, ⵔⴰⴷ ⵜⵔⵉⵜ ⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵉⵏ ⵙ ⵓⴱⵔⵉⴷ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵉⵏ ⴳ ⵓⵙⴽⴽⵉⵍ, ord{""a"") = 0, ord{""b"") = 1, ... ord{""z"") = 25 ⵉⵎⴷⵢⴰⵜⵏ >>> split_words{""Hello world!"")) std::vector<std::string>({(std::string) ""Hello"", (std::string) ""world!""}) >>> split_words{(((""Hello, world!"")) std::vector<std::string>{((dstring) >>> split_words{""Hello, world!"")) 3
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵎⵉⴹⴰⵏ ⵏ ⵉⵎⴹⴰⵏ, ⵙⵙⵓⴼⵖ ⵉⵙ ⴳⴰⵏ ⵉⵎⵙⵓⴷⵙⵏ ⵙ ⵓⵍⴽⴰⵎ. ⵉⵖ ⴷⴰⵔⴽ ⵓⵎⵉⴹⴰⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⵎ ⵢⴰⵏ, ⵙⵙⵓⴼⵖ false. ⵙⵙⵓⵜⵓⵔ ⵉⵙ ⵓⵔ ⵉⵍⵍⵉ ⵓⵎⴹⴰⵏ ⴰⵎⴳⵓⵔⴰⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉⵎⴷⵢⴰⵜⵏ >>> is_sorted{((std::vector<long>{(long) 5}))) (true) >>> is_sorted{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵏⴱⵔⴰⵣⵏ, ⴽⵓ ⵢⴰⵏ ⴳⵉⵙⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵏⵉⵡ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙ ⵓⵎⴷⵢⴰ, ⵉⵏⴱⵔⴰⵣⵏ = (ⵜⴰⵏⵣⵡⵉ, ⵜⴳⵉⵔⴰ) = (1, 2). ⵉⵏⴱⵔⴰⵣⵏ ⴰⴷ ⴽⵛⵎⵏ, ⵎⴰ ⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵙ ⴳⴰⵏ ⵉⵏⴱⵔⴰⵣⵏ (ⵜⴰⵏⵣⵡⵉ, ⵜⴳⵉⵔⴰ) ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. ⴳ ⴽⵓ ⵉⵏⴱⵔⴰⵣⵏ, ⴷⴰ ⵜⵜⵓⵙⵎⴳⴰⵍⵏ ⵉⵙ ⵉⴳⴰ ⵓⵣⵡⵉⵔⵉ ⵏⵏⵙ ⴰⵎⵥⵥⵢⴰⵏ ⵏⵖ ⴰⵎⵥⵢⴰⵏ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏ ⵉⵙ ⵜⴳⴰ ⵜⵉⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⵏ ⵉⵏⴱⵔⴰⵣⵏ ⴰⴷ ⵙⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ. ⴰⵎⴷⵢⴰ, ⴰⵙⵎⴽⵍ ⵏ ⵉⵏⴱⵔⴰⵣⵏ (1, 3), (2, 4) ⵉⴳⴰ (2, 3) ⴷ ⵜⵉⵣⵉ ⵏⵏⵙ ⵜⴳⴰ 1, ⴷ ⵓⵔ ⵉⴳⵉ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ. ⵎⴽ ⵜⴳⴰ ⵜⵉⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⵢⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ, ⵙⵓⵍ ⵉⵏⵖ ""ⵉⵀⴰ"", ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⵙⵓⵍ ⵉⵏⵖ ""ⵍⴰ"". ⵎⴽ ⵍⵍⵉⵖ ⵓⵔ ⴷⴰ ⵜⵜⵎⴽⵍⵏ ⵙⵉⵏ ⵉⵏⴱⵔⴰⵣⵏ, ⵙⵓⵍⵏ ""ⵍⴰ"". [input/output] samples: >>> intersection::(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵔⴰ ⵏ ⵓⵡⵉⴽⵜⵓⵔ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔⴷ ⵜⴰⴳⵓⵜ ⵏ ⵜⵉⵙⵎⴽⵜⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⵔⵏ ⵙ ⵓⵙⴽⴽⵉⵍ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⴽⵓ ⵓⵟⵟⵓⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ, ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⴷⵢⴰⵏ ⵙ 1, -1 ⵏⵖⴷ 0. ⵜⵔⴰⵔⴷ: None ⵉ ⵡⵉⴽⵜⵓⵔ ⵓⵔ ⵉⵍⵍⵉⵏ. ⴰⵎⴷⵢⴰ: >>> prod_signs{((std::vector<long>{(long)1, (long)2, (long)2, (long)-4}))) 9 >>> prod_signs{(std::vector<long>{(long)0, (long)1}))) 0 >>> prod_signs{(std::vector<long>((())) std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴽⵓ ⵜⴰⵡⵡⵓⵔⵜ ⴳ ⵜⴽⵔⵟⴰ ⵏ N ⵜⵉⴼⵔⵉⵙⵉⵏ ⴷ N ⵜⵉⵔⵙⴰⵍ (N >= 2) ⴷ ⴽⵓ ⵜⴰⵡⵡⵓⵔⵜ ⵏ k, ⴽⵓ ⵜⴰⵡⵡⵓⵔⵜ ⴳ ⵜⴽⵔⵟⴰ ⵏ ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵏⴰⵎⴽⵜ. ⴽⵓ ⵜⴰⵡⵡⵓⵔⵜ ⴳ ⵓⵙⵏⵓⵎⵍ [1, N * N] ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵏⴰⵎⴽⵜ ⴳ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ. ⵜⵅⵙⴷ ⴰⴷ ⵜⴰⴼⴷ ⴰⴱⵔⵉⴷ ⵏ ⵓⵖⵣⵓ k ⴳ ⵜⴽⵔⵟⴰ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⴱⴷⵓ ⵙⴳ ⴽⵓ ⵜⴰⵡⵡⵓⵔⵜ, ⴷ ⴳ ⴽⵓ ⵜⴰⵙⵓⵔⵉⴼⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵍⵎ ⵉ ⴽⵓ ⵜⴰⵡⵡⵓⵔⵜ ⵜⴰⵎⴰⵢⵏⵓⵜ, ⵙ ⵜⴳⵓⵔⵉ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⴷ ⵉ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵍⵎ ⵉ ⴽⵓ ⵜⴰⵡⵡⵡⵓⵔⵜ ⵏ ⵓⵖⵣⵓ k, ⵎⴰⵛⴰ ⵓⵔ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵍⵎ ⵙⴳ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ. ⵜⴰⵡⵓⵔⵜ A (ⵙ ⵜⵉⵖⵣⵎⴽⵔⵟⴰ ⵏ ⵜ) ⵜⵣⵎⵔⴷ ⵓⵖⵣⵎⴽⵜ ⵏ B (ⵙ ⵜⴽⵔⵟⴰ ⵏ ⵜ) ⵎⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ ⵏ ⵜⴽⵔⵟⴰ A ⴷ B (ⵍ B (ⴰⴷ) (ⴰⴷ (ⴰⴷ ⵏⵜⵜⵓ ⴰⵙ ⵏⵜⵜⵓ ⴰⵙ ⵏⵜⵜⴰ l_st_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴽⵓ ⵢⴰⵏ ⵉⵙⵙⵏ ⵜⴰⴹⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ, ⵜⵜⵓⵙⵎⵔⵙⵏⵜ ⵙ ⵓⴳⴳⴰⵔ ⵏ ⵉⵎⵓⵙⵏⴰⵡⵏ ⴳ ⵜⴰⵙⵓⵜⵉⵏ ⵜⵉⵎⴳⴳⵓⵔⴰ. ⵎⴰⵛⴰ, ⵎⴰ ⵓⵔ ⵉⵙⵙⵏ ⵎⵉⴷⴷⵏ ⵜⴳⴰ ⵜⴰⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵉ. ⵜⴰⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵉ ⵜⴻⵜⵜⵓⵙⵏⵎⵍ ⵙ ⵓⵙⵏⵓⵍⴼⵓ: tri(1) = 3 tri(n) = 1 + n / 2, ⵉⴳ n ⴰⵎⵎ ⵓⵎⵉⴹⴰⵏ ⴰⵎⵎ ⵓⵎⵉⴹⴰⵏ. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ⵉⴳ n ⴰⵎⵉⴹⴰⵏ ⴰⵎⵎ ⵓⵎⵉⴹⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵏⴳⵉⴹⴰⵏ, ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⴰⵔⴷ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⵉⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ n + 1 ⵏ ⵜⴰⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵉ. ⴰⵎⴷⵢⴰ: >>> tri(((3) (d) (ⴰⴳ ⵓⵟⵟⵓⵏ ⴰⵎⴷⵉⵔ ⴰⵎⵣⵣⵉⵍ><(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⵓⴼⵖ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ. ⵙⵙⵓⴼⵖ 0 ⵎⴽ ⴳⴰⵏ ⴰⴽⴽⵡ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> ⵡⵓⵟⵟⵓⵏⵏ (((1)) (1) >>> ⵡⵓⵟⵟⵓⵏⵏ (((4)) (0) >>> ⵡⵓⵟⵟⵓⵏⵏ (((235)) (15)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏ ⵜⵉⵔⵔⴰ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵍⴰ ⵉⵏⴳⵔⴰⵡⵏ ⵉⵎⴽⴽⵓⵥⵏ. ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵜⵔⴰ ⴰⴷ ⵜⴰⵡⵉ ⵜⵉⴷⵜ ⵎⴽ ⴷ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵏ ⵉⵏⴳⵔⴰⵡⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⵓⵕ ⵏ ⵉⵏⴳⵔⴰⵡⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⵓⵕ ⵏ ⵉⵏⴳⵔⴰⵡⵏ. >>> is_nested((""[[]]"")) (true) >>> is_nested((""[]]]]]]]]]]]]]]]]) (false) >>> is_nested((""[][]"") (false) >>> is_nested(""[]"") (false) >>> is_nested(""[[]]"") (true) >>> is_nested(""[[]]"") (true)
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏ. ⴷⴰ ⵜⵜⵓⵙⵔⴰⵙ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵓⵢⴷ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴷ, ⴷⴰ ⵜⵜⵓⵙⵔⴰⵙ ⴽⵓ ⵢⴰⵏ ⴳ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵓⴽⵙⴰⵢ ⵏ ⵓⴼⵍⵍⴰ. ⵉⵎⴷⵢⴰⵜⵏ: >>> lst:{ⵜⵡⵉⴽⵜⵓⵔ<ⵜⵡⵉⴽⵜⵓⵔ>{ⵜⵡⵉⴽⵜⵓⵔ}1.0f, (ⵜⵡⵉⴽⵜⵓⵔ)2.0f, (ⵜⵡⵉⴽⵜⵓⵔ)3.0f}))) (14) >>> lst:{ⵜⵡⵉⴽⵜⵓⵔ<ⵜⵡⵉⴽⵜⵓⵔ>{ⵜⵡⵉⴽⵜⵓⵔ)1.0f, (ⵜⵡⵉⴽⵜⵓⵔ)4.0f, (ⵜⵡⵉⴽⵜⵓⵔ)9.0f}))) >>> (98) lst:{ⵜⵡⵉⴽⵜⵓⵔ:{ⵜⵡⵉⴽⵜⵓⵔ}{ⵜⵡⵉⴽⵜⵓⵔ}1.0f, (ⵜⵡⵉⴽⵜⵓⵔ)3.0f, (ⵜⵡⵉⴽⵜⵓⵔ)5.0f, (ⵜⵡⵉⴽⵜⵓⵔ)7.0f} (84) >>> lst:{ⵜⵡⵉⴽⵜⵓⵔ>{ⵜⵓⵔ}{ⵜⵡⵉⴽⵜⵓⵔ}1.0f, (ⵜⵡⵉⴽⵜⵓⵔ) 2.0f, (ⵜⵡⵉⴽⵜⵓⵔ) 2.0f)) (6) >>> (ⵜⵡⵉⴽⵜⵓⵔ:{ⵜⵡⵉⴽⵜⵡⵉⴽⵜⵓⵔ:{ⵜⵡⵉⴽⵜⵓⵔ}1.0f, (ⵜⵡⵉⴽⵜⵡⵉⴽⵜⵓⵔ) (6) >>> (ⵜⵡⵉⴽⵜⵡⵉⴽⵜⵓⵔ)
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵎⵓⵖ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵢⴰⵏ ⵓⵖⵉⵍⵓⴼ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵙ ⵜⵉⴼⵉⵏⴰⵖ ⵓⵔ ⵉⴳⵉ ⴰⴳⵣⵣⵓⵎ ⵏ ⵜⴳⵓⵔⵉ, ⴷ ⵜⵉⴷⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵜⴰⵖⴹⴼⵜ: "" ⵜⴳⵓⵔⵉ "" ⵜⴳⴰ ⵢⴰⵜ ⵜⵔⴰⴱⴱⵓⵜ ⵏ ⵡⵓⵎⵓⵖⵏ ⵉⵜⵜⵓⵣⵍⴰⵢⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ. ⵉⵎⴷⵢⴰⵜⵏ: >>> check_if_last_char_is_a_letter ((((""apple pie"")) (false) >>> check_if_last_char_is_a_letter (((""apple pi e"")) (true) >>> check_if_last_char_is_a_letter ((((""apple pi e "")) (false) >>> check_if_last_char_is_a_letter ((("""")) (false)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵙⵏⵎⴽⵍ ⴰⵎⵇⵔⴰⵏ ⵏ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵇⵔⴰⵏ ⵏⵖⴷ ⴰⵎⵣⴷⴰⵢ ⵏ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ ⴷ ⵢⵣⵔⵉⵏ. ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙ ⴰⴷ, ⵙⴽⵔ -1. ⵓⵔ ⵔⴰⴷ ⵉⵟⵟⴰⴼ ⵓⵡⵉⴽⵜⵓⵔ ⵉⵜⵜⵓⵢⴰⴽⴽⴰⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵢⴰⵍⵍⴰⵏ. ⵉⵎⴷⵢⴰⵜⵏ: >>> can_arrange{((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⵜⴰⴱⵔⵔⵉⵜ (ⴰ,ⴱ), ⴳ ⵉⵍⵍⴰ 'ⴰ' ⴰⵎⵇⵇⵔⴰⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵔⵉⵏⵉⵏ, ⴷ 'ⴱ' ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵔⵉⵏⵉⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ. ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵔⵉⵏⵉⵏ ⵏⵖ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵔⵉⵏⵉⵏ, ⵙⴽⵔ ⴰⵙⵏ None. ⵉⵎⴷⵢⴰⵜⵏ: >>> largest_smallest_integers(((std::vector<long>(long) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7))) std::make_tuplestd::optional<long>(stdull::nopt), std::optional<long>((1)) >>> largest_smallest_integers(((stdull::stdull::long))) std::make_tuplest::long)))
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵉⵙⵏⴼⵍⵏ, ⵏⵖ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⴰⵔ ⵉⵙⵙⴽⵛⵎ ⴰⵎⵙⵏⴼⵍⵍ ⴰⵎⵇⵔⴰⵏ ⴳ ⵡⴰⵏⴰⵡ ⵏ ⵓⵎⵙⵏⴼⵍ ⵏⵏⵙ. ⵓⵔ ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵎⴽⵍⵍⵉ ⴳⴰⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⴳⴰⵔⴰⵏⵏ. ⵜⴰⵖⴹⴼⵜ: ⵎⴽ ⵉⵜⵜⵓⵙⵎⴷⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵎ ⵜⵉⴼⵉⵏⴰⵖ, ⵜⴰⵖⴹⴼⵜ ⵜⴰⴱⵔⵙⴳⴳⵡⴰⴷⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⴳ . ⵏⵖⴷ , >>> compare_one(1, 2.5f) 2.5f >>> compare_one(1, ""2,3"") ""2,3"" >>> compare_one(""5,1"", ""6"") ""6"" >>> compare_one(""1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⴼⵔⴰⵏ ⵉⵙ ⵉⵥⴹⴰⵕ ⵓⵟⵟⵓⵏ n ⴰⴷ ⵉⵜⵜⵢⴰⵔⴰⵏ ⵙ ⵜⵔⵎⵜ ⵏ 4 ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵓⴹⴰⵏⵏ ⵉⵎⵏⵖⴰⵏⵏ ⴰⵎⴷⵢⴰ >>> is_equal_to_sum_even (((4)) (false) >>> is_equal_to_sum_even (((6)) (false) >>> is_equal_to_sum_even (((8)) (true)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⴼⴰⵔⵙ ⴰⴱⵕⴰⵣⵉⵍⵉ ⵙ: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! ⴳ ⵉⵍⵍⴰ n > 0 ⵙ ⵓⵎⴷⵢⴰ: >>> special_factorial (((4)) (288) ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵓⵎⵥ ⴰⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴷ ⵔⴰⴷ ⵜⵔⴰⵔ ⵓⴼⴰⵔⵙ ⴰⴷ ⴰⵎⴷⴷⴰⴷ.
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⴹⵕⵉⵚ ⵏ ⵜⵣⵍⵖⴰ, ⵙⵙⵎⵔⵙ ⵜⵉⴼⵔⴽⵉⵏ ⵙ ⵉⵙⵡⴰⵍⵏ, ⴷ ⵎⴽ ⴷⴰⵔ ⵜⵣⵍⵖⴰ ⵓⴳⴳⴰⵔ ⵏ 2 ⵏ ⵉⵙⵡⴰⵍⵏ ⵉⵎⵎⵣⴷⴰⵢⵏ, ⵙⵙⵎⵔⵙ - >>> fix_spaces(("" ⴰⵎⴷⵢⴰ"")) (""ⴰⵎⴷⵢⴰ"") >>> fix_spaces(("" ⴰⵎⴷⵢⴰ 1"")) (""ⴰⵎⴷⵢⴰ_1"") >>> fix_spaces(("" ⴰⵎⴷⵢⴰ 2"") (""_ⴰⵎⴷⵢⴰ_2"") >>> fix_spaces(("" ⴰⵎⴷⵢⴰ 3"")
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⴽⵜⵓⵎ ⵉⵙⵎⴷⵢⴰ ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ, ⴰⵔ ⵉⵙⵙⴽⵛⵎ ""ⵉⵀ"" ⵎⴽ ⵉⴳⴰ ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⵣⵔⴼⴰⵏ, ⴰⵔ ⵉⵙⵙⴽⵛⵎ ""ⵓⵅ"" ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⵔ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵖⴰⵙ ⵎⴽ ⵍⵍⴰⵏ ⴽⵓⵍⵍⵓ ⵜⵎⵙⴰⵔⵉⵏ ⴰⴷ: - ⵓⵔ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⴽⵕⴰⴹ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ('0'-'9') ⴳ ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ. - ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⵉⵍⵍⴰ ⵖⴰⵙ ⵢⴰⵏ ⵓⴽⵜⵓⵎ '.' - ⵓⵔ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴳ ⵓⴽⵜⵓⵎ ⴷⴰⵜ ⵓⴽⵜⵓⵎ ⴰⵣⵔⴼⴰⵏ, ⴰⵔ ⵉⵙⵙⵏⵜⵉ ⵙ ⵢⴰⵏ ⵓⴽⵜⵓⵎ ⵙⴳ ⵉⵙⴽⴽⵉⵍⵏ ⵏ ⵜⵉⵔⵔⴰ ⵜⴰⵍⴰⵜⵉⵏⵉⵜ ('a'-'z' ⴷ 'A'-Z'). - ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⴳ ⵓⴽⵜⵓⵎ ⴷⴼⵉⵔ ⵓⴽⵜⵓⵎ ⵢⴰⵏ ⵙⴳ ⵡⵉⵏⵏⴰ ⴷ ⵉⴷⴷⴰⵏ: ['txt', 'exe', 'll'] ⵉⵎⴷⵢⴰⵜⵏ: >>> file_name_check_{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// "" ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⴽⴽⴰ ⵢⴰⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉ ⴽⵓⵍⵍⵓ ⵉⵎⴷⵢⴰⵡⵏ ⴳ ⵓⴽⵛⵛⵓⵎ, ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵜⴽⴽⴰ ⴰⵎⴽⴽⵓⵥ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵖ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3 ⴷ ⵔⴰⴷ ⵜⴽⴽⴰ ⴰⵎⴽⴽⵓⵥ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵖ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 4 ⴷ ⵓⵔ ⵉⴳ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵓⵔ ⵜⵙⵏⴼⵍ ⵉ ⵉⵎⴷⵢⴰⵡⵏ ⴳ ⵓⴽⵛⵛⵓⵎ ⵏ ⵓⴽⵛⵛⵓⵎ ⵍⵍⵉ ⵓⵔ ⵉⴳⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3 ⵏⵖ 4. ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵉⵎⴷⵢⴰⵡⵏ. ⵉⵎⴷⵢⴰⵡⵏ: >>> lst (long({(long) 1, (long) 2, (long) 1, (long) 3})) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴳⵓⵔⵉ, ⵜⴰⴳⵓⵔⵉ ⵜⵍⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵢⵙⴱⴹⵏ ⵙ ⵢⴰⵏ ⵓⵙⴰⵢⵔⴰⵔ, ⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵓⵔⵉ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵢⵎⵎⴰⵜ, ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵣⵡⵓⵔⴰ, ⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⵉⵔⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴳ ⵓⵡⵜⵜⵓ ⴰⵎⴰⵢⵏⵓ ⴰⵎⵎ ⵜⴰⴳⵓⵔⵉ ⵜⴰⵢⵎⵎⴰⵜ. ⴰⵎⴷⵢⴰ 1: >>> words_in_sentence (((""This is a test"")) (""is"") ⴰⵎⴷⵢⴰ 2: >>> words_in_sentence (((""let's go for swimming"")) (""go for"") ⵜⵉⵎⵥⵍⴰⵢ: * 1 <= len ({(sentence)) <= 100 * ⵜⴰⴳⵓⵔⵉ ⵜⵍⴰ ⵖⴰⵙ ⵜⵉⵔⵔⴰ
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵎⵔⵙ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵔⴰⴷ ⵉⵙⴱⴷⴷⴰⴷ ⴰⵙⵏⵓⵎⵍ x * n. ⴷⴰ ⵜⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵜⵉⴷⵜ ⵎⴽⵍⵍⵉ x * n ⴷⴰ ⵉⵜⵜⵓⵙⵎⴽⵍ ⵙ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴷ ⵜⵉⴷⵜ ⵎⴽⵍⵍⵉ ⵓⵔ ⵉⴳⵉ. ⵙⵡⴰ x ⴷ n, ⴳⴰⵏ ⴰⵙⵎⴷⵢⴰ ⵏ ⵓⴽⵙⴰⵢ, ⴷ ⵖⵓⵔⵙⵏ ⵜⴰⵍⵖⴰ ⴷ ⵢⵓⵛⴽⴰⵏ, <numerator>/<denominator> ⴳⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴷ ⵓⵎⵙⵙⴰⵖ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵙⵎ ⵎⴰⵙ ⴷ x ⴷ n ⴳⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⵓⵔ ⵖⵓⵔⵙⵏ ⴰⵔⴰ ⴰⵎⵙⵙⴰⵖ. >>> ⵙⵙⴱⴷⴷⴰⴷ (((""1/5""), (""5/1"")) (ⵜⴰⴷⴷⵓⵜ) >>> ⵙⵙⴱⴷⴷⴰⴷ (((""1/6""), (""2/1"") (ⵜⴰⴷⴷⵓⵜ) >>> ⵙⵙⴱⴷⴷⴰⴷ (((""7/10""), (""10/2"") (ⵜⴰⴷⴷⵓⵜ)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⵓⴷⵙ ⵜⴰⵡⵡⵓⵔⵉ ⵏ ⵓⵎⵙⴽⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ. ⵙⵙⵓⴷⵙ ⴰⵙⵏⵎⵍ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏⵏⵙⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> order_by_points{(std::vector<long>({(long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({(long) -1, (long) -1, (long) -12, (long) 11}) >>> order_by_points{(std::vector<long>())) (std::vector<long>(long))
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵎⵇⵇⵓⵔⵏⵉⵏ ⴷⴰⵔ 10 ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⵓⴳⴳⴰⵔⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⴳⴰⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ (1, 3, 5, 7, 9). ⵙ ⵓⵎⴷⵢⴰ: >>> specialFilter(((std::vector<long>({(long) 15, (long) -73, (long) 14 , (long) -15}))) (1) >>> specialFilter((std::vector<long>({(long) 33, (long) -2, (long) -3, (long) 45, (long) 21, (long) 109} (2))))
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵓ ⵢⴰⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ n. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔ ⵢⴰⵜ ⵜⴱⵔⵉⴷⵜ ⵏ ⵉⵎⵉⴹⵏ ⵉⵎⵏⵉⴳⵏ a ⵏ ⵜⵉⵖⵣⵉ n. ⵉ ⴽⵓ i (1 ≤ i ≤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1. ⴰⵔⵏ ⵉⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⵏ ⵉⵎⵎⵔⵏ (a[i], a[j], a[k]) ⵏ a ⴳ i < j < k, ⴷ a[i] + a[j] + a[k] ⵉⴳⴰ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⴰⵎⴷⵢⴰ: >>> get_max_triples((5)) (1) ⴰⵙⴼⵔⵓ: a = [1, 3, 7, 13, 21] ⴰⵎⵉⴹⴰⵏ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ ⵏ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵎⵔⵏ (1, 7, 13).
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵍⵍⴰⵏⵜ 8 ⵏ ⵜⵣⵡⵉⵏⵏⵉⵏ ⴳ ⵓⵏⴳⵔⴰⵡ ⵏ ⵜⴰⴼⵓⴽⵜ ⵏⵏⵖ: ⵜⴰⵎⴰⵜⴰⵢⵜ ⵏ ⵜⴰⴼⵓⴽⵜ ⵜⴳⴰ ⵜⵊⵎⵉⵍⵜ, ⴷ ⵜⴰⵎⴰⵜⴰⵢⵜ ⵏⵏⵙ ⵜⴳⴰ ⴼⵉⵏⵓⵙ, ⴷⴼⴼⵉⵔ ⵏ ⵖⵉⵍⴰⴷ, ⴷ ⵡⴰⴽⴰⵍ, ⴷ ⵎⴰⵕⵚ, ⴷ ⵢⵓⴱⵉⵜⵔ, ⴷ ⵙⴰⵜⵓⵔⵏ, ⴷ ⵓⵕⴰⵏⵓⵙ, ⴷ ⵏⵉⴱⵜⵓⵏ. ⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵍⵜ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵜⵣⵡⵉⵏⵏⵉⵏ ⵙ ⵉⵙⵎ ⵏ ⵜⵉⵙⵉⵔⵎⵉⵏ ⵜⵣⵡⵉⵏⵏⵉⵏ ⴷ ⵜⵣⵡⵉⵏⵏⵉⵏ. ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⴱⵔⵣⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⵣⵡⵉⵏⵏⵉⵏ ⴰⴽⴽⵡ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳⵔ ⵜⵣⵡⵉⵏⵏⵉⵏ ⵏⵏⵙ ⴳⵔ ⵜⵣⵡⵉⵏⵏⵉⵏ ⵏ ⵜⵣⵡⵉⵏⵏⵉⵏ ⴷ ⵜⵣⵡⵉⵏⵏⵉⵏ ⵏ ⵜⵣⵡⵉⵏⵏⵉⵏ 2, ⵙ ⵓⵙⵎⵉⵍ ⵏ ⵜⴰⵎⴰ ⵏ ⵜⴰⴼⵓⴽⵜ. ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⴱⵔⵣⴰ ⵜⴰⵣⴳⵍⵜ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵜⵣⵡⵉⵏⵏⵉⵏ ⵏⵖ ⵜⵣⵡⵉⵏⵏⵉⵏ 2 ⵉⵙⵎⴰⵡⵏ ⵏ ⵜⵣⵡⵉⵏⵏⵉⵏ. ⴰⵎⴷⵢⴰⴷ ⵉⴳⴰⵏ: >>> bf{(((((""ⵊⵓⴱⵉⵜⵔ"") ({((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⵔⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵎⵎ ⵓⴱⴰⵔⴰⵣ, ⴰⵔ ⵉⵙⴽⵛⵎ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵖⵓⵔⵙⵏ ⵜⵉⵖⵣⵉ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ, ⴰⵔ ⵉⵙⴽⵛⵎ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⵙ ⵢⴰⵜ ⵜⵙⵏⵙⵉ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ, ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⴰⵀⴰ ⵉⴳⴰ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵓⵔ ⵉⴳⵉ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏⵏ, ⴷ ⵉⵖⵢ ⴰⴷ ⵢⴰⵎⵥ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵍⵍⴰⵏ. ⵜⴰⵙⵏⵙⵉ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⴰⴷ ⵜⵍⵍⴰ ⵙ ⵓⵖⵣⵉ ⵏ ⴽⵓ ⵜⴳⵓⵔⵉ, ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⴽⵛⵎ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⴰⴷ. ⵎⴽⵍⵍⵉ ⴷⴰⵔ ⵙⵉⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵖⵣⵉ ⵢⴰⵜ, ⵙⵙⵓⴷⵙ ⵓⵡⵉⴽⵜⵓⵔ ⵙ ⵜⴰⵍⵖⴰ ⵜⴰⴽⵍⵉⴼⵜ. ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵜⵙⵏⵙⵉ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ. ⵜⵣⵎⵎⴰⵢ ⴰⴷ ⵏⴽⵛⵎ ⴽⵓ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵖⵣⵉ.
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴰⵖⴰⵡⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵉⴳⴰ n ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵉⵎⴷⵢⴰⵜⵏ: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵎⴹⴰⵏⵏ, ⵙⵙⴽⵔ ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵓⴽⵓⵥ ⵏ ⵉⵎⴹⴰⵏⵏ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⵏⵏⴰ ⵓⵔ ⵉⵎⵢⴰⵏⴰⵡⵏ. ⵥⴹⴰⵕⴷ ⴰⴷ ⵓⵔ ⵉⵙⴽⵔ ⵉⵎⴹⴰⵏⵏ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. >>> double_the_difference{(((std::vector<float>(({(long)1, (long)3, (long)2, (long)0}))) (10) >>> double_the_difference((((std::vector<float>{(long)-1, (long)-2, (long)0}))) (0) >>> double_the_difference(((std::vector<float>{(long)9, (long)-2}))) (81) >>> double_the_difference(((std::vector<float>{((long) 0))) (0) ⵎⴽ ⵜⴳⴰ ⵜⴽⵛⵛⵓⵎⵜ ⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵓⵙⴽⵛⵓⵎ, ⵙⵙⴽⵔ 0.
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵏⵙⵙⴽⵜⵉ ⴽⵓⵍⵍⵓ ⵜⴰⵡⵏⴳⵉⵎⵜ ⴰⴷ ⵍⵍⵉⵖ ⴷⴰ ⵏⵙⵙⵏ ⵜⵉⵢⴰⴼⵓⵜ ⵏ ⴽⵔⴰ ⵏ ⵜⵎⵙⴰⵔⵉⵏ ⵉⵜⵜⵓⵢⵙⴽⴰⵔⵏ ⴳ ⵜⵉⵣⵉ ⵉⵖⵣⵣⵉⴼⵏ. ⵜⵉⴼⵔⴰⵙ ⴷ ⵜⵡⵏⴳⵉⵎⵉⵏ ⵏⵏⴰ ⵖⵓⵔⴽ ⴳ ⵜⵉⵣⵉ ⴰⴷ ⵙⵍⴰⵡⴰⵏ ⴰⴽⴽⵡ ⴰⴷ ⵜⵜ ⵏⵙⵙⴽⵜⵉ ⴷ ⴰⴷ ⵜⵜ ⵏⵙⵎⵣⴰⵣⴰⵍ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵜⵉ ⵎⴽ ⵍⵍⵉ ⵢⵜⵜⵓⵙⵏⵎⴰⵍ ⵓⴼⴳⴰⵏ ⵜⵉⵢⴰⴼⵓⵜⵉⵏ ⵏ ⴽⵔⴰ ⵏ ⵉⵎⵏⴽⴰⴷⵏ. ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵏ ⵜⵏⵇⵇⵉⵟⵉⵏ ⴷ ⵉⵙⵏⵎⴰⵍⵏ ⵏ ⵜⵉⵣⵉ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⴳ ⴽⵓ ⵢⴰⵏ ⵏ ⵉⵎⵏⴽⴰⴷⵏ ⴷⴰ ⵉⵙⵙⵏⵎⴰⵍ ⵢⴰⵏ ⵓⵎⵏⴽⴰⴷ ⵏ ⵜⵉⵣⵉ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵏⵏⴰ ⵉⵙⵏⵎⴰⵍⵏ ⵎⴰⵎⴽ ⵍⵍⵉ ⵢⵣⵔⵉⵏ ⴽⵓ ⵢⴰⵏ. ⵎⴽ ⵍⵍⵉ ⵙⵏⵎⴰⵍⵏ ⵙ ⵜⵣⴷⴷⴰⵢⵜ, ⵡⴰⵜⵉⴳ ⵉⴳⴰ 0, ⴷ ⵎⴽ ⵍⵍⵉ ⵓⵔ ⵉⴳⵉ, ⵡⴰⵜⵉⴳ ⵉⴳⴰ ⴰⵎⵣⴰⵔ ⴰⵖⵣⴰⵔⵉ ⴳⵔ ⵓⵙⵏⵎⴰⵍ ⴷ ⵓⵙⵏⵎⴰⵍ. ⴰⵎⴷⵢⴰ: >>> (long{((long:long:long vector<long>{long:long} long{long} long{long} long (long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long:long
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⵉⵙⵎ ⵏ ⵜⵔⵎⵜ (ⵜⴰⵏⴳⴳⴰ) ⴷ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵙⵖⵣⵏ. ⵉⵙⵖⵣⵏⵏ ⵔⴰⴷ ⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵉ ⵓⵙⵙⴽⵛⵎ ⵏ ⵜⵔⵎⵉⵏ ⵢⴰⴹⵏⵉⵏ ⵙ ⵜⵔⵎⵜ. ⵜⴰⴷⵓⵙⵉ ⵏ ⵓⵙⵖⵣⵏ ⵜⴳⴰ ⵣⵓⵏⴷ ⴰⵢⴰ: ⴰⴷ ⵜⴳ CAP ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵜⴰⵎⵇⵕⴰⵏⵜ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵏ, ⴷ ⴰⴷ ⵜⴳ SM ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⵔⵔⴰ ⵜⴰⵎⵥⵥⵢⴰⵏⵜ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵏ, ⵜⴰⴷⵓⵙⵉ ⵜⵜⵓⴼⴽⴰ ⵙ ⵓⴳⵣⵣⵓⵎ CAP - SM. ⵔⴰⴷ ⵜⵙⵙⵓⴼⵖ ⵜⴰⴷⵓⵙⵉ ⵜⴰⵅⴰⵜⴰⵔⵜ ⴷ ⵜⵔⵎⵜ ⴳ ⵓⵙⴽⴽⵉⵍ ⴰⴷ: ClassName.StrongestExtensionName. ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⵙⵖⵣⵏⵏ ⵏ ⵢⴰⵜ ⵜⴷⵓⵙⵉ, ⵔⴰⴷ ⵜⵙⵙⵓⴼⵖ ⵢⴰⵜ ⵏⵏⴰ ⴷ ⵜⵣⵡⴰⵔ ⴳ ⵓⵡⵉⴽⵜⵓⵔ. ⵙ ⵓⵎⴷⵢⴰ, ⵎⴽ ⵜⵜⵓⴼⴽⴰ ""Slices"" ⴰⵎⵎ ⵜⵔⵎⵜ ⴷ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵉⵙⵖⵣⵏ: [SE'viSliNGCesCesCes'SE', Cheese', StufedF'] ⵔⴰⴷ ⵜⵔⵎⴷ 'Slices.viSlivesC' then you should return 'SlivesC'SlivesC::st::viviSlivesC::st::st::st::st::st::st:Slives::st:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:S:
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵜⵍⵍⴰ ⴷⴰⵔⴽ 2 ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵜⵅⵙⴷ ⴰⴷ ⵜⵔⴰⵔ true ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵏⵖ ⴽⵔⴰ ⵏ ⵜⵙⵓⵜⵍⵜ ⵏⵏⵙ ⵢⴰⵜ ⵜⵉⵔⵔⴰ ⴳ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ >>> cycpattern_check((""abcd""), (""abd"")) (false) >>> cycpattern_check((""hello""), (""ell"") (true) >>> cycpattern_check(""whassup""), (""psus"")) (false) >>> cycpattern_check((""abab""), (""baa"")) (true) >>> cycpattern_(check""efef""), (""eeff"") cy (false) >>> cycpattern_check((""himens""), (""simen"") (true)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ, ⵙⵙⵓⴼⵖ ⵜⴰⵡⴰⵍⵜ ⵏ ⵜⴱⵔⵣⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⴷ ⵡⵉⵏ ⵡⴰⵔ ⴰⵎⴹⴰⵏ. ⴰⵎⴷⵢⴰ: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵟⵟⵓⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ, ⵙⵙⵓⵜⵔ ⴰⵎⵢⴰⵡⴰⵙ ⵏ ⵡⵓⵟⵟⵓⵏ ⵕⵓⵎⴰⵏ ⴰⵎⵎ ⵜⴰⵡⴰⵍⵜ, ⴷ ⵙⵙⵓⴼⵖ ⵙ ⵉⵎⴷⵢⴰⵡⵏ ⵉⵎⵥⵥⵉⵏ. ⵜⵉⵎⵥⴰ: 1 <= num <= 1000 ⵉⵎⴷⵢⴰⵜⵏ: >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳⴰⵏ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ. ⴰⵔ ⵏⵙⵙⴽⵛⵎ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ ⴰⵎⵙⴷⵓⵙ, ⵏⵙⵙⴽⵛⵎ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵢⴰⵏ ⵓⴽⵕⴰⴹ ⴰⵎⵙⴷⵓⵙ. ⵢⴰⵏ ⵓⴽⵕⴰⴹ ⴰⵎⵙⴷⵓⵙ ⵉⴳⴰ ⵢⴰⵏ ⵓⴽⵕⴰⴹ ⴳⵉⵙ ⵢⴰⵜ ⵜⵉⴼⵓⵍⵜ ⵜⴰⵎⵙⴷⵓⵙⵜ ⵏⵖⴷ 90 ⵏ ⵜⵙⴽⵡⴼⵍⵜ. ⴰⵎⴷⵢⴰ: >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵙⵔⵙⵏ ⵜⴰⵡⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵜⵓⵔ ⵏ ⵜⵉⴼⵉⵏⴰⵖ. ⵉⵍⵍⴰ ⴳ ⵓⵡⵉⴽⵜⵓⵔ ⴽⵉⴳⴰⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵙⵙⵓⴼⵖ ⵜⴰⴳⵓⵔⵉ ⵏⵏⴰ ⴷⴰⵔ ⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⵉⵡⵏ. ⵎⴽ ⴷⴰⵔ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵙⵓⴼⵖ ⵢⴰⵏ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⴳ ⵓⵏⵎⴰⵍⴰ ⵏ ⵓⵙⴽⴽⵉⵍ. >>> find_max{(std::vector<std::string>({(std::string) ""name"", (std::string) ""of"", (std::string) ""string""}))) (""string"") >>> find_max{(std::vector<std::string>({(std::string) ""name"", (std::string) ""enam"") >>> find_max{(std::vector<std>{(((std) ""aaaaaa"" >>> find_max{(std::string> (std:string) ""bb"" (std) ""aaa"" (((string))
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵔⴰⴷ ⵜⵔⴰⵔⴷ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵏ [ⴰⵎⴹⴰⵏ ⴰⴽⴽⵡ ⵏ ⵉⴽⵙⵉⵍⵏ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ ⴷⴼⴼⵉⵔ ⵏ ⵜⵙⵙⵓⵜⵍⵜ, ⴰⵎⴹⴰⵏ ⵏ ⵉⴽⵙⵉⵍⵏ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ ⴷⴼⴼⵉⵔ ⵏ ⵜⵙⵙⵓⵜⵍⵜ] ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⴽⵔⴰ ⵏ ⵉⴽⵙⵉⵍⵏ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ, ⵔⴰⴷ ⵜⵙⵙⵓⵜⵍⵜ ⴽⵓⵍⵍⵓ ⵉⴽⵙⵉⵍⵏ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⴳⵏ, ⵎⴰⵛ ⵔⴰⴷ ⵜⵙⵙⵓⵜⵍⵜ. ⴰⵎⴷⵢⴰ: >>> eat((5), (6), (10)) (std::vector<long>{(()11, (long)4})) >>> eat(4), (8), (9) (std::vector<long>{(()12, ( (1})) >>> eat(1), (10), (10) (std::vector<long>{()11, (long) 0)) >>> (((2), (5) (std::vector<<<d>{(7)) 0) @ long long: number of carrots remaining in stock that you need to eat: 1000 *: 0 = <= 1000: *number <= 0 ⵏ ⵉⵎⴷⴷⴰⵢⵏ ⵉⵎⴷⴷⴰⵢⵏ ⵏⵏⴰ ⴷ ⵉⵇⵇⵉⵎⵏ ⴳ ⵓⴳⴰⵎ ⵏ ⵉⵙⵎⵓⵜⵜⴳⵏ: 1000: *=====
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴳ ⵓⵎⵢⴰⵡⴰⵙ ⵏ ⵓⵎⵙⵙⵓⴷⵙ, ⵏⵜⵜⴰⴼⴰ ⵙⵉⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ ⴷ ⵓⵎⵙⵡⵓⵔⵉ. ⴰⵎⵙⵙⵓⴷⵙ ⴰⵎⵣⵡⴰⵔⵓ ⴷⴰⵔⵙ ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ, ⴷ ⵓⵎⵙⵙⵓⴷⵙ ⵡⵉⵙⵙ ⵙⵉⵏ ⵉⴳⴰ ⴰⵎⵙⵙⵓⴷⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵎⵔⵙⵏ ⵙⵉⵏ ⵉⵎⵙⵙⵓⴷⵙⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉ ⵓⵙⴽⴰⵔ ⵏ ⵜⴳⵓⵔⵉ ⵏ ⵍⵊⵉⴱⵔ ⴷ ⵓⵙⵡⵓⵔⵉ ⵏ ⵓⵙⵜⴰⵍ ⵏ ⵜⴳⵓⵔⵉ ⴰⴷ. ⵜⵉⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵜⵉⵎⵣⵡⵓⵔⴰ: ⴰⵙⵎⵓⵏ (+) ⴰⵙⵏⴳⵔ ( ) - ⴰⵙⵎⵓⵜⵜⴳ (*) ⴰⵙⴱⴹⵓ ⵏ ⵓⵙⵡⵉⵔ (//) ⴰⵙⵎⵓⵜⵜⴳ (**) ⴰⵎⴷⵢⴰ: ⴰⵎⵙⵙⵓⴷⵙ['+', '*', '-'] ⵓⵎⵙⵙⵓⴷⵙ = [2, 3, 4, 5] ⵜⵢⴰⴼⵓⵜ = 2 + 3 * 4 - 5 => ⵜⵢⴰⴼⵓⵜ = 9 ⵜⵏⴰⴹⵜ: ⵜⵉⵣⵉ ⵏ ⵓⵎⵙⵙⵓⴷⵙ ⴰⵎⵙⵙⵓⴷⵙ ⵜⴳⴰ ⵜⵜ ⵜⵉⵣⵉ ⵏ ⵓⵎⵙⵙⵓⴷⵙ ⴰⵎⵙⵙⵓⴷⵙ ⴱⵍⴰ ⵢⴰⵏ. ⴰⵎⵙⵙⵓⴷⵙ ⴰⵎⵙⵙⵓⴷⵙ ⵉⴳⴰ ⴰⵎⵙⵙⵓⴷⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏⴳⵏ. ⴰⵎⵙⵙⵓⴷⵙ ⴰⵎⵙⵙⵓⴷⵙ ⴷⴰⵔ ⵖⵓⵔⴰⵔ ⵢⴰⵏ ⵓⵎⵙⵙⵓⴷⵙ, ⴷ ⵓⵎⵙⵙⵓⴷⵙ ⴰⵎⵙⵙⵓⴷⵙ ⵖⵓⵔⵙ ⵖⵓⵔ ⵙⵉⵏ.
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉ ⴽⵔⴰ ⵏ ⵓⵡⵉⴽⵉ s. ⵎⴽ ⵜⴳⴰ s[i] ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⵙⵙⵓⵜⵍ ⵜⴰⵡⵉⴽⵉ ⵏⵏⵙ ⵙⴳ ⴷⴷⴰⵡ ⵙ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⴱⵔⴰⵔⴳ, ⵎⴽ ⵓⵔ ⵜⵍⵍⴰ. ⵎⴽ ⵓⵔ ⵜⵍⵍⴰ ⴳ ⵓⵡⵉⴽⵉ ⴽⵔⴰ ⵏ ⵜⴱⵔⴰⵜⵉⵏ, ⵙⵙⵓⵜⵍ ⵜⴰⵡⵉⴽⵉ. ⵜⴰⵡⵡⵓⵔⵉ ⴰⴷ ⵜⵔⴰ ⴰⴷ ⵜⵙⴽⵔ ⵜⴰⵡⵉⴽⵉ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ. ⴰⵎⴷⵢⴰ >>> solve((""1234"")) (""4321"") >>> solve(""ab"")) (""AB"") >>> solve((""#a@C"")) (""#A@c"")
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵓⵡⵉⴽⵉ 'text', ⵙⴽⵔ ⴰⵙⴽⵔ ⵏ ⵓⵡⵉⴽⵉ ⵏ ⵓⴱⵟⵟⵓ md5 ⵏⵏⵙ. ⵉⴳ 'text' ⵉⴳⴰ ⵓⵡⵉⴽⵉ ⴰⵣⴳⵣⴰ, ⵙⴽⵔ None. >>> string_to_md5(((""Hello world"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,tzm_Tfng,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ⵉⴳ ⴷⴰⵔⴽ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b, ⵙⵙⵓⴼⵖ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵓⵟⵟⵓⵏⵏ ⴳⵔ a ⴷ b, ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵇⵔⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: >>> generate_integers((2), (8)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
