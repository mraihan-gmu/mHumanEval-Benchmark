task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ពិនិត្យមើលថាតើនៅក្នុង vector នៃចំនួនដែលបានផ្តល់, មានចំនួនពីរជិតគ្នាជាងកម្រិតកំណត់. >>> has_close_elements ((((std:: vector<float> ((({(float) 1.0f, (float) 2.0f, (float) 3.0f})), (0.5f)) (កុហក) >>> has_close_elements (((std:: vector<float> (((float) 1.0f, (float) 2.8f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f})), (0.3f)) (ពិត)
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការបញ្ចូលទៅក្នុងលក្ខខណ្ឌនេះគឺជាខ្សែដែលមានក្រុមជាច្រើននៃក្រដាសបិទបាំងដែលត្រូវបានបិទបាំងគោលបំណងរបស់អ្នកគឺដើម្បីបែងចែកក្រុមទាំងនោះទៅជាខ្សែឯកជននិងត្រឡប់ទៅវិញវ៉ិចទ័រនៃពួកគេក្រុមឯកជនមានតុល្យភាព (ស្លាកបើកនីមួយៗ ត្រូវបិទត្រឹមត្រូវ) និងមិនត្រូវបានបិទបាំងក្នុងគ្នាទៅវិញទៅមក Ignore any spaces in the input string. >>> separate_paren_groups(""( ) (() (( ) ) ))) (std::vector<std::string>{(std::string) "")"", ((((())::"", (std::string) ""((())))))
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់ចំនួន floating point វិជ្ជមាន, វាអាចត្រូវបានបំបែកទៅជាភាគ integer (ភាគ integer ធំជាងចំនួនដែលផ្តល់) និង decimals (ភាគដែលនៅសល់គឺមានតិចជាង 1) ។ ត្រឡប់មកវិញភាគភាគភាគនៃចំនួន។ >>> truncate_number((3.5f)) (0.5f)
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវ vector នៃការដាក់ប្រាក់ និងការដកប្រាក់នៅលើគណនីធនាគារដែលចាប់ផ្តើមដោយសល់សល់សល់សល់។ ការងាររបស់អ្នកគឺដើម្បីកំណត់ថាតើនៅគ្រប់ពេលវេលានៃសល់គណនីធ្លាក់ចុះក្រោមសល់សល់សល់ហើយនៅពេលវេលានោះមុខងារគួរតែត្រឡប់មកវិញ true បើមិនដូច្នេះទេវាគួរតែត្រឡប់មកវិញ false. >>> below_zero(((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សម្រាប់ទិសដៅនៃចំនួនបញ្ចូលមួយ, គណនា Mean Absolute Deviation ជុំវិញមធ្យមនៃតួលេខនេះ Mean Absolute Deviation គឺជាការខុសគ្នារវាងតួអក្សរនិងមជ្ឈមណ្ឌល (មធ្យមនៅក្នុងករណីនេះ): MAD = មធ្យម  x - x_mean  >>> mean_absolute_deviation (((std:: vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បញ្ចូលលេខ 'ដកស្រង់' រវាងតួទាំងពីរដងជាប់គ្នានៃ vector input `numbers' >>> intersperse((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1, (long) 2, (long) 3})), (4)) (std::vector<long>({long) 1, (long) 4, (long) 2, (long) 4, (long) 3}))
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Input ទៅកាន់ function នេះគឺជា string តំណាងឱ្យក្រុមជាច្រើនសម្រាប់ parentheses nested បំបែកដោយអគារ។ សម្រាប់ក្រុមនីមួយៗ output កម្រិត nesting ជ្រៅបំផុតនៃ parentheses. ឧទាហរណ៍ (() (()) មានកម្រិត nesting កម្រិតពីរក្នុងពេលដែល ((())) មានបី។ >>> parse_nested_parens ((((((()) ((())) () (((()))))) (std:: vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការបាញ់ត្រី វ៉ិចទ័រ បញ្ចូល នៃ ខ្សែសង្វាក់ តែ សម្រាប់ អ្នក ដែល មាន ខ្សែសង្វាក់ ផ្នែក ផ្តល់ >>> filter_by_substring(((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""})), (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""bac""d"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សម្រាប់ vector នៃចំនួនគត់ដែលបានផ្តល់ជូន, សូមត្រឡប់មកវិញនូវ tuple ដែលមានចំនួន និងលេខកូដនៃចំនួនគត់ទាំងអស់នៅក្នុង vector. លេខកូដសរុបគ្មានត្រូវស្មើនឹង 0 និងលេខកូដសរុបគ្មានត្រូវស្មើនឹង 1. >>> sum_product (((std::vector<long>())) (std::make_tuple ((0, 1)) >>> sum_product (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple ((10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ពី vector នៃ integer ដែលបានផ្តល់ឱ្យ, បង្កើត vector នៃ rolling អត្ថន័យអតិបរមាដែលត្រូវបានរកឃើញរហូតដល់ពេលដែលបានផ្តល់នៅក្នុង sequence. >>> rolling_max(((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// រក palindrome ខ្លីបំផុតដែលចាប់ផ្តើមដោយខ្សែផ្គត់ផ្គង់ គំនិតអាល់ហ្សេរីទាំគឺងាយស្រួល: - រក postfix ខ្លីបំផុតនៃខ្សែផ្គត់ផ្គង់ដែលជា palindrome - បន្ថែមទៅចុងនៃខ្សែប្រឆាំងនៃខ្សែ prefix ដែលមកមុនសុក្រឹត palindromic ។ >>> make_palindrome ((("""")) ("""") >>> make_palindrome (((""cat"")) (""catac"") >>> make_palindrome (((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Input គឺជា string a និង b ដែលមានតែ 1s និង 0s ប៉ុណ្ណោះ។ ធ្វើការ XOR ជា binary លើ input ទាំងនេះ និង return result ដូចគ្នា ជា string ។ >>> string_xor((""010""), (""110"")) (""100"")
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ក្នុងចំណោមវ៉ិចទ័រនៃខ្សែ, សូមត្រឡប់ទៅវិញដែលវែងជាងគេមួយ. ត្រឡប់ទៅវិញដំបូងមួយក្នុងករណីនៃខ្សែជាច្រើននៃទំហំដូចគ្នា. ត្រឡប់ទៅវិញគ្មានក្នុងករណីដែលវ៉ិចទ័របញ្ចូលគឺគ្មាន. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest(((std::vector<std::string>{(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest((((std::vector<std::string>({(std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់មកវិញនូវមធ្យមភាគរួមដ៏ធំបំផុតនៃចំនួនគត់ a និង b >>> មធ្យមភាគ_ធំបំផុត (greatest_common_divisor) (((3)) (5) (1) >>> មធ្យមភាគ_ធំបំផុត (greatest_common_divisor) (((25) (15) (5)
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// វិវ៉ុលវិលត្រឡប់នៃអក្សរដើមទាំងអស់ពីខ្លីបំផុតទៅជាវែងបំផុតនៃខ្សែបញ្ចូល >>> all_prefixes (((""abc"")) (std:: vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បញ្ជូន string ដែលមានចំនួនកំណត់ដោយអវកាសចាប់ពី 0 រហូតដល់ n រួមទាំង។ >>> string_sequence((0)) (""0"") >>> string_sequence((5)) (""0 1 2 3 4 5"")
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្តល់នូវខ្សែសង្វាក់មួយ, រកមើលថាតើមានសញ្ញាបត្រខុសគ្នាប៉ុន្មាន (មិនគិតពី case) ដែលវាមាន >>> count_distinct_characters (((""xyzXYZ"")) (3) >>> count_distinct_characters (((""Jerry"")) (4)
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Input to this function is a string representing musical notes in an ASCII format. Your is to parse string vector of integers corresponding to many beats does. Here is a legend: 'o' note, lasts four beats 'o 112' - last half note, lasts two beats 'o 112' - last quater note, lasts one beat >>> parse_music. ((((o o 12 12 o 12 o 12 o 12 o 12 o 12 o 12 o 12 o 12 o 13 o 14 o 14 o 14 o 14 o 14 o 14 o 15 o 14 o 15 o 15 o 16 o 16 o 17 o 17 o 18 o 18 o 18 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 19 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21 o 21
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// រកមើលថា តើសន្សំសំចៃមួយអាចត្រូវបានរកឃើញក្នុងសន្សំសំចៃដើមបានប៉ុន្មានដង។ រាប់បញ្ចូលករណីផ្ទុយគ្នា: >>> how_many_times((""""), (""a"")) (0) >>> how_many_times(""aaa""), (""a"")) (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Input គឺជា string ដែលមានអវកាសកំណត់នៃចំនួនពី 'សូន្យ' ទៅ 'ប្រាំមួយ' ជម្រើសត្រឹមត្រូវគឺ 'សូន្យ', 'មួយ', 'ពីរ', 'បី', 'បួន', 'ប្រាំ', 'ប្រាំមួយ', 'ប្រាំពីរ', 'ប្រាំបី' និង 'ប្រាំមួយ' ត្រឡប់មកវិញ string ជាមួយនឹងលេខដែលត្រូវបានរៀបចំនៃតូចបំផុតទៅធំបំផុត >>> sort_numbers (((""បីមួយប្រាំ"")) (""មួយបីប្រាំ"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ពីទិសដៅដែលផ្តល់ជូននៃលេខ (ដែលមានកម្ពស់យ៉ាងហោចណាស់ពីរ) ជ្រើសរើសនិងត្រឡប់មកវិញពីរដែលជិតគ្នា និងត្រឡប់មកវិញតាមលំដាប់ (លេខតូចជាង, លេខធំជាង) >>> find_closest_elements (((std:: vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.2f}))) (std:: make_tuple (((2.0f, 2.2f)) >>> find_closest_elements (((std:: vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f)) (std:: vector<float>, (float) 2.0f))
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្តល់ វ៉ិចទ័រ នៃ ចំនួន (នៃ អត្តសញ្ញាណ ពីរ យ៉ាងហោចណាស់) អនុវត្ត ការផ្លាស់ប្តូរ លំដាប់ ថ្នាក់ ទៅលើ វ៉ិចទ័រ នោះ ដោយមាន ចំនួន តូច បំផុត នឹង ក្លាយជា 0 និង ធំ បំផុត នឹង ក្លាយជា 1 >>> rescale_to_unit ({((std::vector<float>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Filter given vector of any cppthon values only for integers >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>(())))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់មកវិញនៃប្រវែងនៃ string >>> string_length ((("""")) (0) >>> string_length (((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សម្រាប់ចំនួន n ដែលបានផ្តល់ឱ្យ, រកចំនួនធំជាងគេដែលបែងចែក n បានស្មើ, តូចជាង n >>> largest_divisor ((((15)) (5)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// វិវ៉ុលត្រឡប់នៃកត្តាដំបូងនៃចំនួនគត់ដែលត្រូវបានផ្តល់ដោយចាត់តាំងពីតូចបំផុតទៅធំបំផុត. កត្តានីមួយៗត្រូវត្រូវបាន vectored ចំនួនដងដែលទាក់ទងនឹងចំនួនដងដែលវាបង្ហាញនៅក្នុង factorization. ចំនួនបញ្ចូលត្រូវស្មើនឹងផលិតផលនៃកត្តាទាំងអស់ >>> factorization (((8)) (std:: vector<long> (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ពី vector នៃ integer, ដក element ទាំងអស់ ដែល កើតឡើង ច្រើនជាង មួយដង។ រក្សា លំដាប់ នៃ element នៅ សល់ ដូចគ្នា នឹង ក្នុង ចំណូល ។ >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សម្រាប់សរសៃដែលបានផ្តល់ជូន សូមបម្លែងអក្សរតូចទៅជាអក្សរធំ និងអក្សរធំទៅជាអក្សរតូច >>> flip_case (((""Hello"")) (""hELLO"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Concatenate vector of strings into a single string >>> concatenate(((std::vector<std::string>())) ("""") >>> concatenate(((std::vector<std::string>({(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) (""abc"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការបាញ់ត្រី វ៉ិចទ័រ បញ្ចូល នៃ ខ្សែសង្វាក់ តែ សម្រាប់ អ្នក ដែល ចាប់ផ្តើម ជាមួយ នឹង prefix មួយ បាន ផ្តល់ ឲ្យ ។ >>> filter_by_prefix((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string) ""cde"", (stdstring) ""array""})), (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមត្រឡប់មកវិញតែចំនួនវិជ្ជមាននៅក្នុង vector. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive(((std::vector<long>({long) -5, (long) -3, (long) -5, (long) -3, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់មកវិញពិតប្រសិនបើចំនួនដែលបានផ្តល់ជាចំនួនដំបូង ហើយខុសទៀត >>> is_prime((6)) (កុហក) >>> is_prime((101)) (ពិត) >>> is_prime((11) (ពិត) >>> is_prime((13441)) (ពិត) >>> is_prime(61)) (ពិត) >>> is_prime(4)) (កុហក) >>> is_prime(1)) (កុហក)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// តួអង្គនេះយកវ៉ិចទ័រ l ហើយវិលត្រឡប់មកវិញវ៉ិចទ័រ l' ដែល l' គឺដូចគ្នាទៅនឹង l នៅក្នុងតួអក្សរដែលមិនអាចបែងចែកបានដោយបី, ខណៈដែលតម្លៃរបស់វ៉ិចទ័រដែលអាចបែងចែកបានដោយបីគឺស្មើនឹងតម្លៃនៃតួអក្សរដែលពាក់ព័ន្ធនៃ l, ប៉ុន្តែត្រូវបានរៀបចំព្រាម. >>> sort_third: vector<long>{(long) 1, (long) 2, (long) 3}))) (std: vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third: vector<long>{(long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std vector<(long>{(long>{(long) 2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5}))
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់ទៅវិញនូវតួឯកឯកដែលត្រូវបានរៀបចំនៃ vector >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់ទៅតួអក្សរខ្ពស់បំផុតនៅក្នុង vector. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long) -5, (long) 2, (long) -3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមត្រឡប់មកវិញចំនួនដងដែលតួ 7 លេចឡើងនៅក្នុងចំនួនគត់តិចជាង n ដែលអាចបែងចែកបានដោយ 11 ឬ 13 >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// តួអង្គនេះយកវ៉ិចទ័រ l ហើយវិលត្រឡប់មកវិញវ៉ិចទ័រ l' ដែល l' គឺដូចគ្នាទៅនឹង l នៅក្នុងតួអង្គមិនស្មើគ្នា ខណៈដែលតម្លៃរបស់វ៉ិចទ័រនៅតួអង្គស្មើនឹងតម្លៃនៃតួអង្គស្មើនៃ l ប៉ុន្តែត្រូវបានរៀបចំព្រោះ។ >>> sort_even(((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<(long>{((long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib ផ្តល់នូវចំនួន n-th ដែលជាចំនួន Fibonacci ហើយវាក៏ជាចំនួនដំបូងដែរ >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib(3)) (5) >>> prime_fib((4)) (13) >>> prime_fib(5)) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// triple_sum_to_zero យក វ៉ិចទ័រ នៃ តួអង្គ សរុប ជា ចំណូល វា ត្រឡប់ មក វិញ ថា ពិត បើ មាន អត្តសញ្ញាណ ប័ណ្ណ បី ផ្សេង គ្នា ក្នុង វ៉ិចទ័រ ដែល សរុប ទៅ នឹង លេខ សូន្យ ហើយ ខុស បើ មិន ដូច្នោះ ទេ >>> triple_sum_to_zero(std::vector<long>(long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triple_sum_to_zero(std::vector<long>(long) 1, (long) 3, (long) 2, (long) 1} >>> (true) triple_sum_to_zero(std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) triple_sum_to_zero >>> (long) 2 (long) 4, (long) 5, (long) 3, (long) 9, (long) 7))) (true) triple_sum_to_zero))) (long) >>> (long_long)
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមទស្សនាបង្ហាញផ្លូវមួយដែលជាផ្លូវដ៏ត្រឹមត្រូវមួយដែលមានរយៈពេលយូរឥតឈប់ឈរ. រថយន្ត n កំពុងបើកឆ្វេងទៅស្តាំ; ស្របពេលជាមួយគ្នានៃរថយន្ត n ផ្សេងទៀតកំពុងបើកឆ្វេងទៅឆ្វេង. រថយន្តទាំងពីរចាប់ផ្តើមនៅឆ្ងាយពីគ្នាទៅវិញទៅមក. រថយន្តទាំងអស់ដើរក្នុងល្បឿនដូចគ្នា. រថយន្តពីរត្រូវបានគេនិយាយថាប៉ះគ្នានៅពេលរថយន្តដែលកំពុងដើរឆ្វេងទៅស្តាំប៉ះរថយន្តដែលកំពុងដើរពីស្តាំទៅឆ្វេង. ទោះជាយ៉ាងណា, រថយន្តទាំងពីរមានភាពរឹងមាំនិងរឹងមាំឥតឈប់ឈរ; ជាលទ្ធផល, ពួកគេនៅតែបន្តដំណើរតាមផ្លូវរបស់ពួកគេដូចមិនដែលប៉ះគ្នា។ មុខងារនេះបញ្ចេញចំនួននៃការប៉ះទង្គិចបែបនេះ.
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់ទៅ vector ដែលមានអក្សរដែលបង្កើនដោយ 1. >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// pairs_sum_to_zero យក vector នៃ integer ជា input. វា ត្រឡប់ មក វិញ ពិត បើសិនជា មាន ពីរ ដាច់ ដោយ ឡែក ពី គ្នា ក្នុង vector ដែល សរុប ទៅ នឹង លេខ តិច, និង ខុស បើ មិន ដូច្នេះ ទេ. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>((long) 1, (long) 3, (long) 2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long>{long>(long> (long) 2, (long) 4, (long) 5, (long) 3, (long) 5, (long) 7))) (true) >>> pairs_sum_to_zero))) (long_long) >>> (long_long) >>> (long_se)
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្លាស់ប្តូរមូលដ្ឋានចំនួននៃលេខបញ្ចូល x ទៅជាមូលដ្ឋាន។ ការបង្ហាញសរសៃត្រឡប់ក្រោយការបម្លែង។ ចំនួនមូលដ្ឋានតិចជាង 10 >>> change_base((8), (3)) (""22"") >>> change_base((8), (2)) (""1000"") >>> change_base((7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវប្រវែងនៃផ្នែកមួយ និងតំបន់ត្រឡប់ខ្ពស់សម្រាប់ត្រីកោណ។ >>> triangle_area((5), (3)) (7.5f)
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// លំដាប់លេខ Fib4 គឺជាលំដាប់ដែលស្រដៀងនឹងលំដាប់ Fibbonacci ដែលត្រូវបានកំណត់ដូចខាងក្រោម: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). សូមសរសេរមុខងារដើម្បីធ្វើការរាប់លេខលេខលេខ n-th នៃលំដាប់លេខ fib4 ដោយមានប្រសិទ្ធភាព។ កុំប្រើការវិលត្រឡប់។ >>> fib4((5)) (4) >>> fib4(6)) (8) >>> fib4((7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// វិលត្រឡប់មកវិញនៃធាតុក្នុង vector l. >>> median((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (float(3) >>> median((std::vector<long>({(long) -10, (long) 4, (long) 6, (long) 1000, (long) 10, (long) 20}))) (15.0f)
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការត្រួតពិនិត្យថាតើខ្សែដែលបានផ្តល់ជា palindrome >>> is_palindrome ((("""")) (ពិត) >>> is_palindrome (((""aba"")) (ពិត) >>> is_palindrome (((""aaaaa"")) (ពិត) >>> is_palindrome (((""zbcd"")) (មិនពិត)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់មកវិញ 2^n modulo p (ត្រូវដឹងអំពីតួលេខ) >>> modp((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp((0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101)) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels គឺជាមុខងារដែលយកសរសៃវ៉ែន និងបញ្ជូនសរសៃវ៉ែនដោយគ្មានសម្លេង។ >>> remove_vowels ((("""")) ("""") >>> remove_vowels (((""abcdef"")) (""bcdf"") >>> remove_vowels (((""aaaaa"")) ("""") >>> remove_vowels (((""aaBAA"")) (""B"") >>> remove_vowels (((""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់ទៅ true ប្រសិនបើចំនួនទាំងអស់នៅក្នុង vector l ស្ថិតនៅក្រោមកម្រិត t. >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បន្ថែមចំនួនពីរ x និង y >>> បន្ថែម ({}) (2), ({}) (3) (5) >>> បន្ថែម ({}) (5), ({}) (7) (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ពិនិត្យមើលថាតើពាក្យពីរមានអក្សរដូចគ្នាទេ >>> same_chars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) (ពិត) >>> same_chars((""abcd""), (""dddddddabc"")) (ពិត) >>> same_chars(""dddddddabc""), (""abcd"") (ពិត) >>> same_chars((""eabcd""), (""dddddddabc"")) (មិនពិត) >>> same_chars >>>""((abcd""), (""dddddddabc"") (មិនពិត) >>> same_chars(""eabcd""), (""dddddddddabce"") (មិនពិត) >>> same_chars((""eabcd""), (""ddddzzzzzdzzdddabc"") (មិនពិត)
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមត្រឡប់មកវិញលេខ Fibonacci n-th ។ >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets គឺជា string នៃ ""<"" និង "">"". return true ប្រសិនបើ bracket បើក មាន bracket បិទ ដូចគ្នា. >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>"")) (true) >>> correct_bracketing("">(<>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Return true is vector elements are monotonically increasing or decreasing. >>> monotonic ((((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (true) >>> monotonic ((((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (false) >>> monotonic ((((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (true)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ត្រឡប់ទៅវិញលេខដែលត្រូវបានរៀបចំនូវតួឯករួមតែមួយសម្រាប់វ៉ិចទ័រពីរ. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមត្រឡប់ទៅកត្តាដំបូងដ៏ធំបំផុតនៃ n. ឧទាហរណ៍ថា n > 1 ហើយមិនមែនជាកត្តាដំបូងទេ >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// sum_to_n គឺជាមុខងារដែលសរុបចំនួនពី 1 ដល់ n. >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets គឺជា string នៃ ""("" និង "")"". return true ប្រសិនបើ bracket បើក មាន bracket បិទ ដូចគ្នា >>> correct_bracketing((""("")) (false) >>> correct_bracketing(""() "")) (true) >>> correct_bracketing(""(()))) (true) >>> correct_bracketing(("")
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs តំណាងឱ្យកម្រិតនៃពូជសញ្ញា. xs[0] + xs[1] * x + xs[2] * x^2 + .... ត្រឡប់មកវិញនូវកំណែនៃពូជសញ្ញានេះនៅក្នុងទម្រង់ដូចគ្នា. >>> កំណែ(((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> កំណែ: (((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// លំដាប់លេខ FibFib គឺជាលំដាប់ដែលស្រដៀងនឹងលំដាប់ Fibbonacci ដែលត្រូវបានកំណត់ដូចខាងក្រោម: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). សូមសរសេរមុខងារដើម្បីធ្វើការរាប់លេខលេខ n-th នៃលំដាប់លេខ fibfib. >>> fibfib((1)) (0) >>> fib((5)) (4) >>> fib(8)) (24)
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារ vowels_count ដែលយកសរសៃតំណាងឱ្យពាក្យជាអង់តែន ហើយបញ្ជូនចំនួនសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងឲ្យសរសៃតំណាងឲ្យសរសៃតំណាងនៅក្នុងសរសៃតំណាង។ សរសៃតំណាងនៅក្នុងករណីនេះគឺ 'a', 'e', 'i', 'o', 'o', 'u', 'u'។ ទីនេះ 'y'ក៏ជាសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងឱ្យសរសៃតំណាងឱ្យសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាងអោយសរសៃតំណាង។
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការផ្លាស់ប្តូរជារង្វង់នៃលេខគត់ x, ការផ្លាស់ប្តូរលេខទៅខាងស្តាំដោយការផ្លាស់ប្តូរ និងបញ្ជូនលទ្ធផលមកជាសរសៃ។ ប្រសិនបើការផ្លាស់ប្តូរ > ចំនួនលេខ, ត្រឡប់លេខត្រឡប់មកវិញ។ >>> circular_shift (((12), (1)) (""21"") >>> circular_shift (((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការងារ សរសេរ មុខងារ ដែល យក ខ្សែអក្សរ ជា ចំណូល និង បញ្ជូន លទ្ធផល នៃ តួអក្សរ ខាងលើ តែ ប៉ុណ្ណោះ ' កូដ ASCII ឧទាហរណ៍: >>> digitSum(("""")) (0) >>> digitSum((""abAB"")) (131) >>> digitSum(""abcCd"")) (67) >>> digitSum((""helloE"")) (69) >>> digitSum((""woArBld"")) (131) >>> digitSum((""aAXaaaa"")) (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ក្នុងការងារនេះអ្នកនឹងទទួលបានសរសៃមួយដែលតំណាងឱ្យចំនួនផ្លែប៉ោម និងផ្លែប៉ោមដែលត្រូវបានចែកចាយនៅក្នុងកញ្ចប់ផ្លែឈើ កញ្ចប់នេះមានផ្លែប៉ោម, ផ្លែប៉ោម, និងផ្លែឈើម៉ុង។ ដោយបានផ្តល់សរសៃដែលតំណាងឱ្យចំនួនសរុបនៃផ្លែប៉ោម និងផ្លែប៉ោម និងចំនួនគត់ដែលតំណាងឱ្យចំនួនសរុបនៃផ្លែឈើនៅក្នុងកញ្ចប់ត្រឡប់មកវិញចំនួនផ្លែឈើម៉ុងហ្គោនៅក្នុងកញ្ចប់។ សម្រាប់ឧទាហរណ៍: >>> ផ្លែ_ការចែកចាយ (((((""5 ផ្លែប៉ោម និង 6 ផ្លែប៉ោម""), (19)) (8) >>> ផ្លែ_ការចែកចាយ (((((""0 ផ្លែប៉ោម និង 1 ផ្លែប៉ោម""), (3)) (2) >>> ផ្លែ_ការចែកចាយ ((((((""2 ផ្លែប៉ោម និង 3 ផ្លែប៉ោម""), (100)) (95) >>> ផ្លែ_ការចែកចាយ (((""100 ផ្លែប៉ោម និង 1 ផ្លែប៉ោម""), (120)) (19)))
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""ដោយមានវ៉ិចទ័រតំណាងឱ្យសាខានៃដើមឈើដែលមានសូត្រគត់មិនអវិជ្ជមានការងាររបស់អ្នកគឺដើម្បីដកយកសូត្រមួយ និងត្រឡប់មកវិញ។ សូត្រដែលត្រូវបានដកចេញគួរតែជាសូត្រដែលមានតម្លៃស្មើតិចបំផុត។ ប្រសិនបើមានសូត្រជាច្រើនដែលមានតម្លៃស្មើតិចបំផុតដែលត្រូវបានរកឃើញត្រឡប់មកវិញសូត្រដែលមានតារាងតូចបំផុត។ សូត្រដែលត្រូវបានដកចេញគួរតែត្រូវបានត្រឡប់មកវិញនៅក្នុងវ៉ិចទ័រ, [smallest_value, its index ], បើគ្មានតម្លៃស្មើឬសូត្រដែលត្រូវបានផ្តល់ឱ្យគឺគ្មាន, ត្រឡប់មកវិញ [] ឧទាហរណ៍ 1: >>> pluck(((stdvector<<(long>{long}4, (long) 2, (long) 3}))) (stdvector::<(long>{long}2, (long) 1}) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់វ៉ិចទ័រមិនខ្វះនៃចំនួនគត់វិជ្ជមាន។ ត្រឡប់មកវិញចំនួនគត់ធំជាងគេដែលធំជាងសូន្យ, និងមានអត្រាខ្ពស់ជាងឬស្មើនឹងតម្លៃនៃចំនួនគត់ផ្ទាល់ខ្លួន។ អត្រានៃចំនួនគត់គឺចំនួនដងដែលវាបង្ហាញនៅក្នុងវ៉ិចទ័រ។ ប្រសិនបើគ្មានតម្លៃបែបនេះ, ត្រឡប់មកវិញ -1. ឧទាហរណ៍: >>> search:{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ឧទាហរណ៍: >>> strange_sort_list: កែវ <long> (long) 1, (long) 2, (long) 3, (long) 4}))) (std:: vector <long> (long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list: កែវ <long> (long) 5, (long) 5, (long) 5}))) (std:: vector <long> (long) 5, (long) 5, (long) 5}))) (std:: vector <long> (long) 5, (long) 5, (long) 5} >>> strange_sort_list: កែវ <long> (long) 5))) (std:: vector <long> (long) 5)) (std:: vector <long> (long) 5))
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវប្រវែងនៃភាគីទាំងបីនៃត្រីចក្រមួយ។ ត្រឡប់មកវិញនៃតំបន់នៃត្រីចក្រដែលត្រូវបានពង្រីកទៅ 2 ចំណុចតារាងសញ្ញាប្រសិនបើភាគីទាំងបីបង្កើតជាត្រីចក្រត្រឹមត្រូវ។ បើមិនដូច្នេះទេត្រឡប់មកវិញ -1 ភាគីទាំងបីបង្កើតជាត្រីចក្រត្រឹមត្រូវនៅពេលដែលចំនួននៃភាគីទាំងពីរធំជាងភាគីទីបី។ ឧទាហរណ៍: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារដែលត្រឡប់មកវិញពិតប្រសិនបើវត្ថុ q នឹងហោះ, និងខុស បើមិនដូច្នេះទេ វត្ថុ q នឹងហោះ ប្រសិនបើវាមានតុល្យភាព (វាជា vector palindromic) និងចំនួននៃអក្សររបស់វាតិចជាងឬស្មើនឹងទម្ងន់អតិបរមាដែលអាចធ្វើបាន w ឧទាហរណ៍: >>> will_it_fly(((std::vector<long>({long) 1, (long) 2}), (5)) (false) # 1+2 តិចជាងទម្ងន់អតិបរមាដែលអាចធ្វើបាន, ប៉ុន្តែវាមិនមានតុល្យភាព. >>> will_it_fly((((std::vector<long>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្តល់ឱ្យ vector arr នៃចំនួនគត់, រកចំនួនអក្សរតិចបំផុតដែលត្រូវផ្លាស់ប្តូរដើម្បីធ្វើឱ្យ vector ជា palindromic. Vector palindromic គឺជា vector ដែលត្រូវបានអានដូចគ្នាទៅមុខនិងក្រោយ។ ក្នុងការផ្លាស់ប្តូរមួយ, អ្នកអាចផ្លាស់ប្តូរអក្សរមួយទៅជាអក្សរផ្សេងទៀត. ឧទាហរណ៍: >>> smallest_change(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1} (1) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1)))
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមសរសេរ function ដែលទទួលយក vector ពីរនៃ strings ហើយត្រឡប់មកវិញ vector ដែលមានចំនួនសរុបនៃ chars នៅក្នុងសរសៃទាំងអស់នៃ vector តិចជាង vector មួយទៀត។ ប្រសិនបើ vector ទាំងពីរមានចំនួន chars ដូចគ្នា, ត្រឡប់មកវិញ vector ដំបូង។ ឧទាហរណ៍ >>> total_match (), (std::vector (), (std::string) (), (std::vector (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std::string) (), (std:string) (), (std:string) (), (std:string) (), (std:string) ()) (, (std:string) (), (std:string) (), (std:string) (d:string) (), (std:string) (string) (string) (string) (string (string) (string) (string) (string) (string) (string (string) (string) (string) (string (string) (string) (string) (string (string) (string) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (str) (
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារដែលវិលត្រឡប់ true ប្រសិនបើចំនួនដែលត្រូវបានផ្តល់គឺការបំបែកនៃចំនួនដើម 3 និង false បើមិនដូច្នេះទេ (a) តិចជាង 100 ឧទាហរណ៍: >>> is_multiply_prime((30)) (true) 30 = 2 * 3 * 5
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// កិច្ចការរបស់អ្នកគឺសរសេរ function ដែលត្រឡប់មកវិញ true ប្រសិនបើចំនួន x គឺជាសមត្ថភាពសាមញ្ញនៃ n និង false នៅក្នុងករណីផ្សេងទៀត. x គឺជាសមត្ថភាពសាមញ្ញនៃ n ប្រសិនបើ n**int=x ឧទាហរណ៍: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរអក្សរដែលយកចំនួនគត់ a ហើយត្រឡប់មកវិញពិត ប្រសិនបើ ingeger នេះជាគុម្ពនៃចំនួនគត់មួយកម្រិត។ សូមបញ្ជាក់ថា អ្នកអាចគិតថាការបញ្ចូលគឺមានប្រសិទ្ធភាពជានិច្ច ឧទាហរណ៍: >>> iscube (((1)) (ពិត) >>> iscube (((2)) (មិនពិត) >>> iscube ((-1)) (ពិត) >>> iscube (((64)) (ពិត) >>> iscube (((0)) (ពិត) >>> iscube (((180)) (មិនពិត)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានបញ្ជាឱ្យសរសេរមុខងារដែលទទួលបានចំនួនដប់ដប់ជា string និងរាប់ចំនួននៃលេខដប់ដប់ដែលជាលេខដំបូង (លេខដំបូង, ឬលេខដំបូង, គឺជាលេខធម្មជាតិដែលធំជាង 1 ដែលមិនមែនជាផលិតផលនៃចំនួនធម្មជាតិតូចជាងពីរ) ។លេខដប់ដប់គឺ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.លេខដើមគឺ 2, 3, 5, 7, 11, 13, 17,... ដូច្នេះអ្នកត្រូវកំណត់ចំនួននៃលេខដូចខាងក្រោម: 2, 3, 5, 7, B (=ដប់ដប់ 11), D (=ដប់ដប់ 13) កត់សម្គាល់: អ្នកអាចគិតថាការបញ្ចូលគឺត្រឹមត្រូវឬលេខដងនិងសញ្ញាកំណត់ A,B,C,D,E,F គឺតែងតែមានអក្សរធំ។ ឧទាហរណ៍: >>> hex_((AB""key"") (1) >>> hex_(((((10"") >>> hex_(77"") (2) >>> hex_(AB""key"") >>> hex_(1"") (4) hex_33"") >>> hex_((ABC"" (68) >>> hex_123 (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកនឹងទទួលបានលេខនៅក្នុងទម្រង់ដប់ ហើយការងាររបស់អ្នកគឺដើម្បីបម្លែងវាទៅជាទម្រង់បៃតង មុខងារនេះគួរតែត្រឡប់មកវិញខ្សែមួយ ដោយមានតួអក្សរនីមួយៗ តួអក្សរនីមួយៗ នៅក្នុងខ្សែនឹងជា '0' ឬ '1' នឹងមានតួអក្សរបន្ថែម 'db' នៅដើមនិងចុងនៃខ្សែតួអក្សរបន្ថែមនឹងមានដើម្បីជួយជាមួយទម្រង់ ឧទាហរណ៍: >>> decimal_to_binary (((15)) (""db1111db"") >>> decimal_to_binary (((32)) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវ string s. កិច្ចការរបស់អ្នកគឺដើម្បីពិនិត្យមើលថា string នោះគឺជា hapcpp ឬអត់។ string គឺជា hapcpp ប្រសិនបើប្រវែងរបស់វាមានយ៉ាងហោចណាស់ 3 ហើយអក្សរ 3 ជាប់គ្នាគឺខុសគ្នា ឧទាហរណ៍: >>> is_happy (((""a"")) (កុហក) >>> is_happy (((""aa"")) (កុហក) >>> is_happy (((""abcd"")) (ពិត) >>> is_happy (((""aabb"")) (កុហក) >>> is_happy (((""adb"")) (ពិត) >>> is_happy ((((xyy"")) (កុហក)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// វាជាសប្តាហ៍ចុងក្រោយនៃវស្សា ហើយគ្រូបង្រៀនត្រូវផ្តល់ចំណាត់ថ្នាក់ដល់សិស្ស។ គ្រូបង្រៀនបានបង្កើតអាល់ហ្សេរីទាំរបស់ខ្លួនសម្រាប់ការវាយតម្លៃបញ្ហានេះគឺថា នាងបានបាត់បង់កូដដែលនាងបានប្រើសម្រាប់ការវាយតម្លៃ។ នាងបានផ្តល់ឱ្យអ្នកនូវ vector នៃ GPAs សម្រាប់សិស្សមួយចំនួនហើយអ្នកត្រូវសរសេរ function ដែលអាចបញ្ចេញ vector នៃចំណាត់ថ្នាក់អក្សរដោយប្រើតារាងដូចខាងក្រោម: GPA  Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E ឧទាហរណ៍: >>>_grade equation: ""{std:: vector<float>{(float) 4.0f, (float) 3, (float) 1.7f, (float) 2, (float) 3.5f))) (std: vector<std:: std:: std::string:: std::string:: std:: ""A"" + "" (string) d: "" (string) (C) "" (C) "" (string) "" ())
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារដែលយកសរសៃវ៉ែន ហើយត្រឡប់មកវិញ true ប្រសិនបើប្រវែងសរសៃវ៉ែនជាចំនួនដើម ឬ false បើមិនដូច្នេះទេ ឧទាហរណ៍ >>> prime_length((""Hello"")) (true) >>> prime_length((""abcdcba"")) (true) >>> prime_length((""kittens"")) (true) >>> prime_length((""orange"")) (false)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់ចំនួនគត់វិជ្ជមាន n, សូមត្រឡប់មកវិញចំនួននៃចំនួនគត់វិជ្ជមាន n-digit ដែលចាប់ផ្តើមឬបញ្ចប់ដោយ 1 ។
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់ចំនួនគត់វិជ្ជមាន N, សូមត្រឡប់មកវិញចំនួនសរុបនៃតួខ្លួនរបស់វានៅក្នុងគណបក្សពីរគត់. ឧទាហរណ៍ >>> ដោះស្រាយ((1000)) (""1"") >>> ដោះស្រាយ((150)) (""110"") >>> ដោះស្រាយ((147)) (""1100"") កែប្រែ: @N ចំនួនគត់ការរឹតត្បិត: 0 ≤ N ≤ 10000. លទ្ធផល: ខ្សែនៃចំនួនគណបក្សពីរ
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវ vector ដែលមិនមែនជាអាវុធនៃចំនួនគត់ lst. បន្ថែមអំបិលដែលនៅចំណុចមិនសូវជាគត់ .. ឧទាហរណ៍: >>> add((std:: vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារដែលយកស្លាកសញ្ញាមួយ និងបញ្ជូនវីដេអូមួយដែលត្រូវបានបញ្ជាបញ្ជាជាជាស្លាកសញ្ញាជាស្លាកសញ្ញាដែលពាក្យទាំងអស់ (បែងចែកដោយអាកាស) ត្រូវបានជំនួសដោយពាក្យថ្មីដែលអក្សរទាំងអស់ត្រូវបានរៀបចំតាមលំដាប់ឡើងទៅតាមតម្លៃ ascii កត់សម្គាល់: អ្នកគួរតែរក្សាលំដាប់នៃពាក្យនិងអាកាសយាន្តក្នុងសាលាឧទាហរណ៍: >>> anti_shuffle (((""Hi"")) (""Hi"") >>> anti_shuffle (((""hello"")) (""ehllo"") >>> anti_shuffle (((""Hello World!!!"")) (""Hello !!!Wdlor"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវទិន្នន័យ 2 ដីម៉ែត្រ, ជា vectors nested, ដែលមានលក្ខណៈដូចទៅនឹង matrix, ទោះជាយ៉ាងណា, មិនដូច matrix, រៀងរាល់ជួរអាចមានចំនួនស្លាកផ្សេងគ្នា. ដោយបានផ្តល់ lst, និង integer x, រក integer x នៅក្នុង vector, និងត្រឡប់ទៅ vector នៃ tuples, [(x1, y1), (x2, y2) ...] ដូចជាថា tuple នីមួយៗ គឺជាតម្រូវការ - (row, columns), ចាប់ផ្តើមដោយ 0. រៀបចំតម្រូវការជាដំបូងដោយជួរក្នុងលំដាប់ឡើង. ក៏រៀបចំតម្រូវការនៃ row ដោយ columns នៅក្នុងលំដាប់ចុះ. ឧទាហរណ៍: >>> get_row(std::vector<std::vector<<d>, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ឧទាហរណ៍: >>> sort_array(std::vector<long>())) (std::vector<long>)) >>> sort_array((std::vector<long>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើត មុខងារ encrypt ដែល យក ខ្សែអក្សរ ជា អា ក្រាម និង បញ្ជូន ខ្សែអក្សរ ដែល បាន បិទ ដោយ បិទ អក្សរ ដែល ត្រូវ បាន បិទ ដោយ បិទ ។ អក្សរ ត្រូវ បាន បិទ ដោយ បិទ ដោយ របៀប ដែល អក្សរ ត្រូវ បាន បិទ ដោយ បិទ ដោយ បិទ ដោយ បិទ ។ ឧទាហរណ៍: >>> encrypt((""hi"")) (""lm"") >>> encrypt((""asdfghjkl"")) (""ewhjklnop"") >>> encrypt((""gf"")) (""kj"") >>> encrypt((""et"")) (""ix"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់វ៉ិចទ័រនៃចំនួនគត់។ សរសេរមុខងារ next_smallest ((() ដែលត្រឡប់មកវិញវេជ្ជបណ្ឌិតតូចជាងគេទី 2 នៃវ៉ិចទ័រ។ ត្រឡប់មកវិញគ្មានប្រសិនបើគ្មានវេជ្ជបណ្ឌិតនោះទេ។ >>> next_smallest (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest (((std::vector<long>(long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest (((std::vector<long>())) std::nullopt >>> next_smallest (((std::vector<long>{(long) 1, (long) 1))) std::nullopt
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកនឹងទទួលបានពាក្យមួយសន្លឹក ហើយការងាររបស់អ្នកគឺរាប់ចំនួននៃការធុញទ្រាន់។ ភាពធុញទ្រាន់គឺជាសំនួរដែលចាប់ផ្តើមដោយពាក្យ ""I"" សំនួរត្រូវបានកំណត់ដោយ '.', '?' ឬ '! ' ឧទាហរណ៍: >>> is_bored ((("" Hello world "")) (0) >>> is_bored (((""មេឃពណ៌ខៀវ។ ព្រះអាទិត្យកំពុងភ្លឺ។ ខ្ញុំចូលចិត្តអាកាសធាតុនេះ"")) (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើតតួអង្គមួយដែលយកចំនួន 3 ។ ត្រឡប់មកវិញពិតប្រសិនបើចំនួនមួយនៃចំនួនគឺស្មើនឹងចំនួនពីរផ្សេងទៀត, និងចំនួនទាំងអស់គឺជាចំនួនពេញ។ ត្រឡប់មកវិញខុសក្នុងករណីផ្សេងទៀត. ឧទាហរណ៍ >>> any_int (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float)) (true) >>> any_int (float) (float) (float) (float) (float) (float) (float)) (true) >>> any_int (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float)) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float (float) (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float) (float (float) (float) (float (float) (float) (float) (float) (float (float) (float) (float) (float) (float) (flo) (float) (float) (flo) (flo) (float) (float) (float) (float) (float (float) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរ function មួយ ដែល យក សារ មួយ មក និង encode ដោយ របៀប ដែល វា swaps case នៃ អក្សរ ទាំងអស់, replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the English alphabet. ឧទាហរណ៍: >>> encode (((""test"")) (""TGST"") >>> encode (((""This is a message"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវ vector នៃចំនួនពេញ. អ្នកត្រូវការដើម្បីរកតម្លៃដំបូងធំជាងគេនិងត្រឡប់មកវិញចំនួននៃលេខរបស់វា. ឧទាហរណ៍: >>> skjkasdkd((std:: vector<long>((long) 0, (long) 3, (long) 2, (long) 1, (long) 3, (long) 5, (long) 7, (long) 4, (long) 5, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) 3, (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ឧទាហរណ៍: >>> check_dict_case (((((std::map<std::string,std::string>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អនុវត្តន៍តួអង្គដែលយកចំនួនសរុបដែលមិនមែនជាអវិជ្ជមាន និងវិលត្រឡប់មកវិញនូវ vector នៃចំនួនគត់ដំបូង n ដែលជាចំនួនសរុបនិងតិចជាង n ឧទាហរណ៍: >>> count_up_to((5)) (std::vector<long>{(long) 2, (long) 3})) >>> count_up_to(11)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7})) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 19)) >>> count_up_1) (std::vector<long>> (std::vector<long>18): count_up_to(((3, (long) 11, (long) 5, (long)) (std: (long) 1, (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បំពេញតួអង្គដែលយកចំនួនគត់ពីរ និងវិលត្រឡប់មកវិញនូវផលិតផលនៃលេខអង្គភាពរបស់ពួកគេ ។ គិតថាការបញ្ចូលគឺមានប្រសិទ្ធភាពជានិច្ច។ ឧទាហរណ៍: >>> បូក (((148), (412)) (16) >>> បូក ((19), (28)) (72) >>> បូក ((2020), (1851)) (0) >>> បូក ((14), (-15)) (20)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវខ្សែ s, រាប់ចំនួនសម្លេងស្លាកសញ្ញាធំនៅក្នុងអក្សរគូ។ ឧទាហរណ៍: >>> count_upper (((""aBCdEf"")) (1) >>> count_upper (((""abcdefg"")) (0) >>> count_upper (((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើតតួអង្គមួយដែលយកតំលៃ (សរសៃ) តំណាងឱ្យចំនួនមួយ ហើយត្រឡប់មកវិញនូវចំនួនគត់ដែលជិតបំផុត។ ប្រសិនបើចំនួននោះមានចម្ងាយស្មើពីចំនួនគត់ពីរ, សូមពង្រីកវាពីសូន្យ។ ឧទាហរណ៍ >>> closest_integer (((""10"")) (10) >>> closest_integer (((""15.3"")) កត់សម្គាល់ (15): ការពង្រីកពីសូន្យមានន័យថាប្រសិនបើចំនួនដែលបានផ្តល់គឺមានចម្ងាយស្មើពីចំនួនគត់ពីរ, អ្នកគួរតែត្រឡប់មកវិញគឺមួយដែលឆ្ងាយបំផុតពីសូន្យ។ ឧទាហរណ៍ closest_integer (((""14.5"") គួរត្រឡប់មកវិញ 15 និង closest_integer (((-14.5"") គួរត្រឡប់មកវិញ -15.
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវចំនួនគត់វិជ្ជមាន n, អ្នកត្រូវធ្វើជាគំនរនៃ n កម្រិតនៃថ្ម. កម្រិតដំបូងមានថ្ម n ចំនួនថ្មនៅក្នុងកម្រិតបន្ទាប់គឺ: - ចំនួនគត់បន្ទាប់ប្រសិនបើ n ជាគត់ - ចំនួនគូបន្ទាប់ប្រសិនបើ n ជាគូ. ត្រឡប់មកវិញចំនួនថ្មក្នុងកម្រិតនីមួយៗ ក្នុងវ៉ិចទ័រ, ដែលតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវឱ្យតម្រូវអោយតម្រូវអោយតម្រូវអោយតម្រូវអោយតម្រូវអោយតម្រូវអោយតម្រូវអោយតម្រូវអោយ
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកនឹងទទួលបានស្លាកសញ្ញានៃពាក្យដែលបែងចែកដោយកាំបិត ឬអគារចំហ។ការងាររបស់អ្នកគឺបំបែកស្លាកសញ្ញាទៅជាពាក្យ និងត្រឡប់មកវិញនូវ vector នៃពាក្យ។ ឧទាហរណ៍: >>> words_string (((""Hi, my name is John"")) (std::vector<std::string>({(std::string) ""Hi"", (std::string) ""my"", (std::string) ""name"", (std::string) ""is"", (std::string) ""John""}) >>> words_string (((""One, two, three, four, five, six"")) (std::vector<std::string>{(stdstring) ""One"", (std::string) ""two"", (std::string) ""three"", (std::string) ""four"", (std::string) ""five"", (std::string) ""six""})
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// តួអង្គនេះយកចំនួនវិជ្ជមាន x និង y ហើយវិលត្រឡប់មកវិញនូវចំនួនគត់ដែលធំជាងគេដែលស្ថិតនៅក្នុងចន្លោះ [x, y] រួមទាំង។ ប្រសិនបើគ្មានចំនួនបែបនេះទេ, តួអង្គនេះគួរតែវិលត្រឡប់មកវិញ -១ ឧទាហរណ៍: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// អ្នកត្រូវបានផ្តល់ចំនួនគត់វិជ្ជមាន n និង m ហើយការងាររបស់អ្នកគឺដើម្បីគិតជាមធ្យមនៃចំនួនគត់ពី n ដល់ m (រួមទាំង n និង m) ។ ជុំវិញចម្លើយទៅចំនួនគត់ជិតបំផុតនិងបម្លែងវាទៅជាគណបក្សបៃតង។ ប្រសិនបើ n ធំជាង m, ត្រឡប់មកវិញ -1. ឧទាហរណ៍: >>> rounded_avg (((1), (5)) ""0b11"" >>> rounded_avg (((7), (5)) -1 >>> rounded_avg (((10), (20)) ""0b1111"" >>> rounded_avg (((20), (33)) ""0b11010""
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្តល់នូវ vector នៃចំនួនគត់វិជ្ជមាន x. ត្រឡប់ទៅ vector ដែលត្រូវបានរៀបចំបើកនៃតួទាំងឡាយដែលមិនមានលេខគត់ណាមួយ។ កត់សម្គាល់: Vector ដែលត្រូវបានត្រឡប់មកវិញគួរតែត្រូវបានរៀបចំបើកឡើងជាបន្តបន្ទាប់។ ឧទាហរណ៍: >>> unique_digits(std::vector<long>({long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវ vector នៃចំនួនគត់, sort the integers that are between 1 and 9 inclusive, reverse the resulting vector, and then replace each digit by its corresponding name from ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"" ឧទាហរណ៍: >>> by_length((std::vector<long>{long) 2, (long) 1, (long) 1, (long) 4, (long) 5, (long) 8, (long) 2, (long) 3}))) (std::vector<std::string>{(std::string) ""Eight"", (std::string) ""Five"", (std::string) ""Four"", (std::string) ""Three"", (std::string) ""Two"", (std::string) ""Two"", ""Four"", ""Five"", ""Five"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""One"", ""
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អនុវត្តន៍មុខងារ f ដែលយក n ជាឧបករណ៍បញ្ជា ហើយវិលត្រឡប់មកវិញនូវ vector ដែលមានទំហំ n ដូច្នេះតម្លៃនៃអាល់អេម៉ង់នៅ index i គឺជាសមាសភាគនៃ i ប្រសិនបើ i ជាគូ ឬចំនួននៃចំនួនពី 1 ទៅ i បើមិនដូច្នេះទេ i ចាប់ផ្តើមពី 1. សមាសភាគនៃ i គឺជាការបំបែកនៃចំនួនពី 1 ទៅ i (1 * 2 * ... * i) ឧទាហរណ៍: >>> f((5)) (std:: vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវចំនួនគត់វិជ្ជមាន n, សូមត្រឡប់មកវិញនូវ tuple ដែលមានចំនួនគត់និងគត់ដែលស្ថិតនៅក្នុងចន្លោះ ((1, n), រួមទាំងគត់។ ឧទាហរណ៍ទី 1: >>> even_odd_palindrome (((3)) (std::make_tuple ((1, 2)) ពន្យល់: គត់ដែលស្ថិតនៅក្នុងគត់គឺ 1, 2, 3. មួយក្នុងចំណោមពួកគេគឺគត់, និងពីរក្នុងចំណោមពួកគេគឺគត់។ ឧទាហរណ៍ទី 2: >>> even_odd_palindrome (((12)) (std::make_tuple ((4, 6)) ពន្យល់: គត់ដែលស្ថិតនៅក្នុងគត់គឺ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. បួនក្នុងចំណោមពួកគេគឺគត់, និង៦ក្នុងចំណោមពួកគេគឺគត់។ កត់: 1 <= n = 10^3 <^3 2. tuple ត្រូវបានត្រឡប់មកវិញមានចំនួនគត់និងគត់ដែលស្ថិតនៅក្នុងគត់គឺគត់។
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារ count_nums ដែលយក vector នៃចំនួនគត់ និងបញ្ជូនចំនួនអក្សរដែលមានចំនួនលេខ > 0 ប្រសិនបើចំនួនមួយគឺអវិជ្ជមាន, បន្ទាប់មកលេខដែលចុះហត្ថលេខាដំបូងរបស់វានឹងមានអវិជ្ជមាន: ឧទាហរណ៍ -123 មានលេខចុះហត្ថលេខា -1, 2, និង 3. >>> count_nums ((((std:: vector<long>())) (0) >>> count_nums (((std:: vector<long>{(long) -1, (long) -11, (long) -11}))) (1) >>> count_nums (((std:: vector<long>{(long) -1, (long) -1, (long) -2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// យើងមាន vector 'arr' នៃចំនួនគត់ N arr[1], arr[2], ..., arr[N] .ចំនួននៅក្នុង vector នឹងត្រូវបានបញ្ជាដោយចៃដន្យការងាររបស់អ្នកគឺដើម្បីកំណត់ថាតើវាអាចទទួលបាន vector ដែលត្រូវបានរៀបចំបែបមិនថយចុះដោយអនុវត្តន៍ប្រតិបត្តិការដូចខាងក្រោមនៅលើ vector ដែលបានផ្តល់ជូន: អ្នកត្រូវបានអនុញ្ញាតឱ្យអនុវត្តប្រតិបត្តិការប្ដូរស្តាំគ្រប់ពេល។ ប្រតិបត្តិការប្ដូរស្តាំមួយមានន័យថាការផ្លាស់ប្តូរតំណែងទាំងអស់នៃ vector ដោយមានចំណុចមួយក្នុងទិសដៅស្តាំ។ តំណាងចុងក្រោយនៃ vector នឹងត្រូវបានផ្លាស់ប្តូរទៅកាន់ចំណុចចាប់ផ្តើមនៅក្នុង vector គឺ 0th index ។ ប្រសិនបើវាអាចទទួលបាន vector ដែលត្រូវបានរៀបចំបែបអនុវត្តប្រតិបត្តិការខាងលើនោះត្រឡប់មកវិញ true ត្រឡប់មកវិញ false ។ ប្រសិនបើ vector ដែលបានផ្តល់ជូននោះគឺគ្មានអ្វីទេនោះត្រឡប់មកវិញ true ។ កំណត់: Vector ដែលបានផ្តល់ជូនត្រូវបានធានាថាមានតំណាងតែមួយ។ ឧទាហរណ៍: >>> move_one_ball_{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ក្នុងបញ្ហានេះ, អ្នកនឹងអនុវត្តមុខងារមួយដែលយក vector ចំនួនពីរ, និងកំណត់ថាតើវាអាចធ្វើបានដើម្បីផ្លាស់ប្តូរអត្តសញ្ញាណប័ណ្ណរវាងពួកគេដើម្បីធ្វើឱ្យ lst1 ជា vector នៃចំនួនគូតែប៉ុណ្ណោះ. គ្មានការកំណត់លើចំនួនអត្តសញ្ញាណប័ណ្ណដែលត្រូវបានផ្លាស់ប្តូររវាង lst1 និង lst2. ប្រសិនបើវាអាចផ្លាស់ប្តូរអត្តសញ្ញាណប័ណ្ណរវាង lst1 និង lst2 ដើម្បីធ្វើឱ្យអត្តសញ្ញាណប័ណ្ណទាំងអស់នៃ lst1 មានគូ, ត្រឡប់មកវិញ ""YES"" បើមិនដូច្នេះទេត្រឡប់មកវិញ ""NO"" ឧទាហរណ៍: >>> exchange((std::vector<>(long) {1, (long) 2, (long) 3, (long) 4})), (std::vector<>(long) {1, (long) 2, (long) 3, (long) 4}) (""YES"") >>>((std::exchange<> vector<>{1, (long) 2, (long) 3, (long) 4}), (std::vector<>(long) {1, (long) 5, (long)) (long) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) ()) ()) ()) ()) ()) ()) ()) ()))) ()) ()) ()))) ()) ()) ()))) ()))) ())))
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ឧទាហរណ៍: >>> histogram (((""a b c"")) (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}})) >>> histogram (((""a b b a"")) (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})) >>> histogram (((""a b c a"")) (std::map<std::string,long>{{""a"", 2}, {""b"", 2}})) >>> histogram (((""a b c a b"")) (std::map<std::string,long>{{""a"", 2}, {""b"", 2}})) >>> histogram (b b a"") (std::string, 4"") (std::string, 4"") (std:string, long)) >>>
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// កិច្ចការ យើងបានទទួលខ្សែពីរគឺ s និង c, អ្នកត្រូវលុបអក្សរទាំងអស់នៅក្នុង s ដែលស្មើនឹងអក្សរណាមួយនៅក្នុង c បន្ទាប់មកពិនិត្យមើលថាខ្សែលទ្ធផលគឺ palindrome ។ខ្សែមួយត្រូវបានគេហៅថា palindrome ប្រសិនបើវាអានដូចគ្នាទៅមុខនិងក្រោយ។ អ្នកគួរតែត្រឡប់មកវិញនូវ tuple ដែលមានខ្សែលទ្ធផលនិង true / false សម្រាប់ការពិនិត្យមើល។ ឧទាហរណ៍ >>> reverse_delete (((""abcde""), (""ae"")) (std::make_tuple (((bcd"", false)) >>> reverse_delete (((""abcdef""), (""b"") (std::make_tuple (((acdef"",)) >>> reverse_delete (((abcded"", false)) >>> reverse_delete (((abcded""), (""abcba"") (std::make_tuple (((cdedc"", true))
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្តល់នូវ vector នៃ string ដែល string នីមួយៗ មានតែលេខប៉ុណ្ណោះ, return a vector. element នីមួយៗ i នៃ output ត្រូវជា ""ចំនួនលេខ odd នៅក្នុង string i នៃ input. "" ដែល i ទាំងអស់ត្រូវត្រូវបានជំនួសដោយចំនួនលេខ odd នៅក្នុង string i នៃ input. >>> odd_count((std::vector<std::string>(({std::string) ""1234567""}))) (std::vector<std::string>({std::string) ""ចំនួនលេខ odd នៃ element 4n នៃ string4ng 4 នៃ 4n. "")) >>> odd_count(stdvector<stdstring>::{(stdstring) "" , ""3 (stdstring)::{""1111""}))) (std vector<std::string::{""}) 1 (n: 1}) លេខ odd នៃ element 1 នៃ string 8n. "" (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) 8 (string) (string) (string)
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវ vector នៃ integer n, រកចំនួនចំនួនតិចបំផុតនៃ vector នីមួយៗ ឧទាហរណ៍ >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវក្របខ័ណ្ឌសិប្បនិម្មិតនៃអណ្តូងទឹក. ជួរនីមួយៗតំណាងឱ្យអណ្តូងតែមួយ, និងមួយក្នុងជួរតំណាងឱ្យមួយផ្នែកនៃទឹក. អណ្តូងនីមួយៗមានបង្គោលដែលអាចត្រូវបានប្រើដើម្បីដកទឹកចេញពីវា, ហើយបង្គោលទាំងអស់មានសមត្ថភាពដូចគ្នា. ការងាររបស់អ្នកគឺដើម្បីប្រើបង្គោលដើម្បីបូមទឹកអណ្តូង. Output ចំនួនដងដែលអ្នកត្រូវការដើម្បីទម្លាក់បង្គោល. ឧទាហរណ៍ 1: >>> max_fill(((std::vector<std::vector<long>, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ក្នុង Kata នេះ អ្នក ត្រូវ រៀបចំ វ៉ិចទ័រ នៃ ចំនួន សរុប ដែល មិន ជា អវិជ្ជមាន តាម ចំនួន មួយ ក្នុង ការ តំណាង របស់ វា ក្នុង លេខ ពីរ ក្នុង លំដាប់ ថយ ចុះ សម្រាប់ ចំនួន ដូច គ្នា នៃ មួយ គឺ រៀបចំ តាម តម្លៃ ដប់ វា ត្រូវ អនុវត្ត ដូច នេះ: >>> sort_array((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5})) >>> sort_array((std::vector<long>{(long) 2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std::vector<(long>{(long) 6, (long) 5, (long) 4, (long) 3, (long) 2} >>> sort_array: vector<(long>{{(long>1, (long) 3, (long)) (long) 0, (long)) (long) 2, (long) 4)) (long) (long) (long) (long)
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវ string s និងចំនួនធម្មជាតិ n, អ្នកត្រូវបានគេបញ្ជាឱ្យអនុវត្តមុខងារមួយដែលត្រឡប់មកវិញ vector នៃពាក្យទាំងអស់ពី string s ដែលមានសម្លេងសុទ្ធតែ n, ដើម្បីពាក្យទាំងនេះបង្ហាញនៅក្នុង string s. ប្រសិនបើ string s គឺគ្មានអ្វីទេនោះមុខងារនេះគួរតែត្រឡប់មកវិញ vector ដែលគ្មានអ្វីនោះ។ សូមបញ្ជាក់ថាអ្នកអាចគិតថា string input មានតែអក្សរនិងអគារគំរូ: >>> select_words (((""Mary had a little lamb""), (4)) (std::vector<std::string>(({std::string) ""little""}) >>> select_words (""Mary had a little lamb""), (3)) (std::vector<std::string>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់ពាក្យមួយ. ការងាររបស់អ្នកគឺដើម្បីរក vowel ដែលជិតបំផុតដែលស្ថិតនៅចន្លោះពីរសំឡេងចម្រៀងពីខាងស្តាំនៃពាក្យ ( case sensitive) ។សំឡេងចម្រៀងនៅដើមនិងចុងមិនរាប់ទេ។ Return ខ្សែទទេប្រសិនបើអ្នកមិនបានរកឃើញសំឡេងចម្រៀងណាមួយបានបំពេញលក្ខខណ្ឌខាងលើ។ អ្នកអាចគិតថាខ្សែដែលផ្តល់បានមានអក្សរអង់គ្លេសតែប៉ុណ្ណោះ។ ឧទាហរណ៍: >>> get_closest_vowel (((""yogurt"")) (""u"") >>> get_closest_vowel (((""FULL"")) (""U"") >>> get_closest_vowel (((""quick"")) ("""") >>> get_closest_vowel ((((ab"") ("""")
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវ vector នៃខ្សែពីរខ្សែទាំងពីររួមមានក្រដាសបើក '(' ឬក្រដាសបិទ ') 'តែប៉ុណ្ណោះ ការងាររបស់អ្នកគឺដើម្បីត្រួតពិនិត្យថាតើវាអាចប្រមូលខ្សែទាំងពីរតាមរបៀបណាមួយដែលសន្សំបានថាខ្សែដែលទទួលបាននឹងល្អខ្សែ S ត្រូវបានចាត់ទុកថាល្អប្រសិនបើនិងតែប្រសិនបើក្រដាសទាំងអស់នៅក្នុង S មានតុល្យភាព ឧទាហរណ៍: ខ្សែ '(())) 'ល្អហើយខ្សែ '()) 'មិនល្អទេ ត្រឡប់មកវិញ 'Yes' ប្រសិនបើមានវិធីដើម្បីបង្កើតខ្សែល្អនិងត្រឡប់មកវិញ 'No' បើមិនដូច្នេះទេ ឧទាហរណ៍: >>> match_parens((std:: vector<std:: string>{((stdstring) "") "", (((std:: string) "")) (""Yes"") >>> match_parens<std:: vector<std>{(std:: string"") ("", ((stdstring)) (""No""))))
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវ vector arr នៃចំនួនគត់និងចំនួនគត់វិជ្ជមាន k, សូមត្រឡប់មកវិញ vector ដែលត្រូវបានរៀបចំបែបកម្រិត k ជាមួយនឹងចំនួន k ក្នុង arr. ឧទាហរណ៍ទី 1: >>> maxima (maximum) std::vector<long> (long) -3, (long) -4, (long) -5, (long) -4, (long) -3, (long) -5 (long) ឧទាហរណ៍ទី 2: >>> maxima (maximum) std::vector<long> (long) -4, (long) -4, (long) -4 (long)), (2) (std::vector<long> (long) -4, (long) -4 (long))) ឧទាហរណ៍ទី 3: >>> maxima (long) std::vector<long> (long) -3, (long) -2, (long) -1, (long) -2, (long) -1, (long) -2, (long) -1, (long) -1, (long) (1) (std::vector<long>) -2): 1. កម្រិតនៃ vector នឹងស្ថិតក្នុងចន្លោះនៃ 1000 ដងនៃ vector. កម្រិតនៃ vector នឹងស្ថិតក្នុងចន្លោះនៃ 1000 ដង vector. កម្រិតនៃ vector នឹងស្ថិតក្នុងចន្លោះនៃ 1000 ដង vector. កម្រិតនៃ vector នឹងស្ថិតក្នុងចន្លោះ len-1. [កម្រិត: 0, len-1, len-1, len-1, len=3, len=2] ។
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវ vector ដែលមិនមែនជាអង្រែនៃចំនួនគត់, សូមត្រឡប់មកវិញនូវចំនួននៃតួឯកទាំងអស់ដែលស្ថិតនៅក្នុងតំណែងគូ។ ឧទាហរណ៍ >>> solution((std::vector<long>({long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> solution(((std::vector<long>({long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> solution(((std::vector<long>({long) 30, (long) 13, (long) 24, (long) 321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវ vector ដែលមិនមែនជាអាវុធនៃចំនួនគត់ arr និងចំនួនគត់ k, សូមត្រឡប់មកវិញនូវចំនួននៃតួដែលមានចំនួនពីរដងពីតួគត់ k ដំបូងនៃ arr. ឧទាហរណ៍: >>> add_elements((std::vector<long>({long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) កំហិត: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការគិតរបស់កូឡាត្ស (Collatz conjecture) គឺជាការគិតមួយនៅក្នុងគណិតវិទ្យាដែលពាក់ព័ន្ធនឹងការកំណត់បន្តបន្ទាប់ដូចខាងក្រោម: ចាប់ផ្តើមដោយចំនួនគត់វិជ្ជមាន n ។ បន្ទាប់មកពាក្យនីមួយៗត្រូវបានទទួលបានពីពាក្យមុនដូចខាងក្រោម: ប្រសិនបើពាក្យមុនគឺគូទ, ពាក្យបន្ទាប់គឺមួយភាគបីនៃពាក្យមុន។ ប្រសិនបើពាក្យមុនគឺចម្លែក, ពាក្យបន្ទាប់គឺ 3 ដងនៃពាក្យមុនបូក 1. ការគិតគឺថាមិនថាមានតម្លៃអ្វីនៃ n, ការបន្តបន្ទាប់នឹងទទួលបាន 1. កត់សម្គាល់: 1. កូឡាត្ស (Collatz) គឺ [1] ។ 2. វ៉ិចទ័រដែលត្រូវបានរៀបចំនិងលេខកើនឡើង។ ឧទាហរណ៍: get_odd_collatz5) ត្រឡប់មកវិញ [1, 5] ការបន្តបន្ទាប់របស់កូឡាត្សសម្រាប់ 5 គឺ [5, 8, 16, 4, 2, 1], ដូច្នេះចំនួនចម្លែកមានតែ 1 និង 5 ប៉ុណ្ណោះ >>> get_odd_collatz (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវសរសេរមុខងារមួយដែលបញ្ជាក់ថា string ថ្ងៃដែលបានផ្តល់និងត្រឡប់មកវិញពិតប្រសិនបើថ្ងៃមានសុពលភាព បើមិនដូច្នេះទេ false. ថ្ងៃមានសុពលភាពប្រសិនបើគ្រប់ច្បាប់ដូចខាងក្រោមត្រូវបានបំពេញ: 1. string ថ្ងៃមិននៅស្ងៀម 2. ចំនួនថ្ងៃមិនតិចជាង 1 ឬខ្ពស់ជាង 31 ថ្ងៃសម្រាប់ខែ 1,3,5,7,8,10,12. និងចំនួនថ្ងៃមិនតិចជាង 1 ឬខ្ពស់ជាង 30 ថ្ងៃសម្រាប់ខែ 4,6,9,11. ហើយចំនួនថ្ងៃមិនតិចជាង 1 ឬខ្ពស់ជាង 29 សម្រាប់ខែ 2. 3. ខែមិនគួរតិចជាង 1 ឬខ្ពស់ជាង 12. 4. ថ្ងៃគួរតែមាននៅក្នុងទម្រង់: mm-dd-yyyy >>> valid_(date((103-11-2000"")) (ពិត) >>> valid_date((15-01-2012"")) (មិនពិត) >>> valid_date(04-040-20"") (មិនពិត) >>> valid_(date_(06-2020"") (ពិត) >>> valid_date""06/04/2020) (មិនពិត)
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ផ្តល់ឱ្យខ្សែនៃពាក្យ, ត្រឡប់មកវិញវ៉ិចទ័រនៃពាក្យបែកជាបន្ទាត់សោ, ប្រសិនបើគ្មានបន្ទាត់សោនៅក្នុងអត្ថបទដែលអ្នកគួរតែបែកជាកំប៉ុង ',' ប្រសិនបើគ្មានកំប៉ុងដែលអ្នកគួរតែត្រឡប់មកវិញចំនួនអក្សរតូចដែលមានលំដាប់មិនធម្មតានៅក្នុងអក្សរ, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 ឧទាហរណ៍ >>> split_words ((((""Hello world!"")) std::vector<std::string>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ឧទាហរណ៍ >>> is_sorted(((std::vector<long>{(long) 5}))) (true) >>> is_sorted((std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) (true) >>> is_sorted((std::vector<long>{(long) 1, (long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) (true) >>> is_sorted (long) 3, (long) 4, (long) 6, (long) 6, (long) 6, (long) 7, (long) 6, (long) 7, (long) 8, (long) 8, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 9, (long) 10, (long) 10, (long) 10, (long) 10, (long) 10, (long) 10, (long) 10, (long) 10, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long)) (long) (long) (long) (long)) (
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ឧទាហរណ៍: ការកាត់ផ្តាច់នៃរវាងរវាងរវាង (1, 3), (2, 4) គឺ (2, 3) ដែលមានទំហំគឺ 1 ដែលមិនមែនជាចំនួនដើម។ ប្រសិនបើទំហំនៃរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាងរវាង
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកបានទទួល vector arr នៃចំនួនពេញ ហើយអ្នកត្រូវការត្រឡប់មកវិញចំនួននៃចំនួនពេញដែលបង្កឡើងដោយផលិតផលនៃសញ្ញាទាំងអស់នៃចំនួនក្នុង vector ដែលតំណាងដោយ 1, -1 ឬ 0 កត់សម្គាល់: ត្រឡប់មកវិញគ្មានសម្រាប់ arr ដែលគ្មានសញ្ញា ឧទាហរណ៍: >>> prod_signs(((std::vector<long>{(long) 1, (long) 2, (long) 2, (long) -4)))) 9 >>> prod_signs(std::vector<long>({(long) 0, (long) 1}))) 0 >>> prod_signs((std::vector<long>(())) std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមបញ្ជាក់ថា ផ្លូវដែលមានប្រវែង k មានន័យថាបានទៅមើលប្រវែង k (មិនចាំបាច់ខុសគ្នា) ។ អ្នកមិនអាចចេញពីប្រវែងក្រាលទេ. ផ្លូវ A (ប្រវែង k) ត្រូវបានចាត់ទុកថាមានទំហំតិចជាងផ្លូវ B (ប្រវែង k) ប្រសិនបើបន្ទាប់ពីបានធ្វើវ៉ិចទ័រដែលត្រូវបានបញ្ជាទិញនៃតម្លៃនៅលើប្រវែង A និង B (យើងហៅវាថា l_stA និង l_stB), វាមានលក្ខណៈសំដីតិចជាង l_stB, ម្យ៉ាងទៀតគឺយើងមានឥទ្ធិពលតែមួយសម្រាប់ទិន្នន័យដែលយើងមានគឺ j_j = l_j < 1 (i = l_j < 1 (i = l_j) និងយើងមានឥទ្ធិពលតែមួយសម្រាប់ទិន្នន័យដែលយើងមាន) ។
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// មនុស្សគ្រប់គ្នាស្គាល់ Fibonacci sequence វាត្រូវបានសិក្សាយ៉ាងជ្រាលជ្រៅដោយអ្នកគណិតវិទ្យានៅក្នុងពីរសតវត្សរ៍ចុងក្រោយនេះ ។ ទោះជាយ៉ាងណាអ្វីដែលមនុស្សមិនដឹងគឺ Tribonacci sequence ។ Tribonacci sequence ត្រូវបានកំណត់ដោយការវិវត្តន៍: tri(1) = 3 tri(n) = 1 + n / 2, ប្រសិនបើ n គឺជួន. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ប្រសិនបើ n គឺមិនធម្មតា. ឧទាហរណ៍: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 អ្នកត្រូវបានផ្តល់ចំនួនគត់មិនអវិជ្ជមាន n, អ្នកត្រូវត្រឡប់មកវិញវ៉ិចទ័រនៃ n + 1 ដំបូងនៃលំដាប់ Tribonacci ។ ឧទាហរណ៍: >>> tri(3) (dst vector long><<(((({) (long1,3, (long2,) (long8}))
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់ចំនួនគត់វិជ្ជមាន n, សូមត្រឡប់មកវិញនូវផលិតផលនៃលេខមិនស្មើគ្នា។ ត្រឡប់មកវិញ 0 ប្រសិនបើលេខទាំងអស់គឺគូ។ ឧទាហរណ៍: >>> លេខ((1)) (1) >>> លេខ((4)) (0) >>> លេខ((235)) (15)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើត មុខងារ ដែល យក ខ្សែ ដែល មាន តែ ក្រដាស ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ នឹង ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មើ ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា ស្មា
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវផ្តល់នូវ vector នៃចំនួន អ្នកត្រូវបញ្ជូនចំនួននៃភាគហ៊ុននៅក្នុង vector ដែលបានផ្តល់ជូន, ចងក្រងអក្សរក្នុង vector ទៅ int ខ្ពស់បំផុតដំបូង ឧទាហរណ៍: >>> lst: vector <float> <float> 1.0f, (float) 2.0f, (float) 3.0f))) (14) >>> lst: vector <float> <float> 1.0f, (float) 4.0f, (float) 9.0f))) >>> (98) lst: vector <float> <float> 1.0f, (float) 3.0f, (float) 5.0f, (float) 7.0f))) (84) >>> lst: vector <float> <float> 1.04f, (float) 2.04f, (float) 2.09f, (float) 2.04f, (float) 2.04f, (float) 2.04f, (float) 2.04f, (float) 2.04f, (float)
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើត មុខងារ ដែល ផ្តល់ លទ្ធផល true ប្រសិនបើ តួអក្សរ ចុងក្រោយ នៃ ខ្សែសង្វាក់ មួយ ជា តួអក្សរ អក្សរ និង មិនមែន ជា ផ្នែក មួយ នៃ ពាក្យ និង false បើ មិន ដូច្នេះ ទេ ។ កត់សម្គាល់: ""ពាក្យ"" គឺជា ក្រុម តួអក្សរ ដែល បែងចែក ដោយ អក្សរ ។ ឧទាហរណ៍: >>> check_if_last_char_is_a_letter (((""apple pie"")) (false) >>> check_if_last_char_is_a_letter (((""apple pi e"")) (true) >>> check_if_last_char_is_a_letter (((""apple pi e "")) (false) >>> check_if_last_char_is_a_letter ((("""")) (false)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើត មុខងារ ដែល ផ្តល់ នូវ អាណាព្យាបាល ធំ បំផុត នៃ អាណាព្យាបាល ដែល មិន ធំ ជាង ឬ ស្មើ នឹង អាណាព្យាបាល ដែល នៅ មុន វា ភ្លាមៗ បើ គ្មាន អាណាព្យាបាល បែប នេះ ទេ នោះ ត្រឡប់ មក វិញ -1. វ៉ិចទ័រ ដែល បាន ផ្តល់ មិន មាន តម្លៃ ចម្លង ទេ ឧទាហរណ៍: >>> can_arrange(((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange(((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើត មុខងារ ដែល ផ្តល់ លេខ ទូទៅ (a, b) ដែល 'a' គឺជា តួ លេខ ធំ បំផុត នៃ តួ លេខ ទាំង អស់ ដែល មាន អវិជ្ជមាន ហើយ 'b' គឺ តួ លេខ តូច បំផុត នៃ តួ លេខ ទាំង អស់ ដែល មាន អវិជ្ជមាន ក្នុង វ៉ិចទ័រ មួយ។ បើ គ្មាន តួ លេខ ទាំង អស់ ដែល មាន អវិជ្ជមាន ឬ តួ លេខ ទាំង អស់ ដែល មាន អវិជ្ជមាន នោះ ទេ នោះ ផ្តល់ លេខ ទាំង នោះ មក វិញ ដោយ មាន លេខ None ឧទាហរណ៍: >>> largest_smallest_integers(((std::vector<long>{long>) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7))) std::make_tuplestd::optional<long>), std::optional<long>) 1) >>> largest_smallest_integers<long> (long>)
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// បង្កើតតួអង្គមួយដែលយកចំនួនសរុប, floats, ឬ string ដែលតំណាងឱ្យចំនួនពិត ហើយបញ្ជូន variable ធំជាងនៅក្នុងប្រភេទ variable ដែលបានផ្តល់ជូន។ បញ្ជូន None ប្រសិនបើតម្លៃគឺស្មើគ្នា។ កត់សម្គាល់: ប្រសិនបើចំនួនពិតត្រូវបានតំណាងឱ្យជា string, floating point អាចជា . ឬ , >>> compare_one(1, 2.5f) 2.5f >>> compare_one(1, ""2,3"") ""2,3"" >>> compare_one(""5,1"", ""6"") ""6"" >>> compare_one(""1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// វាយតម្លៃថា តើចំនួន n ដែលបានផ្តល់អាចត្រូវបានសរសេរជាចំនួននៃចំនួនសរុបចំនួនសរុបចំនួន 4 ដែលមានសុពលភាពដូចគ្នាបានឬអត់ ឧទាហរណ៍ >>> is_equal_to_sum_even ((4)) (កុហក) >>> is_equal_to_sum_even ((6)) (កុហក) >>> is_equal_to_sum_even ((8)) (ពិត)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// កត្តាប្រេស៊ីលត្រូវបានកំណត់ថា: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! ដែល n > 0 ឧទាហរណ៍: >>> special_factorial (((4)) (288) តួនាទីនឹងទទួលបានចំនួនគត់ជាចំណូលនិងគួរតែត្រឡប់មកវិញ កត្តាពិសេសនៃចំនួនគត់នេះ។
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវអត្ថបទស្លាកសញ្ញា, សូមប្តូរកន្លែងទាំងអស់នៅក្នុងវាដោយស្លាកសញ្ញា, ហើយប្រសិនបើស្លាកសញ្ញាមានច្រើនជាង 2 កន្លែងជាប់គ្នា, បន្ទាប់មកប្តូរកន្លែងជាប់គ្នាទាំងអស់ដោយ - >>> fix_spaces ((("" ឧទាហរណ៍"")) (""ឧទាហរណ៍"") >>> fix_spaces ((("" ឧទាហរណ៍ 1"")) (""ឧទាហរណ៍_1"") >>> fix_spaces ((("" ឧទាហរណ៍ 2"")) (""_Example_2"") >>> fix_spaces ((("" ឧទាហរណ៍ 3"")) (""_Example-3"")
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// បង្កើត មុខងារ ដែល យក ខ្សែ តំណាង ឲ្យ ឈ្មោះ ឯកសារ ហើយ បញ្ជូន 'Yes' បើ ឈ្មោះ ឯកសារ មាន សុពលភាព ហើយ បញ្ជូន 'No' បើ មិន ដូច្នោះ ទេ ឈ្មោះ ឯកសារ ត្រូវ បាន ចាត់ ទុក ថា មាន សុពលភាព ប្រសិន បើ និង តែ ប្រសិន បើ លក្ខខណ្ឌ ទាំង អស់ ខាង ក្រោម ត្រូវ បាន បំពេញ: - មិន គួរ មាន ច្រើន ជាង បី អក្សរ ('0'-'9') ក្នុង ឈ្មោះ ឯកសារ - ឈ្មោះ ឯកសារ មាន ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ពណ៌ ព
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// "" តួអង្គនេះនឹងយកវ៉ិចទ័រនៃចំនួនគត់សម្រាប់តួអង្គទាំងអស់នៅក្នុងវ៉ិចទ័រនោះ តួអង្គនឹងដាក់ទីពីរតួអង្គចំនួនគត់ ប្រសិនបើអិនឌិចរបស់វាជាចម្លែកនៃ 3 ហើយនឹងដាក់ទីបីតួអង្គចំនួនគត់ ប្រសិនបើអិនឌិចរបស់វាជាចម្លែកនៃ 4 និងមិនមែនជាចម្លែកនៃ 3 តួអង្គនឹងមិនផ្លាស់ប្តូរតួអង្គនៅក្នុងវ៉ិចទ័រដែលមានអិនឌិចមិនមែនជាចម្លែកនៃ 3 ឬ 4 តួអង្គនោះនឹងត្រឡប់មកវិញនូវចំនួននៃតួអង្គទាំងអស់ ឧទាហរណ៍: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst (long) >>> lst (long{(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវខ្សែតំណាងឱ្យសំនួរមួយ សំនួរនោះមានពាក្យមួយចំនួនដែលបែងចែកដោយអគារ ហើយអ្នកត្រូវបញ្ជូនខ្សែមួយដែលមានពាក្យពីសំនួរដើម ដែលមានទំហំជាចំនួនដើម ការរៀបចំព្រាមនៃពាក្យនៅក្នុងខ្សែថ្មីគួរតែដូចគ្នាទៅនឹងដើម ឧទាហរណ៍ទី 1: >>> words_in_sentence (((""This is a test"")) (""is"") ឧទាហរណ៍ទី 2: >>> words_in_sentence (((""let go for swimming"")) (""go for"") កំហិត: * 1 <= len ((sentence) <= 100 * សំនួរមានតែអក្សរប៉ុណ្ណោះ
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការបំពេញការងាររបស់អ្នកគឺដើម្បីអនុវត្តមុខងារដែលនឹងបង្កើនការបញ្ចេញមតិ x * n មុខងារនេះនឹងវិលត្រឡប់ទៅ true ប្រសិនបើ x * n វាយតម្លៃទៅជាចំនួនទាំងមូលនិង false បើមិនដូច្នេះទេ x និង n គឺជាតំណាងស្លាកនៃភាគហ៊ុនមួយ ហើយមានទម្រង់ដូចខាងក្រោម <numerator>/<denominator> ដែលភាគហ៊ុននិងភាគហ៊ុនទាំងពីរគឺជាចំនួនទាំងមូលវិជ្ជមាន អ្នកអាចចាត់ទុកថា x និង n គឺជាភាគហ៊ុនត្រឹមត្រូវ ហើយមិនមានសូន្យជាភាគហ៊ុន។ >>> simplify((""1/5""), (""5/1"")) (true) >>> simplify((""1/6""), (""2/1"") (false) >>> simplify((""7/10""), (""10/2"") (false)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារដែលរៀបចំ vector ដែលបានផ្តល់របស់ចំនួនពេញក្នុងលំដាប់ឡើងទៅតាមចំនួនលេខរបស់វា។ កត់សម្គាល់: ប្រសិនបើមានវត្ថុជាច្រើនដែលមានចំនួនលេខដូចគ្នា, សូមរៀបចំវត្ថុទាំងនោះដោយផ្អែកលើអិនដិចរបស់ពួកគេនៅក្នុង vector ដើម។ ឧទាហរណ៍: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) -1, (long) -12, (long) 11})) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារដែលយក vector នៃចំនួនជាចំណូល ហើយត្រឡប់មកវិញចំនួនអក្សរនៅក្នុង vector ដែលមានច្រើនជាង 10 ហើយទាំងពីរលេខដំបូងនិងចុងក្រោយនៃចំនួនគឺមិនស្មើ (1, 3, 5, 7, 9) ឧទាហរណ៍: >>> specialFilter(((std::vector<long>({(long) 15, (long) -73, (long) 14 , (long) -15}))) (1) >>> specialFilter((std::vector<long>({(long) 33, (long) -2, (long) -3, (long) -4, (long) 21, (long) 109} (2))))
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់ចំនួនគត់វិជ្ជមាន n អ្នកត្រូវបង្កើត vector ចំនួនគត់ a នៃកំណាត់ n សម្រាប់ i (1 ≤ i ≤ n) នីមួយៗ តម្លៃនៃ a[i] = i * i - i + 1 ។ ត្រឡប់មកវិញចំនួននៃ triples (a[i], a[j], a[k]) នៃ a ដែល i < j < k, និង a[i] + a[j] + a[k] គឺជាចម្លើយនៃ 3 ឧទាហរណ៍: >>> get_max_triples((5)) (1) ការពន្យល់: a = [1, 3, 7, 13, 21] គុណភាព triples ត្រឹមត្រូវគឺ (1, 7, 13)
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// មានផែនដីចំនួន ៨ ក្នុងប្រព័ន្ធព្រះអាទិត្យរបស់យើង: ផ្កាយដែលនៅជិតបំផុតទៅនឹងព្រះអាទិត្យគឺមីក្រូ, មួយទៀតគឺផ្កាយរណប, បន្ទាប់មកផែនដី, មីក្រូ, មីក្រូ, ស្កាយរណប, អ៊ុយរ៉ានូ, នេត្យូ។ សរសេរមុខងារដែលយកឈ្មោះផ្កាយពីរជាខ្សែផ្កាយ1 និងផ្កាយ2. មុខងារនេះគួរតែត្រឡប់មកវិញនូវ tuple ដែលមានគ្រប់ផ្កាយដែលមានរង្វង់ស្ថិតនៅចន្លោះរង្វង់ផ្កាយ1 និងរង្វង់ផ្កាយ2 ដែលត្រូវបានរៀបចំតាមការជិតដល់ព្រះអាទិត្យ. មុខងារនេះគួរតែត្រឡប់មកវិញនូវ tuple ដែលគ្មានអ្វីប្រសិនបើផ្កាយ1 ឬផ្កាយ2 មិនមែនជាឈ្មោះផ្កាយត្រឹមត្រូវទេ ឧទាហរណ៍ >>> bf((""មីក្រូ""), (""មីក្រូ"") (std::vector<std::string>{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សូមសរសេរ function មួយដែលទទួលយក vector នៃ strings ជា parameter, លុប strings ដែលមានទទឹងមិនស្មើពីវា, និងត្រឡប់ vector ដែលទទួលបានដោយបញ្ជាដែលរៀបចំបែបនេះ, Vector នេះជា vector នៃ strings ហើយមិនដែលជា vector នៃលេខ, ហើយវាអាចមានផ្ទុក duplicates. បញ្ជានៃ vector នេះគួរតែឡើងដោយទំហំនៃពាក្យនីមួយៗ ហើយអ្នកគួរតែត្រឡប់ vector ដែលរៀបចំបែបនេះដោយច្បាប់នោះ. ប្រសិនបើពាក្យពីរមានទំហំដូចគ្នា, ត្រូវរៀបចំបែបនេះតាមអក្សរ. Function នេះគួរតែត្រឡប់ vector នៃ strings នៅក្នុងបញ្ជាដែលរៀបចំបែបនេះ. អ្នកអាចគិតថាពាក្យទាំងអស់នឹងមានទំហំដូចគ្នា. ឧទាហរណ៍: >>> list_sort{""}std:: vector<stdstring>{""}stdstring>{""}stdstring"" (a""} (a""} (a""}) (aaa""} (a""} (a""} (a""} (a"" (a""}) (a"" (a""a"" (a""a""a""a) (a""a""a) (a""a""a) (a""a""a""a) (a""a""a""a) (a""a""a""a""a) (a""a""a""a""a""a) (a""a""a""a""a""a""a""a""a""a) (a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// កម្មវិធីសាមញ្ញមួយដែលត្រូវត្រឡប់មកវិញនូវតម្លៃនៃ x ប្រសិនបើ n ជាចំនួនដើម ហើយត្រូវត្រឡប់មកវិញនូវតម្លៃនៃ y បើមិនដូច្នេះទេ ឧទាហរណ៍: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្តល់នូវវ៉ិចទ័រនៃលេខ, ត្រឡប់មកវិញចំនួននៃទីពីរនៃលេខនៅក្នុងវ៉ិចទ័រដែលមិនសាមញ្ញ. មើលរំលងលេខដែលជាអវិជ្ជមានឬមិនមែនជាចំនួនពេញ. >>> double_the_difference (ដក) std::vector<float> (long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference (ដក) std::vector<float> (long) -1, (long) -2, (long) 0}))) (0) >>> double_the_difference (ដក) std::vector<float> (long) -9, (long) -2)))) (81) >>> double_the_difference (ដក) std::vector<float> (long) -0))) (0) ប្រសិនបើវ៉ិចទ័របញ្ចូលគឺទទេ, ត្រឡប់មកវិញ 0.
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ខ្ញុំគិតថាយើងទាំងអស់គ្នាចាំបាននូវអារម្មណ៍នោះ នៅពេលដែលលទ្ធផលនៃព្រឹត្តិការណ៍ដែលរង់ចាំយូរបំផុតត្រូវបានគេដឹង។ អារម្មណ៍និងគំនិតដែលអ្នកមាននៅពេលនោះពិតជាគួរឱ្យកត់សម្គាល់ និងប្រៀបធៀប។ ការងាររបស់អ្នកគឺដើម្បីកំណត់ថាតើមនុស្សម្នាក់បានសន្និដ្ឋានលទ្ធផលនៃលទ្ធផលនៃលទ្ធផលជាច្រើន។ អ្នកត្រូវបានផ្តល់វ៉ិចទ័រពីរនៃលទ្ធផលនិងការប៉ាន់ស្មាននៃរយៈពេលស្មើគ្នា, ដែលក្នុងនោះតារាងនីមួយៗ បង្ហាញលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលលទ្ធផលល
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកនឹងទទួលបានឈ្មោះនៃជម្រើស (ជម្រើស) និងវ៉ិចទ័រនៃការពង្រីក។ ការពង្រីកត្រូវបានប្រើដើម្បីផ្ទុកជម្រើសបន្ថែមទៅក្នុងជម្រើសដូចខាងក្រោម: ចូរ CAP ជាចំនួនអក្សរធំនៅក្នុងឈ្មោះនៃការពង្រីក, ហើយសូម SM ជាចំនួនអក្សរតូចនៅក្នុងឈ្មោះនៃការពង្រីក, ភាពខ្លាំងត្រូវបានផ្តល់ដោយភាគ CAP - SM អ្នកគួរតែស្វែងរកការពង្រីកដ៏ខ្លាំងបំផុតនិងត្រឡប់ទៅជាជម្រើសមួយនៅក្នុងទម្រង់នេះ: ClassName.StrongestExtensionName. ប្រសិនបើមានពីរឬច្រើនការពង្រីកដែលមានភាពខ្លាំងដូចគ្នា, អ្នកគួរតែជ្រើសរើសមួយដែលកើតឡើងមុននៅក្នុង vector. ឧទាហរណ៍ប្រសិនបើអ្នកត្រូវបានផ្តល់ ""Slices"" ជាជម្រើសនិងវ៉ិចទ័រនៃការពង្រីក: ['SErviSliNGCes',' Cheese', 'StufedF'] បន្ទាប់មកអ្នកគួរតែត្រឡប់ទៅ 'Slices.SErviSliNGCes':::::: mySliNGCes:: mySliNGCes:: mySliNGCes:: mySliNGCes:: mySliNGC:: mySliNGC:: mySliNGC:: myS:: mySliNGC:: mySliNGC:: myS:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest:: strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strongest::strong
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបញ្ជូនពាក្យ true ប្រសិនបើពាក្យទីពីរ ឬការដងខ្លួនណាមួយរបស់វាជាខ្សែសង្វាក់នៅពាក្យដំបូង >>> cycpattern_check((""abcd""), (""abd"")) (false) >>> cycpattern_check((""hello""), (""ell"")) (true) >>> cycpattern_check(""whassup""), (""psus"")) (false) >>> cycpattern_check((""abab""), (""baa"")) (true) >>> cycpattern_(check""efef""), (""eeff"") cy (false) >>> cycpattern_check((""himens""), (""simen"") (true)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ផ្តល់នូវចំនួនគត់. return a tuple ដែលមានចំនួនគត់និងគត់ជារៀងរាល់ឧទាហរណ៍: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់ចំនួនគត់វិជ្ជមាន, ទទួលបានលេខរ៉ូម៉ាំងស្មើនឹងវាជាខ្សែមួយ, ហើយបញ្ជូនវាទៅក្នុងអក្សរតូច: 1 <= num <= 1000 ឧទាហរណ៍: >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426)) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់នូវប្រវែងនៃភាគីទាំងបីនៃត្រីកោណ. ត្រឡប់ទៅ true ប្រសិនបើភាគីទាំងបីបង្កើតជាត្រីកោណទទឹង, false បើមិនដូច្នេះទេ. ត្រីកោណទទឹងគឺជាត្រីកោណដែលមានទទឹងមួយគឺទទឹងទទឹងឬ 90 ដឺក្រេ. ឧទាហរណ៍: >>> right_angle_triangle (((3), (4), (5)) (true) >>> right_angle_triangle (((1), (2), (3)) (false)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// សរសេរមុខងារដែលទទួលយក vector នៃ strings. Vector មានពាក្យផ្សេងគ្នា. ត្រឡប់ពាក្យដែលមានចំនួនអតិបរមានៃតួឯកតែមួយ. ប្រសិនបើ strings ច្រើនមានចំនួនអតិបរមានៃតួឯកតែមួយ, ត្រឡប់ទៅមួយដែលមកមុនក្នុងលំដាប់ lexicographical. >>> find_max((std:: vector<std::string>({(std::string) ""name"", (std::string) ""of"", (std::string) ""string""}))) (""string"") >>> find_max{(std:: vector<std::string>({(std::string) ""name"", (std::string) ""enam"") >>> find_max{(std::vector<std::string>""game""} (""enam"")))) >>> find_max{(std:: vector<std>{((stdaaaaaaaaaaa""}"", (std::string) ""bbbb"" (""string""): ""string""))
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកជាចង្ក្រានដែលឃ្លាន ហើយអ្នកបានបរិភោគគ្រាប់ស្វាយមួយចំនួនហើយ ប៉ុន្តែឥឡូវនេះអ្នកត្រូវការបរិភោគគ្រាប់ស្វាយច្រើនទៀតដើម្បីបញ្ចប់អាហារក្នុងមួយថ្ងៃ អ្នកគួរតែត្រឡប់មកវិញនូវ vector នៃ [ចំនួនសរុបនៃគ្រាប់ស្វាយដែលបរិភោគបន្ទាប់ពីអាហាររបស់អ្នកចំនួនគ្រាប់ស្វាយដែលនៅសល់បន្ទាប់ពីអាហាររបស់អ្នក ] ប្រសិនបើគ្មានគ្រាប់ស្វាយដែលនៅសល់គ្រប់គ្រាន់ទេ, អ្នកនឹងបរិភោគគ្រាប់ស្វាយទាំងអស់ដែលនៅសល់, ប៉ុន្តែនៅតែឃ្លាន។ ឧទាហរណ៍: >>> បរិភោគ((5), (6), (10)) (std:: vector<long>{(()11, (long) 4})) >>> បរិភោគ ((4), (8), (9) (std:: vector<long>{()12, ( () 1})) បរិភោគ ((1), (10), (10) (std:: vector<long>{() 11, ()) ((0)) បរិភោគ ((2), (11), (5) (std:: vector<<long>7, (() 0)) @number: int number of remaining carrots you need to eat in stock: 1000 *constrain: 0 = 0 *number of int numbers you need to eat: 1000 *number of carrots in stock: 0 *number of int = <= 1000 *number of int numbers that you need to eat: 1000 *constrain stock: 0 = number of int = number of carrots you need to eat: 1000 *number of int = number of int = number of carrots in stock: 1000 *constrain stock: 0
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ការផ្តល់ពីរ vectors operator, និង operand. Vector ដំបូងមានប្រតិបត្តិការ algebra មូលដ្ឋាន, និង vector ទីពីរគឺជា vector នៃ integer. ប្រើ vector ពីរដែលផ្តល់ឱ្យដើម្បីសាងសង់ពាក្យ algebraic និងត្រឡប់ទៅការវាយតម្លៃនៃពាក្យនេះ. ប្រតិបត្តិការ algebra មូលដ្ឋាន: ការបន្ថែម (+ ) ការកាត់ ( ) - ការចង ( * ) ការបែងចែកជាន់ ( // ) ការពង្រីក ( **) ឧទាហរណ៍: operator['+', '*', '-'] vector = [2, 3, 4, 5] លទ្ធផល = 2 + 3 * 4 - 5 => លទ្ធផល = 9 កត់សម្គាល់: ប្រវែងនៃ vector operator គឺស្មើនឹងប្រវែងនៃ vector operand minus មួយ. Operand គឺជា vector នៃ integer ដែលមិនមែនជាអវិជ្ជមាន។ operator vector មានយ៉ាងហោចណាស់មួយ operator, និង vector operand មានយ៉ាងហោចណាស់ពីរ operands ។
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// អ្នកត្រូវបានផ្តល់នូវ string s. ប្រសិនបើ s[i] គឺជាអក្សរមួយ, សូមបកប្រែ case របស់វាពីខាងក្រោមទៅខាងលើឬ vice versa, បើមិនដូច្នេះទេទុកវាដូចដែលវាមាន។ ប្រសិនបើ string គ្មានអក្សរ, សូមបកប្រែ string នេះ។ មុខងារនេះគួរតែត្រឡប់មកវិញ string ដែលទទួលបាន។ ឧទាហរណ៍ >>> solve((""1234"")) (""4321"") >>> solve(""ab"")) (""AB"") >>> solve(""#a@C"")) (""#A@c"")
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ប្រសិនបើបានផ្តល់នូវខ្សែ 'text', សូមត្រឡប់ទៅវិញខ្សែស្មើនឹង md5 របស់វា។ ប្រសិនបើ 'text' គឺជាខ្សែសូន្យ, ត្រឡប់មកវិញ None. >>> string_to_md5 ((((""Hello world"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,khm_Khmr,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ដោយបានផ្តល់ចំនួនគត់វិជ្ជមានចំនួន a និង b, សូមបញ្ជូនលេខគត់រវាង a និង b, ដោយបញ្ជាឡើងទៅ។ ឧទាហរណ៍: >>> generate_integers (((2), (8)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8})) >>> generate_integers (((8), (2)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8})) >>> generate_integers (((10), (14)) (std::vector<long> ((())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
