task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بزانە لە ویکتیۆری ژمارە دیاریکراوەکاندا، ئایا دوو ژمارە لە یەکتر نزیکترن لە خاڵی دیاریکراو. >>> has_close_elements (((std::vector<float> ((({(float) 1.0f, (float) 2.0f, (float) 3.0f})), (0.5f)) (درۆیە) >>> has_close_elements (((std::vector<float> (((float) 1.0f, (float) 2.8f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f})), (0.3f)) (ڕاست)
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەم فانکشنە stringێکە کە چەندین گروپی parentheses ی نیشتەجێیە. ئامانجتان ئەوەیە کە ئەو گرووپانە دابەشی بکەیت بۆ چەند stringێکی جیاواز و ڤێکتەری ئەوانیش بگێڕیتەوە. گرووپەکانی جیا لە یەکتر هاوسەنگیان هەیە (هەر braceێک بە باشی داخراوە) و لە ناو یەکتریدا نیشتەجێ نین. هیچ بۆشاییەک لە string دا پشتگوێ بخە. >>> separate_paren_groups (((""( ) (() (()))))))) (std::vector<std::string> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێی ژمارەی پۆزەتیڤی پلە و پایە، دەکرێت دابەش بکرێت بۆ بەشی تەواوی (بزرگترین ژمارەی تەواو کە لە ژمارە دیاریکراو بچوکترە) و دەیە (بەشی پاشماوەی هەمیشە لە ١ بچوکترە). بەشی دەیە لە ژمارەکە بگەڕێنێتەوە. >>> truncate_number((3.5f)) (0.5f)
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ ڤێکتۆرێکی دانان و دەرهێنانی کارەکانتت پێ دەدرێت لەسەر هەژمارێکی بانکی کە بە سفر دەست پێ دەکات. ئەرکەکەت ئەوەیە کە بزانیت ئەگەر لە هەر خاڵێکدا باڵانسی هەژمارەکە دابەزێت لە ژێر سفر، و لەو خاڵەدا دەبێت فانکشنەکە راست بێت. ئەگەر نا دەبێت بە درۆزن بگەڕێتەوە. >>> below_zero(((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بۆ ڤێکتەرێکی دیاریکراوی ژمارە دەرکەوتە، تێکڕای لادان لە ناوەڕاستی ئەم داتاسێتە حیساب بکە. تێکڕای لادان لە ناوەڕاستی نێوان هەر توخمێک و خاڵی ناوەندی (بە ناوەڕاستی ئەم حاڵەتە): MAD = ٠ x - x_mean ٠ >>> mean_absolute_deviation (((std::vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ژمارەیەک 'دابەشکەر' لە نێوان هەر دوو توخمی یەک لە دوای یەک لە ڤێکتەری دەرچوون `numbers' >>> intersperse((std::vector<long>() ، (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1، (long) 2، (long) 3}) ، (4)) (std::vector<long>({long) 1، (long) 4، (long) 2، (long) 4، (long) 3})
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەم فانکشنە لەڕێگەی ستێرینگێکەوە چەندین گروپی بۆ قۆچکەی ناوە کە بە بۆشایی لێک جیا کراون. بۆ هەر گروپێک، قووڵترین ئاستی قۆچکەی ناوە دەربکە. بۆ نموونە (() (()) زۆرترین دوو ئاستی قۆچکەی هەیە لەکاتێکدا ((())) سێ ئاستی هەیە. >>> parse_nested_parens ((((((()) ((())) () (((()))))) (std::vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فلتەرکردنی ڤێکتۆری دەرھێنانی ڕیزەکان تەنها بۆ ئەوانەی کە ڕیزێکی ژێر ڕیزیان ھەیە >>> filter_by_substring((std::vector<std::string>() ، (""a"")) (std::vector<std::string>()) >>> filter_by_substring(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""}) ، (""a"") (std::vector<std::string>({(std::string) abc"", (std::string) ""bacd"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بۆ ڤێکتەرێکی دیاریکراوی ژمارە تەواوەکان، کۆپێک بدەرەوە کە پێکهاتووە لە کۆکردنەوەو بەرھەمێکی هەموو ژمارە تەواوەکان لە ڤێکتەرێکدا. کۆکردنەوەی بەتاڵ دەبێت یەکسان بێت بە 0 و بەرھەمە بەتاڵەکە دەبێت یەکسان بێت بە 1. >>> sum_product (((std::vector<long>())) (std::make_tuple ((0, 1)) >>> sum_product (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple ((10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لە ڤێکتەرێکی دیاریکراوی ژمارە تەواوەکانەوە، ڤێکتەرێک دروست بکە بۆ زۆرترین توخمی ڕولینگ تا ئەو کاتەی لە زنجیرەکەدا دۆزراوەتەوە. >>> rolling_max ((((std::vector<long> (((long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long> (((long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// کورتترین پالێندۆم بدۆزەرەوە کە بە زنجیرەیەکی دابینکراو دەست پێدەکات. بیرۆکەى ئەلگۆریتمەکە سادەیە: - درێژترین پاشگرە بۆ زنجیرە دابینکراو بدۆزەرەوە کە پالێندۆم بێت. - پێچەوانەى پێشگرە بۆ زنجیرە زیاد بکە کە پێش پاشگری پالێندۆمەکە دێت. >>> make_palindrome ((("""")) ("""") >>> make_palindrome (((""cat"")) (""catac"") >>> make_palindrome (((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دەرچوون دوو ڕیزە a و b کە تەنها لە 1 و 0 پێکهاتوون. ئەنجامدانی دووانەی XOR لەسەر ئەم دەرچوونە و گەڕانەوەی ئەنجامەکە وەک ڕیزێک. >>> string_xor((""010""), (""110"")) (""100"")
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لە دەرگای ڤێکتەری ڕیزەکان، درێژترین ڕیزەکە بگەڕێنەوە. یەکەم ڕیزەکە بگەڕێنەوە لە حاڵەتی بوونی چەند ڕیزێکی هەمان درێژی. نەگەڕان لە حاڵەتی ڤێکتەری دەرچوون بەتاڵ بێت. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest(((std::vector<std::string>{(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest(((std::vector<std::string>({(std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەڕاندنەوەی گەورەترین دابەشکاری گشتی دوو ژمارەی تەواو a و b >>> گەورەترین_ دابەشکاری_ گشتی (((3) ، (5)) (1) >>> گەورەترین_ دابەشکاری_ گشتی (((25), (15)) (5)
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ڤێکتۆری گەڕانەوەی هەموو پێشگرەکان لە کورتترینەوە بۆ درێژترین لە زنجیرەی دەرچوون >>> all_prefixes (((""abc"")) (std::vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// زنجیرەیەک دەگەڕێنێتەوە کە ژمارەکانی بۆشاییی بۆ دیاریکراو لە 0 تا n دەست پێدەکات. >>> string_sequence((0)) (""0"") >>> string_sequence((5)) (""0 1 2 3 4 5"")
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لە زنجیرەیەکدا، بزانە چەند کارەکتەرێکی جیاواز هەیە (بێ گوێدانە پلە و پلە) لە: >>> count_distinct_characters (((""xyzXYZ"")) (3) >>> count_distinct_characters (((""Jerry"")) (4)
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەم فانکشنە بریتییە لە ڕیزێک کە نوتی مۆسیقیی لە فۆرماتی ASCII نیشان دەدات. تۆ دەبێت ڕیزەکانی ڕیزەکان لێک بدەیتەوە کە لە چەند لێدانێک پێکهاتووە. لێرەدا تێبینیەک هەیە: 'o' note, lasts four beats 'o 112' - lasts half note, lasts two beats 112' - quater note, lasts one beat >>> parse_music. (((o o o o o o o o o o o o o o o o o o)) (stdvector<(long>{(long) 4, (long) 2, (long) 1, (long) 2, (long) 2, (long) 1, (long) 1, (long) 1, (long) 1, (long) 4, (long) 4})
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بزانە چەند جارێک زنجیرە زیرەکی دیاریکراو لە زنجیرە ڕەسەنەکەدا دەدۆزرێتەوە. ژمارە حاڵەتەکانی یەکترپشتبوون بکە. >>> how_many_times((""""), (""a"")) (0) >>> how_many_times(""aaa""), (""a"")) (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دەرخراو زنجیرەیەکی ژمارە لە 'نۆل' تا 'نۆی' کە بە بۆشاییەوە دیاریکراوە. ھەڵبژاردەکانی گونجاو 'نۆل' ، 'یەک' ، 'دوو' ، 'سێ' ، 'چوار' ، 'پێنج' ، 'شەش' ، ' حەوت' ، 'هەشت' و 'نۆی'ن. زنجیرەکە بە ژمارە ڕیزبکاتەوە لە بچووکترینەوە بۆ گەورەترین >>> sort_numbers (((""سێ یەک پێنج"")) (""یەک سێ پێنج"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لە ڤێکتۆرێکی ژمارە (بە درێژایی لانیکەم دوو) هەڵبژێرە و دوویان بگەڕێنەوە کە نزیکترین یەکترن و بە ڕیز (نەمرکە، گەورەتر) بگەڕێنەوە. >>> find_closest_elements (((std::vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.2f}))) (std::make_tuple (((2.0f, 2.2f)) >>> find_closest_elements (((std::vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f, (float) 2.0f))
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەپێداچوونی ڤێکتەری ژمارەکان (لانیکەم دوو توخم) ، گۆڕینی هێڵی بۆ ئەو ڤێکتەرە جێبەجێ بکە، بەجۆرێک بچووکترین ژمارە دەبێتە 0 و گەورەترین دەبێتە 1 >>> rescale_to_unit (((std::vector<float>(({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f, (float) 5.0f}))) (std::vector<float>({(float) 0.0f, (float) 0.25f, (float) 0.5f, (float) 0.75f, (float) 1.0f}))
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فلتەرکردنی ڤێکتەری دیاریکراوی ھەر بەهایەکی cppthon تەنها بۆ ژمارە تەواوەکان >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>(())))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// درێژایی string >>> string_length ((("""")) (0) >>> string_length (((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بۆ ژمارەیەکی دیاریکراو n، گەورەترین ژمارە بدۆزەرەوە کە n بە یەکسانی دابەش دەکات، کە بچوکترە لە n >>> گەورەترین_بەشیار ((((15)) (5)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ڤێکتۆری گەڕانەوەی فاکتەری یەکەمی ژمارە تەواو دیاریکراو لە ڕیزبەندی بچووکەوە بۆ گەورە. ھەر یەک لە فاکتۆرەکان دەبێ بە ژمارەی جارەکان بکەوێتە فاکتۆری کردنەوە. ژمارەی ھێنان دەبێ یەکسان بێت بە بەرھەمی ھەموو فاکتۆرەکان >>> فاکتۆریزەکردنی (((8)) (std::vector<long>({(long) 2, (long) 2, (long) 2})) >>> فاکتۆریزەکردنی (((25)) (std::vector<long>({(long) 5, (long) 5})) >>> فاکتۆریزەکردنی ((((70)) (std::vector<long>({(long) 2, (long) 5, (long) 7}))
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لە ڤێکتەرێکی ژمارە تەواوەکان، هەموو ئەو توخمانەی کە زیاتر لە جارێک ڕوودەدەن لابدە. ڕیزبەندی توخمەکان وەک ئەوەی لە داھاتندا ھەبووە بە جێ بهێڵەوە. >>> remove_duplicates(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بۆ ڕیزێکی دیاریکراو، کارەکتەرە بچووکەکان بگێڕە بۆ گەورە و گەورە بۆ بچووک. >>> flip_case ((((""Hello"")) (""hELLO"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// پێکهاتەی زنجیرەکان لە یەک زنجیر >>> پێکهاتەی ((((std::vector<std::string>())) ("""") >>> پێکهاتەی (((std::vector<std::string>({(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) (""abc"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فلتەرێک بۆ ڤێکتەری دەرچوون لە ڕیزەکان تەنها بۆ ئەوانەی کە بە پێشەکی دیاریکراو دەست پێ دەکەن. >>> filter_by_prefix((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string) ""cde"", (stdstring) ""array""})), (""a"") (std::vector<std::string>({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تەنها ژمارە پۆزەتیڤەکان لە ڤێکتۆرەکە بگەڕێنەوە. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive((std::vector<long>({long) -5, (long) -3, (long) -5, (long) -5, (long) -2, (long) -3, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەڕاندنەوەی ڕاستە ئەگەر ژمارەیەکی دیاریکراو یەکەم بێت، وە هەڵە ئەگەر نا. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1)) (false)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەم فانکشنە ڤێکتۆرێکی l وەردەگرێت و ڤێکتۆرێکی l' دەگەڕێنێتەوە کە لە ئەو ئاماژانەدا کە بە سێ دابەش ناکرێت، هاوشێوەی l بێت، لە کاتێکدا بەهاکانی لە ئەو ئاماژانەدا کە بە سێ دابەش دەکرێت، یەکسانن بە بەهاکانی ئاماژەکانی هاوپێچەکانی l، بەڵام ڕێکخرێن. >>> sort_third: vector<long>{(long) 1, (long) 2, (long) 3}))) (std: vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third: vector<long>{(long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std vector<(long>{(long>{(long) 2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5}))
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەڕاندنەوەی توخمە یەکجار جیاکراوەکان لە ڤێکتەرێکدا >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// زیادترین توخمی ڤێکتۆر بگەڕێتەوە. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long) -5, (long) 2, (long) -3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ژمارەی ئەو جارانەی ژمارە 7 دەردەکەوێت لە ژمارە تەواوەکاندا کە کەمتر لە n و بە 11 یان 13 دابەش دەکرێت. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەم فانکشنە ڤێکتۆرێکی l وەردەگرێت و ڤێکتۆرێکی l' دەگەڕێنێتەوە کە لە l دا هاوشێوەی l بێت لە هێندێک هێندێک، لە کاتێکدا بەهاکانی لە هێندێک هێندێک بەهاکانی هێندێک هێندێک لە l، بەڵام ڕێکدەخرێن. >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<(long>{((long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib ژمارە n-ی دەگەڕێنێتەوە کە ژمارەیەکی فیبۆنەچییە و ھەروەھا ژمارەیەکی سەرەتاییە. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib((3)) (5) >>> prime_fib((4)) (13) >>> prime_fib(5)) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// triple_sum_to_zero وەک دەرھێنانێک ڤێکتەرێکی تەواوی ژمارە وەردەگرێت. گەر سێ توخمی جیاواز لە ڤێکتەرەکەدا ھەبێت کە کۆیەکەیان بۆ سفر بێت، ئەوا ڕاست دەداتەوە، ئەگەر نا ئەوا ھەڵەیە. >>> triple_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triple_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (true) triple_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) triple_sum_to_zero::vector<long>{long>((((((2, (long) 4, (long) 5, (long) 3, (long) 9, (long)) >>> triple_false))) (true) triple_sum_to_zero))) (long_vector) >>> (long_long)
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// وا بیربکەرەوە کە شەقامێک هێڵێکی بێ کۆتایی درێژە. n ئۆتۆمبێل لە چەپەوە بۆ ڕاست دەجوڵێن؛ هاوکات، کۆمەڵێکی جیاوازی n ئۆتۆمبێل لە ڕاستەوە بۆ چەپ دەجوڵێن. دوو کۆمەڵەی ئۆتۆمبێل لە سەرەتاوە زۆر دوورن لە یەکتر. هەموو ئۆتۆمبێلەکان بە هەمان خێرایی دەجوڵێن. دوو ئۆتۆمبێل بەیەکدادان کاتێک ئۆتۆمبێلێک کە لە چەپەوە بۆ ڕاست دەجوڵێت بە ئۆتۆمبێلێک دەدات کە لە ڕاستەوە بۆ چەپ دەجوڵێت. لەگەڵ ئەوەشدا، ئۆتۆمبێلەکان بێ سنوور بەهێزن؛ لە ئەنجامدا، بەردەوامن لە جوڵان لە ڕێڕەوی خۆیاندا وەک ئەوەی بەیەکدادان نەکەن. ئەم فانکشنە ژمارەی ئەو پێکدادانە دەردەهێنێت.
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ڤێکتۆری گەڕانەوە لەگەڵ توخمەکان زیادکراو بە ١. >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// pairs_sum_to_zero بە ڤێکتەری ژمارە تەواوەکان وەردەگرێت وەک دەرھێنان. گەر دوو توخمی جیاواز لە ڤێکتردا ھەبێت کە بە سفر کۆدەکرێنەوە، وە بە پێچەوانەوە ھەڵە. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long>{long}2, (long) 4, (long) 5, (long) 3, (long) 5, (long) 7))) >>> (false) pairs >>>_sum_to_zero(std::vector<long> (long_long)) >>> (true) pairs >>> (long_long)
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گۆڕینی بنکەی ژمارەیی ژمارەی ھێنان x بۆ بنکە. نوێنەرایەتی زنجیرە گەڕاندنەوە دوای گۆڕین. ژمارەکانی بنکە کەمتر لە ١٠ن. >>> change_base((8), (3)) (""22"") >>> change_base((8), (2)) (""1000"") >>> change_base((7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە درێژی لایەک و بەرزترین ڕووبەری گەڕانەوەی سێگۆشەیەک. >>> triangle_area ((((5), (3)) (7.5f)
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// زنجیرەی ژمارەکانی Fib4 زنجیرەیەکی هاوشێوەی زنجیرەی فیبۆناکسییە کە بەم شێوەیە پێناسە کراوە: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). تکایە فانکشنێک بنووسە بۆ ئەوەی بە شێوەیەکی کارامە ئامێری n-ەم لە زنجیرەی ژمارەکانی fib4 دابنێ. بەکار مەهێنە گەڕانەوەی. >>> fib4((5)) (4) >>> fib4(6)) (8) >>> fib4(7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// میدیانی گەڕانەوەی توخمەکانی ڤێکتەر l. >>> میدیان (((std::vector<long> (((long) 3، (long) 1، (long) 2، (long) 4، (long) 5)))) (float ((3)) >>> میدیان (((std::vector<long> (((long) -10، (long) 4، (long) 6، (long) 1000، (long) 10، (long) 20)))) (15.0f)
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// پشکنینی ئەوەی کە زنجیرە دیاریکراوەکە پالێندرۆمە >>> is_palindrome ((("""")) (true) >>> is_palindrome (((""aba"")) (true) >>> is_palindrome (((""aaaaa"")) (true) >>> is_palindrome (((""zbcd"")) (false)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەڕانەوەی ٢ ^ ن مۆدۆلۆ پی (ئاگادار بە ژمارەکان). >>> مۆدۆلۆ پی (١٠١) ، (١٠١) (٢) >>> مۆدۆلۆ پی (١٠٠) ، (١٠١) (١) >>> مۆدۆلۆ پی (١٠٣) ، (١١) (٨) >>> مۆدۆلۆ پی (١٠٠) ، (١٠١) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels فانکشنێکە کە ڕیزەکان وەردەگرێت و ڕیزەکان بەبێ دەنگەکان دەگەڕێنێتەوە. >>> remove_vowels ((("""")) ("""") >>> remove_vowels (((""abcdef"")) (""bcdf"") >>> remove_vowels (((""aaaaa"")) ("""") >>> remove_vowels (((""aaBAA"")) (""B"") >>> remove_vowels (((""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەڕاندنەوەی ڕاستە ئەگەر هەموو ژمارەکان لە ڤێکتەری l لە ژێر خاڵی t دا بن. >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10}) ، (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10}) ، (5)) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دوو ژمارە زیاد بکە x و y زیاد بکە ((((2) (3)) (5) >>> زیاد بکە ((((5), (7)) (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بزانە کە دوو وشە هەمان کارەکتەریان هەیە. >>> same_chars (((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) (true) >>> same_chars (((""abcd""), (""dddddddabc"")) (true) >>> same_chars (((""dddddddabc""), (""abcd"")) (true) >>> same_chars (((""eabcd""), (""dddddddabc"")) (false) same_chars >>> (((""abcd""), (""dddddddddabce"")) (false) >>> same_chars (((""eabcd""), (""ddddzzzzzdzzdddabc"") (false)
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ژمارە n ی فیبۆنەچی بدەرەوە. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets بریتییە لە زنجیرەی ""<"" و "">"". راست بگەڕێتەوە ئەگەر هەموو قۆڵی کردنەوەی قۆڵی داخستنی هەبێت. >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>"")) (true) >>> correct_bracketing(""<><>"") (true) >>> correct_bracketing("">(<>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەڕانەوە true ئەگەر توخمەکانی ڤێکتەر بە شێوەیەکی تاکڕەوانە زیاد یان کەم دەبن. >>> تاکڕەوانە ((((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20)))) (true) >>> تاکڕەوانە (((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10)) (false) >>> تاکڕەوانە (((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) - 10)) (true)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەڕاندنەوەی توخمە هاوبەشە یەکجار جیاکراوەکان بۆ دوو ڤێکتەر. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// گەورەترین فاکتەری یەکەمی n بدەرەوە. وا دابنێ n > 1 و فاکتەری یەکەم نییە. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// sum_to_n بریتییە لە فانکشنێک کە ژمارەکانی ١ تا n کۆدەکاتەوە. >>> sum_to_n(((30)) (465) >>> sum_to_n((100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets بریتییە لە زنجیرەی ""("" و "")"". گەرەنتی ڕاستە ئەگەر هەموو قۆڵی کردنەوەی قۆڵی داخستنی هەبێت. >>> correct_bracketing (((""("")) (false) >>> correct_bracketing (((""() "")) (true) >>> correct_bracketing (((""(()))) (true) >>> correct_bracketing ((("") ((()) (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs نوێنەرایەتی کۆئەپێکەری پۆڵینۆم دەکات. xs[0] + xs[1] * x + xs[2] * x^2 + .... دەرهاویشتەی ئەم پۆڵینۆمە بە هەمان شێوە بگەڕێتەوە. >>> دەرهاویشتەی ((((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> دەرهاویشتەی (((std::vector<long>({(long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// زنجیرەی ژمارەی فیبۆفیب زنجیرەیەکی هاوشێوەی زنجیرەی فیبۆناکسییە کە بەم شێوەیە پێناسە کراوە: فیبۆفیب () () == 0 فیبۆفیب () () == 0 فیبۆفیب () == 0 فیبۆفیب () == 1 فیبۆفیب () == فیبۆفیب () == == فیبۆفیب () () + فیبۆفیب () () + فیبۆفیب () () () - () تکایە فانکشنێک بنووسە بۆ بە شێوەیەکی کارا ژماردنی توخمی n ی زنجیرەی ژمارەی فیبۆفیب. >>> فیبۆفیب () () () () (0) >>> فیبۆفیب () () () () () (4) >>> فیبۆفیب () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە دەنگە_ژمارە دەکات کە ڕیزێک لە وشەکان وەک دەرچوون وەردەگرێت و ژمارەی دەنگە دەنگەکان لە ڕیزەکە دەداتەوە. دەنگە دەنگەکان لەم حاڵەتەدا 'a' ، 'e' ، 'i' ، 'o' ، 'u' ن. لێرەدا 'y' ھەروەھا دەنگە دەنگە، بەڵام تەنیا کاتێک لە کۆتایی وشەی دیاریکراو بێت. نموونە: >>> vowels_count (((""abcde"")) (2) >>> vowels_count (((""ACEDY"")) (3)
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە شێوەی بازنەیی ژمارە تەواوەکانی x بگوازنەوە، ژمارەکان بگوازنەوە بۆ لای ڕاست بە شێوەی گواستنەوە و ئەنجامەکە وەک زنجیرە بگێڕنەوە. ئەگەر گواستنەوە > ژمارەی ژمارەکان، ژمارەکان بە پێچەوانەوە بگێڕنەوە. >>> circular_shift (((12), (1)) (""21"") >>> circular_shift (((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەرکێک بنووسە کە ڕیزێکی وەک دەرچوون وەردەگرێت و کۆدی ASCII کۆدی سەرەوەی کارەکتەرەکان دەداتەوە. نموونە: >>> digitSum ((("""")) (0) >>> digitSum (((""abAB"")) (131) >>> digitSum (((""abcCd"")) (67) >>> digitSum (((""helloE"")) (69) >>> digitSum (((""woArBld"")) (131) >>> digitSum (((""aAXaaaa"")) (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لەم ئەرکەدا، ستڕێکت پێدەدرێت کە نوێنەرایەتی ژمارەیەک سێو و پرتەقاڵ دەکات کە دابەشکراون لە سەبەتەیەکی میوەدا ئەم سەبەتەیە سێو و پرتەقاڵ و میوە مانگۆیە. بە پێی ئەو ستڕەی کە نوێنەرایەتی کۆی ژمارەی پرتەقاڵ و سێوەکان دەکات و ژمارەیەکی تەواو کە نوێنەرایەتی کۆی ژمارەی میوە دەکات لە سەبەتەکە، ژمارەی میوە مانگۆیەکان لە سەبەتەکە بدەرەوە. بۆ نموونە: >>> fruit_distribution (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// "" بە پێدانی ڤێکتەرێک کە نوێنەرایەتی لقێکی درەخت دەکات کە گرێ ژمارە تەواو نەرێنیەکانی نییە ئەرکی تۆ ئەوەیە کە یەکێک لە گرێەکان هەڵبگرە و بیگەڕێنیتەوە. گرێ هەڵکێشراو دەبێت گرێ بێت بە بچوکترین بەهای جووت. ئەگەر گرێ زۆر بە هەمان بچوکترین بەهای جووت بدۆزرێتەوە گرێ بدرێتەوە کە بچووکترین هێڵی پێناسە هەیە. گرێ هەڵکێشراو دەبێت بدرێتەوە لە ڤێکتەرێک، [smallest_value، هێڵی پێناسەکەی]، ئەگەر هیچ بەهای جووت نەبێت یان ڤێکتەرەکە بەتاڵ بێت، گەڕانەوە []. نموونە 1: >>> pluck(((stdvector<<(long>{(long) {4, (long) {2, (long) {3}))) (stdvector::<(long}}، (long) {0}، (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەھۆی ئەوەی کە ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھێڵی (باک) ی ھڵی (باک) ی ھڵی (باک) ی ھڵی (باک) ی ھڵی (باک) ی ھڵی (باک) ی ھڵی (باک) ی ھڵی (باک) ی ھێڵ (باک) ی ھێڵ (باک) ی ھێڵ (باک) ی ھێڵ (باک) ی ھێڵ (باک) ی ھێڵ (باک) ھێڵ (باک) ھێڵ (باک) ھێڵ (باک) ھێڵ (باک) ھێڵ (باک) ھێڵ (باک) ھێڵ (ھەڵک (ھ (ھ) ھێڵک) ھێڵک (ھ (ھ)
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەپێپێداچوونی ویکتیۆری تەواو، ڤێکتەری گەڕانەوەی بە ڕیزێکی نامۆ. ڕیزکردنی نامۆ، کاتێکە کە بە کەمترین بەها دەستپێدەکەیت، پاشان زۆرترین ژمارەی تەواوەکانی تر، پاشان کەمترین و هتد. نموونەکان: >>> strange_sort_list{((std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list{(std::vector<long>{(long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5, (long) 5}))) >>> strange_sort_list<(vector::(long> (std::(long))
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی درێژی سێ لای سێگۆشەیەک. ڕووبەری سێگۆشەکە بگێڕێتەوە بە دو خاڵی دوازدەهەم ئەگەر سێ لایەکە سێگۆشەیەکی دروست دروست بکەن. ئەگەر نا بگێڕێتەوە -1 سێ لایەکە سێگۆشەیەکی دروست دەکەن ئەگەر کۆی هەر دوو لایەکە گەورەتر بێت لە لای سێیەم. نموونە: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە راست دەداتەوە ئەگەر ئۆبجێکت q بفڕێت، وە هەڵە ئەگەر نا. ئۆبجێکت q بفڕێت ئەگەر هاوسەنگی هەبێت (ڤێکتۆرێکی پالندرومیە) و کۆی توخمەکانی کەمتر بێت یان یەکسان بێت بە زۆرترین کێشە گونجاو w. نموونە: >>> will_it_fly((std::vector<long>({long) 1، (long) 2}) ، (5)) (false) # 1+2 کەمتر لە زۆرترین کێشە گونجاو، بەڵام هاوسەنگی نییە. >>> will_it_fly((std::vector<long>((long) 3، (long) 2، (long) 3}) ، (1) (false) # هاوسەنگی هەیە، بەڵام 3+2+3 زیاترە لە زۆرترین کێشە گونجاو. >>> will_fly_((std::vector<long>{(long) 3، (long) 2، (long) 3}) ، (9) (true) # 3+2، (3) زۆرترین کێشە گونجاو، بەڵام کەمترە لە زۆرترین کێشە گونجاو، و (5) (long_it_(true) # 3، (long) و (3):
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەی تەواو لە ڤێکتەر، کەمترین ژمارەی ئەو توخمانە بدۆزەرەوە کە پێویستە بگۆڕدرێن بۆ ئەوەی ڤێکتەرەکە پالێندرۆمی بێت. ڤێکتەرێکی پالێندرۆمی ئەو ڤێکتەرەیە کە بە هەمان شێوە دەخوێندرێتەوە بۆ دواوە و بۆ پێشەوە. لە یەک گۆڕانکاری دا، دەتوانیت یەک توخم بگۆڕیت بۆ هەر توخمێکی تر. بۆ نموونە: >>> smallest_change(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 3, (long) 2, (long) 2} (1)))) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1)))
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە دوو ڤێکتەری ڕیزەکان قبوڵ بکات و ئەو ڤێکتەری بگەڕێنێتەوە کە کۆی ژمارەی کارەکانی لە هەموو ڕیزەکانی ڤێکتردا کەمتر بێت لە ڤێکتەری تر. ئەگەر دوو ڤێکتەر هەمان ژمارەی کارەیان هەبێت، یەکەم ڤێکتەری بگەڕێنێتەوە. نموونە >>> total_match ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({}): vector ({) {) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) (}) ({) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (}) (} (}) (}) (}) (}) (}) (}) (}) (} (}) (}) (}) (}) (} (}) (}) (}) (}) (}) (}) (}) (}) (} (}) (}) (} (}) (}) (}) (} (}) (}) (}) (}) (} (}) (}) (}) (} (}) (}) (} (}) (}) (} (}) (} (}) (}) (}) (} (} (}) (}) (}) (}) (} (}) (} (}) (})
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە راست بێت گەر ژمارە دیاریکراوەکە لێکدانەوەی 3 ژمارەی سەرەتایی بێت و بە پێچەوانەوە هەڵە بێت. بە زانینی ئەوەی (a) کەمتر لە 100ە. نموونە: >>> is_multiply_prime((30)) (true) 30 = 2 * 3 * 5
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەرکەکەت ئەوەیە کە فانکشنێک بنوسیت کە راست دەداتەوە ئەگەر ژمارە x ببێتە توانایەکی سادە بۆ n و هەڵە لە حاڵەتەکانی تر. x توانایەکی سادە بۆ n ئەگەر n**int=x بۆ نموونە: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە ژمارەیەکی تەواو a وەردەگرێت و راست دەداتەوە ئەگەر ئەم ingeger سێگۆشەی ژمارەیەکی تەواو بێت. تێبینی: تۆ لەوانەیە وا دابنێیت کە دەسپێک هەمیشە دروستە. نموونە: >>> iscube (((1)) (true) >>> iscube (((2)) (false) >>> iscube (((-1)) (true) >>> iscube (((64)) (true) >>> iscube (((0)) (true) >>> iscube (((180)) (false)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەرکێکت پێ دراوە بۆ نووسینی فانکشنێک کە ژمارەیەکی شەشدەسیمەل وەردەگرێت وەک زنجیرە و ژمارەی ئەو ژمارانە هەژمار دەکات کە ژمارە سەرەتاییەکانن (ژمارەی سەرەتایی، یان ژمارەیەکی سەرەتایی، ژمارەیەکی سروشتییە کە گەورەترە لە 1 کە بەرهەمی دوو ژمارەی سروشتی بچووکتر نییە). ژمارە شەشدەسیمەلەکان بریتییە لە 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. ژمارە سەرەتاییەکان بریتییە لە 2, 3, 5, 7, 11, 13, 17,... بۆیە دەبێت ژمارەیەک لە ژمارە سەرەتاییەکانی خوارەوە دیاری بکەیت: 2, 3, 5, 7, B (=چواردەسیمەل 11), D (=چواردەسیمەل 13). تێبینی: لەوانەیە وا دابنێیت کە دەسپێردراوەکە هەمیشە ڕاست یان بەتاڵە، و هێماکانی A,B,C,D,E,F هەمیشە گەورەن. نموونە: >>> hex_((AB""key"") >>> (1) hex_(((10""E77"") (2) hex >>>""AB""_(1"") >>>ABC"" (4) hex_33"") >>>ABC""((20"" (67) >>>12"" ((DEFF) >>> ((0"")
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ژمارەیەک بە شێوەی دەیەمیانەی پێ دەدرێت و ئەرکی تۆ گۆڕینییە بۆ فۆرماتی دووانەیی. فانکشنەکە دەبێت زنجیرەیەک بگەڕێنێتەوە، لەگەڵ هەر کارەکتەرێک کە نوێنەرایەتی ژمارەیەکی دووانەیی دەکات. هەر کارەکتەرێک لە زنجیرەکە دەبێت '0' یان '1'. دوو کارەکتەرێکی زیادەی 'db' لە سەرەتاو کۆتایی زنجیرەکە دەبێت. کارەکتەرە زیادەکان بۆ یارمەتیدانی فۆرماتە. نموونە: >>> decimal_to_binary (((15)) (""db1111db"") >>> decimal_to_binary (((32)) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// string sت پێ دراوە ئەرکی تۆ ئەوەیە کە پشکنین بکەیت ئایا stringەکە hapcppیە یان نا. stringێک hapcppیە ئەگەر درێژییەکەی لانیکەم 3 بێت و هەر 3 پیتی یەک لە دوای یەک جیاواز بن بۆ نموونە: >>> is_happy((""a"")) (false) >>> is_happy(""aa"")) (false) >>> is_happy((""abcd"")) (true) >>> is_happy((""aabb"")) (false) >>> is_happy(""adb"")) (true) >>> is_happy((""xyy"") (false)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەمە دوا هەفتەی وەرزە و مامۆستاکە دەبێت نمرەکان بدات بە قوتابییەکان. مامۆستاکە ئەلیگۆریتمێکی خۆی بۆ نمر دانان دروستکردووە. تەنها کێشەکە ئەوەیە کە ئەو کۆدە لەدەستداوە کە بۆ نمر دانان بەکاریهێناوە. ئەو ڤێکتەرێکی نمرەی GPA ی بۆ هەندێک قوتابی داوە و دەبێت فانکشنێک بنووسیت کە دەتوانێت دەرکردنی ڤێکتەرێک لە نمرەی پیتی بەکاربهێنێت بەم خشتەیەی خوارەوە: GPA. نمرەی پیتی 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E نموونە: >>>_grade_equation
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە زنجیرە دەنێت و راست دەداتەوە ئەگەر درێژایی زنجیرەکە ژمارەیەکی سەرەتایی بێت یان هەڵە ئەگەر نا نموونە >>> prime_length (((""Hello"")) (true) >>> prime_length (((""abcdcba"")) (true) >>> prime_length (((""kittens"")) (true) >>> prime_length (((""orange"")) (false)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی پۆزەتیڤ n، ژمارەی ژمارە پۆزەتیڤەکانی n-چەندەم گەڕانەوەیە کە بە 1 دەست پێ دەکەن یان کۆتایی دێنن.
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی پۆزەتیڤ N، کۆی گشتیی ژمارەکانی بە دووای بدەرەوە. نموونە >>> چارەسەر (((1000)) (""1"") >>> چارەسەر (((150)) (""110"") >>> چارەسەر (((147)) (""1100"") گۆڕاوەکان: @N ژمارە تەواوەکان سنووردارەکان: 0 ≤ N ≤ 10000. دەرچوون: زنجیرەیەک لە ژمارە دووایەکان
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێدانی ڤێکتۆرێکی پووچ لە ژمارە تەواوەکان lst. زیادکردنی ئەو توخمە جووتانەی کە لە هێندەکانی نامۆدان.. نموونە: >>> add((std::vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە ڕیزێک وەردەگرێت و وەشانێکی ڕیزکراوەی دەگەڕێنێتەوە. وەشانێکی ڕیزکراوەی ڕیز، ڕیزێکە کە هەموو وشەکان (بە بۆشایی جیاکراو) بە وشەیەکی نوێ جێدەخرێتەوە کە هەموو کارەکتەرەکان بە ڕیزێکی بەرزبوونەوە ڕیزکراون بە پشتبەستن بە بەهای ascii. تێبینی: پێویستە ڕیزبەندی وشەکان و بۆشاییە بەتاڵەکان لە ڕستەدا بپارێزن. بۆ نموونە: >>> anti_shuffle((""Hi"")) (""Hi"") >>> anti_shuffle(((""hello"")) (""ehllo"") >>> anti_shuffle""((Hello World!!)) (""Hello !!!Wdlor"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// داتایەکی دوو ڕەهەندی پێدراوە، وەک ڤێکتەرێکی نێچیرکراو، کە هاوشێوەی ماتریکسە، بەڵام بە پێچەوانەی ماتریکسەکان، ھەر ڕیزێک لەوانەیە ژمارەیەکی جیاوازی ستوون لەخۆبگرێت. بە پێی lst و integer x، دۆزینەوەی ژمارە تەواوی x لە ڤێکتەردا، و گەڕانەوەی ڤێکتەری tuples، [(x1, y1), (x2, y2) ...] بە جۆرێک کە ھەر tupleێک کۆئوردیناتێکی - (ڕیز، ستوون) ، دەستپێدەکات بە 0. ڕێکخستنی کۆئوردیناتەکان سەرەتا بە ڕیزەکان بە ڕیزێکی بەرزبوونەوە. ھەروەھا ڕێکخستنی کۆئوردیناتەکانی ڕیزەکان بە ستوون بە ڕیزێکی نزمبوونەوە. نموونە: >>> get_row(std::vector<std::vector<>>>> (long) {long) {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long} {long}{long}{long}{long}long}long {long}long}long {long}long {long}long}long {long}long {long}long}long {long}long {long}long}long {long}long {long}long}long {long}long {long}long}long {long}long {long}long}long {long}long {long}long}long {long}long}long {long}long {long}long}long {long}long}long {long}long {long}long}long {long}long {long}long}long {long}long}long {long}long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} long {long} {long} {long} long {long} long} long {long} {long} {long
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەپێدانی ڤێکتەرێک لە ژمارە تەواو نەرێنیەکان، گەڕانەوەی کۆکپپێک لە ڤێکتەرەکە دوای ڕێکخستن، ئەوا ڤێکتەرەکە بە ڕیزێکی بەرز دەبێتەوە ئەگەر کۆکراوەکەی (((بەهای یەکەمی هێما، بەهای کۆتا هێما) نامۆ بێت، یان بە ڕیزێکی نزم دەبێتەوە ئەگەر کۆکراوەکەی (((بەهای یەکەمی هێما، بەهای کۆتا هێما) جووت بێت. تێبینی: * نەگۆڕی ڤێکتەری دیاریکراو. نموونەکان: >>> sort_array (((std::vector<long>())) (std::vector<long>)) >>> sort_array (((std::vector<long>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە ڕیزێکی وەک ئەرگۆمێنت وەربگرێت و ڕیزێکی شفرە کراو لەگەڵ ئەلفوبێدا بگەڕێنێتەوە. ئەلفوبێدە دەبێت بە جۆرێک بگۆڕدرێت کە پیتەکان بە دوو هێندە بۆ دوو جێگا بچێتە خوارەوە. بۆ نموونە: >>> encrypt((""hi"")) (""lm"") >>> encrypt(((""asdfghjkl"")) (""ewhjklnop"") >>> encrypt((""gf"")) (""kj"") >>> encrypt((""et"")) (""ix"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەھۆی ئەوەی کە لە ھەندێک لە ھەندەکانی ھەندەکان دا ھەندێکی کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەن، ھەندێکی زۆر کەمی ھەندەکان ھەندێک ھەندێک ھەند ھەیە، ھەندێکی زۆر کەمی ھەندەکان ھەندێک ھەند ھەیە، ھەندێکی زۆر ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەند ھەیە، ھەندێک ھەندێک ھەند ھەیە، ھەندێک ھەندێک ھەند ھەیە، ھەندێک ھەندێک ھەندێک ھەند ھەیە، ھەندێک ھەندێک ھەندێک ھەند ھەیە، ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھەندێک ھ
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ زنجیرەیەک وشەت پێ دەدرێت، و ئەرکی تۆ ئەوەیە کە ژمارەی بێزارییەکان هەژمار بکەیت. بێزارییەک ڕستەیە کە بە وشەی ""من"" دەست پێ دەکات. ڕستەکان بە '.', '?' یان '! 'دا سنووریان بۆ دەکرێت. بۆ نموونە: >>> is_bored (((""سڵاو جیهان"")) (0) >>> is_bored (((""ئاسمان شینە. خۆر دەدرەوشێتەوە. من ئەم کەشوهەواشم خۆشدەوێت"")) (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە ٣ ژمارە وەردەگرێت. گەر یەکێک لە ژمارەکان یەکسان بێت بە کۆی دوو ژمارەکەی تر، و هەموو ژمارەکان ژمارە تەواو بن. گەر لە هەر حاڵەتێکی تر هەڵە بێت. نموونە >>> any_int{(float{(5)), (float{(2)), (float{(7))) (true) >>> any_int{((float{(3)), (float{(2)), (float{(2))) (false) >>> any_int{(float{(3)), (float{(-2)), (float{(1))) (true) >>> any_int{(((3.6f), (-2.2f), (float{(2))) (false)
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە پەیامێک وەربگرێت و کۆد بکات بە جۆرێک کە هەموو پیتەکان بگۆڕێت و هەموو دەنگەکان لە پەیامەکەدا بگۆڕێت بە پیتێک کە دوو جێگای لە پێش ئەو دەنگە لە ئەلفوبێی ئینگلیزی دا دەردەکەوێت. تەنها پیتەکان دابنێ. نموونە: >>> encode (((""test"")) (""TGST"") >>> encode (((""This is a message"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەھۆی ئەوەی کە لە ھەندێک ھەنددا ھەندێک ھەند ھەیە، پێویستە بەھای سەرەکیی ھەرە گەورە بدۆزیتەوە و کۆی ھەرە گەورەکەی بدەیتەوە. نموونە: >>> skjkasdkd((std::vector<long>(((long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) ٠، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەگەر نەخشەیەک بدرێت، راست بگەڕێتەوە ئەگەر هەموو کلیلەکان زنجیرە بن لە پیتی بچووک یان هەموو کلیلەکان زنجیرە بن لە پیتی گەورە، ئەگەر نا هەڵە بگەڕێتەوە. فانکشنەکە دەبێت هەڵە بگەڕێتەوە ئەگەر نەخشەکە بەتاڵ بێت. نموونە: >>> check_dict_case ((((std::map<std::string,std::string>(({{""a"", ""apple""}, {""b"", ""banana""}}))) (true) >>> check_dict_case ((((((std::map,std::string>{{""a"", ""apple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) (false) >>> check_dict_case (((map:std::string, {{""a"", ""apple""}, {""banana""}, {""a"", {""a"", {""apple""}, {""apple""}:<std::string>, {""a"", ""apple""}, {""apple""}:std::string, {""a"", ""apple""}:std::string)) (هاوستنستن، ""{""a"", ""apple""}، ""{""std:std:std:std::string}، ""{""std:std:std:std:std:std:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st:st
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک جێبەجێ بکە کە ژمارەیەکی تەواو نەرێنی وەرگرێت و ڤێکتۆرێک لە یەکەم n ژمارە تەواوەکان دەداتەوە کە ژمارە سەرەتاییەکانن و کەمتر لە n. بۆ نموونە: >>> count_up_to((5)) (std::vector<long>{(long) 2, (long) 3})) >>> count_up_to(11)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7})) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 17)) >>> count_up_1) (std::vector<long>> (count_up_to_8) (std:vector<long>{(long)) 3, (long) 5, (long)) (long) 11, (long) 1, (long)) (long) 2, (long)) (long)
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنەکە تەواو بکە کە دوو ژمارە تەواو وەردەگرێت و بەرهەمی یەکەی ژمارەکانی دەداتەوە. وا دابنێ کە دەرچوونەکە هەمیشە دروستە. نموونە: >>> لێکدانەوە (((148), (412)) (16) >>> لێکدانەوە (((19), (28)) (72) >>> لێکدانەوە (((2020), (1851)) (0) >>> لێکدانەوە (((14), (-15)) (20)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ڕیزێک s، ژمارەی دەنگی گەورە لە هێماکانی جووتدا هەژمار بکە. بۆ نموونە: >>> count_upper (((""aBCdEf"")) (1) >>> count_upper (((""abcdefg"")) (0) >>> count_upper (((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە بەها (سترینگ) ێکی ژمارە وەردەگرێت و نزیکترین ژمارەی تەواو بۆ دەگەڕێنێتەوە. ئەگەر ژمارەکە لە دوو ژمارەی تەواو دوور بێت، ئەوا لە سفرەوە دەوری بکە. نموونە >>> closest_integer (((""10"")) (10) >>> closest_integer (((""15.3"")) تێبینی (15): دەوری کردن لە سفر واتە ئەگەر ژمارە دیاریکراوەکە لە دوو ژمارەی تەواو دوور بێت، ئەوا ئەو ژمارەیە کە دوورترە لە سفر دەگەڕێتەوە. بۆ نموونە closest_integer (((""14.5"") دەبێت ١٥ و closest_integer ((-14.5"") دەبێت ١٥-١٥ بگەڕێتەوە.
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی پۆزەتیڤ n، دەبێت کۆپێک لە n ئاستی بەرد دروست بکەیت. یەکەم ئاست n بەردی هەیە. ژمارەی بەردەکان لە ئاستی دواتر بریتییە لە: - ژمارەی نامۆ ئەگەر n نامۆ بێت. - ژمارەی جووت ئەگەر n جووت بێت. ژمارەی بەردەکان لە هەر ئاستێک لە ڤێکتەرێک بدەرەوە، کە توخمی لە هێڵی i ژمارەی بەردەکانی ئاستی (i+1) ی پێناسە دەکات. نموونە: >>> make_a_pile((3) (std::vector<long>{long) 3, (long) 5, (long) 7}))
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ زنجیرەیەک وشەت پێ دەدرێت کە بە خاڵە یان بۆشایی لێک جیا کراونەتەوە. ئەرکی تۆ ئەوەیە کە زنجیرەکە دابەش بکەیت بۆ وشەکان و ڤێکتەری وشەکان بگێڕیتەوە. بۆ نموونە: >>> words_string (((""سڵاو، من ناوی جانمە"")) (std::vector<std::string>({(std::string) ""سڵاو""، (std::string) ""من""، (std::string) ""ناوی""، (std::string) ""یە""، (std::string) ""جۆن""})) >>> words_string (((""یەک، دوو، سێ، چوار، پێنج، شەش"")) (std::vector<std::string>{(stdstring) ""یەک""، (std::string) ""، (std::string) ""، (std::string) ""، (std::string) ""، (std::string) ""، (std::string) ""، (std::string) ""، (std::string) ""، (std::string))
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەم فانکشنە دوو ژمارەی ئەرێنی x و y وەردەگرێت و گەورەترین ژمارەی تەواو دەداتەوە کە لە مەودای [x, y] دا بێت. ئەگەر ژمارەیەکی وا نەبێت، ئەوا فانکشنەکە دەبێت -1 بداتەوە. بۆ نموونە: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// دوو ژمارەی تەواو پۆزەتیڤ n و mت پێ دراوە، ئەرکی تۆ ئەوەیە کە تێکڕای ژمارە تەواوەکانی n تا m (بە n و mیشەوە) حیساب بکەیت. وەڵامەکە بگەیەنێتە نزیکترین ژمارە تەواو و بیگۆڕە بە دووەمی. ئەگەر n گەورەترە لە m، گەڕانەوەی -1. نموونە: >>> rounded_avg((1), (5)) ""0b11"" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) ""0b1111"" >>> rounded_avg(20), (33) ""0b11010""
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەپێدانی ڤێکتۆرێک لە ژمارە پۆزەتیڤەکان x. ڤێکتۆرێکی ڕیزکراو لە هەموو ئەو توخمانەی کە هیچ ژمارەیەکی جووتیان تێدا نییە، بگەڕێتەوە. تێبینی: ڤێکتۆر گەڕاوەکە دەبێت بە ڕیزکردنی زیادکراو ڕیزبکرێت. بۆ نموونە: >>> unique_digits(std::vector<long>({(long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{(long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{(long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێدانی ڤێکتۆرێکی تەواو، ئەو ژمارە تەواوانە ڕیزبکە کە لە نێوان ١ بۆ ٩دا هەن، ڤێکتۆری دەرئەنجام هەڵبگەڕێنە، پاشان ھەر ژمارەیەک بە ناوی بەرانبەری خۆی لە ""یەک""، ""دوو""، ""سێ""، ""چوار""، ""پێنج""، ""شەش""، "" حەوت""، ""هەشت""، ""نۆ"" بگۆڕە. بۆ نموونە: >>> by_length(std::vector<long>{long) 2، (long) 1، (long) 1، (long) 4، (long) 5، (long) 8، (long) 2، (long) 3}))) (std::vector<std::string>{(std::string) ""Eight""، (std::string) ""Five""، (std::string) ""Four""، (std::string) ""Three""، (std::string) ""Two""، (std::string) ""Two""، ""Four""، ""Five""، ""Five"" و ""One"" جێگرەوە. ئەگەر ڤێکتۆرێکی بەتاڵ هەبێت، ڤێکتۆرەکە پشتگوێریت بکە بە ""{string} (long_long_string}"" (long_string) ""{string}، (long_third_long_string}) ""{""} ({string} (long_third)) ئەگەر ڤێکتۆرێکتەرێکی بەتاڵ بێت، ({(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشن f جێبەجێ بکە کە n وەک پارامێتر وەردەگرێت و ڤێکتۆرێکی قەبارەی n دەداتەوە، بە جۆرێک کە بەهای توخم لە هێڵی i فاکتۆری i بێت ئەگەر i جووت بێت یان کۆی ژمارەکانی 1 تا i بێت ئەگەر نا. i لە 1 دەست پێ دەکات فاکتۆری i بریتییە لە لێکدانەوەی ژمارەکانی 1 تا i (1 * 2 * ... * i) نموونە: >>> f((5)) (std:: vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی پۆزەتیڤ n، گەڕاندنەوەی توپلێک کە ژمارەی palindromes ی تەواو و تەواو و تەواو لە چوارچێوەی (((1, n) دا بێت. نموونە 1: >>> even_odd_palindrome (((3)) (std::make_tuple (((1, 2)) ڕوونکردنەوە: palindrome ی تەواو لە 1, 2, 3. یەکێکیان جووت و دووانیان جووتن. نموونە 2: >>> even_odd_palindrome (((12)) (std::make_tuple (((4, 6)) ڕوونکردنەوە: palindrome ی تەواو لە 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. چواریان جووت و 6 یان جووتن. تێبینی: 1 <= n = 10 ^ 3 گەڕانەوەی توپل ژمارەی palindromes ی تەواو و تەواو و تەواو و تەواو و جووت و جووت و جووت دەکات.
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە count_nums کە ڤێکتۆرێکی تەواوی ژمارەکان وەردەگرێت و ژمارەی ئەو توخمانەی دەگەڕێنێتەوە کە کۆی ژمارەکانی >0 بێت. ئەگەر ژمارەیەک نەرێنی بێت، ئەوا یەکەمین ژمارە بە ئیمزای نەرێنی دەبێت: بۆ نموونە -123 ژمارەکانی -1, 2 و 3 ی هەیە. >>> count_nums ((((std::vector<long>())) (0) >>> count_nums (((std::vector<long>{(long) -1, (long) -11, (long) -11}))) (1) >>> count_nums (((std::vector<long>{(long) 1, (long) 1, (long) 2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئێمە ڤێکتەرێکمان هەیە لە N ژمارەی تەواو arr[1], arr[2], ..., arr[N]. ژمارەکانی ڤێکتەرەکە بە هەڕەمەکی ڕیز دەکرێت. ئەرکی تۆ ئەوەیە کە دیاری بکەیت ئەگەر دەکرێ ڤێکتەرێک بە ڕیزێکی نزم نەکراو ڕیزبکرێت بە ئەنجامدانی ئەم ئۆپەراسیۆنەی خوارەوە لەسەر ڤێکتەرەکە: تۆ مۆڵەتت هەیە بۆ ئەنجامدانی ئۆپەراسیۆنی جوڵانەوەی ڕاست چەند جارێک. ئۆپەراسیۆنی جوڵانەوەی ڕاست یەکجار مانای جوڵانەوەی هەموو توخمەکانی ڤێکتەرەکە بە یەک پێگە لە ئاراستەی ڕاستدا. دوایین توخمی ڤێکتەرەکە دەگوێزرێت بۆ پێگەی سەرەتایی لە ڤێکتەرەکە واتە 0th index. ئەگەر دەکرێ ڤێکتەرە ڕیزبکراوەکە بەدەست بهێنیت بە ئەنجامدانی ئۆپەراسیۆنی سەرەوە ئەوا true return false. ئەگەر ڤێکتەرەکە بەتاڵ بێت ئەوا true return false. تێبینی: ڤێکتەرەکە مسۆگەرە بۆ ئەوەی توخمەکانی تایبەت هەبێت. بۆ نموونە: move_plan_one_{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لەم کێشەیەدا، فانکشنێک جێبەجێ دەکەیت کە دوو ڤێکتەری ژمارە وەردەگرێت، و دیاری دەکات کە ئایا دەکرێت ئاڵوگۆڕی توخم لە نێوانیاندا ئەنجام بدرێت بۆ ئەوەی lst1 ببێتە ڤێکتەری ژمارە جووتەکان. هیچ سنورێک نییە لەسەر ژمارەی توخمەکانی ئاڵوگۆڕکراو لە نێوان lst1 و lst2. ئەگەر دەکرێت ئاڵوگۆڕی توخم لە نێوان lst1 و lst2 بکرێت بۆ ئەوەی هەموو توخمەکانی lst1 جووت بن، ئەوا ""بەڵێ"" بدەرەوە. ئەگەر نا، ئەوا ""نا"" بدەرەوە. بۆ نموونە: >>> ئاڵوگۆڕ (((std::vector<>(({long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>({long) 1, (long) 2, (long) 3, (long) 4}) ، (std::vector<>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی زنجیرەیەک کە نوێنەرایەتی پیتێکی بچووک دەکات بە جیاکردنەوەی بۆشایی، نەخشەیەکی پیتەکە بدەرەوە کە زۆرترین دووبارەکردن و ژمارەی پێوەندیدارەکەی تێدایە. ئەگەر چەند پیتێک هەمان ڕووداویان هەبێت، هەموویان بدەرەوە. نموونە: >>> هیستۆگرام (((""a b c"")) (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}})) >>> هیستۆگرام ((((""a b a"")) (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})) >>> هیستۆگرام ((((""a b c a b"")) (std::map<std::string,long>{{""a"", 2}, {""b"", 2}})) >>> هیستۆگرام ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەرک ئێمە دوو ڕیز s و cمان پێ دراوە، دەبێت هەموو کارەکتەرەکانی s سڕینەوە کە یەکسانن بە هەر کارەکتەرێک لە cدا پاشان پشکنین بکەین ئەگەر ڕیزەکە پالێندرۆمە. ڕیزێک بە پالێندرۆمە ناودەبرێت ئەگەر هەمان بۆ پێشەوە بخوێنرێت. دەبێت توپلێک بگێڕینەوە کە ڕیزەکە لە ئەنجامدا بێت و ڕاست/ناڕاست بێت بۆ پشکنینەکە. نموونە >>> reverse_delete((""abcde""), (""ae"")) (std::make_tuple(""bcd"", false)) >>> reverse_delete(""abcdef""), (""b"") (std::make_tuple(""acdef"",)) >>> reverse_delete((abcded"", false)) (std::make_tuple"", true))
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەپێى ڤێکتەرێک لە ڕیزەکان، کە هەر ڕیزێک تەنها لە ژمارە پێکهاتووە، ڤێکتەرێک بگەڕێتەوە. هەر توخمێک i لە دەرچوونەکە دەبێت ""ژمارەى توخمەکانى نامۆ لە ڕیز i لە دەرچوونەکە"". کە هەموو iەکان دەبێت بە ژمارەى ژمارە نامۆکان لە ڕیز i ی دەرچوونەکە جێگیر بکرێن. >>> odd_count((std::vector<std::string>(({std::string) ""1234567""}))) (std::vector<std::string>({stdstring)::""ژمارەى توخمەکانى نامۆ 4n ڕیزەکە 4 لە 4n دەرچوونەکە. "")) >>> odd_count(stdvector<stdstring>::{(stdstring)::{(stdstring)::""3"" (ڕیزەکە 11""""11""}))) (std vector<std::string::{stdstring>:n) 1 ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێدانی ڤێکتۆرێک لە ژمارە تەواوەکان، کەمترین کۆی ھەر بەشێک لە ڤێکتۆرەکانی ژمارە تەواوەکان بدۆزەرەوە. نموونە >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ تۆڕێکی ڕاستگۆشەی بیرەکانت پێ دراوە. هەر ڕیزێک یەک بیرە و هەر یەک لە ڕیزەکان یەک یەکەی ئاون. هەر بیرێک سەبەتەیەکی هاوتای هەیە کە دەتوانرێت بۆ دەرهێنانی ئاو بەکاربهێنرێت، و هەموو سەبەتەکان هەمان تواناییان هەیە. ئەرکەکەت ئەوەیە کە سەبەتەکان بەکاربهێنیت بۆ بەتاڵکردنەوەی بیرەکان. ژمارەی جارەکانی دەرچوون کە پێویستە بۆ دابەزاندنی سەبەتەکان. نموونە 1: >>> max_fill(((std::vector<std::vector<std::vector<long>، (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// لەم کاتا دا، دەبێت ڤێکتەرێکی تەواوی نەگەتیڤەکان بەگوێرەی ژمارەی یەکەکان لە نوێنەرایەتی دوواییان لە ڕیزبەندی بەرزبوونەوەدا ڕیزبکەین. بۆ ژمارەی هاوشێوەی یەکەکان، ڕیزبکە لەسەر بنەمای بەهای دەیمی. دەبێت بەم شێوەیە جێبەجێ بکرێت: >>> sort_array((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5}) >>> sort_array((std::vector<long>{(long) 2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std::vector<long>{(long>{-6, (long) 5, (long) 4, (long) 3, (long) 2} >>> array_array_std::vector<long>{(long>1, (long) 3, (long)) (long) 0, (long)) (long) 2, (long)) (long)) (long) 4)) (long)) (long)
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ڕیزێک s و ژمارەیەکی سروشتی n، ئەرکێکت پێ سپێردراوە بۆ جێبەجێکردنی فانکشنێک کە ڤێکتۆری هەموو وشەکانی ڕیز s دەداتەوە کە ڕێک n هاوئۆنان لەخۆ دەگرێت، بۆ ئەوەی ئەم وشانە لە ڕیز s دا دەربکەوێت. ئەگەر ڕیز s بەتاڵ بێت ئەوا فانکشنەکە دەبێت ڤێکتۆری بەتاڵ بگەڕێنێتەوە. تێبینی: لەوانەیە وا دابنێیت ڕیزە دەرکەوتە تەنها پیت و بۆشایی تێدایە. نموونە: >>> select_words (((""مەریەم بەرخێکی بچووکی هەبوو"") ، (4)) (std::vector<std::string>({(std::string) ""کوچکە""} >>> select_words ((((""مەریەم بەرخێکی بچووکی هەبوو"") ، (3)) (std::vector<std::string>) ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// وشەیەکت پێ دراوە. ئەرکەکەت ئەوەیە نزیکترین دەنگدانە بدۆزیتەوە کە لەنێوان دوو هاوئەندامی لای ڕاستی وشەکە بێت (بە هەستیاری ڕێنووسی). دەنگدانەکان لە سەرەتاو کۆتاییدا هەژمار ناکرێن. گەر هیچ دەنگدانێکت نەدۆزیتەوە مەرجی سەرەوە جێبەجێ کرد، ئەوا ڕیزێکی بەتاڵ بدەرەوە. لەوانەیە وا دابنێیت کە ڕیزەکە تەنها پیتی ئینگلیزی تێدایە. نموونە: >>> get_closest_vowel (((""yogurt"")) (""u"") >>> get_closest_vowel (((""FULL"")) (""U"") >>> get_closest_vowel (((""quick"")) ("""") >>> get_closest_vowel (((ab"") ("""")
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ ڤێکتۆرێکی دوو ڕیزت پێ دراوە، هەردوو ڕیزەکە تەنها لە قۆچی کراو '(' یان قۆچی داخراو ') ' پێکهاتوون. ئەرکەکەت ئەوەیە کە بزانیت ئەگەر دەکرێت دوو ڕیزەکە بە ڕیزێک پێکەوە ببەسترێت، کە ڕیزەکە بە باشی دەردەچێت. ڕیزێک S بە باش دادەنرێت ئەگەر و تەنها ئەگەر هەموو قۆچییەکان لە S هاوسەنگیان هەبێت. بۆ نموونە: ڕیز '(())) ' باشە، لەکاتێکدا ڕیز '()) ' باش نییە. گەر رێگەیەک هەبێت بۆ دروستکردنی ڕیزێکی باش، 'بەڵێ' بگەڕێنەوە، و ئەگەر نا 'نەخێرەوە' بگەڕێنەوە. نموونە: >>> match_parens(std:: vector<std::string>{((stdstring) "") ، "" (((std::string) "")) "" (بەڵێ"") >>> match_parens<std:: vector<std>{(stdstring>"" ((((stdstring)) "" (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێدانی ڤێکتۆرێکی پڕ لە ژمارە تەواوەکان و ژمارەیەکی تەواو پۆزەتیڤ k، ڤێکتۆرێکی ڕێککراوی درێژی k بە زۆرترین ژمارە k لە arr بدەرەوە. نموونە 1: >>> زۆرترین (((std::vector<long>({(long) -3, (long) -4, (long) -4, (long) -5,) ، (3)) (std::vector<long>({(long) -4, (long) -3, (long) -5}) نموونە 2: >>> زۆرترین ((((std::vector<long>({(long) -4, (long) -4}) ، (2)) (std::vector<long>({(long) -4, (long) -4}) نموونە 3: >>> زۆرترین (((std::vector<<long>{(long) -3, (long) -2, (long) -1, (long) -2, (long) -1, (long) -2, (long) -1,) (1) (std::vector<<long>) -2): 1. درێژی ڤێکتەرەکە لە مەودای 1000 دانە دەبێت. تێبینی: لین - 1، لین - 2 دەبێت لە مەودای 1000 دانە بێت.
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ڤێکتۆرێکی پڕی تەواو، کۆی هەموو ئەو توخمە نامۆیانە بگەڕێتەوە کە لە شوێنی جووتدان. نموونە >>> چارەسەر ((((std::vector<long>({(long) 5، (long) 8، (long) 7، (long) 1}))) (12) >>> چارەسەر (((((std::vector<long>({(long) 3، (long) 3، (long) 3}))) (9) >>> چارەسەر ((((std::vector<long>(({(long) 30، (long) 13، (long) 24، (long) 321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێدانی ڤێکتۆرێکی پڕ لە ژمارە تەواوەکان arr و ژمارەیەکی تەواو k، کۆی ئەو توخمانەی بگەڕێتەوە کە زۆرترین دوو خانەی لە یەکەم k توخمی arr. نموونە: >>> add_elements((std::vector<long>({(long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) بەربەستەکان: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr(()
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی پۆزەتیڤ n، ڤێکتەرێکی پۆلێنکراو بگەڕێنەوە کە ژمارە نامۆکان لە زنجیرەی کۆلاتزدا هەبێت. گریمانەی کۆلاتز گریمانەیەکی بیرکارییە کە پەیوەندی بە زنجیرەیەکەوە هەیە کە بەم شێوەیە پێناسە کراوە: دەستپێبکە بە هەر ژمارەیەکی پۆزەتیڤ n. پاشان هەر دەستەواژەیەک لەم دەستەواژەیە پێشوودا وەردەگیرێت بەم شێوەیە: ئەگەر دەستەواژەی پێشوودا جووت بێت، دەستەواژەی داهاتوو نیوەی دەستەواژەی پێشوودا دەبێت. ئەگەر دەستەواژەی پێشوودا نامۆ بێت، دەستەواژەی داهاتوو 3 هێندەی دەستەواژەی پێشوودا دەبێت بە زیادکردنی 1. گریمانەکە ئەوەیە کە گرنگ نییە چ بەهایەکی n بێت، زنجیرەکە هەمیشە دەگاتە 1. تێبینی: 1. کۆلاتز (((1) [1] 2. ڤێکتەری گەڕاوەتەوە بە ڕیزێکی زیادکرد. بۆ نموونە: get_odd_collatz5) گەڕاندنەوەی [1, 5] # زنجیرەی کۆلاتز بۆ 5 بریتییە لە [5, 8, 16, 4, 2, 1], بۆیە ژمارە نامۆکان تەنها 1 و 5ن >>> get_collatz ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// پێویستە فانکشنێک بنووسیت کە ڕیزێکی دیاریکراوی ڕێکەوتی ڕاست بکاتەوە ئەگەر ڕێکەوتی ڕاستە بێت ئەگەر نا هەڵە. ڕێکەوتی ڕاستە ئەگەر هەموو یاساکانی خوارەوە جێبەجێ بکرێت: 1. ڕیزەکەی ڕێکەوتی بەتاڵ نەبێت. 2. ژمارەی ڕۆژەکان کەمتر نەبێت لە 1 یان زیاتر بێت لە 31 ڕۆژ بۆ مانگەکانی 1,3,5,7,8,10,12. ژمارەی ڕۆژەکانیش کەمتر نەبێت لە 1 یان زیاتر بێت لە 30 ڕۆژ بۆ مانگەکانی 4,6,9,11. هەروەها ژمارەی ڕۆژەکان کەمتر نەبێت لە 1 یان زیاتر بێت لە 29 بۆ مانگەکە 2. مانگەکان نابێت کەمتر بێت لە 1 یان زیاتر بێت لە 12. ڕێکەوتیش دەبێت لە فۆرماتی: mm-dd-yyyy >>> valid_(date((01-15-2000"")) (true >>> valid_date (((01-15-2012"")) (false) >>> valid_date (((04-2040"") (false) valid >>>_((date_2020-06-04"") (true >>> valid_date ((((06/04/2020) (false)
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// بە پێی زنجیرە وشەکان، ڤێکتەرێک لە وشەکان بە دابەشکردنی بۆشاییەکان بگەڕێنەوە، ئەگەر بۆشاییەکان لە دەقەکەدا نەبن پێویستە بە کۆماکان دابەش بکرێن، ئەگەر کۆماکان نەبن پێویستە ژمارەی پیتەکانی بچووک بە ڕیزبەندی نامۆ بگەڕێنەوە لە ئەلفوبێت، ord ((('a') = 0، ord ((('b') = 1، ... ord ((('z') = 25 نموونە >>> split_words ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەپێپێداگرتنی ڤێکتۆرێک لە ژمارەکان، گەڕانەوەی ئەگەر یان نا لە ڕیزبەندی بەرزبوونەوەدا. ئەگەر ڤێکتۆر زیاتر لە یەک دووانەوەی هەمان ژمارە هەبێت، گەڕانەوەی هەڵە. هیچ ژمارەیەکی نەرێنی و تەنها ژمارە تەواوەکان دابنێ. نموونە >>> is_sorted ({((std::vector<long>{(long) 5}))) (true) >>> is_sorted ({((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دوو ناوەندی پێدراوە، کە هەر ناوەندێک جووتێکی ژمارە تەواوە. بۆ نموونە، ناوەندی = (دەستپێک، کۆتایی) = (1, 2). ناوەندی پێدراو داخراوە کە مانای وایە ناوەندی (دەستپێک، کۆتایی) هەم دەستپێک و هەم کۆتایی دەگرێتەوە. بۆ هەر ناوەندی پێدراو، وا دادەنرێت کە دەستپێکەکەی کەمتر یان یەکسانە بە کۆتاییەکەی. ئەرکەکەت ئەوەیە کە دیاری بکەیت ئایا درێژی پچڕانی ئەم دوو ناوەندەیە ژمارەیەکی سەرەتاییە. نموونە، پچڕانی ناوەندەکان (1, 3), (2, 4) بریتییە لە (2, 3) کە درێژییەکەی 1ە، کە ژمارەیەکی سەرەتایی نییە. ئەگەر درێژی پچڕانی ژمارەکە ژمارەیەکی سەرەتاییە، ""بەڵێ"" بگەڕێنەوە، ئەگەر نا، ""نا"" بگەڕێنەوە. ئەگەر دوو ناوەندی پچڕانەکە یەکتر ناکۆکن، ""نا"" بگەڕێنەوە. نموونەکان: >>> پچڕان:: (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ ڤێکتۆرێکی پڕ لە ژمارە تەواوەکانت پێدراوە و پێویستە کۆی قەبارەی ژمارە تەواوەکانت بدەیتەوە کە بە بەرھەمی هەموو نیشانەکانی ھەر ژمارەیەک لە ڤێکتەرەکە زیاد کراوە، کە بە ١، -١ یان ٠ نوێنەرایەتی دەکرێت. تێبینی: هیچ شتێک بۆ ڤێکتۆرە بەتاڵەکان نەدەیتەوە. نموونە: >>> prod_signs(((std::vector<long>{(long) ١، (long) ٢، (long) ٢، (long) -٤}))) ٩ >>> prod_signs(std::vector<long>({(long) ٠، (long) ١)) ٠ >>> prod_signs (((std::vector<long>(((std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێێ تۆڕێک کە N ڕیز و N ستوون (N >= 2) و ژمارەیەکی پۆزەتیڤ k بێت، ھەر خانەیەکی تۆڕەکە بەھایەکی تێدایە. ھەر ژمارەیەکی پۆزەتیڤ لە مەودای [1, N * N] بە ھەمووانەوە یەکجار لە خانەکانی تۆڕەکە دەردەکەوێت. تۆ دەبێت کەمترین ڕێڕەوی درێژی k لە تۆڕەکە بدۆزیتەوە. تۆ ئەتوانی لە ھەر خانەیەکەوە دەست پێ بکەیت، و لە ھەر ھەنگاوێکدا ئەتوانی بچیتە ھەر خانەیەکی دراوسێ، بە واتایەکی تر، ئەتوانی بچیتە ھەر خانەیەک کە لەتێک ھەنگاوێکی ھاوبەش لەگەڵ تۆ ھەنگاوێکی ھەنووکەیی ھەیە. تکایە تێبینی بکە کە ڕێڕەوی درێژی k مانای سەردانیکردنی ڕێک k خانە (نەک مەرج بە جیا بوون) تۆ ناتوانیت بچیتە دەرەوەی تۆڕەکە. ڕێڕەوی A (درێژی k) بە کەمتر لە ڕێڕەوی B (درێژی k) دادەنرێت ئەگەر دوای دروستکردنی ڤێکتەرە ڕیزکراوەکانی بەھاکانی خانەکانی A و B (با پێیان بڵێین l_stA و l_stB) ، لە ڕووی فەرهەنگییەوە کەمتر لە l_stA_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// هەموو کەس زنجیرەی فیبۆناتچی دەزانێت، لە دوو سەدەی ڕابردوودا لەلایەن بیرکارانەوە بە قووڵی لێکۆڵینەوەی لەسەر کراوە. بەڵام ئەوەی خەڵک نایزانێت بریتییە لە زنجیرەی تریبۆناتچی. زنجیرەی تریبۆناتچی بە دووبارەبوونەوە پێناسە دەکرێت: tri(1) = 3 tri(n) = 1 + n / 2, ئەگەر n جووت بێت. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ئەگەر n نامۆ بێت. بۆ نموونە: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 ژمارەیەکی تەواو نینەگەتیڤت پێ دراوە، دەبێت ڤێکتۆرێکی یەکەم n + 1 ی زنجیرەی تریبۆناتچی بدەیتەوە. نموونە: >>> tri(3) (dst vector<<((long>{} (long1,3, (long2, (long8})
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی پۆزەتیڤ n، بەرهەمی ژمارە جودەکان بدەرەوە. 0 بدەرەوە ئەگەر هەموو ژمارەکان جووت بن. بۆ نموونە: >>> ژمارە ((((1)) (1) >>> ژمارە (((4)) (0) >>> ژمارە ((((235)) (15)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە ڕیزێکی بێبڕاو وەک دەرھێنان وەربگرێت کە تەنھا بڕاوەکانی چوارگۆشەی تێدایە. فانکشنەکە دەبێت راست بگەڕێنێتەوە ئەگەر و تەنھا ئەگەر یەک زنجیرە بڕاوەی دروست ھەبێت کە لانیکەم یەک بڕاوەی لە زنجیرەکە دا ھەڵکەوتووە. >>> is_nested (((""[[]]"")) (true) >>> is_nested (((""[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ ڤێکتۆرێکی ژمارەت پێ دراوە. تۆ پێویستە کۆی دووجا ژمارەکانی ڤێکتۆرەکە بدەیتەوە، یەکەمجار هەموو توخمەکانی ڤێکتۆرەکە دەورە بدەیتەوە بۆ بەشی سەرەوەی. نموونەکان: >>> lst: vector: float: 1.0f, (float: 2.0f, (float: 3.0f)) (14) >>> lst: vector: float: 1.0f, (float: 4.0f, (float: 9.0f)) >>> (98) lst: vector: float: 1.0f, (float: 3.0f, (float: 5.0f, (float: 7.0f)) (84) >>> lst: vector: float: 1.04f, (float: 2.04f, (float: 0.0f)) (6) >>> vector: float: 1.04f, (float: 2.04f, (float: 0.0f)) (6) >>> vector: float: 1.04f, (float: 2.04f, (float: 0.0f)) (6) >>> vector: float: 1.04f, (float: 1.04f)
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە راست دەداتەوە ئەگەر دوایین کارەکتەری ڕیزێکی دیاریکراو کارەکتەری ئەلفوبێی بێت و بەشێک نەبێت لە وشەیەک، وە هەڵە ئەگەر نا. تێبینی: وشە کۆمەڵێک کارەکتەرە کە بە بۆشایی جیا کراون. نموونە: >>> check_if_last_char_is_a_letter ((((""apple pie"")) (false) >>> check_if_last_char_is_a_letter (((""apple pi e"")) (true) >>> check_if_last_char_is_a_letter (((""apple pi e "")) (false) >>> check_if_last_char_is_a_letter ((("""")) (false)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە گەورەترین هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێماى هێ
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە توپلێک (a, b) دەداتەوە، کە تێیدا 'a' گەورەترین ژمارەی تەواو نەرێنییە، و 'b' بچوکترین ژمارەی تەواو ئەرێنییە لە ڤێکتەرێکدا. ئەگەر ژمارە تەواو نەرێنی یان ئەرێنی نەبێت، ئەوا بە None دەگەڕێنێتەوە. نموونە: >>> largest_smallest_integers(((std::vector<long>{long) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7}))) std::make_tuplestd::optional<long>{long}), std::optional<long>{long}) >>> largest_smallest_integers{(std::vector<long>{long}), std::optional<long>{long} (<long>)
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// فانکشنێک دروست بکە کە ژمارە تەواوەکان، فلوێتەکان، یان زنجیرە ژمارە ڕاستەقینەکان وەردەگرێت و گۆڕاوەکانی گەورەتر لە جۆری گۆڕاوەکەی دەداتەوە. نەگەڕێتەوە ئەگەر بەهاکان یەکسان بن. تێبینی: ئەگەر ژمارەیەکی ڕاستەقینە وەک زنجیرە نوێنەرایەتی بکرێت، ئەوا خاڵی گۆڕاو لەوانەیە . یان ، >>> compare_one(1, 2.5f) 2.5f >>> compare_one(1, ""2,3"") ""2,3"" >>> compare_one(""5,1"", ""6"") ""6"" >>> compare_one(""1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// هەڵسەنگاندن بکە بۆ ئەوەی بزانین ئایا ژمارە n دەتوانرێت وەک کۆی 4 ژمارەی جووت بنوسرێت بۆ نموونە >>> is_equal_to_sum_even ((4)) (درۆ) >>> is_equal_to_sum_even ((6)) (درۆ) >>> is_equal_to_sum_even ((8)) (ڕاست)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فاکتۆریالی بەڕازیلی بەم شێوەیە پێناسە دەکرێت: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! کە n > 0 بۆ نموونە: >>> special_factorial (((4)) (288) فانکشنەکە ژمارەیەکی تەواو وەردەگرێت وەک دەسپێرکردن و دەبێت فاکتۆریالی تایبەتی ئەم ژمارەیە بگەڕێنێتەوە.
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێی دەقی زنجیرە، هەموو بۆشاییەکانی ناوە بە هێڵی ژێرەوە بگۆڕە، ئەگەر زنجیرە زیاتر لە دوو بۆشایی یەک لەدوای یەک هەبێت، ئەوا هەموو بۆشاییە یەک لەدوای یەکەکان بگۆڕە بە - >>> fix_spaces ((("" نموونە"")) (مثال"") >>> fix_spaces ((("" نموونە 1"")) (مثال_1"") >>> fix_spaces ((("" نموونە 2"") (مثال_2"") >>> fix_spaces ((("" نموونە 3"") (مثال_3"")
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک دروست بکە کە ڕیزێک لە ڕیزەکان کە نوێنەرایەتی ناوی فایل دەکات، وەربگرێت و ""بەڵێ"" گەر ناوی فایلەکە ڕاستە، و ""نا"" گەر نا. ناوی فایلەکە بە ڕیز دادەنرێت ئەگەر و تەنها ئەگەر هەموو مەرجەکانی خوارەوە جێبەجێ بکرێت: - نابێت زیاتر لە سێ ژمارە ('0'-'9') لە ناوی فایلەکەدا هەبێت. - ناوی فایلەکە ڕێک یەک خاڵ لەخۆ دەگرێت. - ڕیزەکە پێش خاڵەکە نابێت بەتاڵ بێت، و بە پیتی ئەلفبای لاتینی دەست پێدەکات ('a'-'z' و 'A'-Z'). - ڕیزەکە دوای خاڵەکە دەبێت یەکێک بێت لەمانە: ['txt', 'exe', 'll'] نموونە: >>> file_name_check""(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەم فانکشنە ڤێکتۆرێکی تەواوی ژمارە وەردەگرێت. بۆ هەموو تۆمارەکانی ڤێکتۆرەکە، فانکشنەکە دەبێت چوارگۆشەی تۆمارکردنی ژمارە تەواوەکە بکات ئەگەر ئاماژەکەی چەند هێلێک بێت لە ٣ و سێگۆشەی تۆمارکردنی ژمارە تەواوەکە دەکات ئەگەر ئاماژەکەی چەند هێلێک بێت لە ٤ و چەند هێلێک نەبێت لە ٣. فانکشنەکە گۆڕانکاری ناکات لە تۆمارەکانی ڤێکتۆرەکە کە ئاماژەکانی چەند هێلێک نین لە ٣ یان ٤. فانکشنەکە دواتر دەبێت کۆی هەموو تۆمارەکان بگێڕێتەوە. نموونە: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst ((long)) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ زنجیرەیەکت پێ دراوە کە ڕستەیەک نیشان دەدات، ڕستەکە چەند وشەیەکی تێدایە کە بە بۆشایی لێک جیا کراونەتەوە، وە دەبێت ڕستەیەک بدەیتەوە کە وشەکانی ڕستەی ڕەسەنی تێدایە، کە درێژییەکانی ژمارە سەرەتاییەکانن، ڕیزبەندی وشەکانی ڕستەی نوێ دەبێت وەک ڕستەی ڕەسەنی بێت. نموونە 1: >>> words_in_sentence (((""This is a test"")) (""is"") نموونە 2: >>> words_in_sentence ((((""let's go for swimming"")) (""go for"") ڕێگرییەکان: * 1 <= len (((sentence) <= 100 * ڕستەکە تەنها پیتەکانی تێدایە
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ئەرکی تۆ جێبەجێکردنی فانکشنێکە کە دەربڕینی x * n سادە دەکات. فانکشنەکە راست دەداتەوە ئەگەر x * n بە ژمارەیەکی تەواو بێت و بە پێچەوانەوە هەڵەیە. هەردوو x و n، نوێنەرایەتی زنجیرەی بەشەدان، و ئەم فۆرماتە ی خوارەوەیان هەیە، <بەژمار>/<بە ناوگر> کە هەردوو بەژمار و ناوگر ژمارە تەواو پۆزەتیڤن. دەتوانیت وا دابنێیت کە x و n بەشەدانە دروستن، و سفریان نییە وەک ناوگر. >>> سادە کردن (((""1/5"") ، (""5/1"")) (ڕاست) >>> سادە کردن (((""1/6"") ، (""2/1"") (هەڵە) >>> سادە کردن (((""7/10"") ، (""10/2"") (هەڵە)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە ڤێکتەری دانراوی ژمارە تەواوەکان بە ڕیزکردنی بەرزبوونەوە بەگوێرەی کۆی ژمارەکانی ڕیزبکات. تێبینی: ئەگەر چەند بابەتێک هەبن کە هاوشێوەی کۆی ژمارەکانیان هەیە، ئەوا ڕیزبکە بەگوێرەی هێمای خۆیان لە ڤێکتەری ڕەسەن. بۆ نموونە: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) -1, (long) -12, (long) 11})) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە ڤێکتۆرێکی ژمارە وەک دەرچوون وەربگرێت و ژمارەی ئەو توخمانەی لە ڤێکتۆرەکەدا هەیە بگەڕێنێتەوە کە لە ١٠ گەورەترن و ھەردوو ژمارە یەکەم و کۆتایی ژمارەکە نامۆ بن (١،٣،٥،٧،٩) بۆ نموونە: >>> specialFilter((std::vector<long>({(long) ١٥، (long) ٧٣، (long) ١٤، (long) ١٥))))) (1) >>> specialFilter((std::vector<long>({(long) ٣٣، (long) ٢، (long) ٣، (long) ٤٥، (long) ٢١، (long) ١٠٩)) (2)
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ژمارەیەکی پۆزەتیڤت پێدراوە n. دەبێت ڤێکتۆرێکی تەواوی a دروست بکەیت بە درێژی n. بۆ هەر i (1 ≤ i ≤ n) ، بەهای a[i] = i * i - i + 1. ژمارەی سێبەرەکان (a[i], a[j], a[k]) ی a بدەرەوە کە i < j < k، و a[i] + a[j] + a[k] چەندە لە 3. نموونە: >>> get_max_triples((5)) (1) ڕوونکردنەوە: a = [1, 3, 7, 13, 21] تاکە سێبەرە دروستەکە بریتییە لە (1, 7, 13).
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// هەشت هەسارەی لە سیستەمی خۆریدا هەیە: نزیکترین لە خۆرەکە (مەرکووڕی) ە، دواتر (ڤینۆس) ە، پاشان (زەمین) ، (مەرس) ، (جووپەر) ، (زەمەن) ، (ئۆرانۆس) ، (نێپتوون) ە. فانکشنێک بنووسە کە دوو ناوی هەسارەی وەک زنجیرە (planet1) و (planet2) وەردەگرێت. فانکشنەکە دەبێت توپلێک بگێڕێتەوە کە هەموو ئەو هەسارانە تێدایە کە خولگەكانیان لەنێوان خولگەی هەسارەی (١) و (هەسارەی (٢) دایە، بەگوێرەی نزیکبوونیان لە خۆر. فانکشنەکە دەبێت توپلێکی بەتاڵ بگێڕێتەوە ئەگەر هەسارەی (١) یان هەسارەی (٢) ناوی هەسارەی دروست نەبێت. نموونە >>> bf ((((""جووپەر"") ، (""نێپتوون"") (std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە ڤێکتۆرێکی ڕیزەکان وەک پارامێتر قبوڵ بکات، ئەو ڕیزانەی کە درێژییان نامۆیە لە ڕیزەکان سڕێتەوە، و ڤێکتۆری دەرئەنجام بە ڕیزێکی ڕیزکراو دەگەڕێنێتەوە، ڤێکتۆرەکە هەمیشە ڤێکتۆری ڕیزەکانە و هەرگیز ڤێکتۆری ژمارەکان نییە، و لەوانەیە دووبارە بێت. ڕیزبەندی ڤێکتۆرەکە دەبێت بە درێژایی هەر وشەیەک بەرزبێتەوە، و دەبێت ڤێکتۆرەکە ڕیزبەندی بکەیت بە پێی ئەو یاسایە. ئەگەر دوو وشە هەمان درێژییان هەبێت، ڤێکتۆرەکە ڕیزبەندی بکە بە ئەلفوبێی. فانکشنەکە دەبێت ڤێکتۆری ڕیزبەندی ڕیزبەندی بکات. لەوانەیە وا دابنێیت کە هەموو وشەکان هەمان درێژییان دەبێت. بۆ نموونە: >>> list_sort{""}std::stdvector<stdstring>{""}std::stdvector{""}std""a"" (a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""a""
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەرنامەیەکی سادەیە کە دەبێت بەهای x بگەڕێنێتەوە ئەگەر n ژمارەیەکی سەرەتایی بێت و بەهای y بگەڕێنێتەوە ئەگەر نا. نموونە: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بەپێى ڤێکتەرێک لە ژمارەکان، کۆى چوارگۆشەکانى ژمارەکانى ڤێکتەرەکە بدەرەوە کە نامۆ بن. ژمارەکانى نێگەتیڤ و نە تەواو پشتگوێ بخە. >>> double_the_difference ((((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference (((std::vector<float>{(long) -1, (long) -2, (long) 0}))) (0) >>> double_the_difference (((std::vector<float>{(long) -9, (long) -2)))) (81) >>> double_the_difference ((((std::vector<float>{(long) -0)) (0) ئەگەر ڤێکتەرەکە بەتاڵ بێت، ئەوا 0 بدەرەوە.
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// من پێم وایە هەموومان ئەو هەستەمان لەبیرە کاتێک ئەنجامی ڕووداوێکی چاوەڕوانکراو لە کۆتاییدا زانراوە. ئەو هەست و بیرکردنەوانەی کە لەو کاتەدا هەیە بە دڵنیاییەوە شایانی ئاماژەکردن و بەراوردکردنن. ئەرکەکەت ئەوەیە کە دیاری بکەیت کەسێک ئەنجامی چەند یارییەکی بە دروستی زانیوە. دوو ڤێکتەری سکۆر و گریمانەی یەکسانی دراوە، کە هەر ئاماژەیەک یارییەک نیشان دەدات. ڤێکتەری یەکسانی درێژی بدەرەوە کە نیشانی دەدات چەند دوورە لە هەر گریمانەیەک. ئەگەر بە دروستی زانیبێت، بەهایەکە 0 دەبێت، ئەگەر نا، بەهایەکە جیاوازییە تەواوەکەی نێوان گریمانەکە و ئەنجامەکە. نموونە: >>>((longd::vector<(long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5, (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (longd) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ناوی پۆلێک (دێڕێک) و ڤێکتەری زیادکراوەکانت پێدەدرێت. زیادکراوەکان بۆ بارکردنی پۆلەکانی تر بەکاردەهێنرێت بۆ پۆلەکە. هێزی زیادکراوەکە بەم شێوەیە: با CAP ژمارەی پیتی گەورە بێت لە ناوی زیادکراوەکەدا، و با SM ژمارەی پیتی بچووک بێت لە ناوی زیادکراوەکەدا، بەهێزبوونەکە بە فراکسیۆنی CAP - SM دەدرێت. تۆ دەبێت بەهێزترین زیادکراو بدۆزیتەوە و زنجیرەیەک بەم فۆرماتە بگەڕێنیتەوە: ClassName.StrongestExtensionName. ئەگەر دوو زیادکراو یان زیاتر هەبێت بە هەمان بەهێزبوون، دەبێت ئەوەی یەکەم بێت لە ڤێکتەرەکە هەڵبژێریت. بۆ نموونە، ئەگەر ""Slices"" وەک پۆل و ڤێکتەری زیادکراوەکانت پێ دراوە: ['SErviSliCes'، 'Cheese', 'StuFed'] ئەوا دەبێت 'Slices.viSliCes' بگەڕێنیتەوە: 'myst::viSliCes::myst::viSliCes::myst::viSliCes::myst::viSliCes::myst::myst::viSliCes::myst::string::string::string::string::string::string::string::string::string::string::string::string::string::string: (بە بەهێزترین زیادکراوەی زیادکراوەی (بەست) "" (بە نموونە: ""AAAA"" ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// دوو وشەت پێ دراوە. پێویستە راست بدەیتەوە ئەگەر وشەی دووەم یان هەر یەکێک لە خولانەکانی بریتی بێت لە زنجیرەیەکی ژێرەوە لە وشەی یەکەمدا >>> cycpattern_check((""abcd""), (""abd"")) (false) >>> cycpattern_check((""hello""), (""ell"")) (true) >>> cycpattern_check((""whassup""), (""psus"")) (false) >>> cycpattern_check((""abab""), (""baa"")) (true) >>> cycpattern_(check""efef""), (""eeff"") cy (false) >>> cycpattern_check((""himens""), (""simen"") (true)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی تەواو. گەڕاندنەوەی ژمارەیەکی تاپل کە ژمارەی ژمارە جووت و جودەکانی هەیە. نموونە: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دانانی ژمارەیەکی پۆزەتیڤ، بە یەکسانبوونی ژمارە ڕۆمانییەکەی وەک زنجیرە وەربگرە، و بە پیتی بچووک بیگەڕێنەوە. سنووردارکردن: 1 <= num <= 1000 نموونە: >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426)) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە پێی درێژی سێ لای سێگۆشەیەک. گەر سێ لایەکە سێگۆشەیەکی ڕاستگۆیان پێکهێنا راست دەداتەوە، بە پێچەوانەوە ناڕاست. سێگۆشەیەکی ڕاستگۆ سێگۆشەیە کە یەکێک لە گۆشەکانی گۆشەی ڕاستگۆ یان 90 پلە بێت. نموونە: >>> right_angle_triangle (((3), (4), (5)) (true) >>> right_angle_triangle (((1), (2), (3)) (false)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// فانکشنێک بنووسە کە ڤێکتۆرێکی ڕیزەکان قبوڵ بکات. ڤێکتۆرەکە وشەی جیاواز لەخۆدەگرێت. وشەکە بە زۆرترین ژمارەی کارەکتەرە جیاوازەکان بگەڕێنێتەوە. ئەگەر چەندین ڕیز زۆرترین ژمارەی کارەکتەرە جیاوازەکانی هەبێت، ئەو کەسەی کە یەکەم دێت لە ڕیزبەندی وشەنامەیی بگەڕێنێتەوە. >>> find_max((std::vector<std::string>({(std::string) ""name"", (std::string) ""of"", (std::string) ""string""}))) (""string"") >>> find_max{(std::vector<std::string>{(std::string) ""name"", (std::string) ""enam"", (std::string) ""game""} (""enam"")))) >>> find_max{(std::vector<std>{((stdaaaaaaa""}, (std::string) ""bb"" (""string""): ""cc"" (""string""))))
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// تۆ کەروێشکێکی برسیت و پێشتر ژمارەیەکی دیاریکراو لە گێزەرت خواردووە، بەڵام ئێستا پێویستە گێزەر زیاتر بخۆیت بۆ تەواوکردنی ژەمی ڕۆژەکە. پێویستە ڤێکتەرێک بگێڕیتەوە [ کۆی گشتی گێزەرەکانی خواردوو دوای ژەمەکانت، ژمارەی گێزەرەکانی پاش ژەمەکانت] ئەگەر ژمارەیەکی پێویست گێزەر نەماوە، ئەوا هەموو گێزەرەکانی ماوە دەخۆیت، بەڵام هێشتا برسیت. نموونە: >>> eat((5), (6), (10)) (std::vector<long>{(()11, (long) 4}) >>> eat(4), (8), (9) (std::vector<long>{() 12, ( (1})) eat >>>(1), (10), (10) (std::vector<long>{() 11, (long) 0)) eat >>>(2), (5) (std::vector<long>{() 7, (long) 0) @ V: ژمارەی تەواوی گێزەرەکانی ماوە کە پێویستت پێیانە بۆ ئەوەی لە کۆنگەردا 1000 ی کۆنگەرت هەبێت: *: 0 *: 0 = <= 1000.
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دوو ڤێکتەری ئۆپەراتۆر و ئۆپەراند. ڤێکتەری یەکەم کاری جەبری بنەڕەتی هەیە، و ڤێکتەری دووەم ڤێکتەری ژمارە تەواوەکانە. ئەم دوو ڤێکتەرە بەکاربهێنە بۆ دروستکردنی دەربڕینی جەبری و گەڕانەوەی هەڵسەنگاندنی ئەم دەربڕینە. ئۆپەراتۆرە بنەڕەتییەکانی جەبری: زیادکردن (+ ) کەمکردنەوە ( ) - لێکدان ( * ) دابەشکردنی زەوی ( // ) دەربڕین ( ** ) نموونە: ئۆپەراتۆر['+'، '*', '-'] ڤێکتەری = [2, 3, 4, 5] ئەنجام = 2 + 3 * 4 - 5 => ئەنجام = 9 تێبینی: درێژی ڤێکتەری ئۆپەراتۆر یەکسانە بە درێژی ڤێکتەری ئۆپەراتۆر کەمکراو یەک. ئۆپەراتۆر ڤێکتەری ژمارە تەواوەکانی نەرێنییە. ڤێکتەری ئۆپەراتۆر لانیکەم یەک ئۆپەراتۆر هەیە، و ڤێکتەری ئۆپەراتۆر لانیکەم دوو ئۆپەراتۆر هەیە.
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// string sت پێ دراوە. ئەگەر s[i] پیت بێت، ئەوا پیتی لە خوارەوە بۆ سەرەوە یان بە پێچەوانەوە هەڵبگرە، ئەگەر نا هێشتووەتەوە وەک خۆی. ئەگەر stringەکە پیت نەبێت، ئەوا stringەکە هەڵبگرە. فانکشنەکە دەبێت stringی دەرەنجام بگەڕێنێتەوە. نموونە >>> solve((""1234"")) (""4321"") >>> solve((""ab"")) (""AB"") >>> solve((""#a@C"")) (""#A@c"")
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// string 'text' بدرێت، string هاوتای md5 hashەکەی بدرێتەوە. ئەگەر 'text' ستریندێکی بەتاڵ بێت، None بدرێتەوە. >>> string_to_md5((""Hello world"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,ckb_Arab,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// بە دوو ژمارەی پۆزەتیڤ a و b، ژمارە جووتەکانی نێوان a و b بە ڕیزێکی بەرزکەرەوە بگەڕێنەوە. بۆ نموونە: >>> generate_integers (((2), (8)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8)) >>> generate_integers (((8), (2)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8)) >>> generate_integers (((10), (14)) (std::vector<long> ((())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
