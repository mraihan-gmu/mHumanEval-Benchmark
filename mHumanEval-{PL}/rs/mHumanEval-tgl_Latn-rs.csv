task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,tgl_Latn,rs,"/// ibinigay na threshold. /// Suriin kung sa ibinigay na vector ng mga numero, ay anumang dalawang numero mas malapit sa bawat isa kaysa sa /// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
","fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
    for i in 0..numbers.len() {
        for j in (i + 1)..numbers.len() {
            if (numbers[i] - numbers[j]).abs() < threshold {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}
"
HumanEval_1,tgl_Latn,rs,"/// Iwasan ang anumang mga puwang sa input string. /// Ang magkahiwalay na grupo ay balanse (ang bawat bukas na brace ay maayos na sarado) at hindi naka-nest sa loob ng bawat isa /// hiwalay ang mga grupo sa hiwalay na mga string at ibalik ang vector ng mga ito. /// Input sa function na ito ay isang string na naglalaman ng maramihang mga grupo ng naka-nest na mga parentehes. Ang iyong layunin ay upang /// >>> separate_paren_groups(String::from(""( ) (( )) (( )( ))""))
/// vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {
","fn separate_paren_groups(paren_string: String) -> Vec<String> {
    let mut groups = Vec::new();
    let mut current_group = String::new();
    let mut open_count = 0;

    for char in paren_string.chars() {
        if char == '(' {
            open_count += 1;
            current_group.push(char);
        } else if char == ')' {
            open_count -= 1;
            current_group.push(char);
        }

        if open_count == 0 && !current_group.is_empty() {
            groups.push(current_group.clone());
            current_group.clear();
        }
    }

    groups
}","}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![String::from(""(()())""), String::from(""((()))""), String::from(""()""), String::from(""((())()())"")]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![String::from(""()""), String::from(""(())""), String::from(""((()))""), String::from(""(((())))"")]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![String::from(""(()(())((())))"")]);
    assert_eq!(candidate(String::from(""( ) (( )) (( )( ))"")), vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]);
}
"
HumanEval_2,tgl_Latn,rs,"/// Ibalik ang bahagi ng decimal ng bilang. /// (ang natitirang bahagi ay laging mas maliit kaysa sa 1). /// at integer bahagi (pinakamadaling integer mas maliit kaysa sa ibinigay na numero) at decimals /// Dahil sa isang positibong floating point number, ito ay maaaring i-decompose sa /// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {
","fn truncate_number(number: f64) -> f64 {
    number - number.floor()
}

fn main() {
    println!(""{}"", truncate_number(3.5)); // 0.5
}","}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}
"
HumanEval_3,tgl_Latn,rs,"/// sa puntong iyon function ay dapat bumalik totoo. Kung hindi dapat bumalik ito false. /// zero balanse. Ang iyong gawain ay upang makita kung sa anumang punto ang balanse ng account falls sa ibaba ng zero, at /// Ikaw ay ibinigay ng isang vector ng deposito at withdrawal operasyon sa isang bank account na nagsisimula sa /// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {
","fn below_zero(operations: Vec<isize>) -> bool {
    let mut balance = 0;
    for operation in operations {
        balance += operation;
        if balance < 0 {
            return true;
        }
    }
    false
}

fn main() {
    println!(""{}"", below_zero(vec![1, 2, 3])); // false
    println!(""{}"", below_zero(vec![1, 2, -4, 5])); // true
    println!(""{}"", below_zero(vec![1, -1, -1, 2])); // true
}","}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}
"
HumanEval_4,tgl_Latn,rs,"/// MAD = average. x - x_mean. /// elemento at isang sentro (mean sa kasong ito): /// Mean Absolute Deviation ay ang average na ganap na pagkakaiba sa pagitan ng bawat /// sa paligid ng katumbas ng dataset na ito. /// Para sa isang ibinigay na vector ng mga input na numero, kalkulahin ang Mean Absolute Deviation /// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
","fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
    let n = numbers.len() as f64;
    if n == 0.0 {
        return 0.0;
    }

    let mean: f64 = numbers.iter().sum::<f64>() / n;
    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() / n;
    
    mad
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0];
    println!(""{}"", mean_absolute_deviation(numbers)); // Output: 1.0
}","}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}
"
HumanEval_5,tgl_Latn,rs,"/// Ipasok ang isang numero 'delimeter' sa pagitan ng bawat dalawang magkakasunod na mga elemento ng input vector `numbers' /// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {
","fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {
    if numbers.is_empty() {
        return Vec::new();
    }
    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);
    for (i, &num) in numbers.iter().enumerate() {
        result.push(num);
        if i != numbers.len() - 1 {
            result.push(delimiter);
        }
    }
    result
}

fn main() {
    println!(""{:?}"", intersperse(vec![], 4)); // Output: Vec::<isize>::new()
    println!(""{:?}"", intersperse(vec![1, 2, 3], 4)); // Output: vec![1, 4, 2, 4, 3]
}","}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}
"
HumanEval_6,tgl_Latn,rs,"/// Halimbawa, ang (() (()) ay may maximum na dalawang antas ng pag-aayuno habang ang ((())) ay may tatlong. /// Para sa bawat isa sa grupo, output ang pinakamalalim na antas ng pag-nest ng mga parentehes. /// Input sa function na ito ay isang string kinakatawan ng maramihang mga grupo para sa naka-nest na mga parentehes na pinaghiwalay ng mga puwang. /// >>> parse_nested_parens(String::from(""(()()) ((())) () ((())()())""))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {
","fn parse_nested_parens(paren_string: String) -> Vec<isize> {
    paren_string.split_whitespace().map(|group| {
        let mut max_depth = 0;
        let mut current_depth = 0;
        for char in group.chars() {
            match char {
                '(' => {
                    current_depth += 1;
                    if current_depth > max_depth {
                        max_depth = current_depth;
                    }
                },
                ')' => {
                    current_depth -= 1;
                },
                _ => {}
            }
        }
        max_depth
    }).collect()
}

fn main() {
    let result = parse_nested_parens(String::from(""(()()) ((())) () ((())()())""));
    println!(""{:?}"", result); // Output: [2, 3, 1, 3]
}","}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![4]);
}
"
HumanEval_7,tgl_Latn,rs,"/// I-filter ang isang input vector ng mga string lamang para sa mga na naglalaman ng ibinigay na substring /// >>> filter_by_substring(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from(""abc""), String::from(""bacd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""bacd""), String::from(""array"")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
","fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
    strings.into_iter().filter(|s| s.contains(&substring)).collect()
}","}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""aaaxxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xx"")), vec![String::from(""xxx""), String::from(""aaaxxy""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""grunt""), String::from(""trumpet""), String::from(""prune""), String::from(""gruesome"")], String::from(""run"")), vec![String::from(""grunt""), String::from(""prune"")]);
}
"
HumanEval_8,tgl_Latn,rs,"/// Ang walang laman na kabuuan ay dapat na katumbas ng 0 at ang walang laman na produkto ay dapat na katumbas ng 1. /// Para sa isang ibinigay na vector ng integers, bumalik ng isang tuple na binubuo ng isang kabuuan at isang produkto ng lahat ng mga integers sa isang vector. /// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
","fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
    let sum = numbers.iter().sum();
    let product = numbers.iter().fold(1, |acc, &x| acc * x);
    (sum, product)
}

fn main() {
    println!(""{:?}"", sum_product(vec![])); // (0, 1)
    println!(""{:?}"", sum_product(vec![1, 2, 3, 4])); // (10, 24)
}","}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}
"
HumanEval_9,tgl_Latn,rs,"/// sa pagkakasunud-sunod. /// Mula sa isang ibinigay na vector ng integers, bumuo ng isang vector ng rolling maximum elemento natagpuan hanggang sa ibinigay na sandali /// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
","fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    let mut current_max = isize::MIN;
    for &num in &numbers {
        if num > current_max {
            current_max = num;
        }
        result.push(current_max);
    }
    result
}","}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}
"
HumanEval_10,tgl_Latn,rs,"/// - Magdagdag sa dulo ng string reverse ng isang string prefix na dumating bago ang palindromic suffix. /// - Hanapin ang pinakamahabang postfix ng ibinigay na string na isang palindrome. /// Ang ideya ng algorithm ay simple: /// Hanapin ang pinakamaikling palindrome na nagsisimula sa isang ibinigay na string. /// >>> make_palindrome(String::from(""""))
/// String::from("""")
/// >>> make_palindrome(String::from(""cat""))
/// String::from(""catac"")
/// >>> make_palindrome(String::from(""cata""))
/// String::from(""catac"")
fn make_palindrome(string: String) -> String {
","fn make_palindrome(string: String) -> String {
    fn is_palindrome(s: &str) -> bool {
        s.chars().eq(s.chars().rev())
    }

    if string.is_empty() || is_palindrome(&string) {
        return string;
    }

    for i in (0..string.len()).rev() {
        if is_palindrome(&string[i..]) {
            let prefix = &string[..i];
            let reversed_prefix: String = prefix.chars().rev().collect();
            return string + &reversed_prefix;
        }
    }

    string
}

fn main() {
    println!(""{:?}"", make_palindrome(String::from(""""))); // String::from("""")
    println!(""{:?}"", make_palindrome(String::from(""cat""))); // String::from(""catac"")
    println!(""{:?}"", make_palindrome(String::from(""cata""))); // String::from(""catac"")
}","}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""x"")), String::from(""x""));
    assert_eq!(candidate(String::from(""xyz"")), String::from(""xyzyx""));
    assert_eq!(candidate(String::from(""xyx"")), String::from(""xyx""));
    assert_eq!(candidate(String::from(""jerry"")), String::from(""jerryrrej""));
}
"
HumanEval_11,tgl_Latn,rs,"/// Gumawa ng binary XOR sa mga input at bumalik resulta din bilang isang string. /// Input ay dalawang string a at b na binubuo lamang ng 1s at 0s. /// >>> string_xor(String::from(""010""), String::from(""110""))
/// String::from(""100"")
fn string_xor(a: String, b: String) -> String {
","fn string_xor(a: String, b: String) -> String {
    a.chars()
     .zip(b.chars())
     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })
     .collect()
}","}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from(""111000""), String::from(""101010"")), String::from(""010010""));
    assert_eq!(candidate(String::from(""1""), String::from(""1"")), String::from(""0""));
    assert_eq!(candidate(String::from(""0101""), String::from(""0000"")), String::from(""0101""));
}
"
HumanEval_12,tgl_Latn,rs,"/// strings ng parehong haba. Magbalik Walang sa kaso ang input vector ay walang laman. /// Sa labas ng vector ng mga string, ibalik ang pinakamahabang isa. ibalik ang unang isa sa kaso ng maramihang /// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// Some(String::from(""a""))
/// >>> longest(vec![String::from(""a""), String::from(""bb""), String::from(""ccc"")])
/// Some(String::from(""ccc""))
fn longest(strings: Vec<String>) -> Option<String> {
","fn longest(strings: Vec<String>) -> Option<String> {
    strings.into_iter().max_by_key(|s| s.len())
}","}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), Some(String::from(""x"")));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""yyy""), String::from(""zzzz""), String::from(""www""), String::from(""kkkk""), String::from(""abc"")]), Some(String::from(""zzzz"")));
}
"
HumanEval_13,tgl_Latn,rs,"/// Magbalik ng isang pinakadakilang karaniwang tagapagbahagi ng dalawang integers a at b /// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {
","fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}","}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}
"
HumanEval_14,tgl_Latn,rs,"/// Bumalik vector ng lahat ng mga prefix mula sa pinakamaikling hanggang sa pinakamahabang ng input string /// >>> all_prefixes(String::from(""abc""))
/// vec![String::from(""a""), String::from(""ab""), String::from(""abc"")]
fn all_prefixes(string: String) -> Vec<String> {
","fn all_prefixes(string: String) -> Vec<String> {
    let mut prefixes = Vec::new();
    for i in 1..=string.len() {
        prefixes.push(string[..i].to_string());
    }
    prefixes
}

// Example usage
fn main() {
    let prefixes = all_prefixes(String::from(""abc""));
    println!(""{:?}"", prefixes);
}","}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""asdfgh"")), vec![String::from(""a""), String::from(""as""), String::from(""asd""), String::from(""asdf""), String::from(""asdfg""), String::from(""asdfgh"")]);
    assert_eq!(candidate(String::from(""WWW"")), vec![String::from(""W""), String::from(""WW""), String::from(""WWW"")]);
}
"
HumanEval_15,tgl_Latn,rs,"/// Magbalik ng isang string na naglalaman ng space-delimited na mga numero simula sa 0 upto n kasama. /// >>> string_sequence(0)
/// String::from(""0"")
/// >>> string_sequence(5)
/// String::from(""0 1 2 3 4 5"")
fn string_sequence(n: isize) -> String {
","fn string_sequence(n: isize) -> String {
    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join("" "")
}","}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from(""0""));
    assert_eq!(candidate(3), String::from(""0 1 2 3""));
    assert_eq!(candidate(10), String::from(""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval_16,tgl_Latn,rs,"/// Na ibinigay ng isang string, alamin kung gaano karaming mga natatanging mga character (indipendent ng kaso) ay binubuo ng /// >>> count_distinct_characters(String::from(""xyzXYZ""))
/// 3
/// >>> count_distinct_characters(String::from(""Jerry""))
/// 4
fn count_distinct_characters(string: String) -> isize {
","use std::collections::HashSet;

fn count_distinct_characters(string: String) -> isize {
    let lowercase_string = string.to_lowercase();
    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();
    distinct_chars.len() as isize
}","}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abcde"")), 5);
    assert_eq!(candidate(String::from(""abcdecadeCADE"")), 5);
    assert_eq!(candidate(String::from(""aaaaAAAAaaaa"")), 1);
    assert_eq!(candidate(String::from(""Jerry jERRY JeRRRY"")), 5);
}
"
HumanEval_17,tgl_Latn,rs,"//'Gawin mo' - quater note, tumatagal ng isang beat /// 'o sahod' - kalahating tala, tumatagal ng dalawang beats /// 'o' - buong tala, tumatagal ng apat na beats /// Narito ang isang alamat: /// hindi huling. /// Ang iyong gawain ay upang pag-parse string na ito at ibalik vector ng integers na katumbas ng kung gaano karaming mga beats ay bawat /// Input sa function na ito ay isang string na kumakatawan sa mga musika tala sa isang espesyal na ASCII format. /// >>> parse_music(String::from(""o o| .| o| o| .| .| .| .| o o""))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {
","fn parse_music(music_string: String) -> Vec<isize> {
    let mut result = Vec::new();
    let notes: Vec<&str> = music_string.split_whitespace().collect();

    for note in notes {
        match note {
            ""o"" => result.push(4),
            ""o|"" => result.push(2),
            "".|"" => result.push(1),
            _ => (),
        }
    }

    result
}

fn main() {
    let music_string = String::from(""o o| .| o| o| .| .| .| .| o o"");
    let beats = parse_music(music_string);
    println!(""{:?}"", beats); // Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
}","}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("""")), Vec::<isize>::new());
    assert_eq!(candidate(String::from(""o o o o"")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from("".| .| .| .|"")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from(""o| o| .| .| o o o o"")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from(""o| .| o| .| o o| o o|"")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}
"
HumanEval_18,tgl_Latn,rs,"/// Hanapin kung ilang beses ang isang ibinigay na substring ay maaaring matagpuan sa orihinal na string. Bilangin ang mga kasong overlapping. /// >>> how_many_times(String::from(""""), String::from(""a""))
/// 0
/// >>> how_many_times(String::from(""aaa""), String::from(""a""))
/// 3
/// >>> how_many_times(String::from(""aaaa""), String::from(""aa""))
/// 3
fn how_many_times(string: String, substring: String) -> isize {
","fn how_many_times(string: String, substring: String) -> isize {
    if substring.is_empty() || string.is_empty() {
        return 0;
    }

    let mut count = 0;
    let mut position = 0;

    while let Some(pos) = string[position..].find(&substring) {
        count += 1;
        position += pos + 1; // Move to the start of the next potential substring
    }

    count
}

fn main() {
    println!(""{}"", how_many_times(String::from(""""), String::from(""a""))); // 0
    println!(""{}"", how_many_times(String::from(""aaa""), String::from(""a""))); // 3
    println!(""{}"", how_many_times(String::from(""aaaa""), String::from(""aa""))); // 3
}","}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""""), String::from(""x"")), 0);
    assert_eq!(candidate(String::from(""xyxyxyx""), String::from(""x"")), 4);
    assert_eq!(candidate(String::from(""cacacacac""), String::from(""cac"")), 4);
    assert_eq!(candidate(String::from(""john doe""), String::from(""john"")), 1);
}
"
HumanEval_19,tgl_Latn,rs,"/// Ibalik ang string na may mga numero na nakaayos mula sa pinakamaliit hanggang sa pinakamalaking /// Ang mga wastong pagpipilian ay 'sero', 'isa', 'dalawa', 'tatlo', 'apat', 'limang', 'anim', 'pito', 'walong' at 'siyam'. /// Input ay isang space-delimited string ng numerals mula sa 'zero' sa 'siyam'. /// >>> sort_numbers(String::from(""three one five""))
/// String::from(""one three five"")
fn sort_numbers(numbers: String) -> String {
","fn sort_numbers(numbers: String) -> String {
    let word_to_number = |word: &str| -> u32 {
        match word {
            ""zero"" => 0,
            ""one"" => 1,
            ""two"" => 2,
            ""three"" => 3,
            ""four"" => 4,
            ""five"" => 5,
            ""six"" => 6,
            ""seven"" => 7,
            ""eight"" => 8,
            ""nine"" => 9,
            _ => panic!(""Invalid input""),
        }
    };

    let words: Vec<&str> = numbers.split_whitespace().collect();
    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();

    number_words.sort_by_key(|&(_, number)| number);

    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join("" "")
}","}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""three"")), String::from(""three""));
    assert_eq!(candidate(String::from(""three five nine"")), String::from(""three five nine""));
    assert_eq!(candidate(String::from(""five zero four seven nine eight"")), String::from(""zero four five seven eight nine""));
    assert_eq!(candidate(String::from(""six five four three two one zero"")), String::from(""zero one two three four five six""));
}
"
HumanEval_20,tgl_Latn,rs,"/// iba at ibalik ang mga ito sa pagkakasunud-sunod (mas maliit na bilang, mas malaking bilang). /// Mula sa isang ibinigay na vector ng mga numero (ng haba ng hindi bababa sa dalawang) piliin at ibalik ang dalawang na ang pinakamalapit sa bawat isa /// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {
","fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {
    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut min_diff = f64::INFINITY;
    let mut result = (0.0, 0.0);

    for i in 0..(numbers.len() - 1) {
        let diff = numbers[i + 1] - numbers[i];
        if diff < min_diff {
            min_diff = diff;
            result = (numbers[i], numbers[i + 1]);
        }
    }
    
    result
}

fn main() {
    // Example usage
    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];
    let res1 = find_closest_elements(vec1);
    println!(""{:?}"", res1); // (2.0, 2.2)

    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];
    let res2 = find_closest_elements(vec2);
    println!(""{:?}"", res2); // (2.0, 2.0)
}","}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}
"
HumanEval_21,tgl_Latn,rs,"/// na ang pinakamaliit na bilang ay magiging 0 at ang pinakamalaking ay magiging 1 /// Dahil sa vector ng mga numero (ng hindi bababa sa dalawang mga elemento), mag-apply ng isang linear transform sa vector na iyon, /// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
","fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
    if numbers.len() < 2 {
        return numbers;
    }

    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);
    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

    numbers.into_iter().map(|x| (x - min_value) / (max_value - min_value)).collect()
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    let rescaled = rescale_to_unit(numbers);
    println!(""{:?}"", rescaled);
}","}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}
"
HumanEval_23,tgl_Latn,rs,"/// Ibalik ang haba ng ibinigay na string /// >>> strlen(String::from(""""))
/// 0
/// >>> strlen(String::from(""abc""))
/// 3
fn strlen(string: String) -> isize {
","fn strlen(string: String) -> isize {
    string.chars().count() as isize
}

fn main() {
    println!(""{}"", strlen(String::from(""""))); // Output: 0
    println!(""{}"", strlen(String::from(""abc""))); // Output: 3
}","}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""x"")), 1);
    assert_eq!(candidate(String::from(""asdasnakj"")), 9);
}
"
HumanEval_24,tgl_Latn,rs,"/// Para sa isang ibinigay na bilang na n, hanapin ang pinakamalaking bilang na nagbabahagi ng n nang pantay, mas maliit kaysa sa n /// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {
","fn largest_divisor(n: isize) -> isize {
    for i in (1..n).rev() {
        if n % i == 0 {
            return i;
        }
    }
    1 // If no other divisor is found, return 1
}

fn main() {
    println!(""{}"", largest_divisor(15)); // Output: 5
}","}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}
"
HumanEval_25,tgl_Latn,rs,"/// Input bilang ay dapat na katumbas ng produkto ng lahat ng mga kadahilanan /// Bawat isa sa mga kadahilanan ay dapat na vectored bilang ng mga beses na nauugnay sa kung gaano karaming beses ito ay lumilitaw sa factorization. /// Return vector ng pangunahing mga kadahilanan ng ibinigay na integer sa pagkakasunud-sunod mula sa pinakamaliit hanggang sa pinakamalaking. /// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {
","fn factorize(mut n: isize) -> Vec<isize> {
    let mut factors = Vec::new();
    let mut divisor = 2;
    while n >= divisor * divisor {
        while n % divisor == 0 {
            factors.push(divisor);
            n /= divisor;
        }
        divisor += 1;
    }
    if n > 1 {
        factors.push(n);
    }
    factors
}

fn main() {
    // Test cases
    println!(""{:?}"", factorize(8));  // Should print: [2, 2, 2]
    println!(""{:?}"", factorize(25)); // Should print: [5, 5]
    println!(""{:?}"", factorize(70)); // Should print: [2, 5, 7]
}","}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}
"
HumanEval_26,tgl_Latn,rs,"/// Panatilihin ang pagkakasunud-sunod ng mga elemento na naiwan na pareho sa input. /// Mula sa isang vector ng mga integer, alisin ang lahat ng mga elemento na nangyayari nang higit sa isang beses. /// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
","use std::collections::HashMap;

fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
    let mut occurrences = HashMap::new();
    
    // Count occurrences of each number
    for &number in &numbers {
        *occurrences.entry(number).or_insert(0) += 1;
    }

    // Filter out numbers that occur more than once
    numbers.into_iter()
        .filter(|&number| occurrences[&number] == 1)
        .collect()
}","}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}
"
HumanEval_27,tgl_Latn,rs,"/// Para sa isang ibinigay na string, i-flip ang mga character ng maliit na titik sa uppercase at uppercase sa maliit na titik. /// >>> flip_case(String::from(""Hello""))
/// String::from(""hELLO"")
fn flip_case(string: String) -> String {
","fn flip_case(string: String) -> String {
    string.chars().map(|c| {
        if c.is_lowercase() {
            c.to_ascii_uppercase()
        } else {
            c.to_ascii_lowercase()
        }
    }).collect()
}","}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hello!"")), String::from(""hELLO!""));
    assert_eq!(candidate(String::from(""These violent delights have violent ends"")), String::from(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval_28,tgl_Latn,rs,"/// Concatenate vector ng mga string sa isang solong string /// >>> concatenate(vec![])
/// String::from("""")
/// >>> concatenate(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// String::from(""abc"")
fn concatenate(strings: Vec<String>) -> String {
","fn concatenate(strings: Vec<String>) -> String {
    strings.concat()
}","}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), String::from(""xyz""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z""), String::from(""w""), String::from(""k"")]), String::from(""xyzwk""));
}
"
HumanEval_29,tgl_Latn,rs,"/// I-filter ang isang input vector ng mga string lamang para sa mga na nagsisimula sa isang ibinigay na prefix. /// >>> filter_by_prefix(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from(""abc""), String::from(""bcd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""array"")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
","fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
    strings.into_iter()
        .filter(|s| s.starts_with(&prefix))
        .collect()
}","}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
}
"
HumanEval_30,tgl_Latn,rs,"/// Magbalik lamang ng mga positibong numero sa vector. /// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {
","fn get_positive(l: Vec<isize>) -> Vec<isize> {
    l.into_iter().filter(|&x| x > 0).collect()
}","}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_31,tgl_Latn,rs,"/// Magbalik ng totoo kung ang isang ibinigay na bilang ay pangunahing, at mali kung hindi. /// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}","}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}
"
HumanEval_33,tgl_Latn,rs,"/// sa mga halaga ng kaukulang mga indices ng l, ngunit na-sort. /// l' ay magkapareho sa l sa mga indices na hindi mahahati sa tatlo, habang ang mga halaga nito sa mga indices na mahahati sa tatlo ay magkapareho /// function na ito ay tumatagal ng isang vector l at bumalik ng isang vector l ' tulad na /// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {
","fn sort_third(l: Vec<isize>) -> Vec<isize> {
    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()
        .enumerate()
        .filter(|&(i, _)| i % 3 == 0)
        .map(|(i, &value)| (i, value))
        .collect();

    // Sort the values that are at indices divisible by 3
    divisible_by_three.sort_by_key(|&(_, value)| value);

    let mut result = l.clone();
    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {
        result[*original_index] = divisible_by_three[sorted_index].1;
    }

    result
}","}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}
"
HumanEval_34,tgl_Latn,rs,"/// Magbalik sa mga uri ng natatanging mga elemento sa isang vector /// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {
","fn unique(mut l: Vec<isize>) -> Vec<isize> {
    l.sort_unstable();
    l.dedup();
    l
}

fn main() {
    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);
    println!(""{:?}"", result);
}","}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}
"
HumanEval_35,tgl_Latn,rs,"/// Magbalik maximum elemento sa vector. /// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {
","fn max_element(l: Vec<isize>) -> isize {
    l.into_iter().max().unwrap()
}","}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}
"
HumanEval_36,tgl_Latn,rs,"/// Ibalik ang bilang ng mga beses ang digit 7 ay lumilitaw sa integers mas mababa sa n na ay divisible sa pamamagitan ng 11 o 13. /// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {
","fn fizz_buzz(n: isize) -> isize {
    (0..n)
        .filter(|&x| x % 11 == 0 || x % 13 == 0)
        .flat_map(|x| x.to_string().chars())
        .filter(|&c| c == '7')
        .count() as isize
}","}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}
"
HumanEval_37,tgl_Latn,rs,"/// sa mga halaga ng kahit na mga indices ng l, ngunit na-sorter. /// l' ay magkapareho sa l sa mga hindi katumbas na indices, habang ang mga halaga nito sa mga pares na indices ay pantay /// function na ito ay tumatagal ng isang vector l at bumalik ng isang vector l ' tulad na /// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {
","fn sort_even(l: Vec<isize>) -> Vec<isize> {
    // Collect even indexed elements and sort them
    let mut even_elements: Vec<isize> = l.iter().enumerate()
        .filter(|&(i, _)| i % 2 == 0)
        .map(|(_, &val)| val)
        .collect();
    even_elements.sort();

    // Reconstruct the vector `l'`
    let mut result = l.clone();
    let mut even_index = 0;

    for i in 0..l.len() {
        if i % 2 == 0 {
            result[i] = even_elements[even_index];
            even_index += 1;
        }
    }
    
    result
}","}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}
"
HumanEval_39,tgl_Latn,rs,"/// prime_fib ay nagbabalik ng n-th bilang na isang Fibonacci numero at ito ay din prime. /// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {
","fn prime_fib(n: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        if num <= 3 {
            return true;
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    fn fibonacci() -> impl Iterator<Item = isize> {
        let mut a: isize = 0;
        let mut b: isize = 1;
        std::iter::from_fn(move || {
            let next = a + b;
            a = b;
            b = next;
            Some(a)
        })
    }

    let mut count = 0;
    for fib_num in fibonacci() {
        if is_prime(fib_num) {
            count += 1;
            if count == n {
                return fib_num;
            }
        }
    }
    -1
}","}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}
"
HumanEval_40,tgl_Latn,rs,"/// sum hanggang sa zero, at mali kung hindi man. /// ito ay bumalik totoo kung may tatlong magkakaibang mga elemento sa vector na /// triples_sum_to_zero ay tumatagal ng isang vector ng mga integer bilang isang input. /// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {
","fn triples_sum_to_zero(l: Vec<isize>) -> bool {
    let n = l.len();
    if n < 3 {
        return false;
    }

    let mut sorted_l = l.clone();
    sorted_l.sort();

    for i in 0..n-2 {
        let a = sorted_l[i];
        let mut left = i + 1;
        let mut right = n - 1;

        while left < right {
            let sum = a + sorted_l[left] + sorted_l[right];
            if sum == 0 {
                return true;
            } else if sum < 0 {
                left += 1;
            } else {
                right -= 1;
            }
        }
    }

    false
}","}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}
"
HumanEval_41,tgl_Latn,rs,"/// function na ito output ang bilang ng mga naturang collisions. /// sa kanilang trajectory na parang hindi sila nag-crash. /// Gayunman, ang mga kotse ay walang hanggan na matibay at malakas; bilang resulta, patuloy silang gumagalaw /// kapag ang isang kotse na gumagalaw kaliwa sa kanan ay tumama sa isang kotse na gumagalaw kanan sa kaliwa. //Lahat ng kotse ay gumagalaw sa parehong bilis.//Ang dalawang set ng mga kotse ay nagsisimula nang malayo sa isa't isa./// n mga kotse ay pagmamaneho kaliwa sa kanan; sabay-sabay, isang iba't ibang hanay ng n mga kotse /// Isipin ang isang daan na isang perpektong tuwid na walang hanggan mahabang linya. fn car_race_collision(n: isize) -> isize {
","fn car_race_collision(n: isize) -> isize {
    // Since every car moving left to right will collide exactly once
    // with every car moving right to left, the number of collisions is n * n
    n * n
}

fn main() {
    let n = 5;
    println!(""Number of collisions: {}"", car_race_collision(n));
}","}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}
"
HumanEval_42,tgl_Latn,rs,"/// Return vector na may mga elemento na pinalaki ng 1. /// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {
","fn incr_list(l: Vec<isize>) -> Vec<isize> {
    l.iter().map(|&x| x + 1).collect()
}","}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}
"
HumanEval_43,tgl_Latn,rs,"/// sum hanggang sa zero, at mali kung hindi man. /// ito ay bumalik totoo kung may dalawang magkakaibang mga elemento sa vector na /// pairs_sum_to_zero ay tumatagal ng isang vector ng mga integer bilang isang input. /// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
","fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
    use std::collections::HashSet;
    let mut seen = HashSet::new();
    
    for &num in &l {
        if seen.contains(&-num) {
            return true;
        }
        seen.insert(num);
    }
    false
}

fn main() {
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, 5, 0])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, -2, 1])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 2, 3, 7])); // false
    println!(""{}"", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); // true
    println!(""{}"", pairs_sum_to_zero(vec![1])); // false
}","}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}
"
HumanEval_44,tgl_Latn,rs,"/// ang mga bilang ng base ay mas mababa sa 10. /// return string representasyon pagkatapos ng conversion. /// Baguhin ang numerikal na base ng input na numero ng x sa base. /// >>> change_base(8, 3)
/// String::from(""22"")
/// >>> change_base(8, 2)
/// String::from(""1000"")
/// >>> change_base(7, 2)
/// String::from(""111"")
fn change_base(x: isize, base: isize) -> String {
","fn change_base(x: isize, base: isize) -> String {
    if base < 2 || base > 9 {
        panic!(""Base must be between 2 and 9"");
    }
    
    if x == 0 {
        return String::from(""0"");
    }
    
    let mut result = String::new();
    let mut number = x;
    
    while number > 0 {
        let remainder = number % base;
        result.push_str(&remainder.to_string());
        number /= base;
    }
    
    result.chars().rev().collect()
}","}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from(""22""));
    assert_eq!(candidate(9, 3), String::from(""100""));
    assert_eq!(candidate(234, 2), String::from(""11101010""));
    assert_eq!(candidate(16, 2), String::from(""10000""));
    assert_eq!(candidate(8, 2), String::from(""1000""));
    assert_eq!(candidate(7, 2), String::from(""111""));
    assert_eq!(candidate(2, 3), String::from(""2""));
    assert_eq!(candidate(3, 4), String::from(""3""));
    assert_eq!(candidate(4, 5), String::from(""4""));
    assert_eq!(candidate(5, 6), String::from(""5""));
    assert_eq!(candidate(6, 7), String::from(""6""));
    assert_eq!(candidate(7, 8), String::from(""7""));
}
"
HumanEval_45,tgl_Latn,rs,"/// Dahil sa haba ng isang gilid at mataas na area ng pagbabalik para sa isang tatsulok. /// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {
","fn triangle_area(a: isize, h: isize) -> f64 {
    (a as f64 * h as f64) / 2.0
}

fn main() {
    let area = triangle_area(5, 3);
    println!(""{}"", area);
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}
"
HumanEval_46,tgl_Latn,rs,"/// Mangyaring sumulat ng isang function upang mahusay na kalkulahin ang n-th elemento ng fib4 numero sequence. Huwag gamitin ang pag-uulit. /// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). /// fib4(3) -> 0 /// fib4(2) -> 2 /// fib4(1) -> 0 /// fib4(0) -> 0 /// Ang Fib4 numero pagkakasunud-sunod ay isang pagkakasunud-sunod na katulad sa Fibbonacci pagkakasunud-sunod na tinukoy tulad ng sumusunod: /// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {
","fn fib4(n: isize) -> isize {
    if n < 0 {
        return 0; // Define behavior for negative input
    }

    let mut sequence = vec![0, 0, 2, 0];

    if n < 4 {
        return sequence[n as usize];
    }

    for i in 4..=n {
        let next_value = sequence[(i - 1) as usize] 
                       + sequence[(i - 2) as usize] 
                       + sequence[(i - 3) as usize] 
                       + sequence[(i - 4) as usize];
        sequence.push(next_value);
    }

    sequence[n as usize]
}

fn main() {
    println!(""{}"", fib4(5)); // 4
    println!(""{}"", fib4(6)); // 8
    println!(""{}"", fib4(7)); // 14
}","}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}
"
HumanEval_47,tgl_Latn,rs,"/// Magbalik median ng mga elemento sa vector l. /// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {
","fn median(l: Vec<isize>) -> f64 {
    let mut l = l.clone();
    l.sort();
    let len = l.len();

    if len % 2 == 0 {
        let mid1 = len / 2;
        let mid2 = mid1 - 1;
        ((l[mid1] as f64) + (l[mid2] as f64)) / 2.0
    } else {
        l[len / 2] as f64
    }
}","}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}
"
HumanEval_48,tgl_Latn,rs,"/// Sinusuri kung ibinigay string ay isang palindrome /// >>> is_palindrome(String::from(""""))
/// true
/// >>> is_palindrome(String::from(""aba""))
/// true
/// >>> is_palindrome(String::from(""aaaaa""))
/// true
/// >>> is_palindrome(String::from(""zbcd""))
/// false
fn is_palindrome(text: String) -> bool {
","fn is_palindrome(text: String) -> bool {
    let chars: Vec<char> = text.chars().collect();
    let len = chars.len();
    for i in 0..len / 2 {
        if chars[i] != chars[len - 1 - i] {
            return false;
        }
    }
    true
}","}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("""")), true);
    assert_eq!(candidate(String::from(""aba"")), true);
    assert_eq!(candidate(String::from(""aaaaa"")), true);
    assert_eq!(candidate(String::from(""zbcd"")), false);
    assert_eq!(candidate(String::from(""xywyx"")), true);
    assert_eq!(candidate(String::from(""xywyz"")), false);
    assert_eq!(candidate(String::from(""xywzx"")), false);
}
"
HumanEval_49,tgl_Latn,rs,"/// Magbalik 2^n modulo p (maalam ang mga numeriko). /// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {
","fn modp(n: isize, p: isize) -> isize {
    if p == 1 {
        return 0;
    }
    let mut result = 1;
    let mut base = 2 % p;
    let mut exponent = n;
    
    while exponent > 0 {
        if exponent % 2 == 1 {
            result = (result * base) % p;
        }
        base = (base * base) % p;
        exponent /= 2;
    }
    
    result
}","}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}
"
HumanEval_51,tgl_Latn,rs,"/// remove_vowels ay isang function na tumatagal ng string at nagbabalik string na walang mga vowel. /// >>> remove_vowels(String::from(""""))
/// String::from("""")
/// >>> remove_vowels(String::from(""abcdef""))
/// String::from(""bcdf"")
/// >>> remove_vowels(String::from(""aaaaa""))
/// String::from("""")
/// >>> remove_vowels(String::from(""aaBAA""))
/// String::from(""B"")
/// >>> remove_vowels(String::from(""zbcd""))
/// String::from(""zbcd"")
fn remove_vowels(text: String) -> String {
","fn remove_vowels(text: String) -> String {
    text.chars()
        .filter(|&c| !""aeiouAEIOU"".contains(c))
        .collect()
}","}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""abcdef
ghijklm"")), String::from(""bcdf
ghjklm""));
    assert_eq!(candidate(String::from(""fedcba"")), String::from(""fdcb""));
    assert_eq!(candidate(String::from(""eeeee"")), String::from(""""));
    assert_eq!(candidate(String::from(""acBAA"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""EcBOO"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""ybcd"")), String::from(""ybcd""));
}
"
HumanEval_52,tgl_Latn,rs,"/// Magbalik true kung ang lahat ng mga numero sa vector l ay sa ibaba threshold t. /// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {
","fn below_threshold(l: Vec<isize>, t: isize) -> bool {
    l.iter().all(|&x| x < t)
}

fn main() {
    println!(""{}"", below_threshold(vec![1, 2, 4, 10], 100)); // true
    println!(""{}"", below_threshold(vec![1, 20, 4, 10], 5));  // false
}","}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}
"
HumanEval_53,tgl_Latn,rs,"/// Magdagdag ng dalawang bilang na x at y /// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {
","fn add(x: isize, y: isize) -> isize {
    x + y
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}
"
HumanEval_54,tgl_Latn,rs,"/// Suriin kung ang dalawang salita ay may parehong mga karakter. /// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))
/// true
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabc""))
/// true
/// >>> same_chars(String::from(""dddddddabc""), String::from(""abcd""))
/// true
/// >>> same_chars(String::from(""eabcd""), String::from(""dddddddabc""))
/// false
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabce""))
/// false
/// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))
/// false
fn same_chars(s0: String, s1: String) -> bool {
","use std::collections::HashSet;

fn same_chars(s0: String, s1: String) -> bool {
    let set0: HashSet<char> = s0.chars().collect();
    let set1: HashSet<char> = s1.chars().collect();
    set0 == set1
}

fn main() {
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))); // true
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabc""))); // true
    println!(""{}"", same_chars(String::from(""dddddddabc""), String::from(""abcd""))); // true
    println!(""{}"", same_chars(String::from(""eabcd""), String::from(""dddddddabc""))); // false
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabce""))); // false
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))); // false
}","}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc"")), true);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabc"")), true);
    assert_eq!(candidate(String::from(""dddddddabc""), String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""eabcd""), String::from(""dddddddabc"")), false);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabcf"")), false);
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc"")), false);
    assert_eq!(candidate(String::from(""aabb""), String::from(""aaccc"")), false);
}
"
HumanEval_55,tgl_Latn,rs,"/// Magbalik ng n-th Fibonacci numero. /// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {
","fn fib(n: isize) -> isize {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 1) + fib(n - 2),
    }
}

fn main() {
    println!(""{}"", fib(10)); // 55
    println!(""{}"", fib(1));  // 1
    println!(""{}"", fib(8));  // 21
}","}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}
"
HumanEval_56,tgl_Latn,rs,"/// bumalik totoo kung ang bawat pagbubukas bracket ay may kaukulang pagsasara bracket. /// parentes ay isang string ng ""<"" at "">"". /// >>> correct_bracketing(String::from(""<""))
/// false
/// >>> correct_bracketing(String::from(""<>""))
/// true
/// >>> correct_bracketing(String::from(""<<><>>""))
/// true
/// >>> correct_bracketing(String::from(""><<>""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for bracket in brackets.chars() {
        if bracket == '<' {
            balance += 1;
        } else if bracket == '>' {
            balance -= 1;
            if balance < 0 {
                return false;
            }
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""<>"")), true);
    assert_eq!(candidate(String::from(""<<><>>"")), true);
    assert_eq!(candidate(String::from(""<><><<><>><>"")), true);
    assert_eq!(candidate(String::from(""<><><<<><><>><>><<><><<>>>"")), true);
    assert_eq!(candidate(String::from(""<<<><>>>>"")), false);
    assert_eq!(candidate(String::from(""><<>"")), false);
    assert_eq!(candidate(String::from(""<"")), false);
    assert_eq!(candidate(String::from(""<<<<"")), false);
    assert_eq!(candidate(String::from("">"")), false);
    assert_eq!(candidate(String::from(""<<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>><<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>>><>"")), false);
}
"
HumanEval_57,tgl_Latn,rs,"/// Magbalik totoo ay vector elemento ay monotonically pagtaas o pagbaba. /// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {
","fn monotonic(l: Vec<isize>) -> bool {
    if l.len() <= 1 {
        return true;
    }
    
    let mut increasing = true;
    let mut decreasing = true;
    
    for i in 0..l.len() - 1 {
        if l[i] < l[i + 1] {
            decreasing = false;
        }
        if l[i] > l[i + 1] {
            increasing = false;
        }
    }
    
    increasing || decreasing
}

fn main() {
    println!(""{}"", monotonic(vec![1, 2, 4, 20])); // true
    println!(""{}"", monotonic(vec![1, 20, 4, 10])); // false
    println!(""{}"", monotonic(vec![4, 1, 0, -10])); // true
}","}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}
"
HumanEval_58,tgl_Latn,rs,"/// Magbalik sa mga uri ng natatanging mga karaniwang elemento para sa dalawang vectors. /// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
","use std::collections::HashSet;

fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
    // Convert both vectors to hash sets to remove duplicates and allow set operations
    let set1: HashSet<_> = l1.into_iter().collect();
    let set2: HashSet<_> = l2.into_iter().collect();

    // Find the intersection of both sets
    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();

    // Convert the intersection set to a sorted vector
    let mut result: Vec<_> = intersection.into_iter().collect();
    result.sort();

    result
}

fn main() {
    // Test cases
    println!(""{:?}"", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); // Should print: [1, 5, 653]
    println!(""{:?}"", common(vec![5, 3, 2, 8], vec![3, 2])); // Should print: [2, 3]
}","}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_59,tgl_Latn,rs,"/// Ibalik ang pinakamalaking pangunahing kadahilanan ng n. Ipagpalagay na n > 1 at hindi isang pangunahing. /// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {
","fn largest_prime_factor(mut n: isize) -> isize {
    let mut largest_factor = 1;

    // Check for number of twos that divide n
    while n % 2 == 0 {
        largest_factor = 2;
        n /= 2;
    }

    // n must be odd at this point, so we can skip even numbers
    let mut factor = 3;
    while factor * factor <= n {
        while n % factor == 0 {
            largest_factor = factor;
            n /= factor;
        }
        factor += 2;
    }

    // If n becomes a prime number greater than 2
    if n > 2 {
        largest_factor = n;
    }

    largest_factor
}

fn main() {
    println!(""{}"", largest_prime_factor(13195));
    println!(""{}"", largest_prime_factor(2048));
}","}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}
"
HumanEval_60,tgl_Latn,rs,"/// sum_to_n ay isang function na sums numero mula 1 hanggang n. /// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {
","fn sum_to_n(n: isize) -> isize {
    n * (n + 1) / 2
}","}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}
"
HumanEval_61,tgl_Latn,rs,"/// bumalik totoo kung ang bawat pagbubukas bracket ay may kaukulang pagsasara bracket. /// parentes ay isang string ng ""("" at "")"". /// >>> correct_bracketing(String::from(""(""))
/// false
/// >>> correct_bracketing(String::from(""()""))
/// true
/// >>> correct_bracketing(String::from(""(()())""))
/// true
/// >>> correct_bracketing(String::from("")(()""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for c in brackets.chars() {
        if c == '(' {
            balance += 1;
        } else if c == ')' {
            balance -= 1;
        }

        if balance < 0 {
            return false;
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""()"")), true);
    assert_eq!(candidate(String::from(""(()())"")), true);
    assert_eq!(candidate(String::from(""()()(()())()"")), true);
    assert_eq!(candidate(String::from(""()()((()()())())(()()(()))"")), true);
    assert_eq!(candidate(String::from(""((()())))"")), false);
    assert_eq!(candidate(String::from("")(()"")), false);
    assert_eq!(candidate(String::from(""("")), false);
    assert_eq!(candidate(String::from(""(((("")), false);
    assert_eq!(candidate(String::from("")"")), false);
    assert_eq!(candidate(String::from(""(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())())(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())()))()"")), false);
}
"
HumanEval_62,tgl_Latn,rs,"/// Ibalik ang derivative ng polynomial na ito sa parehong anyo. /// xs[0] + xs[1] * x + xs[2] * x^2 + .... /// xs kumakatawan sa mga coefficient ng isang polynomial. /// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {
","fn derivative(xs: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    for (i, &coeff) in xs.iter().enumerate().skip(1) {
        result.push(coeff * i as isize);
    }
    result
}

fn main() {
    let poly1 = vec![3, 1, 2, 4, 5];
    let poly2 = vec![1, 2, 3];
    println!(""{:?}"", derivative(poly1)); // Output: [1, 4, 12, 20]
    println!(""{:?}"", derivative(poly2)); // Output: [2, 6]
}","}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}
"
HumanEval_63,tgl_Latn,rs,"/// Mangyaring sumulat ng isang function upang mahusay na kalkulahin ang n-th elemento ng mga numero sequence fibfib. /// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). /// fib fib ((2) == 1 /// fib fib ((1) == 0 /// fib fib ((0) == 0 /// Ang FibFib numero pagkakasunud-sunod ay isang pagkakasunud-sunod na katulad sa Fibbonacci sequence na tinukoy tulad ng sumusunod: /// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {
","fn fibfib(n: isize) -> isize {
    if n < 0 {
        // Optionally handle negative indices as an error or specific value
        return -1; // Example error indicator
    }
    match n {
        0 => 0,
        1 => 0,
        2 => 1,
        _ => {
            let mut a = 0;
            let mut b = 0;
            let mut c = 1;
            let mut result = 0;
            for _ in 3..=n {
                result = a + b + c;
                a = b;
                b = c;
                c = result;
            }
            result
        }
    }
}","}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}
"
HumanEval_64,tgl_Latn,rs,"/// Halimbawa: /// vowel, ngunit lamang kapag ito ay nasa dulo ng ibinigay na salita. /// Ang mga boses sa kasong ito ay 'a', 'e', 'i', 'o', 'u'. Dito, 'y' ay isa ring /// isang salita bilang input at ibabalik ang bilang ng mga vowels sa string. /// Isulat ang isang function na vowels_count na tumatagal ng isang string na kumakatawan sa /// >>> vowels_count(String::from(""abcde""))
/// 2
/// >>> vowels_count(String::from(""ACEDY""))
/// 3
fn vowels_count(s: String) -> isize {
","fn vowels_count(s: String) -> isize {
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let s = s.to_lowercase();
    let mut count = 0;

    for (i, c) in s.chars().enumerate() {
        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {
            count += 1;
        }
    }
    
    count
}

fn main() {
    println!(""{}"", vowels_count(String::from(""abcde""))); // Output: 2
    println!(""{}"", vowels_count(String::from(""ACEDY""))); // Output: 3
}","}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from(""abcde"")), 2);
    assert_eq!(candidate(String::from(""Alone"")), 3);
    assert_eq!(candidate(String::from(""key"")), 2);
    assert_eq!(candidate(String::from(""bye"")), 1);
    assert_eq!(candidate(String::from(""keY"")), 2);
    assert_eq!(candidate(String::from(""bYe"")), 1);
    assert_eq!(candidate(String::from(""ACEDY"")), 3);
}
"
HumanEval_65,tgl_Latn,rs,"/// Kung shift > bilang ng mga digit, ibalik ang mga digit. /// at ibalik ang resulta bilang isang string. /// Circular shift ang mga digit ng integer x, shift ang mga digit sa kanan sa pamamagitan ng shift /// >>> circular_shift(12, 1)
/// String::from(""21"")
/// >>> circular_shift(12, 2)
/// String::from(""12"")
fn circular_shift(x: isize, shift: isize) -> String {
","fn circular_shift(x: isize, shift: isize) -> String {
    let mut digits: Vec<char> = x.abs().to_string().chars().collect();
    let len = digits.len() as isize;
    
    if shift > len {
        digits.reverse();
    } else {
        digits.rotate_right(shift as usize % len as usize);
    }
    
    digits.into_iter().collect()
}","}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from(""001""));
    assert_eq!(candidate(12, 2), String::from(""12""));
    assert_eq!(candidate(97, 8), String::from(""79""));
    assert_eq!(candidate(12, 1), String::from(""21""));
    assert_eq!(candidate(11, 101), String::from(""11""));
}
"
HumanEval_66,tgl_Latn,rs,"/// Mga halimbawa: /// Mga ASCII code. /// Sumulat ng isang function na tumatagal ng isang string bilang input at ibabalik ang kabuuan ng mga itaas na mga character lamang' /// Tungkulin /// >>> digitSum(String::from(""""))
/// 0
/// >>> digitSum(String::from(""abAB""))
/// 131
/// >>> digitSum(String::from(""abcCd""))
/// 67
/// >>> digitSum(String::from(""helloE""))
/// 69
/// >>> digitSum(String::from(""woArBld""))
/// 131
/// >>> digitSum(String::from(""aAaaaXa""))
/// 153
fn digitSum(s: String) -> isize {
","fn digitSum(s: String) -> isize {
    s.chars()
     .filter(|c| c.is_uppercase())
     .map(|c| c as isize)
     .sum()
}","}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abAB"")), 131);
    assert_eq!(candidate(String::from(""abcCd"")), 67);
    assert_eq!(candidate(String::from(""helloE"")), 69);
    assert_eq!(candidate(String::from(""woArBld"")), 131);
    assert_eq!(candidate(String::from(""aAaaaXa"")), 153);
    assert_eq!(candidate(String::from("" How are yOu?"")), 151);
    assert_eq!(candidate(String::from(""You arE Very Smart"")), 327);
}
"
HumanEval_67,tgl_Latn,rs,"/// para sa examble: /// sa basket ibalik ang bilang ng mga prutas ng mangga sa basket. /// ang mga kahel at mansanas at isang integer na kumakatawan sa kabuuang bilang ng mga prutas /// mansanas, kahel, at mangga prutas. Given ang string na kumakatawan sa kabuuang bilang ng /// na ipinamamahagi sa isang basket ng prutas na nasa loob ng basket na ito /// Sa gawain na ito, bibigyan ka ng isang string na kumakatawan sa isang bilang ng mga mansanas at mga kahel /// >>> fruit_distribution(String::from(""5 apples and 6 oranges""), 19)
/// 8
/// >>> fruit_distribution(String::from(""0 apples and 1 oranges""), 3)
/// 2
/// >>> fruit_distribution(String::from(""2 apples and 3 oranges""), 100)
/// 95
/// >>> fruit_distribution(String::from(""100 apples and 1 oranges""), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {
","fn fruit_distribution(s: String, n: isize) -> isize {
    let mut parts = s.split_whitespace();
    let apples: isize = parts.next().unwrap().parse().unwrap();
    parts.next(); // skip ""apples""
    parts.next(); // skip ""and""
    let oranges: isize = parts.next().unwrap().parse().unwrap();
    
    n - (apples + oranges)
}

fn main() {
    assert_eq!(fruit_distribution(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(fruit_distribution(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(fruit_distribution(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(fruit_distribution(String::from(""100 apples and 1 oranges""), 120), 19);
    println!(""All test cases passed!"");
}","}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 21), 10);
    assert_eq!(candidate(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""1 apples and 0 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 5), 0);
    assert_eq!(candidate(String::from(""1 apples and 100 oranges""), 120), 19);
}
"
HumanEval_68,tgl_Latn,rs,"/// Halimbawa 1: /// Kung walang kahit na mga halaga o ang ibinigay na vector ay walang laman, bumalik []. /// Ang plucked node ay dapat na ibalik sa isang vector, [ smalest_value, ang index nito ], /// Kung maramihang mga node na may parehong pinakamaliit na kahit na halaga ay natagpuan bumalik ang node na may pinakamaliit na index. /// Ang pinutol na node ay dapat ang node na may pinakamaliit na kahit na halaga. /// ang iyong gawain ay upang kunin ang isa sa mga node at ibalik ito. /// ""Ibigay ang isang vector na kumakatawan sa isang sangay ng isang puno na may non-negative integer nodes /// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {
","fn pluck(arr: Vec<isize>) -> Vec<isize> {
    let mut smallest_even: Option<(isize, usize)> = None;

    for (index, &value) in arr.iter().enumerate() {
        if value % 2 == 0 {
            match smallest_even {
                None => smallest_even = Some((value, index)),
                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),
                _ => {}
            }
        }
    }

    match smallest_even {
        Some((value, index)) => vec![value, index as isize],
        None => Vec::new(),
    }
}","}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}
"
HumanEval_69,tgl_Latn,rs,"/// Mga halimbawa: /// Kung walang ganoong halaga ay umiiral, ibalik -1. /// Ang dalas ng isang integer ay ang bilang ng mga beses ito ay lumilitaw sa vector. /// zero, at may isang dalas na mas malaki o katumbas ng halaga ng integer mismo. /// Ikaw ay ibinigay ng isang hindi-walang laman na vector ng positibong integers. Bumalik ang pinakamalaking integer na mas malaki kaysa sa /// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {
","fn search(lst: Vec<isize>) -> isize {
    use std::collections::HashMap;
    
    let mut frequency_map = HashMap::new();
    
    // Count the frequency of each integer in the vector
    for &num in &lst {
        *frequency_map.entry(num).or_insert(0) += 1;
    }
    
    let mut result = -1;
    
    // Iterate over the map to find the greatest integer with a frequency
    // greater than or equal to its value
    for (&num, &freq) in &frequency_map {
        if freq >= num && num > result {
            result = num;
        }
    }
    
    result
}

// Test cases
fn main() {
    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);
    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);
    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);
}","}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}
"
HumanEval_70,tgl_Latn,rs,"/// Mga halimbawa: /// pagkatapos ay maximum ng natitirang integers, pagkatapos ay minimum at iba pa. /// kakaibang pag-uuri, ay kapag nagsimula ka sa minimum na halaga, /// Dahil sa vector ng integers, bumalik vector sa kakaibang pagkakasunud-sunod. /// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {
","fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::with_capacity(lst.len());
    lst.sort();

    while !lst.is_empty() {
        // Take the smallest element
        if let Some(min) = lst.first().cloned() {
            result.push(min);
            lst.remove(0);
        }
        // Take the largest element
        if let Some(max) = lst.last().cloned() {
            result.push(max);
            lst.pop();
        }
    }

    result
}

fn main() {
    println!(""{:?}"", strange_sort_list(vec![1, 2, 3, 4])); // Output: vec![1, 4, 2, 3]
    println!(""{:?}"", strange_sort_list(vec![5, 5, 5, 5])); // Output: vec![5, 5, 5, 5]
    println!(""{:?}"", strange_sort_list(vec![])); // Output: Vec::<isize>::new()
}","}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}
"
HumanEval_71,tgl_Latn,rs,"/// Halimbawa: /// kaysa sa ikatlong panig. /// Tatlong panig ang gumagawa ng isang makatwirang tatsulok kapag ang kabuuan ng alinman sa dalawang panig ay mas malaki /// Kung hindi man ay bumalik sa -1 /// ang tatsulok na pinarundong sa 2 decimal na puntos kung ang tatlong panig ay bumubuo ng isang wastong tatsulok. /// Dahil sa haba ng tatlong panig ng isang tatsulok. Ibalik ang lugar ng /// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
","fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
    if a + b > c && a + c > b && b + c > a {
        let s = (a + b + c) as f64 / 2.0;
        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();
        (area * 100.0).round() / 100.0
    } else {
        -1.0
    }
}

fn main() {
    println!(""{}"", triangle_area(3, 4, 5)); // 6.0
    println!(""{}"", triangle_area(1, 2, 10)); // -1.0
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}
"
HumanEval_72,tgl_Latn,rs,"/// Halimbawa: /// Ang bagay q ay lumipad kung ito ay balanse (ito ay isang palindromic vector) at ang kabuuan ng mga elemento ay mas mababa sa o katumbas ng maximum na posibleng timbang w. /// Isulat ang isang function na bumalik totoo kung ang bagay q ay lumipad, at mali kung hindi. /// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
","fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
    let sum: isize = q.iter().sum();
    let is_palindromic = q.iter().eq(q.iter().rev());

    is_palindromic && sum <= w
}

fn main() {
    // Test cases
    println!(""{}"", will_it_fly(vec![1, 2], 5)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 1)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 9)); // true
    println!(""{}"", will_it_fly(vec![3], 5)); // true
}","}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}
"
HumanEval_73,tgl_Latn,rs,"/// Halimbawa: /// ay basahin ang parehong pabalik at pasulong. Sa isang pagbabago, maaari mong baguhin ang isang elemento sa anumang iba pang mga elemento. /// kailangang baguhin upang gawin ang vector palindromic. Ang isang palindromic vector ay isang vector na /// Dahil sa isang vector arr ng mga integers, hanapin ang pinakamaliit na bilang ng mga elemento na /// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {
","fn smallest_change(arr: Vec<isize>) -> isize {
    let mut changes = 0;
    let n = arr.len();
    
    for i in 0..n/2 {
        if arr[i] != arr[n - i - 1] {
            changes += 1;
        }
    }
    
    changes
}

// Example usage:
// fn main() {
//     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);
//     println!(""{}"", result); // Outputs: 4
// }","}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}
"
HumanEval_74,tgl_Latn,rs,"/// Mga Halimbawa /// kung ang dalawang vectors ay may parehong bilang ng chars, ibalik ang unang vector. /// kabuuang bilang ng mga chars sa lahat ng mga string ng vector mas mababa kaysa sa iba pang vector. /// Isulat ang isang function na tumatanggap ng dalawang vector ng mga string at ibabalik ang vector na may /// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")])
/// vec![String::from(""hI""), String::from(""Hi"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")])
/// vec![String::from(""hi""), String::from(""admin"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")])
/// vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]
/// >>> total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")])
/// vec![String::from(""4"")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
","fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();

    if char_count(&lst1) <= char_count(&lst2) {
        lst1
    } else {
        lst2
    }
}

// Example usage
fn main() {
    let result1 = total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]);
    println!(""{:?}"", result1);

    let result2 = total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]);
    println!(""{:?}"", result2);
}","}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi"")]), vec![String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]), vec![String::from(""4"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]), vec![String::from(""hI""), String::from(""Hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]), vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hii"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(""this"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""this"")], Vec::<String>::new()), Vec::<String>::new());
}
"
HumanEval_75,tgl_Latn,rs,"/// Halimbawa: /// Sa pagkaalam na ang (a) ay mas mababa sa 100. /// at mali kung hindi man. /// Isulat ang isang function na bumalik totoo kung ang ibinigay na numero ay ang pagkalipat ng 3 mga pangunahing numero /// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {
","fn is_multiply_prime(a: isize) -> bool {
    fn is_prime(n: isize) -> bool {
        if n <= 1 {
            return false;
        }
        if n <= 3 {
            return true;
        }
        if n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    if a < 2 {
        return false;
    }

    let mut primes = Vec::new();
    for i in 2..a {
        if is_prime(i) {
            primes.push(i);
        }
    }

    let p_len = primes.len();
    for i in 0..p_len {
        for j in i..p_len {
            for k in j..p_len {
                if primes[i] * primes[j] * primes[k] == a {
                    return true;
                }
            }
        }
    }
    false
}","}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}
"
HumanEval_76,tgl_Latn,rs,"/// Halimbawa: /// x ay isang simpleng kapangyarihan ng n kung n**int=x /// kapangyarihan ng n at false sa ibang mga kaso. /// Ang iyong gawain ay upang isulat ang isang function na bumalik totoo kung ang isang bilang na x ay isang simple /// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {
","fn is_simple_power(x: isize, n: isize) -> bool {
    if x <= 0 || n <= 0 {
        return false;
    } else if x == 1 {
        return true;
    } else if n == 1 {
        return x == 1;
    }

    let mut power_n = n;
    while power_n < x {
        power_n *= n;
    }
    power_n == x
}

fn main() {
    println!(""{}"", is_simple_power(1, 4)); // true
    println!(""{}"", is_simple_power(2, 2)); // true
    println!(""{}"", is_simple_power(8, 2)); // true
    println!(""{}"", is_simple_power(3, 2)); // false
    println!(""{}"", is_simple_power(3, 1)); // false
    println!(""{}"", is_simple_power(5, 3)); // false
}","}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}
"
HumanEval_77,tgl_Latn,rs,"/// Mga halimbawa: /// Tandaan: maaari mong isipin na ang input ay palaging may bisa. /// kung ang ingeger na ito ay isang kubo ng ilang integer na numero. /// Sumulat ng isang function na tumatagal ng isang integer at nagbabalik true /// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {
","fn iscube(a: isize) -> bool {
    if a < 0 {
        // For negative numbers, take the cube root of the absolute value.
        let cube_root = (-a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    } else {
        let cube_root = (a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    }
}

fn main() {
    println!(""{}"", iscube(1));   // true
    println!(""{}"", iscube(2));   // false
    println!(""{}"", iscube(-1));  // true
    println!(""{}"", iscube(64));  // true
    println!(""{}"", iscube(0));   // true
    println!(""{}"", iscube(180)); // false
}","}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}
"
HumanEval_78,tgl_Latn,rs,"/// Mga halimbawa: /// at ang mga simbolo A,B,C,D,E,F ay laging malalaking titik. /// Tandaan: maaari mong isipin ang input ay palaging tama o walang laman string, /// B (= desimal 11), D (= desimal 13). /// Kaya kailangan mong matukoy ang isang bilang ng mga sumusunod na digit: 2, 3, 5, 7, /// Ang mga bilang bilang ay 2, 3, 5, 7, 11, 13, 17,... /// Hexadecimal digit ay 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. /// higit sa 1 na hindi produkto ng dalawang mas maliit na natural na numero). /// digits na mga primes (ang prime number, o isang prime, ay isang natural na numero /// isang hexadecimal bilang isang string at bilangin ang bilang ng hexadecimal /// Ikaw ay tasked na magsulat ng isang function na tumatanggap /// >>> hex_key(String::from(""AB""))
/// 1
/// >>> hex_key(String::from(""1077E""))
/// 2
/// >>> hex_key(String::from(""ABED1A33""))
/// 4
/// >>> hex_key(String::from(""123456789ABCDEF0""))
/// 6
/// >>> hex_key(String::from(""2020""))
/// 2
fn hex_key(num: String) -> isize {
","fn hex_key(num: String) -> isize {
    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];
    num.chars()
        .filter(|c| prime_hex_chars.contains(c))
        .count() as isize
}","}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from(""AB"")), 1);
    assert_eq!(candidate(String::from(""1077E"")), 2);
    assert_eq!(candidate(String::from(""ABED1A33"")), 4);
    assert_eq!(candidate(String::from(""2020"")), 2);
    assert_eq!(candidate(String::from(""123456789ABCDEF0"")), 6);
    assert_eq!(candidate(String::from(""112233445566778899AABBCCDDEEFF00"")), 12);
}
"
HumanEval_79,tgl_Latn,rs,"/// Mga halimbawa: /// Ang dagdag na mga karakter ay para makatulong sa pormat. /// Magkakaroon ng isang dagdag na pares ng mga character 'db' sa simula at sa dulo ng string. //Ang bawat character sa string ay magiging '0' o '1'. /// binary format. Ang function ay dapat bumalik ng isang string, na may bawat character na kumakatawan sa isang binary /// Bibigyan ka ng isang numero sa decimal form at ang iyong gawain ay upang i-convert ito sa /// >>> decimal_to_binary(15)
/// String::from(""db1111db"")
/// >>> decimal_to_binary(32)
/// String::from(""db100000db"")
fn decimal_to_binary(decimal: isize) -> String {
","fn decimal_to_binary(decimal: isize) -> String {
    let binary_string = format!(""{:b}"", decimal);
    format!(""db{}db"", binary_string)
}

fn main() {
    // Example usage
    let binary_15 = decimal_to_binary(15);
    let binary_32 = decimal_to_binary(32);
    println!(""{}"", binary_15); // Outputs: db1111db
    println!(""{}"", binary_32); // Outputs: db100000db
}","}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from(""db0db""));
    assert_eq!(candidate(32), String::from(""db100000db""));
    assert_eq!(candidate(103), String::from(""db1100111db""));
    assert_eq!(candidate(15), String::from(""db1111db""));
}
"
HumanEval_80,tgl_Latn,rs,"/// Halimbawa: /// Isang string ay haprs kung ang haba nito ay hindi bababa sa 3 at bawat 3 magkakasunod na mga titik ay magkakaiba /// Ang iyong gawain ay upang suriin kung ang string ay haprs o hindi. /// Ikaw ay binigyan ng isang string s. /// >>> is_happy(String::from(""a""))
/// false
/// >>> is_happy(String::from(""aa""))
/// false
/// >>> is_happy(String::from(""abcd""))
/// true
/// >>> is_happy(String::from(""aabb""))
/// false
/// >>> is_happy(String::from(""adb""))
/// true
/// >>> is_happy(String::from(""xyy""))
/// false
fn is_happy(s: String) -> bool {
","fn is_happy(s: String) -> bool {
    if s.len() < 3 {
        return false;
    }

    let chars: Vec<char> = s.chars().collect();
    for i in 0..(chars.len() - 2) {
        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {
            return false;
        }
    }

    true
}

fn main() {
    println!(""{}"", is_happy(String::from(""a""))); // false
    println!(""{}"", is_happy(String::from(""aa""))); // false
    println!(""{}"", is_happy(String::from(""abcd""))); // true
    println!(""{}"", is_happy(String::from(""aabb""))); // false
    println!(""{}"", is_happy(String::from(""adb""))); // true
    println!(""{}"", is_happy(String::from(""xyy""))); // false
}","}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from(""a"")), false);
    assert_eq!(candidate(String::from(""aa"")), false);
    assert_eq!(candidate(String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""adb"")), true);
    assert_eq!(candidate(String::from(""xyy"")), false);
    assert_eq!(candidate(String::from(""iopaxpoi"")), true);
    assert_eq!(candidate(String::from(""iopaxioi"")), false);
}
"
HumanEval_81,tgl_Latn,rs,"/// Halimbawa: /// 0.0 E /// > 0.0 D- /// > 0.7 D /// > 1.0 D+ /// > 1.3 C- /// > 1.7 C /// > 2.0 C+ /// > 2.3 B- /// > 2.7 B /// > 3.0 B+ /// > 3.3 A- /// > 3.7 A /// 4.0 A+ /// GPA.  Grade ng letra /// isang function na maaaring output ng isang vector ng mga grado ng titik gamit ang mga sumusunod na talahanayan: /// Nagbigay siya sa iyo ng isang vector ng GPA para sa ilang mga mag-aaral at kailangan mong magsulat /// Ang tanging problema ay, nawala na sa kanya ang code na ginamit niya para sa paggrade. /// sa mga mag-aaral. Ang guro ay gumagawa ng sariling algorithm para sa grading. /// Ito ang huling linggo ng semestre at ang guro ay dapat magbigay ng mga marka /// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
","fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
    grades.into_iter().map(|gpa| {
        match gpa {
            4.0 => String::from(""A+""),
            v if v > 3.7 => String::from(""A""),
            v if v > 3.3 => String::from(""A-""),
            v if v > 3.0 => String::from(""B+""),
            v if v > 2.7 => String::from(""B""),
            v if v > 2.3 => String::from(""B-""),
            v if v > 2.0 => String::from(""C+""),
            v if v > 1.7 => String::from(""C""),
            v if v > 1.3 => String::from(""C-""),
            v if v > 1.0 => String::from(""D+""),
            v if v > 0.7 => String::from(""D""),
            v if v > 0.0 => String::from(""D-""),
            _ => String::from(""E""),
        }
    }).collect()
}","}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from(""D+"")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from(""D-"")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from(""E"")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(""D""), String::from(""D-""), String::from(""C-""), String::from(""B""), String::from(""B+"")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(""E""), String::from(""D-"")]);
}
"
HumanEval_82,tgl_Latn,rs,"/// Mga Halimbawa /// haba ay isang pangunahing numero o mali kung hindi man /// Sumulat ng isang function na tumatagal ng isang string at nagbabalik true kung ang string /// >>> prime_length(String::from(""Hello""))
/// true
/// >>> prime_length(String::from(""abcdcba""))
/// true
/// >>> prime_length(String::from(""kittens""))
/// true
/// >>> prime_length(String::from(""orange""))
/// false
fn prime_length(string: String) -> bool {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn prime_length(string: String) -> bool {
    let length = string.len();
    is_prime(length)
}

// Example usage
fn main() {
    println!(""{}"", prime_length(String::from(""Hello""))); // true
    println!(""{}"", prime_length(String::from(""abcdcba""))); // true
    println!(""{}"", prime_length(String::from(""kittens""))); // true
    println!(""{}"", prime_length(String::from(""orange""))); // false
}","}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from(""Hello"")), true);
    assert_eq!(candidate(String::from(""abcdcba"")), true);
    assert_eq!(candidate(String::from(""kittens"")), true);
    assert_eq!(candidate(String::from(""orange"")), false);
    assert_eq!(candidate(String::from(""wow"")), true);
    assert_eq!(candidate(String::from(""world"")), true);
    assert_eq!(candidate(String::from(""MadaM"")), true);
    assert_eq!(candidate(String::from(""Wow"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""HI"")), true);
    assert_eq!(candidate(String::from(""go"")), true);
    assert_eq!(candidate(String::from(""gogo"")), false);
    assert_eq!(candidate(String::from(""aaaaaaaaaaaaaaa"")), false);
    assert_eq!(candidate(String::from(""Madam"")), true);
    assert_eq!(candidate(String::from(""M"")), false);
    assert_eq!(candidate(String::from(""0"")), false);
}
"
HumanEval_83,tgl_Latn,rs,"/// positibong integers na nagsisimula o nagtatapos sa 1. /// Dahil sa isang positibong integer n, ibalik ang bilang ng mga numero ng n-digit fn starts_one_ends(n: isize) -> isize {
","fn starts_one_ends(n: isize) -> isize {
    if n <= 0 {
        return 0;
    }
    if n == 1 {
        return 1; // only '1' satisfies the condition for a single-digit
    }

    // Consider numbers starting with '1' (1XXXX...)
    let start_with_one = 9isize.pow((n-1) as u32);

    // Consider numbers ending with '1' (...XXXX1)
    let end_with_one = 9isize.pow((n-1) as u32);
    
    // Consider numbers both starting and ending with '1' and check overlaps (1XXX1)
    let both_start_end_one = 9isize.pow((n-2) as u32);

    // Total numbers starting or ending with '1'
    start_with_one + end_with_one - both_start_end_one
}

fn main() {
    // Example usage:
    let n = 3;
    println!(""Count of n-digit numbers starting or ending with 1: {}"", starts_one_ends(n));
}","}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}
"
HumanEval_84,tgl_Latn,rs,"/// Halimbawa /// Dahil sa isang positibong integer N, ibalik ang kabuuang kabuuan ng mga digit nito sa binary. /// >>> solve(1000)
/// String::from(""1"")
/// >>> solve(150)
/// String::from(""110"")
/// >>> solve(147)
/// String::from(""1100"")
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {
","fn solve(N: isize) -> String {
    let sum_of_digits: isize = N
        .to_string()
        .chars()
        .map(|c| c.to_digit(10).unwrap() as isize)
        .sum();
    
    format!(""{:b}"", sum_of_digits)
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from(""1""));
    assert_eq!(candidate(150), String::from(""110""));
    assert_eq!(candidate(147), String::from(""1100""));
    assert_eq!(candidate(333), String::from(""1001""));
    assert_eq!(candidate(963), String::from(""10010""));
}
"
HumanEval_85,tgl_Latn,rs,"/// Mga halimbawa: /// Dahil sa isang hindi-walang laman na vector ng mga integer lst. magdagdag ng kahit na mga elemento na nasa kakaibang mga index .. /// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {
","fn add(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, _)| i % 2 == 1) // select odd indices
        .map(|(_, &x)| x) // get the values at odd indices
        .filter(|&x| x % 2 == 0) // filter even values
        .sum() // sum the values
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}
"
HumanEval_86,tgl_Latn,rs,"/// Halimbawa: /// Tandaan: Dapat mong panatilihin ang pagkakasunud-sunod ng mga salita at mga espasyo sa pangungusap. /// pag-akyat na pagkakasunud-sunod batay sa halaga ng ascii. /// ay pinalitan ng isang bagong salita kung saan ang lahat ng mga character ay nakaayos sa /// Na-order na bersyon ng string, ay isang string kung saan ang lahat ng mga salita (na hiwalay sa pamamagitan ng puwang) /// Isulat ang isang function na tumatagal ng isang string at nagbabalik ng isang inorder na bersyon nito. /// >>> anti_shuffle(String::from(""Hi""))
/// String::from(""Hi"")
/// >>> anti_shuffle(String::from(""hello""))
/// String::from(""ehllo"")
/// >>> anti_shuffle(String::from(""Hello World!!!""))
/// String::from(""Hello !!!Wdlor"")
fn anti_shuffle(s: String) -> String {
","fn anti_shuffle(s: String) -> String {
    let mut result = String::new();
    let mut word = String::new();

    for c in s.chars() {
        if c.is_whitespace() {
            if !word.is_empty() {
                let mut chars: Vec<char> = word.chars().collect();
                chars.sort_unstable();
                result.push_str(&chars.into_iter().collect::<String>());
                word.clear();
            }
            result.push(c);
        } else {
            word.push(c);
        }
    }

    if !word.is_empty() {
        let mut chars: Vec<char> = word.chars().collect();
        chars.sort_unstable();
        result.push_str(&chars.into_iter().collect::<String>());
    }

    result
}

fn main() {
    // Example usages:
    println!(""{}"", anti_shuffle(String::from(""Hi"")));              // ""Hi""
    println!(""{}"", anti_shuffle(String::from(""hello"")));           // ""ehllo""
    println!(""{}"", anti_shuffle(String::from(""Hello World!!!"")));  // ""Hello !!!Wdlor""
}","}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from(""Hi"")), String::from(""Hi""));
    assert_eq!(candidate(String::from(""hello"")), String::from(""ehllo""));
    assert_eq!(candidate(String::from(""number"")), String::from(""bemnru""));
    assert_eq!(candidate(String::from(""abcd"")), String::from(""abcd""));
    assert_eq!(candidate(String::from(""Hello World!!!"")), String::from(""Hello !!!Wdlor""));
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hi. My name is Mister Robot. How are you?"")), String::from("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval_87,tgl_Latn,rs,"/// Mga halimbawa: /// Gayundin, i-sort ang mga coordinate ng hilera sa pamamagitan ng mga haligi sa bumababa na pagkakasunud-sunod. /// I-sort ang mga coordinate sa simula sa pamamagitan ng mga hilera sa pagtaas na pagkakasunud-sunod. /// bawat tuple ay isang coordinate - (baybay, haligi), na nagsisimula sa 0. /// at bumalik vector ng tuples, [(x1, y1), (x2, y2) ...] tulad na /// Bibigyan lst, at integer x, hanapin ang mga integer x sa vector, /// bawat hilera ay maaaring maglaman ng iba't ibang bilang ng mga haligi. /// na katulad ng matrix, gayunpaman, hindi tulad ng mga matrix, /// Ikaw ay ibinigay ng isang 2 dimensional data, bilang isang nakaukit vectors, /// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
","fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
    let mut result = Vec::new();

    for (row_index, row) in lst.iter().enumerate() {
        let mut found_indices: Vec<isize> = row.iter()
            .enumerate()
            .filter(|&(_, &value)| value == x)
            .map(|(col_index, _)| col_index as isize)
            .collect();

        found_indices.sort_by(|a, b| b.cmp(a)); // Sort column indices in descending order

        for col_index in found_indices {
            result.push((row_index as isize, col_index));
        }
    }

    result
}","}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}
"
HumanEval_88,tgl_Latn,rs,"/// Mga halimbawa: /// * huwag baguhin ang ibinigay na vector. /// Tandaan: /// o i-sort ito sa bumababa order kung ang kabuuan ((unang halaga ng index, huling halaga ng index) ay kahit. /// ikaw ay sort ang ibinigay na vector sa pagtaas ng pagkakasunud-sunod kung ang kabuuan ng ((unang halaga ng index, huling halaga ng index) ay kakaiba, /// Na ibinigay ng isang vector ng mga hindi-negatibong integers, ibalik ang isang cors ng ibinigay na vector pagkatapos ng pag-uuri, /// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {
","fn sort_array(array: Vec<isize>) -> Vec<isize> {
    if array.is_empty() {
        return Vec::<isize>::new();
    }

    let first = array.first().unwrap_or(&0);
    let last = array.last().unwrap_or(&0);
    let sum = first + last;

    let mut sorted_array = array.clone();
    if sum % 2 == 0 {
        sorted_array.sort_by(|a, b| b.cmp(a)); // Descending order
    } else {
        sorted_array.sort(); // Ascending order
    }

    sorted_array
}

fn main() {
    // Test cases
    println!(""{:?}"", sort_array(vec![])); // Vec::<isize>::new()
    println!(""{:?}"", sort_array(vec![5])); // vec![5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5])); // vec![0, 1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); // vec![6, 5, 4, 3, 2, 1, 0]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}
"
HumanEval_89,tgl_Latn,rs,"/// Halimbawa: /// shift down sa pamamagitan ng dalawang pinagkukunan sa dalawang lugar. /// Ang alpabeto ay dapat na i-rotate sa paraang ang mga titik /// ay nagbabalik ng isang string encrypted na may alpabeto na rotated. /// lumikha ng isang function encrypt na tumatagal ng isang string bilang isang argumento at /// >>> encrypt(String::from(""hi""))
/// String::from(""lm"")
/// >>> encrypt(String::from(""asdfghjkl""))
/// String::from(""ewhjklnop"")
/// >>> encrypt(String::from(""gf""))
/// String::from(""kj"")
/// >>> encrypt(String::from(""et""))
/// String::from(""ix"")
fn encrypt(s: String) -> String {
","fn encrypt(s: String) -> String {
    s.chars()
        .map(|c| {
            if c.is_ascii_lowercase() {
                let offset = (c as u8 - b'a' + 4) % 26;
                (b'a' + offset) as char
            } else {
                c
            }
        })
        .collect()
}","}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from(""hi"")), String::from(""lm""));
    assert_eq!(candidate(String::from(""asdfghjkl"")), String::from(""ewhjklnop""));
    assert_eq!(candidate(String::from(""gf"")), String::from(""kj""));
    assert_eq!(candidate(String::from(""et"")), String::from(""ix""));
    assert_eq!(candidate(String::from(""faewfawefaewg"")), String::from(""jeiajeaijeiak""));
    assert_eq!(candidate(String::from(""hellomyfriend"")), String::from(""lippsqcjvmirh""));
    assert_eq!(candidate(String::from(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")), String::from(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert_eq!(candidate(String::from(""a"")), String::from(""e""));
}
"
HumanEval_90,tgl_Latn,rs,"/// Magbalik Walang kung walang ganoong elemento. /// Isulat ang isang function na susunod na pinakamaliit na (() na nagbabalik ng 2nd pinakamaliit na elemento ng vector. /// Ikaw ay ibinigay ng isang vector ng integers. /// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {
","fn next_smallest(lst: Vec<isize>) -> Option<isize> {
    if lst.len() < 2 {
        return None;
    }
    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();
    if unique_elements.len() < 2 {
        return None;
    }
    unique_elements.sort();
    Some(unique_elements[1])
}

fn main() {
    println!(""{:?}"", next_smallest(vec![1, 2, 3, 4, 5])); // Some(2)
    println!(""{:?}"", next_smallest(vec![5, 1, 4, 3, 2])); // Some(2)
    println!(""{:?}"", next_smallest(vec![])); // None
    println!(""{:?}"", next_smallest(vec![1, 1])); // None
}","}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}
"
HumanEval_91,tgl_Latn,rs,"/// Halimbawa: /// Ang mga pangungusap ay pinapahihiwalay ng '.', '?' o '!'. //Ang pag-aaburido ay isang pangungusap na nagsisimula sa salitang ""Ako""./// Bibigyan ka ng isang string ng mga salita, at ang iyong gawain ay bilangin ang bilang /// >>> is_bored(String::from(""Hello world""))
/// 0
/// >>> is_bored(String::from(""The sky is blue. The sun is shining. I love this weather""))
/// 1
fn is_bored(S: String) -> isize {
","fn is_bored(S: String) -> isize {
    S.split(|c| c == '.' || c == '?' || c == '!')
        .filter(|sentence| sentence.trim_start().starts_with(""I""))
        .count() as isize
}","}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from(""Hello world"")), 0);
    assert_eq!(candidate(String::from(""Is the sky blue?"")), 0);
    assert_eq!(candidate(String::from(""I love It !"")), 1);
    assert_eq!(candidate(String::from(""bIt"")), 0);
    assert_eq!(candidate(String::from(""I feel good today. I will be productive. will kill It"")), 2);
    assert_eq!(candidate(String::from(""You and I are going for a walk"")), 0);
}
"
HumanEval_92,tgl_Latn,rs,"/// Mga Halimbawa /// Nagbabalik ng false sa anumang iba pang mga kaso. /// Bumalik totoo kung ang isa sa mga numero ay katumbas ng kabuuan ng iba pang dalawang, at ang lahat ng mga numero ay integers. /// Lumikha ng isang function na tumatagal ng 3 numero. /// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {
","fn any_int(x: f64, y: f64, z: f64) -> bool {
    // Check if all the numbers are integers
    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {
        // Convert f64 to i64 because they are integers
        let xi = x as i64;
        let yi = y as i64;
        let zi = z as i64;

        // Check if any one of the numbers is equal to the sum of the other two
        xi == yi + zi || yi == xi + zi || zi == xi + yi
    } else {
        false
    }
}

fn main() {
    // Examples
    println!(""{}"", any_int(5.0, 2.0, 7.0)); // true
    println!(""{}"", any_int(3.0, 2.0, 2.0)); // false
    println!(""{}"", any_int(3.0, -2.0, 1.0)); // true
    println!(""{}"", any_int(3.6, -2.2, 2.0)); // false
}","}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}
"
HumanEval_93,tgl_Latn,rs,"/// Mga halimbawa: /// Ipagpalagay lamang ang mga titik. /// vowel sa alpabeto ng Ingles. /// ang mensahe na may titik na lilitaw 2 lugar sa unahan nito /// paraan na ito swaps kaso ng lahat ng mga titik, replaces lahat ng mga bokal sa /// Sumulat ng isang function na tumatagal ng isang mensahe, at encodes sa tulad ng isang /// >>> encode(String::from(""test""))
/// String::from(""TGST"")
/// >>> encode(String::from(""This is a message""))
/// String::from(""tHKS KS C MGSSCGG"")
fn encode(message: String) -> String {
","fn encode(message: String) -> String {
    message.chars().map(|c| {
        match c {
            'a' => 'C',
            'e' => 'G',
            'i' => 'K',
            'o' => 'Q',
            'u' => 'W',
            'A' => 'c',
            'E' => 'g',
            'I' => 'k',
            'O' => 'q',
            'U' => 'w',
            'a'..='z' => c.to_ascii_uppercase(),
            'A'..='Z' => c.to_ascii_lowercase(),
            _ => c,
        }
    }).collect()
}","}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from(""TEST"")), String::from(""tgst""));
    assert_eq!(candidate(String::from(""Mudasir"")), String::from(""mWDCSKR""));
    assert_eq!(candidate(String::from(""YES"")), String::from(""ygs""));
    assert_eq!(candidate(String::from(""This is a message"")), String::from(""tHKS KS C MGSSCGG""));
    assert_eq!(candidate(String::from(""I DoNt KnOw WhAt tO WrItE"")), String::from(""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval_94,tgl_Latn,rs,"/// Mga halimbawa: /// Kailangan mong mahanap ang pinakamalaking pangunahing halaga at ibalik ang kabuuan ng mga digit nito. /// Ikaw ay ibinigay ng isang vector ng integers. /// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn digit_sum(n: isize) -> isize {
    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()
}

fn skjkasdkd(lst: Vec<isize>) -> isize {
    match lst.into_iter().filter(is_prime).max() {
        Some(max_prime) => digit_sum(max_prime),
        None => 0,
    }
}","}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}
"
HumanEval_95,tgl_Latn,rs,"use std::collections::HashMap;

/// Mga halimbawa: /// Ang function ay dapat bumalik false ay ang ibinigay na HashMap ay walang laman. /// kaso o lahat ng mga key ay mga string sa upper case, ibabalik false. /// Na ibinigay ng isang HashMap, bumalik totoo kung ang lahat ng mga key ay mga string sa mas mababa /// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (8, String::from(""banana"")), (String::from(""a""), String::from(""apple""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {
","use std::collections::HashMap;

fn check_dict_case(dict: HashMap<String, String>) -> bool {
    if dict.is_empty() {
        return false;
    }

    let mut lowercase = true;
    let mut uppercase = true;

    for key in dict.keys() {
        if !key.chars().all(|c| c.is_lowercase()) {
            lowercase = false;
        }
        if !key.chars().all(|c| c.is_uppercase()) {
            uppercase = false;
        }
    }

    lowercase || uppercase
}

fn main() {
    let dict1 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict1), true);

    let dict2 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict2), false);

    let dict3 = HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]);
    assert_eq!(check_dict_case(dict3), true);

    let dict4 = HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]);
    assert_eq!(check_dict_case(dict4), false);
}","}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""b""), String::from(""banana""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""5""), String::from(""banana"")), (String::from(""a""), String::from(""apple""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""fruit""), String::from(""Orange"")), (String::from(""taste""), String::from(""Sweet""))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}
"
HumanEval_96,tgl_Latn,rs,"/// halimbawa: /// integers na prime numbers at mas mababa sa n. /// Ipatupad ang isang function na tumatagal ng isang non-negatibong integer at nagbabalik ng isang vector ng unang n /// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {
","fn count_up_to(n: isize) -> Vec<isize> {
    let mut primes = Vec::new();

    for num in 2..n {
        let mut is_prime = true;

        for divisor in 2..=((num as f64).sqrt() as isize) {
            if num % divisor == 0 {
                is_prime = false;
                break;
            }
        }

        if is_prime {
            primes.push(num);
        }
    }

    primes
}

fn main() {
    println!(""{:?}"", count_up_to(5)); // vec![2, 3]
    println!(""{:?}"", count_up_to(11)); // vec![2, 3, 5, 7]
    println!(""{:?}"", count_up_to(0)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(20)); // vec![2, 3, 5, 7, 11, 13, 17, 19]
    println!(""{:?}"", count_up_to(1)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(18)); // vec![2, 3, 5, 7, 11, 13, 17]
}","}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}
"
HumanEval_97,tgl_Latn,rs,"/// Mga halimbawa: /// Ipagpalagay na ang input ay laging may bisa. /// ang produkto ng kanilang mga unidad na mga digit. /// Kumpletuhin ang function na tumatagal ng dalawang integers at nagbabalik /// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {
","fn multiply(a: isize, b: isize) -> isize {
    let unit_digit_a = (a % 10).abs();
    let unit_digit_b = (b % 10).abs();
    unit_digit_a * unit_digit_b
}","}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}
"
HumanEval_98,tgl_Latn,rs,"/// Halimbawa: /// Dahil sa isang string s, bilangin ang bilang ng mga uppercase na mga bokal sa kahit na mga index. /// >>> count_upper(String::from(""aBCdEf""))
/// 1
/// >>> count_upper(String::from(""abcdefg""))
/// 0
/// >>> count_upper(String::from(""dBBE""))
/// 0
fn count_upper(s: String) -> isize {
","fn count_upper(s: String) -> isize {
    s.chars().enumerate().filter(|(i, c)| {
        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')
    }).count() as isize
}","}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from(""aBCdEf"")), 1);
    assert_eq!(candidate(String::from(""abcdefg"")), 0);
    assert_eq!(candidate(String::from(""dBBE"")), 0);
    assert_eq!(candidate(String::from(""B"")), 0);
    assert_eq!(candidate(String::from(""U"")), 1);
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""EEEE"")), 2);
}
"
HumanEval_99,tgl_Latn,rs,"/// Mga Halimbawa /// mula sa dalawang integers, round ito malayo mula sa zero. /// at ibinabalik ang pinakamalapit na integer sa mga ito. Kung ang bilang ay equidistant /// Lumikha ng isang function na tumatagal ng isang halaga (string) na kumakatawan sa isang numero /// >>> closest_integer(String::from(""10""))
/// 10
/// >>> closest_integer(String::from(""15.3""))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
fn closest_integer(value: String) -> isize {
","fn closest_integer(value: String) -> isize {
    let num: f64 = value.parse().expect(""Invalid number format"");
    if num.fract().abs() == 0.5 {
        if num.is_sign_positive() {
            num.ceil() as isize
        } else {
            num.floor() as isize
        }
    } else {
        num.round() as isize
    }
}

// Example usage
fn main() {
    println!(""{}"", closest_integer(String::from(""10"")));   // Output: 10
    println!(""{}"", closest_integer(String::from(""15.3""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""14.5""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""-14.5""))); // Output: -15
}","}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from(""10"")), 10);
    assert_eq!(candidate(String::from(""14.5"")), 15);
    assert_eq!(candidate(String::from(""-15.5"")), -16);
    assert_eq!(candidate(String::from(""15.3"")), 15);
    assert_eq!(candidate(String::from(""0"")), 0);
}
"
HumanEval_100,tgl_Latn,rs,"/// Mga halimbawa: /// i ay kumakatawan sa bilang ng mga bato sa antas (i+1). /// Ibalik ang bilang ng mga bato sa bawat antas sa isang vector, kung saan elemento sa index /// - ang susunod na pares na bilang kung n ay pares. /// - ang susunod na ganung numero kung n ay ganung numero. /// Ang bilang ng mga bato sa susunod na antas ay: /// Ang unang antas ay may n bato. /// Dahil sa isang positibong integer na n, kailangan mong gumawa ng isang bunton ng n antas ng mga bato. /// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {
","fn make_a_pile(n: isize) -> Vec<isize> {
    let mut pile = Vec::new();
    let mut current = n;
    
    for _ in 0..n {
        pile.push(current);
        current = if n % 2 == 1 {
            current + 2
        } else {
            current + 2
        };
    }
    
    pile
}

fn main() {
    let level = make_a_pile(3);
    println!(""{:?}"", level);
}","}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}
"
HumanEval_101,tgl_Latn,rs,"/// Halimbawa: /// upang hatiin ang string sa mga salita at ibalik ang isang vector ng mga salita. /// Bibigyan ka ng isang string ng mga salita na pinaghihiwalay ng mga comma o espasyo./// >>> words_string(String::from(""Hi, my name is John""))
/// vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]
/// >>> words_string(String::from(""One, two, three, four, five, six""))
/// vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]
fn words_string(s: String) -> Vec<String> {
","fn words_string(s: String) -> Vec<String> {
    s.split(|c: char| c.is_whitespace() || c == ',')
        .filter(|word| !word.is_empty())
        .map(String::from)
        .collect()
}","}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from(""Hi, my name is John"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]);
    assert_eq!(candidate(String::from(""One, two, three, four, five, six"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from(""Hi, my name"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name"")]);
    assert_eq!(candidate(String::from(""One,, two, three, four, five, six,"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""ahmed     , gamal"")), vec![String::from(""ahmed""), String::from(""gamal"")]);
}
"
HumanEval_102,tgl_Latn,rs,"/// Halimbawa: /// walang tulad ng bilang, pagkatapos ang function ay dapat bumalik -1. /// pinakamalaking kahit integer bilang na nasa saklaw [x, y] kasama. Kung /// function na ito ay tumatagal ng dalawang positibong numero x at y at nagbabalik ang /// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {
","fn choose_num(x: isize, y: isize) -> isize {
    let (start, end) = if x < y { (x, y) } else { (y, x) };
    for n in (start..=end).rev() {
        if n % 2 == 0 {
            return n;
        }
    }
    -1
}

fn main() {
    println!(""{}"", choose_num(12, 15)); // 14
    println!(""{}"", choose_num(13, 12)); // -1
}","}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}
"
HumanEval_104,tgl_Latn,rs,"/// Halimbawa: /// Tandaan: Ang ibinalik na vector ay dapat na i-sort sa pagtaas ng pagkakasunud-sunod. /// mga elemento na walang kahit na digit. /// Dahil sa isang vector ng positibong integers x. ibalik ang isang uri vector ng lahat ng /// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {
","fn unique_digits(x: Vec<isize>) -> Vec<isize> {
    let mut result: Vec<isize> = x.into_iter()
        .filter(|&num| {
            num.to_string().chars().all(|c| {
                match c {
                    '0' | '2' | '4' | '6' | '8' => false,
                    _ => true,
                }
            })
        })
        .collect();
    result.sort();
    result
}","}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}
"
HumanEval_105,tgl_Latn,rs,"/// Halimbawa: /// ""Isa"", ""Dalawa"", ""Tlo"", ""Apat"", ""Lima"", ""Inam"", ""Pito"", ""Walo"", ""Sampung"". /// ibalik ang resulta ng vector, at pagkatapos ay palitan ang bawat digit sa pamamagitan ng mga katumbas na pangalan mula sa /// Na ibinigay ng isang vector ng mga integers, uriin ang mga integers na nasa pagitan ng 1 at 9 kasama, /// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from(""One"")]
fn by_length(arr: Vec<isize>) -> Vec<String> {
","fn by_length(arr: Vec<isize>) -> Vec<String> {
    let digit_names = [
        ""One"", ""Two"", ""Three"", ""Four"", ""Five"", 
        ""Six"", ""Seven"", ""Eight"", ""Nine"",
    ];

    let mut filtered: Vec<isize> = arr.into_iter()
        .filter(|&x| x >= 1 && x <= 9)
        .collect();

    filtered.sort();
    filtered.reverse();

    filtered.into_iter()
        .map(|x| String::from(digit_names[(x - 1) as usize]))
        .collect()
}","}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(""One"")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(""Three""), String::from(""Two""), String::from(""One"")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(""Nine""), String::from(""Eight""), String::from(""Four"")]);
}
"
HumanEval_106,tgl_Latn,rs,"/// Halimbawa: /// ang factorial ng i ay ang pagkalipat ng mga numero mula 1 hanggang i (1 * 2 * ... * i). /// i nagsisimula mula sa 1. /// o ang kabuuan ng mga numero mula 1 hanggang i kung hindi man. /// at nagbabalik ng isang vector ng laki n, tulad na ang halaga ng elemento sa index i ay ang factorial ng i kung i ay kahit na /// Ipatupad ang function f na tumatagal ng n bilang isang parameter, /// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {
","fn f(n: isize) -> Vec<isize> {
    fn factorial(x: isize) -> isize {
        (1..=x).product()
    }

    fn sum_up_to(x: isize) -> isize {
        (1..=x).sum()
    }

    (1..=n)
        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })
        .collect()
}","}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}
"
HumanEval_107,tgl_Latn,rs,"/// Halimbawa 1: /// integer palindromes na nahuhulog sa loob ng saklaw ng ((1, n), kasama. /// Na ibinigay ng isang positibong integer n, bumalik ng isang tuple na may bilang ng kahit at kakaiba /// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {
","fn is_palindrome(x: isize) -> bool {
    let s = x.to_string();
    s == s.chars().rev().collect::<String>()
}

fn even_odd_palindrome(n: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    
    for i in 1..=n {
        if is_palindrome(i) {
            if i % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}
"
HumanEval_108,tgl_Latn,rs,"/// halimbawa -123 ay may mga sinulat na mga digit -1, 2, at 3. /// Kung ang isang bilang ay negatibo, pagkatapos ay ang unang naka-sign na digit nito ay magiging negatibo: /// ang bilang ng mga elemento na may isang kabuuan ng mga digit > 0. /// Isulat ang isang function count_nums na tumatagal ng isang vector ng mga integer at nagbabalik /// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {
","fn count_nums(arr: Vec<isize>) -> isize {
    arr.into_iter()
        .filter(|&num| {
            let mut n = num;
            let mut sum = 0;
            let mut is_first_digit = true;

            while n != 0 {
                let digit = if is_first_digit {
                    is_first_digit = false;
                    n % 10
                } else {
                    (n % 10).abs()
                };
                sum += digit;
                n /= 10;
            }
            sum > 0
        })
        .count() as isize
}","}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}
"
HumanEval_109,tgl_Latn,rs,"/// Halimbawa: /// Tandaan: Ang ibinigay na vector ay garantisadong magkaroon ng natatanging mga elemento. /// Kung ang ibinigay na vector ay walang laman pagkatapos ay bumalik totoo. /// pagkatapos ay bumalik totoo ibabalik false. /// Kung ito ay posible upang makuha ang mga naka-sort vector sa pamamagitan ng pagganap ng itaas na operasyon /// ang panimulang posisyon sa vector i.e. 0th index. /// posisyon sa tamang direksyon. Ang huling elemento ng vector ay ililipat sa /// Isang kanan shift operasyon ay nangangahulugan ng paglilipat ng lahat ng mga elemento ng vector sa pamamagitan ng isa /// Pinapayagan kang magsagawa ng kanan shift operasyon anumang bilang ng mga beses. /// ang sumusunod na operasyon sa ibinigay na vector: /// ito ay posible upang makakuha ng isang vector na nakaayos sa hindi bumababa order sa pamamagitan ng pagganap /// numero sa vector ay random na iniutos./// Mayroon kaming isang vector 'arr' ng N integers arr[1], arr[2], ..., arr[N].Ang /// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {
","fn move_one_ball(arr: Vec<isize>) -> bool {
    if arr.is_empty() {
        return true; // An empty array is already considered sorted.
    }
    
    let mut break_point = 0;
    let mut break_found = false;
    let len = arr.len();

    for i in 0..len {
        if arr[i] > arr[(i + 1) % len] {
            if break_found {
                return false;  // Found more than one break point, not possible.
            }
            break_point = i + 1;
            break_found = true;
        }
    }
    
    // After finding a single break point, simulate the right shift by 'break_point'
    for i in 0..len {
        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {
            return false; // Not sorted in non-decreasing order with this shift.
        }
    }
    
    true
}

// Example usages:

// This will return true, as we can shift twice to sort it.
assert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);

// This will return false, as we can't sort this by any number of shifts.
assert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}
"
HumanEval_110,tgl_Latn,rs,"/// Halimbawa: /// Kung hindi, ibalik ang ""Hindi"". /// lahat ng mga elemento ng lst1 upang maging kahit, bumalik ""YES"". /// Kung ito ay posible upang palitan ang mga elemento sa pagitan ng lst1 at lst2 upang gumawa ng /// Walang limitasyon sa bilang ng mga elemento na pinalitan sa pagitan ng lst1 at lst2. /// sa pagitan nila upang gawin lst1 isang vector ng kahit na numero lamang. /// at tinatayang kung posible na magsagawa ng isang palitan ng mga elemento /// Sa problemang ito, ikaw ay magpatupad ng isang function na tumatagal ng dalawang vectors ng mga numero, /// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from(""YES"")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from(""NO"")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
","fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
    let mut even_in_lst2 = false;
    for &num in &lst2 {
        if num % 2 == 0 {
            even_in_lst2 = true;
            break;
        }
    }

    if even_in_lst2 {
        for &num in &lst1 {
            if num % 2 != 0 {
                return String::from(""YES"");
            }
        }
        return String::from(""YES"");
    }

    String::from(""NO"")
}

fn main() {
    // Example cases
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); // ""YES""
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); // ""NO""
}","}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(""NO""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(""NO""));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(""NO""));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(""YES""));
}
"
HumanEval_111,tgl_Latn,rs,"use std::collections::HashMap;

/// Halimbawa: /// Kung ang ilang mga titik ay may parehong paglitaw, ibalik ang lahat ng mga ito. /// ng titik na may pinakamaraming pag-uulit at naglalaman ng kaukulang bilang. /// Dahil sa isang string na kumakatawan sa isang puwang na hiwalay ang mga maliit na titik, ibalik ang isang HashMap /// >>> histogram(String::from(""a b c""))
/// HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])
/// >>> histogram(String::from(""a b b a""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""a b c a b""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""b b b b a""))
/// HashMap::from([(String::from(""b""), 4)])
/// >>> histogram(String::from(""""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {
","use std::collections::HashMap;

fn histogram(test: String) -> HashMap<String, isize> {
    let mut counts: HashMap<String, isize> = HashMap::new();
    let mut max_count = 0;

    for letter in test.split_whitespace() {
        let count = counts.entry(letter.to_string()).or_insert(0);
        *count += 1;
        if *count > max_count {
            max_count = *count;
        }
    }

    counts.retain(|_, &mut val| val == max_count);
    counts
}

fn main() {
    let result = histogram(String::from(""a b c""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])

    let result = histogram(String::from(""a b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""a b c a b""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""b b b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""b""), 4)])

    let result = histogram(String::from(""""));
    println!(""{:?}"", result); // HashMap::from([])
}","}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from(""a b b a"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c a b"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c d g"")), HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1), (String::from(""d""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""b b b b a"")), HashMap::from([(String::from(""b""), 4)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from("""")), HashMap::from([]));
    assert_eq!(candidate(String::from(""a"")), HashMap::from([(String::from(""a""), 1)]));
}
"
HumanEval_112,tgl_Latn,rs,"/// Halimbawa /// Dapat mong ibalik ang isang tuple na naglalaman ng mga resulta string at totoo / hindi totoo para sa check. /// Ang isang string ay tinatawag na palindrome kung ito ay basahin ang parehong pabalik-balik at pauna-una. /// pagkatapos ay suriin kung ang resulta string ay palindrome. /// Kami ay ibinigay ng dalawang mga string s at c, mayroon kang upang tanggalin ang lahat ng mga character sa s na ay katumbas ng anumang character sa c /// Tungkulin /// >>> reverse_delete(String::from(""abcde""), String::from(""ae""))
/// (String::from(""bcd""), false)
/// >>> reverse_delete(String::from(""abcdef""), String::from(""b""))
/// (String::from(""acdef""), false)
/// >>> reverse_delete(String::from(""abcdedcba""), String::from(""ab""))
/// (String::from(""cdedc""), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {
","fn reverse_delete(s: String, c: String) -> (String, bool) {
    // Create a set of characters to delete for quick lookup
    let delete_chars: std::collections::HashSet<char> = c.chars().collect();
    
    // Filter the string, keeping only characters not in the delete set
    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();
    
    // Check if the filtered string is a palindrome
    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();
    
    // Return the filtered string and whether it's a palindrome
    (filtered, is_palindrome)
}","}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from(""abcde""), String::from(""ae"")), (String::from(""bcd""), false));
    assert_eq!(candidate(String::from(""abcdef""), String::from(""b"")), (String::from(""acdef""), false));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""ab"")), (String::from(""cdedc""), true));
    assert_eq!(candidate(String::from(""dwik""), String::from(""w"")), (String::from(""dik""), false));
    assert_eq!(candidate(String::from(""a""), String::from(""a"")), (String::from(""""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from("""")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""v"")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""vabba""), String::from(""v"")), (String::from(""abba""), true));
    assert_eq!(candidate(String::from(""mamma""), String::from(""mia"")), (String::from(""""), true));
}
"
HumanEval_113,tgl_Latn,rs,"/// ng mga kakaibang digit sa i'th string ng input. /// string i ng input. "" kung saan ang lahat ng mga i ay dapat na pinalitan ng numero /// Bawat elemento i ng output ay dapat na ""ang bilang ng mga kakaibang mga elemento sa /// Na ibinigay ang isang vector ng mga string, kung saan ang bawat string ay binubuo ng mga digit lamang, ibalik ang isang vector. /// >>> odd_count(vec![String::from(""1234567"")])
/// vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]
/// >>> odd_count(vec![String::from(""3""), String::from(""11111111"")])
/// vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]
fn odd_count(lst: Vec<String>) -> Vec<String> {
","fn odd_count(lst: Vec<String>) -> Vec<String> {
    lst.iter()
        .map(|s| {
            let odd_count = s.chars().filter(|&c| {
                match c {
                    '1' | '3' | '5' | '7' | '9' => true,
                    _ => false,
                }
            }).count();
            format!(""the number of odd elements {0}n the str{0}ng {0} of the {0}nput."", odd_count)
        })
        .collect()
}

// Example usage:
// fn main() {
//     let result = odd_count(vec![String::from(""1234567"")]);
//     println!(""{:?}"", result);
// 
//     let result = odd_count(vec![String::from(""3""), String::from(""11111111"")]);
//     println!(""{:?}"", result);
// }","}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from(""1234567"")]), vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]);
    assert_eq!(candidate(vec![String::from(""3""), String::from(""11111111"")]), vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]);
    assert_eq!(candidate(vec![String::from(""271""), String::from(""137""), String::from(""314"")]), vec![String::from(""the number of odd elements 2n the str2ng 2 of the 2nput.""), String::from(""the number of odd elements 3n the str3ng 3 of the 3nput.""), String::from(""the number of odd elements 2n the str2ng 2 of the 2nput."")]);
}
"
HumanEval_114,tgl_Latn,rs,"/// Halimbawa /// ng mga numero. /// Dahil sa isang vector ng integers nums, hanapin ang pinakamaliit na kabuuan ng anumang hindi-walang laman sub-vector /// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {
","fn minSubArraySum(nums: Vec<isize>) -> isize {
    let mut min_sum = nums[0];
    let mut current_sum = nums[0];

    for &num in nums.iter().skip(1) {
        current_sum = current_sum.min(current_sum + num);
        min_sum = min_sum.min(current_sum);
    }

    min_sum
}","}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}
"
HumanEval_115,tgl_Latn,rs,"/// Halimbawa 1: /// Output ang bilang ng mga beses na kailangan mo upang i-download ang mga balde. /// Ang iyong gawain ay gamitin ang mga balde upang maubos ang mga balon. /// at lahat ng mga balde ay may parehong kapasidad. /// Bawat balon ay may katumbas na balde na maaaring gamitin upang kunin ang tubig mula rito, /// at ang bawat 1 sa isang hilera ay kumakatawan sa isang solong yunit ng tubig. //Ang bawat hilera ay kumakatawan sa isang buhangin, at ang bawat hilera ay kumakatawan sa isang buhangin./// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
","fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
    let mut total_water_units = 0;

    for row in grid.iter() {
        for &unit in row.iter() {
            total_water_units += unit;
        }
    }

    // Calculate how many times we need to lower the bucket to extract all water units
    (total_water_units + capacity - 1) / capacity
}

fn main() {
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); // 6
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); // 5
    println!(""{}"", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); // 0
}","}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}
"
HumanEval_116,tgl_Latn,rs,"/// Dapat itong ipatupad tulad nito: /// Para sa katulad na bilang ng mga isa, mag-uri batay sa halaga ng decimal. /// bilang ng mga isa sa kanilang binary representasyon sa pagtaas na pagkakasunud-sunod. /// Sa kata na ito, kailangan mong i-sort ang isang vector ng mga hindi-negatibong integers ayon sa /// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {
","fn sort_array(arr: Vec<isize>) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_by(|&a, &b| {
        let ones_a = a.count_ones();
        let ones_b = b.count_ones();
        if ones_a == ones_b {
            a.cmp(&b)
        } else {
            ones_a.cmp(&ones_b)
        }
    });
    arr
}

fn main() {
    println!(""{:?}"", sort_array(vec![1, 5, 2, 3, 4])); // Output: [1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![-2, -3, -4, -5, -6])); // Output: [-6, -5, -4, -3, -2]
    println!(""{:?}"", sort_array(vec![1, 0, 2, 3, 4])); // Output: [0, 1, 2, 3, 4]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}
"
HumanEval_117,tgl_Latn,rs,"/// Mga halimbawa: /// Tandaan: maaari mong isipin ang input string ay naglalaman lamang ng mga titik at puwang. /// Kung ang string s ay walang laman pagkatapos ang function ay dapat bumalik ng isang walang laman na vector. /// n mga konsonante, sa pagkakasunud-sunod na lumilitaw ang mga salitang ito sa string s. /// isang function na nagbabalik ng isang vector ng lahat ng mga salita mula sa string s na naglalaman ng eksaktong /// Na ibinigay ang isang string s at isang natural na numero n, ikaw ay tasked na ipatupad /// >>> select_words(String::from(""Mary had a little lamb""), 4)
/// vec![String::from(""little"")]
/// >>> select_words(String::from(""Mary had a little lamb""), 3)
/// vec![String::from(""Mary""), String::from(""lamb"")]
/// >>> select_words(String::from(""simple white space""), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from(""Hello world""), 4)
/// vec![String::from(""world"")]
/// >>> select_words(String::from(""Uncle sam""), 3)
/// vec![String::from(""Uncle"")]
fn select_words(s: String, n: isize) -> Vec<String> {
","fn select_words(s: String, n: isize) -> Vec<String> {
    let consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";
    let mut result = Vec::new();

    for word in s.split_whitespace() {
        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();
        if consonant_count == n as usize {
            result.push(word.to_string());
        }
    }

    result
}","}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 4), vec![String::from(""little"")]);
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 3), vec![String::from(""Mary""), String::from(""lamb"")]);
    assert_eq!(candidate(String::from(""simple white space""), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from(""Hello world""), 4), vec![String::from(""world"")]);
    assert_eq!(candidate(String::from(""Uncle sam""), 3), vec![String::from(""Uncle"")]);
    assert_eq!(candidate(String::from(""""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from(""a b c d e f""), 1), vec![String::from(""b""), String::from(""c""), String::from(""d""), String::from(""f"")]);
}
"
HumanEval_118,tgl_Latn,rs,"/// Halimbawa: /// Maaari mong isipin na ang ibinigay na string ay naglalaman ng Ingles na titik lamang. /// mahanap ang anumang bokal na nakatagpo sa kondisyon sa itaas. /// Vowels sa simula at pagtatapos ay hindi bilangin. Bumalik walang laman string kung hindi mo /// dalawang konsonante mula sa kanang bahagi ng salita (mahalaga ang case). //Ang iyong gawain ay hanapin ang pinakamalapit na bokal na nasa pagitan ng /// >>> get_closest_vowel(String::from(""yogurt""))
/// String::from(""u"")
/// >>> get_closest_vowel(String::from(""FULL""))
/// String::from(""U"")
/// >>> get_closest_vowel(String::from(""quick""))
/// String::from("""")
/// >>> get_closest_vowel(String::from(""ab""))
/// String::from("""")
fn get_closest_vowel(word: String) -> String {
","fn get_closest_vowel(word: String) -> String {
    let vowels = ""aeiouAEIOU"";
    let chars: Vec<char> = word.chars().collect();
    if chars.len() < 3 {
        return String::from("""");
    }

    for i in (1..chars.len() - 1).rev() {
        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {
            return chars[i].to_string();
        }
    }
    String::from("""")
}","}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from(""yogurt"")), String::from(""u""));
    assert_eq!(candidate(String::from(""full"")), String::from(""u""));
    assert_eq!(candidate(String::from(""easy"")), String::from(""""));
    assert_eq!(candidate(String::from(""eAsy"")), String::from(""""));
    assert_eq!(candidate(String::from(""ali"")), String::from(""""));
    assert_eq!(candidate(String::from(""bad"")), String::from(""a""));
    assert_eq!(candidate(String::from(""most"")), String::from(""o""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""""));
    assert_eq!(candidate(String::from(""ba"")), String::from(""""));
    assert_eq!(candidate(String::from(""quick"")), String::from(""""));
    assert_eq!(candidate(String::from(""anime"")), String::from(""i""));
    assert_eq!(candidate(String::from(""Asia"")), String::from(""""));
    assert_eq!(candidate(String::from(""Above"")), String::from(""o""));
}
"
HumanEval_119,tgl_Latn,rs,"/// Mga halimbawa: /// Magbalik 'Oo' kung may isang paraan upang gumawa ng isang mahusay na string, at bumalik 'Hindi' kung hindi. /// '()) ' ay hindi. //Halimbawa: ang string '(()))) ay mabuti, habang ang string /// Isang string S ay itinuturing na maging mabuti kung at lamang kung ang lahat ng mga parentehes sa S /// ilang mga order, na ang nagreresultang string ay magiging mabuti. /// Ang iyong trabaho ay suriin kung posible na i-concatenate ang dalawang string sa /// mga parentehesang "" (("" o mga malapit na parentehesang "") "" lamang. /// Ikaw ay ibinigay ng isang vector ng dalawang string, parehong mga string ay binubuo ng bukas /// >>> match_parens(vec![String::from(""()(""), String::from("")"")])
/// String::from(""Yes"")
/// >>> match_parens(vec![String::from("")""), String::from("")"")])
/// String::from(""No"")
fn match_parens(lst: Vec<String>) -> String {
","fn match_parens(lst: Vec<String>) -> String {
    fn is_balanced(s: &str) -> bool {
        let mut balance = 0;
        for ch in s.chars() {
            if ch == '(' {
                balance += 1;
            } else {
                balance -= 1;
            }
            if balance < 0 {
                return false;
            }
        }
        balance == 0
    }

    if lst.len() != 2 {
        return ""No"".to_string();
    }

    let s1 = &lst[0];
    let s2 = &lst[1];

    let combined1 = format!(""{}{}"", s1, s2);
    let combined2 = format!(""{}{}"", s2, s1);

    if is_balanced(&combined1) || is_balanced(&combined2) {
        ""Yes"".to_string()
    } else {
        ""No"".to_string()
    }
}","}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from(""()(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from("")"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(())""), String::from(""())())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")())""), String::from(""(()()("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""(())))""), String::from(""(()())(("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""()""), String::from(""())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(""), String::from(""()))()"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""((((""), String::from(""((())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(()""), String::from(""(()("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(""), String::from("")("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from(""("")]), String::from(""Yes""));
}
"
HumanEval_120,tgl_Latn,rs,"/// Halimbawa 1: /// ng haba k na may pinakamataas na k na numero sa arr. /// Dahil sa isang vector arr ng mga integer at isang positibong integer k, ibalik ang isang uri vector /// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
","fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_unstable_by(|a, b| b.cmp(a));
    let k = k as usize;
    let mut result: Vec<isize> = arr.into_iter().take(k).collect();
    result.sort_unstable();
    result
}

fn main() {
    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
}","}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}
"
HumanEval_121,tgl_Latn,rs,"/// Mga Halimbawa /// Dahil sa isang hindi-walang laman na vector ng mga integers, ibalik ang kabuuan ng lahat ng mga kakaibang elemento na nasa kahit na mga posisyon. /// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {
","fn solution(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)
        .map(|(_, &x)| x)
        .sum()
}","}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}
"
HumanEval_122,tgl_Latn,rs,"/// Halimbawa: /// ang kabuuan ng mga elemento na may hindi hihigit sa dalawang digit mula sa unang k mga elemento ng arr. /// Dahil sa isang hindi-walang laman na vector ng mga integer arr at isang integer k, ibalik /// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {
","fn add_elements(arr: Vec<isize>, k: isize) -> isize {
    arr.iter()
        .take(k as usize)
        .filter(|&&x| x > -100 && x < 100)
        .sum()
}

fn main() {
    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);
    println!(""{}"", result);  // Output: 24
}","}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}
"
HumanEval_123,tgl_Latn,rs,"/// get_odd_collatz(5) ay nagbabalik [1, 5] # Ang pagkakasunud-sunod ng collatz para sa 5 ay [5, 16, 8, 4, 2, 1], kaya ang mga ganung numero ay 1, at 5 lamang. /// Halimbawa: /// 2. ibinalik na vector na inorder sa pagtaas ng order. /// 1. Collatz(1) ay [1]. /// Tandaan: /// term plus 1. Ang koneksiyon ay anuman ang halaga ng n, ang pagkakasunud-sunod ay laging aabot sa 1. /// ang nakaraang termino. Kung ang nakaraang termino ay kakaiba, ang susunod na termino ay 3 beses ang nakaraang /// nakaraang termino tulad ng sumusunod: kung ang nakaraang termino ay pares, ang susunod na termino ay kalahati ng /// tulad ng sumusunod: magsimula sa anumang positibong integer n. Pagkatapos ang bawat termino ay nakuha mula sa /// Ang Collatz conjecture ay isang conjecture sa matematika na may kinalaman sa isang pagkakasunud-sunod na tinukoy /// Dahil sa isang positibong integer n, ibalik ang isang uri vector na may mga ganon numero sa collatz pagkakasunud-sunod. /// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {
","fn get_odd_collatz(n: isize) -> Vec<isize> {
    let mut sequence = Vec::new();
    let mut current = n;

    while current != 1 {
        if current % 2 != 0 {
            sequence.push(current);
        }

        if current % 2 == 0 {
            current /= 2;
        } else {
            current = 3 * current + 1;
        }
    }
    
    // Add the final odd number 1 if n is 1
    sequence.push(1);

    sequence.sort();
    sequence
}

fn main() {
    let result = get_odd_collatz(5);
    println!(""{:?}"", result); // Outputs: [1, 5]
}","}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}
"
HumanEval_124,tgl_Latn,rs,"/// 4. Ang petsa ay dapat sa format: mm-dd-yyyy /// 3. Ang buwan ay hindi dapat mas mababa sa 1 o mas mataas sa 12. //Ang bilang ng mga araw ay hindi mas mababa sa 1 o mas mataas kaysa sa 31 araw para sa mga buwan 1,3,5,7,8,10,12. At ang bilang ng mga araw ay hindi mas mababa sa 1 o mas mataas kaysa sa 30 araw para sa mga buwan 4,6,9,11. At, ang bilang ng mga araw ay hindi mas mababa sa 1 o mas mataas kaysa sa 29 para sa buwan 2. /// 1. Ang petsa string ay hindi walang laman. /// Ang petsa ay may bisa kung ang lahat ng sumusunod na mga patakaran ay natutupad: /// ay nagbabalik true kung ang petsa ay may bisa kung hindi man false. /// Kailangan mong magsulat ng isang function na validates ng isang ibinigay na string ng petsa at /// >>> valid_date(String::from(""03-11-2000""))
/// true
/// >>> valid_date(String::from(""15-01-2012""))
/// false
/// >>> valid_date(String::from(""04-0-2040""))
/// false
/// >>> valid_date(String::from(""06-04-2020""))
/// true
/// >>> valid_date(String::from(""06/04/2020""))
/// false
fn valid_date(date: String) -> bool {
","fn valid_date(date: String) -> bool {
    if date.is_empty() {
        return false;
    }

    let parts: Vec<&str> = date.split('-').collect();
    if parts.len() != 3 {
        return false;
    }

    let maybe_month = parts[0].parse::<u32>();
    let maybe_day = parts[1].parse::<u32>();
    let maybe_year = parts[2].parse::<u32>();

    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {
        return false;
    }

    let month = maybe_month.unwrap();
    let day = maybe_day.unwrap();

    if month < 1 || month > 12 {
        return false;
    }

    match month {
        1 | 3 | 5 | 7 | 8 | 10 | 12 => {
            if day < 1 || day > 31 {
                return false;
            }
        }
        4 | 6 | 9 | 11 => {
            if day < 1 || day > 30 {
                return false;
            }
        }
        2 => {
            if day < 1 || day > 29 {
                return false;
            }
        }
        _ => return false, // This case should never be reached
    }

    true
}","}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from(""03-11-2000"")), true);
    assert_eq!(candidate(String::from(""15-01-2012"")), false);
    assert_eq!(candidate(String::from(""04-0-2040"")), false);
    assert_eq!(candidate(String::from(""06-04-2020"")), true);
    assert_eq!(candidate(String::from(""01-01-2007"")), true);
    assert_eq!(candidate(String::from(""03-32-2011"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""04-31-3000"")), false);
    assert_eq!(candidate(String::from(""06-06-2005"")), true);
    assert_eq!(candidate(String::from(""21-31-2000"")), false);
    assert_eq!(candidate(String::from(""04-12-2003"")), true);
    assert_eq!(candidate(String::from(""04122003"")), false);
    assert_eq!(candidate(String::from(""20030412"")), false);
    assert_eq!(candidate(String::from(""2003-04"")), false);
    assert_eq!(candidate(String::from(""2003-04-12"")), false);
    assert_eq!(candidate(String::from(""04-2003"")), false);
}
"
HumanEval_126,tgl_Latn,rs,"/// Mga Halimbawa /// bilang, bumalik false. Ipagpalagay walang negatibong mga numero at lamang integers. /// sa pagtaas na pagkakasunud-sunod. Kung vector ay may higit sa 1 duplicate ng parehong /// Na ibinigay ng isang vector ng mga numero, bumalik kung sila ay naka-sort o hindi /// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {
","fn is_sorted(lst: Vec<isize>) -> bool {
    if lst.is_empty() || lst.len() == 1 {
        return true;
    }
    
    let mut previous = lst[0];
    let mut repeat_count = 0;

    for &current in &lst[1..] {
        if current < previous {
            return false;
        }
        if current == previous {
            repeat_count += 1;
            if repeat_count >= 2 {
                return false;
            }
        } else {
            repeat_count = 0;
        }
        previous = current;
    }

    true
}","}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}
"
HumanEval_127,tgl_Latn,rs,"/// [input/output] mga sample: /// Kung ang dalawang pagitan ay hindi mag-intersect, ibalik ang ""NO"". /// kung hindi, ibalik ang ""NO"". /// Kung ang haba ng intersection ay isang pangunahing numero, ibalik ""OO"", /// na ang haba nito ay 1, na hindi isang pangunahing numero. /// Halimbawa, ang intersection ng mga pagitan (1, 3), (2, 4) ay (2, 3) /// interbels ay isang pangunahing numero. /// Ang iyong gawain ay upang matukoy kung ang haba ng intersection ng dalawang ito /// Para sa bawat ibinigay na interbyu, ito ay ipinapalagay na ang simula ay mas mababa o katumbas ng katapusan nito. /// kasama ang parehong simula at wakas. /// Ang ibinigay na mga agwat ay sarado na nangangahulugang ang agwat (simula, katapusan) /// kung saan ang bawat pagitan ay isang pares ng mga integer. Halimbawa, pagitan = (simula, katapusan) = (1, 2). /// Ikaw ay bibigyan ng dalawang pagitan, /// >>> intersection((1, 2), (2, 3))
/// String::from(""NO"")
/// >>> intersection((-1, 1), (0, 4))
/// String::from(""NO"")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from(""YES"")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
    let (start1, end1) = interval1;
    let (start2, end2) = interval2;
    let start_intersection = std::cmp::max(start1, start2);
    let end_intersection = std::cmp::min(end1, end2);

    if start_intersection <= end_intersection {
        let length = (end_intersection - start_intersection + 1) as usize;
        if is_prime(length) {
            return String::from(""YES"");
        }
    }
    String::from(""NO"")
}

// Example usage
fn main() {
    println!(""{}"", intersection((1, 2), (2, 3))); // ""NO""
    println!(""{}"", intersection((-1, 1), (0, 4))); // ""NO""
    println!(""{}"", intersection((-3, -1), (-5, 5))); // ""YES""
}","}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from(""NO""));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from(""NO""));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(""YES""));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(""YES""));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (3, 5)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (1, 2)), String::from(""NO""));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(""NO""));
}
"
HumanEval_128,tgl_Latn,rs,"/// Halimbawa: /// Tandaan: bumalik Walang para sa walang laman arr. /// ng bawat numero sa vector, na kinakatawan ng 1, -1 o 0. /// kabuuan ng mga magnitude ng mga integer na pinarami ng produkto ng lahat ng mga tanda /// Ikaw ay ibinigay ng isang vector arr ng integers at kailangan mong bumalik /// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {
","fn prod_signs(arr: Vec<isize>) -> Option<isize> {
    if arr.is_empty() {
        return None;
    }

    let mut sum_of_magnitudes = 0;
    let mut product_of_signs = 1;

    for &num in &arr {
        sum_of_magnitudes += num.abs();
        if num == 0 {
            product_of_signs = 0;
            break;
        } else if num > 0 {
            product_of_signs *= 1;
        } else {
            product_of_signs *= -1;
        }
    }

    Some(sum_of_magnitudes * product_of_signs)
}","}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}
"
HumanEval_129,tgl_Latn,rs,"/// Mga halimbawa: /// Magbalik ng isang inorder vector ng mga halaga sa mga cell na ang pinakamaliit na landas pumunta sa pamamagitan ng. /// Ito ay garantisadong na ang sagot ay natatangi. /// lst_A[j] = lst_B[j]. /// tulad na lst_A[i] < lst_B[i] at para sa anumang j (1 <= j < i) mayroon tayo /// kaysa lst_B, sa ibang salita, may umiiral na isang integer index i (1 <= i <= k) /// sa pamamagitan ng (hayaan naming tawagin ang mga ito lst_A at lst_B), lst_A ay lexicographically mas mababa /// pagkatapos ng paggawa ng mga iniutos vectors ng mga halaga sa mga cell na A at B pumunta /// Isang landas A (ng haba k) ay itinuturing na mas maliit kaysa sa isang landas B (ng haba k) kung /// Hindi ka maaaring lumayo sa grid. /// hindi kinakailangang magkakaiba). /// Mangyaring tandaan na ang isang landas ng haba k ay nangangahulugang bumisita sa eksaktong k na mga cell (hindi /// cell. /// sa ibang salita, maaari kang pumunta sa mga cell na magbahagi ng isang gilid sa iyo kasalukuyang /// mula sa anumang cell, at sa bawat hakbang maaari kang lumipat sa alinman sa mga kapitbahay na cell, /// Kailangan mong mahanap ang pinakamaliit na landas ng haba k sa grid. Maaari kang magsimula /// inclusive ay lilitaw nang isang beses sa mga cell ng grid. /// bawat cell ng grid ay naglalaman ng isang halaga. bawat integer sa saklaw [1, N * N] /// Dahil sa isang grid na may N na mga hilera at N na mga haligi (N >= 2) at isang positibong integer k, /// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
","fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
    let n = grid.len();
    let mut best_path = vec![];
    let mut best_values = vec![isize::MAX; k as usize];
    
    fn dfs(
        grid: &Vec<Vec<isize>>, 
        row: usize, 
        col: usize, 
        path: &mut Vec<(usize, usize)>, 
        values: &mut Vec<isize>, 
        k: isize, 
        best_values: &mut Vec<isize>
    ) {
        if path.len() == k as usize {
            if values < best_values {
                best_values.clone_from(values);
            }
            return;
        }
        
        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];
        for &(dr, dc) in directions.iter() {
            let new_row = row as isize + dr;
            let new_col = col as isize + dc;
            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {
                path.push((new_row as usize, new_col as usize));
                values.push(grid[new_row as usize][new_col as usize]);
                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);
                values.pop();
                path.pop();
            }
        }
    }

    for r in 0..n {
        for c in 0..n {
            let mut path = vec![(r, c)];
            let mut values = vec![grid[r][c]];
            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);
        }
    }

    best_values
}","}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}
"
HumanEval_130,tgl_Latn,rs,"/// Mga halimbawa: /// unang n + 1 mga numero ng pagkakasunud-sunod ng Tribonacci. /// Ikaw ay ibinigay ng isang hindi-negatibong integer numero n, mayroon kang sa isang bumalik sa isang vector ng /// = 2 + 3 + 3 = 8 /// tri(3) = tri(2) + tri(1) + tri(4) /// tri(4) = 3 /// tri(2) = 1 + (2 / 2) = 2 /// Halimbawa: /// tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), kung ang n ay hindi kathang-tangi. /// tri ((n) = 1 + n / 2, kung ang n ay pares. /// tri(1) = 3 /// Ang pagkakasunod-sunod ng Tribonacci ay tinukoy sa pamamagitan ng pag-uulit: //Gayunman, ang hindi alam ng mga tao ay ang pagkakasunud-sunod ni Tribonacci./// Lahat ng tao ay nakakaalam Fibonacci pagkakasunud-sunod, ito ay pinag-aralan nang malalim sa pamamagitan ng mga dalub-agbilang sa /// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {
","fn tri(n: isize) -> Vec<isize> {
    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {
        if n < memo.len() as isize {
            return memo[n as usize];
        }

        let result = if n == 1 {
            3
        } else if n % 2 == 0 {
            1 + n / 2
        } else {
            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)
        };

        if n as usize >= memo.len() {
            memo.resize(n as usize + 1, 0);
        }
        memo[n as usize] = result;
        result
    }

    let mut sequence = Vec::new();
    let mut memo = Vec::new();

    for i in 0..=n {
        sequence.push(tribonacci(i, &mut memo));
    }

    sequence
}","}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}
"
HumanEval_131,tgl_Latn,rs,"/// Halimbawa: /// Magbalik 0 kung ang lahat ng mga digit ay kahit. /// Dahil sa isang positibong integer n, ibalik ang produkto ng mga ganung digit. /// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {
","fn digits(n: isize) -> isize {
    let mut product = 1;
    let mut has_odd = false;
    let mut num = n;

    while num > 0 {
        let digit = num % 10;
        if digit % 2 != 0 {
            product *= digit;
            has_odd = true;
        }
        num /= 10;
    }

    if has_odd {
        product
    } else {
        0
    }
}

fn main() {
    println!(""{}"", digits(1));  // 1
    println!(""{}"", digits(4));  // 0
    println!(""{}"", digits(235)); // 15
}","}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}
"
HumanEval_132,tgl_Latn,rs,"/// kung saan hindi bababa sa isang bracket sa subsequence ay naka-nest. /// Ang function ay dapat bumalik totoo kung at lamang kung may isang wastong subsequence ng mga brackets /// Lumikha ng isang function na tumatagal ng isang string bilang input na naglalaman lamang ng square brackets. /// >>> is_nested(String::from(""[[]]""))
/// true
/// >>> is_nested(String::from(""[]]]]]]][[[[[]""))
/// false
/// >>> is_nested(String::from(""[][]""))
/// false
/// >>> is_nested(String::from(""[]""))
/// false
/// >>> is_nested(String::from(""[[][]]""))
/// true
/// >>> is_nested(String::from(""[[]][[""))
/// true
fn is_nested(string: String) -> bool {
","fn is_nested(string: String) -> bool {
    let mut stack = Vec::new();
    let mut nested = false;

    for bracket in string.chars() {
        if bracket == '[' {
            stack.push(bracket);
        } else if bracket == ']' {
            if let Some(_) = stack.pop() {
                if !stack.is_empty() {
                    nested = true;
                }
            } else {
                return false;
            }
        }
    }

    nested
}

fn main() {
    println!(""{}"", is_nested(String::from(""[[]]""))); // true
    println!(""{}"", is_nested(String::from(""[]]]]]]][[[[[]""))); // false
    println!(""{}"", is_nested(String::from(""[][]""))); // false
    println!(""{}"", is_nested(String::from(""[]""))); // false
    println!(""{}"", is_nested(String::from(""[[][]]""))); // true
    println!(""{}"", is_nested(String::from(""[[]][[""))); // true
}","}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from(""[[]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]][[[[[]"")), false);
    assert_eq!(candidate(String::from(""[][]"")), false);
    assert_eq!(candidate(String::from(""[]"")), false);
    assert_eq!(candidate(String::from(""[[[[]]]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]]]]]"")), false);
    assert_eq!(candidate(String::from(""[][][[]]"")), true);
    assert_eq!(candidate(String::from(""[[]"")), false);
    assert_eq!(candidate(String::from(""[]]"")), false);
    assert_eq!(candidate(String::from(""[[]][["")), true);
    assert_eq!(candidate(String::from(""[[][]]"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""[[[[[[[["")), false);
    assert_eq!(candidate(String::from(""]]]]]]]]"")), false);
}
"
HumanEval_133,tgl_Latn,rs,"/// Mga halimbawa: /// round bawat elemento sa vector sa itaas int ((Ceiling) unang. /// Kailangan mong ibalik ang kabuuan ng mga numero sa kuadrado sa ibinigay na vector, /// Ikaw ay ibinigay ng isang vector ng mga numero. /// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {
","fn sum_squares(lst: Vec<f64>) -> isize {
    lst.iter()
        .map(|&x| x.ceil() as isize)  // Round each element to the nearest upper integer
        .map(|x| x * x)               // Square each element
        .sum()                        // Sum all the squared elements
}

fn main() {
    println!(""{}"", sum_squares(vec![1.0, 2.0, 3.0])); // 14
    println!(""{}"", sum_squares(vec![1.0, 4.0, 9.0])); // 98
    println!(""{}"", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); // 84
    println!(""{}"", sum_squares(vec![1.4, 4.2, 0.0])); // 29
    println!(""{}"", sum_squares(vec![-2.4, 1.0, 1.0])); // 6
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}
"
HumanEval_134,tgl_Latn,rs,"/// Mga halimbawa: /// Tandaan: ""salita"" ay isang grupo ng mga character na pinaghiwalay ng puwang. /// isang bahagi ng isang salita, at mali kung hindi man. /// ng isang naibigay na string ay isang alpabetiko character at ay hindi /// Gumawa ng isang function na nagbabalik true kung ang huling character /// >>> check_if_last_char_is_a_letter(String::from(""apple pie""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e""))
/// true
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e ""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {
","fn check_if_last_char_is_a_letter(txt: String) -> bool {
    if let Some(c) = txt.trim().chars().rev().next() {
        if c.is_alphabetic() {
            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {
                return !prev_char.is_alphabetic();
            }
        }
    }
    false
}

fn main() {
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pie"")));  // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e""))); // true
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e ""))); // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from("""")));           // false
}","}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from(""apple"")), false);
    assert_eq!(candidate(String::from(""apple pi e"")), true);
    assert_eq!(candidate(String::from(""eeeee"")), false);
    assert_eq!(candidate(String::from(""A"")), true);
    assert_eq!(candidate(String::from(""Pumpkin pie "")), false);
    assert_eq!(candidate(String::from(""Pumpkin pie 1"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""eeeee e "")), false);
    assert_eq!(candidate(String::from(""apple pie"")), false);
    assert_eq!(candidate(String::from(""apple pi e "")), false);
}
"
HumanEval_135,tgl_Latn,rs,"/// Mga halimbawa: /// mga halaga ng duplikado. /// walang ganoong elemento umiiral pagkatapos bumalik -1. Ang ibinigay na vector ay hindi maglaman ng /// ay hindi mas malaki o katumbas ng elemento na agad na nauna sa kanya. Kung /// Lumikha ng isang function na nagbabalik ang pinakamalaking index ng isang elemento na kung saan /// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {
","fn can_arrange(arr: Vec<isize>) -> isize {
    for i in (1..arr.len()).rev() {
        if arr[i] < arr[i - 1] {
            return i as isize;
        }
    }
    -1
}

// Example usage:
// fn main() {
//     println!(""{}"", can_arrange(vec![1, 2, 4, 3, 5])); // Outputs: 3
//     println!(""{}"", can_arrange(vec![1, 2, 3])); // Outputs: -1
// }","}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}
"
HumanEval_136,tgl_Latn,rs,"/// Mga halimbawa: /// Kung walang negatibo o positibong integers, ibalik ang mga ito bilang Wala. /// ng positibong integers sa isang vector. /// ang pinakamalaking ng negatibong integers, at 'b' ay ang pinakamaliit /// Lumikha ng isang function na bumalik ng isang tuple (a, b), kung saan 'a' ay /// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
","fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
    let mut largest_negative: Option<isize> = None;
    let mut smallest_positive: Option<isize> = None;

    for &num in &lst {
        if num < 0 {
            largest_negative = match largest_negative {
                Some(largest) => Some(largest.max(num)),
                None => Some(num),
            };
        } else if num > 0 {
            smallest_positive = match smallest_positive {
                Some(smallest) => Some(smallest.min(num)),
                None => Some(num),
            };
        }
    }

    (largest_negative, smallest_positive)
}

fn main() {
    println!(""{:?}"", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); // (None, Some(1))
    println!(""{:?}"", largest_smallest_integers(vec![])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![0])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); // (Some(-1), Some(2))
}","}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}
"
HumanEval_138,tgl_Latn,rs,"/// Halimbawa /// I-evaluate kung ang ibinigay na numero n ay maaaring isulat bilang ang kabuuan ng eksakto 4 positibong kahit na numero /// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {
","fn is_equal_to_sum_even(n: isize) -> bool {
    // A number n can be expressed as the sum of 4 positive even numbers if and only if
    // it is greater than or equal to 8 and even
    n >= 8 && n % 2 == 0
}

// Test cases
fn main() {
    println!(""{}"", is_equal_to_sum_even(4));  // false
    println!(""{}"", is_equal_to_sum_even(6));  // false
    println!(""{}"", is_equal_to_sum_even(8));  // true
}","}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}
"
HumanEval_139,tgl_Latn,rs,"/// Halimbawa: /// kung saan n > 0 /// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! /// Ang Brazilian factorial ay tinukoy bilang: /// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {
","fn factorial(n: isize) -> isize {
    (1..=n).product()
}

fn special_factorial(n: isize) -> isize {
    (1..=n).map(factorial).product()
}

fn main() {
    let result = special_factorial(4);
    println!(""{}"", result);
}","}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}
"
HumanEval_140,tgl_Latn,rs,"/// pagkatapos ay palitan ang lahat ng magkakasunod na espasyo sa - /// at kung ang isang string ay may higit sa 2 magkakasunod na puwang, /// Dahil sa isang string ng teksto, palitan ang lahat ng mga puwang sa ito sa pamamagitan ng mga underline, /// >>> fix_spaces(String::from("" Example""))
/// String::from(""Example"")
/// >>> fix_spaces(String::from("" Example 1""))
/// String::from(""Example_1"")
/// >>> fix_spaces(String::from("" Example 2""))
/// String::from(""_Example_2"")
/// >>> fix_spaces(String::from("" Example 3""))
/// String::from(""_Example-3"")
fn fix_spaces(text: String) -> String {
","fn fix_spaces(text: String) -> String {
    let mut result = String::new();
    let mut space_count = 0;

    for c in text.chars() {
        if c == ' ' {
            space_count += 1;
        } else {
            if space_count > 2 {
                result.push('-');
            } else if space_count > 0 {
                result.push_str(&""_"".repeat(space_count));
            }
            result.push(c);
            space_count = 0;
        }
    }

    if space_count > 2 {
        result.push('-');
    } else if space_count > 0 {
        result.push_str(&""_"".repeat(space_count));
    }
    
    result
}","}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from(""Example"")), String::from(""Example""));
    assert_eq!(candidate(String::from(""Mudasir Hanif "")), String::from(""Mudasir_Hanif_""));
    assert_eq!(candidate(String::from(""Yellow Yellow  Dirty  Fellow"")), String::from(""Yellow_Yellow__Dirty__Fellow""));
    assert_eq!(candidate(String::from(""Exa   mple"")), String::from(""Exa-mple""));
    assert_eq!(candidate(String::from(""   Exa 1 2 2 mple"")), String::from(""-Exa_1_2_2_mple""));
}
"
HumanEval_141,tgl_Latn,rs,"/// Mga halimbawa: /// - Ang substring pagkatapos ng tuldok ay dapat na isa sa mga ito: ['txt', 'exe', 'dll'] /// ang alpabetong Latin ('a'-'z' at 'A'-'Z'). /// - Ang substring bago ang tuldok ay hindi dapat na walang laman, at ito ay nagsisimula sa isang titik mula sa /// - Ang pangalan ng file ay naglalaman ng eksaktong isang tuldok '.' /// - Hindi dapat magkaroon ng higit sa tatlong digit ('0'-'9') sa pangalan ng file. /// ay natugunan: /// Ang pangalan ng isang file ay itinuturing na may bisa kung at kung ang lahat ng mga sumusunod na kondisyon ay natutupad /// 'Oo' kung ang pangalan ng file ay wastong, at nagbabalik 'Hindi' kung hindi. /// Lumikha ng isang function na tumatagal ng isang string na kumakatawan sa pangalan ng isang file, at bumalik /// >>> file_name_check(String::from(""example.txt""))
/// String::from(""Yes"")
/// >>> file_name_check(String::from(""1example.dll""))
/// String::from(""No"")
fn file_name_check(file_name: String) -> String {
","fn file_name_check(file_name: String) -> String {
    let parts: Vec<&str> = file_name.split('.').collect();

    if parts.len() != 2 {
        return String::from(""No"");
    }

    let before_dot = parts[0];
    let after_dot = parts[1];

    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {
        return String::from(""No"");
    }

    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();
    if digit_count > 3 {
        return String::from(""No"");
    }

    match after_dot {
        ""txt"" | ""exe"" | ""dll"" => String::from(""Yes""),
        _ => String::from(""No""),
    }
}","}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from(""example.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1example.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s1sdf3.asd"")), String::from(""No""));
    assert_eq!(candidate(String::from(""K.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""MY16FILE3.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""His12FILE94.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_Y.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""?aREYA.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""/this_is_valid.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.wow"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""this_is_valid.txtexe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""#this2_i4s_5valid.ten"")), String::from(""No""));
    assert_eq!(candidate(String::from(""@this1_is6_valid.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_12valid.6exe4.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""all.exe.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_No.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""Is3youfault.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""no_one#knows.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1I563_Yes3.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_Yes3.txtt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final..txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final132"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_f4indsartal132."")), String::from(""No""));
    assert_eq!(candidate(String::from("".txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s."")), String::from(""No""));
}
"
HumanEval_142,tgl_Latn,rs,"/// Mga halimbawa: /// baguhin ang mga entry sa vector na ang mga index ay hindi isang maramihan ng 3 o 4. ang function ay pagkatapos ay ibalik ang kabuuan ng lahat ng mga entry. /// maramihang 3 at ay cube ang integer entry kung ang index ay isang maramihang ng 4 at hindi ng isang maramihang ng 3. Ang function ay hindi /// function na ito ay kumuha ng isang vector ng mga integer. Para sa lahat ng mga entry sa vector, ang function ay dapat sa square ang integer entry kung ang index ay isang /// "" /// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {
","fn sum_squares(lst: Vec<isize>) -> isize {
    lst.into_iter()
        .enumerate()
        .map(|(i, value)| {
            if i % 3 == 0 {
                value * value
            } else if i % 4 == 0 {
                value * value * value
            } else {
                value
            }
        })
        .sum()
}

fn main() {
    let lst = vec![1, 2, 3];
    println!(""{}"", sum_squares(lst)); // Outputs: 14

    let lst = vec![];
    println!(""{}"", sum_squares(lst)); // Outputs: 0

    let lst = vec![-1, -5, 2, -1, -5];
    println!(""{}"", sum_squares(lst)); // Outputs: 112
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}
"
HumanEval_143,tgl_Latn,rs,"/// Halimbawa 1: /// ang pagkakasunud-sunod ng mga salita sa bagong string ay dapat na pareho sa orihinal na isa. /// na ang haba ay mga bilang primo, /// at kailangan mong ibalik ang isang string na naglalaman ng mga salita mula sa orihinal na pangungusap, /// ang pangungusap ay naglalaman ng ilang mga salita na pinaghiwalay ng isang espasyo, /// Binigyan ka ng string na kumakatawan sa isang pangungusap, /// >>> words_in_sentence(String::from(""This is a test""))
/// String::from(""is"")
/// Example 2:
/// >>> words_in_sentence(String::from(""lets go for swimming""))
/// String::from(""go for"")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn words_in_sentence(sentence: String) -> String {
    let words: Vec<&str> = sentence.split_whitespace().collect();
    let prime_length_words: Vec<&str> = words
        .iter()
        .filter(|&&word| is_prime(word.len()))
        .cloned()
        .collect();
    prime_length_words.join("" "")
}

fn main() {
    assert_eq!(
        words_in_sentence(String::from(""This is a test"")),
        String::from(""is"")
    );
    assert_eq!(
        words_in_sentence(String::from(""lets go for swimming"")),
        String::from(""go for"")
    );
}","}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from(""This is a test"")), String::from(""is""));
    assert_eq!(candidate(String::from(""lets go for swimming"")), String::from(""go for""));
    assert_eq!(candidate(String::from(""there is no place available here"")), String::from(""there is no place""));
    assert_eq!(candidate(String::from(""Hi I am Hussein"")), String::from(""Hi am Hussein""));
    assert_eq!(candidate(String::from(""go for it"")), String::from(""go for it""));
    assert_eq!(candidate(String::from(""here"")), String::from(""""));
    assert_eq!(candidate(String::from(""here is"")), String::from(""is""));
}
"
HumanEval_144,tgl_Latn,rs,"/// Maaari mong isipin na ang x, at n ay mga wastong fractions, at hindi may zero bilang denominator. /// <numerator>/<denominator> kung saan parehong numerator at denominator ay positibong buong numero. //Parehong x at n, ay string representasyon ng isang fraction, at may sumusunod na format, /// x * n. Ang function ay nagbabalik true kung x * n ay nag-a-evaluate sa isang buong bilang at false /// Ang iyong gawain ay upang ipatupad ang isang function na ay simplify ang expression /// >>> simplify(String::from(""1/5""), String::from(""5/1""))
/// true
/// >>> simplify(String::from(""1/6""), String::from(""2/1""))
/// false
/// >>> simplify(String::from(""7/10""), String::from(""10/2""))
/// false
fn simplify(x: String, n: String) -> bool {
","fn gcd(a: u32, b: u32) -> u32 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

fn simplify(x: String, n: String) -> bool {
    let x_parts: Vec<&str> = x.split('/').collect();
    let n_parts: Vec<&str> = n.split('/').collect();
    
    let x_num: u32 = x_parts[0].parse().unwrap();
    let x_den: u32 = x_parts[1].parse().unwrap();
    let n_num: u32 = n_parts[0].parse().unwrap();
    let n_den: u32 = n_parts[1].parse().unwrap();
    
    let result_num = x_num * n_num;
    let result_den = x_den * n_den;
    
    let gcd_value = gcd(result_num, result_den);
    
    result_den / gcd_value == 1
}","}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/6""), String::from(""2/1"")), false);
    assert_eq!(candidate(String::from(""5/1""), String::from(""3/1"")), true);
    assert_eq!(candidate(String::from(""7/10""), String::from(""10/2"")), false);
    assert_eq!(candidate(String::from(""2/10""), String::from(""50/10"")), true);
    assert_eq!(candidate(String::from(""7/2""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""11/6""), String::from(""6/1"")), true);
    assert_eq!(candidate(String::from(""2/3""), String::from(""5/2"")), false);
    assert_eq!(candidate(String::from(""5/2""), String::from(""3/5"")), false);
    assert_eq!(candidate(String::from(""2/4""), String::from(""8/4"")), true);
    assert_eq!(candidate(String::from(""2/4""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""1/5"")), false);
}
"
HumanEval_145,tgl_Latn,rs,"/// Halimbawa: /// ay susuriin ang mga ito batay sa kanilang index sa orihinal na vector. /// Tandaan: kung may ilang mga item na may katulad na kabuuan ng kanilang mga numero, /// sa pagtaas na pagkakasunud-sunod ayon sa kabuuan ng kanilang mga digit. /// Isulat ang isang function na sorts ang ibinigay na vector ng integers /// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
","fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();

    nums_with_indices.sort_by_key(|&(num, index)| {
        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();
        (sum_of_digits, index)
    });

    nums_with_indices.iter().map(|&(num, _)| num).collect()
}

fn main() {
    // Example usage
    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);
    println!(""{:?}"", sorted); // Output: [-1, -11, 1, -12, 11]
}","}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}
"
HumanEval_146,tgl_Latn,rs,"/// Halimbawa: /// unang at huling digit ng isang bilang ay kakaiba (1, 3, 5, 7, 9). /// ang bilang ng mga elemento sa vector na mas malaki kaysa sa 10 at parehong /// Sumulat ng isang function na tumatagal ng isang vector ng mga numero bilang input at returns /// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {
","fn specialFilter(nums: Vec<isize>) -> isize {
    nums.into_iter().filter(|&num| {
        let abs_num = num.abs();
        abs_num > 10 && {
            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();
            let first_digit = digits.first().unwrap();
            let last_digit = digits.last().unwrap();
            first_digit % 2 == 1 && last_digit % 2 == 1
        }
    }).count() as isize
}

// Example usage:
// fn main() {
//     let result1 = specialFilter(vec![15, -73, 14, -15]);
//     println!(""{}"", result1); // Output: 1

//     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);
//     println!(""{}"", result2); // Output: 2
// }","}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}
"
HumanEval_147,tgl_Latn,rs,"/// Halimbawa: /// at a[i] + a[j] + a[k] ay isang maramihang bahagi ng 3. /// Ibalik ang bilang ng mga triple (a[i], a[j], a[k]) ng isang kung saan i < j < k, /// Para sa bawat i (1 ≤ i ≤ n), ang halaga ng a[i] = i * i - i + 1. /// Ikaw ay ibinigay ng isang positibong integer n. Ikaw ay may upang lumikha ng isang integer vector ng haba n. /// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {
","fn get_max_triples(n: isize) -> isize {
    let mut a = Vec::new();
    for i in 1..=n {
        a.push(i * i - i + 1);
    }
    
    let mut count = 0;
    for i in 0..n {
        for j in i+1..n {
            for k in j+1..n {
                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {
                    count += 1;
                }
            }
        }
    }
    count
}

fn main() {
    println!(""{}"", get_max_triples(5)); // Output: 1
}","}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}
"
HumanEval_149,tgl_Latn,rs,"/// Halimbawa: /// Maaari mong isiping lahat ng salita ay magkakapareho ang haba. /// Ang function ay dapat bumalik ng isang vector ng mga string sa naka-order order. /// Kung ang dalawang salita ay may parehong haba, i-sort ang vector ayon sa alpabetiko. /// ay dapat ibalik ang vector na nakaayos sa pamamagitan ng na panuntunan. /// Ang pagkakasunud-sunod ng vector ay dapat na tumataas sa haba ng bawat salita, at ikaw /// at maaaring may mga duplikado. /// Ang vector ay palaging isang vector ng mga string at hindi kailanman isang vector ng mga numero, /// at nagbabalik ang nagresultang vector na may isang naka-order na pagkakasunud-sunod, /// ay tinanggal ang mga string na may ganon katagal mula dito, /// Isulat ang isang function na tumatanggap ng isang vector ng mga string bilang isang parameter, /// >>> list_sort(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")])
/// vec![String::from(""aa"")]
/// >>> list_sort(vec![String::from(""ab""), String::from(""a""), String::from(""aaa""), String::from(""cd"")])
/// vec![String::from(""ab""), String::from(""cd"")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
","fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
    let mut even_length_strings: Vec<String> = lst
        .into_iter()
        .filter(|s| s.len() % 2 == 0)
        .collect();
    
    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));
    
    even_length_strings
}

fn main() {
    let result = sorted_list_sum(vec![
        String::from(""aa""),
        String::from(""a""),
        String::from(""aaa""),
    ]);
    println!(""{:?}"", result); // Should print: [""aa""]

    let result = sorted_list_sum(vec![
        String::from(""ab""),
        String::from(""a""),
        String::from(""aaa""),
        String::from(""cd""),
    ]);
    println!(""{:?}"", result); // Should print: [""ab"", ""cd""]
}","}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")]), vec![String::from(""aa"")]);
    assert_eq!(candidate(vec![String::from(""school""), String::from(""AI""), String::from(""asdf""), String::from(""b"")]), vec![String::from(""AI""), String::from(""asdf""), String::from(""school"")]);
    assert_eq!(candidate(vec![String::from(""d""), String::from(""b""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""d""), String::from(""dcba""), String::from(""abcd""), String::from(""a"")]), vec![String::from(""abcd""), String::from(""dcba"")]);
    assert_eq!(candidate(vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]), vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]);
    assert_eq!(candidate(vec![String::from(""a""), String::from(""b""), String::from(""b""), String::from(""c""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""aaaa""), String::from(""bbbb""), String::from(""dd""), String::from(""cc"")]), vec![String::from(""cc""), String::from(""dd""), String::from(""aaaa""), String::from(""bbbb"")]);
}
"
HumanEval_150,tgl_Latn,rs,"/// Mga halimbawa: /// isang pangunahing numero at dapat ibalik ang halaga ng y kung hindi man. /// Isang simpleng programa na dapat ibalik ang halaga ng x kung n ay /// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {
","fn x_or_y(n: isize, x: isize, y: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        for i in 2..=((num as f64).sqrt() as isize) {
            if num % i == 0 {
                return false;
            }
        }
        true
    }
    
    if is_prime(n) {
        x
    } else {
        y
    }
}

fn main() {
    println!(""{}"", x_or_y(7, 34, 12)); // Output: 34
    println!(""{}"", x_or_y(15, 8, 5)); // Output: 5
}","}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}
"
HumanEval_151,tgl_Latn,rs,"/// sa vector na mga ganon. Iwasan ang mga numero na negatibo o hindi integers. /// Dahil sa isang vector ng mga numero, ibalik ang kabuuan ng mga parisukat ng mga numero /// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {
","fn double_the_difference(lst: Vec<f64>) -> isize {
    lst.iter()
        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)
        .map(|&x| (x as isize).pow(2))
        .sum()
}

fn main() {
    println!(""{}"", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); // 10
    println!(""{}"", double_the_difference(vec![-1.0, -2.0, 0.0])); // 0
    println!(""{}"", double_the_difference(vec![9.0, -2.0])); // 81
    println!(""{}"", double_the_difference(vec![0.0])); // 0
    println!(""{}"", double_the_difference(vec![])); // 0
}","}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}
"
HumanEval_152,tgl_Latn,rs,"/// halimbawa: /// ang halaga ay 0, at kung hindi, ang halaga ay ang ganap na pagkakaiba sa pagitan ng guess at ang puntos. /// Magbalik ng isang vector ng parehong haba na nagpapahiwatig kung gaano kalayo ang bawat guess ay. Kung sila ay may guessed tama, /// Ikaw ay ibinigay ng dalawang vectors ng mga marka at mga hula ng pantay na haba, kung saan ang bawat index ay nagpapakita ng isang tugma. /// Ang iyong gawain ay upang matukoy kung ang isang tao ay tama ang mga resulta ng isang bilang ng mga tugma. /// tiyak na nagkakahalaga ng pag-uulat at paghahambing. //Ang mga damdamin at mga kaisipan na mayroon ka sa sandaling iyon ay.../// Sa palagay ko lahat tayo ay naaalala ang nadarama na iyon kapag ang resulta ng ilang matagal nang hinintay /// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
","fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
    game.iter()
        .zip(guess.iter())
        .map(|(g, gss)| (g - gss).abs())
        .collect()
}

fn main() {
    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);
    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);
    println!(""{:?}"", result1); // Output: [0, 0, 0, 0, 3, 3]
    println!(""{:?}"", result2); // Output: [4, 4, 1, 0, 0, 6]
}","}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}
"
HumanEval_153,tgl_Latn,rs,"/// Halimbawa: /// (ang lakas nito ay -1). /// bumalik 'Slices.SErviNGSliCes' dahil 'SErviNGSliCes' ay ang pinakamatibay na extension /// extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] kung gayon dapat mong /// Halimbawa, kung ikaw ay ibinigay ""Slices"" bilang ang klase at isang vector ng /// pumili ng isa na dumating muna sa vector. /// Kung may dalawa o higit pang mga extension na may parehong lakas, dapat mong /// format: ClassName.StrongestExtensionName. /// Dapat mong mahanap ang pinakamatibay na extension at ibalik ang isang string sa ito /// sa pangalan ng extension, ang lakas ay ibinigay ng fraction CAP - SM. /// mga titik sa pangalan ng extension, at ipaalam SM ang bilang ng mga maliit na titik /// lakas ng extension ay ang mga sumusunod: Hayaan ang CAP ang bilang ng uppercase /// Ang mga extension ay gagamitin upang i-load ang mga karagdagang klase sa klase./// Ikaw ay bibigyan ng pangalan ng isang klase (isang string) at isang vector ng mga extension. /// >>> Strongest_Extension(String::from(""my_class""), vec![String::from(""AA""), String::from(""Be""), String::from(""CC"")])
/// String::from(""my_class.AA"")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
","fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
    let mut strongest_extension = String::new();
    let mut max_strength = i32::MIN;

    for extension in extensions {
        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;
        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;
        let strength = cap_count - sm_count;

        if strength > max_strength {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    format!(""{}.{}"", class_name, strongest_extension)
}","}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from(""Watashi""), vec![String::from(""tEN""), String::from(""niNE""), String::from(""eIGHt8OKe"")]), String::from(""Watashi.eIGHt8OKe""));
    assert_eq!(candidate(String::from(""Boku123""), vec![String::from(""nani""), String::from(""NazeDa""), String::from(""YEs.WeCaNe""), String::from(""32145tggg"")]), String::from(""Boku123.YEs.WeCaNe""));
    assert_eq!(candidate(String::from(""__YESIMHERE""), vec![String::from(""t""), String::from(""eMptY""), String::from(""nothing""), String::from(""zeR00""), String::from(""NuLl__""), String::from(""123NoooneB321"")]), String::from(""__YESIMHERE.NuLl__""));
    assert_eq!(candidate(String::from(""K""), vec![String::from(""Ta""), String::from(""TAR""), String::from(""t234An""), String::from(""cosSo"")]), String::from(""K.TAR""));
    assert_eq!(candidate(String::from(""__HAHA""), vec![String::from(""Tab""), String::from(""123""), String::from(""781345""), String::from(""-_-"")]), String::from(""__HAHA.123""));
    assert_eq!(candidate(String::from(""YameRore""), vec![String::from(""HhAas""), String::from(""okIWILL123""), String::from(""WorkOut""), String::from(""Fails""), String::from(""-_-"")]), String::from(""YameRore.okIWILL123""));
    assert_eq!(candidate(String::from(""finNNalLLly""), vec![String::from(""Die""), String::from(""NowW""), String::from(""Wow""), String::from(""WoW"")]), String::from(""finNNalLLly.WoW""));
    assert_eq!(candidate(String::from(""_""), vec![String::from(""Bb""), String::from(""91245"")]), String::from(""_.Bb""));
    assert_eq!(candidate(String::from(""Sp""), vec![String::from(""671235""), String::from(""Bb"")]), String::from(""Sp.671235""));
}
"
HumanEval_154,tgl_Latn,rs,"/// Ikaw ay bibigyan ng 2 salita. Kailangan mong bumalik totoo kung ang ikalawang salita o anumang ng mga pag-ikot nito ay isang substring sa unang salita /// >>> cycpattern_check(String::from(""abcd""), String::from(""abd""))
/// false
/// >>> cycpattern_check(String::from(""hello""), String::from(""ell""))
/// true
/// >>> cycpattern_check(String::from(""whassup""), String::from(""psus""))
/// false
/// >>> cycpattern_check(String::from(""abab""), String::from(""baa""))
/// true
/// >>> cycpattern_check(String::from(""efef""), String::from(""eeff""))
/// false
/// >>> cycpattern_check(String::from(""himenss""), String::from(""simen""))
/// true
fn cycpattern_check(a: String, b: String) -> bool {
","fn cycpattern_check(a: String, b: String) -> bool {
    let len_b = b.len();
    if len_b == 0 {
        return true;
    }
    let doubled_b = b.clone() + &b;
    for i in 0..len_b {
        if let Some(sub) = doubled_b.get(i..i + len_b) {
            if a.contains(sub) {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from(""xyzw""), String::from(""xyw"")), false);
    assert_eq!(candidate(String::from(""yello""), String::from(""ell"")), true);
    assert_eq!(candidate(String::from(""whattup""), String::from(""ptut"")), false);
    assert_eq!(candidate(String::from(""efef""), String::from(""fee"")), true);
    assert_eq!(candidate(String::from(""abab""), String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""winemtt""), String::from(""tinem"")), true);
}
"
HumanEval_155,tgl_Latn,rs,"/// Halimbawa: /// Given isang integer. bumalik ng isang tuple na may bilang ng kahit at kakaibang mga digit ayon sa pagkakabanggit. /// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {
","fn even_odd_count(num: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    let num_str = num.abs().to_string();
    
    for ch in num_str.chars() {
        if let Some(digit) = ch.to_digit(10) {
            if digit % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}
"
HumanEval_156,tgl_Latn,rs,"/// Mga halimbawa: /// Mga paghihigpit: 1 <= num <= 1000 /// at ibalik ito sa maliit na titik. /// Dahil sa isang positibong integer, makuha ang Roman numerals katumbas nito bilang isang string, /// >>> int_to_mini_roman(19)
/// String::from(""xix"")
/// >>> int_to_mini_roman(152)
/// String::from(""clii"")
/// >>> int_to_mini_roman(426)
/// String::from(""cdxxvi"")
fn int_to_mini_roman(number: isize) -> String {
","fn int_to_mini_roman(mut number: isize) -> String {
    let roman_numerals = [
        (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
        (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
        (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
        (1, ""i""),
    ];
    
    let mut result = String::new();
    
    for &(value, symbol) in roman_numerals.iter() {
        while number >= value {
            number -= value;
            result.push_str(symbol);
        }
    }
    
    result
}","}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from(""xix""));
    assert_eq!(candidate(152), String::from(""clii""));
    assert_eq!(candidate(251), String::from(""ccli""));
    assert_eq!(candidate(426), String::from(""cdxxvi""));
    assert_eq!(candidate(500), String::from(""d""));
    assert_eq!(candidate(1), String::from(""i""));
    assert_eq!(candidate(4), String::from(""iv""));
    assert_eq!(candidate(43), String::from(""xliii""));
    assert_eq!(candidate(90), String::from(""xc""));
    assert_eq!(candidate(94), String::from(""xciv""));
    assert_eq!(candidate(532), String::from(""dxxxii""));
    assert_eq!(candidate(900), String::from(""cm""));
    assert_eq!(candidate(994), String::from(""cmxciv""));
    assert_eq!(candidate(1000), String::from(""m""));
}
"
HumanEval_157,tgl_Latn,rs,"/// Halimbawa: /// 90 degree. /// Ang isang right-angled triangle ay isang triangle na kung saan ang isang anggulo ay tuwid na anggulo o /// panig ay bumubuo ng isang right-angled triangle, mali kung hindi man. /// Na ibinigay ang haba ng tatlong panig ng isang tatsulok. Magbalik true kung ang tatlong /// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
","fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
    let mut sides = [a, b, c];
    sides.sort_unstable();

    let [x, y, z] = sides;
    x * x + y * y == z * z
}","}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}
"
HumanEval_158,tgl_Latn,rs,"/// character, ibalik ang isa na unang dumating sa pagkakasunud-sunod ng leksikograpiya. /// ng natatanging mga character. Kung maramihang mga string ay may maximum na bilang ng natatanging /// Ang vector ay naglalaman ng iba't ibang mga salita. Ibalik ang salita na may maximum na bilang /// Isulat ang isang function na tumatanggap ng isang vector ng mga string. /// >>> find_max(vec![String::from(""name""), String::from(""of""), String::from(""string"")])
/// String::from(""string"")
/// >>> find_max(vec![String::from(""name""), String::from(""enam""), String::from(""game"")])
/// String::from(""enam"")
/// >>> find_max(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")])
/// String::from(""aaaaaaa"")
fn find_max(words: Vec<String>) -> String {
","fn find_max(words: Vec<String>) -> String {
    fn unique_char_count(s: &str) -> usize {
        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();
        for c in s.chars() {
            chars.insert(c);
        }
        chars.len()
    }

    words
        .into_iter()
        .max_by(|a, b| {
            let count_a = unique_char_count(a);
            let count_b = unique_char_count(b);
            count_a.cmp(&count_b).then_with(|| a.cmp(b))
        })
        .unwrap()
}","}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from(""name""), String::from(""of""), String::from(""string"")]), String::from(""string""));
    assert_eq!(candidate(vec![String::from(""name""), String::from(""enam""), String::from(""game"")]), String::from(""enam""));
    assert_eq!(candidate(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")]), String::from(""aaaaaaa""));
    assert_eq!(candidate(vec![String::from(""abc""), String::from(""cba"")]), String::from(""abc""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""this""), String::from(""game""), String::from(""of""), String::from(""footbott"")]), String::from(""footbott""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""gonna""), String::from(""rock"")]), String::from(""gonna""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""a""), String::from(""mad""), String::from(""nation"")]), String::from(""nation""));
    assert_eq!(candidate(vec![String::from(""this""), String::from(""is""), String::from(""a""), String::from(""prrk"")]), String::from(""this""));
    assert_eq!(candidate(vec![String::from(""b"")]), String::from(""b""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""play""), String::from(""play"")]), String::from(""play""));
}
"
HumanEval_159,tgl_Latn,rs,"/// Halimbawa: /// kung wala nang sapat na natitirang mga karot, kakain mo ang lahat ng natitirang mga karot, ngunit gutom ka pa rin. /// ang bilang ng mga karot na natitira pagkatapos ng iyong pagkain ] /// dapat mong ibalik ang isang vector ng [kabuuang bilang ng mga karot na kinain pagkatapos ng iyong pagkain, /// ngunit ngayon kailangan mong kumain ng mas maraming karot upang makumpleto ang mga pagkain sa araw. /// Ikaw ay isang gutom na koneho, at ikaw ay nakain na ng isang tiyak na bilang ng mga karot, /// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
","fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
    let to_eat = if need <= remaining { need } else { remaining };
    vec![number + to_eat, remaining - to_eat]
}","}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}
"
HumanEval_160,tgl_Latn,rs,"/// Operator vector ay may hindi bababa sa isang operator, at operand vector ay may hindi bababa sa dalawang operands. /// Operand ay isang vector ng ng di-negatibong integers. /// Ang haba ng operator vector ay katumbas ng haba ng operand vector minus isa. /// Tandaan: /// => resulta = 9 /// resulta = 2 + 3 * 4 - 5 /// vector = [2, 3, 4, 5] /// operator['+', '*', '-'] /// Halimbawa: /// Pagpapalawak (**) /// Pagbabahagi ng sahig ( // ) /// Multiplikasyon ( * ) /// Pagbawas ( - ) /// Pagdaragdag ( + ) /// Ang pangunahing mga operasyon sa algebra: /// expression at ibalik ang evaluation ng expression na ito. /// ang ikalawang vector ay isang vector ng integers. Gamitin ang dalawang ibinigay na vectors upang bumuo ng algebraic /// Dahil sa dalawang vector operator, at operand. Ang unang vector ay may pangunahing algebra operasyon, at fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
","fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
    let mut result = operand[0];
    
    for i in 0..operator.len() {
        match operator[i].as_str() {
            ""+"" => result += operand[i+1],
            ""-"" => result -= operand[i+1],
            ""*"" => result *= operand[i+1],
            ""//"" => result /= operand[i+1],
            ""**"" => result = result.pow(operand[i+1] as u32),
            _ => panic!(""Unexpected operator""),
        }
    }
    
    result
}

fn main() {
    let operators = vec![""+"",""*"",""-""].iter().map(|s| s.to_string()).collect();
    let operands = vec![2, 3, 4, 5];
    let result = do_algebra(operators, operands);
    println!(""Result: {}"", result);
}","}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from(""**""), String::from(""*""), String::from(""+"")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from(""+""), String::from(""*""), String::from(""-"")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from(""//""), String::from(""*"")], vec![7, 3, 4]), 8);
}
"
HumanEval_161,tgl_Latn,rs,"/// Mga Halimbawa /// Ang function ay dapat ibalik ang nagresultang string. /// Kung ang string ay walang mga titik, i-reverse ang string. /// kung hindi man manatili ito gaya ng dati. /// kung s[i] ay isang titik, ibalik ang kaso nito mula sa ibaba hanggang sa itaas o vice versa, /// Ikaw ay binigyan ng isang string s. /// >>> solve(String::from(""1234""))
/// String::from(""4321"")
/// >>> solve(String::from(""ab""))
/// String::from(""AB"")
/// >>> solve(String::from(""#a@C""))
/// String::from(""#A@c"")
fn solve(s: String) -> String {
","fn solve(s: String) -> String {
    if s.chars().all(|c| !c.is_alphabetic()) {
        s.chars().rev().collect()
    } else {
        s.chars()
            .map(|c| {
                if c.is_lowercase() {
                    c.to_ascii_uppercase()
                } else if c.is_uppercase() {
                    c.to_ascii_lowercase()
                } else {
                    c
                }
            })
            .collect()
    }
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from(""AsDf"")), String::from(""aSdF""));
    assert_eq!(candidate(String::from(""1234"")), String::from(""4321""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""AB""));
    assert_eq!(candidate(String::from(""#a@C"")), String::from(""#A@c""));
    assert_eq!(candidate(String::from(""#AsdfW^45"")), String::from(""#aSDFw^45""));
    assert_eq!(candidate(String::from(""#6@2"")), String::from(""2@6#""));
    assert_eq!(candidate(String::from(""#$a^D"")), String::from(""#$A^d""));
    assert_eq!(candidate(String::from(""#ccc"")), String::from(""#CCC""));
}
"
HumanEval_162,tgl_Latn,rs,"/// Kung 'text' ay isang walang laman na string, bumalik Walang. /// Dahil sa isang string 'text', ibalik ang md5 hash katumbas string. /// >>> string_to_md5(String::from(""Hello world""))
/// Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62""))
fn string_to_md5(text: String) -> Option<String> {
","use md5;

fn string_to_md5(text: String) -> Option<String> {
    if text.is_empty() {
        return None;
    }
    let digest = md5::compute(text);
    Some(format!(""{:x}"", digest))
}","}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from(""Hello world"")), Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert_eq!(candidate(String::from("""")), None);
    assert_eq!(candidate(String::from(""A B C"")), Some(String::from(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert_eq!(candidate(String::from(""password"")), Some(String::from(""5f4dcc3b5aa765d61d8327deb882cf99"")));
}
"
HumanEval_163,tgl_Latn,rs,"/// Halimbawa: /// at b, sa pag-akyat na pagkakasunud-sunod. /// Dahil sa dalawang positibong integers a at b, ibalik ang kahit na mga digit sa pagitan ng a /// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {
","fn generate_integers(a: isize, b: isize) -> Vec<isize> {
    let (start, end) = if a < b { (a, b) } else { (b, a) };
    (start..=end).filter(|&x| x % 2 == 0).collect()
}

fn main() {
    let result1 = generate_integers(2, 8);
    println!(""{:?}"", result1); // Output: vec![2, 4, 6, 8]

    let result2 = generate_integers(8, 2);
    println!(""{:?}"", result2); // Output: vec![2, 4, 6, 8]

    let result3 = generate_integers(10, 14);
    println!(""{:?}"", result3); // Output: vec![10, 12, 14]
}","}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}
"
