[{"task_id":"HumanEval_0","nl":"ceb_Latn","pl":"hs","prompt":"--gihatagan nga sukod. --◯ Susiha kon sa gihatag nga listahan sa mga numero, adunay duha ka numero nga mas duol sa usag usa kay sa ◯--  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =","canonical_solution":"hasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold = any (\\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a \/= b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_1","nl":"ceb_Latn","pl":"hs","prompt":"--Ayaw pagtagad sa bisan unsa nga mga luna sa input string. --Ang nagkalainlaing grupo gibalanse (ang matag bukas nga brace husto nga gisirado) ug dili mag-uukit sa usag usa --pagbulag sa maong grupo ngadto sa lain-laing mga linya ug pagbalik sa listahan sa mga. --Ang input sa niini nga function mao ang usa ka string nga naglangkob sa daghang mga grupo sa nested parentesis.--  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =","canonical_solution":"separateParenGroups :: String -> [String]\nseparateParenGroups paren_string = go paren_string 0 [] \"\" []\n  where\n    go [] _ _ current acc = if null current then acc else acc ++ [current]\n    go (x:xs) depth stack current acc\n      | x == ' ' = go xs depth stack current acc\n      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc\n      | x == ')' =\n          let newCurrent = current ++ [x]\n              newDepth = depth - 1\n          in if newDepth == 0\n             then go xs newDepth (tail stack) \"\" (acc ++ [newCurrent])\n             else go xs newDepth (tail stack) newCurrent acc\n      | otherwise = error \"Unexpected character\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_2","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang bahin sa numero nga gi-decimalan. --(ang nahibilin nga bahin kanunayng mas gamay kay sa 1).--ug integer nga bahin (kinadak-ang integer nga mas gamay kay sa gihatag nga numero) ug mga decimal --◯ Gipasagdan ug positibo nga floating point number, kini mahimong ma-decompose ngadto sa ◯--  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =","canonical_solution":"truncateNumber :: Float -> Float\ntruncateNumber number = number - fromIntegral (floor number)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_3","nl":"ceb_Latn","pl":"hs","prompt":"--sa maong punto ang function kinahanglang mobalik sa Tinuod. Kon dili kini mobalik sa Bakak. --ang imong buluhaton mao ang pag-ila kon sa bisan unsang punto ang balanse sa account mahulog sa ubos sa zero, ug --◯ Gihatagan ka ug listahan sa mga operasyon sa deposito ug pag-atras sa usa ka bank account nga nagsugod sa ◯--  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =","canonical_solution":"belowZero :: [Int] -> Bool\nbelowZero operations = any (< 0) $ scanl (+) 0 operations","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_4","nl":"ceb_Latn","pl":"hs","prompt":"--MAD = average. x - x_mean. --elemento ug usa ka sentro nga punto (ang aberids sa maong kaso): --Ang Mean Absolute Deviation mao ang aberids nga bug-os nga kalainan tali sa matag --sa kinatibuk-an niining dataset. --Alang sa usa ka gihatag nga listahan sa input numero, kalkulahin ang Mean Absolute Deviation.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =","canonical_solution":"meanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers = sum absoluteDifferences \/ fromIntegral (length numbers)\n  where\n    mean = sum numbers \/ fromIntegral (length numbers)\n    absoluteDifferences = map (\\x -> abs (x - mean)) numbers","tests":"\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_5","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Ipasulod ang usa ka numero nga 'delimeter' tali sa matag duha ka sunod-sunod nga mga elemento sa input list ∀numbers' --  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =","canonical_solution":"intersperse :: [Int] -> Int -> [Int]\nintersperse [] _ = []\nintersperse [x] _ = [x]\nintersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_6","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan, ang (() (()) adunay labing kadaghan nga duha ka lebel sa pag-ukay samtang ang ((())) adunay tulo. --Alang sa matag usa sa grupo, i-output ang kinahiladman nga lebel sa pag-nesting sa mga parenteses. -- Ang input sa niini nga function mao ang usa ka string nga nagrepresentar sa daghang mga grupo alang sa nested parentesis gibulag sa mga wanang. --  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =","canonical_solution":"parseNestedParens :: String -> [Int]\nparseNestedParens paren_string = map maxDepth (words paren_string)\n  where\n    maxDepth :: String -> Int\n    maxDepth = go 0 0\n      where\n        go :: Int -> Int -> String -> Int\n        go currentDepth maxDepth [] = maxDepth\n        go currentDepth maxDepth (c:cs)\n          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs\n          | c == ')'  = go (currentDepth - 1) maxDepth cs\n          | otherwise = go currentDepth maxDepth cs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_7","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Pag-filter sa input nga listahan sa mga string alang lamang sa mga naglakip sa gihatag nga substring --  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =","canonical_solution":"filterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring = filter (substring `isInfixOf`) strings\n  where isInfixOf = isInfixOf","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_8","nl":"ceb_Latn","pl":"hs","prompt":"--Ang walay-pulos nga sum kinahanglan nga katumbas sa 0 ug ang walay-pulos nga produkto kinahanglang katumbas sa 1. -- Alang sa usa ka gihatag nga listahan sa integers, mobalik sa usa ka tuple nga naglangkob sa usa ka sum ug sa usa ka produkto sa tanan nga mga integers sa usa ka listahan. --  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =","canonical_solution":"sumProduct :: [Int] -> (Int, Int)\nsumProduct numbers = (sum numbers, product numbers)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_9","nl":"ceb_Latn","pl":"hs","prompt":"--sa sunodsunod. --Gikan sa usa ka gihatag nga listahan sa mga integers, pagmugna sa usa ka listahan sa rolling maximum elemento nga nakit-an hangtud sa gihatag nga panahon.--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =","canonical_solution":"rollingMax :: [Int] -> [Int]\nrollingMax = scanl1 max","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_10","nl":"ceb_Latn","pl":"hs","prompt":"--- Ilakip sa kataposan sa string nga reverse sa usa ka string prefix nga moabut sa atubangan sa palindromic suffix. --- Pangitaa ang labing taas nga postfix sa gihatag nga string nga mao ang usa ka palindrome. --Ang ideya sa algoritmo yano: --Pangitaa ang labing mubo nga palindrome nga nagsugod sa gihatag nga string.--  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =","canonical_solution":"makePalindrome :: String -> String\nmakePalindrome string = string ++ reverse (take (length string - palindromeLength) string)\n  where\n    palindromeLength = longestPalindromicSuffix string\n\nlongestPalindromicSuffix :: String -> Int\nlongestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]\n\nisPalindrome :: String -> Bool\nisPalindrome s = s == reverse s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_11","nl":"ceb_Latn","pl":"hs","prompt":"--Paghimo sa binary XOR sa niini nga mga input ug pagbalik resulta usab ingon nga usa ka string. --DATA nga gi-input mao ang duha ka mga string nga a ug b nga gilangkoban lamang sa 1s ug 0s. --  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =","canonical_solution":"stringXor :: String -> String -> String\nstringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_12","nl":"ceb_Latn","pl":"hs","prompt":"--Pagbalik sa Nothing kon ang input list walay sulod. --Gikan sa listahan sa mga string, mobalik sa labing taas nga usa. Mobalik sa una nga usa sa kaso sa daghang.--  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =","canonical_solution":"longest :: [String] -> Maybe String\nlongest [] = Nothing\nlongest strings = Just $ foldl1 (\\acc x -> if length x > length acc then x else acc) strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_13","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang labing dako nga komon nga divisor sa duha ka integers a ug b --  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =","canonical_solution":"greatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b\n  | b == 0    = a\n  | otherwise = greatestCommonDivisor b (a `mod` b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_14","nl":"ceb_Latn","pl":"hs","prompt":"--│ Ibalik ang listahan sa tanan nga prefix gikan sa labing mubo ngadto sa labing taas sa input string │--  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =","canonical_solution":"allPrefixes :: String -> [String]\nallPrefixes string = [take n string | n <- [1 .. length string]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_15","nl":"ceb_Latn","pl":"hs","prompt":"--│ Ibalik ang usa ka string nga naglangkob sa mga numero nga gi-delimite sa wanang nga nagsugod gikan sa 0 hangtod sa n lakip na. │--  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =","canonical_solution":"stringSequence :: Int -> String\nstringSequence n = unwords $ map show [0..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_16","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Sa usa ka string, susiha kon pila ka lahi nga karakter (dili igsapayan ang case) ang anaa niini ◯--  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =","canonical_solution":"import Data.Char (toLower)\nimport Data.Set (fromList, size)\n\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string = size . fromList $ map toLower string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_17","nl":"ceb_Latn","pl":"hs","prompt":"--'.Nagapa' - quater note, molungtad ug usa ka beat --'o sa' - tunga sa nota, molungtad ug duha ka takbo --'O' - tibuok nota, molungtad ug upat ka takbo --Ania ang usa ka sugilanon: --dili sa kataposan. --Ang imong buluhaton mao ang sa pag-parse niini nga string ug pagbalik sa listahan sa integers nga katumbas sa unsa nga gidaghanon sa mga beats sa matag usa --Ang input sa maong function mao ang usa ka string nga nagrepresentar sa mga nota sa musika sa usa ka espesyal nga ASCII format.--  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =","canonical_solution":"parseMusic :: String -> [Int]\nparseMusic music_string = map beats (words music_string)\n  where\n    beats \"o\" = 4\n    beats \"o|\" = 2\n    beats \".|\" = 1\n    beats _ = 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_18","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Pangitaa kon pila ka beses ang gihatag nga substring nga makaplagan sa orihinal nga string.--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =","canonical_solution":"howManyTimes :: String -> String -> Int\nhowManyTimes string substring\n  | null substring = 0\n  | otherwise = length . filter isPrefixOfSubstring $ tails string\n  where\n    isPrefixOfSubstring = isPrefixOf substring\n    isPrefixOf :: Eq a => [a] -> [a] -> Bool\n    isPrefixOf prefix str = prefix `isPrefixOf` str","tests":"\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_19","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang string nga adunay mga numero nga gihan-ay gikan sa kinagamyan ngadto sa kinadak-an --Ang balido nga mga pagpili mao ang 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' ug 'nine'. --Ang input maoy usa ka space-delimited nga string sa mga numero gikan sa 'zero' ngadto sa 'nine'.--  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =","canonical_solution":"import Data.List (sort)\nimport Data.Maybe (fromJust)\nimport Data.Map (Map, fromList, lookup)\n\nsortNumbers :: String -> String\nsortNumbers numbers = unwords $ map snd $ sort $ map (\\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)\n  where\n    wordToNumber :: Map String Int\n    wordToNumber = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4),\n                             (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_20","nl":"ceb_Latn","pl":"hs","prompt":"--uban ug ibalik sila sa pagkasunodsunod (mas gamay nga gidaghanon, mas dako nga gidaghanon).--Gikan sa usa ka gihatag nga listahan sa mga numero (sa gitas-on sa labing menos duha) pagpili ug pagbalik sa duha nga mao ang labing duol sa matag usa --  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =","canonical_solution":"findClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)\n  where\n    sortedNumbers = sort numbers\n    minByDiff (a1, b1) (a2, b2)\n      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)\n      | otherwise = (a2, b2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_21","nl":"ceb_Latn","pl":"hs","prompt":"--nga ang kinagamyan numero mahimong 0 ug ang kinadak-an mahimong 1 --◯ Gihatagan lista sa mga numero (sa labing menos duha ka mga elemento), iaplikar ang usa ka linear nga pagbalhin ngadto sa maong listahan, --  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =","canonical_solution":"rescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers = map (\\x -> (x - minVal) \/ range) numbers\n  where\n    minVal = minimum numbers\n    maxVal = maximum numbers\n    range = maxVal - minVal","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_23","nl":"ceb_Latn","pl":"hs","prompt":"--Balik sa gitas-on sa gihatag nga string --  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =","canonical_solution":"strlen :: String -> Int\nstrlen string = length string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_24","nl":"ceb_Latn","pl":"hs","prompt":"--Alang sa usa ka gihatag nga numero nga n, pangitaa ang kinadak-ang numero nga nag-apod-apod sa n, mas gamay kay sa n.--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =","canonical_solution":"largestDivisor :: Int -> Int\nlargestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_25","nl":"ceb_Latn","pl":"hs","prompt":"--Ang input number angayng katumbas sa produkto sa tanang mga butang --Ang matag usa sa mga hinungdan kinahanglang ilista sa gidaghanon sa mga higayon nga katumbas sa gidaghanon sa mga higayon nga kini makita diha sa pag-factorize.--Ibalik ang listahan sa mga primerong mga factor sa gihatag nga integer nga giuranan gikan sa kinagamyan ngadto sa kinadak-an.--  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =","canonical_solution":"factorize :: Int -> [Int]\nfactorize n = factorize' n 2\n  where\n    factorize' 1 _ = []\n    factorize' m f\n      | m `mod` f == 0 = f : factorize' (m `div` f) f\n      | otherwise      = factorize' m (f + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_26","nl":"ceb_Latn","pl":"hs","prompt":"--Hupti ang pagkasunodsunod sa mga elemento nga wala na sama sa input. --Gikan sa usa ka listahan sa mga integer, kuhaa ang tanang elemento nga mahitabo sa labaw pa sa makausa.--  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =","canonical_solution":"removeDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers = filter (\\x -> count x numbers == 1) numbers\n  where\n    count x = length . filter (== x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_27","nl":"ceb_Latn","pl":"hs","prompt":"-- Alang sa usa ka gihatag nga string, i-flip ang mga character sa lowercase ngadto sa uppercase ug ang uppercase ngadto sa lowercase. --  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =","canonical_solution":"flipCase :: String -> String\nflipCase = map flipChar\n  where\n    flipChar c\n      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)\n      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_28","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Pag-concatenate sa listahan sa mga string ngadto sa usa ka string --  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =","canonical_solution":"concatenate :: [String] -> String\nconcatenate strings = concat strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_29","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Pag-filter sa input nga listahan sa mga string alang lamang sa mga sugod sa usa ka gihatag nga prefix. --  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =","canonical_solution":"filterByPrefix strings prefix = filter (isPrefixOf prefix) strings\n  where\n    isPrefixOf pfx str = take (length pfx) str == pfx","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_30","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik lamang ang positibo nga mga numero sa listahan.--  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =","canonical_solution":"getPositive :: [Int] -> [Int]\ngetPositive l = filter (> 0) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_31","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang tinuod kon ang gihatag nga numero maoy primo, ug bakak kon dili.--  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =","canonical_solution":"isPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = not (any (\\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_33","nl":"ceb_Latn","pl":"hs","prompt":"--sa mga bili sa katumbas nga mga indices sa l, apan gihan-ay. --l' mao ang managsama sa l sa mga indices nga dili bahinan sa tulo, samtang ang mga bili niini sa mga indices nga bahinan sa tulo managsama --Kini nga function nagkuha sa usa ka listahan ug mobalik sa usa ka listahan nga ingon nga --  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =","canonical_solution":"sortThird :: [Int] -> [Int]\nsortThird l = map selectElem indexed\n  where\n    indexed = zip [0..] l\n    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]\n    sortedThirdElems = sortedElems thirdIndicesElems\n    sortedElems = id -- or List.sort if imported\n    selectElem (i, x)\n      | i `mod` 3 == 0 = head sortedThirdElems\n      | otherwise = x\n    replaceSortedElem xs sorted = map selectElem indexed\n      where\n        replaceElem i (x:xs)\n          | i == 0 = x:xs\n          | otherwise = replaceElem (i - 1) xs\n        selectElem (i, x)\n          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)\n          | otherwise = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_34","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang gi-sort nga talagsaon nga mga elemento sa usa ka listahan.--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =","canonical_solution":"unique :: [Int] -> [Int]\nunique l = sort $ nub l\n  where\n    -- | Remove duplicate elements from a list.\n    nub :: (Eq a) => [a] -> [a]\n    nub [] = []\n    nub (x:xs) = x : nub (filter (\/= x) xs)\n\n    -- | Sort a list of elements (using QuickSort algorithm).\n    sort :: (Ord a) => [a] -> [a]\n    sort [] = []\n    sort (x:xs) =\n      let smallerSorted = sort [a | a <- xs, a <= x]\n          biggerSorted = sort [a | a <- xs, a > x]\n      in  smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_35","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang maximum nga elemento sa listahan.--  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =","canonical_solution":"maxElement :: [Int] -> Int\nmaxElement [] = error \"List cannot be empty\"\nmaxElement (x:xs) = maxElementHelper xs x\n  where\n    maxElementHelper [] currentMax = currentMax\n    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_36","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang gidaghanon sa mga panahon nga ang digit 7 makita sa integers nga mas ubos kay sa n nga mao ang bahin sa 11 o 13.--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =","canonical_solution":"fizzBuzz :: Int -> Int\nfizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_37","nl":"ceb_Latn","pl":"hs","prompt":"--sa mga bili sa bisan indices sa l, apan gihan-ay. --l' mao ang managsama sa l sa mga indices sa dili-parehas, samtang ang mga bili niini sa bisan indices managsama --Kini nga function nagkuha sa usa ka listahan ug mobalik sa usa ka listahan nga ingon nga --  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =","canonical_solution":"sortEven :: [Int] -> [Int]\nsortEven l = merge odds sortedEvens\n  where\n    (odds, evens) = partitionList l\n    sortedEvens = sort evens\n\n    partitionList :: [Int] -> ([Int], [Int])\n    partitionList [] = ([], [])\n    partitionList [x] = ([x], [])\n    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)\n      where\n        (xsOdds, xsEvens) = partitionList xs\n\n    merge :: [Int] -> [Int] -> [Int]\n    merge [] ys = ys\n    merge (x:xs) [] = x:xs\n    merge (x:xs) (y:ys) = x:y:merge xs ys","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_39","nl":"ceb_Latn","pl":"hs","prompt":"-- prime_fib mibalik sa n-th nga numero nga usa ka Fibonacci numero ug kini usab mao ang prime. --  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =","canonical_solution":"primeFib :: Int -> Int\nprimeFib n = primeFibs !! (n - 1)\n  where\n    primeFibs = filter isPrime fibs\n    fibs = map fst $ iterate (\\(a, b) -> (b, a + b)) (0, 1)\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2 = False\n  | k == 2 = True\n  | even k = False\n  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]\n  where\n    upperLimit = floor . sqrt $ fromIntegral k","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_40","nl":"ceb_Latn","pl":"hs","prompt":"--sum ngadto sa zero, ug False kon dili. --kini mobalik True kon adunay tulo ka lahi nga mga elemento sa listahan nga --Ang triple_sum_to_zero naggamit sa listahan sa mga integer isip input.--  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =","canonical_solution":"triplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]\n  where\n    tails [] = []\n    tails xs@(_:xs') = xs : tails xs'","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_41","nl":"ceb_Latn","pl":"hs","prompt":"--Kini nga function maghatag sa gidaghanon sa maong mga pagbangga. --sa ilang agianan nga morag wala sila magbangga.--Apan, ang mga sakyanan lig-on ug lig-on kaayo; busa, sila nagpadayon sa paglihok.--kon ang sakyanan nga naglihok sa wala ngadto sa tuo mohapak sa sakyanan nga naglihok sa tuo ngadto sa wala.--Ang tanang sakyanan naglihok sa samang katulin. Ang duha ka sakyanan giingong nagbangga.--Ang duha ka grupo sa mga sakyanan nagsugod nga halayo kaayo gikan sa --n ka sakyanan nagmaneho sa wala ngadto sa tuo; sa samang higayon, lainlain nga hugpong sa n ka sakyanan --◯ Handurawa ang dalan nga hingpit nga tul-id nga walay kinutoban nga linya.carRaceCollision :: Int -> Int\ncarRaceCollision n =","canonical_solution":"carRaceCollision :: Int -> Int\ncarRaceCollision n = n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_42","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang listahan nga may mga elemento nga gipadako sa 1.--  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =","canonical_solution":"incrList :: [Int] -> [Int]\nincrList l = map (+1) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_43","nl":"ceb_Latn","pl":"hs","prompt":"--sum ngadto sa zero, ug False kon dili. --kini mobalik True kon adunay duha ka lahi nga mga elemento sa listahan nga --Ang pairs_sum_to_zero naggamit sa listahan sa mga integer isip input.--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =","canonical_solution":"pairsSumToZero :: [Int] -> Bool\npairsSumToZero l = any (\\x -> -x `elem` l) l && (length l > 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_44","nl":"ceb_Latn","pl":"hs","prompt":"--ang mga numero sa base mas ubos kay sa 10. --balik string representasyon human sa pagkakabig. --❑ Pag-usab sa numerikal nga basehan sa input nga numero nga x ngadto sa basehan.--  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =","canonical_solution":"changeBase :: Int -> Int -> String\nchangeBase x base\n  | x < base  = show x\n  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_45","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Gihatagan og gitas-on sa usa ka kilid ug taas nga area sa pagbalik alang sa usa ka triyanggo.--  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =","canonical_solution":"triangleArea :: Int -> Int -> Float\ntriangleArea a h = 0.5 * fromIntegral a * fromIntegral h","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_46","nl":"ceb_Latn","pl":"hs","prompt":"--Palihog pagsulat ug function aron sa pag-compute sa n-th nga elemento sa fib4 numero sunod-sunod. Ayaw paggamit sa pag-recursion. --fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). --fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --Ang Fib4 numero sunod-sunod mao ang usa ka sunod-sunod nga susama sa Fibbonacci sunod-sunod nga gihubit sa mosunod: --  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =","canonical_solution":"fib4 :: Int -> Int\nfib4 n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 2\n  | n == 3 = 0\n  | otherwise = iter 0 0 2 0 n\n  where\n    iter a b c d 4 = a + b + c + d\n    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_47","nl":"ceb_Latn","pl":"hs","prompt":"--│ Ibalik ang median sa mga elemento sa listahan nga l. │--  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =","canonical_solution":"median :: [Int] -> Float\nmedian l \n  | odd n     = fromIntegral $ sorted !! mid\n  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) \/ 2\n  where\n    sorted = sort l\n    n = length l\n    mid = n `div` 2\n    sort = sortBy compare","tests":"\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_48","nl":"ceb_Latn","pl":"hs","prompt":"--◯ Pag-check kon ang gihatag nga string mao ang usa ka palindrome ◯--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =","canonical_solution":"isPalindrome :: String -> Bool\nisPalindrome text = text == reverse text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_49","nl":"ceb_Latn","pl":"hs","prompt":"--Balik 2^n modulo p (mahibalo sa numerics).--  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =","canonical_solution":"modp :: Int -> Int -> Int\nmodp n p = powMod 2 n p\n\npowMod :: Int -> Int -> Int -> Int\npowMod base exp modulus\n  | modulus == 1 = 0\n  | exp == 0     = 1\n  | exp == 1     = base `mod` modulus\n  | otherwise    = if odd exp\n                   then (base * halfExp * halfExp) `mod` modulus\n                   else (halfExp * halfExp) `mod` modulus\n  where\n    halfExp = powMod base (exp `div` 2) modulus","tests":"\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_51","nl":"ceb_Latn","pl":"hs","prompt":"-- remove_vowels mao ang usa ka function nga nagkuha string ug mobalik string nga walay mga vowels. --  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =","canonical_solution":"removeVowels :: String -> String\nremoveVowels text = filter (`notElem` \"aeiouAEIOU\") text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_52","nl":"ceb_Latn","pl":"hs","prompt":"--│ Ibalik ang Tinuod kon ang tanang numero sa listahan l ubos sa threshold t. │--  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =","canonical_solution":"belowThreshold l t = all (< t) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_53","nl":"ceb_Latn","pl":"hs","prompt":"--Pag-add sa duha ka numero x ug y.--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =","canonical_solution":"add :: Int -> Int -> Int\nadd x y = x + y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_54","nl":"ceb_Latn","pl":"hs","prompt":"--Susiha kon ang duha ka pulong adunay samang mga karakter.--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =","canonical_solution":"import Data.List (nub, sort)\n\nsameChars :: String -> String -> Bool\nsameChars s0 s1 = sort (nub s0) == sort (nub s1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_55","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang n-th Fibonacci number.--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =","canonical_solution":"fib :: Int -> Int\nfib n = fibHelper 0 1 n\n  where\n    fibHelper a _ 0 = a\n    fibHelper a b n = fibHelper b (a + b) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_56","nl":"ceb_Latn","pl":"hs","prompt":"--return True kon ang matag pag-abli nga bracket adunay katumbas nga pagsira nga bracket. --Ang mga parentes usa ka string sa \"<\" ug \">\".--  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBrackets brackets 0 == 0\n\ncheckBrackets :: String -> Int -> Int\ncheckBrackets [] n = n\ncheckBrackets (x:xs) n\n  | n < 0 = -1\n  | x == '<' = checkBrackets xs (n + 1)\n  | x == '>' = checkBrackets xs (n - 1)\n  | otherwise = checkBrackets xs n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_57","nl":"ceb_Latn","pl":"hs","prompt":"--│ Return True mao ang listahan elemento nga monotonically pagdugang o pagkunhod. │--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =","canonical_solution":"monotonic :: [Int] -> Bool\nmonotonic l = increasing l || decreasing l\n  where\n    increasing xs = all (uncurry (<=)) (zip xs (tail xs))\n    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_58","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang mga nagkalainlain nga komon nga mga elemento alang sa duha ka lista.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =","canonical_solution":"common :: [Int] -> [Int] -> [Int]\ncommon l1 l2 = uniqueSortedCommon\n  where\n    commonElements = filter (`elem` l2) l1\n    uniqueCommon = removeDuplicates commonElements\n    uniqueSortedCommon = sort uniqueCommon\n\n    removeDuplicates :: [Int] -> [Int]\n    removeDuplicates = foldr (\\x seen -> if x `elem` seen then seen else x : seen) []\n\n    sort :: [Int] -> [Int]\n    sort [] = []\n    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)\n      where\n        lesser  = filter (< p) xs\n        greater = filter (>= p) xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_59","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang kinadak-ang primerong factor sa n. Ibutang nga n > 1 ug dili usa ka primerong numero.--  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =","canonical_solution":"largestPrimeFactor :: Int -> Int\nlargestPrimeFactor n = helper n 2\n  where\n    helper n factor\n      | factor * factor > n = n\n      | n `mod` factor == 0 = helper (n `div` factor) factor\n      | otherwise = helper n (factor + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_60","nl":"ceb_Latn","pl":"hs","prompt":"--Ang sum_to_n maoy usa ka function nga nag-sum sa mga numero gikan sa 1 ngadto sa n.--  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =","canonical_solution":"sumToN :: Int -> Int\nsumToN n = sum [1..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_61","nl":"ceb_Latn","pl":"hs","prompt":"--return True kon ang matag pag-abli nga bracket adunay katumbas nga pagsira nga bracket. --│ brackets mao ang usa ka string sa \"(\" ug \"\". │--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBalance brackets 0\n  where\n    checkBalance [] 0 = True\n    checkBalance [] _ = False\n    checkBalance (x:xs) n\n      | x == '('  = checkBalance xs (n + 1)\n      | x == ')' && n > 0 = checkBalance xs (n - 1)\n      | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_62","nl":"ceb_Latn","pl":"hs","prompt":"--Balik derivative niini nga polynomial sa sama nga porma. --xs[0] + xs[1] * x + xs[2] * x^2 + .... -- xs nagrepresentar sa mga coefficient sa polynomial. --  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =","canonical_solution":"derivative :: [Int] -> [Int]\nderivative xs = zipWith (*) (tail xs) [1..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_63","nl":"ceb_Latn","pl":"hs","prompt":"--Palihog pagsulat ug function aron sa pag-eksperiensya sa n-th nga elemento sa sunod-sunod nga numero sa fibfib. --fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). --fibfib(2) == 1 --fibfib(1) == 0 --fibfib(0) == 0 --Ang sunodsunod nga FibFib numero mao ang usa ka sunodsunod nga susama sa Fibbonacci sunodsunod nga gihubit sa mosunod: --  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =","canonical_solution":"fibfib :: Int -> Int\nfibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibs !! n\n  where\n    fibs = 0 : 0 : 1 : zipWith3 (\\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_64","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --bokal, apan kon kini anaa sa kataposan sa gihatagan nga pulong lamang. --Ang mga bokal niining kasoha mao ang 'a', 'e', 'i', 'o', 'u'. Dinhi, ang 'y' maoy usa usab ka --usa ka pulong ingon nga input ug mobalik sa gidaghanon sa mga bokal sa string. --◯ Pagsulat sa usa ka function nga vowels_count nga nagdala og usa ka string nga nagrepresentar sa ◯--  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =","canonical_solution":"vowelsCount :: String -> Int\nvowelsCount s = length $ filter isVowel $ zip s [1..]\n  where\n    isVowel (c, pos) =\n      let lowercaseC = toLower c\n          isRegularVowel = lowercaseC `elem` \"aeiou\"\n          isLastCharY = lowercaseC == 'y' && pos == length s\n      in isRegularVowel || isLastCharY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_65","nl":"ceb_Latn","pl":"hs","prompt":"--Kon shift > gidaghanon sa mga digit, balik digit balik. --ug iuli ang resulta isip usa ka string. -- Ang sirkular nga pag-ilis sa mga numero sa integer nga x, pag-ilis sa mga numero ngadto sa tuo pinaagi sa pag-ilis --  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =","canonical_solution":"circularShift :: Int -> Int -> String\ncircularShift x shift =\n  let digits = show x\n      len = length digits\n      effectiveShift = shift `mod` len\n  in if shift > len\n     then reverse digits\n     else let (begin, end) = splitAt (len - effectiveShift) digits\n          in end ++ begin","tests":"\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_66","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Mga ASCII nga kodigo. --Pagsulat sa usa ka function nga nagkuha sa usa ka string ingon nga input ug mobalik sa kantidad sa ibabaw nga mga karakter lamang' --Tugas.--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =","canonical_solution":"digitsum :: String -> Int\ndigitsum s = sum $ map fromEnum $ filter isUpper s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_67","nl":"ceb_Latn","pl":"hs","prompt":"--alang sa examble: --sa basket iuli ang gidaghanon sa mga prutas sa mangga sa basket. --mga kahel ug mansanas ug usa ka integer nga nagrepresentar sa kinatibuk-ang gidaghanon sa mga prutas --Ang mga mansanas, mga kahel, ug mga prutas sa mangga.--nga gibahin diha sa usa ka basket nga may bunga nga anaa sa maong basket --Sa kini nga buluhaton, ikaw hatagan og usa ka string nga nagrepresentar sa gidaghanon sa mga mansanas ug mga kahel.--  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =","canonical_solution":"import Text.Read (readMaybe)\n\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n = n - totalApplesOranges\n  where\n    totalApplesOranges = sum $ map (readNumber . words) [\"apples\", \"oranges\"]\n    readNumber keyword = case dropWhile (not . (==\" \") . dropWhile (\/=' ')) $ words s of\n      [] -> 0\n      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_68","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan 1: --Kon walay bisan mga bili o ang gihatag nga listahan mao ang walay sulod, pagbalik []. --Ang gikuha nga node kinahanglan nga ibalik sa usa ka listahan, [ smalest_value, ang iyang index ], --Kon daghang mga nodes uban sa sama nga kinagamyan bisan bili ang nakaplagan pagbalik sa nodes nga adunay kinagamyan nga index. --Ang giputol nga node kinahanglang mao ang node nga may kinagamyang bisan nga bili.--ang imong buluhaton mao ang pagkuhag usa sa mga nodyo ug ibalik kini.--\"Gipasa ang usa ka listahan nga nagrepresentar sa usa ka sanga sa usa ka kahoy nga adunay dili-negatibo integer nodes --  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =","canonical_solution":"pluck :: [Int] -> [Int]\npluck arr = case filter (\\(x, _) -> even x) (zip arr [0..]) of\n    [] -> []\n    evens -> let (value, index) = minimum evens in [value, index]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_69","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Kon walay ingon nga bili anaa, pagbalik -1. --Ang kasubsob sa usa ka integer mao ang gidaghanon sa mga higayon nga kini makita diha sa listahan. --zero, ug adunay kasubsob nga mas dako o katumbas sa bili sa integer mismo. --Ikaw gihatag sa usa ka dili-walay sulod nga listahan sa positibo nga integers. Ibalik ang kinadak-ang integer nga mas dako kay sa --  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nsearch :: [Int] -> Int\nsearch lst = \n    let frequencies = map (\\g -> (head g, length g)) . group . sort $ lst\n        candidates = filter (\\(val, freq) -> freq >= val) frequencies\n    in case candidates of\n         [] -> -1\n         _  -> fst . maximum $ candidates","tests":"\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_70","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --unya maximum sa nahibilin nga integers, unya minimum ug sa ingon sa. --Ang katingad-an nga pag-ilis, mao kon ikaw magsugod uban sa labing ubos nga bili, --◯ Gihatagan lista sa mga integer, pagbalik lista sa talagsaon nga pagkasunudsunod.--  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =","canonical_solution":"strangeSortList :: [Int] -> [Int]\nstrangeSortList [] = []\nstrangeSortList lst = go (sort lst) True\n  where\n    go [] _ = []\n    go xs toggle\n      | toggle    = head xs : go (tail xs) False\n      | otherwise = last xs : go (init xs) True","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_71","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --kay sa ikatulong bahin.--Ang tulo ka kilid maoy usa ka triyanggo kon ang kantidad sa duha ka kilid mas dako.--Kon dili, ibalik ang -1 --ang trianggulo nga gipurong ngadto sa 2 ka decimal nga mga punto kon ang tulo ka kilid maoy usa ka balido nga trianggulo. --Gitan-aw ang gitas-on sa tulo ka kilid sa usa ka trianggulo, balikon ang lapad sa --  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =","canonical_solution":"import Text.Printf (printf)\n\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c\n    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))\n    | otherwise = -1\n  where\n    s = (fromIntegral (a + b + c)) \/ 2\n    isValidTriangle x y z = x + y > z && x + z > y && y + z > x\n    roundToTwoDecimals x = read (printf \"%.2f\" x) :: Float","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_72","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Ang butang q molupad kon kini balanse (kini usa ka palindromic nga listahan) ug ang kantidad sa mga elemento niini mas ubos o katumbas sa maximum nga posible nga gibug-aton w.--❑ Pagsulat og function nga mobalik sa Tinuod kon ang butang q molupad, ug Palso kon dili.--  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =","canonical_solution":"willItFly :: [Int] -> Int -> Bool\nwillItFly q w = isPalindrome q && sum q <= w\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome xs = xs == reverse xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_73","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --sa usa ka pagbag-o, imong mausab ang usa ka elemento ngadto sa bisan unsang laing elemento. --kinahanglan nga mausab aron ang listahan palindromic. Usa ka palindromic listahan mao ang usa ka listahan nga --Gipasagdan sa usa ka listahan arr sa integers, pagpangita sa labing gamay nga gidaghanon sa mga elemento nga --  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =","canonical_solution":"smallestChange :: [Int] -> Int\nsmallestChange arr = sum $ zipWith (\\x y -> if x \/= y then 1 else 0) arr (reverse arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_74","nl":"ceb_Latn","pl":"hs","prompt":"--Mga Ehemplo --kon ang duha ka listahan adunay samang gidaghanon sa mga character, ibalik ang unang listahan. --total nga gidaghanon sa mga chars sa tanan nga mga string sa listahan nga mas ubos kay sa ubang listahan. --❑ Pagsulat sa usa ka function nga modawat sa duha ka listahan sa mga string ug mobalik sa listahan nga adunay --  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =","canonical_solution":"totalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2\n  | totalChars lst1 < totalChars lst2 = lst1\n  | totalChars lst1 > totalChars lst2 = lst2\n  | otherwise = lst1\n  where\n    totalChars = sum . map length","tests":"\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_75","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Kon nahibaloan nga ang (a) mas gamay kay sa 100. --ug bakak kon dili. --❑ Pagsulat og usa ka function nga mobalik sa tinuod kon ang gihatag nga numero mao ang multiplikasyon sa 3 nga mga numero primo.--  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =","canonical_solution":"isMultiplyPrime :: Int -> Bool\nisMultiplyPrime a = any isTriplePrimeProduct primeTriples\n  where\n    primes = filter isPrime [2..99]\n    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]\n    isTriplePrimeProduct (x, y, z) = x * y * z == a\n\nisPrime :: Int -> Bool\nisPrime n \n  | n < 2     = False\n  | otherwise = not (any (\\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_76","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --x maoy usa ka simple nga gahum sa n kon n**int=x --gahum sa n ug bakak sa ubang mga kaso. --Ang imong buluhaton mao ang pagsulat sa usa ka function nga mobalik tinuod kon ang usa ka gidaghanon x mao ang usa ka yano nga.--  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =","canonical_solution":"isSimplePower :: Int -> Int -> Bool\nisSimplePower x n\n  | x < 1 || n < 1 = False\n  | n == 1 = x == 1\n  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_77","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Hinumdomi: imong madahom nga ang input kanunayng balido. --kon kini nga ingeger usa ka kubo sa pipila ka integer nga numero. --❑ Pagsulat og usa ka function nga nagkuha og usa ka integer ug mobalik sa Tinuod ❑--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =","canonical_solution":"iscube :: Int -> Bool\niscube a = let n = round (fromIntegral a ** (1\/3)) in n^3 == a","tests":"\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_78","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --ug ang mga simbolo nga A,B,C,D,E,F kanunayng dagko nga letra. --Hinumdomi: imong mahimo sa paghunahuna sa input mao ang kanunay nga husto o walay sulod nga string, --B (= decimal 11), D (= decimal 13). --Busa kinahanglan nimong tukion ang usa ka gidaghanon sa mosunod nga mga digit: 2, 3, 5, 7, --Ang mga prime number mao ang 2, 3, 5, 7, 11, 13, 17,... --Ang hexadecimal nga mga numero mao ang 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. --mas dako kay sa 1 nga dili produkto sa duha ka mas gamay nga natural nga mga numero).--mga digit nga mga numero nga primo (ang numero nga primo, o usa ka numero nga primo, maoy natural nga numero --usa ka hexadecimal numero ingon nga usa ka string ug ihap sa gidaghanon sa hexadecimal --Ikaw gisugo sa pagsulat sa usa ka function nga modawat sa.--  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =","canonical_solution":"hexKey :: String -> Int\nhexKey num = length . filter (`elem` primeHexDigits) $ num\n  where\n    primeHexDigits = \"2357BD\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_79","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Ang dugang mga karakter anaa aron makatabang sa pormat. --Adunay usa ka dugang nga pares sa mga karakter 'db' sa sinugdanan ug sa katapusan sa string. --Ang matag karakter sa string mahimong '0' o '1'.--binary format. Ang function kinahanglan nga mobalik sa usa ka string, uban sa matag karakter nga nagrepresentar sa usa ka binary --◯ Hatagan ka ug numero sa porma sa decimal ug ang imong buluhaton mao ang pag-convert niini ngadto sa ◯--  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =","canonical_solution":"decimalToBinary :: Int -> String\ndecimalToBinary decimal = \"db\" ++ toBinary decimal ++ \"db\"\n  where\n    toBinary 0 = \"0\"\n    toBinary n = reverse (binaryHelper n)\n\n    binaryHelper 0 = \"\"\n    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_80","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Ang usa ka string maoy haphs kon ang gitas-on niini labing menos 3 ug matag 3 ka sunodsunod nga mga letra lahi --Ang imong buluhaton mao ang pagsusi kon ang string haphs o dili.--Ikaw gihatag sa usa ka string s. --  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =","canonical_solution":"isHappy :: String -> Bool\nisHappy s\n  | length s < 3 = False\n  | otherwise = all distinctTriples (windows 3 s)\n  where\n    distinctTriples [x, y, z] = x \/= y && y \/= z && x \/= z\n    distinctTriples _ = False\n    windows n xs\n      | length xs < n = []\n      | otherwise = take n xs : windows n (tail xs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_81","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --0.0 E --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 B+ --> 3.3 A- --> 3.7 A --4.0 A+ --GPA. Gredyo sa letra.--usa ka function nga mahimong mag-output sa usa ka listahan sa mga grado sa letra nga gigamit ang mosunod nga talaan: --Siya naghatag kanimo ug listahan sa GPA sa pipila ka estudyante ug kinahanglan nimong isulat kini.--Ang suliran mao nga nawad-an siya sa kodigo nga iyang gigamit sa paggradwar.--Ang magtutudlo naghimo sa iyang kaugalingong algoritmo sa paggradwar. --Kini mao ang katapusan nga semana sa semestre ug ang magtutudlo kinahanglan nga mohatag sa mga grado.--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =","canonical_solution":"numericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades = map gpaToLetterGrade grades\n  where\n    gpaToLetterGrade gpa\n      | gpa == 4.0 = \"A+\"\n      | gpa > 3.7  = \"A\"\n      | gpa > 3.3  = \"A-\"\n      | gpa > 3.0  = \"B+\"\n      | gpa > 2.7  = \"B\"\n      | gpa > 2.3  = \"B-\"\n      | gpa > 2.0  = \"C+\"\n      | gpa > 1.7  = \"C\"\n      | gpa > 1.3  = \"C-\"\n      | gpa > 1.0  = \"D+\"\n      | gpa > 0.7  = \"D\"\n      | gpa > 0.0  = \"D-\"\n      | otherwise  = \"E\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_82","nl":"ceb_Latn","pl":"hs","prompt":"--Mga Ehemplo --ang gitas-on maoy usa ka numero nga primo o False kon dili --❑ Pagsulat og function nga magkuha ug string ug mobalik ug True kon ang string ❑--  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =","canonical_solution":"primeLength :: String -> Bool\nprimeLength string = isPrime (length string)\n\nisPrime :: Int -> Bool\nisPrime n\n  | n < 2     = False\n  | n == 2    = True\n  | even n    = False\n  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_83","nl":"ceb_Latn","pl":"hs","prompt":"--positibo nga mga integer nga magsugod o matapos sa 1. --❑ Gipasudlan og positibo nga integer nga n, ibalik ang ihap sa mga numero nga n-digit ❑startsOneEnds :: Int -> Int\nstartsOneEnds n =","canonical_solution":"startsOneEnds :: Int -> Int\nstartsOneEnds n\n  | n <= 0    = 0\n  | n == 1    = 1\n  | otherwise = 18 * 10^(n-2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_84","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan --DATA A positive integer N, Ibalik ang kinatibuk-ang kantidad sa mga digit niini sa binary. --  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 ≤ N ≤ 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =","canonical_solution":"solve :: Int -> String\nsolve N = toBinary (sumOfDigits N)\n  where\n    sumOfDigits 0 = 0\n    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)\n\n    toBinary 0 = \"0\"\n    toBinary n = reverse (toBinary' n)\n      where\n        toBinary' 0 = \"\"\n        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_85","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Gipasagdan sa usa ka dili-walay sulod nga listahan sa mga integer una. pag-add sa bisan nga mga elemento nga anaa sa mga indices nga dili-tambok .. --  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =","canonical_solution":"add :: [Int] -> Int\nadd lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_86","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Hinumdomi: Kinahanglan nimong sundon ang pagkasunodsunod sa mga pulong ug mga wanang sa mga pulong sa mga pulong. --nag-uswag nga pagkasunodsunod base sa ascii value. --gipulihan sa usa ka bag-ong pulong diin ang tanang karakter gihan-ay sa --Ang gi-order nga bersyon sa string, mao ang usa ka string diin ang tanan nga mga pulong (gibulag pinaagi sa wanang) --❑ Pagsulat og function nga magkuha ug string ug magbalik ug ordered nga bersyon niini.--  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =","canonical_solution":"import Data.List (sort)\nimport Data.Char (isAlpha)\n\nantiShuffle :: String -> String\nantiShuffle s = unwords $ map sortWord (wordsAndSpaces s)\n  where\n    sortWord word = if all isAlpha word then sort word else word\n    wordsAndSpaces [] = []\n    wordsAndSpaces xs = if head xs == ' ' \n                        then \" \" : wordsAndSpaces (dropWhile (== ' ') xs)\n                        else let (word, rest) = break (== ' ') xs\n                             in word : wordsAndSpaces rest","tests":"\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_87","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Dugang pa, sortaha ang mga koordinada sa han-ay pinaagi sa mga haligi sa nag-anam-anam nga pagkasunodsunod. --Pag-order sa mga koordinada sa sinugdan pinaagi sa mga linya nga nagakauswag. --matag tuple mao ang usa ka coordinate - (linya, mga kolum), sugod sa 0. --ug pagbalik listahan sa mga tuples, [(x1, y1), (x2, y2) ...] ingon nga --Gipasagdan lst, ug integer x, pangitaon integer x sa listahan, --ang matag laray mahimong maglakip ug lainlaing gidaghanon sa mga haligi. --nga susama sa matrix, apan dili sama sa mga matrix, --❑ Gihatagan ka ug 2 dimensional nga datos, ingon nga mga lista nga gi-nest, ❑--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =","canonical_solution":"getRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x = concatMap processRow (zip [0..] lst)\n  where\n    processRow (rowIndex, row) = \n      let colIndices = reverse $ findIndices (== x) row\n      in [(rowIndex, colIndex) | colIndex <- colIndices]\n\nfindIndices :: (a -> Bool) -> [a] -> [Int]\nfindIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_88","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --* ayaw usba ang gihatag nga listahan. --Panid: --o i-sort kini sa nag-us-os nga pagkasunodsunod kon ang kantidad ((unang bili sa indeks, kataposang bili sa indeks) par. --imong sortahon ang gihatag nga listahan sa nagatungas nga pagkasunudsunod kon ang kantidad ((unang bili sa indeks, kataposang bili sa indeks) maoy dili-parehas, --☐ Gihatagan usa ka listahan sa mga non-negatibo integers, mobalik sa usa ka cohs sa gihatag nga listahan human sa pag-sort, ☐--  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =","canonical_solution":"sortArray :: [Int] -> [Int]\nsortArray array\n  | null array = array\n  | otherwise =\n    let first = head array\n        last = last array\n        sumFirstLast = first + last\n    in if odd sumFirstLast\n       then sort array\n       else reverse (sort array)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_89","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --pag-ilis sa ubos sa duha ka pilo ngadto sa duha ka dapit. --Ang alpabeto kinahanglang i-rotate sa paagi nga ang mga letra --mobalik sa usa ka string encrypted uban sa alpabeto nga giliwat. --◯ Paghimo og usa ka encrypt function nga magdala og usa ka string isip argumento ug ◯--  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =","canonical_solution":"encrypt :: String -> String\nencrypt s = map shiftChar s\n  where\n    shiftChar c\n      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')\n      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_90","nl":"ceb_Latn","pl":"hs","prompt":"--Ibalik ang Wala kon wala kana nga elemento. --Isulat ang usa ka function nga next_smallest (() nga mobalik sa ika-2 nga kinagamyan nga elemento sa listahan. --◯ Gihatagan ka og lista sa mga integer.--  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =","canonical_solution":"nextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =\n  let uniqueSorted = removeDuplicates $ quicksort lst\n  in if length uniqueSorted < 2\n     then Nothing\n     else Just (uniqueSorted !! 1)\n\nremoveDuplicates :: (Ord a) => [a] -> [a]\nremoveDuplicates = foldr (\\x acc -> if x `elem` acc then acc else x : acc) []\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_91","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Ang mga pulong gilain sa '.', '?' o '!'. --Ang kalisod maoy usa ka pulong nga nagsugod sa pulong \"Ako\".--◯ Hatagan ka ug mga pulong, ug ang imong buluhaton mao ang pag-ihap sa gidaghanon ◯--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =","canonical_solution":"isBored :: String -> Int\nisBored s = length $ filter (startsWithI . words) $ splitSentences s\n  where\n    splitSentences :: String -> [String]\n    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters \".?!\"\n    \n    splitOnDelimiters :: String -> String -> [String]\n    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of\n      \"\" -> []\n      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''\n    \n    startsWithI :: [String] -> Bool\n    startsWithI [] = False\n    startsWithI (x:_) = map toLower x == \"i\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_92","nl":"ceb_Latn","pl":"hs","prompt":"--Mga Ehemplo --Magbalik ug bakak sa ubang mga kaso. --Magbalik ug tinuod kon ang usa sa mga numero mao ang katumbas sa duha ka uban pa, ug ang tanan nga mga numero mao ang mga integer. --Paghimo og usa ka function nga nagkinahanglan og 3 ka numero.--  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =","canonical_solution":"anyInt :: Float -> Float -> Float -> Bool\nanyInt x y z\n  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =\n      x == y + z || y == x + z || z == x + y\n  | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_93","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Pagdahom nga mga letra lamang. --bokal sa Iningles nga alpabeto. --ang mensahe nga may letra nga makita 2 ka dapit sa unahan niana --paagi nga kini swaps kaso sa tanan nga mga letra, nagpuli sa tanan nga mga bokal sa --◯ Pagsulat og usa ka function nga magkuha og mensahe, ug mag-encode niini sa ingon nga ◯--  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =","canonical_solution":"encode :: String -> String\nencode = map transformChar\n  where\n    transformChar :: Char -> Char\n    transformChar c\n      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c\n      | otherwise      = swapCase c c\n      where\n        lowerC = toLower c\n\n    isVowel :: Char -> Bool\n    isVowel c = c `elem` \"aeiou\"\n\n    swapCase :: Char -> Char -> Char\n    swapCase origC c\n      | isUpper origC = toLower c\n      | otherwise     = toUpper c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_94","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Kinahanglan nimo nga pangitaon ang kinadak-ang prima nga kantidad ug ibalik ang kantidad sa mga numero niini.--◯ Gihatagan ka og lista sa mga integer.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =","canonical_solution":"skjkasdkd :: [Int] -> Int\nskjkasdkd lst = sumDigits (largestPrime lst)\n\n-- Function to check if a number is prime\nisPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]\n\n-- Integer square root using binary search, O(log n)\nisqrt :: Int -> Int\nisqrt n = floor . sqrt $ fromIntegral n\n\n-- Function to find the largest prime in the list\nlargestPrime :: [Int] -> Int\nlargestPrime = foldr (\\x acc -> if isPrime x && x > acc then x else acc) 0\n\n-- Function to calculate the sum of the digits of a number\nsumDigits :: Int -> Int\nsumDigits 0 = 0\nsumDigits n = n `mod` 10 + sumDigits (n `div` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_95","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Ang function kinahanglan nga mobalik sa bakak mao ang gihatag nga listahan sa asosasyon mao ang walay sulod. --case o ang tanan nga mga yawe mao ang mga string sa upper case, otherwise return False. --◯ Gipasagdan sa usa ka listahan sa mga kapunongan, pagbalik Tinuod kon ang tanan nga mga yawe mao ang mga pisi sa ubos ◯--  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =","canonical_solution":"import Data.Char (isUpper, isLower)\n\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase [] = False\ncheckDictCase dict = all isLower allKeys || all isUpper allKeys\n  where\n    allKeys = concatMap fst dict","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_96","nl":"ceb_Latn","pl":"hs","prompt":"--pananglitan: --mga integer nga mga numero primo ug mas gamay kay sa n. --❑ Paghimo og function nga magkuha og non-negative integer ug mobalik sa listahan sa unang n --  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =","canonical_solution":"countUpTo :: Int -> [Int]\ncountUpTo n = filter isPrime [2..n-1]\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_97","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Ibutang nga ang input kanunayng balido. --ang produkto sa ilang mga numero sa yunit. --Pagkompleto sa function nga nagkuha og duha ka integer ug mobalik sa --  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =","canonical_solution":"multiply :: Int -> Int -> Int\nmultiply a b = (abs a `mod` 10) * (abs b `mod` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_98","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --◯ Sa string nga s, ihap ang gidaghanon sa dagkong mga bokal nga may par nga mga indise. ◯--  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =","canonical_solution":"countUpper :: String -> Int\ncountUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` \"AEIOU\"]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_99","nl":"ceb_Latn","pl":"hs","prompt":"--Mga Ehemplo --gikan sa duha ka integer, pa-aboton kini gikan sa zero.--ug mobalik sa labing duol nga integer niini. Kon ang gidaghanon mao ang equidistant --◯ Paghimo og usa ka function nga magkuha og usa ka kantidad (string) nga nagrepresentar sa usa ka numero --  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =","canonical_solution":"closestInteger :: String -> Int\nclosestInteger value = \n  let n = read value :: Double\n  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_100","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --i nagrepresentar sa gidaghanon sa mga bato sa lebel (i+1). --Ibalik ang gidaghanon sa mga bato sa matag ang-ang sa usa ka listahan, diin elemento sa index --- ang sunod nga pares nga numero kon ang n pares. --- ang sunod nga numero nga dili parisan kon n maoy parisan. --Ang gidaghanon sa mga bato sa sunod nga lebel mao ang: --Ang unang lebel dunay n ka bato. --◯ Tungod kay adunay positibo nga integer nga n, kinahanglan nimong himoon ang usa ka pundok nga n ka lebel sa mga bato. ◯--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =","canonical_solution":"makeAPile :: Int -> [Int]\nmakeAPile n = take n [n, n + 2 ..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_101","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --sa pagbulag sa mga pulong ug sa pagbalik sa usa ka listahan sa mga pulong. --◯ Hatagan ka ug mga pulong nga gibulag sa mga comma o mga luna.--  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =","canonical_solution":"wordsString :: String -> [String]\nwordsString s = words $ map (\\c -> if c == ',' then ' ' else c) s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_102","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --walay ingon nga numero, unya ang function kinahanglan nga mobalik -1. --labing dako nga bisan integer numero nga anaa sa range [x, y] lakip na.--Kini nga function nagkuha og duha ka positibo nga numero x ug y ug mibalik sa --  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =","canonical_solution":"chooseNum :: Int -> Int -> Int\nchooseNum x y\n    | x > y = -1\n    | even upperBound = upperBound\n    | even (upperBound - 1) = upperBound - 1\n    | otherwise = -1\n  where\n    upperBound = max x y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_104","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Hinumdomi: Ang gibalik nga listahan kinahanglang i-sort nga nagkadaghan.--mga elemento nga walay bisan usa ka numero.--◯ Gihatagan usa ka listahan sa positibo nga integers x. pagbalik sa usa ka gi-sort nga listahan sa tanan ◯--  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =","canonical_solution":"uniqueDigits :: [Int] -> [Int]\nuniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_105","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --\"Usa\", \"Duha\", \"Tulo\", \"Upat\", \"Lima\", \"Unom\", \"Pito\", \"Walo\", \"Usa\". --balikon ang resulta nga listahan, ug dayon pulihan ang matag digit sa katumbas nga ngalan gikan sa --◯ Gipasagdan sa usa ka listahan sa mga integer, sorta ang mga integer nga anaa sa taliwala sa 1 ug 9 lakip na, ◯--  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the list is empty, return an empty list:\n--  >>> byLength []\n--  []\n--  If the list has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =","canonical_solution":"byLength :: [Int] -> [String]\nbyLength arr = map digitName . reverse . sort . filter isValid $ arr\n  where\n    isValid x = x >= 1 && x <= 9\n    digitName x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"\n      _ -> error \"Unexpected number\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_106","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --ang factorial sa i mao ang pag-ampon sa mga numero gikan sa 1 ngadto sa i (1 * 2 * ... * i).--i sugod sa 1. --o ang kantidad sa mga numero gikan sa 1 ngadto sa i kon dili. --ug mobalik sa usa ka listahan sa gidak-on n, nga ang bili sa elemento sa index i mao ang factorial sa i kon i mao ang bisan -- Pagpatuman sa function f nga nagkuha sa n isip parameter, --  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =","canonical_solution":"f :: Int -> [Int]\nf n = map g [1..n]\n  where\n    g i\n      | even i    = factorial i\n      | otherwise = sum [1..i]\n    \n    factorial 0 = 1\n    factorial m = product [1..m]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_107","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan 1: --integer palindromes nga mahulog sa sulod sa range ((1, n), inclusive. --❑ Gipasudlan sa usa ka positibo nga integer n, mobalik sa usa ka tuple nga adunay gidaghanon sa bisan ug talagsaon ❑--  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =","canonical_solution":"evenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n = (length evens, length odds)\n  where\n    isPalindrome x = show x == reverse (show x)\n    palindromes = filter isPalindrome [1..n]\n    evens = filter even palindromes\n    odds  = filter odd palindromes","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_108","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan, ang -123 may mga numero nga -1, 2, ug 3. --Kon negatibo ang usa ka numero, ang unang sinulat nga digit niini negatibo: --ang gidaghanon sa mga elemento nga adunay sum sa mga digit > 0. --❑ Pagsulat sa usa ka function count_nums nga nagkuha sa usa ka listahan sa mga integer ug mibalik ❑--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =","canonical_solution":"countNums :: [Int] -> Int\ncountNums arr = length $ filter ((> 0) . sumDigits) arr\n  where\n    sumDigits 0 = 0\n    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)\n                  in sum digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_109","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Hinumdomi: Ang gihatag nga listahan garantiya nga adunay talagsaon nga mga elemento. --Kon ang gihatag nga listahan mao ang walay sulod unya pagbalik Tinuod. --unya mobalik True o mobalik False. --Kon kini posible nga makuha ang gihan-ay nga listahan pinaagi sa paghimo sa ibabaw nga operasyon --ang sinugdanan nga posisyon sa listahan nga mao ang ika-0 nga indeks. --Ang kataposang elemento sa listahan ibalhin ngadto sa --Ang usa ka right shift operation nagpasabot sa pag-ilis sa tanang elemento sa listahan sa usa ka .--Ikaw gitugotan sa paghimo sa husto nga pag-ilis operasyon bisan unsang gidaghanon sa mga panahon. --ang mosunod nga operasyon sa gihatag nga listahan: --posible nga makuha ang usa ka listahan nga gihan-ay sa dili-nagkadaghan nga kahusay pinaagi sa paghimo sa --Ang mga numero sa listahan i-order nga walay tuyo.--Kita adunay usa ka listahan 'arr' sa N integers arr[1], arr[2], ..., arr[N].Ang --  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given list.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  list by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =","canonical_solution":"moveOneBall :: [Int] -> Bool\nmoveOneBall [] = True\nmoveOneBall arr = canBeSorted (arr ++ arr)\n  where\n    n = length arr\n    canBeSorted xs = any isSorted (take n <$> tails xs)\n    isSorted ys = and $ zipWith (<=) ys (tail ys)\n    tails [] = []\n    tails l@(_:xs) = l : tails xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_110","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Kon dili, balikon ang \"Dili\". --ang tanan nga mga elemento sa lst1 nga bisan, mobalik \"YES\". --Kon posible nga magbayloay ug mga elemento tali sa lst1 ug lst2 aron sa paghimo ug --Walay limitasyon sa gidaghanon sa mga elemento nga gibaylohan tali sa lst1 ug lst2. --sa taliwala nila aron himoon ang lista nga may mga numero nga par. --ug nag-agad kon posible ba nga maghimog pagbayloay sa mga elemento --Sa niini nga problema, kamo sa pagpatuman sa usa ka function nga nagkinahanglan sa duha ka mga listahan sa mga numero, --  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =","canonical_solution":"exchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | all even lst1 = \"YES\"\n  | null oddLst1 || null evenLst2 = \"NO\"\n  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)\n                in if possibility then \"YES\" else \"NO\"\n  where\n    oddLst1 = filter odd lst1\n    evenLst2 = filter even lst2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_111","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Kon daghang letra ang parehas nga nahitabo, ibalik ang tanan. --sa sulat nga adunay labing pag-usab ug naglangkob sa katumbas nga gidaghanon. --◯ Gipasagdan sa usa ka string nga nagrepresentar sa usa ka luna gibulag nga mga letra nga gamay, mobalik sa usa ka listahan sa asosasyon ◯--  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nhistogram :: String -> [(String, Int)]\nhistogram input =\n  let wordsList = words input\n      grouped = group $ sort wordsList\n      countList = map (\\ws -> (head ws, length ws)) grouped\n      maxCount = if null countList then 0 else maximum $ map snd countList\n  in filter ((== maxCount) . snd) countList","tests":"\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_112","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan --Ikaw kinahanglan nga mobalik sa usa ka tuple nga naglangkob sa resulta string ug Tinuod\/Pagkalimbong alang sa check. --Ang usa ka string gitawag ug palindrome kon kini mabasa sa samang paagi sa unahan ug sa likod. --unya susihon kon ang resulta nga string mao ang palindrome. --Kita gihatag sa duha ka mga linya s ug c, kamo adunay sa delete sa tanan nga mga karakter sa s nga mao ang sama sa bisan unsa nga karakter sa c --Tugas.--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =","canonical_solution":"import Data.List (filter)\n\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =\n  let result = filter (`notElem` c) s\n  in (result, result == reverse result)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_113","nl":"ceb_Latn","pl":"hs","prompt":"--sa mga dili-parehas nga mga numero sa i'th string sa input. --string i sa input. \" diin ang tanan nga mga i kinahanglan nga pulihan sa numero --Ang matag elemento i sa output kinahanglan nga \"ang gidaghanon sa mga elemento nga dili parisan sa --DATA A LIST OF STRINGS, diin ang matag string naglangkob lamang sa mga digit, Ibalik ang usa ka lista.--  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =","canonical_solution":"oddCount :: [String] -> [String]\noddCount lst = map formatString lst\n  where\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"\n\n    countOdds :: String -> Int\n    countOdds str = length $ filter isOddDigit str\n\n    formatString :: String -> String\n    formatString str =\n      let oddCount = countOdds str in\n      \"the number of odd elements \" ++ show oddCount ++ \n      \"n the str\" ++ show oddCount ++ \"ng \" ++ show oddCount ++\n      \" of the \" ++ show oddCount ++ \"nput.\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_114","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan --sa mga numero. --Gipasagdan sa usa ka listahan sa mga integer n, pangitaa ang labing gamay nga kantidad sa bisan unsa nga dili-walay sulod nga sub-lista.--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =","canonical_solution":"minsubarraysum :: [Int] -> Int\nminsubarraysum nums = minimum $ scanl1 (\\acc x -> min x (acc + x)) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_115","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan 1: --Ibutang ang gidaghanon sa mga higayon nga imong gikinahanglan sa pag-ubos sa mga balde. --Ang imong buluhaton mao ang paggamit sa mga balde sa pag-ibulhog sa mga atabay. --ug ang tanang balde managsama ang kapasidad. --Ang matag atabay dunay katumbas nga balde nga magamit sa pag-ekstrak ug tubig gikan niini, --ug ang matag 1 sa usa ka linya nagrepresentar sa usa ka yunit sa tubig. --◯ Gihatagan ka ug usa ka rektanggulo nga grid sa mga atabay. Ang matag linya nagrepresentar sa usa ka atabay, ◯--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =","canonical_solution":"maxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity = ceiling (fromIntegral totalWater \/ fromIntegral capacity)\n  where\n    totalWater = sum (map sum grid)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_116","nl":"ceb_Latn","pl":"hs","prompt":"--Kini kinahanglang ipatuman sa ingon niini: --Alang sa susamang gidaghanon sa mga usa, pag-ilis pinasukad sa decimal nga kantidad. --gidaghanon sa mga usa diha sa ilang binary representasyon sa nagatindog nga kahikayan. --Sa kini nga Kata, kamo kinahanglan nga sorta sa usa ka listahan sa mga dili-negatibo integers sumala sa--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =","canonical_solution":"import Data.Bits (popCount)\nimport Data.List (sortBy)\n\nsortArray :: [Int] -> [Int]\nsortArray arr = sortBy compareOnesAndValues arr\n  where\n    compareOnesAndValues x y =\n      let onesX = popCount x\n          onesY = popCount y\n      in if onesX == onesY\n         then compare x y\n         else compare onesX onesY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_117","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Hinumdomi: imong mahimo sa paghunahuna sa input string naglangkob lamang sa mga letra ug mga wanang.--Kon ang string s mao ang walay sulod unya ang function kinahanglan nga mobalik sa usa ka walay sulod nga listahan. --n ka mga konsonante, aron kining mga pulonga makita diha sa string s. --usa ka function nga mobalik sa usa ka listahan sa tanan nga mga pulong gikan sa string s nga naglangkob sa eksakto nga --❑ Gipasagdan ug usa ka string s ug natural nga numero n, ikaw gisugo sa pagpadapat ❑--  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =","canonical_solution":"selectWords :: String -> Int -> [String]\nselectWords s n = filter (\\word -> countConsonants word == n) (words s)\n  where\n    countConsonants = length . filter (`elem` consonants)\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_118","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Ikaw mahimo sa paghunahuna nga ang gihatag nga string naglangkob sa Iningles nga sulat lamang. --pangitaa ang bisan unsang bokal nga nagatuman sa kondisyon sa ibabaw. --Vowels sa sinugdanan ug sa katapusan dili ihap. Ibalik ang walay sulod nga string kon kamo wala --duha ka mga konsonante gikan sa tuo nga kiliran sa pulong (mahinungdanong-ug-mahinungdanong-ug-mahinungdanon). --◯ Gihatagan ka ug pulong. Ang imong buluhaton mao ang pagpangita sa labing duol nga bokal nga anaa sa taliwala sa ◯ ug ◯--  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =","canonical_solution":"getClosestVowel :: String -> String\ngetClosestVowel word = go (reverse word) False\n  where\n    vowels = \"aeiouAEIOU\"\n    go [] _ = \"\"\n    go (x:xs) lastWasConsonant\n      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False\n      | x `notElem` vowels = go xs True\n      | otherwise = go xs False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_119","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Ibalik ang 'Oo' kon adunay paagi sa paghimo sa usa ka maayong string, ug ibalik ang 'Dili' kon dili. --\"()) \" dili. --Pananglitan: ang string '(()))))) maayo, samtang ang string --Ang usa ka string S giisip nga maayo kon ug lamang kon ang tanan nga mga parenteses sa S --sa pipila ka mga order, nga ang nagresulta nga string mahimong maayo. --Ang imong trabaho mao ang pagsusi kon posible ba nga mag-concatenate ang duha ka mga string diha sa --parentesis \" ((\" o parentesis nga \") \" lamang. --◯ Gihatagan ka og listahan sa duha ka mga string, ang duha ka mga string naglangkob sa open ◯--  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =","canonical_solution":"matchParens :: [String] -> String\nmatchParens [a, b] =\n    if isValid (a ++ b) || isValid (b ++ a) then \"Yes\" else \"No\"\n  where\n    isValid :: String -> Bool\n    isValid = go 0\n      where\n        go 0 [] = True\n        go _ [] = False\n        go n (x:xs)\n            | x == '('  = go (n + 1) xs\n            | x == ')'  = n > 0 && go (n - 1) xs\n    isValid _ = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_120","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan 1: --sa gitas-on k uban sa kinadak-ang k nga mga numero sa arr. --☐ Gihatagan usa ka listahan arr sa integers ug sa usa ka positibo nga integer k, mobalik sa usa ka gi-sort nga listahan ☐--  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the list will be in the range of [1, 1000].\n--  2. The elements in the list will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =","canonical_solution":"maximum :: [Int] -> Int -> [Int]\nmaximum arr k = take k $ reverse $ sort arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_121","nl":"ceb_Latn","pl":"hs","prompt":"--Mga Ehemplo --Gipasagdan sa usa ka dili-walay sulod nga listahan sa mga integers, mobalik sa kantidad sa tanan nga mga talagsaon nga mga elemento nga anaa sa bisan mga posisyon.--  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =","canonical_solution":"solution :: [Int] -> Int\nsolution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_122","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --ang kantidad sa mga elemento nga adunay labing kadaghan duha ka mga digit gikan sa unang k nga mga elemento sa arr. --Gipasagdan sa usa ka dili-walay sulod nga listahan sa mga integer arr ug sa usa ka integer k, balik --  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =","canonical_solution":"addElements :: [Int] -> Int -> Int\naddElements arr k = sum $ filter (\\x -> x >= -99 && x <= 99) $ take k arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_123","nl":"ceb_Latn","pl":"hs","prompt":"--get_odd_collatz(5) mobalik [1, 5] # Ang sunod-sunod nga collatz alang sa 5 mao ang [5, 16, 8, 4, 2, 1], busa ang mga numero nga dili-parehas mao lamang ang 1, ug 5. --Pananglitan: --2. giuli nga listahan nga gihan-ay sa nagkadaghan nga kahikayan. --Ang Collatz ((1) mao ang [1]. --Panid: --ang termino ug ang 1. Ang pangagpas mao nga bisan unsa pa ang bili sa n, ang sunodsunod kanunayng moabot sa 1. --Kon ang unang termino maoy dili-parehas, ang sunod nga termino maoy 3 ka pilo sa una.--ang unang termino sa mosunod nga paagi: kon ang unang termino par, ang sunod nga termino maoy katunga sa --sa mosunod: sugdan uban sa bisan unsang positibo nga integer n. Unya ang matag termino makuha gikan sa --Ang panghunahuna ni Collatz maoy panghunahuna sa matematika nga naglangkit sa usa ka sunodsunod nga gihubit --DATA A Positibo nga integer n, Ibalik ang usa ka gi-sort nga listahan nga adunay mga dili-parehas nga mga numero sa Collatz sunod-sunod. --  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =","canonical_solution":"getOddCollatz :: Int -> [Int]\ngetOddCollatz n = sort . filter odd $ collatzSequence n\n  where\n    collatzSequence 1 = [1]\n    collatzSequence x\n      | even x    = x : collatzSequence (x `div` 2)\n      | otherwise = x : collatzSequence (3 * x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_124","nl":"ceb_Latn","pl":"hs","prompt":"--4. Ang petsa kinahanglang diha sa pormat: mm-dd-yyyy --3. Ang mga bulan dili angay nga mas ubos sa 1 o mas taas kay sa 12.--Ang gidaghanon sa mga adlaw dili ubos pa kay sa 1 o mas taas pa kay sa 31 ka adlaw alang sa mga bulan 1,3,5,7,8,10,12. Ug ang gidaghanon sa mga adlaw dili ubos pa kay sa 1 o mas taas pa kay sa 30 ka adlaw alang sa mga bulan 4,6,9,11. Ug, ang gidaghanon sa mga adlaw dili ubos pa kay sa 1 o mas taas pa kay sa 29 alang sa bulan 2. --1. Ang petsa nga string dili walay sulod. --Ang petsa balido kon ang tanan sa mosunod nga mga lagda natuman: --mobalik True kon ang petsa balido sa laing paagi False. --Ikaw kinahanglan nga mosulat sa usa ka function nga validates sa usa ka gihatag nga petsa string ug --  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06\/04\/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =","canonical_solution":"import Text.Read (readMaybe)\nimport Data.List.Split (splitOn)\n\nvalidDate :: String -> Bool\nvalidDate date =\n    case splitOn \"-\" date of\n        [m, d, y] -> isValidMonthDayYear m d y\n        _         -> False\n\nisValidMonthDayYear :: String -> String -> String -> Bool\nisValidMonthDayYear m d y =\n    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of\n        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day\n        _ -> False\n\nisValidMonth :: Int -> Bool\nisValidMonth month = month >= 1 && month <= 12\n\nisValidDay :: Int -> Int -> Bool\nisValidDay month day\n    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31\n    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30\n    | month == 2                           = day >= 1 && day <= 29\n    | otherwise                            = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_126","nl":"ceb_Latn","pl":"hs","prompt":"--Mga Ehemplo --numero, pagbalik Bakak. Pagtuo nga walay negatibo nga mga numero ug integers lamang. --kon ang listahan adunay kapin sa usa ka duplikado sa mao gihapon --◯ Gipasudlan ug listahan sa mga numero, ibalik kon sila gihan-ay o dili ◯--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =","canonical_solution":"isSorted :: [Int] -> Bool\nisSorted lst = go lst Nothing\n  where\n    go [] _ = True\n    go [x] _ = True\n    go (x:y:xs) prev\n      | x > y = False\n      | x == y && prev == Just x = False\n      | otherwise = go (y:xs) (Just x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_127","nl":"ceb_Latn","pl":"hs","prompt":"--[input\/output] mga sampol: --Kon ang duha ka interbyu dili mag-intersect, ibalik ang \"NO\". --kon dili, ibalik ang \"NO\". --Kon ang gitas-on sa interseksyon maoy usa ka numero nga primo, ibalik ang \"YES\", --nga ang gitas-on niini mao ang 1, nga dili usa ka numero primo. --Pananglitan, ang interseksyon sa mga interbens (1, 3), (2, 4) mao ang (2, 3) --ang mga interbyu maoy usa ka numero nga primo. --Ang imong buluhaton mao ang pagtino kon ang gitas-on sa pag-angol niining duha --Alang sa matag gihatag nga yugto, gihunahuna nga ang sinugdanan niini mas gamay o katumbas sa kataposan niini. --naglakip sa sinugdanan ug kataposan. --Ang gihatag nga mga interbyu sirado nga nagpasabot nga ang interbyu (sugod, katapusan) --diin ang matag interbyu maoy pares sa mga integer. Pananglitan, interbyu = (sugod, katapusan) = (1, 2).--Ikaw gihatagan ug duha ka interbyu,--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =","canonical_solution":"intersection :: (Int, Int) -> (Int, Int) -> String\nintersection (start1, end1) (start2, end2) = \n    if intersectionLength > 0 && isPrime intersectionLength\n    then \"YES\"\n    else \"NO\"\n  where\n    intersectionStart = max start1 start2\n    intersectionEnd = min end1 end2\n    intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    isPrime :: Int -> Bool\n    isPrime n\n      | n <= 1 = False\n      | n == 2 = True\n      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_128","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Hinumdomi: wala'y iuli alang sa walay sulod nga mga arr. --sa matag numero sa listahan, nga gihawasan sa 1, -1 o 0. --sum sa kadaghan sa mga integer nga gipadaghan sa produkto sa tanang ilhanan --◯ Gihatagan ka og usa ka listahan sa mga integer ug kinahanglan nimong ibalik ◯--  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =","canonical_solution":"prodSigns :: [Int] -> Maybe Int\nprodSigns [] = Nothing\nprodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_129","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Ibalik ang usa ka gi-order nga listahan sa mga bili sa mga selyula nga ang kinagamyang agianan moagi. --Gitino nga ang tubag maoy talagsaon. --lst_A[j] = lst_B[j]. --ingon nga lst_A[i] < lst_B[i] ug alang sa bisan unsa nga j (1 <= j < i) kita adunay --kay sa lst_B, sa laing mga pulong, adunay usa ka integer nga index i (1 <= i <= k) --pinaagi sa (tawagon nato sila nga lst_A ug lst_B), ang lst_A mas gamay sa leksikograpiya --human sa paghimo sa gi-order nga mga listahan sa mga bili sa mga selyula nga A ug B moadto --Ang agianan nga A (sa gitas-on nga k) giisip nga mas gamay kay sa agianan nga B (sa gitas-on nga k) kon --Dili ka makagawas sa grid. --dili kinahanglang lahi).--Palihug timan-i nga ang dalan nga gitas-on k nagpasabot nga mobisita sa eksakto k ka selula (dili --cell. --sa laing pagkasulti, ikaw makaadto sa mga selula nga may bahin sa usa ka kilid uban kanimo karon --gikan sa bisan unsang selula, ug sa matag lakang nga imong mahimo sa pagbalhin ngadto sa bisan unsa sa mga silingan nga mga selula, --Kinahanglan nimo nga pangitaon ang labing gamay nga agianan sa gitas-on k sa grid.--ang inclusive makita sa eksaktong makausa diha sa mga selyula sa grid. --matag cell sa grid adunay bili. Ang matag integer sa range [1, N * N] -- Gipasagdan ang usa ka grid nga adunay N nga mga laray ug N nga mga haligi (N >= 2) ug usa ka positibo nga integer k, --  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =","canonical_solution":"import Data.List (sort, sortBy)\nimport Data.Ord (comparing)\nimport Control.Monad (guard)\n\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k = head $ sort paths\n  where\n    n = length grid\n    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]\n    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n      where\n        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n\n    value (r, c) = grid !! r !! c\n    paths = do\n      start <- cells\n      findPaths k [start]\n    findPaths 1 path = return $ map value path\n    findPaths l path@(current:_) = do\n      next <- neighbors current\n      findPaths (l-1) (next : path)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_130","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --unang n + 1 ka numero sa sekwensiya ni Tribonacci. --Ikaw gihatag sa usa ka non-negatibo integer numero n, kamo adunay sa usa ka pagbalik sa usa ka listahan sa --= 2 + 3 + 3 = 8 --tri(3) = tri(2) + tri(1) + tri(4) --tri(4) = 3 --tri(2) = 1 + (2 \/ 2) = 2 --Pananglitan: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), kon ang n maoy di-parehas. --tri (n) = 1 + n \/ 2, kon ang n par. --tri(1) = 3 --Ang sunod-sunod nga mga linya ni Tribonacci gihubit pinaagi sa pag-usab: --Apan, ang wala mailhi sa mga tawo mao ang sekwensiya ni Tribonacci.--Ang tanan nasayod sa sunodsunod nga Fibonacci, kini gitun-an pag-ayo sa mga matematiko sa --  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =","canonical_solution":"tri :: Int -> [Int]\ntri n = map tribonacci [0..n]\n  where\n    -- Define the recursive function to calculate the tribonacci value for a given n\n    tribonacci :: Int -> Int\n    tribonacci 0 = 1\n    tribonacci 1 = 3\n    tribonacci x\n      | even x    = 1 + x `div` 2\n      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_131","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Ibalik ang 0 kon ang tanan nga mga digit mao ang bisan. --DATA A positive integer n, balik sa produkto sa mga dili-parehas nga mga numero. --  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =","canonical_solution":"digits :: Int -> Int\ndigits n\n  | null oddDigits = 0\n  | otherwise      = product oddDigits\n  where\n    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_132","nl":"ceb_Latn","pl":"hs","prompt":"--diin labing menos usa ka parente sa sunodsunod nga gipasulod. --Ang function kinahanglan nga mobalik True kon ug lamang kon adunay usa ka balido nga subsequence sa mga parente -- Paghimo og usa ka function nga nagkuha sa usa ka string ingon nga input nga naglakip lamang sa mga kuwadrado nga parentes. --  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =","canonical_solution":"isNested :: String -> Bool\nisNested string = go string 0 False\n  where\n    go [] _ nested = nested\n    go (x:xs) depth nested\n      | x == '['  = go xs (depth + 1) (nested || depth >= 1)\n      | x == ']' && depth > 0 = go xs (depth - 1) nested\n      | otherwise = go xs depth nested","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_133","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --round matag elemento sa listahan ngadto sa ibabaw nga int ((Ceiling) una. --Kinahanglan nga mobalik ang kantidad sa mga numero sa kwadrado sa gihatag nga listahan, --◯ Gihatagan ka ug listahan sa mga numero. ◯--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =","canonical_solution":"import Data.List (foldl')\nimport Prelude hiding (sum)\n\nsumSquares :: [Float] -> Int\nsumSquares lst = foldl' (\\acc x -> acc + ceiling x ^ 2) 0 lst","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_134","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Hinumdomi: Ang \"pulong\" maoy grupo sa mga karakter nga gibulag sa wanang. --bahin sa usa ka pulong, ug bakak kon dili. --sa usa ka gihatag nga string mao ang usa ka alpabetiko nga karakter ug dili --Paghimo og usa ka function nga mobalik sa Tinuod kon ang katapusang karakter --  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =","canonical_solution":"checkIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt = \n    let trimmed = reverse . dropWhile (== ' ') $ reverse txt\n    in case trimmed of\n        [] -> False\n        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_135","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --magdoble sa mga sukod. --walay maong elemento anaa unya pagbalik -1. Ang gihatag nga listahan dili maglakip sa --dili mas dako o katumbas sa elemento nga nag-una dayon niini.--Paghimo og usa ka function nga mobalik sa kinadak-ang index sa usa ka elemento nga --  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =","canonical_solution":"canArrange :: [Int] -> Int\ncanArrange arr = go arr (-1) 0\n  where\n    go [] maxIdx _ = maxIdx\n    go [_] maxIdx _ = maxIdx\n    go (x:y:xs) maxIdx idx\n      | x >= y    = go (y:xs) idx (idx + 1)\n      | otherwise = go (y:xs) maxIdx (idx + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_136","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Kon walay negatibo o positibo nga integers, mobalik sila ingon nga Wala.--sa positibo nga mga integer diha sa usa ka listahan. --ang kinadak-an sa negatibo integers, ug ang \"b\" mao ang kinagamyan --❑ Paghimo og usa ka function nga mobalik sa usa ka tuple (a, b), diin 'a' mao ang ❑--  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =","canonical_solution":"largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst = (largestNegative, smallestPositive)\n  where\n    negatives = filter (< 0) lst\n    positives = filter (> 0) lst\n    largestNegative = if null negatives then Nothing else Just (maximum negatives)\n    smallestPositive = if null positives then Nothing else Just (minimum positives)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_138","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan --I-evaluate kon ang gihatag nga numero n mahimong isulat isip sum sa eksakto nga 4 ka positibo nga bisan numero.--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =","canonical_solution":"isEqualToSumEven :: Int -> Bool\nisEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_139","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --diin n > 0 --brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! --Ang Brazilian factorial gihubit nga: --  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =","canonical_solution":"specialFactorial :: Int -> Int\nspecialFactorial n = product [factorial x | x <- [1..n]]\n  where\n    factorial 0 = 1\n    factorial k = k * factorial (k - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_140","nl":"ceb_Latn","pl":"hs","prompt":"--unya ilis ang tanang sunodsunod nga mga wanang sa - --ug kon ang usa ka string adunay labaw pa kay sa 2 sunod-sunod nga mga wanang, --◯ Sa usa ka text string, pulihi ang tanang luna niini sa mga underline, --  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =","canonical_solution":"fixSpaces :: String -> String\nfixSpaces text = concatMap replaceSpaces (groupSpaces text)\n  where\n    groupSpaces :: String -> [String]\n    groupSpaces [] = []\n    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest\n\n    replaceSpaces :: String -> String\n    replaceSpaces spaces@(x:_)\n      | x == ' ' && length spaces > 2 = \"-\"\n      | x == ' ' = replicate (length spaces) '_'\n      | otherwise = spaces","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_141","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --- Ang substring human sa punto kinahanglan nga usa niini: ['txt', 'exe', 'dll'] --ang Latin nga alpabeto ('a'-'z' ug 'A'-'Z'). --- Ang substring sa atubangan sa punto kinahanglan nga dili walay sulod, ug kini nagsugod sa usa ka sulat gikan sa --- Ang ngalan sa file naglangkob sa eksaktong usa ka punto '.' --- Dili angay nga adunay kapin sa tulo ka digit ('0'-'9') sa ngalan sa file. --natuman: --Ang ngalan sa usa ka file giisip nga balido kon ug kon ang tanan sa mosunod nga mga kondisyon --'Oo' kon ang ngalan sa file balido, ug mobalik sa 'Dili' kon dili. --◯ Paghimo ug function nga magkuha ug string nga nagrepresentar sa ngalan sa file, ug mobalik ug ◯--  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =","canonical_solution":"import Data.Char (isDigit, isLetter)\n\nfileNameCheck :: String -> String\nfileNameCheck file_name \n  | countDots \/= 1 = \"No\"\n  | length digits > 3 = \"No\"\n  | null beforeDot || not (isLetter (head beforeDot)) = \"No\"\n  | afterDot `notElem` validExtensions = \"No\"\n  | otherwise = \"Yes\"\n  where \n    (beforeDot, afterDot) = span (\/= '.') file_name\n    countDots = length $ filter (== '.') file_name\n    digits = filter isDigit file_name\n    validExtensions = [\"txt\", \"exe\", \"dll\"]\n    afterDot = if null dotAndAfter then \"\" else tail dotAndAfter\n    dotAndAfter = dropWhile (\/= '.') file_name","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"\/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_142","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --pag-usab sa mga entry sa listahan kansang mga index dili sa usa ka daghan sa 3 o 4. ang function unya mobalik sa kantidad sa tanan nga mga entry. --daghan sa 3 ug sa pag-cube sa integer entry kon ang iyang index mao ang usa ka daghan sa 4 ug dili sa usa ka daghan sa 3. Ang function dili --Kini nga function magkuha sa usa ka listahan sa mga integers. Alang sa tanan nga mga entry sa listahan, ang function kinahanglan nga square sa integer entry kon ang iyang index mao ang usa ka --\" --  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =","canonical_solution":"sumSquares :: [Int] -> Int\nsumSquares lst = sum $ zipWith transform [0..] lst\n  where\n    transform idx x\n      | idx `mod` 3 == 0 = x * x\n      | idx `mod` 4 == 0 = x * x * x\n      | otherwise        = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_143","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan 1: --ang pagkasunodsunod sa mga pulong sa bag-ong linya kinahanglang sama sa orihinal. --kansang gitas-on maoy mga numero primo, --ug kamo adunay sa pagbalik sa usa ka string nga naglangkob sa mga pulong gikan sa orihinal nga mga pulong, --ang sentensiya dunay pipila ka pulong nga gibulag sa wanang, --◯ Gihatagan ka ug usa ka string nga nagrepresentar sa usa ka pulong, ◯--  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =","canonical_solution":"import Data.List (intercalate)\n\nwordsInSentence :: String -> String\nwordsInSentence sentence = intercalate \" \" $ filter (isPrime . length) (words sentence)\n\nisPrime :: Int -> Bool\nisPrime n | n < 2     = False\n          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_144","nl":"ceb_Latn","pl":"hs","prompt":"--Mahimo nimong hunahunaon nga ang x, ug n maoy tukmang mga fraction, ug wala silay zero isip denominator.--<numerator>\/<denominator> diin ang numerator ug denominator maoy positibo nga mga integer. --Ang x ug n, maoy mga representasyon sa usa ka hugpong sa mga hugpong sa mga hugpong, ug adunay mosunod nga pormat, --x * n. Ang function mobalik sa Tinuod kon x * n nagbanabana sa usa ka tibuok nga numero ug False --Ang imong buluhaton mao ang sa pagpatuman sa usa ka function nga mopadali sa ekspresyon.--  >>> simplify \"1\/5\" \"5\/1\"\n--  True\n--  >>> simplify \"1\/6\" \"2\/1\"\n--  False\n--  >>> simplify \"7\/10\" \"10\/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =","canonical_solution":"import Data.Ratio (denominator, numerator, (%))\n\nsimplify :: String -> String -> Bool\nsimplify x n =\n  let (xNum, xDen) = toFraction x\n      (nNum, nDen) = toFraction n\n      result = (xNum * nNum) % (xDen * nDen)\n  in denominator result == 1\n\ntoFraction :: String -> (Integer, Integer)\ntoFraction s =\n  let (numStr, _:denStr) = break (=='\/') s\n  in (read numStr, read denStr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/6\" \"2\/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/1\" \"3\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/10\" \"10\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/10\" \"50\/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/2\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11\/6\" \"6\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/3\" \"5\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/2\" \"3\/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"8\/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"1\/5\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_145","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --pag-order kanila pinasukad sa ilang indeks diha sa orihinal nga listahan. --Hinumdomi: kon adunay daghang mga item nga adunay susamang kantidad sa ilang mga digit, --sa nagatungas nga pagkasunodsunod sumala sa kantidad sa ilang mga digit. --❑ Pagsulat og usa ka function nga mag-order sa gihatag nga listahan sa mga integer.--  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =","canonical_solution":"import Data.List (sortBy)\nimport Data.Function (on)\n\norderByPoints :: [Int] -> [Int]\norderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums\n  where\n    sumOfDigits :: Int -> Int\n    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)\n    \n    indexedNums :: [(Int, Int)]\n    indexedNums = zip (map sumOfDigits nums) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_146","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --ang unang ug kataposang mga numero sa usa ka numero maoy dili-parehas (1, 3, 5, 7, 9).--ang gidaghanon sa mga elemento sa listahan nga mas dako kay sa 10 ug ang duha --◯ Pagsulat og function nga magkuha ug listahan sa mga numero isip input ug pagbalik ◯--  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =","canonical_solution":"specialfilter :: [Int] -> Int\nspecialfilter nums = length $ filter isSpecial nums\n  where\n    isSpecial n = n > 10 && isOddFirstAndLast (abs n)\n\n    isOddFirstAndLast :: Int -> Bool\n    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit\n      where\n        xStr = show x\n        firstDigit = head xStr\n        lastDigit = last xStr\n\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_147","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --ug ang a[i] + a[j] + a[k] maoy multiplikado sa 3. --Ibalik ang gidaghanon sa mga triple (a[i], a[j], a[k]) sa usa ka diin i < j < k, --Alang sa matag i (1 ≤ i ≤ n), ang bili sa a[i] = i * i - i + 1. --❑ Gihatagan ka og positibo nga integer nga n. Kinahanglan nimo nga maghimo og usa ka lista sa mga integer nga gitas-on nga n.--  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =","canonical_solution":"getMaxTriples :: Int -> Int\ngetMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]\n  where\n    a = [i * i - i + 1 | i <- [1..n]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_149","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --Mahimo nimong hunahunaon nga ang tanang pulong managsama ang gitas-on. --Ang function kinahanglan nga mobalik sa usa ka listahan sa mga linya sa gihan-ay nga pagkasunodsunod. --Kon ang duha ka pulong managsama ug gitas-on, i-order ang listahan sa alpabetiko. --kinahanglang ibalik ang listahan nga gihan-ay sumala nianang lagda. --Ang pagkasunudsunod sa listahan kinahanglang mosaka sa gitas-on sa matag pulong, ug ikaw --ug kini mahimong maglakip ug mga duplikado. --Ang listahan mao ang kanunay nga usa ka listahan sa mga string ug dili gayud usa ka listahan sa mga numero, --ug mobalik sa resulta nga listahan uban sa usa ka gihan-ay nga kahikayan, --delete ang mga string nga adunay dili paryente nga gitas-on gikan niini, --❑ Pagsulat sa usa ka function nga modawat sa usa ka listahan sa mga string ingon nga usa ka parameter, ❑--  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =","canonical_solution":"sortedListSum :: [String] -> [String]\nsortedListSum lst = sortBy compareStrings (filter evenLength lst)\n  where\n    evenLength s = even (length s)\n    compareStrings s1 s2\n      | length s1 == length s2 = compare s1 s2\n      | otherwise = compare (length s1) (length s2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_150","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --usa ka numero nga primo ug kinahanglan nga mobalik sa bili sa y kon dili. --Usa ka yano nga programa nga kinahanglan mobalik sa bili sa x kon n mao ang --  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =","canonical_solution":"xOrY :: Int -> Int -> Int -> Int\nxOrY n x y = if isPrime n then x else y\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_151","nl":"ceb_Latn","pl":"hs","prompt":"--Ayaw tagda ang mga numero nga negatibo o dili integers. --Gipasagdan sa usa ka listahan sa mga numero, mobalik sa katugbang sa mga kwadrado sa mga numero.--  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =","canonical_solution":"doubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst = \n    sum [x * x | x <- map round lst, x > 0, odd x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_152","nl":"ceb_Latn","pl":"hs","prompt":"--pananglitan: --ang kantidad maoy 0, ug kon dili, ang kantidad mao ang bug-os nga kalainan tali sa gihunahuna ug sa score. --Ibalik ang usa ka listahan sa sama nga gitas-on nga nagtimaan kon unsa ka layo ang matag pagtagna.--Ikaw hatagan ug duha ka listahan sa mga marka ug mga pangagpas nga managsama ang gitas-on, diin ang matag indeks magpakita ug katugbang. --Ang imong buluhaton mao ang pagtino kon husto ba ang pagdayagnos sa usa ka tawo sa mga resulta sa daghang panagsama. --angay gayod nga isulat ug itandi. --Ang mga pagbati ug mga hunahuna nga imong nabatonan nianang higayona maoy imong gihulagway sa imong kaugalingon.--Sa akong hunahuna kitang tanan nahinumdom nianang pagbati sa dihang ang resulta sa dugay nang gipaabot nga--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =","canonical_solution":"compare :: [Int] -> [Int] -> [Int]\ncompare game guess = zipWith (\\g s -> abs (g - s)) game guess","tests":"\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_153","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --(ang iyang kusog mao ang -1).--balikon 'Slices.SErviNGSliCes' tungod kay 'SErviNGSliCes' mao ang labing lig-on nga extension --extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] nan angay kang --Pananglitan, kon ikaw gihatag \"Slices\" ingon nga ang klase ug sa usa ka listahan sa --pilion ang una sa listahan. --Kon adunay duha o labaw pa nga mga extension nga managsama ang kusog, kinahanglan nga imong --format: ClassName.StrongestExtensionName. --Kinahanglan nimo nga pangitaon ang labing lig-on nga extension ug ibalik ang usa ka string niini --sa ngalan sa extension, ang kusog gihatag sa fraction CAP - SM. --letra sa ngalan sa extension, ug himoa nga ang SM mao ang gidaghanon sa gagmay nga mga letra --ang kusog sa extension mao ang mosunod: Himoa nga ang CAP mao ang numero sa dagkong letra --Ang mga extension gamiton sa pag-load sa dugang mga klase ngadto sa klase.--❑ Ikaw hatagan sa ngalan sa usa ka klase (usa ka string) ug usa ka listahan sa mga extension.--  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =","canonical_solution":"strongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions = class_name ++ \".\" ++ strongestExt\n  where\n    calculateStrength :: String -> Int\n    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)\n    \n    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)\n    \n    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)\n    maxStrength ext1 ext2\n      | snd ext1 > snd ext2 = ext1\n      | otherwise           = ext2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_154","nl":"ceb_Latn","pl":"hs","prompt":"--Ikaw gihatag 2 mga pulong. kamo kinahanglan nga mobalik Tinuod kon ang ikaduha nga pulong o sa bisan unsa sa iyang mga pag-ikot mao ang usa ka substring sa unang pulong.--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =","canonical_solution":"cycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b = any (`isInfixOf` a) rotations\n  where\n    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_155","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --DATA INTEGER. Ibalik ang usa ka tuple nga adunay gidaghanon sa bisan ug dili paryente nga mga numero sa tinagsa. --  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =","canonical_solution":"evenOddCount :: Int -> (Int, Int)\nevenOddCount num = (length evens, length odds)\n  where\n    digits = map (read . (:[])) . show . abs $ num\n    evens = filter even digits\n    odds  = filter odd digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_156","nl":"ceb_Latn","pl":"hs","prompt":"--Mga pananglitan: --Mga pagdili: 1 <= num <= 1000 --ug balikon kini sa gamayng letra. --◯ Gihatagan ug positibo nga integer, kuhaon ang Romanong numero nga katumbas niini isip usa ka string, --  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =","canonical_solution":"intToMiniRoman :: Int -> String\nintToMiniRoman number = concatMap (replicateSymbol number) romanNumerals\n  where\n    romanNumerals = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n                     (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n                     (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    \n    replicateSymbol :: Int -> (Int, String) -> String\n    replicateSymbol n (value, symbol)\n      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)\n      | otherwise = \"\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_157","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --90 ka degree. --Ang usa ka tul-id nga sukod sa triyanggo maoy usa ka triyanggo diin ang usa ka anggulo tul-id o --ang mga kilid maoy usa ka tulay-angled trianggulo, Kon dili, sayop. --Gitan-aw ang gitas-on sa tulo ka kilid sa usa ka trianggulo.--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =","canonical_solution":"rightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c = \n    let [x, y, z] = sort [a, b, c]\n    in x^2 + y^2 == z^2\n    where sort = Data.List.sort","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_158","nl":"ceb_Latn","pl":"hs","prompt":"--mga karakter, ibalik ang una nga anaa sa leksikograpikong pagkasunodsunod. --Kon daghang mga string adunay kinadak-ang gidaghanon sa talagsaon nga mga karakter --Ang listahan naglangkob sa lainlaing mga pulong. Ibalik ang pulong nga may kinadak-ang gidaghanon --❑ Pagsulat og function nga modawat sa listahan sa mga string.--  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =","canonical_solution":"import Data.List (nub, sort)\n\nfindMax :: [String] -> String\nfindMax words = \n    head . sort . map snd . filter (\\(n, _) -> n == maxUnique) $ wordUniquePairs\n  where\n    wordUniquePairs = [(length . nub $ word, word) | word <- words]\n    maxUnique = maximum $ map fst wordUniquePairs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_159","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --kon wala nay igong mga lugas nga nahibilin, mokaon ka sa tanang lugas nga nahibilin, apan gigutom gihapon ka. --ang gidaghanon sa mga carrots nga nahabilin human sa imong pagkaon] --[kabubut-on nga gidaghanon sa mga carrots nga imong gikaon human sa imong pagkaon, --apan karon kinahanglan nimong kan-on ang dugang mga carrot aron makompleto ang imong pagkaon sa adlaw.--Ikaw usa ka gigutom nga koneho, ug nakaon na ka ug pipila ka mga carrot,--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =","canonical_solution":"eat :: Int -> Int -> Int -> [Int]\neat number need remaining\n  | remaining >= need = [number + need, remaining - need]\n  | otherwise = [number + remaining, 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_160","nl":"ceb_Latn","pl":"hs","prompt":"--Operator listahan adunay labing menos usa ka operator, ug operand listahan adunay labing menos duha ka operands. --Ang operand maoy listahan sa mga integer nga dili negatibo.--Ang gitas-on sa operator listahan mao ang katumbas sa gitas-on sa operand listahan minus usa. --Panid: --=> resulta = 9 --resulta = 2 + 3 * 4 - 5 --lista = [2, 3, 4, 5] --operator['+', '*', '-'] --Pananglitan: --Pag-uswag (**) --Pagbahinbahin sa salog ( \/\/ ) --Pagkubli ( * ) --Pag-ikyas ( - ) --Pagdugang (+) --Ang pangunang mga operasyon sa algebra: --expression ug ibalik ang evaluation sa expression. --Ang ikaduhang listahan mao ang listahan sa mga integer. Gamita ang duha nga gihatag nga mga listahan sa pagtukod sa algebraic.--Gihatagan og duha ka listahan operator, ug operand. Ang unang listahan adunay mga sukaranan nga algebra operasyon, ug doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =","canonical_solution":"doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand = evaluate operand operator\n  where\n    evaluate [x] [] = x\n    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops\n      where\n        result = applyOperation op x y\n\n    applyOperation \"+\" a b = a + b\n    applyOperation \"-\" a b = a - b\n    applyOperation \"*\" a b = a * b\n    applyOperation \"\/\/\" a b = a `div` b\n    applyOperation \"**\" a b = a ^ b\n    applyOperation _ _ _ = error \"Unsupported operation\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"\/\/\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_161","nl":"ceb_Latn","pl":"hs","prompt":"--Mga Ehemplo --Ang function kinahanglan nga mobalik sa resulta nga string. --Kon ang string walay mga letra, balikon ang string. --kon dili, himoa nga ingon niini. --kon ang s[i] maoy letra, i-reverse ang case niini gikan sa ubos ngadto sa ibabaw o vice versa, --Ikaw gihatag sa usa ka string s. --  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =","canonical_solution":"solve :: String -> String\nsolve s\n  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s\n  | otherwise = reverse s\n  where\n    toggleCase c\n      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char\n      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_162","nl":"ceb_Latn","pl":"hs","prompt":"--Kon 'text' mao ang usa ka walay sulod nga string, mobalik Wala. --☐ Ang usa ka string 'text', mobalik sa iyang md5 hash katumbas string.--  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =","canonical_solution":"import qualified Data.ByteString.Char8 as C\nimport qualified Data.Digest.Pure.MD5 as MD5\n\nstringToMd5 :: String -> Maybe String\nstringToMd5 text\n  | null text = Nothing\n  | otherwise = Just $ show $ MD5.md5 $ C.pack text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_163","nl":"ceb_Latn","pl":"hs","prompt":"--Pananglitan: --ug b, sa nag-uswag nga pagkasunodsunod. --Gipasagdan duha ka positibo nga integers a ug b, mobalik sa bisan numero tali sa usa ka --  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =","canonical_solution":"generateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b = filter even [min a b .. max a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()"}]