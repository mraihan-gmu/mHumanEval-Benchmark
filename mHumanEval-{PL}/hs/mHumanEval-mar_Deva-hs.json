[{"task_id":"HumanEval_0","nl":"mar_Deva","pl":"hs","prompt":"----ЁЯУМ рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕рдВрдЦреНрдпрд╛рдВрдЪреНрдпрд╛ рдпрд╛рджреАрдд, рдХреЛрдгрддреАрд╣реА рджреЛрди рд╕рдВрдЦреНрдпрд╛ рдПрдХрдореЗрдХрд╛рдВрдкреЗрдХреНрд╖рд╛ рдЬрд╡рд│ рдЖрд╣реЗрдд рдХрд╛ рддреЗ рддрдкрд╛рд╕рд╛.--  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =","canonical_solution":"hasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold = any (\\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a \/= b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_1","nl":"mar_Deva","pl":"hs","prompt":"--рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреАрд▓ рдХреЛрдгрддреНрдпрд╛рд╣реА рд╕реНрдкреЗрд╕рдХрдбреЗ рджреБрд░реНрд▓рдХреНрд╖ рдХрд░рд╛.--рд╕реНрд╡рддрдВрддреНрд░ рдЧрдЯ рд╕рдВрддреБрд▓рд┐рдд рдЖрд╣реЗрдд (рдкреНрд░рддреНрдпреЗрдХ рдЙрдШрдбрд╛ рдХрдВрд╕ рдпреЛрдЧреНрдпрд░рд┐рддреНрдпрд╛ рдмрдВрдж рдЖрд╣реЗ) рдЖрдгрд┐ рдПрдХрдореЗрдХрд╛рдВрдордзреНрдпреЗ рдЧреБрдВрдлрд▓реЗрд▓реЗ рдирд╛рд╣реАрдд.--рддреНрдпрд╛ рд╕рдореВрд╣рд╛рд▓рд╛ рд╕реНрд╡рддрдВрддреНрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рд╡реЗрдЧрд│реЗ рдХрд░рд╛ рдЖрдгрд┐ рддреНрдпрд╛рддреАрд▓ рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛.--рдпрд╛ рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ рдЗрдирдкреБрдЯ рдореНрд╣рдгрдЬреЗ рдПрдХрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рдЕрдиреЗрдХ рдЧреБрдВрдбрд╛рд│рд▓реЗрд▓реНрдпрд╛ рдХрдВрд╕ рдЕрд╕рддрд╛рдд.--  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =","canonical_solution":"separateParenGroups :: String -> [String]\nseparateParenGroups paren_string = go paren_string 0 [] \"\" []\n  where\n    go [] _ _ current acc = if null current then acc else acc ++ [current]\n    go (x:xs) depth stack current acc\n      | x == ' ' = go xs depth stack current acc\n      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc\n      | x == ')' =\n          let newCurrent = current ++ [x]\n              newDepth = depth - 1\n          in if newDepth == 0\n             then go xs newDepth (tail stack) \"\" (acc ++ [newCurrent])\n             else go xs newDepth (tail stack) newCurrent acc\n      | otherwise = error \"Unexpected character\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_2","nl":"mar_Deva","pl":"hs","prompt":"--рд╕рдВрдЦреНрдпрд╛рдЪрд╛ рджрд╢рдорд▓рд╡ рднрд╛рдЧ рдкрд░рдд рдХрд░рд╛.--(рдЕрд╡рд╢реЗрд╖ рднрд╛рдЧ рдиреЗрд╣рдореА 1 рдкреЗрдХреНрд╖рд╛ рд▓рд╣рд╛рди рдЕрд╕рддреЛ).--рдЖрдгрд┐ рдкреВрд░реНрдгрд╛рдВрдХ рднрд╛рдЧ (рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕рдВрдЦреНрдпреЗрдкреЗрдХреНрд╖рд╛ рд╕рд░реНрд╡рд╛рдд рдореЛрдард╛ рдкреВрд░реНрдгрд╛рдВрдХ рд▓рд╣рд╛рди) рдЖрдгрд┐ рджрд╢рд╛рдВрд╢ --тИЩтИЩтИЩ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдлреНрд▓реЛрдЯрд┐рдВрдЧ рдкреЙрдЗрдВрдЯ рдирдВрдмрд░ рджрд┐рд▓реНрдпрд╛рд╕, рддреЛ тИЩтИЩтИЩ рдордзреНрдпреЗ рд╡рд┐рдШрдЯрд┐рдд рдХреЗрд▓рд╛ рдЬрд╛рдК рд╢рдХрддреЛ--  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =","canonical_solution":"truncateNumber :: Float -> Float\ntruncateNumber number = number - fromIntegral (floor number)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_3","nl":"mar_Deva","pl":"hs","prompt":"--рддреНрдпрд╛ рд╡реЗрд│реА рдлрдВрдХреНрд╢рдирдиреЗ True рдкрд░рдд рдХреЗрд▓реЗ рдкрд╛рд╣рд┐рдЬреЗ. рдЕрдиреНрдпрдерд╛ рддреЗ False рдкрд░рдд рдХреЗрд▓реЗ рдкрд╛рд╣рд┐рдЬреЗ.--рдЬрд░ рддреБрдордЪреНрдпрд╛ рдЦрд╛рддреНрдпрд╛рддреАрд▓ рд╢рд┐рд▓реНрд▓рдХ рд╢реВрдиреНрдпрдЪреНрдпрд╛ рдЦрд╛рд▓реА рдЧреЗрд▓реЗ рддрд░ рддреЗ рд╢реЛрдзреВрди рдХрд╛рдврдгреЗ рд╣реЗ рддреБрдордЪреЗ рдХрд╛рдо рдЖрд╣реЗ.-- рддреБрдореНрд╣рд╛рд▓рд╛ рдмрдБрдХ рдЦрд╛рддреНрдпрд╛рддреАрд▓ рдЬрдорд╛ рдЖрдгрд┐ рдкреИрд╕реЗ рдХрд╛рдврдгреНрдпрд╛рдЪреНрдпрд╛ рд╡реНрдпрд╡рд╣рд╛рд░рд╛рдВрдЪреА рдпрд╛рджреА рджрд┐рд▓реА рдЬрд╛рддреЗ рдЬреА  рдиреЗ рд╕реБрд░реВ рд╣реЛрддреЗ--  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =","canonical_solution":"belowZero :: [Int] -> Bool\nbelowZero operations = any (< 0) $ scanl (+) 0 operations","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_4","nl":"mar_Deva","pl":"hs","prompt":"--MAD = рд╕рд░рд╛рд╕рд░реА. x - x_mean. --рдШрдЯрдХ рдЖрдгрд┐ рдХреЗрдВрджреНрд░рдмрд┐рдВрджреВ (рдпрд╛ рдкреНрд░рдХрд░рдгрд╛рдд рд╕рд░рд╛рд╕рд░реА): --рд╕рд░рд╛рд╕рд░реА рдирд┐рд░рдкреЗрдХреНрд╖ рд╡рд┐рдЪрд▓рди рдореНрд╣рдгрдЬреЗ рдкреНрд░рддреНрдпреЗрдХ --рдпрд╛ рдбреЗрдЯрд╛рд╕реЗрдЯрдЪреНрдпрд╛ рд╕рд░рд╛рд╕рд░реАрдЪреНрдпрд╛ рдЖрд╕рдкрд╛рд╕.-- рдЖрдЧрдд рд╕рдВрдЦреНрдпрд╛рдВрдЪреНрдпрд╛ рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕реВрдЪреАрд╕рд╛рдареА, рд╕рд░рд╛рд╕рд░реА рдкрд░рд┐рдкреВрд░реНрдг рд╡рд┐рдЪрд▓рдирд╛рдЪреА рдЧрдгрдирд╛ рдХрд░рд╛.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =","canonical_solution":"meanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers = sum absoluteDifferences \/ fromIntegral (length numbers)\n  where\n    mean = sum numbers \/ fromIntegral (length numbers)\n    absoluteDifferences = map (\\x -> abs (x - mean)) numbers","tests":"\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_5","nl":"mar_Deva","pl":"hs","prompt":"--тИАрдЖрдВрдХрдбрд╛рдВрдЪреНрдпрд╛ рдпрд╛рджреАрддреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рджреЛрди рд╕рд▓рдЧ рдШрдЯрдХрд╛рдВрдордзреНрдпреЗ 'рдбрд┐рд▓рд┐рдорд┐рдЯрд░' рдХреНрд░рдорд╛рдВрдХ рдШрд╛рд▓рд╛--  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =","canonical_solution":"intersperse :: [Int] -> Int -> [Int]\nintersperse [] _ = []\nintersperse [x] _ = [x]\nintersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_6","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛. (() (()) рдордзреНрдпреЗ рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд рджреЛрди рд╕реНрддрд░рд╛рдВрдЪреЗ рдиреЗрд╕реНрдЯрд┐рдВрдЧ рдЖрд╣реЗ рддрд░ ((())) рдордзреНрдпреЗ рддреАрди рдЖрд╣реЗрдд.--рдкреНрд░рддреНрдпреЗрдХ рдЧрдЯрд╛рд╕рд╛рдареА, рдХрдВрд╕рд╛рддреАрд▓ рд╕рд░реНрд╡рд╛рдд рдЦреЛрд▓ рд╕реНрддрд░рд╛рдЪреЗ рдиреЗрд╕реНрдЯрд┐рдВрдЧ рдЖрдЙрдЯрдкреБрдЯ рдХрд░рд╛.--рдпрд╛ рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрд╣реЗ рдЬреА рдЕрдВрддрд░рд╛рд│рд╛рдиреЗ рд╡рд┐рднрдХреНрдд рдХреЗрд▓реЗрд▓реНрдпрд╛ рдХрдВрд╕рд╛рдд рдЕрдиреЗрдХ рдЧрдЯрд╛рдВрдЪреЗ рдкреНрд░рддрд┐рдирд┐рдзрд┐рддреНрд╡ рдХрд░рддреЗ.--  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =","canonical_solution":"parseNestedParens :: String -> [Int]\nparseNestedParens paren_string = map maxDepth (words paren_string)\n  where\n    maxDepth :: String -> Int\n    maxDepth = go 0 0\n      where\n        go :: Int -> Int -> String -> Int\n        go currentDepth maxDepth [] = maxDepth\n        go currentDepth maxDepth (c:cs)\n          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs\n          | c == ')'  = go (currentDepth - 1) maxDepth cs\n          | otherwise = go currentDepth maxDepth cs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_7","nl":"mar_Deva","pl":"hs","prompt":"--тЭС рджрд┐рд▓реЗрд▓реНрдпрд╛ рдЙрдк-рд╢реГрдВрдЧреА рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдЕрд╕рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрдЪреА рдХреЗрд╡рд│ рдЗрдирдкреБрдЯ рдпрд╛рджреА рдлрд┐рд▓реНрдЯрд░ рдХрд░рд╛.--  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =","canonical_solution":"filterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring = filter (substring `isInfixOf`) strings\n  where isInfixOf = isInfixOf","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_8","nl":"mar_Deva","pl":"hs","prompt":"--рд░рд┐рдХреНрдд рдмреЗрд░реАрдЬ 0 рдЖрдгрд┐ рд░рд┐рдХреНрдд рдЧреБрдгрдирдЦрдВрдб 1 рдЕрд╕рд╛рд╡реЗ.-- рдкреВрд░реНрдгрд╛рдВрдХ рд╕реВрдЪреАрд╕рд╛рдареА, рдпрд╛рджреАрддреАрд▓ рд╕рд░реНрд╡ рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдмреЗрд░реАрдЬ рдЖрдгрд┐ рдЧреБрдгрдирдЦрдВрдб рдЕрд╕рд▓реЗрд▓реА рдПрдХ рдЯрдкрд▓ рдкрд░рдд рдХрд░рд╛.--  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =","canonical_solution":"sumProduct :: [Int] -> (Int, Int)\nsumProduct numbers = (sum numbers, product numbers)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_9","nl":"mar_Deva","pl":"hs","prompt":"--рдХреНрд░рдорд╛рдиреЗ.--ЁЯУМ рдкреВрд░реНрдгрд╛рдВрдХ рд╕реВрдЪреАрдордзреВрди, рджрд┐рд▓реЗрд▓реНрдпрд╛ рдХреНрд╖рдгрд╛рдкрд░реНрдпрдВрдд рдЖрдврд│рд▓реЗрд▓реНрдпрд╛ рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд рдШрдЯрдХрд╛рдВрдЪреА рдпрд╛рджреА рддрдпрд╛рд░ рдХрд░рд╛.--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =","canonical_solution":"rollingMax :: [Int] -> [Int]\nrollingMax = scanl1 max","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_10","nl":"mar_Deva","pl":"hs","prompt":"--- рд╕реНрдЯреНрд░рд┐рдВрдЧрдЪреНрдпрд╛ рд╢реЗрд╡рдЯрдЪреНрдпрд╛ рдмрд╛рдЬреВрд▓рд╛ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкреНрд░реАрдлрд┐рдХреНрд╕ рдЬреЛрдбрд╛ рдЬреЛ рдкреЕрд▓рд┐рдВрдбреНрд░реЛрдорд┐рдХ рдкреНрд░рддреНрдпрдп рдЖрдзреА рдпреЗрддреЛ.--- рдкреБрд░рд╡рд┐рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрдЪрд╛ рд╕рд░реНрд╡рд╛рдд рдореЛрдард╛ рдкреЛрд╕реНрдЯрдлрд┐рдХреНрд╕ рд╢реЛрдзрд╛ рдЬреЛ рдкреЕрд▓рд┐рдВрдбреНрд░реЛрдо рдЖрд╣реЗ.--рдЕрд▓реНрдЧреЛрд░рд┐рджрдо рдХрд▓реНрдкрдирд╛ рд╕реЛрдкреА рдЖрд╣реЗ: --ЁЯУМ рджрд┐рд▓реЗрд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рд╕реБрд░реВ рд╣реЛрдгрд╛рд░реА рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рдкреЕрд▓рд┐рдВрдбреНрд░реЛрдо рд╢реЛрдзрд╛.--  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =","canonical_solution":"makePalindrome :: String -> String\nmakePalindrome string = string ++ reverse (take (length string - palindromeLength) string)\n  where\n    palindromeLength = longestPalindromicSuffix string\n\nlongestPalindromicSuffix :: String -> Int\nlongestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]\n\nisPalindrome :: String -> Bool\nisPalindrome s = s == reverse s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_11","nl":"mar_Deva","pl":"hs","prompt":"--рдпрд╛ рдЗрдирдкреБрдЯрд╡рд░ рдмрд╛рдпрдирд░реА XOR рдХрд░рд╛ рдЖрдгрд┐ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдореНрд╣рдгреВрдирд╣реА рдирд┐рдХрд╛рд▓ рдкрд░рдд рдХрд░рд╛.-- рдЗрдирдкреБрдЯ рджреЛрди рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЖрд╣реЗрдд a рдЖрдгрд┐ b рдЬреНрдпрд╛рдд рдлрдХреНрдд 1 рдЖрдгрд┐ 0 рдЖрд╣реЗрдд.--  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =","canonical_solution":"stringXor :: String -> String -> String\nstringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_12","nl":"mar_Deva","pl":"hs","prompt":"--рд╕рдорд╛рди рд▓рд╛рдВрдмреАрдЪреНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕. рдЗрдирдкреБрдЯ рд╕реВрдЪреА рд░рд┐рдХреНрдд рдЕрд╕рд▓реНрдпрд╛рд╕ рдХрд╛рд╣реАрд╣реА рдкрд░рдд рдХрд░реВ рдирдХрд╛.--ЁЯУМ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреНрдпрд╛ рдпрд╛рджреАрддреВрди рд╕рд░реНрд╡рд╛рдд рд▓рд╛рдВрдм рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛.--  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =","canonical_solution":"longest :: [String] -> Maybe String\nlongest [] = Nothing\nlongest strings = Just $ foldl1 (\\acc x -> if length x > length acc then x else acc) strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_13","nl":"mar_Deva","pl":"hs","prompt":"--рджреЛрди рдкреВрд░реНрдгрд╛рдВрдХ a рдЖрдгрд┐ b рдЪрд╛ рд╕рд░реНрд╡рд╛рдд рдореЛрдард╛ рд╕рд╛рдорд╛рдиреНрдп рд╡рд┐рднрд╛рдЬрдХ рдорд┐рд│рд╡рд╛.--  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =","canonical_solution":"greatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b\n  | b == 0    = a\n  | otherwise = greatestCommonDivisor b (a `mod` b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_14","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИ рд╕рд░реНрд╡ рдЙрдкрд╕рд░реНрдЧ рд╕реВрдЪреА рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рдкрд╛рд╕реВрди рд▓рд╛рдВрдм рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░реНрдпрдВрдд рдкрд░рдд рдХрд░рддреЗ тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ--  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =","canonical_solution":"allPrefixes :: String -> [String]\nallPrefixes string = [take n string | n <- [1 .. length string]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_15","nl":"mar_Deva","pl":"hs","prompt":"-- 0 рдкрд╛рд╕реВрди n рдкрд░реНрдпрдВрддрдЪреНрдпрд╛ рдЕрдВрддрд░рд╛рд│-рд╕реАрдорд┐рдд рд╕рдВрдЦреНрдпреЗрдЪреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛.--  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =","canonical_solution":"stringSequence :: Int -> String\nstringSequence n = unwords $ map show [0..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_16","nl":"mar_Deva","pl":"hs","prompt":"--ЁЯУМ рдПрдХрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрд▓рд╛ рджрд┐рд▓реЗрд▓рдВ, рдХрд┐рддреА рд╡реЗрдЧрд╡реЗрдЧрд│реЗ рдЕрдХреНрд╖рд░ рдЖрд╣реЗрдд рддреЗ рд╢реЛрдзрд╛ (рдХреЗрд╕ рд╡рд┐рдЪрд╛рд░рд╛рдд рди рдШреЗрддрд╛)--  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =","canonical_solution":"import Data.Char (toLower)\nimport Data.Set (fromList, size)\n\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string = size . fromList $ map toLower string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_17","nl":"mar_Deva","pl":"hs","prompt":"--' 'рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛рд╣рд╛--'рдУрд░рдбрд╛рдп' - рдЕрд░реНрдзрд╛ рд╕реНрд╡рд░, рджреЛрди рдмреАрдЯреНрд╕ рдЪрд╛рд▓реЗрд▓.--'рдУ' - рд╕рдВрдкреВрд░реНрдг рдиреЛрдЯ, рдЪрд╛рд░ рдмреАрдЯреНрд╕ рдЯрд┐рдХрддреЗ.--рдпреЗрдереЗ рдПрдХ рдЖрдЦреНрдпрд╛рдпрд┐рдХрд╛ рдЖрд╣реЗ:--рд╢реЗрд╡рдЯрдЪрд╛ рдирд╛рд╣реА.--рддреБрдордЪреЗ рдХрд╛рдо рд╣реЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд╛рд░реНрд╕ рдХрд░рдгреЗ рдЖрдгрд┐ рдкреНрд░рддреНрдпреЗрдХрд╛рдиреЗ рдХрд┐рддреА рдмреАрдЯреНрд╕ рдХреЗрд▓реНрдпрд╛ рдЖрд╣реЗрдд рддреНрдпрд╛ рдЕрдиреБрд╖рдВрдЧрд╛рдиреЗ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рдкрд░рдд рдХрд░рдгреЗ рдЖрд╣реЗ.--рдпрд╛ рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ рдЗрдирдкреБрдЯ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрд╣реЗ рдЬреА рд╡рд┐рд╢реЗрд╖ ASCII рд╕реНрд╡рд░реВрдкрд╛рдд рд╕рдВрдЧреАрдд рдиреЛрдЯреНрд╕ рджрд░реНрд╢рд╡рддреЗ.--  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =","canonical_solution":"parseMusic :: String -> [Int]\nparseMusic music_string = map beats (words music_string)\n  where\n    beats \"o\" = 4\n    beats \"o|\" = 2\n    beats \".|\" = 1\n    beats _ = 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_18","nl":"mar_Deva","pl":"hs","prompt":"--ЁЯУМ рдореВрд▓рднреВрдд рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рдХрд┐рддреА рд╡реЗрд│рд╛ рдЙрдк-рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрдврд│рддреЗ рд╣реЗ рд╢реЛрдзрд╛.--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =","canonical_solution":"howManyTimes :: String -> String -> Int\nhowManyTimes string substring\n  | null substring = 0\n  | otherwise = length . filter isPrefixOfSubstring $ tails string\n  where\n    isPrefixOfSubstring = isPrefixOf substring\n    isPrefixOf :: Eq a => [a] -> [a] -> Bool\n    isPrefixOf prefix str = prefix `isPrefixOf` str","tests":"\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_19","nl":"mar_Deva","pl":"hs","prompt":"--рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рдкрд╛рд╕реВрди рд╕рд░реНрд╡рд╛рдд рдореЛрдареНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рдХреНрд░рдорд╛рдВрдХ рдЕрд╕рд▓реЗрд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛ --рд╡реИрдз рдкрд░реНрдпрд╛рдп 'рд╢реВрдиреНрдп', 'рдПрдХ', 'рджреЛрди', 'рддреАрди', 'рдЪрд╛рд░', 'рдкрд╛рдЪ', 'рд╕рд╣рд╛', 'рд╕рд╛рдд', 'рдЖрда' рдЖрдгрд┐ 'рдирдК' рдЖрд╣реЗрдд.--рдЗрдирдкреБрдЯ рд╣реЗ рд╢реВрдиреНрдп рддреЗ рдирдК рдкрд░реНрдпрдВрддрдЪреНрдпрд╛ рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдЬрд╛рдЧрд╛-рд╕реАрдорд╛рдмрджреНрдз рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрд╣реЗ.--  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =","canonical_solution":"import Data.List (sort)\nimport Data.Maybe (fromJust)\nimport Data.Map (Map, fromList, lookup)\n\nsortNumbers :: String -> String\nsortNumbers numbers = unwords $ map snd $ sort $ map (\\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)\n  where\n    wordToNumber :: Map String Int\n    wordToNumber = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4),\n                             (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_20","nl":"mar_Deva","pl":"hs","prompt":"--рдЗрддрд░ рдЖрдгрд┐ рддреНрдпрд╛рдВрдирд╛ рдХреНрд░рдорд╛рдиреЗ рдкрд░рдд рдХрд░рд╛ (рдХрдореА рд╕рдВрдЦреНрдпрд╛, рдореЛрдареА рд╕рдВрдЦреНрдпрд╛).--тЭС рдкреБрд░рд╡рдард╛ рдХреЗрд▓реЗрд▓реНрдпрд╛ рд╕рдВрдЦреНрдпрд╛рдВрдЪреНрдпрд╛ рд╕реВрдЪреАрдордзреВрди (рдХрд┐рдорд╛рди рджреЛрди рд▓рд╛рдВрдмреАрдЪреЗ) рдирд┐рд╡рдб рдХрд░рд╛ рдЖрдгрд┐ рддреНрдпрд╛рдкреИрдХреА рдкреНрд░рддреНрдпреЗрдХрд╛рдЪреНрдпрд╛ рд╕рд░реНрд╡рд╛рдд рдЬрд╡рд│рдЪреЗ рджреЛрди рдкрд░рдд рдХрд░рд╛.--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =","canonical_solution":"findClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)\n  where\n    sortedNumbers = sort numbers\n    minByDiff (a1, b1) (a2, b2)\n      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)\n      | otherwise = (a2, b2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_21","nl":"mar_Deva","pl":"hs","prompt":"--рдЕрд╢рд╛ рдкреНрд░рдХрд╛рд░реЗ рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рд╕рдВрдЦреНрдпрд╛ 0 рд╣реЛрдИрд▓ рдЖрдгрд┐ рд╕рд░реНрд╡рд╛рдд рдореЛрдареА рд╕рдВрдЦреНрдпрд╛ 1 рд╣реЛрдИрд▓.-- рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рджрд┐рд▓реА рдЖрд╣реЗ (рдХрд┐рдорд╛рди рджреЛрди рдШрдЯрдХрд╛рдВрдЪреА), рддреНрдпрд╛ рдпрд╛рджреАрд▓рд╛ рд░реЗрд╖реЗрдЪрд╛ рд░реВрдкрд╛рдВрддрд░ рд▓рд╛рдЧреВ рдХрд░рд╛, --  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =","canonical_solution":"rescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers = map (\\x -> (x - minVal) \/ range) numbers\n  where\n    minVal = minimum numbers\n    maxVal = maximum numbers\n    range = maxVal - minVal","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_23","nl":"mar_Deva","pl":"hs","prompt":"--рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрдЪреА рд▓рд╛рдВрдмреА рдкрд░рдд рдХрд░рд╛.--  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =","canonical_solution":"strlen :: String -> Int\nstrlen string = length string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_24","nl":"mar_Deva","pl":"hs","prompt":"--n рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕рдВрдЦреНрдпреЗрд╕рд╛рдареА, n рдкреЗрдХреНрд╖рд╛ рд▓рд╣рд╛рди, рд╕рд░реНрд╡рд╛рдд рдореЛрдареА рд╕рдВрдЦреНрдпрд╛ рд╢реЛрдзрд╛ рдЬреА n рд▓рд╛ рд╕рдорд╛рди рд░реАрддреАрдиреЗ рд╡рд┐рднрд╛рдЧрддреЗ.--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =","canonical_solution":"largestDivisor :: Int -> Int\nlargestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_25","nl":"mar_Deva","pl":"hs","prompt":"--рдЗрдирдкреБрдЯ рдХреНрд░рдорд╛рдВрдХ рд╕рд░реНрд╡ рдШрдЯрдХрд╛рдВрдЪреНрдпрд╛ рдЧреБрдгрд╛рдХрд╛рд░рд╛рдЪреНрдпрд╛ рдмрд░реЛрдмрд░ рдЕрд╕рд╛рд╡рд╛.--рдкреНрд░рддреНрдпреЗрдХ рдШрдЯрдХрд╛рдЪреА рд╕рдВрдЦреНрдпрд╛ рд╣реА рдШрдЯрдХрд╛рдВрдЪреНрдпрд╛ рдХреНрд░рдорд╛рдВрдХрд╛рдордзреНрдпреЗ рдХрд┐рддреА рд╡реЗрд│рд╛ рдпреЗрддреЗ рддреНрдпрд╛рдиреБрд╕рд╛рд░ рдХреЗрд▓реА рдкрд╛рд╣рд┐рдЬреЗ.--тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ тФВ--  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =","canonical_solution":"factorize :: Int -> [Int]\nfactorize n = factorize' n 2\n  where\n    factorize' 1 _ = []\n    factorize' m f\n      | m `mod` f == 0 = f : factorize' (m `div` f) f\n      | otherwise      = factorize' m (f + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_26","nl":"mar_Deva","pl":"hs","prompt":"--рдЗрдирдкреБрдЯрдордзреНрдпреЗ рдЕрд╕рд▓реЗрд▓рд╛ рдХреНрд░рдо рдмрд╛рдХреА рдШрдЯрдХ рдареЗрд╡рд╛.-- рдкреВрд░реНрдгрд╛рдВрдХ рд╕реВрдЪреАрдордзреВрди, рдПрдХрд╛рдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рд╡реЗрд│рд╛ рдпреЗрдгрд╛рд░реЗ рд╕рд░реНрд╡ рдШрдЯрдХ рдХрд╛рдврд╛.--  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =","canonical_solution":"removeDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers = filter (\\x -> count x numbers == 1) numbers\n  where\n    count x = length . filter (== x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_27","nl":"mar_Deva","pl":"hs","prompt":"-- рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрд╕рд╛рдареА, рд▓рд╣рд╛рди рдЕрдХреНрд╖рд░рд╛рдВрдирд╛ рдореЛрдареЗ рдЕрдХреНрд╖рд░рд╛рдВрдордзреНрдпреЗ рд╡ рдореЛрдареЗ рдЕрдХреНрд╖рд░рд╛рдВрдирд╛ рд▓рд╣рд╛рди рдЕрдХреНрд╖рд░рд╛рдВрдордзреНрдпреЗ рдмрджрд▓рд╛.--  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =","canonical_solution":"flipCase :: String -> String\nflipCase = map flipChar\n  where\n    flipChar c\n      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)\n      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_28","nl":"mar_Deva","pl":"hs","prompt":"--тЭС рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдпрд╛рджреА рдПрдХрд╛рдЪ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рдПрдХрддреНрд░ рдХрд░рд╛.--  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =","canonical_solution":"concatenate :: [String] -> String\nconcatenate strings = concat strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_29","nl":"mar_Deva","pl":"hs","prompt":"--тЭС рджрд┐рд▓реЗрд▓реНрдпрд╛ рдЙрдкрд╕рд░реНрдЧрд╛рдиреЗ рд╕реБрд░реВ рд╣реЛрдгрд╛рд▒реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдЗрдирдкреБрдЯ рдпрд╛рджреА рдлрд┐рд▓реНрдЯрд░ рдХрд░рд╛.--  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =","canonical_solution":"filterByPrefix strings prefix = filter (isPrefixOf prefix) strings\n  where\n    isPrefixOf pfx str = take (length pfx) str == pfx","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_30","nl":"mar_Deva","pl":"hs","prompt":"--ЁЯУМ рдпрд╛рджреАрддреАрд▓ рдлрдХреНрдд рд╕рдХрд╛рд░рд╛рддреНрдордХ рд╕рдВрдЦреНрдпрд╛ рдкрд░рдд рдХрд░рд╛.--  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =","canonical_solution":"getPositive :: [Int] -> [Int]\ngetPositive l = filter (> 0) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_31","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ--  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =","canonical_solution":"isPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = not (any (\\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_33","nl":"mar_Deva","pl":"hs","prompt":"--l рдЪреНрдпрд╛ рд╕рдВрдмрдВрдзрд┐рдд рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХрд╛рдВрдЪреНрдпрд╛ рдореВрд▓реНрдпрд╛рдВрдиреБрд╕рд╛рд░, рдкрд░рдВрддреБ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реЗ.--l' рд╣реЗ l рдмрд░реЛрдмрд░ рдЖрд╣реЗ, рдЬреЗ рддреАрдирдиреЗ рд╡рд┐рднрд╛рдЬреНрдп рдирд╛рд╣реА, рддрд░ рддреНрдпрд╛рдЪреЗ рдореВрд▓реНрдп рддреАрдирдиреЗ рд╡рд┐рднрд╛рдЬреНрдп рдЖрд╣реЗ.--рд╣реЗ рдлрдВрдХреНрд╢рди рдПрдХ рд╕реВрдЪреА l рдШреЗрддреЗ рдЖрдгрд┐ рдПрдХ рд╕реВрдЪреА рдкрд░рдд рдХрд░рддреЗ рдЬрд╕реЗ рдХреА--  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =","canonical_solution":"sortThird :: [Int] -> [Int]\nsortThird l = map selectElem indexed\n  where\n    indexed = zip [0..] l\n    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]\n    sortedThirdElems = sortedElems thirdIndicesElems\n    sortedElems = id -- or List.sort if imported\n    selectElem (i, x)\n      | i `mod` 3 == 0 = head sortedThirdElems\n      | otherwise = x\n    replaceSortedElem xs sorted = map selectElem indexed\n      where\n        replaceElem i (x:xs)\n          | i == 0 = x:xs\n          | otherwise = replaceElem (i - 1) xs\n        selectElem (i, x)\n          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)\n          | otherwise = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_34","nl":"mar_Deva","pl":"hs","prompt":"-- рдпрд╛рджреАрддреАрд▓ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реЗ рдЕрдирдиреНрдп рдШрдЯрдХ рдкрд░рдд рдХрд░рд╛.--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =","canonical_solution":"unique :: [Int] -> [Int]\nunique l = sort $ nub l\n  where\n    -- | Remove duplicate elements from a list.\n    nub :: (Eq a) => [a] -> [a]\n    nub [] = []\n    nub (x:xs) = x : nub (filter (\/= x) xs)\n\n    -- | Sort a list of elements (using QuickSort algorithm).\n    sort :: (Ord a) => [a] -> [a]\n    sort [] = []\n    sort (x:xs) =\n      let smallerSorted = sort [a | a <- xs, a <= x]\n          biggerSorted = sort [a | a <- xs, a > x]\n      in  smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_35","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИ рд╕реВрдЪреАрддреАрд▓ рдХрдорд╛рд▓ рдШрдЯрдХ рдкрд░рдд рдХрд░рд╛.--  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =","canonical_solution":"maxElement :: [Int] -> Int\nmaxElement [] = error \"List cannot be empty\"\nmaxElement (x:xs) = maxElementHelper xs x\n  where\n    maxElementHelper [] currentMax = currentMax\n    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_36","nl":"mar_Deva","pl":"hs","prompt":"--ЁЯУМ 11 рдХрд┐рдВрд╡рд╛ 13 рдиреЗ рд╡рд┐рднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ n рдкреЗрдХреНрд╖рд╛ рдХрдореА рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛ рдордзреНрдпреЗ 7 рдЪреА рд╕рдВрдЦреНрдпрд╛ рдХрд┐рддреА рд╡реЗрд│рд╛ рдпреЗрддреЗ рддреЗ рджрд╛рдЦрд╡рд╛.--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =","canonical_solution":"fizzBuzz :: Int -> Int\nfizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_37","nl":"mar_Deva","pl":"hs","prompt":"--l рдЪреНрдпрд╛ рд╕рдо рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХрд╛рдВрдЪреНрдпрд╛ рдореВрд▓реНрдпрд╛рдВрдиреБрд╕рд╛рд░, рдкрдг рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реЗ.--l' рд╣реЗ l рдмрд░реЛрдмрд░ рдЖрд╣реЗ, рддрд░ рддреНрдпрд╛рдЪреЗ рдореВрд▓реНрдп рд╕рдорд╛рди рдЖрд╣реЗ.--рд╣реЗ рдлрдВрдХреНрд╢рди рдПрдХ рд╕реВрдЪреА l рдШреЗрддреЗ рдЖрдгрд┐ рдПрдХ рд╕реВрдЪреА рдкрд░рдд рдХрд░рддреЗ рдЬрд╕реЗ рдХреА--  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =","canonical_solution":"sortEven :: [Int] -> [Int]\nsortEven l = merge odds sortedEvens\n  where\n    (odds, evens) = partitionList l\n    sortedEvens = sort evens\n\n    partitionList :: [Int] -> ([Int], [Int])\n    partitionList [] = ([], [])\n    partitionList [x] = ([x], [])\n    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)\n      where\n        (xsOdds, xsEvens) = partitionList xs\n\n    merge :: [Int] -> [Int] -> [Int]\n    merge [] ys = ys\n    merge (x:xs) [] = x:xs\n    merge (x:xs) (y:ys) = x:y:merge xs ys","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_39","nl":"mar_Deva","pl":"hs","prompt":"--prime_fib рдлреНрдмреЛрдиреЕрдХреА рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ рдЖрдгрд┐ рддреА рд╕реБрджреНрдзрд╛ рдкреНрд░рд╛рдЗрдо рдЖрд╣реЗ.--  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =","canonical_solution":"primeFib :: Int -> Int\nprimeFib n = primeFibs !! (n - 1)\n  where\n    primeFibs = filter isPrime fibs\n    fibs = map fst $ iterate (\\(a, b) -> (b, a + b)) (0, 1)\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2 = False\n  | k == 2 = True\n  | even k = False\n  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]\n  where\n    upperLimit = floor . sqrt $ fromIntegral k","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_40","nl":"mar_Deva","pl":"hs","prompt":"--рд╢реВрдиреНрдп рдкрд░реНрдпрдВрддрдЪреА рдмреЗрд░реАрдЬ, рдЖрдгрд┐ рдЕрдиреНрдпрдерд╛ рдЦреЛрдЯреЗ.--рдЬрд░ рдпрд╛рджреАрдордзреНрдпреЗ рддреАрди рднрд┐рдиреНрди рдШрдЯрдХ рдЕрд╕рддреАрд▓ рддрд░ рддреЗ True рдкрд░рдд рдХрд░рддреЗ.--рдЯреНрд░рд┐рдкрд▓рд╕реЕрдо рдЯреВ рдЬреАрд░реЛ рд╣реЗ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рдЗрдирдкреБрдЯ рдореНрд╣рдгреВрди рдШреЗрддреЗ.--  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =","canonical_solution":"triplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]\n  where\n    tails [] = []\n    tails xs@(_:xs') = xs : tails xs'","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_41","nl":"mar_Deva","pl":"hs","prompt":"--рдпрд╛ рдлрдВрдХреНрд╢рдирдордзреВрди рдЕрд╢рд╛ рдкреНрд░рдХрд╛рд░рдЪреНрдпрд╛ рдЯрдХреНрдХрд░рдЪреА рд╕рдВрдЦреНрдпрд╛ рдорд┐рд│рддреЗ.--рддреНрдпрд╛рдВрдЪреНрдпрд╛ рдкреНрд░рд╡рд╛рд╕рд╛рдЪреНрдпрд╛ рдорд╛рд░реНрдЧрд╛рдд рдЕрд╕реЗ рд╣реЛрддреЗ рдХреА, рдЬрдгреВ рдХрд╛рд╣реА рддреЗ рдПрдХрдореЗрдХрд╛рдВрд╢реА рдЯрдХреНрдХрд░ рдШреЗрдд рдирд╡реНрд╣рддреЗ.--рдорд╛рддреНрд░, рдпрд╛ рдЧрд╛рдбреНрдпрд╛ рдЕрддреА рдордЬрдмреВрдд рдЖрдгрд┐ рдордЬрдмреВрдд рдЖрд╣реЗрдд. рдкрд░рд┐рдгрд╛рдореА, рддреНрдпрд╛ рдкреБрдвреЗ рдЬрд╛рдд рд░рд╛рд╣рддрд╛рдд.--рдЬреЗрд╡реНрд╣рд╛ рдбрд╛рд╡реАрдХрдбреВрди рдЙрдЬрд╡реАрдХрдбреЗ рдЪрд╛рд▓рдгрд╛рд░реА рдЧрд╛рдбреА рдЙрдЬрд╡реАрдХрдбреВрди рдбрд╛рд╡реАрдХрдбреЗ рдЪрд╛рд▓рдгрд╛рд▒реНрдпрд╛ рдЧрд╛рдбреАрд▓рд╛ рдзрдбрдХрддреЗ.--рдкреНрд░рддреНрдпреЗрдХ рдЧрд╛рдбреА рд╕рдорд╛рди рд╡реЗрдЧрд╛рдиреЗ рдЪрд╛рд▓рддреЗ. рджреЛрди рдХрд╛рд░ рдПрдХрдореЗрдХрд╛рдВрдирд╛ рдзрдбрдХрддрд╛рдд рдЕрд╕реЗ рдореНрд╣рдгрддрд╛рдд.--рдЙрдЬрд╡реАрдХрдбреВрди рдбрд╛рд╡реАрдХрдбреЗ рдЪрд╛рд▓рд╡рддрд╛рдд. рдХрд╛рд░рдЪреНрдпрд╛ рджреЛрди рдЬреЛрдбреНрдпрд╛ рд╕реБрд░реБрд╡рд╛рддреАрд▓рд╛ рдЦреВрдк рджреВрд░ рдЖрд╣реЗрдд.--n рдХрд╛рд░ рдбрд╛рд╡реАрдХрдбреВрди рдЙрдЬрд╡реАрдХрдбреЗ рдЪрд╛рд▓рд╡рддрд╛рдд; рдПрдХрд╛рдЪ рд╡реЗрд│реА, n рдХрд╛рд░рдЪрд╛ рд╡реЗрдЧрд│рд╛ рд╕рдВрдЪ --рдХрд▓реНрдкрдирд╛ рдХрд░рд╛ рдХреА рдПрдХ рд░рд╕реНрддрд╛ рдЖрд╣реЗ рдЬреЛ рдЕрдЧрджреА рд╕рд░рд│ рдЖрд╣реЗ, рдЕрд╕реАрдо рд▓рд╛рдВрдмреАрдЪреА рд░реЗрд╖рд╛.carRaceCollision :: Int -> Int\ncarRaceCollision n =","canonical_solution":"carRaceCollision :: Int -> Int\ncarRaceCollision n = n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_42","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ--  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =","canonical_solution":"incrList :: [Int] -> [Int]\nincrList l = map (+1) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_43","nl":"mar_Deva","pl":"hs","prompt":"--рд╢реВрдиреНрдп рдкрд░реНрдпрдВрддрдЪреА рдмреЗрд░реАрдЬ, рдЖрдгрд┐ рдЕрдиреНрдпрдерд╛ рдЦреЛрдЯреЗ.--рдЬрд░ рдпрд╛рджреАрдордзреНрдпреЗ рджреЛрди рднрд┐рдиреНрди рдШрдЯрдХ рдЕрд╕рддреАрд▓ рддрд░ рддреЗ True рдкрд░рдд рдХрд░рддреЗ.--pairs_sum_to_zero рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рдЗрдирдкреБрдЯ рдореНрд╣рдгреВрди рдШреЗрддреЗ.--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =","canonical_solution":"pairsSumToZero :: [Int] -> Bool\npairsSumToZero l = any (\\x -> -x `elem` l) l && (length l > 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_44","nl":"mar_Deva","pl":"hs","prompt":"--рдмреЗрд╕ рдХреНрд░рдорд╛рдВрдХ резреж рдкреЗрдХреНрд╖рд╛ рдХрдореА рдЖрд╣реЗрдд.--рд░реВрдкрд╛рдВрддрд░рд╛рдирдВрддрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкреНрд░рддрд┐рдирд┐рдзрд┐рддреНрд╡ рдкрд░рдд рдХрд░рд╛.-- X рдЪреА рд╕рдВрдЦреНрдпрд╛рддреНрдордХ рдЖрдзрд╛рд░ рд╕рдВрдЦреНрдпрд╛рддреНрдордХ рдЖрдзрд╛рд░рд╛рдд рдмрджрд▓рд╛.--  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =","canonical_solution":"changeBase :: Int -> Int -> String\nchangeBase x base\n  | x < base  = show x\n  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_45","nl":"mar_Deva","pl":"hs","prompt":"---- рддреНрд░рд┐рдХреЛрдгрд╛рдЪреА рдмрд╛рдЬреВ рдЖрдгрд┐ рдЙрдЪреНрдЪ рдкрд░рддрд╛рд╡рд╛ рдХреНрд╖реЗрддреНрд░ рджрд┐рд▓реЗрд▓реА рдЖрд╣реЗ.--  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =","canonical_solution":"triangleArea :: Int -> Int -> Float\ntriangleArea a h = 0.5 * fromIntegral a * fromIntegral h","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_46","nl":"mar_Deva","pl":"hs","prompt":"--рдХреГрдкрдпрд╛ fib4 рд╕рдВрдЦреНрдпрд╛ рдЕрдиреБрдХреНрд░рдорд╛рдЪреНрдпрд╛ n-рд╡реНрдпрд╛ рдШрдЯрдХрд╛рдЪреА рдХрд╛рд░реНрдпрдХреНрд╖рдорддреЗрдиреЗ рдЧрдгрдирд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛. рдкреБрдирд░рд╛рд╡реГрддреНрддреА рд╡рд╛рдкрд░реВ рдирдХрд╛.--fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--рдлреЕрдм 4 ((3) -> 0 --рдлреЕрдм 4 (((2) -> 2 --рдлреЕрдм 4 (рез) -> реж --рдлреЕрдм 4 ({0}) -> 0 --Fib4 рдХреНрд░рдорд╛рдВрдХ рдЕрдиреБрдХреНрд░рдо рд╣рд╛ рдлрд┐рдмреЛрдиреЕрдХреА рдЕрдиреБрдХреНрд░рдорд╛рдкреНрд░рдорд╛рдгреЗрдЪ рдЖрд╣реЗ.--  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =","canonical_solution":"fib4 :: Int -> Int\nfib4 n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 2\n  | n == 3 = 0\n  | otherwise = iter 0 0 2 0 n\n  where\n    iter a b c d 4 = a + b + c + d\n    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_47","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИ рд╕реВрдЪреА рдордзреАрд▓ рдШрдЯрдХрд╛рдВрдЪреА рдордзреНрдпрдорд╛рдВрдХ рдкрд░рдд рдХрд░рддреЗ.--  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =","canonical_solution":"median :: [Int] -> Float\nmedian l \n  | odd n     = fromIntegral $ sorted !! mid\n  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) \/ 2\n  where\n    sorted = sort l\n    n = length l\n    mid = n `div` 2\n    sort = sortBy compare","tests":"\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_48","nl":"mar_Deva","pl":"hs","prompt":"--рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрд▓рд╛ рдкреЕрд▓рд┐рдВрдбреНрд░реЛрдо рдЖрд╣реЗ рдХрд╛ рддреЗ рддрдкрд╛рд╕рддреЗ.--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =","canonical_solution":"isPalindrome :: String -> Bool\nisPalindrome text = text == reverse text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_49","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ--  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =","canonical_solution":"modp :: Int -> Int -> Int\nmodp n p = powMod 2 n p\n\npowMod :: Int -> Int -> Int -> Int\npowMod base exp modulus\n  | modulus == 1 = 0\n  | exp == 0     = 1\n  | exp == 1     = base `mod` modulus\n  | otherwise    = if odd exp\n                   then (base * halfExp * halfExp) `mod` modulus\n                   else (halfExp * halfExp) `mod` modulus\n  where\n    halfExp = powMod base (exp `div` 2) modulus","tests":"\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_51","nl":"mar_Deva","pl":"hs","prompt":"--remove_vowels рд╣реЗ рдПрдХ рдлрдВрдХреНрд╢рди рдЖрд╣реЗ рдЬреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдШреЗрддреЗ рдЖрдгрд┐ рд╕реНрд╡рд░ рдирд╕рд▓реЗрд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рддреЗ.--  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =","canonical_solution":"removeVowels :: String -> String\nremoveVowels text = filter (`notElem` \"aeiouAEIOU\") text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_52","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ--  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =","canonical_solution":"belowThreshold l t = all (< t) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_53","nl":"mar_Deva","pl":"hs","prompt":"--рджреЛрди рд╕рдВрдЦреНрдпрд╛ рдЬреЛрдбреВ x рдЖрдгрд┐ y.--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =","canonical_solution":"add :: Int -> Int -> Int\nadd x y = x + y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_54","nl":"mar_Deva","pl":"hs","prompt":"--ЁЯУМ рджреЛрди рд╢рдмреНрджрд╛рдВрдЪреЗ рдЕрдХреНрд╖рд░ рдПрдХрд╕рд╛рд░рдЦреЗ рдЖрд╣реЗрдд рдХрд╛ рддреЗ рддрдкрд╛рд╕рд╛.--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =","canonical_solution":"import Data.List (nub, sort)\n\nsameChars :: String -> String -> Bool\nsameChars s0 s1 = sort (nub s0) == sort (nub s1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_55","nl":"mar_Deva","pl":"hs","prompt":"--ЁЯУМ n-рд╡реНрдпрд╛ рдлрд┐рдмреЛрдиреЕрдХреА рд╕рдВрдЦреНрдпрд╛ рдкрд░рдд рдХрд░рд╛.--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =","canonical_solution":"fib :: Int -> Int\nfib n = fibHelper 0 1 n\n  where\n    fibHelper a _ 0 = a\n    fibHelper a b n = fibHelper b (a + b) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_56","nl":"mar_Deva","pl":"hs","prompt":"--рдЬрд░ рдкреНрд░рддреНрдпреЗрдХ рдЙрдШрдбрдгреНрдпрд╛рдЪреНрдпрд╛ рдХрдВрд╕рд╛рдд рд╕рдВрдмрдВрдзрд┐рдд рдмрдВрдж рдХрдВрд╕ рдЕрд╕реЗрд▓ рддрд░ рд╕рддреНрдп рдкрд░рдд рдХрд░рд╛.-- brackets рд╣реЗ \"<\" рдЖрдгрд┐ \">\" рдЪреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрд╣реЗ.--  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBrackets brackets 0 == 0\n\ncheckBrackets :: String -> Int -> Int\ncheckBrackets [] n = n\ncheckBrackets (x:xs) n\n  | n < 0 = -1\n  | x == '<' = checkBrackets xs (n + 1)\n  | x == '>' = checkBrackets xs (n - 1)\n  | otherwise = checkBrackets xs n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_57","nl":"mar_Deva","pl":"hs","prompt":"--тЦИтЦИ True рдкрд░рдд рдХрд░рд╛ рдореНрд╣рдгрдЬреЗ рдпрд╛рджреАрддреАрд▓ рдШрдЯрдХ рдПрдХрд╕рдорд╛рди рд╡рд╛рдврдд рдХрд┐рдВрд╡рд╛ рдХрдореА рд╣реЛрдд рдЖрд╣реЗрдд.--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =","canonical_solution":"monotonic :: [Int] -> Bool\nmonotonic l = increasing l || decreasing l\n  where\n    increasing xs = all (uncurry (<=)) (zip xs (tail xs))\n    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_58","nl":"mar_Deva","pl":"hs","prompt":"--рджреЛрди рд╕реВрдЪреАрдВрд╕рд╛рдареА рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реЗ рдЕрджреНрд╡рд┐рддреАрдп рд╕рд╛рдорд╛рдиреНрдп рдШрдЯрдХ рдкрд░рдд рдХрд░рд╛.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =","canonical_solution":"common :: [Int] -> [Int] -> [Int]\ncommon l1 l2 = uniqueSortedCommon\n  where\n    commonElements = filter (`elem` l2) l1\n    uniqueCommon = removeDuplicates commonElements\n    uniqueSortedCommon = sort uniqueCommon\n\n    removeDuplicates :: [Int] -> [Int]\n    removeDuplicates = foldr (\\x seen -> if x `elem` seen then seen else x : seen) []\n\n    sort :: [Int] -> [Int]\n    sort [] = []\n    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)\n      where\n        lesser  = filter (< p) xs\n        greater = filter (>= p) xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_59","nl":"mar_Deva","pl":"hs","prompt":"--n рдЪрд╛ рд╕рд░реНрд╡рд╛рдд рдореЛрдард╛ рдкреНрд░рд╛рдЗрдо рдлреЕрдХреНрдЯрд░ рдкрд░рдд рдХрд░рд╛. n > 1 рдЖрдгрд┐ рдкреНрд░рд╛рдЗрдо рдирд╛рд╣реА рдЕрд╕реЗ рдЧреГрд╣реАрдд рдзрд░рд╛.--  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =","canonical_solution":"largestPrimeFactor :: Int -> Int\nlargestPrimeFactor n = helper n 2\n  where\n    helper n factor\n      | factor * factor > n = n\n      | n `mod` factor == 0 = helper (n `div` factor) factor\n      | otherwise = helper n (factor + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_60","nl":"mar_Deva","pl":"hs","prompt":"--sum_to_n рд╣реЗ рдПрдХ рдлрдВрдХреНрд╢рди рдЖрд╣реЗ рдЬреЗ 1 рддреЗ n рдкрд░реНрдпрдВрддрдЪреНрдпрд╛ рд╕рдВрдЦреНрдпреЗрдЪреА рдмреЗрд░реАрдЬ рдХрд░рддреЗ.--  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =","canonical_solution":"sumToN :: Int -> Int\nsumToN n = sum [1..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_61","nl":"mar_Deva","pl":"hs","prompt":"--рдЬрд░ рдкреНрд░рддреНрдпреЗрдХ рдЙрдШрдбрдгреНрдпрд╛рдЪреНрдпрд╛ рдХрдВрд╕рд╛рдд рд╕рдВрдмрдВрдзрд┐рдд рдмрдВрдж рдХрдВрд╕ рдЕрд╕реЗрд▓ рддрд░ рд╕рддреНрдп рдкрд░рдд рдХрд░рд╛.-- parentheses рдореНрд╣рдгрдЬреЗ \"(\" рдЖрдгрд┐ \"\") рдЪреА рд╕реНрдЯреНрд░рд┐рдВрдЧ.--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBalance brackets 0\n  where\n    checkBalance [] 0 = True\n    checkBalance [] _ = False\n    checkBalance (x:xs) n\n      | x == '('  = checkBalance xs (n + 1)\n      | x == ')' && n > 0 = checkBalance xs (n - 1)\n      | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_62","nl":"mar_Deva","pl":"hs","prompt":"--рдпрд╛ рдмрд╣реБрдкрджрдЪреЗ рд╡реНрдпреБрддреНрдкрдиреНрди рддреНрдпрд╛рдЪ рд╕реНрд╡рд░реВрдкрд╛рдд рдкрд░рдд рдХрд░рд╛.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --x рд╣реЗ рдмрд╣реБрдкрджрд╛рддреАрд▓ рдЧреБрдгрд╛рдВрдХ рджрд░реНрд╢рд╡рддрд╛рдд.--  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =","canonical_solution":"derivative :: [Int] -> [Int]\nderivative xs = zipWith (*) (tail xs) [1..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_63","nl":"mar_Deva","pl":"hs","prompt":"--рдХреГрдкрдпрд╛ рдлреЕрдмрдлреЕрдм рдХреНрд░рдорд╛рдВрдХ рдЕрдиреБрдХреНрд░рдорд╛рдЪреНрдпрд╛ n рд╡реНрдпрд╛ рдШрдЯрдХрд╛рдЪреА рдХрд╛рд░реНрдпрдХреНрд╖рдорддреЗрдиреЗ рдЧрдгрдирд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛.--fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3).--рдлреНрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдл--рдлреНрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдлрдл--рдлреНрдлрдлрдлрдлрдлрдл (реж) == реж --рдлрд╛рдпрдмреЛрдиреЕрдХреА рдЕрдиреБрдХреНрд░рдорд╛рдкреНрд░рдорд╛рдгреЗрдЪ рдлрд┐рдмреЛрдиреЕрдХреА рдЕрдиреБрдХреНрд░рдорд╛рдЪреА рд╡реНрдпрд╛рдЦреНрдпрд╛ рдЦрд╛рд▓реАрд▓рдкреНрд░рдорд╛рдгреЗ рдЖрд╣реЗ.--  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =","canonical_solution":"fibfib :: Int -> Int\nfibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibs !! n\n  where\n    fibs = 0 : 0 : 1 : zipWith3 (\\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_64","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдорд╛рддреНрд░, рдЬреЗрд╡реНрд╣рд╛ рддреЛ рдПрдЦрд╛рджреНрдпрд╛ рд╢рдмреНрджрд╛рдЪреНрдпрд╛ рд╢реЗрд╡рдЯреА рдЕрд╕рддреЛ рддреЗрд╡реНрд╣рд╛рдЪ.--рдпрд╛ рдкреНрд░рдХрд░рдгрд╛рдд рд╕реНрд╡рд░ 'рдЕ', 'рдИ', 'рдЖрдп', 'рдУ', 'рдпреВ' рдЖрд╣реЗрдд. рдпреЗрдереЗ, 'рдп' рджреЗрдЦреАрд▓ рдПрдХ рдЖрд╣реЗ.--рдПрдХ рд╢рдмреНрдж рдЗрдирдкреБрдЯ рдореНрд╣рдгреВрди рдЖрдгрд┐ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреАрд▓ рд╕реНрд╡рд░ рд╕рдВрдЦреНрдпрд╛ рдкрд░рдд рдХрд░рддреЗ.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреНрдпрд╛рдордзреНрдпреЗ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЕрд╕реЗрд▓ рдЬреА --  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =","canonical_solution":"vowelsCount :: String -> Int\nvowelsCount s = length $ filter isVowel $ zip s [1..]\n  where\n    isVowel (c, pos) =\n      let lowercaseC = toLower c\n          isRegularVowel = lowercaseC `elem` \"aeiou\"\n          isLastCharY = lowercaseC == 'y' && pos == length s\n      in isRegularVowel || isLastCharY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_65","nl":"mar_Deva","pl":"hs","prompt":"--рдЬрд░ рд╢рд┐рдлреНрдЯ > рдЕрдВрдХрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рдЕрд╕реЗрд▓ рддрд░ рдЕрдВрдХрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рдЙрд▓рдЯ рдХрд░рд╛.--рдЖрдгрд┐ рдкрд░рд┐рдгрд╛рдо рд╕реНрдЯреНрд░рд┐рдВрдЧ рдореНрд╣рдгреВрди рдкрд░рдд рдХрд░рддреЛ.-- рд╡рд░реНрддреБрд│рд╛рдХрд╛рд░ рд╕рд░рдХрд╡рд╛ x рдЪреА рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛, рд╕рд░рдХрд╡рд╛ x рдЪреА рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛ рдЙрдЬрд╡реАрдХрдбреЗ рд╕рд░рдХрд╡рд╛ --  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =","canonical_solution":"circularShift :: Int -> Int -> String\ncircularShift x shift =\n  let digits = show x\n      len = length digits\n      effectiveShift = shift `mod` len\n  in if shift > len\n     then reverse digits\n     else let (begin, end) = splitAt (len - effectiveShift) digits\n          in end ++ begin","tests":"\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_66","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --ASCII рдХреЛрдб.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рдЗрдирдкреБрдЯ рдореНрд╣рдгреВрди рд╕реНрдЯреНрд░рд┐рдВрдЧ рдШреЗрддреЗ рдЖрдгрд┐ рдлрдХреНрдд рд╡рд░рдЪреНрдпрд╛ рд╡рд░реНрдгрд╛рдВрдЪреЗ рдмреЗрд░реАрдЬ рдкрд░рдд рдХрд░рддреЗ' --рдХрд╛рд░реНрдп--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =","canonical_solution":"digitsum :: String -> Int\ndigitsum s = sum $ map fromEnum $ filter isUpper s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_67","nl":"mar_Deva","pl":"hs","prompt":"--рдпрд╛ рднрд╛рдЧрд╛рд╕рд╛рдареА:--рдпрд╛ рдмрд╛рд╕реНрдХреЗрдЯрдордзреНрдпреЗ рдЕрд╕рд▓реЗрд▓реНрдпрд╛ рдЖрдВрдмрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рджрд╛рдЦрд╡рд╛.--рд╕рдВрддреНрд░реА рдЖрдгрд┐ рд╕рдлрд░рдЪрдВрдж рдЖрдгрд┐ рдПрдХ рдкреВрд░реНрдгрд╛рдВрдХ рдЬреЗ рдлрд│рд╛рдВрдЪреА рдПрдХреВрдг рд╕рдВрдЦреНрдпрд╛ рджрд░реНрд╢рд╡рд┐рддреЗ --рд╕рдлрд░рдЪрдВрдж, рд╕рдВрддреНрд░реА рдЖрдгрд┐ рдЖрдордЪреА рдлрд│реЗ. рдПрдХреВрдг рд╕рдВрдЦреНрдпрд╛ рджрд░реНрд╢рд╡рд┐рдгрд╛рд░реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рджрд┐рд▓реА рддрд░ --рдЬреЗ рдлрд│рд╛рдВрдЪреНрдпрд╛ рдЯреЛрдкрд▓реАрдд рд╡рд╛рдЯрдк рдХреЗрд▓реЗ рдЬрд╛рддрд╛рдд, рддреНрдпрд╛ рдЯреЛрдкрд▓реАрдд рдлрд│реЗ рдЕрд╕рддрд╛рдд.--рдпрд╛ рдХрд╛рдорд╛рдд рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рджрд┐рд▓реА рдЬрд╛рдИрд▓ рдЬреА рдНрдкрд▓ рдЖрдгрд┐ рдСрд░реЗрдВрдЬрдЪреА рд╕рдВрдЦреНрдпрд╛ рджрд░реНрд╢рд╡реЗрд▓.--  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =","canonical_solution":"import Text.Read (readMaybe)\n\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n = n - totalApplesOranges\n  where\n    totalApplesOranges = sum $ map (readNumber . words) [\"apples\", \"oranges\"]\n    readNumber keyword = case dropWhile (not . (==\" \") . dropWhile (\/=' ')) $ words s of\n      [] -> 0\n      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_68","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг 1: --рдЬрд░ рддреЗрдереЗ рдХреЛрдгрддреАрд╣реА рд╕рдо рдореВрд▓реНрдпреЗ рдирд╕рддреАрд▓ рдХрд┐рдВрд╡рд╛ рджрд┐рд▓реЗрд▓реА рдпрд╛рджреА рд░рд┐рдХреНрдд рдЕрд╕реЗрд▓ рддрд░ рдкрд░рдд [].--рдирд┐рд╡рдбрд▓реЗрд▓рд╛ рдиреЛрдб рдпрд╛рджреАрдордзреНрдпреЗ рдкрд░рдд рдХреЗрд▓рд╛ рдкрд╛рд╣рд┐рдЬреЗ, [ smalest_value, рддреНрдпрд╛рдЪреЗ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ ], --рдЬрд░ рд╕рдорд╛рди рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рд╕рдо рдореВрд▓реНрдп рдЕрд╕рд▓реЗрд▓реЗ рдЕрдиреЗрдХ рдиреЛрдбреНрд╕ рдЖрдврд│рд▓реЗ рддрд░ рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рдЕрд╕рд▓реЗрд▓рд╛ рдиреЛрдб рдкрд░рдд рдХрд░рд╛. --рдирд┐рд╡рдбрд▓реЗрд▓рд╛ рдиреЛрдб рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рд╕рдо рдореВрд▓реНрдпрд╛рдЪрд╛ рдиреЛрдб рдЕрд╕рд╛рд╡рд╛.--рддреБрдордЪреЗ рдХрд╛рдо рдЖрд╣реЗ рдиреЛрдбрдкреИрдХреА рдПрдХ рдХрд╛рдвреВрди рдкрд░рдд рдХрд░рдгреЗ.--\"рдПрдХ рд╡реГрдХреНрд╖рд╛рддреАрд▓ рд╢рд╛рдЦрд╛ рджрд░реНрд╢рд╡рд┐рдгрд╛рд░реА рдПрдХ рдпрд╛рджреА рджрд┐рд▓реА рдЬреНрдпрд╛рдд рдиреЙрди-рдирдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рдиреЛрдбреНрд╕ рдЖрд╣реЗрдд.--  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =","canonical_solution":"pluck :: [Int] -> [Int]\npluck arr = case filter (\\(x, _) -> even x) (zip arr [0..]) of\n    [] -> []\n    evens -> let (value, index) = minimum evens in [value, index]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_69","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЬрд░ рдЕрд╕реЗ рдХреЛрдгрддреЗрд╣реА рдореВрд▓реНрдп рдЕрд╕реНрддрд┐рддреНрд╡рд╛рдд рдирд╕реЗрд▓ рддрд░ -рез рдкрд░рдд рдХрд░рд╛.--рдкреВрд░реНрдгрд╛рдВрдХрдЪреА рд╡рд╛рд░рдВрд╡рд╛рд░рддрд╛ рд╣реА рдпрд╛рджреАрдд рдХрд┐рддреА рд╡реЗрд│рд╛ рджрд┐рд╕реВрди рдпреЗрддреЗ.--рд╢реВрдиреНрдп, рдЖрдгрд┐ рдкреВрд░реНрдгрд╛рдВрдХ рд╕реНрд╡рддрдГ рдЪреНрдпрд╛ рдореВрд▓реНрдпрд╛рдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдХрд┐рдВрд╡рд╛ рд╕рдорд╛рди рд╡рд╛рд░рдВрд╡рд╛рд░рддрд╛ рдЖрд╣реЗ.--рддреБрдореНрд╣рд╛рд▓рд╛ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рджрд┐рд▓реЗ рдЖрд╣реЗрдд. рд╕рд░реНрд╡рд╛рдд рдореЛрдареА рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛ рдкрд░рдд рдХрд░рд╛ рдЬреА  рдкреЗрдХреНрд╖рд╛ рдореЛрдареА рдЖрд╣реЗ.--  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nsearch :: [Int] -> Int\nsearch lst = \n    let frequencies = map (\\g -> (head g, length g)) . group . sort $ lst\n        candidates = filter (\\(val, freq) -> freq >= val) frequencies\n    in case candidates of\n         [] -> -1\n         _  -> fst . maximum $ candidates","tests":"\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_70","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдордЧ рдЙрд░реНрд╡рд░рд┐рдд рдкреВрд░реНрдгрд╛рдВрдХрд╛рддреАрд▓ рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд, рдордЧ рдХрд┐рдорд╛рди рдЖрдгрд┐ рдЕрд╕реЗрдЪ.--рд╡рд┐рдЪрд┐рддреНрд░ рдХреНрд░рдорд╡рд╛рд░реА, рдЬреЗрд╡реНрд╣рд╛ рдЖрдкрдг рдХрд┐рдорд╛рди рдореВрд▓реНрдпрд╛рдкрд╛рд╕реВрди рдкреНрд░рд╛рд░рдВрдн рдХрд░рддрд╛, -- рдкреВрд░реНрдгрд╛рдВрдХ рджрд┐рд▓реЗрд▓реА рдпрд╛рджреА, рд╡рд┐рдЪрд┐рддреНрд░ рдХреНрд░рдорд╛рдиреЗ рдкрд░рдд рдпрд╛рджреА.--  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =","canonical_solution":"strangeSortList :: [Int] -> [Int]\nstrangeSortList [] = []\nstrangeSortList lst = go (sort lst) True\n  where\n    go [] _ = []\n    go xs toggle\n      | toggle    = head xs : go (tail xs) False\n      | otherwise = last xs : go (init xs) True","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_71","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рддрд┐рд╕рд▒реНрдпрд╛ рдмрд╛рдЬреВрдкреЗрдХреНрд╖рд╛.--рддреАрди рдмрд╛рдЬреВ рд╡реИрдз рддреНрд░рд┐рдХреЛрдг рдмрдирд╡рддрд╛рдд рдЬреЗрд╡реНрд╣рд╛ рдХреЛрдгрддреНрдпрд╛рд╣реА рджреЛрди рдмрд╛рдЬреВрдВрдЪреА рдмреЗрд░реАрдЬ рдореЛрдареА рдЕрд╕рддреЗ.--рдЕрдиреНрдпрдерд╛ рдкрд░рдд -1 --рддреНрд░рд┐рдХреЛрдг рджреЛрди рджрд╢рдорд▓рд╡ рдмрд┐рдВрджреВ рдкрд░реНрдпрдВрдд рдЧреЛрд▓ рдХреЗрд▓реЗрд▓рд╛ рдЕрд╕реЗрд▓ рддрд░ рддреАрди рдмрд╛рдЬреВ рдПрдХ рд╡реИрдз рддреНрд░рд┐рдХреЛрдг рддрдпрд╛рд░ рдХрд░рддрд╛рдд.--рддреНрд░рд┐рдХреЛрдгрд╛рдЪреНрдпрд╛ рддреАрди рдмрд╛рдЬреВрдЪреА рд▓рд╛рдВрдмреА рджрд┐рд▓реА рддрд░,  рдЪрд╛ рдХреНрд╖реЗрддреНрд░рдлрд│ рджреНрдпрд╛.--  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =","canonical_solution":"import Text.Printf (printf)\n\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c\n    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))\n    | otherwise = -1\n  where\n    s = (fromIntegral (a + b + c)) \/ 2\n    isValidTriangle x y z = x + y > z && x + z > y && y + z > x\n    roundToTwoDecimals x = read (printf \"%.2f\" x) :: Float","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_72","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдСрдмреНрдЬреЗрдХреНрдЯ q рдЙрдбреНрдбрд╛рдг рдХрд░реАрд▓ рдЬрд░ рддреЛ рд╕рдВрддреБрд▓рд┐рдд рдЕрд╕реЗрд▓ (рддреЛ рдПрдХ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдорд┐рдХ рдпрд╛рджреА рдЖрд╣реЗ) рдЖрдгрд┐ рддреНрдпрд╛рдЪреЗ рдШрдЯрдХ рдмреЗрд░реАрдЬ рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд рд╢рдХреНрдп рд╡рдЬрдирд╛рдкреЗрдХреНрд╖рд╛ рдХрдореА рдХрд┐рдВрд╡рд╛ рд╕рдорд╛рди рдЕрд╕реЗрд▓ w.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреЗ рдЬрд░ рдСрдмреНрдЬреЗрдХреНрдЯ q рдЙрдбреЗрд▓ рддрд░ True рдЖрдгрд┐ рдЕрдиреНрдпрдерд╛ False рдкрд░рдд рдХрд░реЗрд▓.--  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =","canonical_solution":"willItFly :: [Int] -> Int -> Bool\nwillItFly q w = isPalindrome q && sum q <= w\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome xs = xs == reverse xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_73","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдПрдХрд╛ рдмрджрд▓рд╛рдордзреНрдпреЗ, рддреБрдореНрд╣реА рдПрдХ рдШрдЯрдХ рдЗрддрд░ рдХреЛрдгрддреНрдпрд╛рд╣реА рдШрдЯрдХрд╛рдордзреНрдпреЗ рдмрджрд▓реВ рд╢рдХрддрд╛.--рдпрд╛рджреАрд▓рд╛ рдкреЕрд▓рд┐рдВрдбреНрд░реЛрдорд┐рдХ рдмрдирд╡рд┐рдгреНрдпрд╛рд╕рд╛рдареА рдмрджрд▓рдгреНрдпрд╛рдЪреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рдЖрд╣реЗ. рдкреЕрд▓рд┐рдВрдбреНрд░реЛрдорд┐рдХ рдпрд╛рджреА рд╣реА рдЕрд╢реА рдпрд╛рджреА рдЖрд╣реЗ рдЬреА --ЁЯУМ рдкреВрд░реНрдгрд╛рдВрдХ arr рдЪреА рдпрд╛рджреА рджрд┐рд▓реА, рддрд░ рддреНрдпрд╛рддреАрд▓ рдШрдЯрдХрд╛рдВрдЪреА рдХрд┐рдорд╛рди рд╕рдВрдЦреНрдпрд╛ рд╢реЛрдзрд╛.--  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =","canonical_solution":"smallestChange :: [Int] -> Int\nsmallestChange arr = sum $ zipWith (\\x y -> if x \/= y then 1 else 0) arr (reverse arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_74","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ --рдЬрд░ рджреЛрдиреНрд╣реА рдпрд╛рджреАрдВрдордзреНрдпреЗ рд╕рдорд╛рди рд╕рдВрдЦреНрдпрд╛ рдЕрд╕реЗрд▓ рддрд░ рдкрд╣рд┐рд▓реА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛.--рдпрд╛рджреАрддреАрд▓ рд╕рд░реНрд╡ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдордзреАрд▓ рдЕрдХреНрд╖рд░ рд╕рдВрдЦреНрдпрд╛ рд╣реА рдЗрддрд░ рд╕реВрдЪреАрдкреЗрдХреНрд╖рд╛ рдХрдореА рдЖрд╣реЗ.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреНрдпрд╛ рджреЛрди рд╕реВрдЪреА рд╕реНрд╡реАрдХрд╛рд░рддреЗ рдЖрдгрд┐ рдЬреНрдпрд╛рдЪреА рдпрд╛рджреА рдЖрд╣реЗ рддреА рдкрд░рдд рдХрд░рддреЗ.--  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =","canonical_solution":"totalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2\n  | totalChars lst1 < totalChars lst2 = lst1\n  | totalChars lst1 > totalChars lst2 = lst2\n  | otherwise = lst1\n  where\n    totalChars = sum . map length","tests":"\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_75","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --(a) резрежреж рдкреЗрдХреНрд╖рд╛ рдХрдореА рдЖрд╣реЗ рд╣реЗ рдЬрд╛рдгреВрди.--рдЖрдгрд┐ рдЦреЛрдЯреЗ рдЖрд╣реЗ.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рджрд┐рд▓реЗрд▓реА рд╕рдВрдЦреНрдпрд╛ 3 рдкреНрд░рд╛рдЗрдо рдирдВрдмрд░рдЪреА рдЧреБрдгрдирдЦрдВрдб рдЕрд╕реЗрд▓ рддрд░ рддреА рдлрдВрдХреНрд╢рди true рдкрд░рдд рдХрд░рддреЗ.--  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =","canonical_solution":"isMultiplyPrime :: Int -> Bool\nisMultiplyPrime a = any isTriplePrimeProduct primeTriples\n  where\n    primes = filter isPrime [2..99]\n    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]\n    isTriplePrimeProduct (x, y, z) = x * y * z == a\n\nisPrime :: Int -> Bool\nisPrime n \n  | n < 2     = False\n  | otherwise = not (any (\\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_76","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --x рд╣реЗ n рдЪреЗ рдПрдХ рд╕рд╛рдзреЗ рдЧреБрдгрдирдЦрдВрдб рдЖрд╣реЗ рдЬрд░ n**int=x --рдПрдирдЪреА рд╢рдХреНрддреА рдЖрдгрд┐ рдЗрддрд░ рдкреНрд░рдХрд░рдгрд╛рдВрдордзреНрдпреЗ рдЦреЛрдЯреЗ.--рддреБрдордЪреЗ рдХрд╛рдо рд╣реЗ рдЖрд╣реЗ рдХреА рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рдЬрд░ x рд╣реА рдПрдХ рд╕рд╛рдзреА рд╕рдВрдЦреНрдпрд╛ рдЕрд╕реЗрд▓ рддрд░ рддреА рдлрдВрдХреНрд╢рди true рдкрд░рдд рдХрд░рддреЗ.--  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =","canonical_solution":"isSimplePower :: Int -> Int -> Bool\nisSimplePower x n\n  | x < 1 || n < 1 = False\n  | n == 1 = x == 1\n  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_77","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЯреАрдкрдГ рдЖрдкрдг рдЗрдирдкреБрдЯ рдиреЗрд╣рдореА рд╡реИрдз рдЖрд╣реЗ рдЕрд╕реЗ рдЧреГрд╣реАрдд рдзрд░рд▓реЗ рдЬрд╛рдК рд╢рдХрддреЗ.--рдЬрд░ рд╣рд╛ рдЗрдиреНрдЬреЗрдЧрд░ рдХрд╛рд╣реА рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛рдЪрд╛ рдШрди рдЕрд╕реЗрд▓ рддрд░.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рдПрдХ рдкреВрд░реНрдгрд╛рдВрдХ a рдШреЗрддреЗ рдЖрдгрд┐ True рдкрд░рдд рдХрд░рддреЗ.--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =","canonical_solution":"iscube :: Int -> Bool\niscube a = let n = round (fromIntegral a ** (1\/3)) in n^3 == a","tests":"\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_78","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЖрдгрд┐ рдЪрд┐рдиреНрд╣реЗ рдП, рдмреА, рд╕реА, рдбреА, рдИ, рдПрдл рдиреЗрд╣рдореАрдЪ рдореЛрдареЗ рдЖрд╣реЗрдд.--рдЯреАрдкрдГ рдЖрдкрдг рдЗрдирдкреБрдЯ рдиреЗрд╣рдореА рдпреЛрдЧреНрдп рдХрд┐рдВрд╡рд╛ рд░рд┐рдХреНрдд рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрд╣реЗ рдЕрд╕реЗ рдЧреГрд╣реАрдд рдзрд░рд▓реЗ рдЬрд╛рдК рд╢рдХрддреЗ, --рдмреА (= рджрд╢рдорд▓рд╡ 11), рдбреА (= рджрд╢рдорд▓рд╡ 13).--рддрд░ рддреБрдореНрд╣рд╛рд▓рд╛ рдЦрд╛рд▓реАрд▓ рдЕрдВрдХрд╛рдВрдкреИрдХреА рдПрдХ рд╕рдВрдЦреНрдпрд╛ рд╢реЛрдзрд╛рд╡реА рд▓рд╛рдЧреЗрд▓: 2, 3, 5, 7, --рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ 2, 3, 5, 7, 11, 13, 17,. . . рдЖрд╣реЗрдд.--рд╣реЗрдХреНрд╕рд╛рдбреЗрд╕рд┐рдорд▓ рдЕрдВрдХ рд╣реЗ рдЖрд╣реЗрдд 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.--1 рдкреЗрдХреНрд╖рд╛ рдореЛрдард╛ рдЖрд╣реЗ рдЬреЛ рджреЛрди рд▓рд╣рд╛рди рдиреИрд╕рд░реНрдЧрд┐рдХ рд╕рдВрдЦреНрдпреЗрдЪрд╛ рдЧреБрдгрдирдЦрдВрдб рдирд╛рд╣реА).--рдЬреНрдпрд╛ рдЕрдВрдХ рдкреНрд░рд╛рдердорд┐рдХ рдЖрд╣реЗрдд (рдкреНрд░рд╛рдердорд┐рдХ рд╕рдВрдЦреНрдпрд╛, рдХрд┐рдВрд╡рд╛ рдПрдХ рдкреНрд░рд╛рдердорд┐рдХ, рдПрдХ рдиреИрд╕рд░реНрдЧрд┐рдХ рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ --рд╣реЗрдХреНрд╕рд╛рдбреЗрд╕рд┐рдорд▓ рд╕рдВрдЦреНрдпрд╛ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдореНрд╣рдгреВрди рдЖрдгрд┐ рд╣реЗрдХреНрд╕рд╛рдбреЗрд╕рд┐рдорд▓ рд╕рдВрдЦреНрдпрд╛ рдореЛрдЬрддреЗ --рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рдЕрд╕реЗ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛рдпрд▓рд╛ рд╕рд╛рдВрдЧрд┐рддрд▓реЗ рдЖрд╣реЗ рдЬреЗ рдкреНрд░рд╛рдкреНрдд рдХрд░рддреЗ.--  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =","canonical_solution":"hexKey :: String -> Int\nhexKey num = length . filter (`elem` primeHexDigits) $ num\n  where\n    primeHexDigits = \"2357BD\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_79","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЕрддрд┐рд░рд┐рдХреНрдд рд╡рд░реНрдг рд╕реНрд╡рд░реВрдкрд╛рдд рдорджрдд рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдЖрд╣реЗрдд.--рд╕реНрдЯреНрд░рд┐рдВрдЧрдЪреНрдпрд╛ рд╕реБрд░реБрд╡рд╛рддреАрд▓рд╛ рдЖрдгрд┐ рд╢реЗрд╡рдЯреА 'db' рдЕрд╕реЗ рдЕрддрд┐рд░рд┐рдХреНрдд рджреЛрди рд╡рд░реНрдг рдЕрд╕рддреАрд▓.--рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рдЕрдХреНрд╖рд░ '0' рдХрд┐рдВрд╡рд╛ '1' рдЕрд╕реЗрд▓.--рдмрд╛рдпрдирд░реА рд╕реНрд╡рд░реВрдк. рдлрдВрдХреНрд╢рдирдиреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛рд╡реА, рдкреНрд░рддреНрдпреЗрдХ рд╡рд░реНрдг рдмрд╛рдпрдирд░реА --ЁЯУМ рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╕рдВрдЦреНрдпрд╛ рджрд┐рд▓реА рдЬрд╛рдИрд▓ рджрд╢рдорд▓рд╡ рд╕реНрд╡рд░реВрдкрд╛рдд рдЖрдгрд┐ рддреБрдордЪреЗ рдХрд╛рдо рдЖрд╣реЗ рддреА рд░реБрдкрд╛рдВрддрд░рд┐рдд рдХрд░рдгреЗ ЁЯУМ--  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =","canonical_solution":"decimalToBinary :: Int -> String\ndecimalToBinary decimal = \"db\" ++ toBinary decimal ++ \"db\"\n  where\n    toBinary 0 = \"0\"\n    toBinary n = reverse (binaryHelper n)\n\n    binaryHelper 0 = \"\"\n    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_80","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдПрдЦрд╛рджреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рд╣рд╛рдл рдЕрд╕рддреЗ рдЬрд░ рддреНрдпрд╛рдЪреА рд▓рд╛рдВрдмреА рдХрдореАрдд рдХрдореА рей рдЕрд╕реЗрд▓ рдЖрдгрд┐ рдкреНрд░рддреНрдпреЗрдХ рей рд╕рд▓рдЧ рдЕрдХреНрд╖рд░реЗ рд╡реЗрдЧрд│реА рдЕрд╕рддреАрд▓.--рддреБрдордЪреЗ рдХрд╛рдо рд╣реЗ рдЖрд╣реЗ рдХреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рд╣рд╛рдл рдЖрд╣реЗ рдХреА рдирд╛рд╣реА рд╣реЗ рддрдкрд╛рд╕рдгреЗ.--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ s рджрд┐рд▓реА рдЖрд╣реЗ.--  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =","canonical_solution":"isHappy :: String -> Bool\nisHappy s\n  | length s < 3 = False\n  | otherwise = all distinctTriples (windows 3 s)\n  where\n    distinctTriples [x, y, z] = x \/= y && y \/= z && x \/= z\n    distinctTriples _ = False\n    windows n xs\n      | length xs < n = []\n      | otherwise = take n xs : windows n (tail xs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_81","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --реж.реж рдИ --> реж. реж рдбреА- --> 0.7 D --> рез.реж рдбреА+ --> рез.рей C- --> рез.рен C--> реи.реж C+ --> реи.рей рдмреА- --> реи.рен B --> 3.0 рдмреА + --> 3.3 рдЕ- --> 3.7 A --рек.реж A+ --GPA. рд▓реЗрдЯрд░ рдЧреНрд░реЗрдб.--рдПрдХ рдлрдВрдХреНрд╢рди рдЬреЗ рдЦрд╛рд▓реАрд▓ рд╕рд╛рд░рдгреА рд╡рд╛рдкрд░реВрди рдЕрдХреНрд╖рд░рд╛рдВрдЪреНрдпрд╛ рдЧреНрд░реЗрдбрдЪреА рдпрд╛рджреА рдЖрдЙрдЯрдкреБрдЯ рдХрд░реВ рд╢рдХрддреЗ: --рддрд┐рдиреЗ рддреБрдореНрд╣рд╛рд▓рд╛ рдХрд╛рд╣реА рд╡рд┐рджреНрдпрд╛рд░реНрдереНрдпрд╛рдВрдЪреНрдпрд╛ GPA рдЪреА рдпрд╛рджреА рджрд┐рд▓реА рдЖрд╣реЗ рдЖрдгрд┐ рддреБрдореНрд╣рд╛рд▓рд╛ рд▓рд┐рд╣рд╛рдпрдЪреЗ рдЖрд╣реЗ .--рдлрдХреНрдд рдПрдХрдЪ рд╕рдорд╕реНрдпрд╛ рдЖрд╣реЗ рддреА рдореНрд╣рдгрдЬреЗ, рддреА рдЧреНрд░реЗрдбрд┐рдВрдЧрд╕рд╛рдареА рд╡рд╛рдкрд░рд▓реЗрд▓рд╛ рдХреЛрдб рд╣рд░рд╡рд▓рд╛ рдЖрд╣реЗ.--рд╡рд┐рджреНрдпрд╛рд░реНрдереНрдпрд╛рдВрдирд╛. рд╢рд┐рдХреНрд╖рдХ рд╕реНрд╡рддрдГрдЪреЗ рдЧреБрдг рджреЗрдгреНрдпрд╛рд╕рд╛рдареА рдЕрд▓реНрдЧреЛрд░рд┐рджрдо рдмрдирд╡рдд рдЖрд╣реЗ.--рд╕реЗрдореЗрд╕реНрдЯрд░рдЪрд╛ рд╢реЗрд╡рдЯрдЪрд╛ рдЖрдард╡рдбрд╛ рдЖрд╣реЗ рдЖрдгрд┐ рд╢рд┐рдХреНрд╖рдХрд╛рдВрдирд╛ рдЧреБрдг рджреНрдпрд╛рдпрдЪреЗ рдЖрд╣реЗрдд.--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =","canonical_solution":"numericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades = map gpaToLetterGrade grades\n  where\n    gpaToLetterGrade gpa\n      | gpa == 4.0 = \"A+\"\n      | gpa > 3.7  = \"A\"\n      | gpa > 3.3  = \"A-\"\n      | gpa > 3.0  = \"B+\"\n      | gpa > 2.7  = \"B\"\n      | gpa > 2.3  = \"B-\"\n      | gpa > 2.0  = \"C+\"\n      | gpa > 1.7  = \"C\"\n      | gpa > 1.3  = \"C-\"\n      | gpa > 1.0  = \"D+\"\n      | gpa > 0.7  = \"D\"\n      | gpa > 0.0  = \"D-\"\n      | otherwise  = \"E\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_82","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ --length рд╣реА рдПрдХ рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ рдХрд┐рдВрд╡рд╛ рдЕрдиреНрдпрдерд╛ рдЦреЛрдЯреЗ рдЖрд╣реЗ --рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдШреЗрдгрд╛рд░реЗ рдЖрдгрд┐ рд╕реНрдЯреНрд░рд┐рдВрдЧ рд╕рддреНрдп рдЕрд╕реЗрд▓ рддрд░ рд╕рддреНрдп рдкрд░рдд рдХрд░рдгрд╛рд░реЗ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛.--  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =","canonical_solution":"primeLength :: String -> Bool\nprimeLength string = isPrime (length string)\n\nisPrime :: Int -> Bool\nisPrime n\n  | n < 2     = False\n  | n == 2    = True\n  | even n    = False\n  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_83","nl":"mar_Deva","pl":"hs","prompt":"--1 рдиреЗ рд╕реБрд░реВ рд╣реЛрдгрд╛рд░реА рдХрд┐рдВрд╡рд╛ рд╕рдВрдкрдгрд╛рд░реА рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ.--ЁЯУМ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рджрд┐рд▓реЗрд▓рд╛ рдЖрд╣реЗ, рддрд░ n-рдЕрдВрдХреА рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рдкрд░рдд рджреНрдпрд╛.startsOneEnds :: Int -> Int\nstartsOneEnds n =","canonical_solution":"startsOneEnds :: Int -> Int\nstartsOneEnds n\n  | n <= 0    = 0\n  | n == 1    = 1\n  | otherwise = 18 * 10^(n-2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_84","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг --ЁЯУМ рдПрдХ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ N рджрд┐рд▓реЗрд▓рд╛ рдЖрд╣реЗ, рддреНрдпрд╛рдЪреЗ рдЕрдВрдХрд╛рдВрдЪреЗ рдПрдХреВрдг рдмреЗрд░реАрдЬ рдмрд╛рдпрдирд░реАрдордзреНрдпреЗ рдкрд░рдд рдХрд░рд╛.--  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 тЙд N тЙд 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =","canonical_solution":"solve :: Int -> String\nsolve N = toBinary (sumOfDigits N)\n  where\n    sumOfDigits 0 = 0\n    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)\n\n    toBinary 0 = \"0\"\n    toBinary n = reverse (toBinary' n)\n      where\n        toBinary' 0 = \"\"\n        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_85","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --l. рдкреНрд░рдердо рд╡рд┐рд╖рдо рд╕рдВрдЦреНрдпрд╛ рдЕрд╕рд▓реЗрд▓реНрдпрд╛ рд╕рдо рд╕рдВрдЦреНрдпрд╛ рдЬреЛрдбреВ.--  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =","canonical_solution":"add :: [Int] -> Int\nadd lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_86","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЯреАрдк: рд╡рд╛рдХреНрдпрд╛рддреАрд▓ рд╢рдмреНрдж рдЖрдгрд┐ рд░рд┐рдХреНрдд рдЬрд╛рдЧрд╛рдВрдЪреА рдХреНрд░рдорд╡рд╛рд░реА рддреБрдореНрд╣реА рдкрд╛рд│рд▓реА рдкрд╛рд╣рд┐рдЬреЗ.--ASCII рдореВрд▓реНрдпрд╛рд╡рд░ рдЖрдзрд╛рд░рд┐рдд рд╡рд╛рдврддреА рдХреНрд░рдорд╡рд╛рд░реА.--рдирд╡реАрди рд╢рдмреНрджрд╛рджреНрд╡рд╛рд░реЗ рдмрджрд▓рд▓реЗ рдЬрд╛рддрд╛рдд рдЬреНрдпрд╛рдордзреНрдпреЗ рд╕рд░реНрд╡ рд╡рд░реНрдг  рдордзреНрдпреЗ рд╡реНрдпрд╡рд╕реНрдерд┐рдд рдХреЗрд▓реЗ рдЬрд╛рддрд╛рдд--рд╕реНрдЯреНрд░рд┐рдВрдЧрдЪреА рдСрд░реНрдбрд░ рдХреЗрд▓реЗрд▓реА рдЖрд╡реГрддреНрддреА рд╣реА рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрд╣реЗ рдЬрд┐рдереЗ рд╕рд░реНрд╡ рд╢рдмреНрдж (рд╕реНрдкреЗрд╕рджреНрд╡рд╛рд░реЗ рд╡рд┐рднрдХреНрдд) --рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдШреЗрдгрд╛рд░реЗ рдЖрдгрд┐ рддреНрдпрд╛рдЪреА рдСрд░реНрдбрд░ рдХреЗрд▓реЗрд▓реА рдЖрд╡реГрддреНрддреА рдкрд░рдд рдХрд░рдгрд╛рд░реЗ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛.--  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =","canonical_solution":"import Data.List (sort)\nimport Data.Char (isAlpha)\n\nantiShuffle :: String -> String\nantiShuffle s = unwords $ map sortWord (wordsAndSpaces s)\n  where\n    sortWord word = if all isAlpha word then sort word else word\n    wordsAndSpaces [] = []\n    wordsAndSpaces xs = if head xs == ' ' \n                        then \" \" : wordsAndSpaces (dropWhile (== ' ') xs)\n                        else let (word, rest) = break (== ' ') xs\n                             in word : wordsAndSpaces rest","tests":"\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_87","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рддрд╕реЗрдЪ, рдкрдВрдХреНрддреАрдЪреЗ рд╕рдордиреНрд╡рдп рдШрдЯрддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рд╕реНрддрдВрднрд╛рджреНрд╡рд╛рд░реЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛.--рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рд╕реБрд░реБрд╡рд╛рддреАрд▓рд╛ рд╡рд╛рдврддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рдкрдВрдХреНрддреАрдиреБрд╕рд╛рд░ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛.--рдкреНрд░рддреНрдпреЗрдХ рдЯрдкрд▓ рдПрдХ рд╕рдордиреНрд╡рдп рдЖрд╣реЗ - (рдкрдВрдХреНрддреА, рд╕реНрддрдВрдн), 0 рдиреЗ рд╕реБрд░реВ рд╣реЛрддреЗ.--рдЖрдгрд┐ рдЯреНрдпреВрдкрд▓реНрд╕рдЪреА рдпрд╛рджреА рдкрд░рдд рдХрд░рддреЗ, [(x1, y1), (x2, y2) ...] рдЕрд╢рд╛ рдкреНрд░рдХрд╛рд░реЗ рдХреА --lst, рдЖрдгрд┐ рдкреВрд░реНрдгрд╛рдВрдХ x рджрд┐рд▓реЗрд▓рд╛, рдпрд╛рджреАрддреАрд▓ рдкреВрд░реНрдгрд╛рдВрдХ x рд╢реЛрдзрд╛, --рдкреНрд░рддреНрдпреЗрдХ рдкрдВрдХреНрддреАрдордзреНрдпреЗ рднрд┐рдиреНрди рд╕рдВрдЦреНрдпрд╛рддреАрд▓ рд╕реНрддрдВрдн рдЕрд╕реВ рд╢рдХрддрд╛рдд.--рдЬреЗ рдореЕрдЯреНрд░рд┐рдХреНрд╕ рд╕рд╛рд░рдЦреЗ рдЖрд╣реЗ, рдкрдг рдореЕрдЯреНрд░рд┐рдХреНрд╕рдЪреНрдпрд╛ рд╡рд┐рдкрд░реАрдд,--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рджреНрд╡рд┐-рдЖрдпрд╛рдореА рдбреЗрдЯрд╛ рджрд┐рд▓рд╛ рдЬрд╛рддреЛ, рдПрдХ рдиреЗрд╕реНрдЯреЗрдб рд▓рд┐рд╕реНрдЯ рдореНрд╣рдгреВрди,--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =","canonical_solution":"getRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x = concatMap processRow (zip [0..] lst)\n  where\n    processRow (rowIndex, row) = \n      let colIndices = reverse $ findIndices (== x) row\n      in [(rowIndex, colIndex) | colIndex <- colIndices]\n\nfindIndices :: (a -> Bool) -> [a] -> [Int]\nfindIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_88","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --* рджрд┐рд▓реЗрд▓реА рдпрд╛рджреА рдмрджрд▓реВ рдирдХрд╛.--рдЯреАрдк:--рдХрд┐рдВрд╡рд╛ рддреЗ рдЙрддрд░рддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛ рдЬрд░ рдмреЗрд░реАрдЬ ((рдкреНрд░рдердо рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рдореВрд▓реНрдп, рд╢реЗрд╡рдЯрдЪреЗ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рдореВрд▓реНрдп) рд╕рдо рдЕрд╕реЗрд▓.--рдЖрдкрдг рджрд┐рд▓реЗрд▓реА рдпрд╛рджреА рд╡рд╛рдврддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛рд▓ рдЬрд░ рдмреЗрд░реАрдЬ ((рдкреНрд░рдердо рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рдореВрд▓реНрдп, рд╢реЗрд╡рдЯрдЪреЗ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рдореВрд▓реНрдп) рд╡рд┐рд╖рдо рдЕрд╕реЗрд▓, -- рдирдХрд╛рд░рд╛рддреНрдордХ рдирд╕рд▓реЗрд▓реНрдпрд╛ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рджрд┐рд▓реНрдпрд╛рд╕, рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реНрдпрд╛рдирдВрддрд░ рджрд┐рд▓реЗрд▓реНрдпрд╛ рдпрд╛рджреАрддреАрд▓ рдПрдХ рдХреЛрд╣ рдкрд░рдд рдХрд░рд╛, --  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =","canonical_solution":"sortArray :: [Int] -> [Int]\nsortArray array\n  | null array = array\n  | otherwise =\n    let first = head array\n        last = last array\n        sumFirstLast = first + last\n    in if odd sumFirstLast\n       then sort array\n       else reverse (sort array)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_89","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рджреЛрди рдЧреБрдгрд╛рдВрдиреА рджреЛрди рдард┐рдХрд╛рдгреА рдЦрд╛рд▓реА рд╕рд░рдХрдгреЗ.--рдЕрдХреНрд╖рд░реЗ рдЕрд╢рд╛ рдкреНрд░рдХрд╛рд░реЗ рдлрд┐рд░рд╡рд▓реА рдкрд╛рд╣рд┐рдЬреЗрдд рдХреА рдЕрдХреНрд╖рд░реЗ --рдЕрдХреНрд╖рд░реЗ рдлрд┐рд░рд╡реВрди рдПрдиреНрдХреНрд░рд┐рдкреНрдЯ рдХреЗрд▓реЗрд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рддреЗ.--рдПрдХ рдлрдВрдХреНрд╢рди рдПрдиреНрдХреНрд░рд┐рдкреНрдЯ рддрдпрд╛рд░ рдХрд░рд╛ рдЬреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧрд▓рд╛ рддрд░реНрдХ рдореНрд╣рдгреВрди рдШреЗрддреЗ рдЖрдгрд┐--  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =","canonical_solution":"encrypt :: String -> String\nencrypt s = map shiftChar s\n  where\n    shiftChar c\n      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')\n      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_90","nl":"mar_Deva","pl":"hs","prompt":"--рдЬрд░ рдЕрд╕реЗ рдШрдЯрдХ рдирд╕реЗрд▓ рддрд░ рдХрд╛рд╣реАрд╣реА рдкрд░рдд рдХрд░реВ рдирдХрд╛.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ next_smallest (() рдЬреЗ рдпрд╛рджреАрддреАрд▓ 2 рд╡реНрдпрд╛ рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рдШрдЯрдХрд╛рдЪреЗ рдкреБрдирд░рд╛рдЧрдорди рдХрд░рддреЗ.-- рддреБрдореНрд╣рд╛рд▓рд╛ рдкреВрд░реНрдгрд╛рдВрдХ рджрд┐рд▓реЗ рдЖрд╣реЗрдд.--  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =","canonical_solution":"nextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =\n  let uniqueSorted = removeDuplicates $ quicksort lst\n  in if length uniqueSorted < 2\n     then Nothing\n     else Just (uniqueSorted !! 1)\n\nremoveDuplicates :: (Ord a) => [a] -> [a]\nremoveDuplicates = foldr (\\x acc -> if x `elem` acc then acc else x : acc) []\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_91","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рд╡рд╛рдХреНрдп '', '?' рдХрд┐рдВрд╡рд╛ '! ' рдиреЗ рд╡рд┐рднрдХреНрдд рдХреЗрд▓реЗ рдЬрд╛рддрд╛рдд.--рдХрдВрдЯрд╛рд│рд╡рд╛рдгреЗрдкрдгрд╛ рд╣рд╛ \"рдореА\" рдпрд╛ рд╢рдмреНрджрд╛рдкрд╛рд╕реВрди рд╕реБрд░реВ рд╣реЛрдгрд╛рд░рд╛ рд╡рд╛рдХреНрдп рдЖрд╣реЗ.--рддреБрдореНрд╣рд╛рд▓рд╛ рд╢рдмреНрджрд╛рдВрдЪреА рдПрдХ рд╕рд╛рдЦрд│реА рджрд┐рд▓реА рдЬрд╛рдИрд▓, рдЖрдгрд┐ рддреБрдордЪреЗ рдХрд╛рдо рдЖрд╣реЗ рд╕рдВрдЦреНрдпрд╛ рдореЛрдЬрдгреЗ.--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =","canonical_solution":"isBored :: String -> Int\nisBored s = length $ filter (startsWithI . words) $ splitSentences s\n  where\n    splitSentences :: String -> [String]\n    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters \".?!\"\n    \n    splitOnDelimiters :: String -> String -> [String]\n    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of\n      \"\" -> []\n      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''\n    \n    startsWithI :: [String] -> Bool\n    startsWithI [] = False\n    startsWithI (x:_) = map toLower x == \"i\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_92","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ --рдЗрддрд░ рдХреЛрдгрддреНрдпрд╛рд╣реА рдмрд╛рдмрддреАрдд false рдкрд░рдд рдХрд░рддреЗ.--рдЬрд░ рдПрдХ рд╕рдВрдЦреНрдпрд╛ рдЗрддрд░ рджреЛрди рд╕рдВрдЦреНрдпреЗрдЪреНрдпрд╛ рдмреЗрд░реАрдЬрдЪреНрдпрд╛ рдмрд░реЛрдмрд░ рдЕрд╕реЗрд▓ рдЖрдгрд┐ рд╕рд░реНрд╡ рд╕рдВрдЦреНрдпрд╛ рдкреВрд░реНрдгрд╛рдВрдХ рдЕрд╕рддреАрд▓ рддрд░ рд╕рддреНрдп рдкрд░рдд рдХрд░рддреЗ.--рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреНрдпрд╛рдд рей рд╕рдВрдЦреНрдпрд╛ рдЕрд╕рддреАрд▓.--  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =","canonical_solution":"anyInt :: Float -> Float -> Float -> Bool\nanyInt x y z\n  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =\n      x == y + z || y == x + z || z == x + y\n  | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_93","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдлрдХреНрдд рдЕрдХреНрд╖рд░реЗ рдЧреГрд╣реАрдд рдзрд░рд╛.--рдЗрдВрдЧреНрд░рдЬреА рд╡рд░реНрдгрдорд╛рд▓рд╛ рдордзреНрдпреЗ рд╕реНрд╡рд░.--рддреНрдпрд╛ рдЖрдзреА рджреЛрди рдард┐рдХрд╛рдгреА рджрд┐рд╕рдгрд╛рд░реЗ рдЕрдХреНрд╖рд░ рдЕрд╕рд▓реЗрд▓рд╛ рдореЗрд╕реЗрдЬ --рдЬреНрдпрд╛рдореБрд│реЗ рд╕рд░реНрд╡ рдЕрдХреНрд╖рд░рд╛рдВрдЪреА рдХреЗрд╕ рдмрджрд▓рд▓реА рдЬрд╛рддреЗ, рд╕рд░реНрд╡ рд╕реНрд╡рд░ рдмрджрд▓рд▓реЗ рдЬрд╛рддрд╛рдд.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рд╕рдВрджреЗрд╢ рдШреЗрддреЗ рдЖрдгрд┐ рдЕрд╢рд╛ рдкреНрд░рдХрд╛рд░реЗ рдПрдиреНрдХреЛрдб рдХрд░рддреЗ.--  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =","canonical_solution":"encode :: String -> String\nencode = map transformChar\n  where\n    transformChar :: Char -> Char\n    transformChar c\n      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c\n      | otherwise      = swapCase c c\n      where\n        lowerC = toLower c\n\n    isVowel :: Char -> Bool\n    isVowel c = c `elem` \"aeiou\"\n\n    swapCase :: Char -> Char -> Char\n    swapCase origC c\n      | isUpper origC = toLower c\n      | otherwise     = toUpper c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_94","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рддреБрдореНрд╣рд╛рд▓рд╛ рд╕рд░реНрд╡рд╛рдд рдореЛрдареА рдкреНрд░рд╛рдЗрдо рд╡реНрд╣реЕрд▓реНрдпреВ рд╢реЛрдзрд╛рд╡реА рд▓рд╛рдЧреЗрд▓ рдЖрдгрд┐ рддреНрдпрд╛рдЪреНрдпрд╛ рдЕрдВрдХрд╛рдВрдЪреА рдмреЗрд░реАрдЬ рдкрд░рдд рдХрд░рд╛рд╡реА рд▓рд╛рдЧреЗрд▓.-- рддреБрдореНрд╣рд╛рд▓рд╛ рдкреВрд░реНрдгрд╛рдВрдХ рджрд┐рд▓реЗ рдЖрд╣реЗрдд.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =","canonical_solution":"skjkasdkd :: [Int] -> Int\nskjkasdkd lst = sumDigits (largestPrime lst)\n\n-- Function to check if a number is prime\nisPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]\n\n-- Integer square root using binary search, O(log n)\nisqrt :: Int -> Int\nisqrt n = floor . sqrt $ fromIntegral n\n\n-- Function to find the largest prime in the list\nlargestPrime :: [Int] -> Int\nlargestPrime = foldr (\\x acc -> if isPrime x && x > acc then x else acc) 0\n\n-- Function to calculate the sum of the digits of a number\nsumDigits :: Int -> Int\nsumDigits 0 = 0\nsumDigits n = n `mod` 10 + sumDigits (n `div` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_95","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдлрдВрдХреНрд╢рдирдиреЗ False рд░рд┐рдЯрд░реНрди рдХреЗрд▓реЗ рдкрд╛рд╣рд┐рдЬреЗ, рдЬрд░ рджрд┐рд▓реЗрд▓реА рдЕрд╕реЛрд╕рд┐рдПрд╢рди рд▓рд┐рд╕реНрдЯ рд░рд┐рдХреНрдд рдЕрд╕реЗрд▓.--case рдХрд┐рдВрд╡рд╛ рд╕рд░реНрд╡ рдХреА рдЕрдкрд░рдХреЗрд╕ рдордзреНрдпреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдЖрд╣реЗрдд, рдЕрдиреНрдпрдерд╛ False рдкрд░рдд рдХрд░рд╛.-- рдПрдХ рд╕рдВрдШрдЯрдирд╛ рдпрд╛рджреА рджрд┐рд▓реНрдпрд╛рд╕, рд╕рд░реНрд╡ рдХрд│рд╛ рдХрдореА рдордзреНрдпреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрд╣реЗрдд рддрд░ рдЦрд░реЗ рдкрд░рдд --  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =","canonical_solution":"import Data.Char (isUpper, isLower)\n\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase [] = False\ncheckDictCase dict = all isLower allKeys || all isUpper allKeys\n  where\n    allKeys = concatMap fst dict","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_96","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдкреВрд░реНрдгрд╛рдВрдХ рдЬреЗ рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗрдд рдЖрдгрд┐ n рдкреЗрдХреНрд╖рд╛ рд▓рд╣рд╛рди рдЖрд╣реЗрдд.--рдПрдХ рдлрдВрдХреНрд╢рди рдХрд╛рд░реНрдпрд╛рдиреНрд╡рд┐рдд рдХрд░рд╛ рдЬреА рдПрдХ рдиреЙрди-рдирдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рдШреЗрддреЗ рдЖрдгрд┐ рдкрд╣рд┐рд▓реНрдпрд╛ n рдЪреА рд╕реВрдЪреА рдкрд░рдд рдХрд░рддреЗ.--  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =","canonical_solution":"countUpTo :: Int -> [Int]\ncountUpTo n = filter isPrime [2..n-1]\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_97","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЗрдирдкреБрдЯ рдиреЗрд╣рдореА рд╡реИрдз рдЖрд╣реЗ рдЕрд╕реЗ рдЧреГрд╣реАрдд рдзрд░рд╛.--рддреНрдпрд╛рдВрдЪреНрдпрд╛ рдпреБрдирд┐рдЯ рдЕрдВрдХрд╛рдВрдЪреНрдпрд╛ рдЧреБрдгрд╛рдХрд╛рд░рд╛рдиреЗ.--рджреЛрди рдкреВрд░реНрдгрд╛рдВрдХ рдШреЗрдгрд╛рд░реЗ рдЖрдгрд┐ рдкрд░рдд рдпреЗрдгрд╛рд░реЗ рдлрдВрдХреНрд╢рди рдкреВрд░реНрдг рдХрд░рд╛.--  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =","canonical_solution":"multiply :: Int -> Int -> Int\nmultiply a b = (abs a `mod` 10) * (abs b `mod` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_98","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: -- рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ s рджрд┐рд▓реЗрд▓реА рдЖрд╣реЗ, рддрд░ рд╕рдо рд╕реВрдЪрдХрд╛рдВрдордзреНрдпреЗ рдореЛрдареНрдпрд╛ рд╕реНрд╡рд░ рд╕рдВрдЦреНрдпрд╛ рдореЛрдЬреВрди рдШреНрдпрд╛.--  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =","canonical_solution":"countUpper :: String -> Int\ncountUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` \"AEIOU\"]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_99","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ --рджреЛрди рдкреВрд░реНрдгрд╛рдВрдХ, рд╢реВрдиреНрдп рдкрд╛рд╕реВрди рджреВрд░ рдЧреЛрд▓.--рдЖрдгрд┐ рддреНрдпрд╛рд▓рд╛ рд╕рд░реНрд╡рд╛рдд рдЬрд╡рд│рдЪрд╛ рдкреВрд░реНрдгрд╛рдВрдХ рджреЗрддреЛ. рдЬрд░ рд╕рдВрдЦреНрдпрд╛ рд╕рдорд╛рди рдЕрдВрддрд░рд╛рд╡рд░ рдЕрд╕реЗрд▓ рддрд░ --ЁЯУМ рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреА рдПрдХ рд╕рдВрдЦреНрдпрд╛ рджрд░реНрд╢рд╡рд┐рдгрд╛рд░реА рдПрдХ рдореВрд▓реНрдп (рд╕реНрдЯреНрд░рд┐рдВрдЧ) рдШреЗрддреЗ.--  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =","canonical_solution":"closestInteger :: String -> Int\nclosestInteger value = \n  let n = read value :: Double\n  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_100","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --i рд╣реЗ рд╕реНрддрд░рд╛рд╡рд░реАрд▓ рджрдЧрдбрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рджрд░реНрд╢рд╡рддреЗ (i+1).--рдпрд╛рджреАрддреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рд╕реНрддрд░рд╛рд╡рд░реАрд▓ рджрдЧрдбрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рдкрд░рдд рдХрд░рд╛, рдЬрд┐рдереЗ рдШрдЯрдХ --- рдкреБрдвреАрд▓ рд╕рдВрдЦреНрдпрд╛ рдЬрд░ n рд╕рдо рдЕрд╕реЗрд▓ рддрд░.--- рдкреБрдвреАрд▓ рд╡рд┐рд╖рдо рд╕рдВрдЦреНрдпрд╛ рдЬрд░ n рд╡рд┐рд╖рдо рдЕрд╕реЗрд▓ рддрд░.--рдкреБрдвреАрд▓ рд╕реНрддрд░рд╛рд╡рд░реАрд▓ рджрдЧрдбрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛: --рдкрд╣рд┐рд▓реНрдпрд╛ рд╕реНрддрд░рд╛рд╡рд░ n рджрдЧрдб рдЖрд╣реЗрдд.-- рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рджрд┐рд▓реНрдпрд╛рд╕, рддреБрдореНрд╣рд╛рд▓рд╛ n рд╕реНрддрд░рд╛рдВрдЪреЗ рджрдЧрдб рдмрдирд╡рд╛рдпрдЪреЗ рдЖрд╣реЗрдд.--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =","canonical_solution":"makeAPile :: Int -> [Int]\nmakeAPile n = take n [n, n + 2 ..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_101","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рд╕реНрдЯреНрд░рд┐рдВрдЧрд▓рд╛ рд╢рдмреНрджрд╛рдВрдордзреНрдпреЗ рд╡рд┐рднрд╛рдЬрд┐рдд рдХрд░рдгреЗ рдЖрдгрд┐ рд╢рдмреНрджрд╛рдВрдЪреА рдпрд╛рджреА рдкрд░рдд рдХрд░рдгреЗ.--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╢рдмреНрджрдорд╛рд▓рд╛ рджрд┐рд▓реА рдЬрд╛рдИрд▓ рдЬреА рдХрдорд╛ рдХрд┐рдВрд╡рд╛ рд╕реНрдкреЗрд╕рдиреЗ рд╡рд┐рднрдХреНрдд рдХреЗрд▓реА рдЬрд╛рдИрд▓. рддреБрдордЪреЗ рдХрд╛рдо рдЖрд╣реЗ --  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =","canonical_solution":"wordsString :: String -> [String]\nwordsString s = words $ map (\\c -> if c == ',' then ' ' else c) s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_102","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЕрд╢реА рд╕рдВрдЦреНрдпрд╛ рдирд╕реЗрд▓ рддрд░ рдлрдВрдХреНрд╢рдирд▓рд╛ -1 рдкрд░рдд рдорд┐рд│рд╛рдпрд▓рд╛ рд╣рд╡реЗ.--рд╕рд░реНрд╡рд╛рдд рдореЛрдареА рд╕рдо рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛ рдЬреА [x, y] рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рд╢реНрд░реЗрдгреАрдд рдЖрд╣реЗ. рдЬрд░ --рд╣реЗ рдлрдВрдХреНрд╢рди рджреЛрди рд╕рдХрд╛рд░рд╛рддреНрдордХ рд╕рдВрдЦреНрдпрд╛ x рдЖрдгрд┐ y рдШреЗрддреЗ рдЖрдгрд┐ --  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =","canonical_solution":"chooseNum :: Int -> Int -> Int\nchooseNum x y\n    | x > y = -1\n    | even upperBound = upperBound\n    | even (upperBound - 1) = upperBound - 1\n    | otherwise = -1\n  where\n    upperBound = max x y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_104","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЯреАрдкрдГ рдкрд░рдд рдЖрд▓реЗрд▓реНрдпрд╛ рдпрд╛рджреАрдордзреНрдпреЗ рд╡рд╛рдврддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛рд╡реА.--рдЬреНрдпрд╛рдд рдХреЛрдгрддреЗрд╣реА рд╕рдо рдЕрдВрдХ рдирд╛рд╣реА.-- рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ x рдЪреА рдпрд╛рджреА рджрд┐рд▓реА рдЖрд╣реЗ. рд╕рд░реНрд╡  рдЪреА рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛.--  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =","canonical_solution":"uniqueDigits :: [Int] -> [Int]\nuniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_105","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдПрдХ, рджреЛрди, рддреАрди, рдЪрд╛рд░, рдкрд╛рдЪ, рд╕рд╣рд╛, рд╕рд╛рдд, рдЖрда, рдирдК.--рдкрд░рд┐рдгрд╛рдореА рдпрд╛рджреА рдЙрд▓рдЯ рдХрд░рд╛, рдЖрдгрд┐ рдирдВрддрд░ рдкреНрд░рддреНрдпреЗрдХ рдЕрдВрдХрд╛рдЪреЗ рддреНрдпрд╛рддреАрд▓ рд╕рдВрдмрдВрдзрд┐рдд рдирд╛рд╡ рдмрджрд▓реВрди рдШреНрдпрд╛.--ЁЯУМ рдкреВрд░реНрдгрд╛рдВрдХ рд╕реВрдЪреА рджрд┐рд▓реА рдЖрд╣реЗ, 1 рддреЗ 9 рдпрд╛ рджрд░рдореНрдпрд╛рди рдЕрд╕рдгрд╛рд▒реНрдпрд╛ рдкреВрд░реНрдгрд╛рдВрдХ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛,--  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the list is empty, return an empty list:\n--  >>> byLength []\n--  []\n--  If the list has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =","canonical_solution":"byLength :: [Int] -> [String]\nbyLength arr = map digitName . reverse . sort . filter isValid $ arr\n  where\n    isValid x = x >= 1 && x <= 9\n    digitName x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"\n      _ -> error \"Unexpected number\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_106","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --i рдЪреЗ рдЧреБрдгрдирдЦрдВрдб рдореНрд╣рдгрдЬреЗ 1 рддреЗ i рдкрд░реНрдпрдВрддрдЪреНрдпрд╛ рд╕рдВрдЦреНрдпрд╛рдВрдЪреЗ рдЧреБрдгрдирдЦрдВрдб (1 * 2 * . . . * i).--рдореА 1 рдкрд╛рд╕реВрди рд╕реБрд░реВ рдХрд░рддреЛ.--рдХрд┐рдВрд╡рд╛ 1 рддреЗ i рдкрд░реНрдпрдВрддрдЪреНрдпрд╛ рд╕рдВрдЦреНрдпреЗрдЪреА рдмреЗрд░реАрдЬ.--рдЖрдгрд┐ рдЖрдХрд╛рд░ n рдЪреА рдпрд╛рджреА рдкрд░рдд рдХрд░рддреЗ, рдЬрд╕реЗ рдХреА рдЗрдВрдбреЗрдХреНрд╕ i рдордзреАрд▓ рдШрдЯрдХрд╛рдЪреЗ рдореВрд▓реНрдп i рдЪреЗ рдлреЕрдХреНрдЯреЛрд░рд┐рдпрд▓ рдЖрд╣реЗ рдЬрд░ i рд╕рдо рдЕрд╕реЗрд▓ рддрд░ --f рд╣реЗ рдлрдВрдХреНрд╢рди рд▓рд╛рдЧреВ рдХрд░рд╛ рдЬреЗ n рд▓рд╛ рдкреЕрд░рд╛рдореАрдЯрд░ рдореНрд╣рдгреВрди рдШреЗрддреЗ,--  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =","canonical_solution":"f :: Int -> [Int]\nf n = map g [1..n]\n  where\n    g i\n      | even i    = factorial i\n      | otherwise = sum [1..i]\n    \n    factorial 0 = 1\n    factorial m = product [1..m]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_107","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг 1: --рдкреВрд░реНрдгрд╛рдВрдХ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо рдЬреЗ рд╢реНрд░реЗрдгреАрдордзреНрдпреЗ рдпреЗрддрд╛рдд ((1, n), рд╕рдорд╛рд╡рд┐рд╖реНрдЯ.--ЁЯУМ рдПрдХ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рджрд┐рд▓реНрдпрд╛рд╕, рдПрдХ рдЯрдкрд▓ рдкрд░рдд рдХрд░рд╛ рдЬреНрдпрд╛рдд рд╕рдо рд╡ рд╡рд┐рд╖рдо рд╕рдВрдЦреНрдпрд╛ рдЕрд╕реЗрд▓.--  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =","canonical_solution":"evenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n = (length evens, length odds)\n  where\n    isPalindrome x = show x == reverse (show x)\n    palindromes = filter isPalindrome [1..n]\n    evens = filter even palindromes\n    odds  = filter odd palindromes","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_108","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛. -123 рдордзреНрдпреЗ -1, 2, рдЖрдгрд┐ 3 рд╣реЗ рдЕрдВрдХ рдЖрд╣реЗрдд.--рдЬрд░ рд╕рдВрдЦреНрдпрд╛ рдирдХрд╛рд░рд╛рддреНрдордХ рдЕрд╕реЗрд▓ рддрд░, рддреНрдпрд╛рдЪреЗ рдкрд╣рд┐рд▓реЗ рдЪрд┐рдиреНрд╣ рдЕрд╕рд▓реЗрд▓реЗ рдЕрдВрдХ рдирдХрд╛рд░рд╛рддреНрдордХ рдЕрд╕реЗрд▓: --рдЬреНрдпрд╛ рдШрдЯрдХрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рдЕрдВрдХрд╛рдВрдЪреА рдмреЗрд░реАрдЬ рдЖрд╣реЗ > реж.--рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ count_nums рдЬреЗ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рдШреЗрддреЗ рдЖрдгрд┐ рдкрд░рдд рдХрд░рддреЗ.--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =","canonical_solution":"countNums :: [Int] -> Int\ncountNums arr = length $ filter ((> 0) . sumDigits) arr\n  where\n    sumDigits 0 = 0\n    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)\n                  in sum digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_109","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдиреЛрдЯ: рджрд┐рд▓реЗрд▓реНрдпрд╛ рдпрд╛рджреАрдд рдЕрджреНрд╡рд┐рддреАрдп рдШрдЯрдХ рдЕрд╕рд▓реНрдпрд╛рдЪреА рд╣рдореА рдЖрд╣реЗ.--рджрд┐рд▓реЗрд▓реА рдпрд╛рджреА рд░рд┐рдХреНрдд рдЕрд╕рд▓реНрдпрд╛рд╕ True рдкрд░рдд рдХрд░рд╛.--рддрд░ True рдкрд░рдд рдХрд░рд╛ рдЕрдиреНрдпрдерд╛ False рдкрд░рдд рдХрд░рд╛.--рдЬрд░ рд╡рд░реАрд▓ рдСрдкрд░реЗрд╢рди рдХрд░реВрди рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реА рдпрд╛рджреА рдорд┐рд│рд╡рдгреЗ рд╢рдХреНрдп рдЕрд╕реЗрд▓ рддрд░ --рдпрд╛рджреАрддреАрд▓ рдкреНрд░рд╛рд░рдВрднрд┐рдХ рд╕реНрдерд╛рди рдореНрд╣рдгрдЬреЗрдЪ реж рд╡реНрдпрд╛ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ.--рдпрд╛рджреАрддреАрд▓ рд╢реЗрд╡рдЯрдЪрд╛ рдШрдЯрдХ  рдордзреНрдпреЗ рд╣рд▓рд╡рд▓рд╛ рдЬрд╛рдИрд▓--рдЙрдЬрд╡реАрдХрдбреЗ рд╕рд░рдХрдгреНрдпрд╛рдЪреА рдПрдХ рдХреНрд░рд┐рдпрд╛ рдореНрд╣рдгрдЬреЗ рд╕реВрдЪреАрддреАрд▓ рд╕рд░реНрд╡ рдШрдЯрдХрд╛рдВрдирд╛ рдПрдХрд╛рдиреЗ рд╕рд░рдХрд╡рдгреЗ.--рддреБрдореНрд╣рд╛рд▓рд╛ рдЙрдЬрд╡реАрдХрдбреЗ рд╡рд│рдгреНрдпрд╛рдЪреА рдСрдкрд░реЗрд╢рди рдХрд┐рддреАрд╣реА рд╡реЗрд│рд╛ рдХрд░реВ рд╢рдХрддрд╛.--рджрд┐рд▓реЗрд▓реНрдпрд╛ рдпрд╛рджреАрддреАрд▓ рдЦрд╛рд▓реАрд▓ рдСрдкрд░реЗрд╢рди: -- рд╣реЗ рдХрд░реВрди рд╕реВрдЪреА рдХрдореА рди рд╣реЛрдгрд╛рд▒реНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рдгреЗ рд╢рдХреНрдп рдЖрд╣реЗ.--рдпрд╛рджреАрддреАрд▓ рд╕рдВрдЦреНрдпрд╛ рдпрд╛рджреГрдЪреНрдЫрд┐рдХрдкрдгреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реА рдЬрд╛рддреАрд▓. рддреБрдордЪреЗ рдХрд╛рдо рд╣реЗ рдард░рд╡рдгреЗ рдЖрд╣реЗ рдХреА --рдЖрдкрд▓реНрдпрд╛рдХрдбреЗ рдПрдХ рд╕реВрдЪреА рдЖрд╣реЗ 'arr' N рдкреВрд░реНрдгрд╛рдВрдХ arr[1], arr[2], ..., arr[N] рдЪреА.--  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given list.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  list by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =","canonical_solution":"moveOneBall :: [Int] -> Bool\nmoveOneBall [] = True\nmoveOneBall arr = canBeSorted (arr ++ arr)\n  where\n    n = length arr\n    canBeSorted xs = any isSorted (take n <$> tails xs)\n    isSorted ys = and $ zipWith (<=) ys (tail ys)\n    tails [] = []\n    tails l@(_:xs) = l : tails xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_110","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЕрдиреНрдпрдерд╛, \"рдирд╛рд╣реА\" рдкрд░рдд рдХрд░рд╛.--lst1 рдЪреЗ рд╕рд░реНрд╡ рдШрдЯрдХ рд╕рдо рдЕрд╕рд╛рд╡реЗрдд, \"YES\" рдкрд░рдд рдХрд░рд╛.--рдЬрд░ lst1 рдЖрдгрд┐ lst2 рджрд░рдореНрдпрд╛рди рдШрдЯрдХ рдмрджрд▓рдгреЗ рд╢рдХреНрдп рдЕрд╕реЗрд▓ рддрд░ --lst1 рдЖрдгрд┐ lst2 рджрд░рдореНрдпрд╛рди рдмрджрд▓рд▓реЗрд▓реНрдпрд╛ рдШрдЯрдХрд╛рдВрдЪреНрдпрд╛ рд╕рдВрдЦреНрдпреЗрд╡рд░ рдХреЛрдгрддреАрд╣реА рдорд░реНрдпрд╛рджрд╛ рдирд╛рд╣реА.--рдлрдХреНрдд рдЬреЛрдбреНрдпрд╛ рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рдмрдирд╡рдгреНрдпрд╛рд╕рд╛рдареА.--рдЖрдгрд┐ рдШрдЯрдХ рджреЗрд╡рд╛рдгрдШреЗрд╡рд╛рдг рдХрд░рдгреЗ рд╢рдХреНрдп рдЖрд╣реЗ рдХрд╛ рд╣реЗ рдард░рд╡рддреЗ .--рдпрд╛ рд╕рдорд╕реНрдпреЗрдордзреНрдпреЗ, рдЖрдкрдг рдПрдХ рдлрдВрдХреНрд╢рди рдХрд╛рд░реНрдпрд╛рдиреНрд╡рд┐рдд рдХрд░рд╛рд▓ рдЬреА рджреЛрди рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рдШреЗрддреЗ,--  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =","canonical_solution":"exchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | all even lst1 = \"YES\"\n  | null oddLst1 || null evenLst2 = \"NO\"\n  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)\n                in if possibility then \"YES\" else \"NO\"\n  where\n    oddLst1 = filter odd lst1\n    evenLst2 = filter even lst2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_111","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдЬрд░ рдЕрдиреЗрдХ рдЕрдХреНрд╖рд░реЗ рдПрдХрд╛рдЪ рдард┐рдХрд╛рдгреА рдЕрд╕рддреАрд▓ рддрд░ рддреНрдпрд╛ рд╕рд░реНрд╡ рдкрд░рдд рдХрд░рд╛.--рдЬреНрдпрд╛ рдЕрдХреНрд╖рд░рд╛рдЪреА рд╕рдВрдЦреНрдпрд╛ рд╕рд░реНрд╡рд╛рдзрд┐рдХ рдЖрд╣реЗ рдЖрдгрд┐ рдЬреНрдпрд╛рдд рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ.-- рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рджрд┐рд▓реЗрд▓реА рдЬреА рд╕реНрдкреЗрд╕ рд╡рд┐рднрдХреНрдд рд▓рдШреБрдХрдерд╛ рдЕрдХреНрд╖рд░реЗ рджрд░реНрд╢рд╡рддреЗ, рдПрдХ рд╕рдВрдШрдЯрдирд╛ рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛ --  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nhistogram :: String -> [(String, Int)]\nhistogram input =\n  let wordsList = words input\n      grouped = group $ sort wordsList\n      countList = map (\\ws -> (head ws, length ws)) grouped\n      maxCount = if null countList then 0 else maximum $ map snd countList\n  in filter ((== maxCount) . snd) countList","tests":"\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_112","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг --рдЖрдкрдг рдкрд░рд┐рдгрд╛рдо рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЖрдгрд┐ рд╕рддреНрдпрд╛рдкрдирд╕рд╛рдареА True\/False рдЕрд╕рд▓реЗрд▓реА рдПрдХ рдЯрдкрд▓ рдкрд░рдд рдХрд░рд╛рд╡реА.--рдПрдЦрд╛рджреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд╛рд▓рд┐рдВрдбреНрд░реЛрдо рдЕрд╕реЗ рдореНрд╣рдЯрд▓реЗ рдЬрд╛рддреЗ рдЬрд░ рддреА рдорд╛рдЧреЗ рдЖрдгрд┐ рдкреБрдвреЗ рд╕рд╛рд░рдЦреАрдЪ рд╡рд╛рдЪрд▓реА рдЬрд╛рддреЗ.--рдордЧ рдкрд░рд┐рдгрд╛рдо рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкреЕрд▓рд┐рдВрдбреНрд░реЛрдо рдЖрд╣реЗ рдХрд╛ рддреЗ рддрдкрд╛рд╕рд╛.--рдЖрдореНрд╣рд╛рд▓рд╛ рджреЛрди рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ s рдЖрдгрд┐ c рджрд┐рд▓реНрдпрд╛ рдЖрд╣реЗрдд, рддреБрдореНрд╣рд╛рд▓рд╛ s рдордзреАрд▓ рд╕рд░реНрд╡ рд╡рд░реНрдг рдХрд╛рдвреВрди рдЯрд╛рдХрд╛рд╡реЗ рд▓рд╛рдЧрддреАрд▓ рдЬреЗ c рдордзреАрд▓ рдХреЛрдгрддреНрдпрд╛рд╣реА рд╡рд░реНрдг рдмрд░реЛрдмрд░ рдЖрд╣реЗрдд.--рдХрд╛рд░реНрдп--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =","canonical_solution":"import Data.List (filter)\n\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =\n  let result = filter (`notElem` c) s\n  in (result, result == reverse result)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_113","nl":"mar_Deva","pl":"hs","prompt":"--рдЗрдирдкреБрдЯрдЪреНрдпрд╛ i'th рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рд╡рд┐рд╖рдо рдЕрдВрдХрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛.--рдЗрдирдкреБрдЯрдЪреА рд╕реНрдЯреНрд░рд┐рдВрдЧ i. \" рдЬрд┐рдереЗ рд╕рд░реНрд╡ i рдЪреА рдЬрд╛рдЧрд╛ рд╕рдВрдЦреНрдпрд╛  рдиреЗ рдШреНрдпрд╛рд╡реА.--рдЖрдЙрдЯрдкреБрдЯрдордзреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рдШрдЯрдХ i рд╣реЗ \"рдЕрдгреНрд╡рд░рд┐рдд рдШрдЯрдХрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛\" рдЕрд╕рд╛рд╡реА.-- рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдпрд╛рджреА рджрд┐рд▓реА, рдЬрд┐рдереЗ рдкреНрд░рддреНрдпреЗрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдлрдХреНрдд рдЕрдВрдХрд╛рдВрдЪреА рдЕрд╕рддреЗ, рдПрдХ рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛.--  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =","canonical_solution":"oddCount :: [String] -> [String]\noddCount lst = map formatString lst\n  where\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"\n\n    countOdds :: String -> Int\n    countOdds str = length $ filter isOddDigit str\n\n    formatString :: String -> String\n    formatString str =\n      let oddCount = countOdds str in\n      \"the number of odd elements \" ++ show oddCount ++ \n      \"n the str\" ++ show oddCount ++ \"ng \" ++ show oddCount ++\n      \" of the \" ++ show oddCount ++ \"nput.\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_114","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг ---- рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рджрд┐рд▓реА, рдХреЛрдгрддреНрдпрд╛рд╣реА рдиреЙрди-рд░рд┐рдХреНрдд рдЙрдк-рд╕реВрдЪреАрдЪреА рдХрд┐рдорд╛рди рдмреЗрд░реАрдЬ рд╢реЛрдзрд╛.--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =","canonical_solution":"minsubarraysum :: [Int] -> Int\nminsubarraysum nums = minimum $ scanl1 (\\acc x -> min x (acc + x)) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_115","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг 1: --рдЖрдкрд▓реНрдпрд╛рд▓рд╛ рдХрд┐рддреА рд╡реЗрд│рд╛ рд╡рд╛рдбрдЧрд╛ рдЦрд╛рд▓реА рдЖрдгрдгреНрдпрд╛рдЪреА рдЧрд░рдЬ рдЖрд╣реЗ рддреЗ рдЖрдЙрдЯрдкреБрдЯ рдХрд░рд╛.--рддреБрдордЪреЗ рдХрд╛рдо рдЖрд╣реЗ рддреЗ рдореНрд╣рдгрдЬреЗ рд╡рд┐рд╣рд┐рд░реА рд░рд┐рдХрд╛рдореА рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдмрд╛рджрд▓реНрдпрд╛рдВрдЪрд╛ рд╡рд╛рдкрд░ рдХрд░рдгреЗ.--рдЖрдгрд┐ рд╕рд░реНрд╡ рд╡рд╛рдбреНрдпрд╛рдВрдордзреНрдпреЗ рд╕рдорд╛рди рдХреНрд╖рдорддрд╛ рдЖрд╣реЗ.--рдкреНрд░рддреНрдпреЗрдХ рд╡рд┐рд╣рд┐рд░реАрдд рдПрдХ рдпреЛрдЧреНрдп рд╡рд╛рдбрдЧрд╛ рдЖрд╣реЗ рдЬреНрдпрд╛рдЪрд╛ рд╡рд╛рдкрд░ рддреНрдпрд╛рддреВрди рдкрд╛рдгреА рдХрд╛рдврдгреНрдпрд╛рд╕рд╛рдареА рдХреЗрд▓рд╛ рдЬрд╛рдК рд╢рдХрддреЛ.--рдЖрдгрд┐ рдкреНрд░рддреНрдпреЗрдХ 1 рд╣реЗ рдкрд╛рдгреНрдпрд╛рдЪреЗ рдПрдХрдХ рджрд░реНрд╢рд╡рддреЗ.--рддреБрдореНрд╣рд╛рд▓рд╛ рд╡рд┐рд╣рд┐рд░реАрдВрдЪреА рдПрдХ рдЖрдпрддрд╛рдХреГрддреА рдЬрд╛рд│реА рджрд┐рд▓реА рдЖрд╣реЗ. рдкреНрд░рддреНрдпреЗрдХ рдкрдВрдХреНрддреА рдПрдХрд╛ рд╡рд┐рд╣рд┐рд░реАрдЪреЗ рдкреНрд░рддрд┐рдирд┐рдзрд┐рддреНрд╡ рдХрд░рддреЗ,--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =","canonical_solution":"maxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity = ceiling (fromIntegral totalWater \/ fromIntegral capacity)\n  where\n    totalWater = sum (map sum grid)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_116","nl":"mar_Deva","pl":"hs","prompt":"--рддреНрдпрд╛рдЪреА рдЕрдВрдорд▓рдмрдЬрд╛рд╡рдгреА рдкреБрдвреАрд▓рдкреНрд░рдорд╛рдгреЗ рдХрд░рд╛рд╡реА рд▓рд╛рдЧреЗрд▓:--рдПрдХрдЪреНрдпрд╛ рд╕рдорд╛рди рд╕рдВрдЦреНрдпреЗрд╕рд╛рдареА, рджрд╢рд╛рдВрд╢ рдореВрд▓реНрдпрд╛рд╡рд░ рдЖрдзрд╛рд░рд┐рдд рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛.--рддреНрдпрд╛рдВрдЪреНрдпрд╛ рдмрд╛рдпрдирд░реА рдкреНрд░рддрд┐рдирд┐рдзрд┐рддреНрд╡рд╛рддреАрд▓ рдПрдХреАрдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рд╡рд╛рдврддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ.--рдпрд╛ рдХрд╛рддрд╛рдордзреНрдпреЗ, рддреБрдореНрд╣рд╛рд▓рд╛ рдиреЙрди-рдирдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреАрдд рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛рд╡реА рд▓рд╛рдЧреЗрд▓.--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =","canonical_solution":"import Data.Bits (popCount)\nimport Data.List (sortBy)\n\nsortArray :: [Int] -> [Int]\nsortArray arr = sortBy compareOnesAndValues arr\n  where\n    compareOnesAndValues x y =\n      let onesX = popCount x\n          onesY = popCount y\n      in if onesX == onesY\n         then compare x y\n         else compare onesX onesY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_117","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЯреАрдкрдГ рдЖрдкрдг рдЗрдирдкреБрдЯ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рдлрдХреНрдд рдЕрдХреНрд╖рд░реЗ рдЖрдгрд┐ рд╕реНрдкреЗрд╕ рдЖрд╣реЗрдд рдЕрд╕реЗ рдЧреГрд╣реАрдд рдзрд░реВ рд╢рдХрддрд╛.--рдЬрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ s рд░рд┐рдХреНрдд рдЕрд╕реЗрд▓ рддрд░ рдлрдВрдХреНрд╢рдирдиреЗ рд░рд┐рдХреНрдд рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛рд╡реА.--n рд╡реНрдпрдВрдЬрди, рдЕрд╢рд╛ рдХреНрд░рдорд╛рдиреЗ рдХреА рд╣реЗ рд╢рдмреНрдж рд╕реНрдЯреНрд░рд┐рдВрдЧ s рдордзреНрдпреЗ рджрд┐рд╕рддрд╛рдд.--рдПрдХ рдлрдВрдХреНрд╢рди рдЬреА string s рдордзреВрди рд╕рд░реНрд╡ рд╢рдмреНрджрд╛рдВрдЪреА рдпрд╛рджреА рдкрд░рдд рдХрд░рддреЗ рдЬреНрдпрд╛рдд рдирдХреНрдХреА --тИЩтИЩтИЩрдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ s рдЖрдгрд┐ рдПрдХ рдиреИрд╕рд░реНрдЧрд┐рдХ рд╕рдВрдЦреНрдпрд╛ n рджрд┐рд▓реЗрд▓реА рдЖрд╣реЗ, рддреБрдореНрд╣рд╛рд▓рд╛ рдЕрдВрдорд▓рдмрдЬрд╛рд╡рдгреА рдХрд░рдгреНрдпрд╛рдЪреЗ рдХрд╛рдо рджреЗрдгреНрдпрд╛рдд рдЖрд▓реЗ рдЖрд╣реЗ тИЩтИЩтИЩ--  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =","canonical_solution":"selectWords :: String -> Int -> [String]\nselectWords s n = filter (\\word -> countConsonants word == n) (words s)\n  where\n    countConsonants = length . filter (`elem` consonants)\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_118","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдЖрдкрдг рдЧреГрд╣реАрдд рдзрд░реВ рд╢рдХрддрд╛ рдХреА рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рдлрдХреНрдд рдЗрдВрдЧреНрд░рдЬреА рдЕрдХреНрд╖рд░реЗ рдЖрд╣реЗрдд.--рд╡рд░реАрд▓ рдЕрдЯ рдкреВрд░реНрдг рдХрд░рдгрд╛рд░реЗ рдХреЛрдгрддреЗрд╣реА рд╕реНрд╡рд░ рд╢реЛрдзрд╛.--рд╕реБрд░реБрд╡рд╛рддреАрд▓рд╛ рд╡ рд╢реЗрд╡рдЯреА рд╕реНрд╡рд░рд╛рдВрдЪреА рдЧрдгрдирд╛ рд╣реЛрдд рдирд╛рд╣реА. рдЬрд░ рддреБрдореНрд╣реА рддрд╕реЗ рдХреЗрд▓реЗ рдирд╛рд╣реА рддрд░ рд░рд┐рдХреНрдд рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛.--рджреЛрди рд╡реНрдпрдВрдЬрди рд╢рдмреНрджрд╛рдЪреНрдпрд╛ рдЙрдЬрд╡реНрдпрд╛ рдмрд╛рдЬреВрд▓рд╛ (рдХреЗрд╕ рд╕реЗрдиреНрд╕рд┐рдЯрд┐рд╡реНрд╣).--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╢рдмреНрдж рджрд┐рд▓рд╛ рдЖрд╣реЗ. рддреБрдордЪреЗ рдХрд╛рдо рдЖрд╣реЗ рдЬрд╡рд│рдЪрд╛ рд╕реНрд╡рд░ рд╢реЛрдзрдгреЗ рдЬреЛ  рдордзреНрдпреЗ рдЙрднрд╛ рдЖрд╣реЗ.--  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =","canonical_solution":"getClosestVowel :: String -> String\ngetClosestVowel word = go (reverse word) False\n  where\n    vowels = \"aeiouAEIOU\"\n    go [] _ = \"\"\n    go (x:xs) lastWasConsonant\n      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False\n      | x `notElem` vowels = go xs True\n      | otherwise = go xs False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_119","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЬрд░ рдПрдЦрд╛рджреА рдЪрд╛рдВрдЧрд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдмрдирд╡рдгреНрдпрд╛рдЪрд╛ рдорд╛рд░реНрдЧ рдЕрд╕реЗрд▓ рддрд░ 'рд╣реЛрдп' рдкрд░рдд рдХрд░рд╛, рдЖрдгрд┐ рдЕрдиреНрдпрдерд╛ 'рдирд╛рд╣реА' рдкрд░рдд рдХрд░рд╛.--\" (()) \" рдирд╛рд╣реА.--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: рд╕реНрдЯреНрд░рд┐рдВрдЧ '(()))) рдЪрд╛рдВрдЧрд▓реА рдЖрд╣реЗ, рддрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ --рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ S рдЪрд╛рдВрдЧрд▓реА рдорд╛рдирд▓реА рдЬрд╛рддреЗ рдЬрд░ рдЖрдгрд┐ рдлрдХреНрдд рдЬрд░ S рдордзреАрд▓ рд╕рд░реНрд╡ рдХрдВрд╕ --рдХрд╛рд╣реА рдХреНрд░рдо, рдХреА рдкрд░рд┐рдгрд╛рдореА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЪрд╛рдВрдЧрд▓реА рдЕрд╕реЗрд▓.--рддреБрдордЪреЗ рдХрд╛рдо рд╣реЗ рддрдкрд╛рд╕рдгреЗ рдЖрд╣реЗ рдХреА рджреЛрди рддрд╛рд░ рдПрдХрддреНрд░ рдЬреЛрдбрдгреЗ рд╢рдХреНрдп рдЖрд╣реЗ рдХрд╛.--рдлрдХреНрдд рдХрдВрд╕рд╛рдд \" ((\") рдХрд┐рдВрд╡рд╛ рдХрдВрд╕рд╛рдд \") \" рдЕрд╕рд╛ рд╢рдмреНрдж рд╡рд╛рдкрд░рд╛.--рддреБрдореНрд╣рд╛рд▓рд╛ рджреЛрди рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдпрд╛рджреА рджрд┐рд▓реА рдЖрд╣реЗ, рджреЛрдиреНрд╣реА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рдУрдкрди рдЖрд╣реЗрдд.--  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =","canonical_solution":"matchParens :: [String] -> String\nmatchParens [a, b] =\n    if isValid (a ++ b) || isValid (b ++ a) then \"Yes\" else \"No\"\n  where\n    isValid :: String -> Bool\n    isValid = go 0\n      where\n        go 0 [] = True\n        go _ [] = False\n        go n (x:xs)\n            | x == '('  = go (n + 1) xs\n            | x == ')'  = n > 0 && go (n - 1) xs\n    isValid _ = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_120","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг 1: --k рд▓рд╛рдВрдмреАрдЪреЗ рдЖрдгрд┐ рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд k рд╕рдВрдЦреНрдпрд╛ arr рдордзреНрдпреЗ.--ЁЯУМ рдкреВрд░реНрдгрд╛рдВрдХ arr рдЪреА рдпрд╛рджреА рдЖрдгрд┐ k рд╣реА рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рджрд┐рд▓реЗрд▓реА рдЖрд╣реЗ, рддрд░ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛.--  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the list will be in the range of [1, 1000].\n--  2. The elements in the list will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =","canonical_solution":"maximum :: [Int] -> Int -> [Int]\nmaximum arr k = take k $ reverse $ sort arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_121","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ -- рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рдЦрд╛рд▓реА рдирд╕рд▓реЗрд▓реНрдпрд╛ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреАрдордзреНрдпреЗ, рд╕рд░реНрд╡ рд╡рд┐рд╖рдо рдШрдЯрдХрд╛рдВрдЪреА рдмреЗрд░реАрдЬ рдкрд░рдд рдХрд░рд╛ рдЬреА рдЕрдЧрджреА рд╕реНрдерд┐рддреАрдд рдЖрд╣реЗрдд.--  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =","canonical_solution":"solution :: [Int] -> Int\nsolution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_122","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --arr рдЪреНрдпрд╛ рдкрд╣рд┐рд▓реНрдпрд╛ k рдШрдЯрдХрд╛рдВрдкреИрдХреА рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд рджреЛрди рдЕрдВрдХреА рдШрдЯрдХрд╛рдВрдЪреА рдмреЗрд░реАрдЬ.--рдкреВрд░реНрдгрд╛рдВрдХ arr рдЖрдгрд┐ рдкреВрд░реНрдгрд╛рдВрдХ k рдЪреА рдиреЙрди-рд░рд┐рдХреНрдд рдпрд╛рджреА рджрд┐рд▓реНрдпрд╛рд╕, рдкрд░рдд рдХрд░рд╛.--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =","canonical_solution":"addElements :: [Int] -> Int -> Int\naddElements arr k = sum $ filter (\\x -> x >= -99 && x <= 99) $ take k arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_123","nl":"mar_Deva","pl":"hs","prompt":"--get_odd_collatz(5) [1, 5] # 5 рд╕рд╛рдареА рдХреЛрд▓рд╛рдЯрдЭ рдХреНрд░рдо [5, 16, 8, 4, 2, 1], рдореНрд╣рдгреВрди рд╡рд┐рд╖рдо рд╕рдВрдЦреНрдпрд╛ рдлрдХреНрдд 1 рдЖрдгрд┐ 5 рдЖрд╣реЗрдд.--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --2. рдкрд░рдд рдЖрд▓реЗрд▓реА рдпрд╛рджреА рд╡рд╛рдврддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реА.--рез. рдХреЛрд▓рд╛рдЯрдЭ (рез) рд╣реЗ [рез] рдЖрд╣реЗ.--рдЯреАрдк:--рдЯрд░реНрдо рдкреНрд▓рд╕ рез. рдЕрдВрджрд╛рдЬ рдЕрд╕рд╛ рдЖрд╣реЗ рдХреА n рдЪреА рдХреЛрдгрддреАрд╣реА рдХрд┐рдВрдордд рдЕрд╕реЛ, рдЕрдиреБрдХреНрд░рдо рдиреЗрд╣рдореА рез рдкрд░реНрдпрдВрдд рдкреЛрд╣реЛрдЪреЗрд▓.--рдЬрд░ рдорд╛рдЧреАрд▓ рдкрдж рд╡рд┐рд╖рдо рдЕрд╕реЗрд▓ рддрд░ рдкреБрдвреАрд▓ рдкрдж рдорд╛рдЧреАрд▓ рдкрджрдЪреНрдпрд╛ 3 рдкрдЯ рдЕрд╕реЗрд▓.--рдорд╛рдЧреАрд▓ рдкрдж рдкреБрдвреАрд▓рдкреНрд░рдорд╛рдгреЗ: рдЬрд░ рдорд╛рдЧреАрд▓ рдкрдж рд╕рдо рдЕрд╕реЗрд▓ рддрд░ рдкреБрдвреАрд▓ рдкрдж рдЕрд░реНрдзрд╛ рдЖрд╣реЗ--рдЦрд╛рд▓реАрд▓рдкреНрд░рдорд╛рдгреЗ: рдХреЛрдгрддреНрдпрд╛рд╣реА рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рдиреЗ рдкреНрд░рд╛рд░рдВрдн рдХрд░рд╛. рдордЧ рдкреНрд░рддреНрдпреЗрдХ рдкрдж  рдкрд╛рд╕реВрди рдкреНрд░рд╛рдкреНрдд рд╣реЛрддреЗ.--рдХреЛрд▓рд╛рдЯреНрдЭ рдЕрдиреБрдорд╛рди рд╣реЗ рдЧрдгрд┐рддрд╛рддреАрд▓ рдПрдХ рдЕрдиреБрдорд╛рди рдЖрд╣реЗ рдЬреЗ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЕрдиреБрдХреНрд░рдорд╛рд╢реА рд╕рдВрдмрдВрдзрд┐рдд рдЖрд╣реЗ .--ЁЯУМ рдПрдХ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рджрд┐рд▓реЗрд▓рд╛ рдЖрд╣реЗ, рдПрдХ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛ рдЬреНрдпрд╛рдордзреНрдпреЗ рдХреЛрд▓рд╛рдЯреНрдЭ рдЕрдиреБрдХреНрд░рдорд╛рдордзреНрдпреЗ рд╡рд┐рд╖рдо рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗрдд.--  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =","canonical_solution":"getOddCollatz :: Int -> [Int]\ngetOddCollatz n = sort . filter odd $ collatzSequence n\n  where\n    collatzSequence 1 = [1]\n    collatzSequence x\n      | even x    = x : collatzSequence (x `div` 2)\n      | otherwise = x : collatzSequence (3 * x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_124","nl":"mar_Deva","pl":"hs","prompt":"--4. рддрд╛рд░реАрдЦ рдЦрд╛рд▓реАрд▓ рд╕реНрд╡рд░реВрдкрд╛рдд рдЕрд╕рд╛рд╡реА: рдорд┐рдореА-рдбреНрдбреНрдб-рдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕрдЕ--3. рдорд╣рд┐рдиреНрдпрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ 1 рдкреЗрдХреНрд╖рд╛ рдХрдореА рдХрд┐рдВрд╡рд╛ 12 рдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдЕрд╕реВ рдирдпреЗ.--2. рдорд╣рд┐рдиреНрдпрд╛рд╕рд╛рдареА рджрд┐рд╡рд╕рд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ 1 рдкреЗрдХреНрд╖рд╛ рдХрдореА рдХрд┐рдВрд╡рд╛ 31 рджрд┐рд╡рд╕рд╛рдВрдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдирд╕рд╛рд╡реА 1,3,5,7,8,10,12. рдЖрдгрд┐ рдорд╣рд┐рдиреНрдпрд╛рдВрд╕рд╛рдареА рджрд┐рд╡рд╕рд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ 1 рдкреЗрдХреНрд╖рд╛ рдХрдореА рдХрд┐рдВрд╡рд╛ 30 рджрд┐рд╡рд╕рд╛рдВрдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдирд╕рд╛рд╡реА 4,6,9,11. рдЖрдгрд┐ рдорд╣рд┐рдиреНрдпрд╛рд╕рд╛рдареА рджрд┐рд╡рд╕рд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ 1 рдкреЗрдХреНрд╖рд╛ рдХрдореА рдХрд┐рдВрд╡рд╛ 29 рджрд┐рд╡рд╕рд╛рдВрдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдирд╕рд╛рд╡реА 2.--1. рджрд┐рдирд╛рдВрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рд░рд┐рдХреНрдд рдирд╛рд╣реА.--рдЦрд╛рд▓реАрд▓ рд╕рд░реНрд╡ рдирд┐рдпрдорд╛рдВрдЪреЗ рдкрд╛рд▓рди рдХреЗрд▓реНрдпрд╛рд╕ рддрд╛рд░реАрдЦ рд╡реИрдз рдЖрд╣реЗ: --рдЬрд░ рддрд╛рд░реАрдЦ рд╡реИрдз рдЕрд╕реЗрд▓ рддрд░ True рдкрд░рдд рдХрд░рддреЗ рдЕрдиреНрдпрдерд╛ False.--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛рдпрдЪреЗ рдЖрд╣реЗ рдЬреА рджрд┐рд▓реЗрд▓реНрдпрд╛ рддрд╛рд░рдЦреЗрдЪреА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдорд╛рдиреНрдп рдХрд░рддреЗ рдЖрдгрд┐--  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06\/04\/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =","canonical_solution":"import Text.Read (readMaybe)\nimport Data.List.Split (splitOn)\n\nvalidDate :: String -> Bool\nvalidDate date =\n    case splitOn \"-\" date of\n        [m, d, y] -> isValidMonthDayYear m d y\n        _         -> False\n\nisValidMonthDayYear :: String -> String -> String -> Bool\nisValidMonthDayYear m d y =\n    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of\n        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day\n        _ -> False\n\nisValidMonth :: Int -> Bool\nisValidMonth month = month >= 1 && month <= 12\n\nisValidDay :: Int -> Int -> Bool\nisValidDay month day\n    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31\n    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30\n    | month == 2                           = day >= 1 && day <= 29\n    | otherwise                            = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_126","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ --рдХреНрд░рдорд╛рдВрдХ, рдЕрд╕рддреНрдп рдкрд░рдд рдХрд░рд╛. рдирдХрд╛рд░рд╛рддреНрдордХ рд╕рдВрдЦреНрдпрд╛ рдЖрдгрд┐ рдлрдХреНрдд рдкреВрд░реНрдгрд╛рдВрдХ рдЧреГрд╣реАрдд рдзрд░рд╛.--рдпрд╛рджреАрдд рдПрдХ рдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдбреБрдкреНрд▓рд┐рдХреЗрдЯ рдЕрд╕рддреАрд▓ рддрд░ -- рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рджрд┐рд▓реНрдпрд╛рд╕, рддреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реЗ рдЖрд╣реЗрдд рдХреА рдирд╛рд╣реА рддреЗ рдкрд░рдд рдХрд░рд╛.--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =","canonical_solution":"isSorted :: [Int] -> Bool\nisSorted lst = go lst Nothing\n  where\n    go [] _ = True\n    go [x] _ = True\n    go (x:y:xs) prev\n      | x > y = False\n      | x == y && prev == Just x = False\n      | otherwise = go (y:xs) (Just x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_127","nl":"mar_Deva","pl":"hs","prompt":"--[рдЗрдирдкреБрдЯ\/рдЖрдЙрдЯрдкреБрдЯ] рдирдореБрдиреЗ: --рдЬрд░ рджреЛрди рдЕрдВрддрд░рд╛рд│ рдПрдХрдореЗрдХрд╛рдВрдирд╛ рдЫреЗрджрдд рдирд╕рддреАрд▓ рддрд░ \"рдирд╛рд╣реА\" рдкрд░рдд рдХрд░рд╛.--рдирд╛рд╣реА рддрд░ \"рдирд╛рд╣реА\" рдкрд░рдд рдХрд░рд╛.--рдЬрд░ рдЫреЗрджрдирдмрд┐рдВрджреВрдЪреА рд▓рд╛рдВрдмреА рдПрдХ рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ рдЕрд╕реЗрд▓ рддрд░ \"рд╣реЛрдп\" рдкрд░рдд рдХрд░рд╛.--рдЬреНрдпрд╛рдЪреА рд▓рд╛рдВрдмреА 1 рдЖрд╣реЗ, рдЬреА рдПрдХ рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ рдирд╛рд╣реА.--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде, рдЕрдВрддрд░рд╛рд│рд╛рдЪрд╛ рдЫреЗрджрдирдмрд┐рдВрджреВ (1, 3), (2, 4) рд╣рд╛ (2, 3) рдЖрд╣реЗ.--рдЕрдВрддрд░рд╛рд▓ рд╣реА рдПрдХ рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ.--рддреБрдордЪреЗ рдХрд╛рдо рд╣реЗ рдард░рд╡рдгреЗ рдЖрд╣реЗ рдХреА рдпрд╛ рджреЛрдирдЪреНрдпрд╛ рдЫреЗрджрдирдмрд┐рдВрджреВрдЪреА рд▓рд╛рдВрдмреА --рдкреНрд░рддреНрдпреЗрдХ рджрд┐рд▓реЗрд▓реНрдпрд╛ рдЕрдВрддрд░рд╛рд╕рд╛рдареА, рдЕрд╕реЗ рдорд╛рдирд▓реЗ рдЬрд╛рддреЗ рдХреА рддреНрдпрд╛рдЪреА рд╕реБрд░реБрд╡рд╛рдд рддреНрдпрд╛рдЪреНрдпрд╛ рд╢реЗрд╡рдЯрдЪреНрдпрд╛ рддреБрд▓рдиреЗрдд рдХрдореА рдХрд┐рдВрд╡рд╛ рд╕рдорд╛рди рдЖрд╣реЗ.--рдпрд╛рдд рд╕реБрд░реБрд╡рд╛рдд рдЖрдгрд┐ рд╢реЗрд╡рдЯ рджреЛрдиреНрд╣реА рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдЖрд╣реЗрдд.--рджрд┐рд▓реЗрд▓реНрдпрд╛ рдЕрдВрддрд░рд╛рд▓рд╛ рдмрдВрдж рдХреЗрд▓реЗ рдЖрд╣реЗ рдпрд╛рдЪрд╛ рдЕрд░реНрде рдЕрд╕рд╛ рдХреА рдЕрдВрддрд░рд╛рд▓рд╛ (рд╕реБрд░реВрд╡рд╛рдд, рд╢реЗрд╡рдЯ) --рдЬрд┐рдереЗ рдкреНрд░рддреНрдпреЗрдХ рдЕрдВрддрд░ рдкреВрд░реНрдгрд╛рдВрдХ рдЬреЛрдб рдЖрд╣реЗ. рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде, рдЕрдВрддрд░ = (рд╕реБрд░реВрд╡рд╛рдд, рд╢реЗрд╡рдЯ) = (1, 2).--рддреБрдореНрд╣рд╛рд▓рд╛ рджреЛрди рдЕрдВрддрд░рд╛рд│ рджрд┐рд▓реЗ рдЖрд╣реЗрдд,--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =","canonical_solution":"intersection :: (Int, Int) -> (Int, Int) -> String\nintersection (start1, end1) (start2, end2) = \n    if intersectionLength > 0 && isPrime intersectionLength\n    then \"YES\"\n    else \"NO\"\n  where\n    intersectionStart = max start1 start2\n    intersectionEnd = min end1 end2\n    intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    isPrime :: Int -> Bool\n    isPrime n\n      | n <= 1 = False\n      | n == 2 = True\n      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_128","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдЯреАрдк: рд░рд┐рдХреНрдд рдЖрд░реЗрд╕рд╛рдареА рдХрд╛рд╣реАрд╣реА рдкрд░рдд рдХрд░реВ рдирдХрд╛.--рдпрд╛рджреАрддреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рдХреНрд░рдорд╛рдВрдХрд╛рдЪреЗ рдкреНрд░рддрд┐рдирд┐рдзрд┐рддреНрд╡ 1, -1 рдХрд┐рдВрд╡рд╛ 0 рдиреЗ рдХреЗрд▓реЗ рдЬрд╛рддреЗ.--рдкреВрд░реНрдгрд╛рдВрдХ рдкрд░рд┐рдорд╛рдгрд╛рддреАрд▓ рдмреЗрд░реАрдЬ рд╕рд░реНрд╡ рдЪрд┐рдиреНрд╣реЗрдЪреНрдпрд╛ рдЧреБрдгрд╛рдХрд╛рд░рд╛рдиреЗ рдЧреБрдгрд╛рдХрд╛рд░ --рддреБрдореНрд╣рд╛рд▓рд╛ рдкреВрд░реНрдгрд╛рдВрдХ рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдПрдХ рд╕реВрдЪреА рджрд┐рд▓реА рдЖрд╣реЗ рдЖрдгрд┐ рддреБрдореНрд╣рд╛рд▓рд╛ рддреА рдкрд░рдд рдХрд░рд╛рд╡реА рд▓рд╛рдЧреЗрд▓.--  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =","canonical_solution":"prodSigns :: [Int] -> Maybe Int\nprodSigns [] = Nothing\nprodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_129","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдХрд┐рдорд╛рди рдорд╛рд░реНрдЧрд╛рд╡рд░ рдЬрд╛рдгрд╛рд▒реНрдпрд╛ рд╕реЗрд▓рд╡рд░реАрд▓ рдореВрд▓реНрдпрд╛рдВрдЪреА рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реА рдпрд╛рджреА рдкрд░рдд рдХрд░рддреЗ.--рдпрд╛рдЪреЗ рдЙрддреНрддрд░ рдЕрджреНрд╡рд┐рддреАрдп рдЖрд╣реЗ рдпрд╛рдЪреА рд╣рдореА рджрд┐рд▓реА рдЬрд╛рддреЗ.--lst_A[j] = lst_B[j] .--рдЕрд╢рд╛ рдкреНрд░рдХрд╛рд░реЗ lst_A[i] < lst_B[i] рдЖрдгрд┐ рдХреЛрдгрддреНрдпрд╛рд╣реА j (1 <= j < i) рд╕рд╛рдареА рдЖрдкрд▓реНрдпрд╛рдХрдбреЗ --lst_B рдкреЗрдХреНрд╖рд╛, рджреБрд╕рд▒реНрдпрд╛ рд╢рдмреНрджрд╛рдВрдд, рдПрдХ рдкреВрд░реНрдгрд╛рдВрдХ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ i (1 <= i <= k)  рдЕрд╕реНрддрд┐рддреНрд╡рд╛рдд рдЖрд╣реЗ.--lst_A рдЖрдгрд┐ lst_B рдЕрд╕реЗ рдореНрд╣рдгреВ рдпрд╛), lst_A рд╣реЗ рд╢рдмреНрджрдХреЛрд╢рд╛рддреНрдордХрджреГрд╖реНрдЯреНрдпрд╛ рдХрдореА рдЖрд╣реЗ.--A рдЖрдгрд┐ B рдордзреНрдпреЗ рдЬрд╛рдгрд╛рд▒реНрдпрд╛ рд╕реЗрд▓рд╡рд░реАрд▓ рдореВрд▓реНрдпрд╛рдВрдЪреА рдХреНрд░рдорд╡рд╛рд░реАрдд рдпрд╛рджреА рдмрдирд╡рд▓реНрдпрд╛рдирдВрддрд░ --рдПрдХ рдорд╛рд░реНрдЧ A (рд▓рд╛рдВрдмреА k) рдПрдХ рдорд╛рд░реНрдЧ B (рд▓рд╛рдВрдмреА k) рдкреЗрдХреНрд╖рд╛ рд▓рд╣рд╛рди рдорд╛рдирд▓реЗ рдЬрд╛рддреЗ рдЬрд░ --рддреБрдореНрд╣реА рдЧреНрд░рд┐рдбрдЪреНрдпрд╛ рдмрд╛рд╣реЗрд░ рдЬрд╛рдК рд╢рдХрдд рдирд╛рд╣реА.--рдЖрд╡рд╢реНрдпрдХрдкрдгреЗ рд╡реЗрдЧрд│реЗ).--рдХреГрдкрдпрд╛ рд▓рдХреНрд╖рд╛рдд рдШреНрдпрд╛ рдХреА k рд▓рд╛рдВрдмреАрдЪрд╛ рдорд╛рд░реНрдЧ рдореНрд╣рдгрдЬреЗ рдирдХреНрдХреА k рдкреЗрд╢реАрдВрдирд╛ рднреЗрдЯ рджреЗрдгреЗ (рди --рдореЛрдмрд╛рдИрд▓ рдлреЛрди--рдореНрд╣рдгрдЬреЗрдЪ рддреБрдореНрд╣реА рддреБрдордЪреНрдпрд╛ рд╡рд░реНрддрдорд╛рдирд╛рдЪреНрдпрд╛ рдХрдбрд╛рд╢реА рдЬреЛрдбрд▓реЗрд▓реНрдпрд╛ рд╕реЗрд▓рдордзреНрдпреЗ рдЬрд╛рдК рд╢рдХрддрд╛.--рдХреЛрдгрддреНрдпрд╛рд╣реА рд╕реЗрд▓рдордзреВрди, рдЖрдгрд┐ рдкреНрд░рддреНрдпреЗрдХ рдЯрдкреНрдкреНрдпрд╛рдд рддреБрдореНрд╣реА рд╢реЗрдЬрд╛рд░рдЪреНрдпрд╛ рдХреЛрдгрддреНрдпрд╛рд╣реА рд╕реЗрд▓рдордзреНрдпреЗ рдЬрд╛рдК рд╢рдХрддрд╛, --рддреБрдореНрд╣рд╛рд▓рд╛ рдХрд┐рдорд╛рди рд▓рд╛рдВрдмреА k рдЪрд╛ рдорд╛рд░реНрдЧ рд╢реЛрдзрд╛рдпрдЪрд╛ рдЖрд╣реЗ. рддреБрдореНрд╣реА рд╕реБрд░реБрд╡рд╛рдд рдХрд░реВ рд╢рдХрддрд╛.--рд╕рдорд╛рд╡реЗрд╢реА рдЧреНрд░рд┐рдбрдЪреНрдпрд╛ рдкреЗрд╢реАрдВрд╡рд░ рдЕрдЧрджреА рдПрдХрджрд╛рдЪ рджрд┐рд╕рддреЗ.--рдЧреНрд░реАрдбрдЪреНрдпрд╛ рдкреНрд░рддреНрдпреЗрдХ рд╕реЗрд▓рдордзреНрдпреЗ рдПрдХ рдореВрд▓реНрдп рдЕрд╕рддреЗ. [1, N * N] рд╢реНрд░реЗрдгреАрддреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рдкреВрд░реНрдгрд╛рдВрдХ-- рдПрди рдкрдВрдХреНрддреА рдЖрдгрд┐ рдПрди рд╕реНрддрдВрдн (рдПрди >= 2) рдЖрдгрд┐ рдПрдХ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ k рдЕрд╕рд▓реЗрд▓реА рдПрдХ рдЬрд╛рд│реА рджрд┐рд▓реА, --  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =","canonical_solution":"import Data.List (sort, sortBy)\nimport Data.Ord (comparing)\nimport Control.Monad (guard)\n\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k = head $ sort paths\n  where\n    n = length grid\n    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]\n    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n      where\n        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n\n    value (r, c) = grid !! r !! c\n    paths = do\n      start <- cells\n      findPaths k [start]\n    findPaths 1 path = return $ map value path\n    findPaths l path@(current:_) = do\n      next <- neighbors current\n      findPaths (l-1) (next : path)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_130","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЯреНрд░рд╛рдмреЛрдиреЕрдХреА рдЕрдиреБрдХреНрд░рдорд╛рдЪреНрдпрд╛ рдкрд╣рд┐рд▓реНрдпрд╛ n + 1 рд╕рдВрдЦреНрдпрд╛.--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рдиреЙрди-рдирдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рджрд┐рд▓рд╛ рдЖрд╣реЗ, рддреБрдореНрд╣рд╛рд▓рд╛  рдЪреА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛рд╡реА рд▓рд╛рдЧреЗрд▓.--= реи + рей + рей = рео --рддреНрд░рд┐рдХреВрдЯ (рей) = рддреНрд░рд┐рдХреВрдЯ (реи) + рддреНрд░рд┐рдХреВрдЯ (рез) + рддреНрд░рд┐рдХреВрдЯ (рек)--рддреНрд░рд┐рдХреБрдВрдб) = рей--рддреНрд░рд┐рдХреВрдЯ (реи) = рез + (реи \/ реи) = реи --рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЬрд░ n рд╡рд┐рд╖рдо рдЕрд╕реЗрд▓ рддрд░ tri ((n - 1) + tri ((n - 2) + tri ((n + 1)--рдЬрд░ n рд╕рдо рдЕрд╕реЗрд▓ рддрд░ tri (n) = 1 + n \/ 2--рддреНрд░рд┐рдХреВрдЯ (рез) = рей--рдЯреНрд░рд┐рдмреЛрдиреЕрдХреА рдЕрдиреБрдХреНрд░рдо рдкреБрдирд░рд╛рд╡реГрддреНрддреАрджреНрд╡рд╛рд░реЗ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдХреЗрд▓рд╛ рдЬрд╛рддреЛрдГ --рдорд╛рддреНрд░, рд▓реЛрдХрд╛рдВрдирд╛ рдорд╛рд╣рд┐рдд рдирд╛рд╣реА рдХреА, рдЯреНрд░рд╛рдпрдмреЛрдирд╛рдЪреА рдЕрдиреБрдХреНрд░рдо рдХрд╛рдп рдЖрд╣реЗ.--рдлрд┐рдмреЛрдиреЕрдХреА рдЕрдиреБрдХреНрд░рдорд╛рдмрджреНрджрд▓ рд╕рд░реНрд╡рд╛рдВрдирд╛ рдорд╛рд╣рд┐рддреА рдЖрд╣реЗ, рддреНрдпрд╛рдЪрд╛ рдЕрднреНрдпрд╛рд╕ рдЧрдгрд┐рддрдЬреНрдЮрд╛рдВрдиреА резрепрекреж рдордзреНрдпреЗ рдХреЗрд▓рд╛ рд╣реЛрддрд╛.--  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =","canonical_solution":"tri :: Int -> [Int]\ntri n = map tribonacci [0..n]\n  where\n    -- Define the recursive function to calculate the tribonacci value for a given n\n    tribonacci :: Int -> Int\n    tribonacci 0 = 1\n    tribonacci 1 = 3\n    tribonacci x\n      | even x    = 1 + x `div` 2\n      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_131","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЬрд░ рд╕рд░реНрд╡ рдЕрдВрдХ рд╕рдо рдЕрд╕рддреАрд▓ рддрд░ 0 рдкрд░рдд рдХрд░рд╛.-- рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рджрд┐рд▓реЗрд▓рд╛, рд╡рд┐рд╖рдо рдЕрдВрдХрд╛рдВрдЪреЗ рдЧреБрдгрдирдлрд▓ рдкрд░рдд рджреНрдпрд╛.--  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =","canonical_solution":"digits :: Int -> Int\ndigits n\n  | null oddDigits = 0\n  | otherwise      = product oddDigits\n  where\n    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_132","nl":"mar_Deva","pl":"hs","prompt":"--рдЬреНрдпрд╛рдд рдХрд┐рдорд╛рди рдПрдХ рдмреНрд░реЕрдХреЗрдЯ рдЙрдк-рдХреНрд░рдорд╛рдд рдиреЗрд╕реНрдЯреЗрдб рдЖрд╣реЗ.--рдлрдВрдХреНрд╢рдирдиреЗ True рд░рд┐рдЯрд░реНрди рдХреЗрд▓реЗ рдкрд╛рд╣рд┐рдЬреЗ рдЬрд░ рдЖрдгрд┐ рдлрдХреНрдд рдЬрд░ рдХрдВрд╕рд╛рддреАрд▓ рд╡реИрдз рдЙрдкрдХреНрд░рдо рдЕрд╕реЗрд▓ рддрд░ -- рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреА рдлрдХреНрдд рд╕реНрдХреНрд╡реЗрдЕрд░ рдмреНрд░реЕрдХреЗрдЯ рдЕрд╕рд▓реЗрд▓реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЗрдирдкреБрдЯ рдореНрд╣рдгреВрди рдШреЗрддреЗ.--  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =","canonical_solution":"isNested :: String -> Bool\nisNested string = go string 0 False\n  where\n    go [] _ nested = nested\n    go (x:xs) depth nested\n      | x == '['  = go xs (depth + 1) (nested || depth >= 1)\n      | x == ']' && depth > 0 = go xs (depth - 1) nested\n      | otherwise = go xs depth nested","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_133","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдпрд╛рджреАрддреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рдШрдЯрдХ рдкреНрд░рдердо рд╡рд░рдЪреНрдпрд╛ int ((рдЫрддрд╛рдкрд░реНрдпрдВрдд) рдкрд░реНрдпрдВрдд рдЧреЛрд▓ рдХрд░рд╛.--рддреБрдореНрд╣рд╛рд▓рд╛ рджрд┐рд▓реЗрд▓реНрдпрд╛ рдпрд╛рджреАрддреАрд▓ рд╕рдВрдЦреНрдпрд╛рдВрдЪреНрдпрд╛ рдЪреМрд░рд╕рд╛рдЪреА рдмреЗрд░реАрдЬ рдкрд░рдд рдХрд░рд╛рд╡реА рд▓рд╛рдЧреЗрд▓, --рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рдирдВрдмрд░рдЪреА рдпрд╛рджреА рджрд┐рд▓реА рдЬрд╛рддреЗ.--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =","canonical_solution":"import Data.List (foldl')\nimport Prelude hiding (sum)\n\nsumSquares :: [Float] -> Int\nsumSquares lst = foldl' (\\acc x -> acc + ceiling x ^ 2) 0 lst","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_134","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЯреАрдкрдГ \"рд╢рдмреНрдж\" рд╣реЗ рд╕реНрдкреЗрд╕рджреНрд╡рд╛рд░реЗ рд╡рд┐рднрдХреНрдд рдХреЗрд▓реЗрд▓реНрдпрд╛ рд╡рд░реНрдгрд╛рдВрдЪреЗ рд╕рдореВрд╣ рдЖрд╣реЗ.--рдПрдХрд╛ рд╢рдмреНрджрд╛рдЪрд╛ рдПрдХ рднрд╛рдЧ, рдЖрдгрд┐ рдЕрдиреНрдпрдерд╛ рдЦреЛрдЯреЗ.--рджрд┐рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрдЪреЗ рдЕрдХреНрд╖рд░ рд╡рд░реНрдгрдорд╛рд▓рд╛рдЪреЗ рдЕрдХреНрд╖рд░ рдЖрд╣реЗ рдЖрдгрд┐  рдирд╛рд╣реА.--рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреА рд╢реЗрд╡рдЯрдЪреЗ рдЕрдХреНрд╖рд░ --  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =","canonical_solution":"checkIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt = \n    let trimmed = reverse . dropWhile (== ' ') $ reverse txt\n    in case trimmed of\n        [] -> False\n        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_135","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рджреБрд╣реЗрд░реА рдореВрд▓реНрдпреЗ.--рдЕрд╕рд╛ рдХреЛрдгрддрд╛рд╣реА рдШрдЯрдХ рдЕрд╕реНрддрд┐рддреНрд╡рд╛рдд рдирд╕рд▓реНрдпрд╛рд╕ рдкрд░рдд -1. рджрд┐рд▓реЗрд▓реНрдпрд╛ рдпрд╛рджреАрдордзреНрдпреЗ  рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдирд╕реЗрд▓.--рддреНрдпрд╛рдЪреНрдпрд╛ рдЖрдзреАрдЪреНрдпрд╛ рдШрдЯрдХрд╛рдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдХрд┐рдВрд╡рд╛ рд╕рдорд╛рди рдирд╛рд╣реА. рдЬрд░ --рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреЗ рдПрдЦрд╛рджреНрдпрд╛ рдШрдЯрдХрд╛рдЪрд╛ рд╕рд░реНрд╡рд╛рдд рдореЛрдард╛ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рдкрд░рдд рдХрд░рддреЗ рдЬреЗ --  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =","canonical_solution":"canArrange :: [Int] -> Int\ncanArrange arr = go arr (-1) 0\n  where\n    go [] maxIdx _ = maxIdx\n    go [_] maxIdx _ = maxIdx\n    go (x:y:xs) maxIdx idx\n      | x >= y    = go (y:xs) idx (idx + 1)\n      | otherwise = go (y:xs) maxIdx (idx + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_136","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдЬрд░ рдирдХрд╛рд░рд╛рддреНрдордХ рдХрд┐рдВрд╡рд╛ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рдирд╕реЗрд▓ рддрд░ рддреЗ рд╢реВрдиреНрдп рдореНрд╣рдгреВрди рдкрд░рдд рдХрд░рд╛.--рдпрд╛рджреАрддреАрд▓ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ.--рд╕рд░реНрд╡рд╛рдд рдореЛрдард╛ рдирдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ, рдЖрдгрд┐ 'b' рд╕рд░реНрд╡рд╛рдд рд▓рд╣рд╛рди рдЖрд╣реЗ --рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреЗ рдПрдХ рдЯрдкрд▓ (a, b) рдкрд░рдд рдХрд░рддреЗ, рдЬрд┐рдереЗ 'a' рдЖрд╣реЗ --  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =","canonical_solution":"largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst = (largestNegative, smallestPositive)\n  where\n    negatives = filter (< 0) lst\n    positives = filter (> 0) lst\n    largestNegative = if null negatives then Nothing else Just (maximum negatives)\n    smallestPositive = if null positives then Nothing else Just (minimum positives)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_138","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг --ЁЯУМ n рд╣реА рд╕рдВрдЦреНрдпрд╛ рдЪрд╛рд░ рд╕рдХрд╛рд░рд╛рддреНрдордХ рд╕рдВрдЦреНрдпрд╛рдВрдЪреНрдпрд╛ рдмреЗрд░реАрдЬ рдореНрд╣рдгреВрди рд▓рд┐рд╣рд┐рддрд╛ рдпреЗрддреЗ рдХрд╛?--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =","canonical_solution":"isEqualToSumEven :: Int -> Bool\nisEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_139","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЬреЗрдереЗ n > 0 --рдмреНрд░рд╛рдЭрд┐рд▓рд┐рдпрди_рдлреЕрдХреНрдЯреЛрд░рд┐рдпрд▓ (n) = n! * (n-1)! * (n-2)! * . . . * 1! --рдмреНрд░рд╛рдЭрд┐рд▓рд┐рдпрди рдлреЕрдХреНрдЯреЛрд░рд┐рдпрд▓ рд╣реЗ рдЦрд╛рд▓реАрд▓рдкреНрд░рдорд╛рдгреЗ рдЖрд╣реЗ:--  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =","canonical_solution":"specialFactorial :: Int -> Int\nspecialFactorial n = product [factorial x | x <- [1..n]]\n  where\n    factorial 0 = 1\n    factorial k = k * factorial (k - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_140","nl":"mar_Deva","pl":"hs","prompt":"--рдирдВрддрд░ рд╕рд░реНрд╡ рд╕рд▓рдЧ рд╕реНрдкреЗрд╕ -  рдиреЗ рдмрджрд▓рд╡рд╛.--рдЖрдгрд┐ рдЬрд░ рдПрдХрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рджреЛрдирдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рд╕рд▓рдЧ рд╕реНрдкреЗрд╕ рдЕрд╕рддреАрд▓ рддрд░, -- рдПрдХ рдордЬрдХреВрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ рджрд┐рд▓реЗрд▓реА рдЖрд╣реЗ, рддреНрдпрд╛рддреАрд▓ рд╕рд░реНрд╡ рд╕реНрдкреЗрд╕ рдЕрдВрдбрд░рд╕реНрдХреЛрд░рдиреЗ рдмрджрд▓рд╛, --  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =","canonical_solution":"fixSpaces :: String -> String\nfixSpaces text = concatMap replaceSpaces (groupSpaces text)\n  where\n    groupSpaces :: String -> [String]\n    groupSpaces [] = []\n    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest\n\n    replaceSpaces :: String -> String\n    replaceSpaces spaces@(x:_)\n      | x == ' ' && length spaces > 2 = \"-\"\n      | x == ' ' = replicate (length spaces) '_'\n      | otherwise = spaces","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_141","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --- рдмрд┐рдВрджреВ рдирдВрддрд░рдЪреА рд╕рдмрд╕реНрдЯреНрд░рд┐рдВрдЧ рдпрд╛рдкреИрдХреА рдПрдХ рдЕрд╕рд╛рд╡реАрдГ ['txt', 'exe', 'dll'] --рд▓реЕрдЯрд┐рди рд╡рд░реНрдгрдорд╛рд▓рд╛ ('рдЕ' - 'рдЭ' рдЖрдгрд┐ 'рдЕ' - 'рдЭ') --- рдард┐рдкрдХреЗ рдЖрдзреАрдЪреА рд╕рдмрд╕реНрдЯреНрд░рд┐рдВрдЧ рд░рд┐рдХреНрдд рдЕрд╕реВ рдирдпреЗ, рдЖрдгрд┐ рддреА  рдпрд╛ рдЕрдХреНрд╖рд░рд╛рдкрд╛рд╕реВрди рд╕реБрд░реВ рд╣реЛрддреЗ.--- рдлрд╛рдИрд▓рдЪреНрдпрд╛ рдирд╛рд╡рд╛рдордзреНрдпреЗ рдПрдХ рдмрд┐рдВрджреВ рдЖрд╣реЗ.--- рдлрд╛рдИрд▓рдЪреНрдпрд╛ рдирд╛рд╡рд╛рдордзреНрдпреЗ рддреАрди рдЕрдВрдХрд╛рдВрдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд ('0'-'9') рдирд╕рд╛рд╡реЗрдд.--рдкреВрд░реНрдг рдХреЗрд▓реЗ рдЬрд╛рддрд╛рдд: --рдЦрд╛рд▓реАрд▓ рд╕рд░реНрд╡ рдЕрдЯреА рдкреВрд░реНрдг рдЭрд╛рд▓реНрдпрд╛рд╕рдЪ рдПрдЦрд╛рджреНрдпрд╛ рдлрд╛рдИрд▓рдЪреЗ рдирд╛рд╡ рд╡реИрдз рдорд╛рдирд▓реЗ рдЬрд╛рддреЗ.--рдлрд╛рдЗрд▓рдЪреЗ рдирд╛рд╡ рд╡реИрдз рдЕрд╕рд▓реНрдпрд╛рд╕ 'рд╣реЛрдп' рдЖрдгрд┐ рдЕрдиреНрдпрдерд╛ 'рдирд╛рд╣реА' рдкрд░рдд рдХрд░рддреЗ.--рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреА рдлрд╛рдИрд▓рдЪреЗ рдирд╛рд╡ рджрд░реНрд╢рд╡рд┐рдгрд╛рд░реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдШреЗрддреЗ рдЖрдгрд┐ рдкрд░рдд рдХрд░рддреЗ.--  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =","canonical_solution":"import Data.Char (isDigit, isLetter)\n\nfileNameCheck :: String -> String\nfileNameCheck file_name \n  | countDots \/= 1 = \"No\"\n  | length digits > 3 = \"No\"\n  | null beforeDot || not (isLetter (head beforeDot)) = \"No\"\n  | afterDot `notElem` validExtensions = \"No\"\n  | otherwise = \"Yes\"\n  where \n    (beforeDot, afterDot) = span (\/= '.') file_name\n    countDots = length $ filter (== '.') file_name\n    digits = filter isDigit file_name\n    validExtensions = [\"txt\", \"exe\", \"dll\"]\n    afterDot = if null dotAndAfter then \"\" else tail dotAndAfter\n    dotAndAfter = dropWhile (\/= '.') file_name","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"\/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_142","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдпрд╛рджреАрддреАрд▓ рдЬреНрдпрд╛рдВрдЪреА рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ 3 рдХрд┐рдВрд╡рд╛ 4 рдЪрд╛ рдЧреБрдгрдХ рдирд╛рд╣реА рдЕрд╢рд╛ рдиреЛрдВрджреА рдмрджрд▓реВ. рдлрдВрдХреНрд╢рди рдирдВрддрд░ рд╕рд░реНрд╡ рдиреЛрдВрджреАрдВрдЪреЗ рдмреЗрд░реАрдЬ рдкрд░рдд рдХрд░реЗрд▓.--3 рдЪрд╛ рдЧреБрдгрдХ рдЖрдгрд┐ рдкреВрд░реНрдгрд╛рдВрдХ рдкреНрд░рд╡рд┐рд╖реНрдЯреАрдЪреЗ рдШрди рдХрд░реЗрд▓ рдЬрд░ рддреНрдпрд╛рдЪреЗ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ 4 рдЪрд╛ рдЧреБрдгрдХ рдЕрд╕реЗрд▓ рдЖрдгрд┐ 3 рдЪрд╛ рдЧреБрдгрдХ рдирд╕реЗрд▓ рддрд░ рдлрдВрдХреНрд╢рди --рд╣реЗ рдлрдВрдХреНрд╢рди рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рдШреЗрдИрд▓. рдпрд╛рджреАрддреАрд▓ рд╕рд░реНрд╡ рдиреЛрдВрджреАрдВрд╕рд╛рдареА, рдлрдВрдХреНрд╢рди рдкреВрд░реНрдгрд╛рдВрдХ рдкреНрд░рд╡рд┐рд╖реНрдЯреАрдЪрд╛ рдЪреМрд░рд╕ рдЕрд╕реЗрд▓ рдЬрд░ рддреНрдпрд╛рдЪреЗ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ  рдЕрд╕реЗрд▓ рддрд░.--\" --  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =","canonical_solution":"sumSquares :: [Int] -> Int\nsumSquares lst = sum $ zipWith transform [0..] lst\n  where\n    transform idx x\n      | idx `mod` 3 == 0 = x * x\n      | idx `mod` 4 == 0 = x * x * x\n      | otherwise        = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_143","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг 1: --рдирд╡реАрди рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреАрд▓ рд╢рдмреНрджрд╛рдВрдЪреА рдХреНрд░рдорд╡рд╛рд░реА рдореВрд│ рд╕реНрдЯреНрд░рд┐рдВрдЧрд╕рд╛рд░рдЦреАрдЪ рдЕрд╕рд╛рд╡реА.--рдЬреНрдпрд╛рдВрдЪреА рд▓рд╛рдВрдмреА рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ, --рдЖрдгрд┐ рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛рд╡реА рд▓рд╛рдЧреЗрд▓ рдЬреНрдпрд╛рдд рдореВрд│ рд╡рд╛рдХреНрдпрд╛рддрд▓реЗ рд╢рдмреНрдж рдЕрд╕рддреАрд▓, --рдпрд╛ рд╡рд╛рдХреНрдпрд╛рдд рдХрд╛рд╣реА рд╢рдмреНрдж рдЖрд╣реЗрдд, рдЬреНрдпрд╛рдВрдирд╛ рд╕реНрдкреЗрд╕рдиреЗ рд╡реЗрдЧрд│реЗ рдХреЗрд▓реЗ рдЖрд╣реЗ.--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╡рд╛рдХреНрдп рджрд░реНрд╢рд╡рдгрд╛рд░реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рджрд┐рд▓реА рдЬрд╛рддреЗ,--  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =","canonical_solution":"import Data.List (intercalate)\n\nwordsInSentence :: String -> String\nwordsInSentence sentence = intercalate \" \" $ filter (isPrime . length) (words sentence)\n\nisPrime :: Int -> Bool\nisPrime n | n < 2     = False\n          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_144","nl":"mar_Deva","pl":"hs","prompt":"--рддреБрдореНрд╣реА рдЕрд╕реЗ рдорд╛рдиреВ рд╢рдХрддрд╛ рдХреА x, рдЖрдгрд┐ n рд╣реЗ рд╡реИрдз рдЕрдкреВрд░реНрдгрд╛рдВрдХ рдЖрд╣реЗрдд, рдЖрдгрд┐ рддреНрдпрд╛рдВрдЪреНрдпрд╛рдд рд╢реВрдиреНрдп рдирд╛рд╣реА.--<рд╕рдВрдЦреНрдпрд╛>\/<рдирд╛рдо> рдЬреНрдпрд╛рдордзреНрдпреЗ рд╕рдВрдЦреНрдпрд╛ рдЖрдгрд┐ рдирд╛рдо рджреЛрдиреНрд╣реА рд╕рдХрд╛рд░рд╛рддреНрдордХ рд╕рдВрдкреВрд░реНрдг рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗрдд.--рдЕрдиреНрдпрдерд╛. x рдЖрдгрд┐ n рд╣реЗ рджреЛрдиреНрд╣реА, рдПрдХ рднрд╛рдЧрд╛рдЪреЗ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкреНрд░рддрд┐рдирд┐рдзрд┐рддреНрд╡ рдЖрд╣реЗрдд, рдЖрдгрд┐ рдЦрд╛рд▓реАрд▓ рд╕реНрд╡рд░реВрдк рдЖрд╣реЗ, --x * n. рдлрдВрдХреНрд╢рди True рд░рд┐рдЯрд░реНрди рдХрд░рддреЗ рдЬрд░ x * n рдПрдХ рдкреВрд░реНрдгрд╛рдВрдХ рдЖрдгрд┐ False --рддреБрдордЪреЗ рдХрд╛рдо рд╣реЗ рдЖрд╣реЗ рдХреА рддреБрдореНрд╣реА рдПрдХ рдлрдВрдХреНрд╢рди рддрдпрд╛рд░ рдХрд░рд╛ рдЬреЗ рдЕрднрд┐рд╡реНрдпрдХреНрддреАрд▓рд╛ рд╕реЛрдкреЗ рдХрд░реЗрд▓.--  >>> simplify \"1\/5\" \"5\/1\"\n--  True\n--  >>> simplify \"1\/6\" \"2\/1\"\n--  False\n--  >>> simplify \"7\/10\" \"10\/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =","canonical_solution":"import Data.Ratio (denominator, numerator, (%))\n\nsimplify :: String -> String -> Bool\nsimplify x n =\n  let (xNum, xDen) = toFraction x\n      (nNum, nDen) = toFraction n\n      result = (xNum * nNum) % (xDen * nDen)\n  in denominator result == 1\n\ntoFraction :: String -> (Integer, Integer)\ntoFraction s =\n  let (numStr, _:denStr) = break (=='\/') s\n  in (read numStr, read denStr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/6\" \"2\/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/1\" \"3\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/10\" \"10\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/10\" \"50\/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/2\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11\/6\" \"6\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/3\" \"5\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/2\" \"3\/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"8\/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"1\/5\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_145","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдореВрд│ рдпрд╛рджреАрддреАрд▓ рддреНрдпрд╛рдВрдЪреНрдпрд╛ рдЕрдиреБрдХреНрд░рдордгрд┐рдХреЗрдЪреНрдпрд╛ рдЖрдзрд╛рд░реЗ рддреНрдпрд╛рдВрдирд╛ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛.--рдЯреАрдкрдГ рдЬрд░ рдЕрдиреЗрдХ рдЖрдпрдЯрдо рдЕрд╕рддреАрд▓ рддрд░ рддреНрдпрд╛рдВрдЪреНрдпрд╛ рдЕрдВрдХрд╛рдВрдЪреА рдмреЗрд░реАрдЬ рд╕рд╛рд░рдЦреАрдЪ рдЕрд╕реЗрд▓ рддрд░, --рддреНрдпрд╛рдВрдЪреНрдпрд╛ рдЕрдВрдХрд╛рдВрдЪреНрдпрд╛ рдмреЗрд░реАрдЬрдиреБрд╕рд╛рд░ рд╡рд╛рдврддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ.--ЁЯУМ рдкреВрд░реНрдгрд╛рдВрдХ рд╕реВрдЪреАрдЪреА рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рдгрд╛рд░реА рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛.--  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =","canonical_solution":"import Data.List (sortBy)\nimport Data.Function (on)\n\norderByPoints :: [Int] -> [Int]\norderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums\n  where\n    sumOfDigits :: Int -> Int\n    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)\n    \n    indexedNums :: [(Int, Int)]\n    indexedNums = zip (map sumOfDigits nums) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_146","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдПрдХрд╛ рд╕рдВрдЦреНрдпреЗрдЪрд╛ рдкрд╣рд┐рд▓рд╛ рдЖрдгрд┐ рд╢реЗрд╡рдЯрдЪрд╛ рдЕрдВрдХ рд╡рд┐рд╖рдо рдЖрд╣реЗ (1, 3, 5, 7, 9).--рдпрд╛рджреАрддреАрд▓ рдШрдЯрдХрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ 10 рдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдЖрд╣реЗ рдЖрдгрд┐ рджреЛрдиреНрд╣реА --ЁЯУМ рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рдЗрдирдкреБрдЯ рдореНрд╣рдгреВрди рдШреЗрддреЗ рдЖрдгрд┐ рд░рд┐рдЯрд░реНрди рдореНрд╣рдгреВрди рджреЗрддреЗ.--  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =","canonical_solution":"specialfilter :: [Int] -> Int\nspecialfilter nums = length $ filter isSpecial nums\n  where\n    isSpecial n = n > 10 && isOddFirstAndLast (abs n)\n\n    isOddFirstAndLast :: Int -> Bool\n    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit\n      where\n        xStr = show x\n        firstDigit = head xStr\n        lastDigit = last xStr\n\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_147","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг:--рдЖрдгрд┐ a[i] + a[j] + a[k] рд╣реЗ рей рдЪреЗ рдЧреБрдгрдХ рдЖрд╣реЗ.--a рдЪреНрдпрд╛ рддрд┐рд╣реЗрд░реА (a[i], a[j], a[k]) рдЪреА рд╕рдВрдЦреНрдпрд╛ рдкрд░рдд рдХрд░рд╛ рдЬрд┐рдереЗ i < j < k, --рдкреНрд░рддреНрдпреЗрдХ i (1 тЙд i тЙд n) рд╕рд╛рдареА, a[i] = i * i - i + 1 рдЪреА рдХрд┐рдВрдордд.--рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ n рджрд┐рд▓рд╛ рдЖрд╣реЗ. рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рдкреВрд░реНрдгрд╛рдВрдХ рд╕реВрдЪреА рддрдпрд╛рд░ рдХрд░рд╛рд╡реА рд▓рд╛рдЧреЗрд▓ рд▓рд╛рдВрдмреА n рдЪреА.--  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =","canonical_solution":"getMaxTriples :: Int -> Int\ngetMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]\n  where\n    a = [i * i - i + 1 | i <- [1..n]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_149","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рддреБрдореНрд╣реА рдЕрд╕реЗ рдорд╛рдиреВ рд╢рдХрддрд╛ рдХреА рд╕рд░реНрд╡ рд╢рдмреНрджрд╛рдВрдЪреА рд▓рд╛рдВрдмреА рд╕рдорд╛рди рдЕрд╕реЗрд▓.--рдлрдВрдХреНрд╢рдирдиреЗ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реНрдпрд╛ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛рд╡реА.--рджреЛрди рд╢рдмреНрджрд╛рдВрдЪреА рд▓рд╛рдВрдмреА рд╕рдорд╛рди рдЕрд╕рд▓реНрдпрд╛рд╕, рдпрд╛рджреА рд╡рд░реНрдгрдХреНрд░рдорд╛рдиреБрд╕рд╛рд░ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд╛.--рдпрд╛ рдирд┐рдпрдорд╛рдиреБрд╕рд╛рд░ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛рд╡реА.--рдпрд╛рджреАрддреАрд▓ рдХреНрд░рдо рдкреНрд░рддреНрдпреЗрдХ рд╢рдмреНрджрд╛рдЪреНрдпрд╛ рд▓рд╛рдВрдмреАрдиреБрд╕рд╛рд░ рд╡рд╛рдврдд рдЕрд╕рд╛рд╡рд╛, рдЖрдгрд┐ рддреБрдореНрд╣реА --рдЖрдгрд┐ рддреНрдпрд╛рдд рдбреБрдкреНрд▓рд┐рдХреЗрдЯ рдЕрд╕реВ рд╢рдХрддрд╛рдд.--рдпрд╛рджреА рд╣реА рдиреЗрд╣рдореА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдпрд╛рджреА рдЕрд╕рддреЗ рдЖрдгрд┐ рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рдХрдзреАрдЪ рдирд╕рддреЗ.--рдЖрдгрд┐ рдХреНрд░рдорд╡рд╛рд░реА рд▓рд╛рд╡рд▓реЗрд▓реНрдпрд╛ рдХреНрд░рдорд╡рд╛рд░реАрд╕рд╣ рдкрд░рд┐рдгрд╛рдореА рдпрд╛рджреА рдкрд░рдд рдХрд░рддреЗ, --рддреНрдпрд╛рдкрд╛рд╕реВрди рд╡рд┐рд╖рдо рд▓рд╛рдВрдмреАрдЪреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕ рд╣рдЯрд╡рддреЗ, --рдПрдХ рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдпрд╛рджреА рдкреЕрд░рд╛рдореАрдЯрд░ рдореНрд╣рдгреВрди рд╕реНрд╡реАрдХрд╛рд░рддреЗ,--  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =","canonical_solution":"sortedListSum :: [String] -> [String]\nsortedListSum lst = sortBy compareStrings (filter evenLength lst)\n  where\n    evenLength s = even (length s)\n    compareStrings s1 s2\n      | length s1 == length s2 = compare s1 s2\n      | otherwise = compare (length s1) (length s2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_150","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдПрдХ рдЕрднрд╛рдЬреНрдп рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ рдЖрдгрд┐ y рдЪреА рдХрд┐рдВрдордд рдкрд░рдд рдХрд░рд╛рд╡реА рдЕрдиреНрдпрдерд╛.--рдПрдХ рд╕рд╛рдзрд╛ рдкреНрд░реЛрдЧреНрд░рд╛рдо рдЬреЛ x рдЪреА рд╡реНрд╣реЕрд▓реНрдпреВ рд░рд┐рдЯрд░реНрди рдХрд░рддреЛ рдЬрд░ n  рдЕрд╕реЗрд▓ рддрд░--  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =","canonical_solution":"xOrY :: Int -> Int -> Int -> Int\nxOrY n x y = if isPrime n then x else y\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_151","nl":"mar_Deva","pl":"hs","prompt":"--рдпрд╛рджреАрдд рд╡рд┐рд╖рдо рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗрдд. рдирдХрд╛рд░рд╛рддреНрдордХ рдХрд┐рдВрд╡рд╛ рдкреВрд░реНрдгрд╛рдВрдХ рдирд╕рд▓реЗрд▓реНрдпрд╛ рд╕рдВрдЦреНрдпрд╛рдВрдХрдбреЗ рджреБрд░реНрд▓рдХреНрд╖ рдХрд░рд╛.--ЁЯУМ рд╕рдВрдЦреНрдпрд╛рдВрдЪреА рдпрд╛рджреА рджрд┐рд▓реА, рд╕рдВрдЦреНрдпрд╛рдВрдЪреНрдпрд╛ рдЪреМрд░рд╕рд╛рдЪреА рдмреЗрд░реАрдЬ рдкрд░рдд рдХрд░рд╛.--  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =","canonical_solution":"doubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst = \n    sum [x * x | x <- map round lst, x > 0, odd x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_152","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдореВрд▓реНрдп 0 рдЖрд╣реЗ, рдЖрдгрд┐ рдЬрд░ рдирд╛рд╣реА, рддрд░ рдореВрд▓реНрдп рдЕрдВрджрд╛рдЬ рдЖрдгрд┐ рд╕реНрдХреЛрдЕрд░ рджрд░рдореНрдпрд╛рди рдкрд░рд┐рдкреВрд░реНрдг рдлрд░рдХ рдЖрд╣реЗ.--рдкреНрд░рддреНрдпреЗрдХ рдЕрдВрджрд╛рдЬ рдХрд┐рддреА рджреВрд░ рд╣реЛрддрд╛ рд╣реЗ рджрд░реНрд╢рд╡рд┐рдгрд╛рд░реА рд╕рдорд╛рди рд▓рд╛рдВрдмреАрдЪреА рдпрд╛рджреА рдкрд░рдд рдХрд░рд╛. рдЬрд░ рддреНрдпрд╛рдВрдиреА рдпреЛрдЧреНрдп рдЕрдВрджрд╛рдЬ рд▓рд╛рд╡рд▓рд╛ рдЕрд╕реЗрд▓ рддрд░, --рддреБрдореНрд╣рд╛рд▓рд╛ рд╕рдорд╛рди рд▓рд╛рдВрдмреАрдЪреНрдпрд╛ рд╕реНрдХреЛрдЕрд░ рдЖрдгрд┐ рдЕрдВрджрд╛рдЬ рдпрд╛рдВрдЪреА рджреЛрди рдпрд╛рджреА рджрд┐рд▓реА рдЬрд╛рддреЗ, рдЬрд┐рдереЗ рдкреНрд░рддреНрдпреЗрдХ рдирд┐рд░реНрджреЗрд╢рд╛рдВрдХ рдПрдХ рдЬреБрд│рдгреА рджрд░реНрд╢рд╡рд┐рддреЛ.--рддреБрдордЪреНрдпрд╛ рдХрд╛рдорд╛рдЪреЗ рдЙрджреНрджрд┐рд╖реНрдЯ рд╣реЗ рдард░рд╡рдгреЗ рдЖрд╣реЗ рдХреА рдПрдЦрд╛рджреНрдпрд╛ рд╡реНрдпрдХреНрддреАрдиреЗ рдЕрдиреЗрдХ рд╕рд╛рдордиреНрдпрд╛рдВрдЪреЗ рдирд┐рдХрд╛рд▓ рдмрд░реЛрдмрд░ рдЕрдВрджрд╛рдЬ рд▓рд╛рд╡рд▓реЗ рдЖрд╣реЗрдд рдХрд╛.--рдирд┐рд╢реНрдЪрд┐рддрдкрдгреЗ рд▓рдХреНрд╖рд╛рдд рдШреЗрдгреНрдпрд╛рд╕рд╛рд░рдЦреЗ рдЖрдгрд┐ рддреБрд▓рдирд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рд░рдЦреЗ рдЖрд╣реЗ.--рддреНрдпрд╛ рдХреНрд╖рдгреА рддреБрдордЪреНрдпрд╛ рдордирд╛рдд рдХрд╛рдп рд╡рд┐рдЪрд╛рд░ рдЖрдгрд┐ рднрд╛рд╡рдирд╛ рдЖрд╣реЗрдд рд╣реЗ рддреБрдореНрд╣рд╛рд▓рд╛ рдХрд│реЗрд▓.--рдорд▓рд╛ рд╡рд╛рдЯрддреЗ рдЖрдкрдг рд╕рд░реНрд╡рдЬрдг рддреНрдпрд╛ рднрд╛рд╡рдирд╛ рдЖрдард╡рддреЛ рдЬреЗрд╡реНрд╣рд╛ рдХрд╛рд╣реА рд▓рд╛рдВрдм рдкреНрд░рддреАрдХреНрд╖рд┐рдд рдкрд░рд┐рдгрд╛рдо--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =","canonical_solution":"compare :: [Int] -> [Int] -> [Int]\ncompare game guess = zipWith (\\g s -> abs (g - s)) game guess","tests":"\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_153","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --(рддреНрдпрд╛рдЪреА рддрд╛рдХрдж -рез рдЖрд╣реЗ).--'Slices.SERVINGSliCes' рдкрд░рдд рдХрд░рд╛ рдХрд╛рд░рдг 'SERVINGSliCes' рд╣рд╛ рд╕рд░реНрд╡рд╛рдд рдордЬрдмреВрдд рд╡рд┐рд╕реНрддрд╛рд░ рдЖрд╣реЗ.--['рд╕реЗрд░реНрд╡рд┐рдВрдЧреНрд╕','рдЪреАрдЭ', 'рд╕реНрдЯреБрдлреНрдб'] рддрд░ рддреБрдореНрд╣реА --рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде, рдЬрд░ рддреБрдореНрд╣рд╛рд▓рд╛ рд╡рд░реНрдЧ рдореНрд╣рдгреВрди \"Slices\" рджрд┐рд▓реЗ рдЧреЗрд▓реЗ рдЕрд╕реЗрд▓ рдЖрдгрд┐ --рдпрд╛рджреАрдд рдкреНрд░рдердо рдпреЗрдгрд╛рд▒реНрдпрд╛рд▓рд╛ рдирд┐рд╡рдбрд╛.--рдЬрд░ рджреЛрди рдХрд┐рдВрд╡рд╛ рддреНрдпрд╛рдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдПрдХреНрд╕рдЯреЗрдВрд╢рди рдЕрд╕рддреАрд▓ рддрд░ рддреБрдореНрд╣рд╛рд▓рд╛--рд╕реНрд╡рд░реВрдк: рд╡рд░реНрдЧ рдирд╛рд╡. рд╕рд░реНрд╡рд╛рдд рдордЬрдмреВрдд рд╡рд┐рд╕реНрддрд╛рд░ рдирд╛рд╡. --рддреБрдореНрд╣рд╛рд▓рд╛ рд╕рд░реНрд╡рд╛рдд рдордЬрдмреВрдд рд╡рд┐рд╕реНрддрд╛рд░ рд╢реЛрдзрд▓рд╛ рдкрд╛рд╣рд┐рдЬреЗ рдЖрдгрд┐ рдпрд╛рдордзреНрдпреЗ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХреЗрд▓реА рдкрд╛рд╣рд┐рдЬреЗ.--рдпрд╛ рд╡рд┐рд╕реНрддрд╛рд░рд╛рдЪреНрдпрд╛ рдирд╛рд╡рд╛рдордзреНрдпреЗ, рд╕реАрдПрдкреА-рдПрд╕рдПрдо рдпрд╛ рднрд╛рдЧрд╛рджреНрд╡рд╛рд░реЗ рддрд╛рдХрдж рджрд┐рд▓реА рдЬрд╛рддреЗ.--рдПрдХреНрд╕рдЯреЗрдВрд╢рдирдЪреНрдпрд╛ рдирд╛рд╡рд╛рддреАрд▓ рдЕрдХреНрд╖рд░реЗ, рдЖрдгрд┐ SM рд╣реА рд▓рд╣рд╛рди рдЕрдХреНрд╖рд░рд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рдЕрд╕реВ рджреНрдпрд╛ --рд╡рд┐рд╕реНрддрд╛рд░рд╛рдЪреА рддрд╛рдХрдж рдЦрд╛рд▓реАрд▓рдкреНрд░рдорд╛рдгреЗ рдЖрд╣реЗ: CAP рд╣рд╛ рдЕрдкрд░рдХреЗрд╕рдЪрд╛ рдирдВрдмрд░ рдЕрд╕реВ рджреНрдпрд╛ --рдПрдХреНрд╕рдЯреЗрдВрд╢рдирдЪрд╛ рд╡рд╛рдкрд░ рд╡рд░реНрдЧрд╛рдд рдЕрддрд┐рд░рд┐рдХреНрдд рд╡рд░реНрдЧ рд▓реЛрдб рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдХреЗрд▓рд╛ рдЬрд╛рддреЛ.-- рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХрд╛ рд╡рд░реНрдЧрд╛рдЪреЗ рдирд╛рд╡ (рд╕реНрдЯреНрд░рд┐рдВрдЧ) рдЖрдгрд┐ рд╡рд┐рд╕реНрддрд╛рд░ рдпрд╛рджреА рджрд┐рд▓реА рдЬрд╛рдИрд▓.--  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =","canonical_solution":"strongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions = class_name ++ \".\" ++ strongestExt\n  where\n    calculateStrength :: String -> Int\n    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)\n    \n    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)\n    \n    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)\n    maxStrength ext1 ext2\n      | snd ext1 > snd ext2 = ext1\n      | otherwise           = ext2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_154","nl":"mar_Deva","pl":"hs","prompt":"--рддреБрдореНрд╣рд╛рд▓рд╛ рджреЛрди рд╢рдмреНрдж рджрд┐рд▓реЗ рдЖрд╣реЗрдд. рддреБрдореНрд╣рд╛рд▓рд╛ True рдкрд░рдд рдХрд░рд╛рд╡реЗ рд▓рд╛рдЧреЗрд▓ рдЬрд░ рджреБрд╕рд░рд╛ рд╢рдмреНрдж рдХрд┐рдВрд╡рд╛ рддреНрдпрд╛рдЪреНрдпрд╛ рдХреЛрдгрддреНрдпрд╛рд╣реА рдлрд┐рд░рд╡рдгреНрдпрд╛ рдкрд╣рд┐рд▓реНрдпрд╛ рд╢рдмреНрджрд╛рдЪреА рд╕рдмрд╕реНрдЯреНрд░рд┐рдВрдЧ рдЕрд╕реЗрд▓.--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =","canonical_solution":"cycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b = any (`isInfixOf` a) rotations\n  where\n    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_155","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдПрдХ рдкреВрд░реНрдгрд╛рдВрдХ рджрд┐рд▓реЗрд▓рд╛ рдЖрд╣реЗ. рдПрдХ рдЯрдкрд▓ рдкрд░рдд рдХрд░рд╛ рдЬреНрдпрд╛рдордзреНрдпреЗ рдЕрдиреБрдХреНрд░рдореЗ рд╕рдо рдЖрдгрд┐ рд╡рд┐рд╖рдо рдЕрдВрдХрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ рдЖрд╣реЗ.--  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =","canonical_solution":"evenOddCount :: Int -> (Int, Int)\nevenOddCount num = (length evens, length odds)\n  where\n    digits = map (read . (:[])) . show . abs $ num\n    evens = filter even digits\n    odds  = filter odd digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_156","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ: --рдирд┐рд░реНрдмрдВрдз: 1 <= рд╕рдВрдЦреНрдпрд╛ <= 1000 --рдЖрдгрд┐ рддреЗ рд▓рдШреБрдХрдерд╛рдВрдордзреНрдпреЗ рдкрд░рдд рдХрд░рд╛.--ЁЯУМ рдПрдХ рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рджрд┐рд▓реНрдпрд╛рд╕, рддреНрдпрд╛рдЪреЗ рд░реЛрдорди рдЕрдВрдХ рд╕рдорддреБрд▓реНрдп рд╕реНрдЯреНрд░рд┐рдВрдЧ рдореНрд╣рдгреВрди рдорд┐рд│рд╡рд╛, --  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =","canonical_solution":"intToMiniRoman :: Int -> String\nintToMiniRoman number = concatMap (replicateSymbol number) romanNumerals\n  where\n    romanNumerals = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n                     (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n                     (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    \n    replicateSymbol :: Int -> (Int, String) -> String\n    replicateSymbol n (value, symbol)\n      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)\n      | otherwise = \"\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_157","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --репреж рдЕрдВрд╢.--рдПрдХ рд╕рдордХреЛрдиреА рддреНрд░рд┐рдХреЛрдг рдореНрд╣рдгрдЬреЗ рдПрдХ рддреНрд░рд┐рдХреЛрдг рдЬреНрдпрд╛рдордзреНрдпреЗ рдПрдХ рдХреЛрди рд╕рдордХреЛрди рдЖрд╣реЗ рдХрд┐рдВрд╡рд╛ --рдмрд╛рдЬреВ рдПрдХ рдЙрдЬрд╡реНрдпрд╛ рдХреЛрдирд╛рдд рддреНрд░рд┐рдХреЛрдг рддрдпрд╛рд░ рдХрд░рддрд╛рдд, рдЕрдиреНрдпрдерд╛ рдЦреЛрдЯреЗ.--рддреНрд░рд┐рдХреЛрдгрд╛рдЪреНрдпрд╛ рддреАрди рдмрд╛рдЬреВрдЪреА рд▓рд╛рдВрдмреА рджрд┐рд▓реА рдЖрд╣реЗ.--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =","canonical_solution":"rightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c = \n    let [x, y, z] = sort [a, b, c]\n    in x^2 + y^2 == z^2\n    where sort = Data.List.sort","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_158","nl":"mar_Deva","pl":"hs","prompt":"--рдЕрдХреНрд╖рд░реЗ, рд╢рдмреНрджрд╕рдВрдЧреНрд░рд╣рд╛рдЪреНрдпрд╛ рдХреНрд░рдорд╡рд╛рд░реАрдд рдкреНрд░рдердо рдпреЗрдгрд╛рд░реА рдЕрдХреНрд╖рд░реЗ рдкрд░рдд рдХрд░рд╛.--рдЬрд░ рдПрдХрд╛рдзрд┐рдХ рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдордзреНрдпреЗ рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд рд╕рдВрдЦреНрдпрд╛ рдЕрджреНрд╡рд┐рддреАрдп рдЕрд╕реЗрд▓ рддрд░--рдпрд╛рджреАрдд рд╡реЗрдЧрд╡реЗрдЧрд│реЗ рд╢рдмреНрдж рдЖрд╣реЗрдд. рдЬрд╛рд╕реНрддреАрдд рдЬрд╛рд╕реНрдд рд╕рдВрдЦреНрдпреЗрд╕рд╣ рд╢рдмреНрдж рдкрд░рдд рдХрд░рд╛ --рдПрдХ рдЕрд╢реА рдлрдВрдХреНрд╢рди рд▓рд┐рд╣рд╛ рдЬреА рд╕реНрдЯреНрд░рд┐рдВрдЧреНрд╕рдЪреА рдпрд╛рджреА рд╕реНрд╡реАрдХрд╛рд░рддреЗ.--  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =","canonical_solution":"import Data.List (nub, sort)\n\nfindMax :: [String] -> String\nfindMax words = \n    head . sort . map snd . filter (\\(n, _) -> n == maxUnique) $ wordUniquePairs\n  where\n    wordUniquePairs = [(length . nub $ word, word) | word <- words]\n    maxUnique = maximum $ map fst wordUniquePairs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_159","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдг: --рдЬрд░ рдкреБрд░реЗрд╕реЗ рдЧрд╛рдЬрд░ рд╢рд┐рд▓реНрд▓рдХ рдирд╕реЗрд▓ рддрд░ рддреБрдореНрд╣реА рд╕рд░реНрд╡ рдЧрд╛рдЬрд░ рдЦрд╛рд▓, рдкрдг рддрд░реАрд╣реА рднреВрдХ рд▓рд╛рдЧреЗрд▓.--рдЬреЗрд╡рдгрд╛рдирдВрддрд░ рдЙрд░рд▓реЗрд▓реНрдпрд╛ рдЧрд╛рдЬрд░рдЪреА рд╕рдВрдЦреНрдпрд╛ ] --рддреБрдореНрд╣реА рдЬреЗрд╡рдгрд╛рдирдВрддрд░ рдЦрд╛рд▓реНрд▓реЗрд▓реНрдпрд╛ рдЧрд╛рдЬрд░рдЪреА рдПрдХреВрдг рд╕рдВрдЦреНрдпрд╛,--рдкрдг рдЖрддрд╛ рддреБрдореНрд╣рд╛рд▓рд╛ рджрд┐рд╡рд╕рднрд░рд╛рдд рдЬреЗрд╡рдг рдкреВрд░реНрдг рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдЬрд╛рд╕реНрдд рдЧрд╛рдЬрд░ рдЦрд╛рдгреНрдпрд╛рдЪреА рдЧрд░рдЬ рдЖрд╣реЗ.--рддреБрдореНрд╣реА рдПрдХ рднреБрдХреЗрд▓реЗрд▓рд╛ рд╕рд╕рд╛ рдЖрд╣рд╛рдд, рдЖрдгрд┐ рддреБрдореНрд╣реА рдЖрдзреАрдЪ рдХрд╛рд╣реА рдЧрд╛рдЬрд░ рдЦрд╛рд▓реНрд▓реЗ рдЖрд╣реЗрдд,--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =","canonical_solution":"eat :: Int -> Int -> Int -> [Int]\neat number need remaining\n  | remaining >= need = [number + need, remaining - need]\n  | otherwise = [number + remaining, 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_160","nl":"mar_Deva","pl":"hs","prompt":"--рдСрдкрд░реЗрдЯрд░ рдпрд╛рджреАрдордзреНрдпреЗ рдХрдореАрдд рдХрдореА рдПрдХ рдСрдкрд░реЗрдЯрд░ рдЕрд╕рддреЛ рдЖрдгрд┐ рдСрдкрд░реЗрдиреНрдб рдпрд╛рджреАрдордзреНрдпреЗ рдХрдореАрдд рдХрдореА рджреЛрди рдСрдкрд░реЗрдиреНрдб рдЕрд╕рддрд╛рдд.--рдСрдкрд░реЗрдиреНрдб рд╣реЗ рдиреЙрди-рдирдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА рдЖрд╣реЗ.--рдСрдкрд░реЗрдЯрд░ рд▓рд┐рд╕реНрдЯрдЪреА рд▓рд╛рдВрдмреА рдСрдкрд░реЗрдиреНрдб рд▓рд┐рд╕реНрдЯрдЪреНрдпрд╛ рд▓рд╛рдВрдмреАрдЪреНрдпрд╛ рдПрдХрд╛рд╡рд┐рд░реБрджреНрдз рд╕рдорд╛рди рдЖрд╣реЗ.--рдЯреАрдк:--=> рдкрд░рд┐рдгрд╛рдо = 9 --рдкрд░рд┐рдгрд╛рдо = 2 + 3 * 4 - 5 --рдпрд╛рджреА = [2, 3, 4, 5] --рдСрдкрд░реЗрдЯрд░ ['+', '*', '-'] --рдЙрджрд╛рд╣рд░рдг: --рдПрдХреНрд╕рдкреЛрдиреЗрдВрдЯрд┐рдПрд╢рди (**)--рдордЬрд▓рд╛ рд╡рд┐рднрд╛рдЧрдгреА ( \/\/ ) --рдЧреБрдгрд╛рдХрд╛рд░ (*) --рдШрдЯ (- ) --рдЬреЛрдбрдгреА (+) --рдореВрд▓рднреВрдд рдмреАрдЬрдЧрдгрд┐рдд рдСрдкрд░реЗрд╢рдиреНрд╕:--рдЕрднрд┐рд╡реНрдпрдХреНрддреА рдЖрдгрд┐ рдпрд╛ рдЕрднрд┐рд╡реНрдпрдХреНрддреАрдЪреЗ рдореВрд▓реНрдпрд╛рдВрдХрди рдкрд░рдд рдХрд░рд╛.--рджреБрд╕рд░реА рдпрд╛рджреА рдореНрд╣рдгрдЬреЗ рдкреВрд░реНрдгрд╛рдВрдХ рдпрд╛рджреА.--рджреЛрди рд╕реВрдЪреА рдСрдкрд░реЗрдЯрд░ рдЖрдгрд┐ рдСрдкрд░реЗрдиреНрдб рджрд┐рд▓реЗ рдЖрд╣реЗрдд. рдкрд╣рд┐рд▓реНрдпрд╛ рд╕реВрдЪреАрдордзреНрдпреЗ рдореВрд▓рднреВрдд рдмреАрдЬрдЧрдгрд┐рдд рдСрдкрд░реЗрд╢рдиреНрд╕ рдЖрд╣реЗрдд, рдЖрдгрд┐doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =","canonical_solution":"doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand = evaluate operand operator\n  where\n    evaluate [x] [] = x\n    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops\n      where\n        result = applyOperation op x y\n\n    applyOperation \"+\" a b = a + b\n    applyOperation \"-\" a b = a - b\n    applyOperation \"*\" a b = a * b\n    applyOperation \"\/\/\" a b = a `div` b\n    applyOperation \"**\" a b = a ^ b\n    applyOperation _ _ _ = error \"Unsupported operation\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"\/\/\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_161","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгреЗ --рдлрдВрдХреНрд╢рдирдиреЗ рдкрд░рд┐рдгрд╛рдореА рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛рд╡реА.--рдЬрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧрдордзреНрдпреЗ рдХреЛрдгрддреЗрд╣реА рдЕрдХреНрд╖рд░ рдирд╕реЗрд▓ рддрд░ рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЙрд▓рдЯ рдХрд░рд╛.--рдЕрдиреНрдпрдерд╛ рддреЗ рдЬрд╕реЗ рдЖрд╣реЗ рддрд╕реЗ рдареЗрд╡рд╛.--рдЬрд░ s[i] рдПрдХ рдЕрдХреНрд╖рд░ рдЕрд╕реЗрд▓ рддрд░ рддреНрдпрд╛рдЪреЗ рдХреЗрд╕ рдХрдореА рддреЗ рд╡рд░ рдХрд┐рдВрд╡рд╛ рдЙрд▓рдЯ рдЙрд▓рдЯ рдХрд░рд╛, --рддреБрдореНрд╣рд╛рд▓рд╛ рдПрдХ рд╕реНрдЯреНрд░рд┐рдВрдЧ s рджрд┐рд▓реА рдЖрд╣реЗ.--  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =","canonical_solution":"solve :: String -> String\nsolve s\n  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s\n  | otherwise = reverse s\n  where\n    toggleCase c\n      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char\n      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_162","nl":"mar_Deva","pl":"hs","prompt":"--'text' рд╣реА рд░рд┐рдХреНрдд рд╕реНрдЯреНрд░рд┐рдВрдЧ рдЕрд╕рд▓реНрдпрд╛рд╕, Nothing рдкрд░рдд рдХрд░рд╛.--тЭС 'text' рд╣реА рд╕реНрдЯреНрд░рд┐рдВрдЧ рджрд┐рд▓реНрдпрд╛рд╕, рддреНрдпрд╛рдЪреА md5 рд╣реЕрд╢ рд╕рдорддреБрд▓реНрдп рд╕реНрдЯреНрд░рд┐рдВрдЧ рдкрд░рдд рдХрд░рд╛.--  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =","canonical_solution":"import qualified Data.ByteString.Char8 as C\nimport qualified Data.Digest.Pure.MD5 as MD5\n\nstringToMd5 :: String -> Maybe String\nstringToMd5 text\n  | null text = Nothing\n  | otherwise = Just $ show $ MD5.md5 $ C.pack text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_163","nl":"mar_Deva","pl":"hs","prompt":"--рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде: --рдЖрдгрд┐ рдм, рд╡рд╛рдврддреНрдпрд╛ рдХреНрд░рдорд╛рдиреЗ.--рджреЛрди рд╕рдХрд╛рд░рд╛рддреНрдордХ рдкреВрд░реНрдгрд╛рдВрдХ a рдЖрдгрд┐ b рджрд┐рд▓реЗ, a рд╡ b рдордзреАрд▓ рд╕рдо рдЕрдВрдХ рдкрд░рдд рдХрд░рд╛.--  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =","canonical_solution":"generateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b = filter even [min a b .. max a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()"}]