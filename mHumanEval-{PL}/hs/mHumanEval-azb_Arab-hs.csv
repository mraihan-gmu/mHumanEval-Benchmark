task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,azb_Arab,hs,"--آدرسه.--٠ باخ باخ گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر گؤر--  >>> hasCloseElements [1.0,2.0,3.0] 0.5
--  False
--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3
--  True
hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold =","hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold = any (\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a /= b]","
main :: IO ()
main = do
  let candidate = hasCloseElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_1,azb_Arab,hs,"--هر هانسی بیر بوش یئرین ایستیفاده ائتمه سین.--آيري-آيري دسته لر توازنليدير (هر آچيق قورشاق دوزگون بير شکئلده باغليدير) و بير-بيرلري نين ائچينه يئرلشمه ميشلر .--بو گروهلاری آیری-آیری سیرا-سیرالارا آییرماق و اونلارین لیستینی قایتارماق.--بو فانکشنین گئرئش سی چوخلو قوسولموش قوسوملاری اولان بیر سیرا دیر.--  >>> separateParenGroups ""( ) (( )) (( )( ))""
--  [""()"",""(())"",""(()())""]
separateParenGroups :: String -> [String]
separateParenGroups paren_string =","separateParenGroups :: String -> [String]
separateParenGroups paren_string = go paren_string 0 [] """" []
  where
    go [] _ _ current acc = if null current then acc else acc ++ [current]
    go (x:xs) depth stack current acc
      | x == ' ' = go xs depth stack current acc
      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc
      | x == ')' =
          let newCurrent = current ++ [x]
              newDepth = depth - 1
          in if newDepth == 0
             then go xs newDepth (tail stack) """" (acc ++ [newCurrent])
             else go xs newDepth (tail stack) newCurrent acc
      | otherwise = error ""Unexpected character""","
main :: IO ()
main = do
  let candidate = separateParenGroups
  if candidate ""(()()) ((())) () ((())()())"" == [""(()())"",""((()))"",""()"",""((())()())""] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [""()"",""(())"",""((()))"",""(((())))""] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [""(()(())((())))""] then pure () else error ""assertion failed""
  if candidate ""( ) (( )) (( )( ))"" == [""()"",""(())"",""(()())""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_2,azb_Arab,hs,"--اعشاریین اعشاریین عوضین قاییت.--(قوشا قالما پارچا هامی زامان ۱-دن آز اولور).--و دوغرو سایی نین بؤلومو (بؤیوک دوغرو سایی، وئریلن سایی دان کئچیدیر) و اونلاییشلار --مثبت بیر یومورتا نقطه سینی نظرده آلاراق، اونو یئرینه یئتیریر.--  >>> truncateNumber 3.5
--  0.5
truncateNumber :: Float -> Float
truncateNumber number =","truncateNumber :: Float -> Float
truncateNumber number = number - fromIntegral (floor number)","
main :: IO ()
main = do
  let candidate = truncateNumber
  if candidate 3.5 == 0.5 then pure () else error ""assertion failed""
  if candidate 1.25 == 0.25 then pure () else error ""assertion failed""
  if candidate 123.0 == 0.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_3,azb_Arab,hs,"--بو نقطه ده تابع true-ي قايتارماليدير.--صفر تراز. وظيفه يينيز، حسابين ترازينين هر هانسي بير نقطه ده صفردن آشاغي دوشمه سيني آنلاماقدير، و --۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰.۰--  >>> belowZero [1,2,3]
--  False
--  >>> belowZero [1,2,(-4),5]
--  True
belowZero :: [Int] -> Bool
belowZero operations =","belowZero :: [Int] -> Bool
belowZero operations = any (< 0) $ scanl (+) 0 operations","
main :: IO ()
main = do
  let candidate = belowZero
  if candidate [] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-4),5,6] == True then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error ""assertion failed""
  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_4,azb_Arab,hs,"--MAD = average. x - x_mean. --عنصر و مرکز نقطه (معنوی بو حالدا): --مَنْطَقَةُ الْمُحَرَّمِ هُوَ الْفَرْقُ الْمُبَرَّرُ بَيْنَ كُلِّ--بو داده لرین اورتاسی نین اطرافین دا.--""دئریلن بیر سیرا گئرئش نومره لری اوچون، آراسی مطلق انحرافین حساب اولونسون"".--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]
--  1.0
meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers =","meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers = sum absoluteDifferences / fromIntegral (length numbers)
  where
    mean = sum numbers / fromIntegral (length numbers)
    absoluteDifferences = map (\x -> abs (x - mean)) numbers","
main :: IO ()
main = do
  let candidate = meanAbsoluteDeviation
  if candidate [1.0,2.0] == 0.5 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_5,azb_Arab,hs,"--۰.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۱.۲.۲.۱.۲.۲.۲.۲.۲.۲.۲.۳--  >>> intersperse [] 4
--  []
--  >>> intersperse [1,2,3] 4
--  [1,4,2,4,3]
intersperse :: [Int] -> Int -> [Int]
intersperse numbers delimeter =","intersperse :: [Int] -> Int -> [Int]
intersperse [] _ = []
intersperse [x] _ = [x]
intersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","
main :: IO ()
main = do
  let candidate = intersperse
  if candidate [] 7 == [] then pure () else error ""assertion failed""
  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error ""assertion failed""
  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_6,azb_Arab,hs,"--مثلا (() (()) ان چوخ ایکی یئرلشمه سوییه سی وار و ((())) اوچ. --هر بير قروپ اوچون، قوسلوقلارين ان درين سيخينتي ليک لريني يازين.--بو فاکتئرین گئرئش سینده بیر چوخ قروپلارین تمثیل اولونموش بیر سیرا سی دی.--  >>> parseNestedParens ""(()()) ((())) () ((())()())""
--  [2,3,1,3]
parseNestedParens :: String -> [Int]
parseNestedParens paren_string =","parseNestedParens :: String -> [Int]
parseNestedParens paren_string = map maxDepth (words paren_string)
  where
    maxDepth :: String -> Int
    maxDepth = go 0 0
      where
        go :: Int -> Int -> String -> Int
        go currentDepth maxDepth [] = maxDepth
        go currentDepth maxDepth (c:cs)
          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs
          | c == ')'  = go (currentDepth - 1) maxDepth cs
          | otherwise = go currentDepth maxDepth cs","
main :: IO ()
main = do
  let candidate = parseNestedParens
  if candidate ""(()()) ((())) () ((())()())"" == [2,3,1,3] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [4] then pure () else error ""assertion failed""
  pure ()"
HumanEval_7,azb_Arab,hs,"--۰۲:۰۸:۲۲ -۱۳:۲۲:۲۲:۲۲--  >>> filterBySubstring [] ""a""
--  []
--  >>> filterBySubstring [""abc"",""bacd"",""cde"",""array""] ""a""
--  [""abc"",""bacd"",""array""]
filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring =","filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring = filter (substring `isInfixOf`) strings
  where isInfixOf = isInfixOf","
main :: IO ()
main = do
  let candidate = filterBySubstring
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""aaaxxy"",""john doe"",""xxxAAA"",""xxx""] ""xx"" == [""xxx"",""aaaxxy"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""grunt"",""trumpet"",""prune"",""gruesome""] ""run"" == [""grunt"",""prune""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_8,azb_Arab,hs,"--بوش جمع 0 و بوش محصول 1 اولا بیلر.--٠: بير تام سايي ليزه سي اوچون، بير توپل قاييدين کي، بير سايي ليزه سينده بوتون تام ساييلارين جمع و ضربي نين بيرينجي سايي اولسون.--  >>> sumProduct []
--  (0, 1)
--  >>> sumProduct [1,2,3,4]
--  (10, 24)
sumProduct :: [Int] -> (Int, Int)
sumProduct numbers =","sumProduct :: [Int] -> (Int, Int)
sumProduct numbers = (sum numbers, product numbers)","
main :: IO ()
main = do
  let candidate = sumProduct
  if candidate [] == (0, 1) then pure () else error ""assertion failed""
  if candidate [1,1,1] == (3, 1) then pure () else error ""assertion failed""
  if candidate [100,0] == (100, 0) then pure () else error ""assertion failed""
  if candidate [3,5,7] == (15, 105) then pure () else error ""assertion failed""
  if candidate [10] == (10, 10) then pure () else error ""assertion failed""
  pure ()"
HumanEval_9,azb_Arab,hs,"--دوزگونلوکده.--٠:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:--  >>> rollingMax [1,2,3,2,3,4,2]
--  [1,2,3,3,3,4,4]
rollingMax :: [Int] -> [Int]
rollingMax numbers =","rollingMax :: [Int] -> [Int]
rollingMax = scanl1 max","
main :: IO ()
main = do
  let candidate = rollingMax
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error ""assertion failed""
  pure ()"
HumanEval_10,azb_Arab,hs,"--- ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري--- يئتيريلن سيرانين ان اوزون پستفئکسي کي، پاليندرومدير تاپين.--آلقورتم دوشونجه سی ساده دیر:--٠.اينجه لنينجه پاليندروم کي، وارد اولان سيرله باشلايير.--  >>> makePalindrome """"
--  """"
--  >>> makePalindrome ""cat""
--  ""catac""
--  >>> makePalindrome ""cata""
--  ""catac""
makePalindrome :: String -> String
makePalindrome string =","makePalindrome :: String -> String
makePalindrome string = string ++ reverse (take (length string - palindromeLength) string)
  where
    palindromeLength = longestPalindromicSuffix string

longestPalindromicSuffix :: String -> Int
longestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]

isPalindrome :: String -> Bool
isPalindrome s = s == reverse s","
main :: IO ()
main = do
  let candidate = makePalindrome
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""x"" == ""x"" then pure () else error ""assertion failed""
  if candidate ""xyz"" == ""xyzyx"" then pure () else error ""assertion failed""
  if candidate ""xyx"" == ""xyx"" then pure () else error ""assertion failed""
  if candidate ""jerry"" == ""jerryrrej"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_11,azb_Arab,hs,"--بو گئرئشلرده باینری XOR ائدیر و نتیجه نی بیر سِری کیمی قایتاریر.--٠: آدرس ورودي دو رشته a و b است كه فقط از 1 و 0 تشکیل شده اند.--  >>> stringXor ""010"" ""110""
--  ""100""
stringXor :: String -> String -> String
stringXor a b =","stringXor :: String -> String -> String
stringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","
main :: IO ()
main = do
  let candidate = stringXor
  if candidate ""111000"" ""101010"" == ""010010"" then pure () else error ""assertion failed""
  if candidate ""1"" ""1"" == ""0"" then pure () else error ""assertion failed""
  if candidate ""0101"" ""0000"" == ""0101"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_12,azb_Arab,hs,"--stringلرین اوزونلوغو برابر دیر. اگر آخیت لیق لستی بوش اولسا، Nothing یئرینه قاییت.--٠.سيرسيمانلارين سيراسيندان، ان اوزونونو قايتار.--  >>> longest []
--  Just (Nothing)
--  >>> longest [""a"",""b"",""c""]
--  Just (""a"")
--  >>> longest [""a"",""bb"",""ccc""]
--  Just (""ccc"")
longest :: [String] -> Maybe String
longest strings =","longest :: [String] -> Maybe String
longest [] = Nothing
longest strings = Just $ foldl1 (\acc x -> if length x > length acc then x else acc) strings","
main :: IO ()
main = do
  let candidate = longest
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == Just (""x"") then pure () else error ""assertion failed""
  if candidate [""x"",""yyy"",""zzzz"",""www"",""kkkk"",""abc""] == Just (""zzzz"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_13,azb_Arab,hs,"--a و b ساییلاری نین ان بؤیوک اورتاق بؤلونومو قاییدیب.--  >>> greatestCommonDivisor 3 5
--  1
--  >>> greatestCommonDivisor 25 15
--  5
greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b =","greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b
  | b == 0    = a
  | otherwise = greatestCommonDivisor b (a `mod` b)","
main :: IO ()
main = do
  let candidate = greatestCommonDivisor
  if candidate 3 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 15 == 5 then pure () else error ""assertion failed""
  if candidate 49 14 == 7 then pure () else error ""assertion failed""
  if candidate 144 60 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_14,azb_Arab,hs,"--۰۲.۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲۲--  >>> allPrefixes ""abc""
--  [""a"",""ab"",""abc""]
allPrefixes :: String -> [String]
allPrefixes string =","allPrefixes :: String -> [String]
allPrefixes string = [take n string | n <- [1 .. length string]]","
main :: IO ()
main = do
  let candidate = allPrefixes
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""asdfgh"" == [""a"",""as"",""asd"",""asdf"",""asdfg"",""asdfgh""] then pure () else error ""assertion failed""
  if candidate ""WWW"" == [""W"",""WW"",""WWW""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_15,azb_Arab,hs,"--٠-دن n-ي قدر، فضايی محدود اولان ساريلاري ايله بير سيراني قاييدير.--  >>> stringSequence 0
--  ""0""
--  >>> stringSequence 5
--  ""0 1 2 3 4 5""
stringSequence :: Int -> String
stringSequence n =","stringSequence :: Int -> String
stringSequence n = unwords $ map show [0..n]","
main :: IO ()
main = do
  let candidate = stringSequence
  if candidate 0 == ""0"" then pure () else error ""assertion failed""
  if candidate 3 == ""0 1 2 3"" then pure () else error ""assertion failed""
  if candidate 10 == ""0 1 2 3 4 5 6 7 8 9 10"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_16,azb_Arab,hs,"--٠ بير سير وئرميش، نئچه آيري حرفدن (حرفين بؤلويو-بؤيوکوندن) اولماسيني بيل.--  >>> countDistinctCharacters ""xyzXYZ""
--  3
--  >>> countDistinctCharacters ""Jerry""
--  4
countDistinctCharacters :: String -> Int
countDistinctCharacters string =","import Data.Char (toLower)
import Data.Set (fromList, size)

countDistinctCharacters :: String -> Int
countDistinctCharacters string = size . fromList $ map toLower string","
main :: IO ()
main = do
  let candidate = countDistinctCharacters
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abcde"" == 5 then pure () else error ""assertion failed""
  if candidate ""abcdecadeCADE"" == 5 then pure () else error ""assertion failed""
  if candidate ""aaaaAAAAaaaa"" == 1 then pure () else error ""assertion failed""
  if candidate ""Jerry jERRY JeRRRY"" == 5 then pure () else error ""assertion failed""
  pure ()"
HumanEval_17,azb_Arab,hs,"--""شاش"" - دؤردونجو نوت، بیر دؤیوشه داوام ائدیر.--""اوشاغی"" - یاریم نوتا، ایکی دؤیوشه داوام ائدیر.--""او"" - بوتون نوتا، دؤرد دؤیوشه داوام ائدیر.--بورادا بير افسانه وار:--آخيردا يوخ.--سیزین ایشینیز بو سِرینی تحلیل ائتمک و هر سِرین نئچه دؤیوشونه اویغون اولان ساییلارین بیر سیرا ساییلارینی قایتارماق دیر.---- بو فؤنکشنین گئرئش سی، مخصوص ASCII فورماتیندا موسیقی نوتا لاری تمثیل ائدن بیر سیم دیر.--  >>> parseMusic ""o o| .| o| o| .| .| .| .| o o""
--  [4,2,1,2,2,1,1,1,1,4,4]
parseMusic :: String -> [Int]
parseMusic music_string =","parseMusic :: String -> [Int]
parseMusic music_string = map beats (words music_string)
  where
    beats ""o"" = 4
    beats ""o|"" = 2
    beats "".|"" = 1
    beats _ = 0","
main :: IO ()
main = do
  let candidate = parseMusic
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""o o o o"" == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate "".| .| .| .|"" == [1,1,1,1] then pure () else error ""assertion failed""
  if candidate ""o| o| .| .| o o o o"" == [2,2,1,1,4,4,4,4] then pure () else error ""assertion failed""
  if candidate ""o| .| o| .| o o| o o|"" == [2,1,2,1,4,2,4,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_18,azb_Arab,hs,"---- نئچه دفعه اوْلان اوْل سارييا اوْل سارييا اوْلدوغونو بیلین. اوْلدوغونو ساییب.--  >>> howManyTimes """" ""a""
--  0
--  >>> howManyTimes ""aaa"" ""a""
--  3
--  >>> howManyTimes ""aaaa"" ""aa""
--  3
howManyTimes :: String -> String -> Int
howManyTimes string substring =","howManyTimes :: String -> String -> Int
howManyTimes string substring
  | null substring = 0
  | otherwise = length . filter isPrefixOfSubstring $ tails string
  where
    isPrefixOfSubstring = isPrefixOf substring
    isPrefixOf :: Eq a => [a] -> [a] -> Bool
    isPrefixOf prefix str = prefix `isPrefixOf` str","
main :: IO ()
main = do
  let candidate = howManyTimes
  if candidate """" ""x"" == 0 then pure () else error ""assertion failed""
  if candidate ""xyxyxyx"" ""x"" == 4 then pure () else error ""assertion failed""
  if candidate ""cacacacac"" ""cac"" == 4 then pure () else error ""assertion failed""
  if candidate ""john doe"" ""john"" == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_19,azb_Arab,hs,"--ان آزدان ان چوخا قدر نؤوبه لنمیش ساري قاییدیر--معتبر سئچیملر ""صفر""، ""بیر""، ""ایکی""، ""اوچ""، ""دؤرد""، ""بئش""، ""التی""، ""یئددی""، ""سەككز"" و ""توقوز"" دیر. --٠-دن ۹-ا قدر اولان عددیلرین بیر سیرا سیری سی واردیر.--  >>> sortNumbers ""three one five""
--  ""one three five""
sortNumbers :: String -> String
sortNumbers numbers =","import Data.List (sort)
import Data.Maybe (fromJust)
import Data.Map (Map, fromList, lookup)

sortNumbers :: String -> String
sortNumbers numbers = unwords $ map snd $ sort $ map (\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)
  where
    wordToNumber :: Map String Int
    wordToNumber = fromList [(""zero"", 0), (""one"", 1), (""two"", 2), (""three"", 3), (""four"", 4),
                             (""five"", 5), (""six"", 6), (""seven"", 7), (""eight"", 8), (""nine"", 9)]","
main :: IO ()
main = do
  let candidate = sortNumbers
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""three"" == ""three"" then pure () else error ""assertion failed""
  if candidate ""three five nine"" == ""three five nine"" then pure () else error ""assertion failed""
  if candidate ""five zero four seven nine eight"" == ""zero four five seven eight nine"" then pure () else error ""assertion failed""
  if candidate ""six five four three two one zero"" == ""zero one two three four five six"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_20,azb_Arab,hs,"--باشقا و اونلاري ترتئبله قايتارين (آز ساي، چوخ ساي).--۰۲.دیرلیگی ۲-دن چوخ اولمایان بیر سایی لیق لیستیندن هر بیریینه ان یاخین اولان ساییلاری سئچیب و یؤنتیردین.--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]
--  (2.0, 2.2)
--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]
--  (2.0, 2.0)
findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers =","findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)
  where
    sortedNumbers = sort numbers
    minByDiff (a1, b1) (a2, b2)
      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)
      | otherwise = (a2, b2)","
main :: IO ()
main = do
  let candidate = findClosestElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_21,azb_Arab,hs,"--بئله کی ان کیچیک سایی 0 و ان بؤیوک سایی 1 اولاجاق --٠. (نئچه عنصردن عبارت) ساييلارين بير سيراسي وئريلن، بو سيراسييا بير خطي ترانسفورماتسييا تطبيق ائده، --  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]
--  [0.0,0.25,0.5,0.75,1.0]
rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers =","rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers = map (\x -> (x - minVal) / range) numbers
  where
    minVal = minimum numbers
    maxVal = maximum numbers
    range = maxVal - minVal","
main :: IO ()
main = do
  let candidate = rescaleToUnit
  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error ""assertion failed""
  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error ""assertion failed""
  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  pure ()"
HumanEval_23,azb_Arab,hs,"--٠.دئدیییین سِره نین اوزونلوغونو قایتار--  >>> strlen """"
--  0
--  >>> strlen ""abc""
--  3
strlen :: String -> Int
strlen string =","strlen :: String -> Int
strlen string = length string","
main :: IO ()
main = do
  let candidate = strlen
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""x"" == 1 then pure () else error ""assertion failed""
  if candidate ""asdasnakj"" == 9 then pure () else error ""assertion failed""
  pure ()"
HumanEval_24,azb_Arab,hs,"--""ن"" اولاراق، ""ن""دن کئچمیش ان بؤیوک سایی نین ""ن""دن کئچمیش ان بؤیوک سایی نین ""ن""دن کئچمیش ان بؤیوک سایی نین ""ن""دن کئچمیش ان بؤیوک سایی نین ""ن""دن کئچمیش ""ن""دن کئچمیش ""ن""دن کئچمیش ""ن""دن کئچمیش ""ن""دن کئچمیش ""ن""دن کئچمیش--  >>> largestDivisor 15
--  5
largestDivisor :: Int -> Int
largestDivisor n =","largestDivisor :: Int -> Int
largestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = largestDivisor
  if candidate 3 == 1 then pure () else error ""assertion failed""
  if candidate 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 == 5 then pure () else error ""assertion failed""
  if candidate 100 == 50 then pure () else error ""assertion failed""
  if candidate 49 == 7 then pure () else error ""assertion failed""
  pure ()"
HumanEval_25,azb_Arab,hs,"--گئرئش ساییسی بوتون فاکتورلارین مولکولونه برابر اولمالیدیر.--هر فاکتورون فاکتورلشدیرمه ده نئچه دفعه گؤرونمه سینه گؤره نئچه دفعه یازیلماسی گرکدیر.--٠: بير ساري ساري ساري بؤلونمه لريني، ان آزيندان ان بؤيوكونه قدر ترتيبله يير.--  >>> factorize 8
--  [2,2,2]
--  >>> factorize 25
--  [5,5]
--  >>> factorize 70
--  [2,5,7]
factorize :: Int -> [Int]
factorize n =","factorize :: Int -> [Int]
factorize n = factorize' n 2
  where
    factorize' 1 _ = []
    factorize' m f
      | m `mod` f == 0 = f : factorize' (m `div` f) f
      | otherwise      = factorize' m (f + 1)","
main :: IO ()
main = do
  let candidate = factorize
  if candidate 2 == [2] then pure () else error ""assertion failed""
  if candidate 4 == [2,2] then pure () else error ""assertion failed""
  if candidate 8 == [2,2,2] then pure () else error ""assertion failed""
  if candidate 57 == [3,19] then pure () else error ""assertion failed""
  if candidate 3249 == [3,3,19,19] then pure () else error ""assertion failed""
  if candidate 185193 == [3,3,3,19,19,19] then pure () else error ""assertion failed""
  if candidate 20577 == [3,19,19,19] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_26,azb_Arab,hs,"--اَلَمَتَکَنین یئرینی آلماسینداکی کیمی یئرینی آلماسینداکی کیمی یئرینی آلماسی.--٠ ساري ساييلار لئستيندن، بير نچه دفعه دن چوخ اولان بوتون ايلمنتلري گؤتور.--  >>> removeDuplicates [1,2,3,2,4]
--  [1,3,4]
removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers =","removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers = filter (\x -> count x numbers == 1) numbers
  where
    count x = length . filter (== x)","
main :: IO ()
main = do
  let candidate = removeDuplicates
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error ""assertion failed""
  pure ()"
HumanEval_27,azb_Arab,hs,"--٠ بير سيرادا، کيچيک حرفلري بؤيوک حرفه و بؤيوک حرفلري کيچيک حرفه چئويريک.--  >>> flipCase ""Hello""
--  ""hELLO""
flipCase :: String -> String
flipCase string =","flipCase :: String -> String
flipCase = map flipChar
  where
    flipChar c
      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)
      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)
      | otherwise = c","
main :: IO ()
main = do
  let candidate = flipCase
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hello!"" == ""hELLO!"" then pure () else error ""assertion failed""
  if candidate ""These violent delights have violent ends"" == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_28,azb_Arab,hs,"--❑ ساريلارين سيراسي ايله بير سارييا باغلاماق--  >>> concatenate []
--  """"
--  >>> concatenate [""a"",""b"",""c""]
--  ""abc""
concatenate :: [String] -> String
concatenate strings =","concatenate :: [String] -> String
concatenate strings = concat strings","
main :: IO ()
main = do
  let candidate = concatenate
  if candidate [] == """" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == ""xyz"" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z"",""w"",""k""] == ""xyzwk"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_29,azb_Arab,hs,"--٠.فيلترليک: بير سيرا سيرلرين داخيلي سيراسي کي، فقط او سيرا سيرلرين کي، بير اؤنيمله باشلايير.--  >>> filterByPrefix [] ""a""
--  []
--  >>> filterByPrefix [""abc"",""bcd"",""cde"",""array""] ""a""
--  [""abc"",""array""]
filterByPrefix :: [String] -> String -> [String]
filterByPrefix strings prefix =","filterByPrefix strings prefix = filter (isPrefixOf prefix) strings
  where
    isPrefixOf pfx str = take (length pfx) str == pfx","
main :: IO ()
main = do
  let candidate = filterByPrefix
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_30,azb_Arab,hs,"--٠ فقط لیستده کی مثبت عددلری گئری قايتارین. ٠--  >>> getPositive [(-1),2,(-4),5,6]
--  [2,5,6]
--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  [5,3,2,3,9,123,1]
getPositive :: [Int] -> [Int]
getPositive l =","getPositive :: [Int] -> [Int]
getPositive l = filter (> 0) l","
main :: IO ()
main = do
  let candidate = getPositive
  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error ""assertion failed""
  if candidate [(-1),(-2)] == [] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_31,azb_Arab,hs,"--اگر بیر اولوملو سایی وارسا true، و باشقا یولدا false یئرینه قاییدیب.--  >>> isPrime 6
--  False
--  >>> isPrime 101
--  True
--  >>> isPrime 11
--  True
--  >>> isPrime 13441
--  True
--  >>> isPrime 61
--  True
--  >>> isPrime 4
--  False
--  >>> isPrime 1
--  False
isPrime :: Int -> Bool
isPrime n =","isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = not (any (\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","
main :: IO ()
main = do
  let candidate = isPrime
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 101 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 13441 == True then pure () else error ""assertion failed""
  if candidate 61 == True then pure () else error ""assertion failed""
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 1 == False then pure () else error ""assertion failed""
  if candidate 5 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 17 == True then pure () else error ""assertion failed""
  if candidate 85 == False then pure () else error ""assertion failed""
  if candidate 77 == False then pure () else error ""assertion failed""
  if candidate 255379 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_33,azb_Arab,hs,"--l'نین مووافقی مؤشره لرینین قئیدلرینه گؤره، آمّا ترتیب ائدیلمیش دیر.--l' اوچا بؤلونمز مؤشره لرده l' ایله عئینی دیر، او حالدا کی، اوچا بؤلونن مؤشره لرده اونون قئیدلری برابر دیر.--بو فاکتئر l-ي گؤتورور و اونو بير ايل-ي قاييدير کي--  >>> sortThird [1,2,3]
--  [1,2,3]
--  >>> sortThird [5,6,3,4,8,9,2]
--  [2,6,3,4,8,9,5]
sortThird :: [Int] -> [Int]
sortThird l =","sortThird :: [Int] -> [Int]
sortThird l = map selectElem indexed
  where
    indexed = zip [0..] l
    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]
    sortedThirdElems = sortedElems thirdIndicesElems
    sortedElems = id -- or List.sort if imported
    selectElem (i, x)
      | i `mod` 3 == 0 = head sortedThirdElems
      | otherwise = x
    replaceSortedElem xs sorted = map selectElem indexed
      where
        replaceElem i (x:xs)
          | i == 0 = x:xs
          | otherwise = replaceElem (i - 1) xs
        selectElem (i, x)
          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)
          | otherwise = x","
main :: IO ()
main = do
  let candidate = sortThird
  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error ""assertion failed""
  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error ""assertion failed""
  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error ""assertion failed""
  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_34,azb_Arab,hs,"--بیر لیستده یالنیز بیر نئچه عنصرین یئرینه یئتیریلمه سینی قاییدیب.--  >>> unique [5,3,5,2,3,3,9,0,123]
--  [0,2,3,5,9,123]
unique :: [Int] -> [Int]
unique l =","unique :: [Int] -> [Int]
unique l = sort $ nub l
  where
    -- | Remove duplicate elements from a list.
    nub :: (Eq a) => [a] -> [a]
    nub [] = []
    nub (x:xs) = x : nub (filter (/= x) xs)

    -- | Sort a list of elements (using QuickSort algorithm).
    sort :: (Ord a) => [a] -> [a]
    sort [] = []
    sort (x:xs) =
      let smallerSorted = sort [a | a <- xs, a <= x]
          biggerSorted = sort [a | a <- xs, a > x]
      in  smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = unique
  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error ""assertion failed""
  pure ()"
HumanEval_35,azb_Arab,hs,"--""فوق العاده""نین یئرینه یئتیریر.--  >>> maxElement [1,2,3]
--  3
--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  123
maxElement :: [Int] -> Int
maxElement l =","maxElement :: [Int] -> Int
maxElement [] = error ""List cannot be empty""
maxElement (x:xs) = maxElementHelper xs x
  where
    maxElementHelper [] currentMax = currentMax
    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","
main :: IO ()
main = do
  let candidate = maxElement
  if candidate [1,2,3] == 3 then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error ""assertion failed""
  pure ()"
HumanEval_36,azb_Arab,hs,"--""7"" ساییسی نین 11 و 13 ایله بؤلونمه سی اوچون ""n"" دن آز اولان عدده لرده گؤرونه جگی ساییسی نین ساییسینی قاییدیب.--  >>> fizzBuzz 50
--  0
--  >>> fizzBuzz 78
--  2
--  >>> fizzBuzz 79
--  3
fizzBuzz :: Int -> Int
fizzBuzz n =","fizzBuzz :: Int -> Int
fizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","
main :: IO ()
main = do
  let candidate = fizzBuzz
  if candidate 50 == 0 then pure () else error ""assertion failed""
  if candidate 78 == 2 then pure () else error ""assertion failed""
  if candidate 79 == 3 then pure () else error ""assertion failed""
  if candidate 100 == 3 then pure () else error ""assertion failed""
  if candidate 200 == 6 then pure () else error ""assertion failed""
  if candidate 4000 == 192 then pure () else error ""assertion failed""
  if candidate 10000 == 639 then pure () else error ""assertion failed""
  if candidate 100000 == 8026 then pure () else error ""assertion failed""
  pure ()"
HumanEval_37,azb_Arab,hs,"--l'ين ايشيک ايشيک لرين قئيدلري، آمّا جورلشميش.--l' l' ایله برابر دیر، او زامان کی اونون قئیدلری برابر ایندیکده برابر دیر --بو فاکتئر l-ي گؤتورور و اونو بير ايل-ي قاييدير کي--  >>> sortEven [1,2,3]
--  [1,2,3]
--  >>> sortEven [5,6,3,4]
--  [3,6,5,4]
sortEven :: [Int] -> [Int]
sortEven l =","sortEven :: [Int] -> [Int]
sortEven l = merge odds sortedEvens
  where
    (odds, evens) = partitionList l
    sortedEvens = sort evens

    partitionList :: [Int] -> ([Int], [Int])
    partitionList [] = ([], [])
    partitionList [x] = ([x], [])
    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)
      where
        (xsOdds, xsEvens) = partitionList xs

    merge :: [Int] -> [Int] -> [Int]
    merge [] ys = ys
    merge (x:xs) [] = x:xs
    merge (x:xs) (y:ys) = x:y:merge xs ys","
main :: IO ()
main = do
  let candidate = sortEven
  if candidate [1,2,3] == [1,2,3] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error ""assertion failed""
  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_39,azb_Arab,hs,"--prime_fib بیر فیبوناچی سایی اولان ن-جی سایی قاییدیب و او دا بیر عینی سایی دیر.--  >>> primeFib 1
--  2
--  >>> primeFib 2
--  3
--  >>> primeFib 3
--  5
--  >>> primeFib 4
--  13
--  >>> primeFib 5
--  89
primeFib :: Int -> Int
primeFib n =","primeFib :: Int -> Int
primeFib n = primeFibs !! (n - 1)
  where
    primeFibs = filter isPrime fibs
    fibs = map fst $ iterate (\(a, b) -> (b, a + b)) (0, 1)

isPrime :: Int -> Bool
isPrime k
  | k < 2 = False
  | k == 2 = True
  | even k = False
  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]
  where
    upperLimit = floor . sqrt $ fromIntegral k","
main :: IO ()
main = do
  let candidate = primeFib
  if candidate 1 == 2 then pure () else error ""assertion failed""
  if candidate 2 == 3 then pure () else error ""assertion failed""
  if candidate 3 == 5 then pure () else error ""assertion failed""
  if candidate 4 == 13 then pure () else error ""assertion failed""
  if candidate 5 == 89 then pure () else error ""assertion failed""
  if candidate 6 == 233 then pure () else error ""assertion failed""
  if candidate 7 == 1597 then pure () else error ""assertion failed""
  if candidate 8 == 28657 then pure () else error ""assertion failed""
  if candidate 9 == 514229 then pure () else error ""assertion failed""
  if candidate 10 == 433494437 then pure () else error ""assertion failed""
  pure ()"
HumanEval_40,azb_Arab,hs,"--صفرین جمعینه، و باشقا یولدا یالان.--اگر اوچ فرقلی عنصری وارسا TRUE قاییدیب--Triple_sum_to_zero، ساییلارین بیر سیرا ساییلارینی گئرئش کیمی قبول ائدیر.--  >>> triplesSumToZero [1,3,5,0]
--  False
--  >>> triplesSumToZero [1,3,(-2),1]
--  True
--  >>> triplesSumToZero [1,2,3,7]
--  False
--  >>> triplesSumToZero [2,4,(-5),3,9,7]
--  True
--  >>> triplesSumToZero [1]
--  False
triplesSumToZero :: [Int] -> Bool
triplesSumToZero l =","triplesSumToZero :: [Int] -> Bool
triplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]
  where
    tails [] = []
    tails xs@(_:xs') = xs : tails xs'","
main :: IO ()
main = do
  let candidate = triplesSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-1)] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [1,2,5,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,9,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-100)] == False then pure () else error ""assertion failed""
  if candidate [100,3,5,(-100)] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_41,azb_Arab,hs,"--بو فونکشن بو جور تصادفلرین سایی سینی آچیقلاماقدادیر.--و او زامان سانکي اونلار بئربئرلري ائله راستلاشماميشديلار.--آنجاق، بو ماشينلار حدسئز گوجلو و مؤحکملر؛ و بونون نتئجه سينده، حرکتده داوام ائديرلر.--او زامان کي، سولدان ساغا گئدن بير ماشين، ساغدان سولا گئدن بير ماشينا ضربه وورور.--هر ماشين بير سرعتده حرکت ائدير.--ماشینلارین ایکی جورو، چوخ اوزاقدان باشلاییب.--n ماشین سول طرفه و ساغ طرفه حرکت ائدیر؛ بیر آندا، n ماشینین فرقلی بیر سیری --٠ تصور کنيد يک جاده که يک خط بي نهایت طولاني و کاملا مستقيم باشه ٠carRaceCollision :: Int -> Int
carRaceCollision n =","carRaceCollision :: Int -> Int
carRaceCollision n = n","
main :: IO ()
main = do
  let candidate = carRaceCollision
  if candidate 2 == 4 then pure () else error ""assertion failed""
  if candidate 3 == 9 then pure () else error ""assertion failed""
  if candidate 4 == 16 then pure () else error ""assertion failed""
  if candidate 8 == 64 then pure () else error ""assertion failed""
  if candidate 10 == 100 then pure () else error ""assertion failed""
  pure ()"
HumanEval_42,azb_Arab,hs,"--۱-دن چوخ اولان عنصرلری بیر یئره قایتار.--  >>> incrList [1,2,3]
--  [2,3,4]
--  >>> incrList [5,3,5,2,3,3,9,0,123]
--  [6,4,6,3,4,4,10,1,124]
incrList :: [Int] -> [Int]
incrList l =","incrList :: [Int] -> [Int]
incrList l = map (+1) l","
main :: IO ()
main = do
  let candidate = incrList
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [4,3,2] then pure () else error ""assertion failed""
  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error ""assertion failed""
  pure ()"
HumanEval_43,azb_Arab,hs,"--صفرین جمعینه، و باشقا یولدا یالان.--اگر لیستده  اوْنلارین آراسینداکی ایکی آیری بیر عنصر وارسا true قاییدیب.--pairs_sum_to_zero، سایی سیز ساییلارین بیر سیرا ساییلارینی گئرئش کیمی قبول ائدیر.--  >>> pairsSumToZero [1,3,5,0]
--  False
--  >>> pairsSumToZero [1,3,(-2),1]
--  False
--  >>> pairsSumToZero [1,2,3,7]
--  False
--  >>> pairsSumToZero [2,4,(-5),3,5,7]
--  True
--  >>> pairsSumToZero [1]
--  False
pairsSumToZero :: [Int] -> Bool
pairsSumToZero l =","pairsSumToZero :: [Int] -> Bool
pairsSumToZero l = any (\x -> -x `elem` l) l && (length l > 1)","
main :: IO ()
main = do
  let candidate = pairsSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,5,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_44,azb_Arab,hs,"--اساس ساييلاري 10 دان آزدير.--چئویرمه دن سونرا string تمثیلینی قایتار.--٠ عددي اساسين گئرئش سايي x-دن اساسا چئويريک. ٠--  >>> changeBase 8 3
--  ""22""
--  >>> changeBase 8 2
--  ""1000""
--  >>> changeBase 7 2
--  ""111""
changeBase :: Int -> Int -> String
changeBase x base =","changeBase :: Int -> Int -> String
changeBase x base
  | x < base  = show x
  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","
main :: IO ()
main = do
  let candidate = changeBase
  if candidate 8 3 == ""22"" then pure () else error ""assertion failed""
  if candidate 9 3 == ""100"" then pure () else error ""assertion failed""
  if candidate 234 2 == ""11101010"" then pure () else error ""assertion failed""
  if candidate 16 2 == ""10000"" then pure () else error ""assertion failed""
  if candidate 8 2 == ""1000"" then pure () else error ""assertion failed""
  if candidate 7 2 == ""111"" then pure () else error ""assertion failed""
  if candidate 2 3 == ""2"" then pure () else error ""assertion failed""
  if candidate 3 4 == ""3"" then pure () else error ""assertion failed""
  if candidate 4 5 == ""4"" then pure () else error ""assertion failed""
  if candidate 5 6 == ""5"" then pure () else error ""assertion failed""
  if candidate 6 7 == ""6"" then pure () else error ""assertion failed""
  if candidate 7 8 == ""7"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_45,azb_Arab,hs,"--٠ طول يک طرف و ارتفاع يک منطقه بازگشت مثلث--  >>> triangleArea 5 3
--  7.5
triangleArea :: Int -> Int -> Float
triangleArea a h =","triangleArea :: Int -> Int -> Float
triangleArea a h = 0.5 * fromIntegral a * fromIntegral h","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 5 3 == 7.5 then pure () else error ""assertion failed""
  if candidate 2 2 == 2.0 then pure () else error ""assertion failed""
  if candidate 10 8 == 40.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_46,azb_Arab,hs,"--لطفاً بیر فاکتوری یازین کی fib4 سایین سیراسی نین ن-جی عنصرینی موثبت حساب ائدسین.--fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --Fib4 عدد سیکسنسی، فیبوناچی سیکسنسییه بنزر بیر سیکسنس دیر کی، بو کیمی تعریف اولونور:--  >>> fib4 5
--  4
--  >>> fib4 6
--  8
--  >>> fib4 7
--  14
fib4 :: Int -> Int
fib4 n =","fib4 :: Int -> Int
fib4 n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 2
  | n == 3 = 0
  | otherwise = iter 0 0 2 0 n
  where
    iter a b c d 4 = a + b + c + d
    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","
main :: IO ()
main = do
  let candidate = fib4
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 28 then pure () else error ""assertion failed""
  if candidate 10 == 104 then pure () else error ""assertion failed""
  if candidate 12 == 386 then pure () else error ""assertion failed""
  pure ()"
HumanEval_47,azb_Arab,hs,"--l-list-element-median-و قايتارير.--  >>> median [3,1,2,4,5]
--  3.0
--  >>> median [(-10),4,6,1000,10,20]
--  15.0
median :: [Int] -> Float
median l =","median :: [Int] -> Float
median l 
  | odd n     = fromIntegral $ sorted !! mid
  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) / 2
  where
    sorted = sort l
    n = length l
    mid = n `div` 2
    sort = sortBy compare","
main :: IO ()
main = do
  let candidate = median
  if candidate [3,1,2,4,5] == 3.0 then pure () else error ""assertion failed""
  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error ""assertion failed""
  if candidate [5] == 5.0 then pure () else error ""assertion failed""
  if candidate [6,5] == 5.5 then pure () else error ""assertion failed""
  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_48,azb_Arab,hs,"--چک می کند که آیا string palindrome است یا نه.--  >>> isPalindrome """"
--  True
--  >>> isPalindrome ""aba""
--  True
--  >>> isPalindrome ""aaaaa""
--  True
--  >>> isPalindrome ""zbcd""
--  False
isPalindrome :: String -> Bool
isPalindrome text =","isPalindrome :: String -> Bool
isPalindrome text = text == reverse text","
main :: IO ()
main = do
  let candidate = isPalindrome
  if candidate """" == True then pure () else error ""assertion failed""
  if candidate ""aba"" == True then pure () else error ""assertion failed""
  if candidate ""aaaaa"" == True then pure () else error ""assertion failed""
  if candidate ""zbcd"" == False then pure () else error ""assertion failed""
  if candidate ""xywyx"" == True then pure () else error ""assertion failed""
  if candidate ""xywyz"" == False then pure () else error ""assertion failed""
  if candidate ""xywzx"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_49,azb_Arab,hs,"--2^n modulo p (آنا ساییلارین آچیق اولماسینی بیلیر)--  >>> modp 3 5
--  3
--  >>> modp 1101 101
--  2
--  >>> modp 0 101
--  1
--  >>> modp 3 11
--  8
--  >>> modp 100 101
--  1
modp :: Int -> Int -> Int
modp n p =","modp :: Int -> Int -> Int
modp n p = powMod 2 n p

powMod :: Int -> Int -> Int -> Int
powMod base exp modulus
  | modulus == 1 = 0
  | exp == 0     = 1
  | exp == 1     = base `mod` modulus
  | otherwise    = if odd exp
                   then (base * halfExp * halfExp) `mod` modulus
                   else (halfExp * halfExp) `mod` modulus
  where
    halfExp = powMod base (exp `div` 2) modulus","
main :: IO ()
main = do
  let candidate = modp
  if candidate 3 5 == 3 then pure () else error ""assertion failed""
  if candidate 1101 101 == 2 then pure () else error ""assertion failed""
  if candidate 0 101 == 1 then pure () else error ""assertion failed""
  if candidate 3 11 == 8 then pure () else error ""assertion failed""
  if candidate 100 101 == 1 then pure () else error ""assertion failed""
  if candidate 30 5 == 4 then pure () else error ""assertion failed""
  if candidate 31 5 == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_51,azb_Arab,hs,"--remove_vowels فانکشنی دیر کی، سِرلرین سِرلرینی آلیر و سِرلرین سِرلرینی سِرلرسیز قایتاریر.--  >>> removeVowels """"
--  """"
--  >>> removeVowels ""abcdef""
--  ""bcdf""
--  >>> removeVowels ""aaaaa""
--  """"
--  >>> removeVowels ""aaBAA""
--  ""B""
--  >>> removeVowels ""zbcd""
--  ""zbcd""
removeVowels :: String -> String
removeVowels text =","removeVowels :: String -> String
removeVowels text = filter (`notElem` ""aeiouAEIOU"") text","
main :: IO ()
main = do
  let candidate = removeVowels
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""abcdef
ghijklm"" == ""bcdf
ghjklm"" then pure () else error ""assertion failed""
  if candidate ""fedcba"" == ""fdcb"" then pure () else error ""assertion failed""
  if candidate ""eeeee"" == """" then pure () else error ""assertion failed""
  if candidate ""acBAA"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""EcBOO"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""ybcd"" == ""ybcd"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_52,azb_Arab,hs,"--اگر l آداسینداکی بوتون ساییلار آداسی نین آداسیندان آشاغی اولسا TRUE قاییدیب.--  >>> belowThreshold [1,2,4,10] 100
--  True
--  >>> belowThreshold [1,20,4,10] 5
--  False
belowThreshold :: [Int] -> Int -> Bool
belowThreshold l t =",belowThreshold l t = all (< t) l,"
main :: IO ()
main = do
  let candidate = belowThreshold
  if candidate [1,2,4,10] 100 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 5 == False then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 21 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 22 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 11 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_53,azb_Arab,hs,"--ايکي عدد x و y جمع ائدير.--  >>> add 2 3
--  5
--  >>> add 5 7
--  12
add :: Int -> Int -> Int
add x y =","add :: Int -> Int -> Int
add x y = x + y","
main :: IO ()
main = do
  let candidate = add
  if candidate 0 1 == 1 then pure () else error ""assertion failed""
  if candidate 1 0 == 1 then pure () else error ""assertion failed""
  if candidate 2 3 == 5 then pure () else error ""assertion failed""
  if candidate 5 7 == 12 then pure () else error ""assertion failed""
  if candidate 7 5 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_54,azb_Arab,hs,"--٠ باخين آيا ايکي سؤزون حرفلري بير دگرلي دير. ٠--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc""
--  True
--  >>> sameChars ""abcd"" ""dddddddabc""
--  True
--  >>> sameChars ""dddddddabc"" ""abcd""
--  True
--  >>> sameChars ""eabcd"" ""dddddddabc""
--  False
--  >>> sameChars ""abcd"" ""dddddddabce""
--  False
--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc""
--  False
sameChars :: String -> String -> Bool
sameChars s0 s1 =","import Data.List (nub, sort)

sameChars :: String -> String -> Bool
sameChars s0 s1 = sort (nub s0) == sort (nub s1)","
main :: IO ()
main = do
  let candidate = sameChars
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddeddabc"" == True then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabc"" == True then pure () else error ""assertion failed""
  if candidate ""dddddddabc"" ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""eabcd"" ""dddddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabcf"" == False then pure () else error ""assertion failed""
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""aabb"" ""aaccc"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_55,azb_Arab,hs,"--""فئبوناشی نین ن-جی سایی"" نی قایتار.--  >>> fib 10
--  55
--  >>> fib 1
--  1
--  >>> fib 8
--  21
fib :: Int -> Int
fib n =","fib :: Int -> Int
fib n = fibHelper 0 1 n
  where
    fibHelper a _ 0 = a
    fibHelper a b n = fibHelper b (a + b) (n - 1)","
main :: IO ()
main = do
  let candidate = fib
  if candidate 10 == 55 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 8 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 89 then pure () else error ""assertion failed""
  if candidate 12 == 144 then pure () else error ""assertion failed""
  pure ()"
HumanEval_56,azb_Arab,hs,"--return True اگر هر آچینما قوسونون بیر قارشیلی باغلانما قوسوسو وارسا. --""<"" و "">"" حرفلرینین بیر سیرا سی دیر.--  >>> correctBracketing ""<""
--  False
--  >>> correctBracketing ""<>""
--  True
--  >>> correctBracketing ""<<><>>""
--  True
--  >>> correctBracketing ""><<>""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBrackets brackets 0 == 0

checkBrackets :: String -> Int -> Int
checkBrackets [] n = n
checkBrackets (x:xs) n
  | n < 0 = -1
  | x == '<' = checkBrackets xs (n + 1)
  | x == '>' = checkBrackets xs (n - 1)
  | otherwise = checkBrackets xs n","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""<>"" == True then pure () else error ""assertion failed""
  if candidate ""<<><>>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<<><><>><>><<><><<>>>"" == True then pure () else error ""assertion failed""
  if candidate ""<<<><>>>>"" == False then pure () else error ""assertion failed""
  if candidate ""><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<"" == False then pure () else error ""assertion failed""
  if candidate ""<<<<"" == False then pure () else error ""assertion failed""
  if candidate "">"" == False then pure () else error ""assertion failed""
  if candidate ""<<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>>><>"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_57,azb_Arab,hs,"--""Return True"" list elements are monotonically increasing or decreasing. ""Return True"" list elements are monotonically increasing or decreasing. ""Return True"" list elements are monotonically increasing or decreasing. ""Return True"" list elements are monotonically increasing or decreasing.--  >>> monotonic [1,2,4,20]
--  True
--  >>> monotonic [1,20,4,10]
--  False
--  >>> monotonic [4,1,0,(-10)]
--  True
monotonic :: [Int] -> Bool
monotonic l =","monotonic :: [Int] -> Bool
monotonic l = increasing l || decreasing l
  where
    increasing xs = all (uncurry (<=)) (zip xs (tail xs))
    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","
main :: IO ()
main = do
  let candidate = monotonic
  if candidate [1,2,4,10] == True then pure () else error ""assertion failed""
  if candidate [1,2,4,20] == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] == False then pure () else error ""assertion failed""
  if candidate [4,1,0,(-10)] == True then pure () else error ""assertion failed""
  if candidate [4,1,1,0] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,2,5,60] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,60] == True then pure () else error ""assertion failed""
  if candidate [9,9,9,9] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_58,azb_Arab,hs,"--٠ بيرينجي سيستمده کي بيرجه بير ايلملي عنصرلري آييرد ائتمه--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]
--  [1,5,653]
--  >>> common [5,3,2,8] [3,2]
--  [2,3]
common :: [Int] -> [Int] -> [Int]
common l1 l2 =","common :: [Int] -> [Int] -> [Int]
common l1 l2 = uniqueSortedCommon
  where
    commonElements = filter (`elem` l2) l1
    uniqueCommon = removeDuplicates commonElements
    uniqueSortedCommon = sort uniqueCommon

    removeDuplicates :: [Int] -> [Int]
    removeDuplicates = foldr (\x seen -> if x `elem` seen then seen else x : seen) []

    sort :: [Int] -> [Int]
    sort [] = []
    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)
      where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs","
main :: IO ()
main = do
  let candidate = common
  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error ""assertion failed""
  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_59,azb_Arab,hs,"--""n""ین ان بؤیوک اساس فاکتورونو قایتار. فرض ائدک کی، ""n"" ۱-دن بؤیوکدور و بیر اساس فاکتور دئییل.--  >>> largestPrimeFactor 13195
--  29
--  >>> largestPrimeFactor 2048
--  2
largestPrimeFactor :: Int -> Int
largestPrimeFactor n =","largestPrimeFactor :: Int -> Int
largestPrimeFactor n = helper n 2
  where
    helper n factor
      | factor * factor > n = n
      | n `mod` factor == 0 = helper (n `div` factor) factor
      | otherwise = helper n (factor + 1)","
main :: IO ()
main = do
  let candidate = largestPrimeFactor
  if candidate 15 == 5 then pure () else error ""assertion failed""
  if candidate 27 == 3 then pure () else error ""assertion failed""
  if candidate 63 == 7 then pure () else error ""assertion failed""
  if candidate 330 == 11 then pure () else error ""assertion failed""
  if candidate 13195 == 29 then pure () else error ""assertion failed""
  pure ()"
HumanEval_60,azb_Arab,hs,"--sum_to_n بیر تابع دیر کی 1 دن n-ه قدر اولان ساییلاری بیرلشدیریر.--  >>> sumToN 30
--  465
--  >>> sumToN 100
--  5050
--  >>> sumToN 5
--  15
--  >>> sumToN 10
--  55
--  >>> sumToN 1
--  1
sumToN :: Int -> Int
sumToN n =","sumToN :: Int -> Int
sumToN n = sum [1..n]","
main :: IO ()
main = do
  let candidate = sumToN
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 66 then pure () else error ""assertion failed""
  if candidate 30 == 465 then pure () else error ""assertion failed""
  if candidate 100 == 5050 then pure () else error ""assertion failed""
  pure ()"
HumanEval_61,azb_Arab,hs,"--return True اگر هر آچینما قوسونون بیر قارشیلی باغلانما قوسوسو وارسا. --.برانتس (brackets) ، "" (("" و """") ،--  >>> correctBracketing ""(""
--  False
--  >>> correctBracketing ""()""
--  True
--  >>> correctBracketing ""(()())""
--  True
--  >>> correctBracketing "")(()""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBalance brackets 0
  where
    checkBalance [] 0 = True
    checkBalance [] _ = False
    checkBalance (x:xs) n
      | x == '('  = checkBalance xs (n + 1)
      | x == ')' && n > 0 = checkBalance xs (n - 1)
      | otherwise = False","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""()"" == True then pure () else error ""assertion failed""
  if candidate ""(()())"" == True then pure () else error ""assertion failed""
  if candidate ""()()(()())()"" == True then pure () else error ""assertion failed""
  if candidate ""()()((()()())())(()()(()))"" == True then pure () else error ""assertion failed""
  if candidate ""((()())))"" == False then pure () else error ""assertion failed""
  if candidate "")(()"" == False then pure () else error ""assertion failed""
  if candidate ""("" == False then pure () else error ""assertion failed""
  if candidate ""(((("" == False then pure () else error ""assertion failed""
  if candidate "")"" == False then pure () else error ""assertion failed""
  if candidate ""(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())())(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())()))()"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_62,azb_Arab,hs,"--بو پولینومین مشتقینی همن شکیلده قایتار.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --x لر بیر چوخملیین ضریبلرینی تمثیل ائدیر.--  >>> derivative [3,1,2,4,5]
--  [1,4,12,20]
--  >>> derivative [1,2,3]
--  [2,6]
derivative :: [Int] -> [Int]
derivative xs =","derivative :: [Int] -> [Int]
derivative xs = zipWith (*) (tail xs) [1..]","
main :: IO ()
main = do
  let candidate = derivative
  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,6] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [2,2] then pure () else error ""assertion failed""
  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error ""assertion failed""
  if candidate [1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_63,azb_Arab,hs,"--لطفاً بیر فاکتوری یازین کی، fibfib عدد سیکسنسی نین ن-جی عنصرینی موثبت حساب ائدسین.--fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3).--fib fib ((2) == 1 --0 0--0 0 0--فئبوناکچي سيراسي نين تشبيه سي ايله فئبوناکچي سيراسي نين تشبيه سي بودور:--  >>> fibfib 1
--  0
--  >>> fibfib 5
--  4
--  >>> fibfib 8
--  24
fibfib :: Int -> Int
fibfib n =","fibfib :: Int -> Int
fibfib n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 1
  | otherwise = fibs !! n
  where
    fibs = 0 : 0 : 1 : zipWith3 (\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","
main :: IO ()
main = do
  let candidate = fibfib
  if candidate 2 == 1 then pure () else error ""assertion failed""
  if candidate 1 == 0 then pure () else error ""assertion failed""
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 24 then pure () else error ""assertion failed""
  if candidate 10 == 81 then pure () else error ""assertion failed""
  if candidate 12 == 274 then pure () else error ""assertion failed""
  if candidate 14 == 927 then pure () else error ""assertion failed""
  pure ()"
HumanEval_64,azb_Arab,hs,"--اؤرنک: --سسلي، آنجاق او زامان کي، بو، سؤزون سونوندا اولور.--بو حالدا سسلی حرفلر ""a""، ""e""، ""i""، ""o""، ""u"" دیر. بورادا ""y"" ده a دیر.--بير سؤزجوک گئرئش اولاراق و سسلردهکي سسلي حرفلرين ساييني قاييدير.--٠ فاکوللار_سايلاشما فاکول يازين کي، ٠-ي تمثيل ائدن بير سيرال گؤتورسون.--  >>> vowelsCount ""abcde""
--  2
--  >>> vowelsCount ""ACEDY""
--  3
vowelsCount :: String -> Int
vowelsCount s =","vowelsCount :: String -> Int
vowelsCount s = length $ filter isVowel $ zip s [1..]
  where
    isVowel (c, pos) =
      let lowercaseC = toLower c
          isRegularVowel = lowercaseC `elem` ""aeiou""
          isLastCharY = lowercaseC == 'y' && pos == length s
      in isRegularVowel || isLastCharY","
main :: IO ()
main = do
  let candidate = vowelsCount
  if candidate ""abcde"" == 2 then pure () else error ""assertion failed""
  if candidate ""Alone"" == 3 then pure () else error ""assertion failed""
  if candidate ""key"" == 2 then pure () else error ""assertion failed""
  if candidate ""bye"" == 1 then pure () else error ""assertion failed""
  if candidate ""keY"" == 2 then pure () else error ""assertion failed""
  if candidate ""bYe"" == 1 then pure () else error ""assertion failed""
  if candidate ""ACEDY"" == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_65,azb_Arab,hs,"--اگر shift > digit ساییسی اولسا، digit لرین یئرینه یئتیریلسین.--و نتيجه رو به صورت يک رشته برميگردونه.---- دایره لی حرکت لر، x سایی نین عددی، عددی دوز طرفه حرکت ائتمک.--  >>> circularShift 12 1
--  ""21""
--  >>> circularShift 12 2
--  ""12""
circularShift :: Int -> Int -> String
circularShift x shift =","circularShift :: Int -> Int -> String
circularShift x shift =
  let digits = show x
      len = length digits
      effectiveShift = shift `mod` len
  in if shift > len
     then reverse digits
     else let (begin, end) = splitAt (len - effectiveShift) digits
          in end ++ begin","
main :: IO ()
main = do
  let candidate = circularShift
  if candidate 100 2 == ""001"" then pure () else error ""assertion failed""
  if candidate 12 2 == ""12"" then pure () else error ""assertion failed""
  if candidate 97 8 == ""79"" then pure () else error ""assertion failed""
  if candidate 12 1 == ""21"" then pure () else error ""assertion failed""
  if candidate 11 101 == ""11"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_66,azb_Arab,hs,"--اؤرنکلر: --ASCII کودلار. --بیر فانکشن یازین کی، بیر سِره نی گئرئش کیمی قبول ائدیر و یالنیز اوُرتاق حرف لرین جمعینی قایتاریر"".--""مهمّت""--  >>> digitsum """"
--  0
--  >>> digitsum ""abAB""
--  131
--  >>> digitsum ""abcCd""
--  67
--  >>> digitsum ""helloE""
--  69
--  >>> digitsum ""woArBld""
--  131
--  >>> digitsum ""aAaaaXa""
--  153
digitsum :: String -> Int
digitsum s =","digitsum :: String -> Int
digitsum s = sum $ map fromEnum $ filter isUpper s","
main :: IO ()
main = do
  let candidate = digitsum
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abAB"" == 131 then pure () else error ""assertion failed""
  if candidate ""abcCd"" == 67 then pure () else error ""assertion failed""
  if candidate ""helloE"" == 69 then pure () else error ""assertion failed""
  if candidate ""woArBld"" == 131 then pure () else error ""assertion failed""
  if candidate ""aAaaaXa"" == 153 then pure () else error ""assertion failed""
  if candidate "" How are yOu?"" == 151 then pure () else error ""assertion failed""
  if candidate ""You arE Very Smart"" == 327 then pure () else error ""assertion failed""
  pure ()"
HumanEval_67,azb_Arab,hs,"--"" اِکسامبل "" اوچون:--سبدده اولان مونو میوه لرین سایی سینی قایتارین.--اورنج و آلما و بیر عدد کی میوه لرین مجموع سایی سینی تمثیل ائدیر --آلما، نارنج و مانجو میوه لری.--بو سبدده اولان مئيوه لر سبدده پايلانير .---- بو ايشده، سيزه بير سيرالار ورئله جک کي، ساري و نارنجين سايي سيني تمثيل ائده جک.--  >>> fruitDistribution ""5 apples and 6 oranges"" 19
--  8
--  >>> fruitDistribution ""0 apples and 1 oranges"" 3
--  2
--  >>> fruitDistribution ""2 apples and 3 oranges"" 100
--  95
--  >>> fruitDistribution ""100 apples and 1 oranges"" 120
--  19
fruitDistribution :: String -> Int -> Int
fruitDistribution s n =","import Text.Read (readMaybe)

fruitDistribution :: String -> Int -> Int
fruitDistribution s n = n - totalApplesOranges
  where
    totalApplesOranges = sum $ map (readNumber . words) [""apples"", ""oranges""]
    readNumber keyword = case dropWhile (not . (=="" "") . dropWhile (/=' ')) $ words s of
      [] -> 0
      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","
main :: IO ()
main = do
  let candidate = fruitDistribution
  if candidate ""5 apples and 6 oranges"" 19 == 8 then pure () else error ""assertion failed""
  if candidate ""5 apples and 6 oranges"" 21 == 10 then pure () else error ""assertion failed""
  if candidate ""0 apples and 1 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""1 apples and 0 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 100 == 95 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 5 == 0 then pure () else error ""assertion failed""
  if candidate ""1 apples and 100 oranges"" 120 == 19 then pure () else error ""assertion failed""
  pure ()"
HumanEval_68,azb_Arab,hs,"--مثال 1:--اگر برابر قئیدلر یوخسا و یا وئریلن لیست بوشدور، [] قاییدیب.--آلینمیش گره ک بیر لیستده قایتاریلمالیدیر، [ smalest_value، its index ]، --اگر نئچه گئچه ن نوْدلارین ان آز برابر قئیدینه مالیک اولماسی اۆچون، ان آز ایندئکسه مالیک اولان نوْدونو قایتار. --آلینمیش گره ک، ان آز جومله قدرینه مالیک گره ک اولمالیدیر.--ایشینیز بیر گره کدن آلماق و اونو یئنه گئری گتیرمک دیر.--""بیر آغاجین شاخه سینی تمثیل ائدن بیر لیست وئریلننده منفی اولمایان بوتون عددی گره کلر وار --  >>> pluck [4,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 2:
--  >>> pluck [1,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 3:
--  >>> pluck []
--  []
--  Example 4:
--  >>> pluck [5,0,3,0,4,2]
--  [0,1]
--  Explanation: 0 is the smallest value, but  there are two zeros,
--  so we will choose the first zero, which has the smallest index.
--  Constraints:
--  * 1 <= nodes.length <= 10000
--  * 0 <= node.value
pluck :: [Int] -> [Int]
pluck arr =","pluck :: [Int] -> [Int]
pluck arr = case filter (\(x, _) -> even x) (zip arr [0..]) of
    [] -> []
    evens -> let (value, index) = minimum evens in [value, index]","
main :: IO ()
main = do
  let candidate = pluck
  if candidate [4,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error ""assertion failed""
  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error ""assertion failed""
  if candidate [5,4,8,4,8] == [4,1] then pure () else error ""assertion failed""
  if candidate [7,6,7,1] == [6,1] then pure () else error ""assertion failed""
  if candidate [7,9,7,1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_69,azb_Arab,hs,"--اؤرنکلر: --اگر بو قدر یوخدور، -1 قاییدیب.--بیر عددین فریکونسییاسی، اونون لیستده نئچه دفعه گؤرونمه سی ساییسی دیر.--صفر، و چوخلوغو اؤزونون قدرینه برابر و یا داها چوخدور.--٠ ايجتيماعي ساييلارين بير بوش اولمايان سيراسي وريلير.--  >>> search [4,1,2,2,3,1]
--  2
--  >>> search [1,2,2,3,3,3,4,4,4]
--  3
--  >>> search [5,5,4,4,4]
--  (-1)
search :: [Int] -> Int
search lst =","import Data.List (group, sort)
import Data.Ord (comparing)

search :: [Int] -> Int
search lst = 
    let frequencies = map (\g -> (head g, length g)) . group . sort $ lst
        candidates = filter (\(val, freq) -> freq >= val) frequencies
    in case candidates of
         [] -> -1
         _  -> fst . maximum $ candidates","
main :: IO ()
main = do
  let candidate = search
  if candidate [5,5,5,5,1] == 1 then pure () else error ""assertion failed""
  if candidate [4,1,4,1,4,4] == 4 then pure () else error ""assertion failed""
  if candidate [3,3] == (-1) then pure () else error ""assertion failed""
  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error ""assertion failed""
  if candidate [2,3,3,2,2] == 2 then pure () else error ""assertion failed""
  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error ""assertion failed""
  if candidate [3,2,8,2] == 2 then pure () else error ""assertion failed""
  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error ""assertion failed""
  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error ""assertion failed""
  if candidate [1,9,10,1,3] == 1 then pure () else error ""assertion failed""
  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error ""assertion failed""
  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error ""assertion failed""
  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error ""assertion failed""
  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error ""assertion failed""
  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error ""assertion failed""
  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error ""assertion failed""
  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error ""assertion failed""
  if candidate [10] == (-1) then pure () else error ""assertion failed""
  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error ""assertion failed""
  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error ""assertion failed""
  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error ""assertion failed""
  if candidate [3,10,10,9,2] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_70,azb_Arab,hs,"--اؤرنکلر: --سونرا قالان بوتون ساييلارين ان چوخو، سونرا لاپ آزي و س.--عجیب ترتیب، اینه که شما با حداقل مقدار شروع میکنید، --٠:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰--  >>> strangeSortList [1,2,3,4]
--  [1,4,2,3]
--  >>> strangeSortList [5,5,5,5]
--  [5,5,5,5]
--  >>> strangeSortList []
--  []
strangeSortList :: [Int] -> [Int]
strangeSortList lst =","strangeSortList :: [Int] -> [Int]
strangeSortList [] = []
strangeSortList lst = go (sort lst) True
  where
    go [] _ = []
    go xs toggle
      | toggle    = head xs : go (tail xs) False
      | otherwise = last xs : go (init xs) True","
main :: IO ()
main = do
  let candidate = strangeSortList
  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error ""assertion failed""
  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error ""assertion failed""
  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error ""assertion failed""
  if candidate [111111] == [111111] then pure () else error ""assertion failed""
  pure ()"
HumanEval_71,azb_Arab,hs,"--اؤرنک: --اوچونجو طرفدن.--اوچ طرف هئچ هانسی ایکی طرفین مجموعی داها چوخ اولماسا، اوچ گوشه لی بیر مثلث یارادیر.--یوخسا، -1 قاییدیب.--اوچ طرفی اعتبارلی بیر مثلث اولسا، اوچو مثلث 2 اعشاری نقطه یه داییرلانمیش اولور.--مثلثین اوچ طرفینین اوزونلوغونو وئردیکده،--  >>> triangleArea 3 4 5
--  6.0
--  >>> triangleArea 1 2 10
--  (-1).0
triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c =","import Text.Printf (printf)

triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c
    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))
    | otherwise = -1
  where
    s = (fromIntegral (a + b + c)) / 2
    isValidTriangle x y z = x + y > z && x + z > y && y + z > x
    roundToTwoDecimals x = read (printf ""%.2f"" x) :: Float","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 3 4 5 == 6.0 then pure () else error ""assertion failed""
  if candidate 1 2 10 == (-1).0 then pure () else error ""assertion failed""
  if candidate 4 8 5 == 8.18 then pure () else error ""assertion failed""
  if candidate 2 2 2 == 1.73 then pure () else error ""assertion failed""
  if candidate 1 2 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 10 5 7 == 16.25 then pure () else error ""assertion failed""
  if candidate 2 6 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 1 1 1 == 0.43 then pure () else error ""assertion failed""
  if candidate 2 2 10 == (-1).0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_72,azb_Arab,hs,"--اؤرنک: --q آبجکت اگر متعادل اولسا اوچاجاق (بو پایلندروم لیستی دیر) و اونون عنصری نین مجموعی ایسه w ان چوخ اولابیله جک وزنین دن آز و یا برابر دیر.--٠ فاکتسييالي يازين کي، اگر q آبجکت اوچاجاقسا، دوغرو و اگر اوچماياجاقسا، يالان جاوابيني قايتارسين.--  >>> willItFly [1,2] 5
--  False
--  # 1+2 is less than the maximum possible weight, but it's unbalanced.
--  >>> willItFly [3,2,3] 1
--  False
--  # it's balanced, but 3+2+3 is more than the maximum possible weight.
--  >>> willItFly [3,2,3] 9
--  True
--  # 3+2+3 is less than the maximum possible weight, and it's balanced.
--  >>> willItFly [3] 5
--  True
--  # 3 is less than the maximum possible weight, and it's balanced.
willItFly :: [Int] -> Int -> Bool
willItFly q w =","willItFly :: [Int] -> Int -> Bool
willItFly q w = isPalindrome q && sum q <= w

isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs","
main :: IO ()
main = do
  let candidate = willItFly
  if candidate [3,2,3] 9 == True then pure () else error ""assertion failed""
  if candidate [1,2] 5 == False then pure () else error ""assertion failed""
  if candidate [3] 5 == True then pure () else error ""assertion failed""
  if candidate [3,2,3] 1 == False then pure () else error ""assertion failed""
  if candidate [1,2,3] 6 == False then pure () else error ""assertion failed""
  if candidate [5] 5 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_73,azb_Arab,hs,"--مثلن: --هر ائلیمنتین بیر عوضینه باشقا بیر عوضین یئرینه یئرلشدیریر.--بو لیستین پالندروم اولماسی اوچون اونو دَییشدیرمک لازیمدیر.--آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر آر--  >>> smallestChange [1,2,3,5,4,7,9,6]
--  4
--  >>> smallestChange [1,2,3,4,3,2,2]
--  1
--  >>> smallestChange [1,2,3,2,1]
--  0
smallestChange :: [Int] -> Int
smallestChange arr =","smallestChange :: [Int] -> Int
smallestChange arr = sum $ zipWith (\x y -> if x /= y then 1 else 0) arr (reverse arr)","
main :: IO ()
main = do
  let candidate = smallestChange
  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error ""assertion failed""
  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,2,3,2,1] == 0 then pure () else error ""assertion failed""
  if candidate [3,1,1,3] == 0 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_74,azb_Arab,hs,"--اؤرنکلر --اگر ایکی لیستده ده کاراکت ساییسی برابر اولسا، ایلک لیستی قایتار.--لیستین بوتون سیرالارینداکی حرفلرین سایی، او بیری لیستدن آز دیر.--٠ فؤنکشن یازین کی، ایکی سِری قبول ائدیر و او سِری قاییدیب کی، --  >>> totalMatch [] []
--  []
--  >>> totalMatch [""hi"",""admin""] [""hI"",""Hi""]
--  [""hI"",""Hi""]
--  >>> totalMatch [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""]
--  [""hi"",""admin""]
--  >>> totalMatch [""hi"",""admin""] [""hI"",""hi"",""hi""]
--  [""hI"",""hi"",""hi""]
--  >>> totalMatch [""4""] [""1"",""2"",""3"",""4"",""5""]
--  [""4""]
totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2 =","totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2
  | totalChars lst1 < totalChars lst2 = lst1
  | totalChars lst1 > totalChars lst2 = lst2
  | otherwise = lst1
  where
    totalChars = sum . map length","
main :: IO ()
main = do
  let candidate = totalMatch
  if candidate [] [] == [] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi""] == [""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [""4""] [""1"",""2"",""3"",""4"",""5""] == [""4""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""Hi""] == [""hI"",""Hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hi""] == [""hI"",""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hii""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [] [""this""] == [] then pure () else error ""assertion failed""
  if candidate [""this""] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_75,azb_Arab,hs,"--اؤرنک: --بیلیندیگی کیمی (a) 100 دن آزدیر.--و باشقا حالدا دا يالان.--٠ فانکشن يازين کي، اگر وئريلن سايي 3 اولسايين ساييلارين ضربيدير، او زامان دوغرو قاييدار.--  >>> isMultiplyPrime 30
--  True
--  30 = 2 * 3 * 5
isMultiplyPrime :: Int -> Bool
isMultiplyPrime a =","isMultiplyPrime :: Int -> Bool
isMultiplyPrime a = any isTriplePrimeProduct primeTriples
  where
    primes = filter isPrime [2..99]
    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]
    isTriplePrimeProduct (x, y, z) = x * y * z == a

isPrime :: Int -> Bool
isPrime n 
  | n < 2     = False
  | otherwise = not (any (\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","
main :: IO ()
main = do
  let candidate = isMultiplyPrime
  if candidate 5 == False then pure () else error ""assertion failed""
  if candidate 30 == True then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == False then pure () else error ""assertion failed""
  if candidate 125 == True then pure () else error ""assertion failed""
  if candidate 105 == True then pure () else error ""assertion failed""
  if candidate 126 == False then pure () else error ""assertion failed""
  if candidate 729 == False then pure () else error ""assertion failed""
  if candidate 891 == False then pure () else error ""assertion failed""
  if candidate 1001 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_76,azb_Arab,hs,"--مثلن: --x ساده بیر n قوْلودور اگر n**int=x --n و false'ين گوجونه باشقا حاللاردا.--سیزین ایشینیز بیر فاکتئر یازماق دیر کی بیر سایی x ساده بیر فاکتئر اولسا true قاییدیب.--  >>> isSimplePower 1 4
--  True
--  >>> isSimplePower 2 2
--  True
--  >>> isSimplePower 8 2
--  True
--  >>> isSimplePower 3 2
--  False
--  >>> isSimplePower 3 1
--  False
--  >>> isSimplePower 5 3
--  False
isSimplePower :: Int -> Int -> Bool
isSimplePower x n =","isSimplePower :: Int -> Int -> Bool
isSimplePower x n
  | x < 1 || n < 1 = False
  | n == 1 = x == 1
  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","
main :: IO ()
main = do
  let candidate = isSimplePower
  if candidate 16 2 == True then pure () else error ""assertion failed""
  if candidate 143214 16 == False then pure () else error ""assertion failed""
  if candidate 4 2 == True then pure () else error ""assertion failed""
  if candidate 9 3 == True then pure () else error ""assertion failed""
  if candidate 16 4 == True then pure () else error ""assertion failed""
  if candidate 24 2 == False then pure () else error ""assertion failed""
  if candidate 128 4 == False then pure () else error ""assertion failed""
  if candidate 12 6 == False then pure () else error ""assertion failed""
  if candidate 1 1 == True then pure () else error ""assertion failed""
  if candidate 1 12 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_77,azb_Arab,hs,"--اؤرنکلر: --ياداشت: گئریلن معلوماتین همیشه اعتبارلی اولدوغونو فرض ائده بیلرسینیز.--اگر بو اينجئر بير عددين مكعبيدير.--""a"" ساییسی آلیناراق ""true"" قاییدیلماسی اوچون بیر فاکتئر یازین.--  >>> iscube 1
--  True
--  >>> iscube 2
--  False
--  >>> iscube (-1)
--  True
--  >>> iscube 64
--  True
--  >>> iscube 0
--  True
--  >>> iscube 180
--  False
iscube :: Int -> Bool
iscube a =","iscube :: Int -> Bool
iscube a = let n = round (fromIntegral a ** (1/3)) in n^3 == a","
main :: IO ()
main = do
  let candidate = iscube
  if candidate 1 == True then pure () else error ""assertion failed""
  if candidate 2 == False then pure () else error ""assertion failed""
  if candidate (-1) == True then pure () else error ""assertion failed""
  if candidate 64 == True then pure () else error ""assertion failed""
  if candidate 180 == False then pure () else error ""assertion failed""
  if candidate 1000 == True then pure () else error ""assertion failed""
  if candidate 0 == True then pure () else error ""assertion failed""
  if candidate 1729 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_78,azb_Arab,hs,"--اؤرنکلر: --و نمونه هاي A,B,C,D,E,F هميشه بزرگ هستن.--ياداشت: گئری آلینما همیشه دوزگون و يا بوش ساري ساییلار، --ب (= ده یازده ینجی سی) ، د (= ده یازده ینجی سی) --بونا گؤره ده، گرک آشاغیداکی عدده لردن بیرینی تعیین ائده سیز: ۲، ۳، ۵، ۷، --ایکی، اوچ، بئش، یئددی، اون بیر، اون اوچ، اون یئددی، اون یئددی، اون یئددی، اون یئددی، ...--آلتینجی سیمی سیرا رقملری: 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، A، B، C، D، E، F.--۱-دن چوخ اولان بیر عدد، ایکی داها آز طبیعی سایی نین مولفه سی دئییل.)--بیرینجی ساییلار (بیرینجی سایی، یا دا بیرینجی سایی، طبیعی سایی دیر --بیر سسلنمه کیمی هکسادسیمال سایی آلینار و هکسادسیمال سایی سایی آلینار.--سیزه آلینان بیر فانکشن یازماق تکلیف ائدیلدی.--  >>> hexKey ""AB""
--  1
--  >>> hexKey ""1077E""
--  2
--  >>> hexKey ""ABED1A33""
--  4
--  >>> hexKey ""123456789ABCDEF0""
--  6
--  >>> hexKey ""2020""
--  2
hexKey :: String -> Int
hexKey num =","hexKey :: String -> Int
hexKey num = length . filter (`elem` primeHexDigits) $ num
  where
    primeHexDigits = ""2357BD""","
main :: IO ()
main = do
  let candidate = hexKey
  if candidate ""AB"" == 1 then pure () else error ""assertion failed""
  if candidate ""1077E"" == 2 then pure () else error ""assertion failed""
  if candidate ""ABED1A33"" == 4 then pure () else error ""assertion failed""
  if candidate ""2020"" == 2 then pure () else error ""assertion failed""
  if candidate ""123456789ABCDEF0"" == 6 then pure () else error ""assertion failed""
  if candidate ""112233445566778899AABBCCDDEEFF00"" == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_79,azb_Arab,hs,"--اؤرنکلر: --آرتيجي حرفلر فورماتيله کؤمک ائتمک اوچون وار.--بو سيرين باشيندا و آخيريندا بير نئچه حرف ""db"" آرتيراجاق.--هر حرفی ""۰"" و یا ""۱"" اولا بیلر.--باینری فورماتی. فانکشن بیر سِری قایتارمالی دیر، هر کاراکتئر بیر باینری --سیزه اونلاییجی شکیلده بیر سایی وئریله جک و سیزین ایشینیز اونو اونلاییجی شکیلده--  >>> decimalToBinary 15
--  ""db1111db""
--  >>> decimalToBinary 32
--  ""db100000db""
decimalToBinary :: Int -> String
decimalToBinary decimal =","decimalToBinary :: Int -> String
decimalToBinary decimal = ""db"" ++ toBinary decimal ++ ""db""
  where
    toBinary 0 = ""0""
    toBinary n = reverse (binaryHelper n)

    binaryHelper 0 = """"
    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","
main :: IO ()
main = do
  let candidate = decimalToBinary
  if candidate 0 == ""db0db"" then pure () else error ""assertion failed""
  if candidate 32 == ""db100000db"" then pure () else error ""assertion failed""
  if candidate 103 == ""db1100111db"" then pure () else error ""assertion failed""
  if candidate 15 == ""db1111db"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_80,azb_Arab,hs,"--مثلن: --بیر سِره هَفس دیر اگر اونون اوزونلوغو ان آز 3 و هر 3 نؤوبه لی حرف فرقلی دیر --سیزین ایشینیز، بو سِرین هَپف اولماسینی یا اولمادیغینی چکمک دیر.--٠: آخه يه رشته اي داده شده--  >>> isHappy ""a""
--  False
--  >>> isHappy ""aa""
--  False
--  >>> isHappy ""abcd""
--  True
--  >>> isHappy ""aabb""
--  False
--  >>> isHappy ""adb""
--  True
--  >>> isHappy ""xyy""
--  False
isHappy :: String -> Bool
isHappy s =","isHappy :: String -> Bool
isHappy s
  | length s < 3 = False
  | otherwise = all distinctTriples (windows 3 s)
  where
    distinctTriples [x, y, z] = x /= y && y /= z && x /= z
    distinctTriples _ = False
    windows n xs
      | length xs < n = []
      | otherwise = take n xs : windows n (tail xs)","
main :: IO ()
main = do
  let candidate = isHappy
  if candidate ""a"" == False then pure () else error ""assertion failed""
  if candidate ""aa"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""adb"" == True then pure () else error ""assertion failed""
  if candidate ""xyy"" == False then pure () else error ""assertion failed""
  if candidate ""iopaxpoi"" == True then pure () else error ""assertion failed""
  if candidate ""iopaxioi"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_81,azb_Arab,hs,"--اؤرنک: --0.0 E --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 B+ --> 3.3 A- --> 3.7 A --4.0 A+ --نمره: حرف درجه:--بیر فاکتوری کی، آشاغیداکی جدولین ایستیفاده سی ایله حرف درجه لری نین بیر لیستینی چیخارا بیلر: --او سنه بعضي اؤيرنجيلرين نمره لرينين بير سيراسي و يازمالي يئنيلريني وئردي.--آنجاق اونون یالنیز پروبلمی، درجه لندیریلمه سی اوچون ایستیفاده ائتدیگی کودی ائتدیگی دیر.--اوستاد اؤز درجه لشدیرمه آلگوریتمینی یارادیردی.--سمستئرین سون هفته سی دیر و اوستاد نمره لری وئرمه لی دیر.--  >>> gradeEquation [4.0,3,1.7,2,3.5]
--  [""A+"",""B"",""C-"",""C"",""A-""]
numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades =","numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades = map gpaToLetterGrade grades
  where
    gpaToLetterGrade gpa
      | gpa == 4.0 = ""A+""
      | gpa > 3.7  = ""A""
      | gpa > 3.3  = ""A-""
      | gpa > 3.0  = ""B+""
      | gpa > 2.7  = ""B""
      | gpa > 2.3  = ""B-""
      | gpa > 2.0  = ""C+""
      | gpa > 1.7  = ""C""
      | gpa > 1.3  = ""C-""
      | gpa > 1.0  = ""D+""
      | gpa > 0.7  = ""D""
      | gpa > 0.0  = ""D-""
      | otherwise  = ""E""","
main :: IO ()
main = do
  let candidate = numericalLetterGrade
  if candidate [4.0,3,1.7,2,3.5] == [""A+"",""B"",""C-"",""C"",""A-""] then pure () else error ""assertion failed""
  if candidate [1.2] == [""D+""] then pure () else error ""assertion failed""
  if candidate [0.5] == [""D-""] then pure () else error ""assertion failed""
  if candidate [0.0] == [""E""] then pure () else error ""assertion failed""
  if candidate [1.0,0.3,1.5,2.8,3.3] == [""D"",""D-"",""C-"",""B"",""B+""] then pure () else error ""assertion failed""
  if candidate [0.0,0.7] == [""E"",""D-""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_82,azb_Arab,hs,"--اؤرنکلر --length بیر اول سایی دیر و یا یالنیز یالان --بیر فاکتئر یازین کی، بیر سِره نی آلسین و اگر سِره نین آدی ۰ اولسا، true قایتارسین.--  >>> primeLength ""Hello""
--  True
--  >>> primeLength ""abcdcba""
--  True
--  >>> primeLength ""kittens""
--  True
--  >>> primeLength ""orange""
--  False
primeLength :: String -> Bool
primeLength string =","primeLength :: String -> Bool
primeLength string = isPrime (length string)

isPrime :: Int -> Bool
isPrime n
  | n < 2     = False
  | n == 2    = True
  | even n    = False
  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = primeLength
  if candidate ""Hello"" == True then pure () else error ""assertion failed""
  if candidate ""abcdcba"" == True then pure () else error ""assertion failed""
  if candidate ""kittens"" == True then pure () else error ""assertion failed""
  if candidate ""orange"" == False then pure () else error ""assertion failed""
  if candidate ""wow"" == True then pure () else error ""assertion failed""
  if candidate ""world"" == True then pure () else error ""assertion failed""
  if candidate ""MadaM"" == True then pure () else error ""assertion failed""
  if candidate ""Wow"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""HI"" == True then pure () else error ""assertion failed""
  if candidate ""go"" == True then pure () else error ""assertion failed""
  if candidate ""gogo"" == False then pure () else error ""assertion failed""
  if candidate ""aaaaaaaaaaaaaaa"" == False then pure () else error ""assertion failed""
  if candidate ""Madam"" == True then pure () else error ""assertion failed""
  if candidate ""M"" == False then pure () else error ""assertion failed""
  if candidate ""0"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_83,azb_Arab,hs,"--مثبت ساییلار کی ۱ ایله باشلانیر و یا باشا چاتیر.--٠ مثبت بير اينتگر n ورين، n-هينگري نين ساييني قايتارين ٠startsOneEnds :: Int -> Int
startsOneEnds n =","startsOneEnds :: Int -> Int
startsOneEnds n
  | n <= 0    = 0
  | n == 1    = 1
  | otherwise = 18 * 10^(n-2)","
main :: IO ()
main = do
  let candidate = startsOneEnds
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 2 == 18 then pure () else error ""assertion failed""
  if candidate 3 == 180 then pure () else error ""assertion failed""
  if candidate 4 == 1800 then pure () else error ""assertion failed""
  if candidate 5 == 18000 then pure () else error ""assertion failed""
  pure ()"
HumanEval_84,azb_Arab,hs,"--اؤرنک --٠ مثبت N عددين ايچينده، اونون ايکينجي سيياسي نين جمعيني قايدير. ٠--  >>> solve 1000
--  ""1""
--  >>> solve 150
--  ""110""
--  >>> solve 147
--  ""1100""
--  Variables:
--  @N integer
--  Constraints: 0 ≤ N ≤ 10000.
--  Output:
--  a string of binary number
solve :: Int -> String
solve N =","solve :: Int -> String
solve N = toBinary (sumOfDigits N)
  where
    sumOfDigits 0 = 0
    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)

    toBinary 0 = ""0""
    toBinary n = reverse (toBinary' n)
      where
        toBinary' 0 = """"
        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","
main :: IO ()
main = do
  let candidate = solve
  if candidate 1000 == ""1"" then pure () else error ""assertion failed""
  if candidate 150 == ""110"" then pure () else error ""assertion failed""
  if candidate 147 == ""1100"" then pure () else error ""assertion failed""
  if candidate 333 == ""1001"" then pure () else error ""assertion failed""
  if candidate 963 == ""10010"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_85,azb_Arab,hs,"--اؤرنکلر: --lst. بیرینجی، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده، بیرلیکده،--  >>> add [4,2,6,7]
--  2
add :: [Int] -> Int
add lst =","add :: [Int] -> Int
add lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","
main :: IO ()
main = do
  let candidate = add
  if candidate [4,88] == 88 then pure () else error ""assertion failed""
  if candidate [4,5,6,7,2,122] == 122 then pure () else error ""assertion failed""
  if candidate [4,0,6,7] == 0 then pure () else error ""assertion failed""
  if candidate [4,4,6,8] == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_86,azb_Arab,hs,"--مثلن: --ياداشت: سؤزجوکلرين و بوش يئرلرئن دوزولمه سيني ساخلامالي سينيز.--آشاغيداکي دوزولمه اساسيندا ASCII قئيمتينه اساسلاناراق.--یئنی بیر سؤزجوکله یئرلشدیریلیر کی، هامیسیندا کی حرفلر یئرلشدیریلیر.--""String""ین یئرلشدیریلن نؤمره سینده، هر بیر کلمه نین (بیر بوشلوقلا آیریلان) بیر سیرا کلمه سی دیر.--٠ فانکشن بنویسید که یک رشته رو بگیره و نسخه ی مرتبش رو بر می گرده--  >>> antiShuffle ""Hi""
--  ""Hi""
--  >>> antiShuffle ""hello""
--  ""ehllo""
--  >>> antiShuffle ""Hello World!!!""
--  ""Hello !!!Wdlor""
antiShuffle :: String -> String
antiShuffle s =","import Data.List (sort)
import Data.Char (isAlpha)

antiShuffle :: String -> String
antiShuffle s = unwords $ map sortWord (wordsAndSpaces s)
  where
    sortWord word = if all isAlpha word then sort word else word
    wordsAndSpaces [] = []
    wordsAndSpaces xs = if head xs == ' ' 
                        then "" "" : wordsAndSpaces (dropWhile (== ' ') xs)
                        else let (word, rest) = break (== ' ') xs
                             in word : wordsAndSpaces rest","
main :: IO ()
main = do
  let candidate = antiShuffle
  if candidate ""Hi"" == ""Hi"" then pure () else error ""assertion failed""
  if candidate ""hello"" == ""ehllo"" then pure () else error ""assertion failed""
  if candidate ""number"" == ""bemnru"" then pure () else error ""assertion failed""
  if candidate ""abcd"" == ""abcd"" then pure () else error ""assertion failed""
  if candidate ""Hello World!!!"" == ""Hello !!!Wdlor"" then pure () else error ""assertion failed""
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hi. My name is Mister Robot. How are you?"" == "".Hi My aemn is Meirst .Rboot How aer ?ouy"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_87,azb_Arab,hs,"--اؤرنکلر: --همچینین، ردیفین کووردیناتلارینی ستونلارین آراسیندا آشاغی یئرلی ترتیبله یین.--کووردئناتلاری ایلک نؤوبه ده یوللارین آرتیق ترتیبله یین.--هر توپل بیر کووردینات دیر.--و توپللارین بیر لیستی، [(x1, y1), (x2, y2) ...] یئرینه قاییدیب بئله کی --lst و x عددینده، لیستده x عددینده، --هر سطرده فرقلی بیر ساییندا ستون اولابیلر.--ماتریکس-ه بنزر، آمما ماتریکسلردن فرقلی اولاراق،--٠:۲۸ --۰:۲۸ --۰:۲۸ ایندی سیزه بیر ایکی اؤلچولو داده، یئرلشدیریلن بیر لیست کیمی وئریلیر، ۰:۲۸ --۰:۲۹--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1
--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]
--  >>> getRow [] 1
--  []
--  >>> getRow [[],[1],[1,2,3]] 3
--  [(2, 2)]
getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x =","getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x = concatMap processRow (zip [0..] lst)
  where
    processRow (rowIndex, row) = 
      let colIndices = reverse $ findIndices (== x) row
      in [(rowIndex, colIndex) | colIndex <- colIndices]

findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","
main :: IO ()
main = do
  let candidate = getRow
  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error ""assertion failed""
  if candidate [] 1 == [] then pure () else error ""assertion failed""
  if candidate [[1]] 2 == [] then pure () else error ""assertion failed""
  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_88,azb_Arab,hs,"--اؤرنکلر: --* وئرن لئستی دییشمیرم. --يادداشت:--و يا اونو آشاغي گئدن ترتيبده آييرد ائده بيلرلر اگر جمع ((اولين ايندئکس قئيمتي، آخير ايندئکس قئيمتي) جفت اولسا.--اگر ((اولين آندا قئيمت، آخير آندا قئيمت) جمعي بير اولماسا، اوٍستوندهکي سيراسي آرتيريب آييرد ائده جکسئنئز،--""منفي اولمایان ساري ساييلارين بير سيراسي وئريلن، سيراسي اوچون بير ""cohs""ي قايديرماق،--  >>> sortArray []
--  []
--  >>> sortArray [5]
--  [5]
--  >>> sortArray [2,4,3,0,1,5]
--  [0,1,2,3,4,5]
--  >>> sortArray [2,4,3,0,1,5,6]
--  [6,5,4,3,2,1,0]
sortArray :: [Int] -> [Int]
sortArray array =","sortArray :: [Int] -> [Int]
sortArray array
  | null array = array
  | otherwise =
    let first = head array
        last = last array
        sumFirstLast = first + last
    in if odd sumFirstLast
       then sort array
       else reverse (sort array)","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5] == [5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error ""assertion failed""
  if candidate [2,1] == [1,2] then pure () else error ""assertion failed""
  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error ""assertion failed""
  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error ""assertion failed""
  pure ()"
HumanEval_89,azb_Arab,hs,"--مثلن: --آشاغييا، ايکي قات، ايکي يئره چئوريل.--الفبئه ده کي حرفلر --بير سيراني قاييدير کي، بو سيرادا الفبا دؤنوشدورولور.--٠ فانکشن انکریپت ایتیرمک اوچون بیر سیمگه آرگومنت اولاراق قبول ائدیر و --  >>> encrypt ""hi""
--  ""lm""
--  >>> encrypt ""asdfghjkl""
--  ""ewhjklnop""
--  >>> encrypt ""gf""
--  ""kj""
--  >>> encrypt ""et""
--  ""ix""
encrypt :: String -> String
encrypt s =","encrypt :: String -> String
encrypt s = map shiftChar s
  where
    shiftChar c
      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')
      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')
      | otherwise = c","
main :: IO ()
main = do
  let candidate = encrypt
  if candidate ""hi"" == ""lm"" then pure () else error ""assertion failed""
  if candidate ""asdfghjkl"" == ""ewhjklnop"" then pure () else error ""assertion failed""
  if candidate ""gf"" == ""kj"" then pure () else error ""assertion failed""
  if candidate ""et"" == ""ix"" then pure () else error ""assertion failed""
  if candidate ""faewfawefaewg"" == ""jeiajeaijeiak"" then pure () else error ""assertion failed""
  if candidate ""hellomyfriend"" == ""lippsqcjvmirh"" then pure () else error ""assertion failed""
  if candidate ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"" == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" then pure () else error ""assertion failed""
  if candidate ""a"" == ""e"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_90,azb_Arab,hs,"--اگر بو عنصر یوخدور، ""هچ""ی قایتارین.--بیر فاکتوری یازین next_smallest (کئچمیشین ان کئچمیش عنصر) کی، لیستین ان کئچمیش عنصرینی قایتاریر.--٠ سنه ساري ساييلارين بير سيراسي وريلير. ٠--  >>> nextSmallest [1,2,3,4,5]
--  Just (2)
--  >>> nextSmallest [5,1,4,3,2]
--  Just (2)
--  >>> nextSmallest []
--  Just (Nothing)
--  >>> nextSmallest [1,1]
--  Just (Nothing)
nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =","nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =
  let uniqueSorted = removeDuplicates $ quicksort lst
  in if length uniqueSorted < 2
     then Nothing
     else Just (uniqueSorted !! 1)

removeDuplicates :: (Ord a) => [a] -> [a]
removeDuplicates = foldr (\x acc -> if x `elem` acc then acc else x : acc) []

quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = nextSmallest
  if candidate [1,2,3,4,5] == Just (2) then pure () else error ""assertion failed""
  if candidate [5,1,4,3,2] == Just (2) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1,1,1,0] == Just (1) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error ""assertion failed""
  pure ()"
HumanEval_91,azb_Arab,hs,"--مثلن: --جمله لر ""، ""، ""، "" و ""! "" ایله آراسینداکی سرحدلرین آراسیندا یئرلشیر.--""I"" کلمه سی ایله باشلانان بیر جومله دیر.--٠.تئزجه بير سؤزلوکله مشغول اولارسينيز و وظيفه نيز سايماقدير.--  >>> isBored ""Hello world""
--  0
--  >>> isBored ""The sky is blue. The sun is shining. I love this weather""
--  1
isBored :: String -> Int
isBored S =","isBored :: String -> Int
isBored s = length $ filter (startsWithI . words) $ splitSentences s
  where
    splitSentences :: String -> [String]
    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters "".?!""
    
    splitOnDelimiters :: String -> String -> [String]
    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of
      """" -> []
      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''
    
    startsWithI :: [String] -> Bool
    startsWithI [] = False
    startsWithI (x:_) = map toLower x == ""i""","
main :: IO ()
main = do
  let candidate = isBored
  if candidate ""Hello world"" == 0 then pure () else error ""assertion failed""
  if candidate ""Is the sky blue?"" == 0 then pure () else error ""assertion failed""
  if candidate ""I love It !"" == 1 then pure () else error ""assertion failed""
  if candidate ""bIt"" == 0 then pure () else error ""assertion failed""
  if candidate ""I feel good today. I will be productive. will kill It"" == 2 then pure () else error ""assertion failed""
  if candidate ""You and I are going for a walk"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_92,azb_Arab,hs,"--اؤرنکلر --هر هانسی بیر حالدا false یئرینده یئرلشیر.--اگر ساییلارین بیری ایکی سایی نین مجموعینه برابر اولسا و بوتون ساییلار تام ساییلار اولسا true قاییدیب.--٠.فاکتسيون ايجاد کن که 3 عدد بگيره. ٠--  >>> anyInt 5 2 7
--  True
--  >>> anyInt 3 2 2
--  False
--  >>> anyInt 3 (-2) 1
--  True
--  >>> anyInt 3.6 -2.2 2
--  False
anyInt :: Float -> Float -> Float -> Bool
anyInt x y z =","anyInt :: Float -> Float -> Float -> Bool
anyInt x y z
  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =
      x == y + z || y == x + z || z == x + y
  | otherwise = False","
main :: IO ()
main = do
  let candidate = anyInt
  if candidate 2.0 3.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 2.5 2.0 3.0 == False then pure () else error ""assertion failed""
  if candidate 1.5 5.0 3.5 == False then pure () else error ""assertion failed""
  if candidate 2.0 6.0 2.0 == False then pure () else error ""assertion failed""
  if candidate 4.0 2.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.2 2.2 2.2 == False then pure () else error ""assertion failed""
  if candidate (-4).0 6.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.0 1.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_93,azb_Arab,hs,"--اؤرنکلر: --آنجاق حرفلر قبول اولونسون.--بو آواچیق، اینگیلیسجه الفباسیندا.--بو سؤزون قاباغیندا ایکی یئر اوْلان حرفله بیر پیغام --بو یولدا بوتون حرفلرین بؤیوک حرفینی یئرینه یئرلشدیریر، بوتون سسلی حرفلری یئرینه یئرلشدیریر.--بير فؤنکشن يازين کي، پيغامي قبول ائده و اونو بو شکيلده كودلانديرسين.--  >>> encode ""test""
--  ""TGST""
--  >>> encode ""This is a message""
--  ""tHKS KS C MGSSCGG""
encode :: String -> String
encode message =","encode :: String -> String
encode = map transformChar
  where
    transformChar :: Char -> Char
    transformChar c
      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c
      | otherwise      = swapCase c c
      where
        lowerC = toLower c

    isVowel :: Char -> Bool
    isVowel c = c `elem` ""aeiou""

    swapCase :: Char -> Char -> Char
    swapCase origC c
      | isUpper origC = toLower c
      | otherwise     = toUpper c","
main :: IO ()
main = do
  let candidate = encode
  if candidate ""TEST"" == ""tgst"" then pure () else error ""assertion failed""
  if candidate ""Mudasir"" == ""mWDCSKR"" then pure () else error ""assertion failed""
  if candidate ""YES"" == ""ygs"" then pure () else error ""assertion failed""
  if candidate ""This is a message"" == ""tHKS KS C MGSSCGG"" then pure () else error ""assertion failed""
  if candidate ""I DoNt KnOw WhAt tO WrItE"" == ""k dQnT kNqW wHcT Tq wRkTg"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_94,azb_Arab,hs,"--اؤرنکلر: --ان بؤیوک بیر اولوملو قئیدین آلیب، اونون عددی مئقدارلارینین جمعینی قایتارمالی سیز.--٠ سنه ساري ساييلارين بير سيراسي وريلير. ٠--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]
--  10
--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]
--  25
--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]
--  13
--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]
--  11
--  >>> skjkasdkd [0,81,12,3,1,21]
--  3
--  >>> skjkasdkd [0,8,1,2,1,7]
--  7
skjkasdkd :: [Int] -> Int
skjkasdkd lst =","skjkasdkd :: [Int] -> Int
skjkasdkd lst = sumDigits (largestPrime lst)

-- Function to check if a number is prime
isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]

-- Integer square root using binary search, O(log n)
isqrt :: Int -> Int
isqrt n = floor . sqrt $ fromIntegral n

-- Function to find the largest prime in the list
largestPrime :: [Int] -> Int
largestPrime = foldr (\x acc -> if isPrime x && x > acc then x else acc) 0

-- Function to calculate the sum of the digits of a number
sumDigits :: Int -> Int
sumDigits 0 = 0
sumDigits n = n `mod` 10 + sumDigits (n `div` 10)","
main :: IO ()
main = do
  let candidate = skjkasdkd
  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error ""assertion failed""
  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error ""assertion failed""
  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error ""assertion failed""
  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error ""assertion failed""
  if candidate [0,81,12,3,1,21] == 3 then pure () else error ""assertion failed""
  if candidate [0,8,1,2,1,7] == 7 then pure () else error ""assertion failed""
  if candidate [8191] == 19 then pure () else error ""assertion failed""
  if candidate [8191,123456,127,7] == 19 then pure () else error ""assertion failed""
  if candidate [127,97,8192] == 10 then pure () else error ""assertion failed""
  pure ()"
HumanEval_95,azb_Arab,hs,"--اؤرنکلر: --تابع گرک false دؤنده رسه، بو، وئریلن ایلیشکی لیستی بوشدور.--case یا بوتون کیلر uppercase سیردیر، یوخسا false قایتار.--٠. اگر بير ارتباط ليستين بوتون کليدلري آشاغيداکي سيرالار اولسا، TRUE'ي قايدير.--  >>> checkDictCase [(""a"", ""apple""), (""b"", ""banana"")]
--  True
--  >>> checkDictCase [(""a"", ""apple""), (""A"", ""banana""), (""B"", ""banana"")]
--  False
--  >>> checkDictCase [(""a"", ""apple""), (8, ""banana""), (""a"", ""apple"")]
--  False
--  >>> checkDictCase [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")]
--  False
--  >>> checkDictCase [(""STATE"", ""NC""), (""ZIP"", ""12345"")]
--  True
checkDictCase :: [(String, String)] -> Bool
checkDictCase dict =","import Data.Char (isUpper, isLower)

checkDictCase :: [(String, String)] -> Bool
checkDictCase [] = False
checkDictCase dict = all isLower allKeys || all isUpper allKeys
  where
    allKeys = concatMap fst dict","
main :: IO ()
main = do
  let candidate = checkDictCase
  if candidate [(""p"", ""pineapple""), (""b"", ""banana"")] == True then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""A"", ""banana""), (""B"", ""banana"")] == False then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""5"", ""banana""), (""a"", ""apple"")] == False then pure () else error ""assertion failed""
  if candidate [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")] == False then pure () else error ""assertion failed""
  if candidate [(""STATE"", ""NC""), (""ZIP"", ""12345"")] == True then pure () else error ""assertion failed""
  if candidate [(""fruit"", ""Orange""), (""taste"", ""Sweet"")] == True then pure () else error ""assertion failed""
  if candidate [] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_96,azb_Arab,hs,"--مثلاً: --ندن آز اولان ایکی ساییلار.--۰۲:۰۸:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۲:۱۱:۱۲:۱۱:۱۲:۱۱:۱۲:۱۱:۱۲:۱۱:۱۲:۱۱:۱۲:۱۱:۱۲:۱:۱۱:۱۲:۱:۱۱:۱۲:۱:۱۲:۱۲:۱:۱۲:۱:۱۲۲:۱:۱:۱۲۲--  >>> countUpTo 5
--  [2,3]
--  >>> countUpTo 11
--  [2,3,5,7]
--  >>> countUpTo 0
--  []
--  >>> countUpTo 20
--  [2,3,5,7,11,13,17,19]
--  >>> countUpTo 1
--  []
--  >>> countUpTo 18
--  [2,3,5,7,11,13,17]
countUpTo :: Int -> [Int]
countUpTo n =","countUpTo :: Int -> [Int]
countUpTo n = filter isPrime [2..n-1]

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = countUpTo
  if candidate 5 == [2,3] then pure () else error ""assertion failed""
  if candidate 6 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 7 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 10 == [2,3,5,7] then pure () else error ""assertion failed""
  if candidate 0 == [] then pure () else error ""assertion failed""
  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error ""assertion failed""
  if candidate 1 == [] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error ""assertion failed""
  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error ""assertion failed""
  pure ()"
HumanEval_97,azb_Arab,hs,"--اؤرنکلر: --فرض ائدک کی، گئرئش همیشه اعتبارلی دیر.--اونلارين واحد سيفرلري نين ضربي.--٠ فانکشني که دو عدد صحيح ميگيره و برميگرده رو کامل کنيد ٠--  >>> multiply 148 412
--  16
--  >>> multiply 19 28
--  72
--  >>> multiply 2020 1851
--  0
--  >>> multiply 14 (-15)
--  20
multiply :: Int -> Int -> Int
multiply a b =","multiply :: Int -> Int -> Int
multiply a b = (abs a `mod` 10) * (abs b `mod` 10)","
main :: IO ()
main = do
  let candidate = multiply
  if candidate 148 412 == 16 then pure () else error ""assertion failed""
  if candidate 19 28 == 72 then pure () else error ""assertion failed""
  if candidate 2020 1851 == 0 then pure () else error ""assertion failed""
  if candidate 14 (-15) == 20 then pure () else error ""assertion failed""
  if candidate 76 67 == 42 then pure () else error ""assertion failed""
  if candidate 17 27 == 49 then pure () else error ""assertion failed""
  if candidate 0 1 == 0 then pure () else error ""assertion failed""
  if candidate 0 0 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_98,azb_Arab,hs,"--مثلن: --""s"" ساري ساري اولاراق، بؤيوک حرفلي حرفلرين سايي ساييلار.--  >>> countUpper ""aBCdEf""
--  1
--  >>> countUpper ""abcdefg""
--  0
--  >>> countUpper ""dBBE""
--  0
countUpper :: String -> Int
countUpper s =","countUpper :: String -> Int
countUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` ""AEIOU""]","
main :: IO ()
main = do
  let candidate = countUpper
  if candidate ""aBCdEf"" == 1 then pure () else error ""assertion failed""
  if candidate ""abcdefg"" == 0 then pure () else error ""assertion failed""
  if candidate ""dBBE"" == 0 then pure () else error ""assertion failed""
  if candidate ""B"" == 0 then pure () else error ""assertion failed""
  if candidate ""U"" == 1 then pure () else error ""assertion failed""
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""EEEE"" == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_99,azb_Arab,hs,"--اؤرنکلر --ایکی سایی نین ایچینده، اونو صفردن اوزاقلاشدیریر.--و اونا ان یاخین سایی قاییدیب. اگر سایی برابر اوزاقدا اولسا --٠ فانکشن ايجاد کن که يک ارزشي (دره) به عنوان يک عدد بدست بياره--  >>> closestInteger ""10""
--  10
--  >>> closestInteger ""15.3""
--  15
--  Note:
--  Rounding away from zero means that if the given number is equidistant
--  from two integers, the one you should return is the one that is the
--  farthest from zero. For example closest_integer(""14.5"") should
--  return 15 and closest_integer(""-14.5"") should return -15.
closestInteger :: String -> Int
closestInteger value =","closestInteger :: String -> Int
closestInteger value = 
  let n = read value :: Double
  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","
main :: IO ()
main = do
  let candidate = closestInteger
  if candidate ""10"" == 10 then pure () else error ""assertion failed""
  if candidate ""14.5"" == 15 then pure () else error ""assertion failed""
  if candidate ""-15.5"" == (-16) then pure () else error ""assertion failed""
  if candidate ""15.3"" == 15 then pure () else error ""assertion failed""
  if candidate ""0"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_100,azb_Arab,hs,"--اؤرنکلر: --i، سطحده کی داشلارین ساییسینی تمثیل ائدیر (i+1).--بیر لیستده هر سطرده کی داشلارین سایی سینی قایتار، بوردا ایندکسده کی عنصر --- اگر n جفت اولسا، گلن جفت سایی.--- اگر n، نئچه سایی اولسا، اوْنلاردان سونراکی نئچه سایی.--گلن سویه ده کی داشلارین سایی: --بیرینجی سویه ده n داش وار.--٠ مثبت بير اينتگر n ورنده، بير توپلو n دنه داش دوزمه ليدير. ٠--  >>> makeAPile 3
--  [3,5,7]
makeAPile :: Int -> [Int]
makeAPile n =","makeAPile :: Int -> [Int]
makeAPile n = take n [n, n + 2 ..]","
main :: IO ()
main = do
  let candidate = makeAPile
  if candidate 3 == [3,5,7] then pure () else error ""assertion failed""
  if candidate 4 == [4,6,8,10] then pure () else error ""assertion failed""
  if candidate 5 == [5,7,9,11,13] then pure () else error ""assertion failed""
  if candidate 6 == [6,8,10,12,14,16] then pure () else error ""assertion failed""
  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error ""assertion failed""
  pure ()"
HumanEval_101,azb_Arab,hs,"--مثلن: --بو ساريي سؤزجوکلره بؤلسون و سؤزجوکلرين بيرينجي سيراسي گري قايتارسين.--سیزه بیر سیرا کلمه لر وئریله جک، اونلاری ایسه ایسه ایشلر آیریلیب. سیزین ایشینیز بودور:--  >>> wordsString ""Hi, my name is John""
--  [""Hi"",""my"",""name"",""is"",""John""]
--  >>> wordsString ""One, two, three, four, five, six""
--  [""One"",""two"",""three"",""four"",""five"",""six""]
wordsString :: String -> [String]
wordsString s =","wordsString :: String -> [String]
wordsString s = words $ map (\c -> if c == ',' then ' ' else c) s","
main :: IO ()
main = do
  let candidate = wordsString
  if candidate ""Hi, my name is John"" == [""Hi"",""my"",""name"",""is"",""John""] then pure () else error ""assertion failed""
  if candidate ""One, two, three, four, five, six"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate ""Hi, my name"" == [""Hi"",""my"",""name""] then pure () else error ""assertion failed""
  if candidate ""One,, two, three, four, five, six,"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""ahmed     , gamal"" == [""ahmed"",""gamal""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_102,azb_Arab,hs,"--مثلن: --بو فاکتئرین بیر سایی یوخدور، اوندا فاکتئر -1 قاییدیب.--[x، y] آراسیندا اولان ان بؤیوک برابر سایی.--بو فانکشن x و y ايکي مثبت سايي آلير و --  >>> chooseNum 12 15
--  14
--  >>> chooseNum 13 12
--  (-1)
chooseNum :: Int -> Int -> Int
chooseNum x y =","chooseNum :: Int -> Int -> Int
chooseNum x y
    | x > y = -1
    | even upperBound = upperBound
    | even (upperBound - 1) = upperBound - 1
    | otherwise = -1
  where
    upperBound = max x y","
main :: IO ()
main = do
  let candidate = chooseNum
  if candidate 12 15 == 14 then pure () else error ""assertion failed""
  if candidate 13 12 == (-1) then pure () else error ""assertion failed""
  if candidate 33 12354 == 12354 then pure () else error ""assertion failed""
  if candidate 5234 5233 == (-1) then pure () else error ""assertion failed""
  if candidate 6 29 == 28 then pure () else error ""assertion failed""
  if candidate 27 10 == (-1) then pure () else error ""assertion failed""
  if candidate 7 7 == (-1) then pure () else error ""assertion failed""
  if candidate 546 546 == 546 then pure () else error ""assertion failed""
  pure ()"
HumanEval_104,azb_Arab,hs,"--مثلن: --ياداشت: گئری قايتاريلان لیست آرتماسی ایله یئرلشمه لی دیر.--هئچ بیر پارلیمانین بیر پارلیمانین بیر پارلیمانین بیر پارلیمانین بیر پارلیمانین--""x"" ساييلي مثبت ساييلارين بير سيراسي وئريلن زامان، ""x"" ساييلي مثبت ساييلارين بير سيراسي وئريلن زامان، ""x"" ساييلي مثبت ساييلارين بير سيراسي وئريلن زامان، ""x"" ساييلي مثبت ساييلارين بير سيراسي وئريلن زامان،--  >>> uniqueDigits [15,33,1422,1]
--  [1,15,33]
--  >>> uniqueDigits [152,323,1422,10]
--  []
uniqueDigits :: [Int] -> [Int]
uniqueDigits x =","uniqueDigits :: [Int] -> [Int]
uniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","
main :: IO ()
main = do
  let candidate = uniqueDigits
  if candidate [15,33,1422,1] == [1,15,33] then pure () else error ""assertion failed""
  if candidate [152,323,1422,10] == [] then pure () else error ""assertion failed""
  if candidate [12345,2033,111,151] == [111,151] then pure () else error ""assertion failed""
  if candidate [135,103,31] == [31,135] then pure () else error ""assertion failed""
  pure ()"
HumanEval_105,azb_Arab,hs,"--مثلن: --""بیر""، ""ایکی""، ""اوچ""، ""دؤرد""، ""بئش""، ""آلتی""، ""یئددی""، ""سەككز""، ""توقوز"".--نتیجه لی لیستین اویغورلاشدیریلار و سونرا هر بیر رقمی -دن اونون مووافقی آدی ایله یئرلشدیریلار.--٠: بير ساري ساييلار سيستمينده، 1 و 9 آراسيندا اولان ساري ساييلاري سيرايا قوي، ٠:--  >>> byLength [2,1,1,4,5,8,2,3]
--  [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""]
--  If the list is empty, return an empty list:
--  >>> byLength []
--  []
--  If the list has any strange number ignore it:
--  >>> byLength [1,(-1),55]
--  [""One""]
byLength :: [Int] -> [String]
byLength arr =","byLength :: [Int] -> [String]
byLength arr = map digitName . reverse . sort . filter isValid $ arr
  where
    isValid x = x >= 1 && x <= 9
    digitName x = case x of
      1 -> ""One""
      2 -> ""Two""
      3 -> ""Three""
      4 -> ""Four""
      5 -> ""Five""
      6 -> ""Six""
      7 -> ""Seven""
      8 -> ""Eight""
      9 -> ""Nine""
      _ -> error ""Unexpected number""","
main :: IO ()
main = do
  let candidate = byLength
  if candidate [2,1,1,4,5,8,2,3] == [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-1),55] == [""One""] then pure () else error ""assertion failed""
  if candidate [1,(-1),3,2] == [""Three"",""Two"",""One""] then pure () else error ""assertion failed""
  if candidate [9,4,8] == [""Nine"",""Eight"",""Four""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_106,azb_Arab,hs,"--اؤرنک: --i-نین فاکتورئلی 1 دن i-ه قدر اولان ساییلارین ضربی دیر (1 * 2 * ... * i).--i 1 دن باشلايير.--و يا 1دن iي قدر اولان ساييلارين جمعي.--و بیر n بؤیوکلوگو لیستی قایتارار کی، i ایندیکسین ده اولان عنصرین قئیمتی i نین فاکتورئلی اولسون اگر i جفت اولسا.--f فنکشنو اجرا کن که n رو به عنوان پارامتر میگیره،--  >>> f 5
--  [1,2,6,24,15]
f :: Int -> [Int]
f n =","f :: Int -> [Int]
f n = map g [1..n]
  where
    g i
      | even i    = factorial i
      | otherwise = sum [1..i]
    
    factorial 0 = 1
    factorial m = product [1..m]","
main :: IO ()
main = do
  let candidate = f
  if candidate 5 == [1,2,6,24,15] then pure () else error ""assertion failed""
  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  if candidate 3 == [1,2,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_107,azb_Arab,hs,"--مثال 1:--ساري ساري پاليندروملار کي، ((۱، ن) ، شمول) دائره سينده ديرلر.--٠ مثبت بير اينتگر n وئريله، بير توپل قايدير کي، اونون ايکي و بيريسي سايي وار ٠--  >>> evenOddPalindrome 3
--  (1, 2)
--  Explanation:
--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
--  Example 2:
--  >>> evenOddPalindrome 12
--  (4, 6)
--  Explanation:
--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
--  Note:
--  1. 1 <= n <= 10^3
--  2. returned tuple has the number of even and odd integer palindromes respectively.
evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n =","evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n = (length evens, length odds)
  where
    isPalindrome x = show x == reverse (show x)
    palindromes = filter isPalindrome [1..n]
    evens = filter even palindromes
    odds  = filter odd palindromes","
main :: IO ()
main = do
  let candidate = evenOddPalindrome
  if candidate 123 == (8, 13) then pure () else error ""assertion failed""
  if candidate 12 == (4, 6) then pure () else error ""assertion failed""
  if candidate 3 == (1, 2) then pure () else error ""assertion failed""
  if candidate 63 == (6, 8) then pure () else error ""assertion failed""
  if candidate 25 == (5, 6) then pure () else error ""assertion failed""
  if candidate 19 == (4, 6) then pure () else error ""assertion failed""
  if candidate 9 == (4, 5) then pure () else error ""assertion failed""
  if candidate 1 == (0, 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_108,azb_Arab,hs,"--مثلاً، -۱۲۳، -۱، ۲، و ۳ رقمی وار.--اگر بیر سایی منفی اولسا، اوندا اونون ایلک سیغینمیش سایی سی منفی اولاجاق: --بو عنصرلرین سایی سی اوْلاراق کی، اوْنلارین رقم لرینین مجموعی > 0 دیر.--"" count_nums "" فاکتئرینی یازین کی، بیر سایی لی ساییلار آلیب و قاییدیب.--  >>> countNums []
--  0
--  >>> countNums [(-1),11,(-11)]
--  1
--  >>> countNums [1,1,2]
--  3
countNums :: [Int] -> Int
countNums arr =","countNums :: [Int] -> Int
countNums arr = length $ filter ((> 0) . sumDigits) arr
  where
    sumDigits 0 = 0
    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)
                  in sum digits","
main :: IO ()
main = do
  let candidate = countNums
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),0] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error ""assertion failed""
  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error ""assertion failed""
  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error ""assertion failed""
  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_109,azb_Arab,hs,"--مثلن:--قید: وئریلن لیستین اؤزل عنصری وارلیغی تضمین اولونور.--اگر وئریلن لیست بوش اولسا، true'ی قایتار.--سونرا true-ي قايتار، يوخسا false-ي.--اگر اوسته کی عملیاتی ائتمکله ترتیبلندیریلن لیستین آلینماسی مومکون اولسا --لیستدهکی باشلانغیج یئرینه، یعنی 0-جی ایندئکسه.--لیستین سونونجو عنصری -ه آپاراجاق.--بیر ساغ یولا دؤنموش عمل، لیستین بوتون عنصری بیر یولا دؤنمک دئمکدیر.--هر دفعه ساغ اولماق اوچون حرکت ائده بیلرسینیز.--آشاغیداکی عملیات، وئریلن لیستده: --بو یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین یئرین--لیستده کی نومره لر تصادفی ترتیب لنه جک.--N عددلرین بیر سیرا سی 'arr' وار arr[1], arr[2], ..., arr[N]--  >>> moveOneBall [3,4,5,1,2]
--  True
--  Explanation: By performin 2 right shift operations, non-decreasing order can
--  be achieved for the given list.
--  >>> moveOneBall [3,5,4,1,2]
--  False
--  Explanation:It is not possible to get non-decreasing order for the given
--  list by performing any number of right shift operations.
moveOneBall :: [Int] -> Bool
moveOneBall arr =","moveOneBall :: [Int] -> Bool
moveOneBall [] = True
moveOneBall arr = canBeSorted (arr ++ arr)
  where
    n = length arr
    canBeSorted xs = any isSorted (take n <$> tails xs)
    isSorted ys = and $ zipWith (<=) ys (tail ys)
    tails [] = []
    tails l@(_:xs) = l : tails xs","
main :: IO ()
main = do
  let candidate = moveOneBall
  if candidate [3,4,5,1,2] == True then pure () else error ""assertion failed""
  if candidate [3,5,10,1,2] == True then pure () else error ""assertion failed""
  if candidate [4,3,1,2] == False then pure () else error ""assertion failed""
  if candidate [3,5,4,1,2] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_110,azb_Arab,hs,"--مثلن: --یوخسا ""نه""ی قایتارین.--lst1'ین بوتون عنصری برابر اولماق اوچون، ""YES""ی قایتارین.--اگر اولاي اولايلار آراسيندا موقاييس ائتمک مومکون اولسا--lst1 و lst2 آراسیندا آچیلان عنصرلرین سایی سی نین هئچ بیر محدودیتی یوخدور.--بو آرادا، اولو ساييلارين بيرليگيني ياراتماق اوچون، اولو ساييلارين بيرليگيني ياراتماق اوچون، اولو ساييلارين بيرليگيني ياراتماق اوچون، اولو ساييلارين بيرليگيني ياراتماق اوچون.--و معلوم ائدیر کی، عنصرلر آراسیندا موذاکیره ائتمک مومکوندور --بو مسئله ده، ايكي ساري ساري ساري ساري ساري ائده ن فؤنکشني ايفاده ائده جك.--  >>> exchange [1,2,3,4] [1,2,3,4]
--  ""YES""
--  >>> exchange [1,2,3,4] [1,5,3,4]
--  ""NO""
--  It is assumed that the input lists will be non-empty.
exchange :: [Int] -> [Int] -> String
exchange lst1 lst2 =","exchange :: [Int] -> [Int] -> String
exchange lst1 lst2
  | all even lst1 = ""YES""
  | null oddLst1 || null evenLst2 = ""NO""
  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)
                in if possibility then ""YES"" else ""NO""
  where
    oddLst1 = filter odd lst1
    evenLst2 = filter even lst2","
main :: IO ()
main = do
  let candidate = exchange
  if candidate [1,2,3,4] [1,2,3,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [1,5,3,4] == ""NO"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [2,1,4,3] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,3] == ""NO"" then pure () else error ""assertion failed""
  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == ""NO"" then pure () else error ""assertion failed""
  if candidate [100,200] [200,200] == ""YES"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_111,azb_Arab,hs,"--اؤرنک: --اگر نئچه حرفین یازیسی بیر هئچ اولماسا، هامیسی یازیلیب.--ان چوخ تکرار اولونان و موقابله سینده اوْلان حرفین سایی سی.--٠.۲.۲.۲.۲.۲.۲.۲.۳.۲.۲.۲.۳.۲.۲.۲.۳.۲.۲.۲.۲.۳.۲.۲.۲.۳.۲.۲.۲.۲.۳.۲.۲.۲.۲.۳.۲.۲.۲.۲.۳.۲.۲.۲.۲.۲.۲.۲.۲.۳.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.۲.--  >>> histogram ""a b c""
--  [(""a"", 1), (""b"", 1), (""c"", 1)]
--  >>> histogram ""a b b a""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""a b c a b""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""b b b b a""
--  [(""b"", 4)]
--  >>> histogram """"
--  []
histogram :: String -> [(String, Int)]
histogram test =","import Data.List (group, sort)
import Data.Ord (comparing)

histogram :: String -> [(String, Int)]
histogram input =
  let wordsList = words input
      grouped = group $ sort wordsList
      countList = map (\ws -> (head ws, length ws)) grouped
      maxCount = if null countList then 0 else maximum $ map snd countList
  in filter ((== maxCount) . snd) countList","
main :: IO ()
main = do
  let candidate = histogram
  if candidate ""a b b a"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c a b"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c d g"" == [(""a"", 1), (""b"", 1), (""c"", 1), (""d"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""b b b b a"" == [(""b"", 4)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""a"" == [(""a"", 1)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_112,azb_Arab,hs,"--اؤرنک --چک اوچون، نتیجه سیز سسلینتی و True/False ایله بیر توپل گئری قايتارین.--بیر سِره، اوْنلارین اوْنلارین اوْنلارینا اوْلدوغو کیمی اوْلدوغو بیر سِره، پالینْدروم دئییلیر.--سونرا، نتیجه نین بیر پالندروم اولماسینی چک. --S و c سیرا سیرا سیری لرین ایکی سی وار، سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا سیرا--""مهمّت""--  >>> reverseDelete ""abcde"" ""ae""
--  (""bcd"", False)
--  >>> reverseDelete ""abcdef"" ""b""
--  (""acdef"", False)
--  >>> reverseDelete ""abcdedcba"" ""ab""
--  (""cdedc"", True)
reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =","import Data.List (filter)

reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =
  let result = filter (`notElem` c) s
  in (result, result == reverse result)","
main :: IO ()
main = do
  let candidate = reverseDelete
  if candidate ""abcde"" ""ae"" == (""bcd"", False) then pure () else error ""assertion failed""
  if candidate ""abcdef"" ""b"" == (""acdef"", False) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""ab"" == (""cdedc"", True) then pure () else error ""assertion failed""
  if candidate ""dwik"" ""w"" == (""dik"", False) then pure () else error ""assertion failed""
  if candidate ""a"" ""a"" == ("""", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" """" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""v"" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""vabba"" ""v"" == (""abba"", True) then pure () else error ""assertion failed""
  if candidate ""mamma"" ""mia"" == ("""", True) then pure () else error ""assertion failed""
  pure ()"
HumanEval_113,azb_Arab,hs,"--بيرينجي سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا سيرا--"" هاردان کي، بوتون i لرين عوضينه  آليشيملي سايي قويولماليدير.--هر بير عنصر i چيخيشين ""سايداکي بيرنفر عنصرلرين سايي"" اولماليدير.--٠.سيرسيمانلارين بير سيراسي و هر سيراسي نين تکجه سيفرلري وار، بير سيراسي قاييدير.--  >>> oddCount [""1234567""]
--  [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
--  >>> oddCount [""3"",""11111111""]
--  [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""]
oddCount :: [String] -> [String]
oddCount lst =","oddCount :: [String] -> [String]
oddCount lst = map formatString lst
  where
    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""

    countOdds :: String -> Int
    countOdds str = length $ filter isOddDigit str

    formatString :: String -> String
    formatString str =
      let oddCount = countOdds str in
      ""the number of odd elements "" ++ show oddCount ++ 
      ""n the str"" ++ show oddCount ++ ""ng "" ++ show oddCount ++
      "" of the "" ++ show oddCount ++ ""nput.""","
main :: IO ()
main = do
  let candidate = oddCount
  if candidate [""1234567""] == [""the number of odd elements 4n the str4ng 4 of the 4nput.""] then pure () else error ""assertion failed""
  if candidate [""3"",""11111111""] == [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""] then pure () else error ""assertion failed""
  if candidate [""271"",""137"",""314""] == [""the number of odd elements 2n the str2ng 2 of the 2nput."",""the number of odd elements 3n the str3ng 3 of the 3nput."",""the number of odd elements 2n the str2ng 2 of the 2nput.""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_114,azb_Arab,hs,"--اؤرنک --ساييلار--٠:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:--  >>> minsubarraysum [2,3,4,1,2,4]
--  1
--  >>> minsubarraysum [(-1),(-2),(-3)]
--  (-6)
minsubarraysum :: [Int] -> Int
minsubarraysum nums =","minsubarraysum :: [Int] -> Int
minsubarraysum nums = minimum $ scanl1 (\acc x -> min x (acc + x)) nums","
main :: IO ()
main = do
  let candidate = minsubarraysum
  if candidate [2,3,4,1,2,4] == 1 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error ""assertion failed""
  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error ""assertion failed""
  if candidate [0,10,20,1000000] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [10,11,13,8,3,4] == 3 then pure () else error ""assertion failed""
  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error ""assertion failed""
  if candidate [(-10)] == (-10) then pure () else error ""assertion failed""
  if candidate [7] == 7 then pure () else error ""assertion failed""
  if candidate [1,(-1)] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_115,azb_Arab,hs,"--مثال 1:--دده لری نئچه دفعه آشاغی سالماق لازیم اولدوغونو بیلدیرین.--ایشینیز بولاقلاری بوشالتماق اوچون سطیرلری ایستیفاده ائتمکدیر.--و بوتون سطللرین ساییسی برابر دیر.--هر بولاقدا اونا مووافئق بیر سطیر وار کی، اوندان سو چکمک اوچون ایستیفاده ائدیله بیلر.--و هر بیر سیرا 1، بیر واحد سو ایله برابر دیر.--هر سيرا تک بير بولاغي تمثيل ائدير.--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1
--  6
--  Example 2:
--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2
--  5
--  Example 3:
--  >>> maxFill [[0,0,0],[0,0,0]] 5
--  0
--  Constraints:
--  * all wells have the same length
--  * 1 <= grid.length <= 10^2
--  * 1 <= grid[:,1].length <= 10^2
--  * grid[i][j] -> 0 | 1
--  * 1 <= capacity <= 10
maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity =","maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity = ceiling (fromIntegral totalWater / fromIntegral capacity)
  where
    totalWater = sum (map sum grid)","
main :: IO ()
main = do
  let candidate = maxFill
  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error ""assertion failed""
  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error ""assertion failed""
  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_116,azb_Arab,hs,"--اونو بئله ائتمک لازيمدير:--برابر سایی بیرلیک لری اوچون، اونلاییش قئیدینه اساسلاناراق ترتیبله --بیرلیکلرین سایی ایکی لیک نوماینده سینده آرتیقلی شکیلده.--بو کاتادا، منفی اولمایان سایی لاری بیر سیرا سیرا یئرینه یئرلشدیریرسیز.--  >>> sortArray [1,5,2,3,4]
--  [1,2,3,4,5]
--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]
--  [(-6),(-5),(-4),(-3),(-2)]
--  >>> sortArray [1,0,2,3,4]
--  [0,1,2,3,4]
sortArray :: [Int] -> [Int]
sortArray arr =","import Data.Bits (popCount)
import Data.List (sortBy)

sortArray :: [Int] -> [Int]
sortArray arr = sortBy compareOnesAndValues arr
  where
    compareOnesAndValues x y =
      let onesX = popCount x
          onesY = popCount y
      in if onesX == onesY
         then compare x y
         else compare onesX onesY","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error ""assertion failed""
  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error ""assertion failed""
  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error ""assertion failed""
  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  pure ()"
HumanEval_117,azb_Arab,hs,"--اؤرنکلر: --ياداشت: گئچديريلن سيرادا فقط حرفلر و بوشلوقلار وار.--اگر string s بوش اولسا، اوندا فاکتوس بیر بوش لیست قایتارمالی دیر.--n سسلی حرفلر، بو کلمه لرین s سیراسیندا گؤرونمه سیله. --بیر فاکتئر کی، سونوجلارین هامیسی نین بیر سیرا سؤزجوکلرینی قایتاریر کی، هامیسی --""s"" و ""n"" ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري--  >>> selectWords ""Mary had a little lamb"" 4
--  [""little""]
--  >>> selectWords ""Mary had a little lamb"" 3
--  [""Mary"",""lamb""]
--  >>> selectWords ""simple white space"" 2
--  []
--  >>> selectWords ""Hello world"" 4
--  [""world""]
--  >>> selectWords ""Uncle sam"" 3
--  [""Uncle""]
selectWords :: String -> Int -> [String]
selectWords s n =","selectWords :: String -> Int -> [String]
selectWords s n = filter (\word -> countConsonants word == n) (words s)
  where
    countConsonants = length . filter (`elem` consonants)
    consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ""","
main :: IO ()
main = do
  let candidate = selectWords
  if candidate ""Mary had a little lamb"" 4 == [""little""] then pure () else error ""assertion failed""
  if candidate ""Mary had a little lamb"" 3 == [""Mary"",""lamb""] then pure () else error ""assertion failed""
  if candidate ""simple white space"" 2 == [] then pure () else error ""assertion failed""
  if candidate ""Hello world"" 4 == [""world""] then pure () else error ""assertion failed""
  if candidate ""Uncle sam"" 3 == [""Uncle""] then pure () else error ""assertion failed""
  if candidate """" 4 == [] then pure () else error ""assertion failed""
  if candidate ""a b c d e f"" 1 == [""b"",""c"",""d"",""f""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_118,azb_Arab,hs,"--اؤرنک: --بئله دوشونورسن کی، بو سیرا یالنیز اینگیلیسجه حرفلری واردیر.--هر بیر سسلی حرفی تاپین کی، اوسته کی شرطلره اویغون اولسون.--باشلانيش و سونونجو سسلي حرفلر ساييلماز.--کلمه نین ساغ طرفیندن ایکی سسلی حرف (آغجا-آغجا بؤلومو)--بیر سؤز وئریلیر. سیزین ایشینیز آراداکی ان یاخین سسلی حرفی تاپماق دیر.--  >>> getClosestVowel ""yogurt""
--  ""u""
--  >>> getClosestVowel ""FULL""
--  ""U""
--  >>> getClosestVowel ""quick""
--  """"
--  >>> getClosestVowel ""ab""
--  """"
getClosestVowel :: String -> String
getClosestVowel word =","getClosestVowel :: String -> String
getClosestVowel word = go (reverse word) False
  where
    vowels = ""aeiouAEIOU""
    go [] _ = """"
    go (x:xs) lastWasConsonant
      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False
      | x `notElem` vowels = go xs True
      | otherwise = go xs False","
main :: IO ()
main = do
  let candidate = getClosestVowel
  if candidate ""yogurt"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""full"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""easy"" == """" then pure () else error ""assertion failed""
  if candidate ""eAsy"" == """" then pure () else error ""assertion failed""
  if candidate ""ali"" == """" then pure () else error ""assertion failed""
  if candidate ""bad"" == ""a"" then pure () else error ""assertion failed""
  if candidate ""most"" == ""o"" then pure () else error ""assertion failed""
  if candidate ""ab"" == """" then pure () else error ""assertion failed""
  if candidate ""ba"" == """" then pure () else error ""assertion failed""
  if candidate ""quick"" == """" then pure () else error ""assertion failed""
  if candidate ""anime"" == ""i"" then pure () else error ""assertion failed""
  if candidate ""Asia"" == """" then pure () else error ""assertion failed""
  if candidate ""Above"" == ""o"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_119,azb_Arab,hs,"--اؤرنکلر: --اگر ""بله""ی یؤنتیردیکده یول وارسا، ""یوخ""ی یؤنتیردیکده یول وارسا، ""یوخ""ی یؤنتیردیکده یول وارسا.--"" (()) "" یوخدور.--مثال اوچون: ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}، ""{""}،--S-ده کی بوتون قوسلارین تکجه S-ده یئرلشن بیر سسلنمه سی یاخشی ساییلار.--بعضي سيرا، کي، نتيجه سينده اولان سير ياخشي اولاجاق.--ایشینیز ایکی سِرینی بیر-بیرینه باغلاماق ایشینه باخماقدیر.--آنجاق "" (("" و یا "" "") قوسلوقلارین آراسیندا.--٠: ايکي سيرله بير ليست وئريلير، هر ائکي سير آچيقدان عبارتدير.--  >>> matchParens [""()("","")""]
--  ""Yes""
--  >>> matchParens ["")"","")""]
--  ""No""
matchParens :: [String] -> String
matchParens lst =","matchParens :: [String] -> String
matchParens [a, b] =
    if isValid (a ++ b) || isValid (b ++ a) then ""Yes"" else ""No""
  where
    isValid :: String -> Bool
    isValid = go 0
      where
        go 0 [] = True
        go _ [] = False
        go n (x:xs)
            | x == '('  = go (n + 1) xs
            | x == ')'  = n > 0 && go (n - 1) xs
    isValid _ = False","
main :: IO ()
main = do
  let candidate = matchParens
  if candidate [""()("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"","")""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()(())"",""())())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")())"",""(()()(""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(())))"",""(()())((""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""()"",""())""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()("",""()))()""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(((("",""((())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")(()"",""(()(""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")("","")(""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"",""(""] == ""Yes"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_120,azb_Arab,hs,"--مثال 1:--اوزونلوغو k اولان و آر آر-دا ان چوخ k سايي اولان.--آر آر آر و k مثبت عددلرین بیر سیراسی وئریلیر، ترتیبلی بیر سیرا قایتار.--  >>> maximum [(-3),(-4),5] 3
--  [(-4),(-3),5]
--  Example 2:
--  >>> maximum [4,(-4),4] 2
--  [4,4]
--  Example 3:
--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1
--  [2]
--  Note:
--  1. The length of the list will be in the range of [1, 1000].
--  2. The elements in the list will be in the range of [-1000, 1000].
--  3. 0 <= k <= len(arr)
maximum :: [Int] -> Int -> [Int]
maximum arr k =","maximum :: [Int] -> Int -> [Int]
maximum arr k = take k $ reverse $ sort arr","
main :: IO ()
main = do
  let candidate = maximum
  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error ""assertion failed""
  if candidate [4,(-4),4] 2 == [4,4] then pure () else error ""assertion failed""
  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error ""assertion failed""
  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error ""assertion failed""
  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error ""assertion failed""
  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error ""assertion failed""
  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error ""assertion failed""
  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error ""assertion failed""
  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error ""assertion failed""
  if candidate [(-10),10] 2 == [(-10),10] then pure () else error ""assertion failed""
  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_121,azb_Arab,hs,"--اؤرنکلر --٠ بير بوش اولمايان ساييلارين سايي سي، بوتون ساييلارين جومله سيني قاييدير کي، برابر اولدوقلاري حاللاردا دير.--  >>> solution [5,8,7,1]
--  12
--  >>> solution [3,3,3,3,3]
--  9
--  >>> solution [30,13,24,321]
--  0
solution :: [Int] -> Int
solution lst =","solution :: [Int] -> Int
solution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","
main :: IO ()
main = do
  let candidate = solution
  if candidate [5,8,7,1] == 12 then pure () else error ""assertion failed""
  if candidate [3,3,3,3,3] == 9 then pure () else error ""assertion failed""
  if candidate [30,13,24,321] == 0 then pure () else error ""assertion failed""
  if candidate [5,9] == 5 then pure () else error ""assertion failed""
  if candidate [2,4,8] == 0 then pure () else error ""assertion failed""
  if candidate [30,13,23,32] == 23 then pure () else error ""assertion failed""
  if candidate [3,13,2,9] == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_122,azb_Arab,hs,"--اؤرنک: --آر آرین ایلک k عنصرین دن چوخ ایکی سیفره لی اولان عنصرلرین مجموعی. --آر آر و k عددلرین بیر بوش اولمایان بیر سیرا سی دییشیک لیگی وئریله رک، return --  >>> addElements [111,21,3,4000,5,6,7,8,9] 4
--  24
--  Constraints:
--  1. 1 <= len(arr) <= 100
--  2. 1 <= k <= len(arr)
addElements :: [Int] -> Int -> Int
addElements arr k =","addElements :: [Int] -> Int -> Int
addElements arr k = sum $ filter (\x -> x >= -99 && x <= 99) $ take k arr","
main :: IO ()
main = do
  let candidate = addElements
  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error ""assertion failed""
  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error ""assertion failed""
  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error ""assertion failed""
  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error ""assertion failed""
  if candidate [1] 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_123,azb_Arab,hs,"--get_odd_collatz(5) return [1, 5] # collatz sequence for 5 is [5, 16, 8, 4, 2, 1]، so the odd numbers are only 1, and 5. --مثلن: --2. قاييديلان فهرست آرتما سيراسيندا ترتيبلانميشدير.--1. Collatz ((1)) = [1]--يادداشت:--""term plus 1"" قیسا ساییسیندا، n-ین هانسی قدر قئیمتینه باخمایاراق، نؤوبه همیشه ۱-ه چاتاجاقدیر.--اگر اوّلکي قيسسا، سونراکي قيسسا، اوّلکي قيسانين 3 قاتيدير.--اؤنجه کی دؤورون اویونلاری بئله دیر: اگر اؤنجه کی دؤور جفت اولسا، سونراکی دؤورون یاریسی --بئله لیکله: هر مثبت عددله باشلایین. سونرا هر بیر عدد  دن آلینیر.--کولاتز قیله سی بیر ریاضی قیله سی دیر کی تعریف اولونموش بیر ترتیب ایله علاقه دار دیر .--٠ مثبت بير اينتگر n وئريله، بير ترتيبلانميش ليستي قايدير کي، Collatz سيراسينده بيرجه ساييلاري وار.--  >>> getOddCollatz 5
--  [1,5]
getOddCollatz :: Int -> [Int]
getOddCollatz n =","getOddCollatz :: Int -> [Int]
getOddCollatz n = sort . filter odd $ collatzSequence n
  where
    collatzSequence 1 = [1]
    collatzSequence x
      | even x    = x : collatzSequence (x `div` 2)
      | otherwise = x : collatzSequence (3 * x + 1)","
main :: IO ()
main = do
  let candidate = getOddCollatz
  if candidate 14 == [1,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 5 == [1,5] then pure () else error ""assertion failed""
  if candidate 12 == [1,3,5] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_124,azb_Arab,hs,"--4. تاريخ بايد به شكل: mm-dd-yyyy --3. آيلار 1 دن آز و 12 دن چوخ اولماماليدير.--۲- آيين گونلرين سايي ۱-دن آز و يا ۳۱-دن چوخ اولماماليدير. ۲- آيين گونلرين سايي ۱-دن آز و يا ۳۰-دن چوخ اولماماليدير.--1. تاريخين سيراسي بوش ديئل.--بو تاریخ، آشاغیداکی قایدالاردان هامیسی راضی اولوندوغو زامان اعتبارلی دیر: --اگر تاریخ یئرلی اولسا TRUE یئرلی اولور، یوخسا FALSE.--٠.تو بايد يه تابع بنويسي که يه رشته تاريخ داده شده رو تاييد کنه و ٠.تو بايد يه تابع بنويسي که يه رشته تاريخ داده شده رو تاييد کنه و ٠.تو بايد يه تابع بنويسي که يه رشته تاريخ داده شده رو تاييد کنه و ٠.تو بايد يه تابع بنويسي که يه رشته تاريخ داده شده رو تاييد کنه و ٠.تو بايد يه تابع بنويسي که يه رشته تاريخ داده شده رو تاييد کنه--  >>> validDate ""03-11-2000""
--  True
--  >>> validDate ""15-01-2012""
--  False
--  >>> validDate ""04-0-2040""
--  False
--  >>> validDate ""06-04-2020""
--  True
--  >>> validDate ""06/04/2020""
--  False
validDate :: String -> Bool
validDate date =","import Text.Read (readMaybe)
import Data.List.Split (splitOn)

validDate :: String -> Bool
validDate date =
    case splitOn ""-"" date of
        [m, d, y] -> isValidMonthDayYear m d y
        _         -> False

isValidMonthDayYear :: String -> String -> String -> Bool
isValidMonthDayYear m d y =
    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of
        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day
        _ -> False

isValidMonth :: Int -> Bool
isValidMonth month = month >= 1 && month <= 12

isValidDay :: Int -> Int -> Bool
isValidDay month day
    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31
    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30
    | month == 2                           = day >= 1 && day <= 29
    | otherwise                            = False","
main :: IO ()
main = do
  let candidate = validDate
  if candidate ""03-11-2000"" == True then pure () else error ""assertion failed""
  if candidate ""15-01-2012"" == False then pure () else error ""assertion failed""
  if candidate ""04-0-2040"" == False then pure () else error ""assertion failed""
  if candidate ""06-04-2020"" == True then pure () else error ""assertion failed""
  if candidate ""01-01-2007"" == True then pure () else error ""assertion failed""
  if candidate ""03-32-2011"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""04-31-3000"" == False then pure () else error ""assertion failed""
  if candidate ""06-06-2005"" == True then pure () else error ""assertion failed""
  if candidate ""21-31-2000"" == False then pure () else error ""assertion failed""
  if candidate ""04-12-2003"" == True then pure () else error ""assertion failed""
  if candidate ""04122003"" == False then pure () else error ""assertion failed""
  if candidate ""20030412"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04-12"" == False then pure () else error ""assertion failed""
  if candidate ""04-2003"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_126,azb_Arab,hs,"--اؤرنکلر --number، return False. فرض ائدک کی، منفی سایی یوخ، آنجاق بوتون ساییلار وار.--اگر لیستده 1 دان چوخ تکنابلویون وارسا --٠:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:--  >>> isSorted [5]
--  True
--  >>> isSorted [1,2,3,4,5]
--  True
--  >>> isSorted [1,3,2,4,5]
--  False
--  >>> isSorted [1,2,3,4,5,6]
--  True
--  >>> isSorted [1,2,3,4,5,6,7]
--  True
--  >>> isSorted [1,3,2,4,5,6,7]
--  False
--  >>> isSorted [1,2,2,3,3,4]
--  True
--  >>> isSorted [1,2,2,2,3,4]
--  False
isSorted :: [Int] -> Bool
isSorted lst =","isSorted :: [Int] -> Bool
isSorted lst = go lst Nothing
  where
    go [] _ = True
    go [x] _ = True
    go (x:y:xs) prev
      | x > y = False
      | x == y && prev == Just x = False
      | otherwise = go (y:xs) (Just x)","
main :: IO ()
main = do
  let candidate = isSorted
  if candidate [5] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,7] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  if candidate [1] == True then pure () else error ""assertion failed""
  if candidate [3,2,1] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,2,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,3,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,3,3,4] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_127,azb_Arab,hs,"--[آندری/آندری] نمونه لری: --اگر بو ایکی آرتیق بیر-بیرینه اویغون اولمایانسا، ""نه"" قاییدیب.--یوخسا ""نه"" دئیه قاییت.--اگر بو تقاطعین اوزونلوغو بیر اولوملو سایی دیر، ""YES"" قاییدیب، --بو اولدوقجا 1 دیر، او دا اولدوقجا بیر اولدوز سایی دئییل.--مثال، (1، 3) ، (2، 4) ، (2، 3) ،--آرالار بیر اولوملو سایی دیر.--سیزین وظیفتینیز بو ایکی نین آراسینداکی بوینون اوزونلوغونو تعیین ائتمک دیر.--هر بير آندا، اونون باشلانيشينين اونون آخيرينا آز يا برابر اولدوغو فرض ائديلير.--باشلانيش و آخيريني دا ائدر.--بو آرالاردا اولان آراسی باغلی دیر، یعنی آرالارداکی آراسی (باشلانغیج، آخیر) --هر بیر آرالیق بیر جوت سایی دیر.مثلا، آرالیق = (آغ، آخ) = (1, 2).--سنه ایکی آرتیق زامان وئریلیر،--  >>> intersection (1, 2) (2, 3)
--  ""NO""
--  >>> intersection ((-1), 1) (0, 4)
--  ""NO""
--  >>> intersection ((-3), (-1)) ((-5), 5)
--  ""YES""
intersection :: (Int, Int) -> (Int, Int) -> String
intersection interval1 interval2 =","intersection :: (Int, Int) -> (Int, Int) -> String
intersection (start1, end1) (start2, end2) = 
    if intersectionLength > 0 && isPrime intersectionLength
    then ""YES""
    else ""NO""
  where
    intersectionStart = max start1 start2
    intersectionEnd = min end1 end2
    intersectionLength = intersectionEnd - intersectionStart + 1
    
    isPrime :: Int -> Bool
    isPrime n
      | n <= 1 = False
      | n == 2 = True
      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","
main :: IO ()
main = do
  let candidate = intersection
  if candidate (1, 2) (2, 3) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-1), 1) (0, 4) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-3), (-1)) ((-5), 5) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-2), 2) ((-4), 0) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-11), 2) ((-1), (-1)) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (3, 5) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (1, 2) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-2), (-2)) ((-3), (-2)) == ""NO"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_128,azb_Arab,hs,"--اؤرنک: --يادداشت: return Nothing for empty arr. --هر سایی نین بیرینجی سی، 1، -1 و 0 ایله تمثیل اولونور.--بوتون علامتلرین مولتولیتینه ضرب اولونموش بوتون عددی بؤیوکلوکلرین جمعی --سنه بير آر آر ساييلي ساييلار سيراسي وئريلير و سنه بير يئنه قاييدماق لازيمدير.--  >>> prodSigns [1,2,2,(-4)]
--  Just (9)
--  >>> prodSigns [0,1]
--  Just (0)
--  >>> prodSigns []
--  Just (Nothing)
prodSigns :: [Int] -> Maybe Int
prodSigns arr =","prodSigns :: [Int] -> Maybe Int
prodSigns [] = Nothing
prodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","
main :: IO ()
main = do
  let candidate = prodSigns
  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error ""assertion failed""
  if candidate [0,1] == Just (0) then pure () else error ""assertion failed""
  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error ""assertion failed""
  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,0] == Just (0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_129,azb_Arab,hs,"--اؤرنکلر: --مینیما یولون گئدیب گئدن حجره لرده کی قئیدلرین ترتیبلی بیر لیستینی قایتار. --جوابين بيرجه اولماسي ضمانت اولونور.--lst_A[j] = lst_B[j].--بئله کی lst_A[i] < lst_B[i] و هر j (1 <= j < i) اوچون --lst_B، باشقا سؤزله، i (1 <= i <= k)  بیر سایی سیز ایندیکس وار.--lst_A و lst_B آدلاندیریر) ، lst_A سؤزلوگونون آز اولماسی دیر.--سونرا A و B گئدن حجره لردهکي قئيمتلري ترتيبلي اولاراق يازين .--بیر یول A (ک اوزونلوغو) بیر یول B (ک اوزونلوغو) دن آز ساییلار اگر --گئتمه یه جکسن.--لازيمدير کي، آيريلسين).--لطفاً توجه ائدین کی، اوزونلوغو k اولان بیر یول، دقیقاً k حجره نی گئدر (مستقیم بیر حجره نین یوخ)--موبايل--باشقا سؤزله، سیز سیزله بیر حاشییه پایلاشان حجره لره گئده بیلرسینیز.--هر مرحله ده هر بیر حجره دن، هر بیر حجره یه یول آچیرسان.--توردا k اوزونلوغوندا اولان ان آز یولونو تاپمالی سیز. باشلایین.--""Inclusive"" یئرلشدیریلن بیر یئرلشدیریلن بیر یئرلشدیریلن بیر یئرلشدیریلن بیر یئرلشدیریلن بیر یئرلشدیریلن بیر یئرلشدیریلن--هر بیر سیللرین بیر قئید واردیر. هر بیر عدد [۱، N * N]--""N"" صف و ""N"" ستون (N >=2) و ""k"" مثبت عددله بیر شبکه ده،--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3
--  [1,2,1]
--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1
--  [1]
minpath :: [[Int]] -> Int -> [Int]
minpath grid k =","import Data.List (sort, sortBy)
import Data.Ord (comparing)
import Control.Monad (guard)

minpath :: [[Int]] -> Int -> [Int]
minpath grid k = head $ sort paths
  where
    n = length grid
    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]
    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
      where
        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n
    value (r, c) = grid !! r !! c
    paths = do
      start <- cells
      findPaths k [start]
    findPaths 1 path = return $ map value path
    findPaths l path@(current:_) = do
      next <- neighbors current
      findPaths (l-1) (next : path)","
main :: IO ()
main = do
  let candidate = minpath
  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error ""assertion failed""
  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error ""assertion failed""
  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error ""assertion failed""
  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error ""assertion failed""
  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error ""assertion failed""
  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error ""assertion failed""
  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_130,azb_Arab,hs,"--اؤرنکلر: --تريبوناتشي سيراسي نين ايلک n + 1 ساييلاري. --سنه منفی اولمایان بیر عدد n وئریلیر، و سن بیر لیستینی قایتارمالیسان.--= 2 + 3 + 3 = 8 --tri(3) = tri(2) + tri(1) + tri(4) --tri ((4) = 3 --tri ((2) = 1 + (2 / 2) = 2 --مثلن: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), اگر n ناقص باشد. --tri ((n) = 1 + n / 2، اگر n جفت دیر. --tri(1) = 3 --تريبوناكچي سياقي بير- بيرينه قاييديلماسي ايله تعريف اولونور:--هر حالدا، نه کیمسه نین تریبوناکچی نؤعونو بیلمه دیگی.--فئبوناکچي سيراسي هرکيمسه يه بلليدير، اونو ۱۹۵۰-جو ايلده رياضيچي لر درين بير شکئلده اؤيرهنديلير.--  >>> tri 3
--  [1,3,2,8]
tri :: Int -> [Int]
tri n =","tri :: Int -> [Int]
tri n = map tribonacci [0..n]
  where
    -- Define the recursive function to calculate the tribonacci value for a given n
    tribonacci :: Int -> Int
    tribonacci 0 = 1
    tribonacci 1 = 3
    tribonacci x
      | even x    = 1 + x `div` 2
      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","
main :: IO ()
main = do
  let candidate = tri
  if candidate 3 == [1,3,2,8] then pure () else error ""assertion failed""
  if candidate 4 == [1,3,2,8,3] then pure () else error ""assertion failed""
  if candidate 5 == [1,3,2,8,3,15] then pure () else error ""assertion failed""
  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error ""assertion failed""
  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error ""assertion failed""
  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error ""assertion failed""
  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error ""assertion failed""
  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error ""assertion failed""
  if candidate 0 == [1] then pure () else error ""assertion failed""
  if candidate 1 == [1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_131,azb_Arab,hs,"--مثلن: --اگر بوتون رقملری برابر اولسا 0 قاییدیب. --٠ مثبت بير اينتگر n ورنده، بيرجه خانين ضربيني قايتارين. ٠--  >>> digits 1
--  1
--  >>> digits 4
--  0
--  >>> digits 235
--  15
digits :: Int -> Int
digits n =","digits :: Int -> Int
digits n
  | null oddDigits = 0
  | otherwise      = product oddDigits
  where
    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","
main :: IO ()
main = do
  let candidate = digits
  if candidate 5 == 5 then pure () else error ""assertion failed""
  if candidate 54 == 5 then pure () else error ""assertion failed""
  if candidate 120 == 1 then pure () else error ""assertion failed""
  if candidate 5014 == 5 then pure () else error ""assertion failed""
  if candidate 98765 == 315 then pure () else error ""assertion failed""
  if candidate 5576543 == 2625 then pure () else error ""assertion failed""
  if candidate 2468 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_132,azb_Arab,hs,"--هارا کي، يئنه ده اينديکي سيراسيدا، اَکيمسه نين بير قوسماسي وار.--بو فاکتوس True-ي آنجاق اگر و آنجاق اگر قوسلوقلارين اعتبارلي بير نؤوبه سي وارسا قايدير .--٠ فانکشن ايجاد کنيد که يک رشته اي رو به عنوان ورودي بگيره که فقط شامل قوس مربع باشه --  >>> isNested ""[[]]""
--  True
--  >>> isNested ""[]]]]]]][[[[[]""
--  False
--  >>> isNested ""[][]""
--  False
--  >>> isNested ""[]""
--  False
--  >>> isNested ""[[][]]""
--  True
--  >>> isNested ""[[]][[""
--  True
isNested :: String -> Bool
isNested string =","isNested :: String -> Bool
isNested string = go string 0 False
  where
    go [] _ nested = nested
    go (x:xs) depth nested
      | x == '['  = go xs (depth + 1) (nested || depth >= 1)
      | x == ']' && depth > 0 = go xs (depth - 1) nested
      | otherwise = go xs depth nested","
main :: IO ()
main = do
  let candidate = isNested
  if candidate ""[[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]][[[[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[][]"" == False then pure () else error ""assertion failed""
  if candidate ""[]"" == False then pure () else error ""assertion failed""
  if candidate ""[[[[]]]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]]]]]"" == False then pure () else error ""assertion failed""
  if candidate ""[][][[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[]]"" == False then pure () else error ""assertion failed""
  if candidate ""[[]][["" == True then pure () else error ""assertion failed""
  if candidate ""[[][]]"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""[[[[[[[["" == False then pure () else error ""assertion failed""
  if candidate ""]]]]]]]]"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_133,azb_Arab,hs,"--اؤرنکلر: --هر بیر عنصرین ایلک نؤوبه سینده یوخاری اینت (تک) درجه سینده دایره لندیریلسین.--بوردا، دوققوزونجو سایی نین جومله سینی قایتارمالی ییق.--٠ سيراسيک نومره لر وئريلير. ٠--  >>> lst [1.0,2.0,3.0]
--  14
--  >>> lst [1.0,4.0,9.0]
--  98
--  >>> lst [1.0,3.0,5.0,7.0]
--  84
--  >>> lst [1.4,4.2,0.0]
--  29
--  >>> lst [-2.4,1.0,1.0]
--  6
sumSquares :: [Float] -> Int
sumSquares lst =","import Data.List (foldl')
import Prelude hiding (sum)

sumSquares :: [Float] -> Int
sumSquares lst = foldl' (\acc x -> acc + ceiling x ^ 2) 0 lst","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error ""assertion failed""
  if candidate [1.4,4.2,0.0] == 29 then pure () else error ""assertion failed""
  if candidate [-2.4,1.0,1.0] == 6 then pure () else error ""assertion failed""
  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error ""assertion failed""
  if candidate [10000.0,10000.0] == 200000000 then pure () else error ""assertion failed""
  if candidate [-1.4,4.6,6.3] == 75 then pure () else error ""assertion failed""
  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error ""assertion failed""
  if candidate [0.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0] == 1 then pure () else error ""assertion failed""
  if candidate [-1.0,1.0,0.0] == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_134,azb_Arab,hs,"--اؤرنکلر: --ياداشت: ""سؤز"" بوشلوقلا آيريلميش حرفلر دسته سي دير.--سؤزون بیر پارچاسی، و باشقا یالان.--بو حرفلرين بير سيراسي، حرفي دير و  دئييل.--۰۲:۰۸:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲:۲۲--  >>> checkIfLastCharIsALetter ""apple pie""
--  False
--  >>> checkIfLastCharIsALetter ""apple pi e""
--  True
--  >>> checkIfLastCharIsALetter ""apple pi e ""
--  False
--  >>> checkIfLastCharIsALetter """"
--  False
checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt =","checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt = 
    let trimmed = reverse . dropWhile (== ' ') $ reverse txt
    in case trimmed of
        [] -> False
        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","
main :: IO ()
main = do
  let candidate = checkIfLastCharIsALetter
  if candidate ""apple"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e"" == True then pure () else error ""assertion failed""
  if candidate ""eeeee"" == False then pure () else error ""assertion failed""
  if candidate ""A"" == True then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie "" == False then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie 1"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""eeeee e "" == False then pure () else error ""assertion failed""
  if candidate ""apple pie"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e "" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_135,azb_Arab,hs,"--اؤرنکلر: --دوپلوملو قئيدلر.--بو عنصرین اولماسی اولمادیغی اوچون، -1 قاییدیلیر.--چوخ اولماز و یا برابر اولماز اوندان قاباقکی عنصردن.--بیر فاکتئر یاراتین کی بیر عنصردن ان بؤیوک ایندئکسی قایتارسین کی--  >>> canArrange [1,2,4,3,5]
--  3
--  >>> canArrange [1,2,3]
--  (-1)
canArrange :: [Int] -> Int
canArrange arr =","canArrange :: [Int] -> Int
canArrange arr = go arr (-1) 0
  where
    go [] maxIdx _ = maxIdx
    go [_] maxIdx _ = maxIdx
    go (x:y:xs) maxIdx idx
      | x >= y    = go (y:xs) idx (idx + 1)
      | otherwise = go (y:xs) maxIdx (idx + 1)","
main :: IO ()
main = do
  let candidate = canArrange
  if candidate [1,2,4,3,5] == 3 then pure () else error ""assertion failed""
  if candidate [1,2,4,5] == (-1) then pure () else error ""assertion failed""
  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error ""assertion failed""
  if candidate [4,8,5,7,3] == 4 then pure () else error ""assertion failed""
  if candidate [] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_136,azb_Arab,hs,"--اؤرنکلر: --اگر منفی و یا مثبت بیر سایی یوخسا، اونلاری Nothing کیمی قایتار.--بير سيرا سيراسيندا مثبت ساييلارين ساييلاري.--بو ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري ساري--""a"" ایله ""a"" نین بیرینجی اولماسی اوچون بیر فاکتئر یاراتین.--  >>> largestSmallestIntegers [2,4,1,3,5,7]
--  (Nothing, 1)
--  >>> largestSmallestIntegers []
--  (Nothing, Nothing)
--  >>> largestSmallestIntegers [0]
--  (Nothing, Nothing)
largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst =","largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst = (largestNegative, smallestPositive)
  where
    negatives = filter (< 0) lst
    positives = filter (> 0) lst
    largestNegative = if null negatives then Nothing else Just (maximum negatives)
    smallestPositive = if null positives then Nothing else Just (minimum positives)","
main :: IO ()
main = do
  let candidate = largestSmallestIntegers
  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error ""assertion failed""
  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error ""assertion failed""
  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error ""assertion failed""
  if candidate [] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [0] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_138,azb_Arab,hs,"--اؤرنک --""ن"" سایی نین، دوغرو 4 مثبت جفت سایی نین جمعی اولاراق یازیلابیلرمی؟--  >>> isEqualToSumEven 4
--  False
--  >>> isEqualToSumEven 6
--  False
--  >>> isEqualToSumEven 8
--  True
isEqualToSumEven :: Int -> Bool
isEqualToSumEven n =","isEqualToSumEven :: Int -> Bool
isEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","
main :: IO ()
main = do
  let candidate = isEqualToSumEven
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == True then pure () else error ""assertion failed""
  if candidate 11 == False then pure () else error ""assertion failed""
  if candidate 12 == True then pure () else error ""assertion failed""
  if candidate 13 == False then pure () else error ""assertion failed""
  if candidate 16 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_139,azb_Arab,hs,"--مثلن: --هارا n > 0 --brazilian_factorial{n} = n! * (n-1)! * (n-2)! * ... * 1! --برازیلیانین فاکتورئلی بئله تعریف اولونور:--  >>> specialFactorial 4
--  288
--  The function will receive an integer as input and should return the special
--  factorial of this integer.
specialFactorial :: Int -> Int
specialFactorial n =","specialFactorial :: Int -> Int
specialFactorial n = product [factorial x | x <- [1..n]]
  where
    factorial 0 = 1
    factorial k = k * factorial (k - 1)","
main :: IO ()
main = do
  let candidate = specialFactorial
  if candidate 4 == 288 then pure () else error ""assertion failed""
  if candidate 5 == 34560 then pure () else error ""assertion failed""
  if candidate 7 == 125411328000 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_140,azb_Arab,hs,"--سونرا بوتون اوز-اوزه اولان بوش یئرلری -  ایله یئرلشدیریر.--و اگر بیر سِره نین ۲-دن چوخ نؤوبه لی یئرلری وارسا، --٠ متنسلله، بوتون بوشلوقلاري آلتداکي حرفلرله عوض ات ٠--  >>> fixSpaces "" Example""
--  ""Example""
--  >>> fixSpaces "" Example 1""
--  ""Example_1""
--  >>> fixSpaces "" Example 2""
--  ""_Example_2""
--  >>> fixSpaces "" Example 3""
--  ""_Example-3""
fixSpaces :: String -> String
fixSpaces text =","fixSpaces :: String -> String
fixSpaces text = concatMap replaceSpaces (groupSpaces text)
  where
    groupSpaces :: String -> [String]
    groupSpaces [] = []
    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest

    replaceSpaces :: String -> String
    replaceSpaces spaces@(x:_)
      | x == ' ' && length spaces > 2 = ""-""
      | x == ' ' = replicate (length spaces) '_'
      | otherwise = spaces","
main :: IO ()
main = do
  let candidate = fixSpaces
  if candidate ""Example"" == ""Example"" then pure () else error ""assertion failed""
  if candidate ""Mudasir Hanif "" == ""Mudasir_Hanif_"" then pure () else error ""assertion failed""
  if candidate ""Yellow Yellow  Dirty  Fellow"" == ""Yellow_Yellow__Dirty__Fellow"" then pure () else error ""assertion failed""
  if candidate ""Exa   mple"" == ""Exa-mple"" then pure () else error ""assertion failed""
  if candidate ""   Exa 1 2 2 mple"" == ""-Exa_1_2_2_mple"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_141,azb_Arab,hs,"--اؤرنکلر: --- اوْنلاردان بیری اوْلمالی دیر: ['txt', 'exe', 'dll'] --لاتین الیفباسی ('a'-'z' و 'A'-'Z'). --- اوسته کی اویونجو حرفی بوش اولمامالی دیر و او حرفی دن باشلاییر.--- فایلین آدیندا هئچ بیر نقطه یوخدور.--- فایلین آدیندا اوچ دان چوخ رقمی اولمامالی دیر ('0'-'9'). --بو یئرلرده:--بیر فایلین آدی یالنیز و فقط او زامان اعتبارلی ساییلار کی، آشاغیداکی شرطلرین هامیسی --""بله"" اگر فایلین آدی یئرلی اولسا و ""نه"" یئرینه قاییدیب. --٠.فاکتوري ايجاد کن که يک رشته اي که اسم يک فايل رو نمايندگي ميکنه و ٠.فاکتوري ايجاد کن که اسم يک فايل رو نمايندگي ميکنه و ٠.فاکتوري ايجاد کن که اسم يک فايل رو نمايندگي ميکنه و ٠.فاکتوري ايجاد کن که اسم يک فايل رو نمايندگي ميکنه و ٠.فاکتوري ايجاد کن که اسم يک فايل رو نمايندگي ميکنه--  >>> fileNameCheck ""example.txt""
--  ""Yes""
--  >>> fileNameCheck ""1example.dll""
--  ""No""
fileNameCheck :: String -> String
fileNameCheck file_name =","import Data.Char (isDigit, isLetter)

fileNameCheck :: String -> String
fileNameCheck file_name 
  | countDots /= 1 = ""No""
  | length digits > 3 = ""No""
  | null beforeDot || not (isLetter (head beforeDot)) = ""No""
  | afterDot `notElem` validExtensions = ""No""
  | otherwise = ""Yes""
  where 
    (beforeDot, afterDot) = span (/= '.') file_name
    countDots = length $ filter (== '.') file_name
    digits = filter isDigit file_name
    validExtensions = [""txt"", ""exe"", ""dll""]
    afterDot = if null dotAndAfter then """" else tail dotAndAfter
    dotAndAfter = dropWhile (/= '.') file_name","
main :: IO ()
main = do
  let candidate = fileNameCheck
  if candidate ""example.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1example.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s1sdf3.asd"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""K.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""MY16FILE3.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""His12FILE94.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_Y.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""?aREYA.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""/this_is_valid.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.wow"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txtexe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""#this2_i4s_5valid.ten"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""@this1_is6_valid.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_12valid.6exe4.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""all.exe.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_No.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""Is3youfault.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""no_one#knows.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1I563_Yes3.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_Yes3.txtt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final..txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final132"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_f4indsartal132."" == ""No"" then pure () else error ""assertion failed""
  if candidate "".txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s."" == ""No"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_142,azb_Arab,hs,"--اؤرنکلر: --فاکتئرین یازیلاری ایسه 3 و 4 نین چوخونلوغو اولمایان یازیلاری یازیلیب.--چوخو 3 و اگر اونون ایندئسی 4 نین چوخو اولماسا و 3 نین چوخو اولماسا، اینتئرئرین گئرئشینی کوب ائده جک.--بو فاکتئر، ساییلارین بیر سیراسی آلاجاق. سیراسینداکی بوتون یازیلار اوچون، فاکتئرین ایندیکسی a  اولسا، ساییلارین یازیسی نین کوارتاسی اوْلوناجاق.--""--  >>> lst
--  [1,2,3]
--  >>> lst
--  []
--  >>> lst
--  [(-1),(-5),2,(-1),(-5)]
sumSquares :: [Int] -> Int
sumSquares lst =","sumSquares :: [Int] -> Int
sumSquares lst = sum $ zipWith transform [0..] lst
  where
    transform idx x
      | idx `mod` 3 == 0 = x * x
      | idx `mod` 4 == 0 = x * x * x
      | otherwise        = x","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1,2,3] == 6 then pure () else error ""assertion failed""
  if candidate [1,4,9] == 14 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error ""assertion failed""
  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error ""assertion failed""
  if candidate [0] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error ""assertion failed""
  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error ""assertion failed""
  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error ""assertion failed""
  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error ""assertion failed""
  pure ()"
HumanEval_143,azb_Arab,hs,"--مثال 1:--یئنی سیرا کلمه لرین ترتیبینی اوّلکی سیرا کلمه لرین ترتیبینه اویغونلاشدیرماق لازیمدیر.--بو اوزانلارین بیرینجی ساییلاریدیر، --و اوّلکي جومله دن سؤزجوکلرين اولدوغو بير سيراني قايديرماليسينيز،--جمله ده بیر نئچه کلمه وار کی، بیر بوشلوقلا آیریلیبلار، --٠: بير جمله ني تمثيل ائدن بير سيرالار وريلير، ٠:--  >>> wordsInSentence ""This is a test""
--  ""is""
--  Example 2:
--  >>> wordsInSentence ""lets go for swimming""
--  ""go for""
--  Constraints:
--  * 1 <= len(sentence) <= 100
--  * sentence contains only letters
wordsInSentence :: String -> String
wordsInSentence sentence =","import Data.List (intercalate)

wordsInSentence :: String -> String
wordsInSentence sentence = intercalate "" "" $ filter (isPrime . length) (words sentence)

isPrime :: Int -> Bool
isPrime n | n < 2     = False
          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = wordsInSentence
  if candidate ""This is a test"" == ""is"" then pure () else error ""assertion failed""
  if candidate ""lets go for swimming"" == ""go for"" then pure () else error ""assertion failed""
  if candidate ""there is no place available here"" == ""there is no place"" then pure () else error ""assertion failed""
  if candidate ""Hi I am Hussein"" == ""Hi am Hussein"" then pure () else error ""assertion failed""
  if candidate ""go for it"" == ""go for it"" then pure () else error ""assertion failed""
  if candidate ""here"" == """" then pure () else error ""assertion failed""
  if candidate ""here is"" == ""is"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_144,azb_Arab,hs,"--فرض ائده بیلرسیز کی، x و n، اعتبارلی کسریلر دیرلر و 0، ممیز اولاراق یوخدور.--<سئچمه>/<مقام> هاردان سئچمه و مقام هردویو مثبت بوتون ساییلاردیر.--x و n هر ایکیسی ده کسری نین سِره لی تمثیل لری دیر و آشاغیداکی فورماتا مالیک دیرلر:--x * n. اگر x * n ساري سايي اولورسا و False  اولسا، فانکشن True-ي قايتارير.--سیزین ایشینیز بیر فؤنکشن یئرینه یئتیرمک دیر کی بو ایفاده نی ساده لشدیره بیلر.--  >>> simplify ""1/5"" ""5/1""
--  True
--  >>> simplify ""1/6"" ""2/1""
--  False
--  >>> simplify ""7/10"" ""10/2""
--  False
simplify :: String -> String -> Bool
simplify x n =","import Data.Ratio (denominator, numerator, (%))

simplify :: String -> String -> Bool
simplify x n =
  let (xNum, xDen) = toFraction x
      (nNum, nDen) = toFraction n
      result = (xNum * nNum) % (xDen * nDen)
  in denominator result == 1

toFraction :: String -> (Integer, Integer)
toFraction s =
  let (numStr, _:denStr) = break (=='/') s
  in (read numStr, read denStr)","
main :: IO ()
main = do
  let candidate = simplify
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/6"" ""2/1"" == False then pure () else error ""assertion failed""
  if candidate ""5/1"" ""3/1"" == True then pure () else error ""assertion failed""
  if candidate ""7/10"" ""10/2"" == False then pure () else error ""assertion failed""
  if candidate ""2/10"" ""50/10"" == True then pure () else error ""assertion failed""
  if candidate ""7/2"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""11/6"" ""6/1"" == True then pure () else error ""assertion failed""
  if candidate ""2/3"" ""5/2"" == False then pure () else error ""assertion failed""
  if candidate ""5/2"" ""3/5"" == False then pure () else error ""assertion failed""
  if candidate ""2/4"" ""8/4"" == True then pure () else error ""assertion failed""
  if candidate ""2/4"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""1/5"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_145,azb_Arab,hs,"--مثلن: --اونلاری اصلی لیستده کی ایندئکسه گؤره یئرلشدیریرلر.--ياداشت: اگر نئچه ايلتيم وار کي، اونلارين سيفرلرينين موکادله سي برابردير،--آرتیق آرتیق، عددی آرتیق.--٠: بير فؤنکشن يازين کي، بوتون ساييلارين بورداکي سيراسي ايله ترتيبلانسين ٠:--  >>> orderByPoints [1,11,(-1),(-11),(-12)]
--  [(-1),(-11),1,(-12),11]
--  >>> orderByPoints []
--  []
orderByPoints :: [Int] -> [Int]
orderByPoints nums =","import Data.List (sortBy)
import Data.Function (on)

orderByPoints :: [Int] -> [Int]
orderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums
  where
    sumOfDigits :: Int -> Int
    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)
    
    indexedNums :: [(Int, Int)]
    indexedNums = zip (map sumOfDigits nums) nums","
main :: IO ()
main = do
  let candidate = orderByPoints
  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error ""assertion failed""
  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error ""assertion failed""
  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_146,azb_Arab,hs,"--مثلن: --بیر سایی نین ایلک و سونونجو رقمی بیرجه دیر (1, 3, 5, 7, 9).--لیستده کی ۱۰-دان چوخ اولان عنصرلرین ساییسی و هر ایکیسی --٠ فؤنکشن يازين کي، گئرئش و دؤنده رمه سي اوچون ساييلارين بير سيراسي قبول ائدسئن ٠--  >>> specialfilter [15,(-73),14,(-15)]
--  1
--  >>> specialfilter [33,(-2),(-3),45,21,109]
--  2
specialfilter :: [Int] -> Int
specialfilter nums =","specialfilter :: [Int] -> Int
specialfilter nums = length $ filter isSpecial nums
  where
    isSpecial n = n > 10 && isOddFirstAndLast (abs n)

    isOddFirstAndLast :: Int -> Bool
    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit
      where
        xStr = show x
        firstDigit = head xStr
        lastDigit = last xStr

    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""","
main :: IO ()
main = do
  let candidate = specialfilter
  if candidate [5,(-2),1,(-5)] == 0 then pure () else error ""assertion failed""
  if candidate [15,(-73),14,(-15)] == 1 then pure () else error ""assertion failed""
  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error ""assertion failed""
  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error ""assertion failed""
  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_147,azb_Arab,hs,"--اؤرنک:--و a[i] + a[j] + a[k] 3'ون قاتیدیر. --a-نین اوچ قاتلی سایی (a[i], a[j], a[k]) -ی قایتاریر.--هر i (1 ≤ i ≤ n) اوچون a[i] = i * i - i + 1 --٠: بير مثبت نينگ سايي سي نينگ اولماسي اوچون، بير نينگ اوزونلوغو نينگ سايي سي نينگ بير سيراسي نينگ اولماسي لازيمدير.--  >>> getMaxTriples 5
--  1
--  Explanation: 
--  a = [1, 3, 7, 13, 21]
--  The only valid triple is (1, 7, 13).
getMaxTriples :: Int -> Int
getMaxTriples n =","getMaxTriples :: Int -> Int
getMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]
  where
    a = [i * i - i + 1 | i <- [1..n]]","
main :: IO ()
main = do
  let candidate = getMaxTriples
  if candidate 5 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 4 then pure () else error ""assertion failed""
  if candidate 10 == 36 then pure () else error ""assertion failed""
  if candidate 100 == 53361 then pure () else error ""assertion failed""
  pure ()"
HumanEval_149,azb_Arab,hs,"--مثلن: --هر سؤزون اوزونلوغو برابر اولاجاغینی دوشونورسونوز.--فانکشنین یئرینه یئرلشدیریلن نؤمره ده بیر سیرا سیلاحلار قایتارمالی دیر.--اگر ایکی کلمه نین اوزونلوغو بیر اولدوغو اولسا، آلفبئتا ترتیبینه لیستی ترتیبله --بو قاعده یه گؤره سئچیلن لیستین یئرینه یئتیرمه سی گرکدیر.--لیستین دوزولمه سی هر بیر سؤزون اوزونلوغونا گؤره آرتمالیدیر، و سیز --و اوندا دوپليکاتلار دا اولا بيلر.--لیست همیشه بیر سیرا لیست دیر و هئچ زامان بیر سایی لی لیست دئییل.--و نتیجه لی لیستین ترتیبینی یئتیریر، --اوْنلاردان اوْنلاشماسین اوْلان اوْنلاشمالارین سئللری آرادان آپاریر، --٠ فانکشن بنویسید که لیست رشته ای رو به عنوان پارامتر قبول کنه، --  >>> listSort [""aa"",""a"",""aaa""]
--  [""aa""]
--  >>> listSort [""ab"",""a"",""aaa"",""cd""]
--  [""ab"",""cd""]
sortedListSum :: [String] -> [String]
sortedListSum lst =","sortedListSum :: [String] -> [String]
sortedListSum lst = sortBy compareStrings (filter evenLength lst)
  where
    evenLength s = even (length s)
    compareStrings s1 s2
      | length s1 == length s2 = compare s1 s2
      | otherwise = compare (length s1) (length s2)","
main :: IO ()
main = do
  let candidate = sortedListSum
  if candidate [""aa"",""a"",""aaa""] == [""aa""] then pure () else error ""assertion failed""
  if candidate [""school"",""AI"",""asdf"",""b""] == [""AI"",""asdf"",""school""] then pure () else error ""assertion failed""
  if candidate [""d"",""b"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""d"",""dcba"",""abcd"",""a""] == [""abcd"",""dcba""] then pure () else error ""assertion failed""
  if candidate [""AI"",""ai"",""au""] == [""AI"",""ai"",""au""] then pure () else error ""assertion failed""
  if candidate [""a"",""b"",""b"",""c"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""aaaa"",""bbbb"",""dd"",""cc""] == [""cc"",""dd"",""aaaa"",""bbbb""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_150,azb_Arab,hs,"--اؤرنکلر: --بير اصلي سايي و گرک y'ين قئيمتئني قايتارسين.--ساده بیر پروقرام کی، اگر n  اولسا، x-ین قئیمتینی قایتاراجاق.--  >>> xOrY 7 34 12
--  34
--  >>> xOrY 15 8 5
--  5
xOrY :: Int -> Int -> Int -> Int
xOrY n x y =","xOrY :: Int -> Int -> Int -> Int
xOrY n x y = if isPrime n then x else y

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = xOrY
  if candidate 7 34 12 == 34 then pure () else error ""assertion failed""
  if candidate 15 8 5 == 5 then pure () else error ""assertion failed""
  if candidate 3 33 5212 == 33 then pure () else error ""assertion failed""
  if candidate 1259 3 52 == 3 then pure () else error ""assertion failed""
  if candidate 7919 (-1) 12 == (-1) then pure () else error ""assertion failed""
  if candidate 3609 1245 583 == 583 then pure () else error ""assertion failed""
  if candidate 91 56 129 == 129 then pure () else error ""assertion failed""
  if candidate 6 34 1234 == 1234 then pure () else error ""assertion failed""
  if candidate 1 2 0 == 0 then pure () else error ""assertion failed""
  if candidate 2 2 0 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_151,azb_Arab,hs,"--سئوگی لی ساییلارین ساییلارینی آلما.--٠:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:۰۰:--  >>> doubleTheDifference [1,3,2,0]
--  10
--  >>> doubleTheDifference [(-1),(-2),0]
--  0
--  >>> doubleTheDifference [9,(-2)]
--  81
--  >>> doubleTheDifference [0]
--  0
--  If the input list is empty, return 0.
doubleTheDifference :: [Float] -> Int
doubleTheDifference lst =","doubleTheDifference :: [Float] -> Int
doubleTheDifference lst = 
    sum [x * x | x <- map round lst, x > 0, odd x]","
main :: IO ()
main = do
  let candidate = doubleTheDifference
  if candidate [.0] == 0 then pure () else error ""assertion failed""
  if candidate [5.0,4.0] == 25 then pure () else error ""assertion failed""
  if candidate [0.1,0.2,0.3] == 0 then pure () else error ""assertion failed""
  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error ""assertion failed""
  if candidate [0.2,3.0,5.0] == 34 then pure () else error ""assertion failed""
  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error ""assertion failed""
  pure ()"
HumanEval_152,azb_Arab,hs,"--اؤرنک: --قئيدين سايي 0 اولور و اولماسا، قئيدين قئيد و نتيجه آراسینداکي مطلق فرقدير.--هر دوشونجه نين نه قدر اوزاق اولدوغونو گؤسترن، همن اوزونلوغو اولان بير سيرا قايتارير.--هر ایندیکسین بیر تطبیقی گؤسترن برابر اوزونلوغو اولان نمره لر و قیله لرین ایکی لیستی سیزه وئریلیر.--سیزین ایشینیز بیر نفرین نئچه یاریشین نتیجه سینی دوزگون قیلمه سینی تعیین ائتمکدیر.--بو، هر شيدن اؤنجه، قئيد ائديلمه سي و موقاييسه ائديلمه سي لازيمدير.--اوشاغین او آنکی دوشونجه لری و حیس لری--منجه هاميميز او حيسيني خاطيرلاييريق کي، نئچه ايل گؤزله نيلن بير شيئن نتيجه سي--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]
--  [0,0,0,0,3,3]
--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]
--  [4,4,1,0,0,6]
compare :: [Int] -> [Int] -> [Int]
compare game guess =","compare :: [Int] -> [Int] -> [Int]
compare game guess = zipWith (\g s -> abs (g - s)) game guess","
main :: IO ()
main = do
  let candidate = compare
  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error ""assertion failed""
  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error ""assertion failed""
  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error ""assertion failed""
  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_153,azb_Arab,hs,"--اؤرنک: --(قویومو - ۱)--return ""Slices.SErviNGSliCes"" چونکي ""SErviNGSliCes"" ان گوجلو اوزولمه دیر --['SERVINGSliCes', 'Cheese', 'StuFfed'] اوندا گرک --مثلاً، اگر ""Slices"" کلاس و --اوّلجه دن گلن آليش-چاليشي سئچين.--اگر ايكي يا داها چوخ يوکونلوگونون گوجونو برابر ائده بيلرسينيز،--format: ClassName.StrongestExtensionName. --لاپ گوجلو اوزولمه نی تاپین و بو اوزولمه ده بیر سیرا قاییتین .--ايشله ديله نين آدينا گؤره، گوج CAP-SM کسري ايله وئريلير. --حرفلرین آدیندا، و SM حرفلرین ساییسی اولمالیدیر.--بو اوزاتما نین گوجلوگو آشاغیداکی کیمی دیر: CAP بؤیوک حرفین سایی اولسون --بو اوزولمه لر، او کلاسین علاوه کلاسلاری یوکله مک اوچون ایستیفاده اولونور.--سیزه بیر کلاسین آدی (سیر) و بیر یوللاندیرما لیستی وئریله جک.--  >>> strongestExtension ""my_class"" [""AA"",""Be"",""CC""]
--  ""my_class.AA""
strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions =","strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions = class_name ++ ""."" ++ strongestExt
  where
    calculateStrength :: String -> Int
    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)
    
    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)
    
    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)
    maxStrength ext1 ext2
      | snd ext1 > snd ext2 = ext1
      | otherwise           = ext2","
main :: IO ()
main = do
  let candidate = strongestExtension
  if candidate ""Watashi"" [""tEN"",""niNE"",""eIGHt8OKe""] == ""Watashi.eIGHt8OKe"" then pure () else error ""assertion failed""
  if candidate ""Boku123"" [""nani"",""NazeDa"",""YEs.WeCaNe"",""32145tggg""] == ""Boku123.YEs.WeCaNe"" then pure () else error ""assertion failed""
  if candidate ""__YESIMHERE"" [""t"",""eMptY"",""nothing"",""zeR00"",""NuLl__"",""123NoooneB321""] == ""__YESIMHERE.NuLl__"" then pure () else error ""assertion failed""
  if candidate ""K"" [""Ta"",""TAR"",""t234An"",""cosSo""] == ""K.TAR"" then pure () else error ""assertion failed""
  if candidate ""__HAHA"" [""Tab"",""123"",""781345"",""-_-""] == ""__HAHA.123"" then pure () else error ""assertion failed""
  if candidate ""YameRore"" [""HhAas"",""okIWILL123"",""WorkOut"",""Fails"",""-_-""] == ""YameRore.okIWILL123"" then pure () else error ""assertion failed""
  if candidate ""finNNalLLly"" [""Die"",""NowW"",""Wow"",""WoW""] == ""finNNalLLly.WoW"" then pure () else error ""assertion failed""
  if candidate ""_"" [""Bb"",""91245""] == ""_.Bb"" then pure () else error ""assertion failed""
  if candidate ""Sp"" [""671235"",""Bb""] == ""Sp.671235"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_154,azb_Arab,hs,"--""True""ي قايديرسان اگر اوّلکي کلمه نين آلت ساريسي اوْلسا.--  >>> cycpatternCheck ""abcd"" ""abd""
--  False
--  >>> cycpatternCheck ""hello"" ""ell""
--  True
--  >>> cycpatternCheck ""whassup"" ""psus""
--  False
--  >>> cycpatternCheck ""abab"" ""baa""
--  True
--  >>> cycpatternCheck ""efef"" ""eeff""
--  False
--  >>> cycpatternCheck ""himenss"" ""simen""
--  True
cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b =","cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b = any (`isInfixOf` a) rotations
  where
    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","
main :: IO ()
main = do
  let candidate = cycpatternCheck
  if candidate ""xyzw"" ""xyw"" == False then pure () else error ""assertion failed""
  if candidate ""yello"" ""ell"" == True then pure () else error ""assertion failed""
  if candidate ""whattup"" ""ptut"" == False then pure () else error ""assertion failed""
  if candidate ""efef"" ""fee"" == True then pure () else error ""assertion failed""
  if candidate ""abab"" ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""winemtt"" ""tinem"" == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_155,azb_Arab,hs,"--اؤرنک: --٠: بير تام سايي وئريله رک، موقايئعه لي اولاراق، برابر و بيردفعه سيکريلري اولان بير توپل قاييدير.--  >>> evenOddCount (-12)
--  (1, 1)
--  >>> evenOddCount 123
--  (1, 2)
evenOddCount :: Int -> (Int, Int)
evenOddCount num =","evenOddCount :: Int -> (Int, Int)
evenOddCount num = (length evens, length odds)
  where
    digits = map (read . (:[])) . show . abs $ num
    evens = filter even digits
    odds  = filter odd digits","
main :: IO ()
main = do
  let candidate = evenOddCount
  if candidate 7 == (0, 1) then pure () else error ""assertion failed""
  if candidate (-78) == (1, 1) then pure () else error ""assertion failed""
  if candidate 3452 == (2, 2) then pure () else error ""assertion failed""
  if candidate 346211 == (3, 3) then pure () else error ""assertion failed""
  if candidate (-345821) == (3, 3) then pure () else error ""assertion failed""
  if candidate (-2) == (1, 0) then pure () else error ""assertion failed""
  if candidate (-45347) == (2, 3) then pure () else error ""assertion failed""
  if candidate 0 == (1, 0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_156,azb_Arab,hs,"--اؤرنکلر: --محدودلاشما: 1 <= num <= 1000 --و اونو بير آز يازيب قايتارين.--٠ مثبت بير عدد و اونون رومن عددي مساوييني بير سيرال اولاراق آلين، ٠--  >>> intToMiniRoman 19
--  ""xix""
--  >>> intToMiniRoman 152
--  ""clii""
--  >>> intToMiniRoman 426
--  ""cdxxvi""
intToMiniRoman :: Int -> String
intToMiniRoman number =","intToMiniRoman :: Int -> String
intToMiniRoman number = concatMap (replicateSymbol number) romanNumerals
  where
    romanNumerals = [(1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
                     (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
                     (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""), (1, ""i"")]
    
    replicateSymbol :: Int -> (Int, String) -> String
    replicateSymbol n (value, symbol)
      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)
      | otherwise = """"","
main :: IO ()
main = do
  let candidate = intToMiniRoman
  if candidate 19 == ""xix"" then pure () else error ""assertion failed""
  if candidate 152 == ""clii"" then pure () else error ""assertion failed""
  if candidate 251 == ""ccli"" then pure () else error ""assertion failed""
  if candidate 426 == ""cdxxvi"" then pure () else error ""assertion failed""
  if candidate 500 == ""d"" then pure () else error ""assertion failed""
  if candidate 1 == ""i"" then pure () else error ""assertion failed""
  if candidate 4 == ""iv"" then pure () else error ""assertion failed""
  if candidate 43 == ""xliii"" then pure () else error ""assertion failed""
  if candidate 90 == ""xc"" then pure () else error ""assertion failed""
  if candidate 94 == ""xciv"" then pure () else error ""assertion failed""
  if candidate 532 == ""dxxxii"" then pure () else error ""assertion failed""
  if candidate 900 == ""cm"" then pure () else error ""assertion failed""
  if candidate 994 == ""cmxciv"" then pure () else error ""assertion failed""
  if candidate 1000 == ""m"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_157,azb_Arab,hs,"--اؤرنک: --90 درجه.--مثلث دوزگون بويونلو، مثلث دير کي، اونون بير بويو دوزگون بويونلو و يا --طرفلری دوزگون بوجاقلی مثلث تشکیل ائدیر، باشقا یولدا یالان.--""True""ي بررسي كنيم اگر--  >>> rightAngleTriangle 3 4 5
--  True
--  >>> rightAngleTriangle 1 2 3
--  False
rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c =","rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c = 
    let [x, y, z] = sort [a, b, c]
    in x^2 + y^2 == z^2
    where sort = Data.List.sort","
main :: IO ()
main = do
  let candidate = rightAngleTriangle
  if candidate 3 4 5 == True then pure () else error ""assertion failed""
  if candidate 1 2 3 == False then pure () else error ""assertion failed""
  if candidate 10 6 8 == True then pure () else error ""assertion failed""
  if candidate 2 2 2 == False then pure () else error ""assertion failed""
  if candidate 7 24 25 == True then pure () else error ""assertion failed""
  if candidate 10 5 7 == False then pure () else error ""assertion failed""
  if candidate 5 12 13 == True then pure () else error ""assertion failed""
  if candidate 15 8 17 == True then pure () else error ""assertion failed""
  if candidate 48 55 73 == True then pure () else error ""assertion failed""
  if candidate 1 1 1 == False then pure () else error ""assertion failed""
  if candidate 2 2 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_158,azb_Arab,hs,"--حرفلر، سؤزلوک نؤوبه سینده ایلک گلن حرفی قایتار. --اگر چوخلو سيرلرين ان چوخو بير حركته مالئک اولسا--لیستده موختلیف سؤزلر وار.--٠ فانکشن بنویسید که لیست رشته ای قبول کنه ٠--  >>> findMax [""name"",""of"",""string""]
--  ""string""
--  >>> findMax [""name"",""enam"",""game""]
--  ""enam""
--  >>> findMax [""aaaaaaa"",""bb"",""cc""]
--  ""aaaaaaa""
findMax :: [String] -> String
findMax words =","import Data.List (nub, sort)

findMax :: [String] -> String
findMax words = 
    head . sort . map snd . filter (\(n, _) -> n == maxUnique) $ wordUniquePairs
  where
    wordUniquePairs = [(length . nub $ word, word) | word <- words]
    maxUnique = maximum $ map fst wordUniquePairs","
main :: IO ()
main = do
  let candidate = findMax
  if candidate [""name"",""of"",""string""] == ""string"" then pure () else error ""assertion failed""
  if candidate [""name"",""enam"",""game""] == ""enam"" then pure () else error ""assertion failed""
  if candidate [""aaaaaaa"",""bb"",""cc""] == ""aaaaaaa"" then pure () else error ""assertion failed""
  if candidate [""abc"",""cba""] == ""abc"" then pure () else error ""assertion failed""
  if candidate [""play"",""this"",""game"",""of"",""footbott""] == ""footbott"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""gonna"",""rock""] == ""gonna"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""a"",""mad"",""nation""] == ""nation"" then pure () else error ""assertion failed""
  if candidate [""this"",""is"",""a"",""prrk""] == ""this"" then pure () else error ""assertion failed""
  if candidate [""b""] == ""b"" then pure () else error ""assertion failed""
  if candidate [""play"",""play"",""play""] == ""play"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_159,azb_Arab,hs,"--اؤرنک: --اگر قالميش گئجتکلرين سايي چاتميرسا، قالميش گئجتکلرين هاميسيني يئيئب، آنجاق گئنه ده آج قالاجاقسينيز.--[ يئردن سونرا قالان گوزل لرين سايي ] --[ يئيندن سونرا يئيديگينيز گوزلليکلرين سايي]--آمما ایندی گونده لیک یئمک لری تاملاماق اوچون داها چوخ گوزئیله یمه لیسن.--آج بیر خرگوشون، و ایندیکی قدر هئیئی یئییبسن،--  >>> eat 5 6 10
--  [11,4]
--  >>> eat 4 8 9
--  [12,1]
--  >>> eat 1 10 10
--  [11,0]
--  >>> eat 2 11 5
--  [7,0]
--  Variables:
--  @number : integer
--  the number of carrots that you have eaten.
--  @need : integer
--  the number of carrots that you need to eat.
--  @remaining : integer
--  the number of remaining carrots thet exist in stock
--  Constrain:
--  * 0 <= number <= 1000
--  * 0 <= need <= 1000
--  * 0 <= remaining <= 1000
--  Have fun :)
eat :: Int -> Int -> Int -> [Int]
eat number need remaining =","eat :: Int -> Int -> Int -> [Int]
eat number need remaining
  | remaining >= need = [number + need, remaining - need]
  | otherwise = [number + remaining, 0]","
main :: IO ()
main = do
  let candidate = eat
  if candidate 5 6 10 == [11,4] then pure () else error ""assertion failed""
  if candidate 4 8 9 == [12,1] then pure () else error ""assertion failed""
  if candidate 1 10 10 == [11,0] then pure () else error ""assertion failed""
  if candidate 2 11 5 == [7,0] then pure () else error ""assertion failed""
  if candidate 4 5 7 == [9,2] then pure () else error ""assertion failed""
  if candidate 4 5 1 == [5,0] then pure () else error ""assertion failed""
  pure ()"
HumanEval_160,azb_Arab,hs,"--اوپراتورلار لیستینده ان آز بیر اوپراتور وار، اوپراتورلار لیستینده ان آز ایکی اوپراتور وار.--اوپئراند، منفی اولمایان بوتون ساییلارین بیر سیراسی دیر.--اوپراتورلارین لیستینین اوزونلوغو اوپراتورلارین لیستینین اوزونلوغو آلینما بیرینه برابر دیر.--يادداشت:--=> نتيجه = 9 --نتیجه = 2 + 3 * 4 - 5 --list = [2, 3, 4, 5] --آپراتور['+', '*', '-'] --اؤرنک: --(**) --طبقه بؤلمه سی ( // ) --ضرب (*) --کسمه (- ) --آرتيرما (+) --اساس الجبر عملیاتلاری: --بو ایفاده نی یازین و بو ایفاده نین قئیدینی قایتارین.--ایکی سی بیر سیرا ساییلارین لیستی دیر.--اوّلکي سيستمده اساس جبري عملياتلار وار و اوّلکي سيستمده جبر عملياتلاري وار.doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand =","doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand = evaluate operand operator
  where
    evaluate [x] [] = x
    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops
      where
        result = applyOperation op x y

    applyOperation ""+"" a b = a + b
    applyOperation ""-"" a b = a - b
    applyOperation ""*"" a b = a * b
    applyOperation ""//"" a b = a `div` b
    applyOperation ""**"" a b = a ^ b
    applyOperation _ _ _ = error ""Unsupported operation""","
main :: IO ()
main = do
  let candidate = doAlgebra
  if candidate [""**"",""*"",""+""] [2,3,4,5] == 37 then pure () else error ""assertion failed""
  if candidate [""+"",""*"",""-""] [2,3,4,5] == 9 then pure () else error ""assertion failed""
  if candidate [""//"",""*""] [7,3,4] == 8 then pure () else error ""assertion failed""
  pure ()"
HumanEval_161,azb_Arab,hs,"--اؤرنکلر --فانکشن نتیجه سینین سسلینتی سینی قایتارمالی دیر.--اگر بو حرفلرین هئچ بیری سی اولماسا، اونو یئرینه یئتیریر.--يوخسا، اولدوقجا قالسين.--اگر s[i] حرف اولسا، اونون حرفی آشاغی دان یوخارییا و یا عکسینه دؤنور، --٠: آخه يه رشته اي داده شده--  >>> solve ""1234""
--  ""4321""
--  >>> solve ""ab""
--  ""AB""
--  >>> solve ""#a@C""
--  ""#A@c""
solve :: String -> String
solve s =","solve :: String -> String
solve s
  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s
  | otherwise = reverse s
  where
    toggleCase c
      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char
      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char
      | otherwise = c","
main :: IO ()
main = do
  let candidate = solve
  if candidate ""AsDf"" == ""aSdF"" then pure () else error ""assertion failed""
  if candidate ""1234"" == ""4321"" then pure () else error ""assertion failed""
  if candidate ""ab"" == ""AB"" then pure () else error ""assertion failed""
  if candidate ""#a@C"" == ""#A@c"" then pure () else error ""assertion failed""
  if candidate ""#AsdfW^45"" == ""#aSDFw^45"" then pure () else error ""assertion failed""
  if candidate ""#6@2"" == ""2@6#"" then pure () else error ""assertion failed""
  if candidate ""#$a^D"" == ""#$A^d"" then pure () else error ""assertion failed""
  if candidate ""#ccc"" == ""#CCC"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_162,azb_Arab,hs,"--اگر 'text' بوش بیر سیردیر، Nothing قایتار. --٠ ""text"" بير سير وئريلن، اونون md5 هش مساوي سيريني قايتارين. ٠--  >>> stringToMd5 ""Hello world""
--  Just (""3e25960a79dbc69b674cd4ec67a72c62"")
stringToMd5 :: String -> Maybe String
stringToMd5 text =","import qualified Data.ByteString.Char8 as C
import qualified Data.Digest.Pure.MD5 as MD5

stringToMd5 :: String -> Maybe String
stringToMd5 text
  | null text = Nothing
  | otherwise = Just $ show $ MD5.md5 $ C.pack text","
main :: IO ()
main = do
  let candidate = stringToMd5
  if candidate ""Hello world"" == Just (""3e25960a79dbc69b674cd4ec67a72c62"") then pure () else error ""assertion failed""
  if candidate """" == Just (Nothing) then pure () else error ""assertion failed""
  if candidate ""A B C"" == Just (""0ef78513b0cb8cef12743f5aeb35f888"") then pure () else error ""assertion failed""
  if candidate ""password"" == Just (""5f4dcc3b5aa765d61d8327deb882cf99"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_163,azb_Arab,hs,"--مثلن: --و ب، آرتماسیندا.--a و b، a-دن b-ه قدر اولان عددلرین بیرینی قاییت.--  >>> generateIntegers 2 8
--  [2,4,6,8]
--  >>> generateIntegers 8 2
--  [2,4,6,8]
--  >>> generateIntegers 10 14
--  []
generateIntegers :: Int -> Int -> [Int]
generateIntegers a b =","generateIntegers :: Int -> Int -> [Int]
generateIntegers a b = filter even [min a b .. max a b]","
main :: IO ()
main = do
  let candidate = generateIntegers
  if candidate 2 10 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 10 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 132 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 17 89 == [] then pure () else error ""assertion failed""
  pure ()"
