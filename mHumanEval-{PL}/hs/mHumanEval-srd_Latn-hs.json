[{"task_id":"HumanEval_0","nl":"srd_Latn","pl":"hs","prompt":"--dadu lìmite. --Proas si in una lista dada de nùmeros, bi sunt duos nùmeros prus a curtzu s'unu de s'àteru de --  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =","canonical_solution":"hasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold = any (\\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a \/= b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_1","nl":"srd_Latn","pl":"hs","prompt":"--Ignorare sos ispàtzios in sa cadena de intrada.--Grupos separados sunt equilibrados (cada brace abertu est serradu in manera adeguada) e non annidados s'unu in intro de s'àteru --ispartzire cussos grupos in cadenas separadas e torrare sa lista de cussos. --Sa funtzione est un'istringa chi cuntenet grupos múltiples de parentesi annidadas.--  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =","canonical_solution":"separateParenGroups :: String -> [String]\nseparateParenGroups paren_string = go paren_string 0 [] \"\" []\n  where\n    go [] _ _ current acc = if null current then acc else acc ++ [current]\n    go (x:xs) depth stack current acc\n      | x == ' ' = go xs depth stack current acc\n      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc\n      | x == ')' =\n          let newCurrent = current ++ [x]\n              newDepth = depth - 1\n          in if newDepth == 0\n             then go xs newDepth (tail stack) \"\" (acc ++ [newCurrent])\n             else go xs newDepth (tail stack) newCurrent acc\n      | otherwise = error \"Unexpected character\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_2","nl":"srd_Latn","pl":"hs","prompt":"--Torrat sa parte detzimale de su nùmeru. --(parte sobrada semper prus pitica de 1).--e parte intreos (interu prus mannu prus piticu de su nùmeru dadu) e detzimales --∙∙ Si ddu donat unu nùmeru de puntu flutuante positivu, si podet decomponner in ∙--  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =","canonical_solution":"truncateNumber :: Float -> Float\ntruncateNumber number = number - fromIntegral (floor number)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_3","nl":"srd_Latn","pl":"hs","prompt":"--in cussu puntu sa funtzione depet torrare True. In casu contràriu depet torrare False.--zero balance. Su traballu tuo est de rilevare si in cale si siat momentu su saldo de su contu calat a suta de zero, e --☐ Si ti donat una lista de sas operatziones de depòsitu e ritiru in unu contu bancari chi cumintzat cun ☐--  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =","canonical_solution":"belowZero :: [Int] -> Bool\nbelowZero operations = any (< 0) $ scanl (+) 0 operations","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_4","nl":"srd_Latn","pl":"hs","prompt":"--MAD = mèdiu. x - x_mean. --elementu e unu puntu tzentrale (mèdia in custu casu): --Sa mèdia de s'esviatzione assoluta est sa diferèntzia mèdia assoluta intre cada unu de sos duos puntos.--in sa mèdia de custu grupu de datos. --Pro una lista dada de nùmeros de intrada, càrculas s'Eviatzione Assoluta Mèdia.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =","canonical_solution":"meanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers = sum absoluteDifferences \/ fromIntegral (length numbers)\n  where\n    mean = sum numbers \/ fromIntegral (length numbers)\n    absoluteDifferences = map (\\x -> abs (x - mean)) numbers","tests":"\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_5","nl":"srd_Latn","pl":"hs","prompt":"--☐ Inserire unu nùmeru 'delimetràriu' intre ogni duos elementos cunseguentes de sa lista de intrada ≠numbers' --  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =","canonical_solution":"intersperse :: [Int] -> Int -> [Int]\nintersperse [] _ = []\nintersperse [x] _ = [x]\nintersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_6","nl":"srd_Latn","pl":"hs","prompt":"--Es. (() (()) tenet unu màssimu de duos livellos de nidificatzione mentras ((())) tenet tres. --Pro cada unu de sos grupos, produire su livellu prus profundu de annidamentu de parèntesi. --Sos input de custa funtzione sunt una cadena chi rapresentat grupos múltiples pro parèntesi annidadas separadas dae ispàtzios.--  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =","canonical_solution":"parseNestedParens :: String -> [Int]\nparseNestedParens paren_string = map maxDepth (words paren_string)\n  where\n    maxDepth :: String -> Int\n    maxDepth = go 0 0\n      where\n        go :: Int -> Int -> String -> Int\n        go currentDepth maxDepth [] = maxDepth\n        go currentDepth maxDepth (c:cs)\n          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs\n          | c == ')'  = go (currentDepth - 1) maxDepth cs\n          | otherwise = go currentDepth maxDepth cs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_7","nl":"srd_Latn","pl":"hs","prompt":"-- Filtra una lista de intradas de cadenas solu pro cussas chi cuntenent una determinada suta-cadena --  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =","canonical_solution":"filterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring = filter (substring `isInfixOf`) strings\n  where isInfixOf = isInfixOf","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_8","nl":"srd_Latn","pl":"hs","prompt":"--Sa summa bòida depet èssere uguale a 0 e su produtu bòidu depet èssere uguale a 1. -- Pro una lista de intreos, torrat unu tuple chi est sa summa e su produtu de totu sos intreos de una lista. --  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =","canonical_solution":"sumProduct :: [Int] -> (Int, Int)\nsumProduct numbers = (sum numbers, product numbers)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_9","nl":"srd_Latn","pl":"hs","prompt":"--in sa secuèntzia.--Dae una lista dada de intreos, generare una lista de elementos màssimos agatados finas a unu momentu dadu.--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =","canonical_solution":"rollingMax :: [Int] -> [Int]\nrollingMax = scanl1 max","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_10","nl":"srd_Latn","pl":"hs","prompt":"--- Agregare a s'agabbu de sa cadena contrària de unu prefissu de cadena chi benit in antis de su suffissu palindròmicu. --- agatare su postfix prus longu de sa cadena fornida chi est unu palindromu. --S'idea de s'algoritmu est simpre: -- Agatade su palindromu prus curtzu chi cumintzat cun sa cadena fornida. --  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =","canonical_solution":"makePalindrome :: String -> String\nmakePalindrome string = string ++ reverse (take (length string - palindromeLength) string)\n  where\n    palindromeLength = longestPalindromicSuffix string\n\nlongestPalindromicSuffix :: String -> Int\nlongestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]\n\nisPalindrome :: String -> Bool\nisPalindrome s = s == reverse s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_11","nl":"srd_Latn","pl":"hs","prompt":"--Esegui sa XOR binària in custos input e torrai su resurtadu fintzas comente a una cadena. -- Input sunt duas cadenas a e b chi cunsistent petzi in 1 e 0. --  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =","canonical_solution":"stringXor :: String -> String -> String\nstringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_12","nl":"srd_Latn","pl":"hs","prompt":"--Torrat nudda in casu chi sa lista de intrada siat bòida.--Dae sa lista de sas cadenas, torrat sa prus longa. Torrat sa prima in casu de mùltipla.--  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =","canonical_solution":"longest :: [String] -> Maybe String\nlongest [] = Nothing\nlongest strings = Just $ foldl1 (\\acc x -> if length x > length acc then x else acc) strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_13","nl":"srd_Latn","pl":"hs","prompt":"--Torrat su màssimu cumunu divisore de duos intreos a e b.--  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =","canonical_solution":"greatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b\n  | b == 0    = a\n  | otherwise = greatestCommonDivisor b (a `mod` b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_14","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat sa lista de totu sos prefissos dae su prus curtzu a su prus longu de sa cadena de intrada --  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =","canonical_solution":"allPrefixes :: String -> [String]\nallPrefixes string = [take n string | n <- [1 .. length string]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_15","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat una cadena chi cuntenet nùmeros delimitados dae s'ispàtziu partinde dae 0 finas a n inclùdidu. --  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =","canonical_solution":"stringSequence :: Int -> String\nstringSequence n = unwords $ map show [0..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_16","nl":"srd_Latn","pl":"hs","prompt":"-- Si ti donat una cadena, iscoberta cantu caràteres distintos (in manera indipendente dae sa cassa) tenet --  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =","canonical_solution":"import Data.Char (toLower)\nimport Data.Set (fromList, size)\n\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string = size . fromList $ map toLower string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_17","nl":"srd_Latn","pl":"hs","prompt":"--\"Sa cosa est bella\" - nota de su cuartu, durat unu battitu.--\"O sa die\" - mesu nota, durat duas batidas.--'O' - nota intrea, durat bator batidas --Custa est una legenda:--non ùrtimu. --Su traballu tuo est de analizare custa cadena e torrare a sa lista de nùmeros intreos chi currispondent a cantu battidos faghet cada unu.-- Input de custa funtzione est una cadena chi rapresentat notas musicales in unu formadu ASCII ispetziale. --  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =","canonical_solution":"parseMusic :: String -> [Int]\nparseMusic music_string = map beats (words music_string)\n  where\n    beats \"o\" = 4\n    beats \"o|\" = 2\n    beats \".|\" = 1\n    beats _ = 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_18","nl":"srd_Latn","pl":"hs","prompt":"-- Aprovat cantu bortas una tzitatzione podet èssere agatada in sa tzitatzione originale.--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =","canonical_solution":"howManyTimes :: String -> String -> Int\nhowManyTimes string substring\n  | null substring = 0\n  | otherwise = length . filter isPrefixOfSubstring $ tails string\n  where\n    isPrefixOfSubstring = isPrefixOf substring\n    isPrefixOf :: Eq a => [a] -> [a] -> Bool\n    isPrefixOf prefix str = prefix `isPrefixOf` str","tests":"\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_19","nl":"srd_Latn","pl":"hs","prompt":"--Torrat sa cadena cun sos nùmeros ordinados dae su prus minore a su prus mannu --Sas eletziones vàlidas sunt \"zero\", \"unu\", \"duos\", \"tres\", \"bator\", \"cincu\", \"ses\", \"sete\", \"otto\" e \"nòighi\". -- Input est una cadena de numerales delimitada dae su logu dae 'zero' a 'nono'. --  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =","canonical_solution":"import Data.List (sort)\nimport Data.Maybe (fromJust)\nimport Data.Map (Map, fromList, lookup)\n\nsortNumbers :: String -> String\nsortNumbers numbers = unwords $ map snd $ sort $ map (\\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)\n  where\n    wordToNumber :: Map String Int\n    wordToNumber = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4),\n                             (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_20","nl":"srd_Latn","pl":"hs","prompt":"--àteros e los torrat in òrdine (nùmeru prus minore, nùmeru prus mannu).--☐ Si non bi sunt, si non bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt, si no bi sunt--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =","canonical_solution":"findClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)\n  where\n    sortedNumbers = sort numbers\n    minByDiff (a1, b1) (a2, b2)\n      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)\n      | otherwise = (a2, b2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_21","nl":"srd_Latn","pl":"hs","prompt":"--de manera chi su nùmeru prus piticu at a devènnere 0 e su prus mannu at a devènnere 1 -- Data una lista de nùmeros (de a su mancu duos elementos), aplicare una trasformada lineare a cussa lista, --  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =","canonical_solution":"rescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers = map (\\x -> (x - minVal) \/ range) numbers\n  where\n    minVal = minimum numbers\n    maxVal = maximum numbers\n    range = maxVal - minVal","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_23","nl":"srd_Latn","pl":"hs","prompt":"--Torrat sa longària de sa cadena dada.--  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =","canonical_solution":"strlen :: String -> Int\nstrlen string = length string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_24","nl":"srd_Latn","pl":"hs","prompt":"--Pro unu nùmeru dadu n, agatade su nùmeru prus mannu chi partzit in manera uguale n, prus minore de n.--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =","canonical_solution":"largestDivisor :: Int -> Int\nlargestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_25","nl":"srd_Latn","pl":"hs","prompt":"--Su nùmeru de intrada depet èssere uguale a su produtu de totu sos fatores.--Ogni de sos fatores diat dèpere èssere elencadu nùmeru de bortas chi currispondet a cantu bortas aparit in sa fatorizatzione.-- Torrat sa lista de sos fatores primos de unu nùmeru intreu dadu in òrdine dae su prus minore a su prus mannu. --  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =","canonical_solution":"factorize :: Int -> [Int]\nfactorize n = factorize' n 2\n  where\n    factorize' 1 _ = []\n    factorize' m f\n      | m `mod` f == 0 = f : factorize' (m `div` f) f\n      | otherwise      = factorize' m (f + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_26","nl":"srd_Latn","pl":"hs","prompt":"--Mantenet s'òrdine de sos elementos lassados uguale a su de s'intrada.-- Dae una lista de intreos, boghe totu sos elementos chi s'agatant prus de una borta. --  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =","canonical_solution":"removeDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers = filter (\\x -> count x numbers == 1) numbers\n  where\n    count x = length . filter (== x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_27","nl":"srd_Latn","pl":"hs","prompt":"-- Pro una cadena dada, imbetzes, girade sos caràteres minores in majusculas e majusculas in minores. --  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =","canonical_solution":"flipCase :: String -> String\nflipCase = map flipChar\n  where\n    flipChar c\n      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)\n      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_28","nl":"srd_Latn","pl":"hs","prompt":"-- Cuncatenare sa lista de cadenas in una sola cadena --  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =","canonical_solution":"concatenate :: [String] -> String\nconcatenate strings = concat strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_29","nl":"srd_Latn","pl":"hs","prompt":"--❑ Filtrare una lista de intradas de cadenas solu pro cussas chi cumintzant cun unu prefissu dadu.--  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =","canonical_solution":"filterByPrefix strings prefix = filter (isPrefixOf prefix) strings\n  where\n    isPrefixOf pfx str = take (length pfx) str == pfx","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_30","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat solu sos nùmeros positivos de sa lista. --  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =","canonical_solution":"getPositive :: [Int] -> [Int]\ngetPositive l = filter (> 0) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_31","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat sa balentia TRUE si unu nùmeru est primu e FALSE si no est beru. --  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =","canonical_solution":"isPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = not (any (\\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_33","nl":"srd_Latn","pl":"hs","prompt":"--a sos balores de sos indices currispondentes de l, ma ordinados.--l' est idènticu a l in sos indices chi non sunt divisìbiles pro tres, mentras sos balores suos in sos indices chi sunt divisìbiles pro tres sunt uguales --Custu sistema pigat una lista e torrat una lista de custa forma:--  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =","canonical_solution":"sortThird :: [Int] -> [Int]\nsortThird l = map selectElem indexed\n  where\n    indexed = zip [0..] l\n    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]\n    sortedThirdElems = sortedElems thirdIndicesElems\n    sortedElems = id -- or List.sort if imported\n    selectElem (i, x)\n      | i `mod` 3 == 0 = head sortedThirdElems\n      | otherwise = x\n    replaceSortedElem xs sorted = map selectElem indexed\n      where\n        replaceElem i (x:xs)\n          | i == 0 = x:xs\n          | otherwise = replaceElem (i - 1) xs\n        selectElem (i, x)\n          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)\n          | otherwise = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_34","nl":"srd_Latn","pl":"hs","prompt":"--Torrat elementos ùnicos ordinados in una lista--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =","canonical_solution":"unique :: [Int] -> [Int]\nunique l = sort $ nub l\n  where\n    -- | Remove duplicate elements from a list.\n    nub :: (Eq a) => [a] -> [a]\n    nub [] = []\n    nub (x:xs) = x : nub (filter (\/= x) xs)\n\n    -- | Sort a list of elements (using QuickSort algorithm).\n    sort :: (Ord a) => [a] -> [a]\n    sort [] = []\n    sort (x:xs) =\n      let smallerSorted = sort [a | a <- xs, a <= x]\n          biggerSorted = sort [a | a <- xs, a > x]\n      in  smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_35","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat s'elementu màssimu in sa lista. --  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =","canonical_solution":"maxElement :: [Int] -> Int\nmaxElement [] = error \"List cannot be empty\"\nmaxElement (x:xs) = maxElementHelper xs x\n  where\n    maxElementHelper [] currentMax = currentMax\n    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_36","nl":"srd_Latn","pl":"hs","prompt":"--│ Iscriet su nùmeru de bortas chi sa tzifra 7 aparesset in intreos prus minores de n chi sunt divisìbiles pro 11 o 13. │--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =","canonical_solution":"fizzBuzz :: Int -> Int\nfizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_37","nl":"srd_Latn","pl":"hs","prompt":"--a sos balores de sos indices paris de l, ma ordinados. --l' est identicu a l in sos indices disparios, mentras sos balores suos in sos indices paris sunt uguales --Custu sistema pigat una lista e torrat una lista de custa forma:--  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =","canonical_solution":"sortEven :: [Int] -> [Int]\nsortEven l = merge odds sortedEvens\n  where\n    (odds, evens) = partitionList l\n    sortedEvens = sort evens\n\n    partitionList :: [Int] -> ([Int], [Int])\n    partitionList [] = ([], [])\n    partitionList [x] = ([x], [])\n    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)\n      where\n        (xsOdds, xsEvens) = partitionList xs\n\n    merge :: [Int] -> [Int] -> [Int]\n    merge [] ys = ys\n    merge (x:xs) [] = x:xs\n    merge (x:xs) (y:ys) = x:y:merge xs ys","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_39","nl":"srd_Latn","pl":"hs","prompt":"-- prime_fib torrat su nùmeru n chi est unu nùmeru de Fibonacci e est puru primu. --  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =","canonical_solution":"primeFib :: Int -> Int\nprimeFib n = primeFibs !! (n - 1)\n  where\n    primeFibs = filter isPrime fibs\n    fibs = map fst $ iterate (\\(a, b) -> (b, a + b)) (0, 1)\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2 = False\n  | k == 2 = True\n  | even k = False\n  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]\n  where\n    upperLimit = floor . sqrt $ fromIntegral k","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_40","nl":"srd_Latn","pl":"hs","prompt":"--summa a zero, e Falsu in su contràriu. --retorna True si b' at tres elementos distintos in sa lista chi --Triple_sum_to_zero pigat una lista de intreos comente input.--  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =","canonical_solution":"triplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]\n  where\n    tails [] = []\n    tails xs@(_:xs') = xs : tails xs'","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_41","nl":"srd_Latn","pl":"hs","prompt":"--Custa funtzione produit su nùmeru de cussas collisiones. --in sa trajetòria issoro comente si non si fiant cumbàtidas.--In cada manera, sas màchinas sunt a manera infinida robustas e fortes; comente resurtadu, sighent a si mòvere.--cando una màchina chi si movet dae manca a dereta tocat una màchina chi si movet dae dereta a manca.--Totus sas màchinas si movent a sa matessi lestresa.--Sas duas partes de màchinas comintzant a èssere meda a tesu dae sa--N màchinas sunt ghiadas dae manca a dereta; in su matessi tempus, un'àteru grupu de n màchinas --❑ Imaginade una bia perfetta, una lìnia dereta a s'infinidu.carRaceCollision :: Int -> Int\ncarRaceCollision n =","canonical_solution":"carRaceCollision :: Int -> Int\ncarRaceCollision n = n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_42","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat sa lista cun sos elementos aumentados de 1. --  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =","canonical_solution":"incrList :: [Int] -> [Int]\nincrList l = map (+1) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_43","nl":"srd_Latn","pl":"hs","prompt":"--summa a zero, e Falsu in su contràriu. --retorna True si bi sunt duos elementos distintos in sa lista chi -- pairs_sum_to_zero pigat una lista de intreos comente input.--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =","canonical_solution":"pairsSumToZero :: [Int] -> Bool\npairsSumToZero l = any (\\x -> -x `elem` l) l && (length l > 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_44","nl":"srd_Latn","pl":"hs","prompt":"--sos nùmeros de base sunt prus pagu de 10.--torrat sa rapresentatzione de sa cadena a pustis de sa cunversione.-- Cambiare sa base numèrica de su nùmeru de intrada x a base. --  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =","canonical_solution":"changeBase :: Int -> Int -> String\nchangeBase x base\n  | x < base  = show x\n  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_45","nl":"srd_Latn","pl":"hs","prompt":"-- Si dat sa longària de unu ladu e s'àrea de retruca prus arta pro unu triàngulu --  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =","canonical_solution":"triangleArea :: Int -> Int -> Float\ntriangleArea a h = 0.5 * fromIntegral a * fromIntegral h","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_46","nl":"srd_Latn","pl":"hs","prompt":"--Iscriere una funtzione pro compudare in manera efitziente s'elementu n-esimu de sa filera de nùmeros fib4.--fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --Sa secuèntzia de nùmeros Fib4 est una secuèntzia sìmile a sa secuèntzia de Fibbonacci chi est definida comente sighit:--  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =","canonical_solution":"fib4 :: Int -> Int\nfib4 n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 2\n  | n == 3 = 0\n  | otherwise = iter 0 0 2 0 n\n  where\n    iter a b c d 4 = a + b + c + d\n    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_47","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat sa mediana de sos elementos de sa lista l. --  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =","canonical_solution":"median :: [Int] -> Float\nmedian l \n  | odd n     = fromIntegral $ sorted !! mid\n  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) \/ 2\n  where\n    sorted = sort l\n    n = length l\n    mid = n `div` 2\n    sort = sortBy compare","tests":"\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_48","nl":"srd_Latn","pl":"hs","prompt":"--Proastimat si sa cadena dada est unu palindromu.--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =","canonical_solution":"isPalindrome :: String -> Bool\nisPalindrome text = text == reverse text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_49","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat 2^n modulo p (siat atentu a sos nùmeros). --  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =","canonical_solution":"modp :: Int -> Int -> Int\nmodp n p = powMod 2 n p\n\npowMod :: Int -> Int -> Int -> Int\npowMod base exp modulus\n  | modulus == 1 = 0\n  | exp == 0     = 1\n  | exp == 1     = base `mod` modulus\n  | otherwise    = if odd exp\n                   then (base * halfExp * halfExp) `mod` modulus\n                   else (halfExp * halfExp) `mod` modulus\n  where\n    halfExp = powMod base (exp `div` 2) modulus","tests":"\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_51","nl":"srd_Latn","pl":"hs","prompt":"--remove_vowels est una funtzione chi pigat sa cadena e torrat sa cadena sena vocales.--  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =","canonical_solution":"removeVowels :: String -> String\nremoveVowels text = filter (`notElem` \"aeiouAEIOU\") text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_52","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat True si totu sos nùmeros in sa lista l sunt a suta de sa lìmites t. --  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =","canonical_solution":"belowThreshold l t = all (< t) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_53","nl":"srd_Latn","pl":"hs","prompt":"--Agregare duos nùmeros, x e y.--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =","canonical_solution":"add :: Int -> Int -> Int\nadd x y = x + y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_54","nl":"srd_Latn","pl":"hs","prompt":"--☐ Verificare si duas paràulas tenent sos matessi caràteres.--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =","canonical_solution":"import Data.List (nub, sort)\n\nsameChars :: String -> String -> Bool\nsameChars s0 s1 = sort (nub s0) == sort (nub s1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_55","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat su nùmeru de Fibonacci n.--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =","canonical_solution":"fib :: Int -> Int\nfib n = fibHelper 0 1 n\n  where\n    fibHelper a _ 0 = a\n    fibHelper a b n = fibHelper b (a + b) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_56","nl":"srd_Latn","pl":"hs","prompt":"--return True si ogni bracheta de aberimentu tenet una bracheta de serrada currispondente. --Sos parentesi sunt una cadena de \"<\" e \">\".--  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBrackets brackets 0 == 0\n\ncheckBrackets :: String -> Int -> Int\ncheckBrackets [] n = n\ncheckBrackets (x:xs) n\n  | n < 0 = -1\n  | x == '<' = checkBrackets xs (n + 1)\n  | x == '>' = checkBrackets xs (n - 1)\n  | otherwise = checkBrackets xs n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_57","nl":"srd_Latn","pl":"hs","prompt":"--\"Return True\" est chi sos elementos de sa lista sunt in manera monotònica creschende o diminuende.--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =","canonical_solution":"monotonic :: [Int] -> Bool\nmonotonic l = increasing l || decreasing l\n  where\n    increasing xs = all (uncurry (<=)) (zip xs (tail xs))\n    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_58","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat elementos ùnicos ordinados comunes pro duas listas. --  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =","canonical_solution":"common :: [Int] -> [Int] -> [Int]\ncommon l1 l2 = uniqueSortedCommon\n  where\n    commonElements = filter (`elem` l2) l1\n    uniqueCommon = removeDuplicates commonElements\n    uniqueSortedCommon = sort uniqueCommon\n\n    removeDuplicates :: [Int] -> [Int]\n    removeDuplicates = foldr (\\x seen -> if x `elem` seen then seen else x : seen) []\n\n    sort :: [Int] -> [Int]\n    sort [] = []\n    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)\n      where\n        lesser  = filter (< p) xs\n        greater = filter (>= p) xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_59","nl":"srd_Latn","pl":"hs","prompt":"-- Torrat su prus mannu fatore primu de n. Assumimus chi n > 1 e non est unu primu. --  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =","canonical_solution":"largestPrimeFactor :: Int -> Int\nlargestPrimeFactor n = helper n 2\n  where\n    helper n factor\n      | factor * factor > n = n\n      | n `mod` factor == 0 = helper (n `div` factor) factor\n      | otherwise = helper n (factor + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_60","nl":"srd_Latn","pl":"hs","prompt":"-- sum_to_n est una funtzione chi summat nùmeros dae 1 a n. --  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =","canonical_solution":"sumToN :: Int -> Int\nsumToN n = sum [1..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_61","nl":"srd_Latn","pl":"hs","prompt":"--return True si ogni bracheta de aberimentu tenet una bracheta de serrada currispondente. --Sos parentesi sunt una cadena de \"(\" e \")\".--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBalance brackets 0\n  where\n    checkBalance [] 0 = True\n    checkBalance [] _ = False\n    checkBalance (x:xs) n\n      | x == '('  = checkBalance xs (n + 1)\n      | x == ')' && n > 0 = checkBalance xs (n - 1)\n      | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_62","nl":"srd_Latn","pl":"hs","prompt":"--Torrat sa derivada de custu polinòmiu in sa matessi forma.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --Sos x rapresentant sos coeficientes de unu polinòmiu.--  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =","canonical_solution":"derivative :: [Int] -> [Int]\nderivative xs = zipWith (*) (tail xs) [1..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_63","nl":"srd_Latn","pl":"hs","prompt":"--Iscriet una funtzione pro compudare in manera efitziente s'elementu n-esimu de sa secuèntzia de nùmeros fibfib. --fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). --fit fit ((2) == 1 --fit fit ((1) == 0 --fit fit ((0) == 0 --Sa secuèntzia de nùmeros FibFib est una secuèntzia sìmile a sa secuèntzia de Fibbonacci chi est definida comente sighit:--  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =","canonical_solution":"fibfib :: Int -> Int\nfibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibs !! n\n  where\n    fibs = 0 : 0 : 1 : zipWith3 (\\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_64","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --vocale, ma solu cando est a sa fine de sa paràula dada.--Sas vocales in custu casu sunt \"a\", \"e\", \"i\", \"o\", \"u\".--una paràula comente input e torrat su nùmeru de vocales in sa cadena. -- Iscriere una funtzione vowels_count chi pigat una cadena chi rapresentat --  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =","canonical_solution":"vowelsCount :: String -> Int\nvowelsCount s = length $ filter isVowel $ zip s [1..]\n  where\n    isVowel (c, pos) =\n      let lowercaseC = toLower c\n          isRegularVowel = lowercaseC `elem` \"aeiou\"\n          isLastCharY = lowercaseC == 'y' && pos == length s\n      in isRegularVowel || isLastCharY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_65","nl":"srd_Latn","pl":"hs","prompt":"--Si shift > nùmeru de tzifras, torrat tzifras a s'imbesse. --e torrat su resurtadu comente a una cadena. -- Movende in tzirculu sas tzifras de s'intreu x, movende sas tzifras a dereta pro càmbiu --  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =","canonical_solution":"circularShift :: Int -> Int -> String\ncircularShift x shift =\n  let digits = show x\n      len = length digits\n      effectiveShift = shift `mod` len\n  in if shift > len\n     then reverse digits\n     else let (begin, end) = splitAt (len - effectiveShift) digits\n          in end ++ begin","tests":"\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_66","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Codificatziones ASCII. --Iscriere una funtzione chi pigat una cadena comente input e torrat sa summa de sos caràteres superiores isceti' --Iscopu--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =","canonical_solution":"digitsum :: String -> Int\ndigitsum s = sum $ map fromEnum $ filter isUpper s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_67","nl":"srd_Latn","pl":"hs","prompt":"--pro s'esàmbulu: --in su càsciu torrat su nùmeru de sos frutos de manga in su càsciu. --sas naranzas e sas manzanas e unu nùmeru intreu chi rapresentant su nùmeru totale de sos frutos --Mancas, naranzas e frutos de mango.--chi sunt distribuidos in unu crastu de frutas custu crastu cuntenet -- In custa tarea, ti ant a dare una cadena chi rapresentat unu nùmeru de manzanas e naranzas --  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =","canonical_solution":"import Text.Read (readMaybe)\n\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n = n - totalApplesOranges\n  where\n    totalApplesOranges = sum $ map (readNumber . words) [\"apples\", \"oranges\"]\n    readNumber keyword = case dropWhile (not . (==\" \") . dropWhile (\/=' ')) $ words s of\n      [] -> 0\n      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_68","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu 1: --Si non b'at balores paris o s'elencu dadu est bòidu, torrat []. --Su nùmene de su nùcleu est istadu torradu in una lista, [small_value, su nùmeru de indice suo], --Si b'at prus nodos cun su matessi balore pari prus piticu torrat su nodus chi tenet s'inditzu prus piticu. --Su nódulu iscolpidu diat dèpere èssere su nódulu cun su balore paris prus minore.--su traballu tuo est de pònnere unu de sos nodos e lu torrare.--\"Cunsiderende una lista chi rapresentat unu ramu de un'àrbore chi tenet nodos intreos non negativos --  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =","canonical_solution":"pluck :: [Int] -> [Int]\npluck arr = case filter (\\(x, _) -> even x) (zip arr [0..]) of\n    [] -> []\n    evens -> let (value, index) = minimum evens in [value, index]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_69","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Si non esistit unu tale balore, torrat -1.--Sa frecuèntzia de unu nùmeru intreu est su nùmeru de bortas chi aparesset in sa lista.--zero, e tenet una frecuèntzia majore o uguale a su balore de su nùmeru intreu matessi. -- Si ti dan una lista de nùmeros intreos positivos chi no est bòida, torra su nùmeru intreu prus mannu chi est prus mannu de --  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nsearch :: [Int] -> Int\nsearch lst = \n    let frequencies = map (\\g -> (head g, length g)) . group . sort $ lst\n        candidates = filter (\\(val, freq) -> freq >= val) frequencies\n    in case candidates of\n         [] -> -1\n         _  -> fst . maximum $ candidates","tests":"\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_70","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --tando màssimu de sos intreos abarrados, tando mìnimu e gasi sighende.--Sortamentu istranu, est cando si cumintzat cun su balore mìnimu, -- Data una lista de intreos, torrat sa lista in un'òrdine istranu. --  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =","canonical_solution":"strangeSortList :: [Int] -> [Int]\nstrangeSortList [] = []\nstrangeSortList lst = go (sort lst) True\n  where\n    go [] _ = []\n    go xs toggle\n      | toggle    = head xs : go (tail xs) False\n      | otherwise = last xs : go (init xs) True","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_71","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --de su de tres lados.--Tres lados faghent unu triàngulu bàlidu cando sa summa de duos lados est prus manna.--In casu contràriu torrat -1 --su triàngulu arrotondadu a 2 puntos detzimales si sos tres lados formant unu triàngulu bàlidu. --Dadu chi sas longas de sos tres lados de unu triàngulu torrant s'àrea de--  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =","canonical_solution":"import Text.Printf (printf)\n\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c\n    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))\n    | otherwise = -1\n  where\n    s = (fromIntegral (a + b + c)) \/ 2\n    isValidTriangle x y z = x + y > z && x + z > y && y + z > x\n    roundToTwoDecimals x = read (printf \"%.2f\" x) :: Float","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_72","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --S'ogetu q at a bolare si est in equilíbriu (est una lista palindromica) e sa summa de sos elementos suos est minore o uguale a su màssimu pesu possìbile w.-- Iscriere una funtzione chi torrat True si s'ogetu q at a bolare, e False in casu contràriu. --  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =","canonical_solution":"willItFly :: [Int] -> Int -> Bool\nwillItFly q w = isPalindrome q && sum q <= w\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome xs = xs == reverse xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_73","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --si podet cambiare un'elementu in un'àteru elementu.--una lista palindroma est una lista chi -- dadu un'elencu arr de intreos, agatade su nùmeru mìnimu de elementos chi --  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =","canonical_solution":"smallestChange :: [Int] -> Int\nsmallestChange arr = sum $ zipWith (\\x y -> if x \/= y then 1 else 0) arr (reverse arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_74","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios --si sas duas listas tenent su matessi nùmeru de caràteres, torrat sa prima lista. --nùmeru totale de caràteres in totu sas cadenas de sa lista prus pagu de s'àtera lista. --Iscriet una funtzione chi atzetat duas listas de cadenas e torrat sa lista chi tenet--  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =","canonical_solution":"totalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2\n  | totalChars lst1 < totalChars lst2 = lst1\n  | totalChars lst1 > totalChars lst2 = lst2\n  | otherwise = lst1\n  where\n    totalChars = sum . map length","tests":"\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_75","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --Saende chi (a) est prus pagu de 100.--e falsos in àteras cosas.-- Iscriere una funtzione chi torrat sa balentia \"true\" si su nùmeru dadu est sa multiplicatzione de 3 nùmeros primos --  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =","canonical_solution":"isMultiplyPrime :: Int -> Bool\nisMultiplyPrime a = any isTriplePrimeProduct primeTriples\n  where\n    primes = filter isPrime [2..99]\n    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]\n    isTriplePrimeProduct (x, y, z) = x * y * z == a\n\nisPrime :: Int -> Bool\nisPrime n \n  | n < 2     = False\n  | otherwise = not (any (\\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_76","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --x est una potèntzia de n si n**int=x --potèntzia de n e falsa in àteros casos. -- Su traballu tuo est de iscrìere una funtzione chi torrat beru si unu nùmeru x est unu nùmeru simple --  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =","canonical_solution":"isSimplePower :: Int -> Int -> Bool\nisSimplePower x n\n  | x < 1 || n < 1 = False\n  | n == 1 = x == 1\n  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_77","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Nota: si podet assumire chi s'intrada est semper vàlida.--si custu ingeger est unu cubu de unu nùmeru intreu.--Iscriet una funtzione chi pigat unu nùmeru intreu a e torrat True.--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =","canonical_solution":"iscube :: Int -> Bool\niscube a = let n = round (fromIntegral a ** (1\/3)) in n^3 == a","tests":"\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_78","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --e sos sìmbulos A,B,C,D,E,F sunt semper maiusculos. --Nota: si podet assumire chi s'intrada est semper curreta o lìtera bòida, --B (= detzimale 11), D (= detzimale 13). --Duncas depes determinare unu nùmeru de sas sighentes tzifras: 2, 3, 5, 7, --Sos nùmeros primos sunt 2, 3, 5, 7, 11, 13, 17,...--Sas tzifras esadecimales sunt 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. --prus mannu de 1 chi non est unu produtu de duos nùmeros naturales prus minores).--tzifras chi sunt primos (numere primu, o unu primu, est unu nùmeru naturale --unu nùmeru esadecimale comente a una cadena e contat su nùmeru de esadecimales -- Ti ant pedidu de iscrìere una funtzione chi retzit --  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =","canonical_solution":"hexKey :: String -> Int\nhexKey num = length . filter (`elem` primeHexDigits) $ num\n  where\n    primeHexDigits = \"2357BD\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_79","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Sos caràteres agiuntivos sunt in cue pro agiudare cun su formadu.--B'at a èssere unu paru de caràteres 'db' in prus a s'incumintzu e a sa fine de sa cadena. --Cada caràtere de sa cadena at a èssere \"0\" o \"1\".--sa funtzione depet torrare una cadena, cun cada caràtere chi rapresentat unu nùmeru binàriu -- Ti ant a donai unu nùmeru in forma dexi e su compitu tuo est de lu cunvertiri in --  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =","canonical_solution":"decimalToBinary :: Int -> String\ndecimalToBinary decimal = \"db\" ++ toBinary decimal ++ \"db\"\n  where\n    toBinary 0 = \"0\"\n    toBinary n = reverse (binaryHelper n)\n\n    binaryHelper 0 = \"\"\n    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_80","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Una cadena est haphs si sa longària sua est de a su mancu 3 e cada 3 lìteras consecutivas sunt distintas --Su traballu tuo est de controllare si sa cadena est haphs o no.--☐ Si ti est dadu una cadena de caràteres ☐--  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =","canonical_solution":"isHappy :: String -> Bool\nisHappy s\n  | length s < 3 = False\n  | otherwise = all distinctTriples (windows 3 s)\n  where\n    distinctTriples [x, y, z] = x \/= y && y \/= z && x \/= z\n    distinctTriples _ = False\n    windows n xs\n      | length xs < n = []\n      | otherwise = take n xs : windows n (tail xs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_81","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --0,0 E --> 0,0 D- --> 0,7 D --> 1,0 D+ --> 1.3 C- --> 1,7 C --> 2,0 C+ --> 2.3 B- --> 2,7 B --> 3,0 B+ --> 3.3 A- --> 3.7 A --4,0 A+ --GPA. Gradu de iscritura.--una funtzione chi podet prodùere un'elencu de sos grados de sas lìteras impreende sa tabela imbeniente: --T'at dadu una lista de sos puntos de calicunu istudiante e depes iscriere.--S'ùnicu problema est chi at pèrdidu su còdighe chi impreat pro sa graduatzione.--Sa mastra at fatu s'algoritmu suo pro sa graduatzione.--Est s'ùrtima chida de su semestre e s'insegnante depet dare sos balores.--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =","canonical_solution":"numericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades = map gpaToLetterGrade grades\n  where\n    gpaToLetterGrade gpa\n      | gpa == 4.0 = \"A+\"\n      | gpa > 3.7  = \"A\"\n      | gpa > 3.3  = \"A-\"\n      | gpa > 3.0  = \"B+\"\n      | gpa > 2.7  = \"B\"\n      | gpa > 2.3  = \"B-\"\n      | gpa > 2.0  = \"C+\"\n      | gpa > 1.7  = \"C\"\n      | gpa > 1.3  = \"C-\"\n      | gpa > 1.0  = \"D+\"\n      | gpa > 0.7  = \"D\"\n      | gpa > 0.0  = \"D-\"\n      | otherwise  = \"E\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_82","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios --longitude est unu nùmeru primu o Falsu si no --Iscriet una funtzione chi pigat una cadena e torrat True si sa cadena est --  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =","canonical_solution":"primeLength :: String -> Bool\nprimeLength string = isPrime (length string)\n\nisPrime :: Int -> Bool\nisPrime n\n  | n < 2     = False\n  | n == 2    = True\n  | even n    = False\n  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_83","nl":"srd_Latn","pl":"hs","prompt":"--intreos positivos chi comintzant o finint cun 1. -- dadu unu nùmeru interu positivu n, torrat su nùmeru de sos nùmeros de n-tzifras startsOneEnds :: Int -> Int\nstartsOneEnds n =","canonical_solution":"startsOneEnds :: Int -> Int\nstartsOneEnds n\n  | n <= 0    = 0\n  | n == 1    = 1\n  | otherwise = 18 * 10^(n-2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_84","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu -- Dadu unu nùmeru interu positivu N, torrat sa summa de sas tzifras suas in binàriu. --  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 ≤ N ≤ 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =","canonical_solution":"solve :: Int -> String\nsolve N = toBinary (sumOfDigits N)\n  where\n    sumOfDigits 0 = 0\n    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)\n\n    toBinary 0 = \"0\"\n    toBinary n = reverse (toBinary' n)\n      where\n        toBinary' 0 = \"\"\n        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_85","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: -- Si tenimus una lista de nùmeros intreos chi no sunt bòidos, prima de totu, agiunghimus sos elementos paris chi sunt in sos indicos dispàrios.--  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =","canonical_solution":"add :: [Int] -> Int\nadd lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_86","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Nota: Depeus mantenni s'òrdini de is fueddus e is ispàtzius lìberus in sa frasi. --ordinamentu creschente basadu subra de su balore ascii. --sunt remplasadas dae una paràula noa in ue totu sos caràteres organizados in --Versione ordinada de sa cadena, est una cadena in ue totu sas paràulas (separadas dae unu ispàtziu) -- Iscriere una funtzione chi pigat una cadena e nde torrat una versione ordinada. --  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =","canonical_solution":"import Data.List (sort)\nimport Data.Char (isAlpha)\n\nantiShuffle :: String -> String\nantiShuffle s = unwords $ map sortWord (wordsAndSpaces s)\n  where\n    sortWord word = if all isAlpha word then sort word else word\n    wordsAndSpaces [] = []\n    wordsAndSpaces xs = if head xs == ' ' \n                        then \" \" : wordsAndSpaces (dropWhile (== ' ') xs)\n                        else let (word, rest) = break (== ' ') xs\n                             in word : wordsAndSpaces rest","tests":"\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_87","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Fintzas, ordinare sas coordinadas de sa fila pro sas colunnas in òrdine decrescente.--Ordinai is coordinadas in manera incumentzada de filas in òrdini crescente.--ogni tupla est una coordinada - (ràngulu, colunnas), incumentzende cun 0. --e torrat sa lista de sas tuples, [(x1, y1), (x2, y2) ...] de manera chi --Dadu lst, e nùmeru intreu x, agatade sos nùmeros intèrios x in sa lista, --ogni riga podet cuntènnere unu nùmeru diferente de colunnas. --chi est sìmile a sa matrice, però, a diferèntzia de sas matrices, --❑ Si ti dan unos datos bidimensionales, comente a listas annidadas,--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =","canonical_solution":"getRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x = concatMap processRow (zip [0..] lst)\n  where\n    processRow (rowIndex, row) = \n      let colIndices = reverse $ findIndices (== x) row\n      in [(rowIndex, colIndex) | colIndex <- colIndices]\n\nfindIndices :: (a -> Bool) -> [a] -> [Int]\nfindIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_88","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --* no cambiai sa lista dada. --Nota: --o ordinare in òrdine decrescente si sa summa (primu balore de indice, ùrtimu balore de indice) est paris. --si at a ordinare sa lista dada in òrdine creschente si sa summa (primmu balore de indice, ùrtimu balore de indice) est dispàdia, -- Si nos dat una lista de intreos no negativos, torrat unu cohs de sa lista dada a pustis de s'ordinamentu, --  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =","canonical_solution":"sortArray :: [Int] -> [Int]\nsortArray array\n  | null array = array\n  | otherwise =\n    let first = head array\n        last = last array\n        sumFirstLast = first + last\n    in if odd sumFirstLast\n       then sort array\n       else reverse (sort array)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_89","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --cambiare a suta de duos multiplicados pro duos logos.--S'alfabetu diat dèpere èssere giradu in manera chi sas lìteras --torrat una cadena chi est codificada cun sa rotatzione de s'alfabetu. -- Creare una funtzione chi pigat una cadena comente a argumentu e --  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =","canonical_solution":"encrypt :: String -> String\nencrypt s = map shiftChar s\n  where\n    shiftChar c\n      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')\n      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_90","nl":"srd_Latn","pl":"hs","prompt":"--Torra Nada si no esistit un'elementu de custa genia.--Iscriet una funtzione next_smallest (de su prus minore) chi torrat su segundu elementu prus minore de sa lista. -- Ti est dadu una lista de nùmeros intreos --  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =","canonical_solution":"nextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =\n  let uniqueSorted = removeDuplicates $ quicksort lst\n  in if length uniqueSorted < 2\n     then Nothing\n     else Just (uniqueSorted !! 1)\n\nremoveDuplicates :: (Ord a) => [a] -> [a]\nremoveDuplicates = foldr (\\x acc -> if x `elem` acc then acc else x : acc) []\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_91","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Sas frases sunt delimitadas cun \"\", \"?\" o \"!\" --Una noia est una frase chi cumintzat cun sa paràula \"io\".--❑ Ti ant a dare una cadena de paràulas, e su traballu tuo est de contare su nùmeru.--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =","canonical_solution":"isBored :: String -> Int\nisBored s = length $ filter (startsWithI . words) $ splitSentences s\n  where\n    splitSentences :: String -> [String]\n    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters \".?!\"\n    \n    splitOnDelimiters :: String -> String -> [String]\n    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of\n      \"\" -> []\n      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''\n    \n    startsWithI :: [String] -> Bool\n    startsWithI [] = False\n    startsWithI (x:_) = map toLower x == \"i\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_92","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios --Torrat false in totu sos àteros casos. --Torrat a èssere beru si unu de sos nùmeros est uguale a sa summa de sos àteros duos, e totu sos nùmeros sunt intreos.-- Creare una funtzione chi pigat 3 nùmeros. --  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =","canonical_solution":"anyInt :: Float -> Float -> Float -> Bool\nanyInt x y z\n  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =\n      x == y + z || y == x + z || z == x + y\n  | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_93","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Assumancu lìteras.--Vocale in s'alfabetu inglesu.--su messàgiu cun sa lìtera chi aparit 2 logos in antis de cussa --In custa manera càmbiat sa cassa de totu sas lìteras, càmbiat totu sas vocales in --Iscriet una funtzione chi pigat unu messàgiu, e lu codificat in una manera chi--  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =","canonical_solution":"encode :: String -> String\nencode = map transformChar\n  where\n    transformChar :: Char -> Char\n    transformChar c\n      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c\n      | otherwise      = swapCase c c\n      where\n        lowerC = toLower c\n\n    isVowel :: Char -> Bool\n    isVowel c = c `elem` \"aeiou\"\n\n    swapCase :: Char -> Char -> Char\n    swapCase origC c\n      | isUpper origC = toLower c\n      | otherwise     = toUpper c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_94","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Deves agatare su balore primu prus mannu e torrare sa summa de sas tzifras suas.-- Ti est dadu una lista de nùmeros intreos --  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =","canonical_solution":"skjkasdkd :: [Int] -> Int\nskjkasdkd lst = sumDigits (largestPrime lst)\n\n-- Function to check if a number is prime\nisPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]\n\n-- Integer square root using binary search, O(log n)\nisqrt :: Int -> Int\nisqrt n = floor . sqrt $ fromIntegral n\n\n-- Function to find the largest prime in the list\nlargestPrime :: [Int] -> Int\nlargestPrime = foldr (\\x acc -> if isPrime x && x > acc then x else acc) 0\n\n-- Function to calculate the sum of the digits of a number\nsumDigits :: Int -> Int\nsumDigits 0 = 0\nsumDigits n = n `mod` 10 + sumDigits (n `div` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_95","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Sa funtzione diat dèpere torrare False si sa lista de assòtzios dada est bòida. --case o totu sas teclas sunt cadenas in maiusculas, si nono torrat False. --☐ Si b'at una lista de assòtzios, torrat True si totu sas teclas sunt cadenas in minore ☐ Si b'at una lista de assòtzios, torrat True si totu sas teclas sunt cadenas in minore ☐--  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =","canonical_solution":"import Data.Char (isUpper, isLower)\n\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase [] = False\ncheckDictCase dict = all isLower allKeys || all isUpper allKeys\n  where\n    allKeys = concatMap fst dict","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_96","nl":"srd_Latn","pl":"hs","prompt":"--pro esèmpiu: --intreos chi sunt nùmeros primos e prus piticos de n. --☐ Implementare una funtzione chi pigat un'intreu non negativu e torrat una lista de sos primos n--  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =","canonical_solution":"countUpTo :: Int -> [Int]\ncountUpTo n = filter isPrime [2..n-1]\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_97","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Assumet chi s'intrada siat semper vàlida.--su produtu de sas tzifras de unidade issoro. -- Completare sa funtzione chi pigat duos intreos e torrat --  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =","canonical_solution":"multiply :: Int -> Int -> Int\nmultiply a b = (abs a `mod` 10) * (abs b `mod` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_98","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: -- Si nos dat una cadena s, contamus su nùmeru de sas vocales majusculas in indices paris. --  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =","canonical_solution":"countUpper :: String -> Int\ncountUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` \"AEIOU\"]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_99","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios --dae duos intreos, l'arrotondamus a tesu dae zero.--E torrat s'intreu prus a curtzu a issu.--☐ Creare una funtzione chi pigat unu balore (string) chi rapresentat unu nùmeru ☐--  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =","canonical_solution":"closestInteger :: String -> Int\nclosestInteger value = \n  let n = read value :: Double\n  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_100","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --i rapresentat su nùmeru de pedras in su livellu (i+1). --Torrat su nùmeru de pedras in cada livellu in una lista, in ue s'elementu in indice --- su nùmeru paris imbeniente si n est paris. --- su nùmeru lìberu si n est lìberu. --Su nùmeru de pedras in su livellu imbeniente est: --Su primu livellu tenet n pedras.--∙ Si tenimus unu nùmeru intreu positivu n, depimus fàghere una pila de n livellos de pedras. ∙--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =","canonical_solution":"makeAPile :: Int -> [Int]\nmakeAPile n = take n [n, n + 2 ..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_101","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --pro partzire sa cadena in paràulas e torrare una lista de paràulas.--☐ Si ti ant a dare una cadena de paràulas separadas dae cummas o ispàtzios.--  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =","canonical_solution":"wordsString :: String -> [String]\nwordsString s = words $ map (\\c -> if c == ',' then ' ' else c) s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_102","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --No esistit unu nùmeru gasi, tando sa funtzione diat dèpere torrare -1.--Su prus mannu nùmeru intreu pari chi est in su rangu [x, y] inclùdidu.--Custa funtzione pigat duos nùmeros positivos x e y e torrat su --  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =","canonical_solution":"chooseNum :: Int -> Int -> Int\nchooseNum x y\n    | x > y = -1\n    | even upperBound = upperBound\n    | even (upperBound - 1) = upperBound - 1\n    | otherwise = -1\n  where\n    upperBound = max x y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_104","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Nota: Sa lista torrada depet èssere ordinada in òrdine creschente.--elementos chi non tenent mancu una tzifra pari.-- dadu un'elencu de nùmeros intreos positivos x. torrat un'elencu ordinadu de totu --  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =","canonical_solution":"uniqueDigits :: [Int] -> [Int]\nuniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_105","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Unu, duos, tres, bator, chimbe, ses, sete, oto, noe.--invertire s'elencu chi resurtat, e posca sostituire cada tzifra cun su nùmene currispondente suo dae -- Si nos dat una lista de nùmeros intreos, ordinamus sos intreos chi sunt intre 1 e 9 inclùdidos, --  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the list is empty, return an empty list:\n--  >>> byLength []\n--  []\n--  If the list has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =","canonical_solution":"byLength :: [Int] -> [String]\nbyLength arr = map digitName . reverse . sort . filter isValid $ arr\n  where\n    isValid x = x >= 1 && x <= 9\n    digitName x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"\n      _ -> error \"Unexpected number\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_106","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --su fatziòriu de i est sa multiplicatzione de sos nùmeros dae 1 a i (1 * 2 * ... * i).--i cumintzat dae 1. --o sa summa de sos nùmeros dae 1 a i in casu contràriu. --E torrat una lista de mannària n, in manera chi su balore de s'elementu in s'inditzu i siat su fatoriale de i si i est pari --Implementare sa funtzione f chi pigat n comente a paràmetru,--  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =","canonical_solution":"f :: Int -> [Int]\nf n = map g [1..n]\n  where\n    g i\n      | even i    = factorial i\n      | otherwise = sum [1..i]\n    \n    factorial 0 = 1\n    factorial m = product [1..m]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_107","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu 1: --palindromos intreos chi s'agatant in su rangu ((1, n), inclùdidu. -- dadu unu nùmeru interu positivu n, torrat unu tuple chi tenet su nùmeru de pares e impares --  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =","canonical_solution":"evenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n = (length evens, length odds)\n  where\n    isPalindrome x = show x == reverse (show x)\n    palindromes = filter isPalindrome [1..n]\n    evens = filter even palindromes\n    odds  = filter odd palindromes","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_108","nl":"srd_Latn","pl":"hs","prompt":"--es. -123 tenet tzifras firmadas -1, 2 e 3. --Si unu nùmeru est negativu, tando sa prima tzifra firma sua at a èssere negativa: --su nùmeru de elementos chi tenet una summa de tzifras > 0. --Iscriet una funtzione count_nums chi pigat una lista de intreos e torrat sa data.--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =","canonical_solution":"countNums :: [Int] -> Int\ncountNums arr = length $ filter ((> 0) . sumDigits) arr\n  where\n    sumDigits 0 = 0\n    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)\n                  in sum digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_109","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Nota: Sa lista dada est garantida de tènnere elementos ùnicos.--Si sa lista dada est bòida torrat True. --tando torrat True, si no torrat False.--Si est possìbile otènnere s'elencu ordinadu realizende s'operatzione de subra --sa positzione de cumintzu in sa lista, est a nàrrere 0° indice. --S'ùrtimu elementu de sa lista at a èssere tramudadu a --Un'operatzione de isvilupu a dereta signìficat isvilupu de totu sos elementos de sa lista de unu.--Ti est permìtidu de esecutare s'operatzione de càmbiu de dereta in cale si siat nùmeru de bortas.--s'operatzione imbeniente in s'elencu dadu: --si podet otènnere un'elencu ordinadu in òrdine non decrescente faghende --sos nùmeros de sa lista ant a èssere ordinados a casu. Su traballu tuo est de determinare si -- Tenimus una lista 'arr' de N intreos arr[1], arr[2], ..., arr[N].--  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given list.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  list by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =","canonical_solution":"moveOneBall :: [Int] -> Bool\nmoveOneBall [] = True\nmoveOneBall arr = canBeSorted (arr ++ arr)\n  where\n    n = length arr\n    canBeSorted xs = any isSorted (take n <$> tails xs)\n    isSorted ys = and $ zipWith (<=) ys (tail ys)\n    tails [] = []\n    tails l@(_:xs) = l : tails xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_110","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --In casu contràriu, torrat \"NO\". --Si totu sos elementos de lst1 sunt paris, torrat \"SI\".--Si est possìbile a iscambiare elementos intre lst1 e lst2 pro fàghere --Non b'at perunu lìmite a su nùmeru de elementos iscambiados intre lst1 e lst2. --tra issos pro fàghere de lst1 una lista de petzi nùmeros paris.--e detèrminat si est possìbile a fàghere unu càmbiu de elementos --In custu problema, depet implementare una funtzione chi pigat duas listas de nùmeros,--  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =","canonical_solution":"exchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | all even lst1 = \"YES\"\n  | null oddLst1 || null evenLst2 = \"NO\"\n  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)\n                in if possibility then \"YES\" else \"NO\"\n  where\n    oddLst1 = filter odd lst1\n    evenLst2 = filter even lst2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_111","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --Si medas lìteras tenent sa matessi aparitzione, torra totu.--de sa lìtera cun sa prus repitida e chi cuntenet su nùmeru currispondente. -- Si b'at una cadena chi rapresentat sas lìteras minores separadas dae unu tzertu ispàtziu, torra una lista de assòtzios --  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nhistogram :: String -> [(String, Int)]\nhistogram input =\n  let wordsList = words input\n      grouped = group $ sort wordsList\n      countList = map (\\ws -> (head ws, length ws)) grouped\n      maxCount = if null countList then 0 else maximum $ map snd countList\n  in filter ((== maxCount) . snd) countList","tests":"\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_112","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu --Tocat a torrare una tupla chi cuntenet sa cadena de resurtados e True\/False pro su controllu.--Una cadena est narada palindroma si si leet sa matessi manera a dae segus comente a dae in antis.--tando controlla si sa cadena de resurtados est palindroma. --Tenimus duas cadenas de caràteres s e c, depimus eliminare totu sos caràteres de s chi sunt uguales a cale si siat caràtere de c.--Iscopu--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =","canonical_solution":"import Data.List (filter)\n\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =\n  let result = filter (`notElem` c) s\n  in (result, result == reverse result)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_113","nl":"srd_Latn","pl":"hs","prompt":"--de tzifras disparias in sa cadena de sa tzertificatzione.--string i de s'intrada. \" ue totu sos i depent èssere remplasados dae su nùmeru --Ogni elementu i de s'output diat dèpere èssere \"su nùmeru de elementos dispàrios in sa --DATA una lista de cadenas, ue cada cadena est cumposta de sìmbulos, torrat una lista. --  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =","canonical_solution":"oddCount :: [String] -> [String]\noddCount lst = map formatString lst\n  where\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"\n\n    countOdds :: String -> Int\n    countOdds str = length $ filter isOddDigit str\n\n    formatString :: String -> String\n    formatString str =\n      let oddCount = countOdds str in\n      \"the number of odd elements \" ++ show oddCount ++ \n      \"n the str\" ++ show oddCount ++ \"ng \" ++ show oddCount ++\n      \" of the \" ++ show oddCount ++ \"nput.\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_114","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu --de nùmeros. -- Si nos dat una lista de nùmeros intreos, agatamus sa summa mìnima de una lista de nùmeros chi non sunt bòidos.--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =","canonical_solution":"minsubarraysum :: [Int] -> Int\nminsubarraysum nums = minimum $ scanl1 (\\acc x -> min x (acc + x)) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_115","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu 1: --Iscrie su nùmeru de bortas chi depes abbasciare sos butìllios.--Sa tarea tua est de impreare sos butzones pro bogare sos putzos.--e totu sos buteddos tenent sa matessi capatzidade.--Ogni putzu tenet unu biddinu chi si podet impreare pro dd'estraer s'abba, --e cada 1 in una lìnia rapresentat una sola unidade de abba. --❑ Si ti donat una retze de putzos, ogni riga rapresentat unu putzu sìngulu, ❑--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =","canonical_solution":"maxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity = ceiling (fromIntegral totalWater \/ fromIntegral capacity)\n  where\n    totalWater = sum (map sum grid)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_116","nl":"srd_Latn","pl":"hs","prompt":"--Si depet implementare comente a custu: --Pro nùmeru sìmile de unas, ordinare basadu subra de balore detzimale. --nùmeru de unos in sa rapresentatzione binària issoro in òrdine creschente. --In custu kata, depes ordinare una lista de intreos no negativos segundu--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =","canonical_solution":"import Data.Bits (popCount)\nimport Data.List (sortBy)\n\nsortArray :: [Int] -> [Int]\nsortArray arr = sortBy compareOnesAndValues arr\n  where\n    compareOnesAndValues x y =\n      let onesX = popCount x\n          onesY = popCount y\n      in if onesX == onesY\n         then compare x y\n         else compare onesX onesY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_117","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Nota: si podet assumere chi sa cadena de intrada cuntenet petzi lìteras e ispàtzios.--Si s est una cadena bòida, tando sa funtzione depet torrare una lista bòida. --n cunsonantes, in s'òrdine in ue custas paràulas aparint in sa cadena s. --una funtzione chi torrat una lista de totu sas paràulas de sa cadena s chi cuntenent pròpiu --☐ Data una cadena s e unu nùmeru naturale n, bos ant dadu sa tarea de implementare ☐--  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =","canonical_solution":"selectWords :: String -> Int -> [String]\nselectWords s n = filter (\\word -> countConsonants word == n) (words s)\n  where\n    countConsonants = length . filter (`elem` consonants)\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_118","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --Si podet pensare chi sa cadena dada cuntenet petzi lìteras in inglesu.--agatare cale si siat vocale chi soddisfat sa cunditzione de subra.--Sas vocales in su cumintzu e in sa fine non contant.--duas cunsonantes dae su ladu deretu de sa paràula (case sensitive). -- Ti est dada una paràula. Su traballu tuo est de agatare sa vocale prus a curtzu chi istat intre --  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =","canonical_solution":"getClosestVowel :: String -> String\ngetClosestVowel word = go (reverse word) False\n  where\n    vowels = \"aeiouAEIOU\"\n    go [] _ = \"\"\n    go (x:xs) lastWasConsonant\n      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False\n      | x `notElem` vowels = go xs True\n      | otherwise = go xs False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_119","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Torrat \"Sì\" si b'at unu modu pro fàghere una cadena bona, e torrat \"No\" si nono.--\"()) \" no est gasi. --Pro esèmpiu: sa cadena '(()))))) ' est bona, mentras sa cadena --Una cadena S est cunsiderada bona si e solu si totu sas parèntesi in S --carchi òrdine, chi sa cadena chi resurtat at a èssere bona.--Su traballu tuo est de controllare si est possìbile a cuncatenare sas duas cadenas in --solu sos parentèsis \" ((\") o sos parentèsis serrados \") \". -- Ti est dadu una lista de duas cadenas, ambas sunt abertas --  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =","canonical_solution":"matchParens :: [String] -> String\nmatchParens [a, b] =\n    if isValid (a ++ b) || isValid (b ++ a) then \"Yes\" else \"No\"\n  where\n    isValid :: String -> Bool\n    isValid = go 0\n      where\n        go 0 [] = True\n        go _ [] = False\n        go n (x:xs)\n            | x == '('  = go (n + 1) xs\n            | x == ')'  = n > 0 && go (n - 1) xs\n    isValid _ = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_120","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu 1: --de longària k cun su màssimu de k nùmeros in arr. -- Si tenimus una lista arr de intreos e unu k de intreos positivos, torrat una lista ordinada --  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the list will be in the range of [1, 1000].\n--  2. The elements in the list will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =","canonical_solution":"maximum :: [Int] -> Int -> [Int]\nmaximum arr k = take k $ reverse $ sort arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_121","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios -- Si tenimus una lista de intreos chi no est bòida, torrat sa summa de totu sos elementos dispari chi sunt in positziones paris. --  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =","canonical_solution":"solution :: [Int] -> Int\nsolution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_122","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --sa summa de sos elementos cun prus de duas tzifras dae sos primos k elementos de arr. -- dadu un'elencu non bòidu de intreos arr e unu nùmeru intreu k, torra --  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =","canonical_solution":"addElements :: [Int] -> Int -> Int\naddElements arr k = sum $ filter (\\x -> x >= -99 && x <= 99) $ take k arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_123","nl":"srd_Latn","pl":"hs","prompt":"--get_odd_collatz(5) torrat [1, 5] # Sa secuèntzia de collatz pro 5 est [5, 16, 8, 4, 2, 1], tando sos nùmeros disparios sunt solu 1, e 5. --Pro esèmpiu: --2. lista torradu ordinadu in òrdine creschende. --1. Collatz(1) est [1]. --Nota: --su tèrmine prus 1. Sa conjetura est chi no importat cale balore de n, sa secuèntzia at a lòmpere semper a 1. --Si su tèrmine pretzedente est dispare, su tèrmine imbeniente est 3 bortas su pretzedente.--tèrmine pretzedente comente sighit: si su tèrmine pretzedente est paris, su tèrmine imbeniente est sa metade de --comente sighit: cumintzare cun cale si siat nùmeru intreu positivu n. Tando cada tèrmine est otentu dae sa --Sa congetura de Collatz est una congetura in matemàtica chi pertocat una secuèntzia definida -- Si b'at unu nùmeru intreu positivu n, torrat una lista ordinada chi tenet sos nùmeros disparios in secuèntzia collatz. --  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =","canonical_solution":"getOddCollatz :: Int -> [Int]\ngetOddCollatz n = sort . filter odd $ collatzSequence n\n  where\n    collatzSequence 1 = [1]\n    collatzSequence x\n      | even x    = x : collatzSequence (x `div` 2)\n      | otherwise = x : collatzSequence (3 * x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_124","nl":"srd_Latn","pl":"hs","prompt":"--Sa data depet èssere in su formadu: mm-dd-aaaa --3. Sos meses non diant dèpere èssere prus pagu de 1 e prus artos de 12.--Su nùmeru de dies non est prus pagu de 1 o prus mannu de 31 dies pro sos meses 1,3,5,7,8,10,12. E su nùmeru de dies non est prus pagu de 1 o prus mannu de 30 dies pro sos meses 4,6,9,11. E, su nùmeru de dies non est prus pagu de 1 o prus mannu de 29 pro su mese 2.--1. Sa cadena de sa data no est bòida.--Sa data est vàlida si sunt cumpiladas totu sas règulas sighentes: --retzeret True si sa data est vàlida, si no False. -- depes iscrìere una funtzione chi validat una cadena de datas dada e --  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06\/04\/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =","canonical_solution":"import Text.Read (readMaybe)\nimport Data.List.Split (splitOn)\n\nvalidDate :: String -> Bool\nvalidDate date =\n    case splitOn \"-\" date of\n        [m, d, y] -> isValidMonthDayYear m d y\n        _         -> False\n\nisValidMonthDayYear :: String -> String -> String -> Bool\nisValidMonthDayYear m d y =\n    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of\n        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day\n        _ -> False\n\nisValidMonth :: Int -> Bool\nisValidMonth month = month >= 1 && month <= 12\n\nisValidDay :: Int -> Int -> Bool\nisValidDay month day\n    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31\n    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30\n    | month == 2                           = day >= 1 && day <= 29\n    | otherwise                            = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_126","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios --nùmeru, torrat False. Assumet chi non bi siant nùmeros negativos e solu intreos.--in òrdine creschente. Si sa lista tenet prus de 1 duplicadu de su matessi--☐ Si tenet una lista de nùmeros, torrat si sunt ordinados o no--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =","canonical_solution":"isSorted :: [Int] -> Bool\nisSorted lst = go lst Nothing\n  where\n    go [] _ = True\n    go [x] _ = True\n    go (x:y:xs) prev\n      | x > y = False\n      | x == y && prev == Just x = False\n      | otherwise = go (y:xs) (Just x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_127","nl":"srd_Latn","pl":"hs","prompt":"--[input\/output] campiones: --Si sos duos intervalles non s'intersecant, torrat \"NO\".--in casu contràriu, torrat \"NO\". --Si sa longària de s'intersecatzione est unu nùmeru primu, torrat \"SI\", --chi sa longària sua est 1, chi no est unu nùmeru primu.--Esèmpiu, s'intersecatzione de sos intervalles (1, 3), (2, 4) est (2, 3) --intervalles est unu nùmeru primu. --Sa tarea tua est de determinare si sa longària de s'intersecatzione de custos duos --Pro cada intervalu dadu, si suponet chi s'incumintzu suo siat minore o uguale a sa fine sua.--includet siat s'incumintzu siat sa fine. --Sos intervalles dados sunt serrados chi signìficat chi s'intervallu (cumentzu, fine) --ue cada intervalu est una pariga de intreos.--☐ Si ti sunt dados duos intervalles, ☐--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =","canonical_solution":"intersection :: (Int, Int) -> (Int, Int) -> String\nintersection (start1, end1) (start2, end2) = \n    if intersectionLength > 0 && isPrime intersectionLength\n    then \"YES\"\n    else \"NO\"\n  where\n    intersectionStart = max start1 start2\n    intersectionEnd = min end1 end2\n    intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    isPrime :: Int -> Bool\n    isPrime n\n      | n <= 1 = False\n      | n == 2 = True\n      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_128","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --Nota: torrat nudda pro arr.--de cada nùmeru in s'elencu, rapresentadu dae 1, -1 o 0. --summa de mannàrias de intreos multiplicada pro su produtu de totu sos signos -- Ti est dadu una lista de nùmeros intreos e depes torrare --  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =","canonical_solution":"prodSigns :: [Int] -> Maybe Int\nprodSigns [] = Nothing\nprodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_129","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Torrat una lista ordinada de sos balores de sas tzèllulas chi su percursu mìnimu colat. --Est garantidu chi sa risposta est ùnica. --lst_A[j] = lst_B[j]. --de manera chi lst_A[i] < lst_B[i] e pro cale si siat j (1 <= j < i) tenimus --de lst_B, in àteras paràulas, esistit un'inditze intreu i (1 <= i <= k) --pro mèdiu de (chamemus issos lst_A e lst_B), lst_A est in manera lessicogràfica prus pagu --a pustis de àere fatu sas listas ordinadas de sos balores in sas tzèllulas chi A e B andant --Unu percursu A (de longària k) est cunsideradu prus minore de unu percursu B (de longària k) si --Non si podet andare a foras de sa retza.--necessariamente distintu).--Si pregat de ammentare chi unu percursu de longària k signìficat chi si sunt visitadas pròpiu k tzèllulas (no --tzione.--in àteras paràulas, si podet andare a tzèllulas chi cumpartzint un'oru cun sa currente --dae cale si siat tzèllula, e in cada passu si podet mòvere a cale si siat de sas tzèllulas a curtzu, --Devimus agatare su caminu mìnimu de sa longària k in sa retza.--inclusiva aparesset petzi una borta in sas tzèllulas de sa retza. --ogni tzella de sa retza cuntenet unu balore. Onzi nùmeru intreu in su rangu [1, N * N] -- Si donat una retza cun N rigas e N colunnas (N >= 2) e unu nùmeru intreu positivu k, --  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =","canonical_solution":"import Data.List (sort, sortBy)\nimport Data.Ord (comparing)\nimport Control.Monad (guard)\n\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k = head $ sort paths\n  where\n    n = length grid\n    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]\n    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n      where\n        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n\n    value (r, c) = grid !! r !! c\n    paths = do\n      start <- cells\n      findPaths k [start]\n    findPaths 1 path = return $ map value path\n    findPaths l path@(current:_) = do\n      next <- neighbors current\n      findPaths (l-1) (next : path)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_130","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --sos primos n + 1 nùmeros de sa secuèntzia de Tribonacci. --Ti est dadu unu nùmeru intreu non-negativu n, depes torrare una lista de sos nùmeros intreales chi tenes.--= 2 + 3 + 3 = 8 --tri(3) = tri(2) + tri(1) + tri(4) --tri(4) = 3 --tri(2) = 1 + (2 \/ 2) = 2 --Pro esèmpiu: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est dispare. --tri (n) = 1 + n \/ 2, si n est paris. --tri(1) = 3 --Sa secuèntzia de Tribonacci est definida dae sa recurrèntzia: --In cada manera, su chi sa gente no connoschet est sa secuèntzia de Tribonacci.--Totus connoschent sa secuèntzia de Fibonacci, est istada istudiada a fundu dae sos matemàticos in su--  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =","canonical_solution":"tri :: Int -> [Int]\ntri n = map tribonacci [0..n]\n  where\n    -- Define the recursive function to calculate the tribonacci value for a given n\n    tribonacci :: Int -> Int\n    tribonacci 0 = 1\n    tribonacci 1 = 3\n    tribonacci x\n      | even x    = 1 + x `div` 2\n      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_131","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Torrat 0 si totu sas tzifras sunt paris. -- Si tenimus unu nùmeru intreu positivu n, torrat su produtu de sas tzifras disparias. --  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =","canonical_solution":"digits :: Int -> Int\ndigits n\n  | null oddDigits = 0\n  | otherwise      = product oddDigits\n  where\n    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_132","nl":"srd_Latn","pl":"hs","prompt":"--in ue a su nessi una de sas parèntesi in sa sutasegèntzia est imbentada. --Sa funtzione depet torrare True si e solu si b' at una sutasegèntzia vàlida de parentesias -- Creare una funtzione chi pigat una cadena comente input chi cuntenet petzi parentesi cuadrada. --  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =","canonical_solution":"isNested :: String -> Bool\nisNested string = go string 0 False\n  where\n    go [] _ nested = nested\n    go (x:xs) depth nested\n      | x == '['  = go xs (depth + 1) (nested || depth >= 1)\n      | x == ']' && depth > 0 = go xs (depth - 1) nested\n      | otherwise = go xs depth nested","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_133","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --arrotondare a su primu ogni elementu de sa lista a su tesu de su tesu.--Deves torrare sa summa de sos nùmeros cuadrados in sa lista dada, --❑ Ti sunt dados una lista de nùmeros.--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =","canonical_solution":"import Data.List (foldl')\nimport Prelude hiding (sum)\n\nsumSquares :: [Float] -> Int\nsumSquares lst = foldl' (\\acc x -> acc + ceiling x ^ 2) 0 lst","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_134","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Nota: \"paràula\" est unu grupu de caràteres separados dae unu ispàtziu. --una parte de una paràula, e falsa in manera contrària.--de una cadena dada est unu caràtere alfabèticu e non est --Creare una funtzione chi torrat True si s'ùrtimu caràtere est --  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =","canonical_solution":"checkIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt = \n    let trimmed = reverse . dropWhile (== ' ') $ reverse txt\n    in case trimmed of\n        [] -> False\n        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_135","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --balores duplicados. --no esistit un'elementu de custa genia, tando torrat -1. Sa lista dada no at a cuntènnere --no est prus mannu o uguale a s'elementu chi dd'agatat in manera immediata in antis.--Creare una funtzione chi torrat s'inditze prus mannu de un'elementu chi--  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =","canonical_solution":"canArrange :: [Int] -> Int\ncanArrange arr = go arr (-1) 0\n  where\n    go [] maxIdx _ = maxIdx\n    go [_] maxIdx _ = maxIdx\n    go (x:y:xs) maxIdx idx\n      | x >= y    = go (y:xs) idx (idx + 1)\n      | otherwise = go (y:xs) maxIdx (idx + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_136","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Si non b'at nùmeros intreos negativos o positivos, torrat comente Nada.--de nùmeros intreos positivos in un'elencu. --su prus mannu de sos intreos negativos, e \"b\" est su prus minore -- Creare una funtzione chi torrat unu tupla (a, b), ue 'a' est --  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =","canonical_solution":"largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst = (largestNegative, smallestPositive)\n  where\n    negatives = filter (< 0) lst\n    positives = filter (> 0) lst\n    largestNegative = if null negatives then Nothing else Just (maximum negatives)\n    smallestPositive = if null positives then Nothing else Just (minimum positives)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_138","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu -- Avalai si su nùmeru dadu n podet èssere iscritu comente a sa summa de 4 nùmeros paris positivos.--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =","canonical_solution":"isEqualToSumEven :: Int -> Bool\nisEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_139","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --ue n > 0 --brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! --Su fatòriu brasilianu est definidu comente:--  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =","canonical_solution":"specialFactorial :: Int -> Int\nspecialFactorial n = product [factorial x | x <- [1..n]]\n  where\n    factorial 0 = 1\n    factorial k = k * factorial (k - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_140","nl":"srd_Latn","pl":"hs","prompt":"--tando remplasare totu sos ispàtzios cunseguentes cun - --e si una cadena tenet prus de 2 ispàtzios cunseguentes, --☐ Si b'at una cadena de testu, sostituire totu sos ispàtzios cun sos puntos a suta, ☐--  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =","canonical_solution":"fixSpaces :: String -> String\nfixSpaces text = concatMap replaceSpaces (groupSpaces text)\n  where\n    groupSpaces :: String -> [String]\n    groupSpaces [] = []\n    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest\n\n    replaceSpaces :: String -> String\n    replaceSpaces spaces@(x:_)\n      | x == ' ' && length spaces > 2 = \"-\"\n      | x == ' ' = replicate (length spaces) '_'\n      | otherwise = spaces","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_141","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Sa substring a pustis de su puntu diat dèpere èssere una de custas: ['txt', 'exe', 'dll'] --s'alfabetu latinu ('a'-'z' e 'A'-'Z'). --- Sa sotziedade prima de su puntu non depet èssere bòida, e comintzat cun una lìtera de --- Su nùmene de su documentu cuntenet unu puntu '.' --- Non si depent impreare prus de tres tzifras ('0'-'9') in su nùmene de su documentu. --sunt cumpilados: --Unu nùmene de archìviu est cunsideradu bàlidu si e solu si totu sas cunditziones sighentes sunt cumpiladas:--\"Yes\" si su nùmene de su documentu est bàlidu, e torrat \"No\" in casu contràriu. -- Creare una funtzione chi pigat una cadena chi rapresentat su nùmene de unu file, e torrat --  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =","canonical_solution":"import Data.Char (isDigit, isLetter)\n\nfileNameCheck :: String -> String\nfileNameCheck file_name \n  | countDots \/= 1 = \"No\"\n  | length digits > 3 = \"No\"\n  | null beforeDot || not (isLetter (head beforeDot)) = \"No\"\n  | afterDot `notElem` validExtensions = \"No\"\n  | otherwise = \"Yes\"\n  where \n    (beforeDot, afterDot) = span (\/= '.') file_name\n    countDots = length $ filter (== '.') file_name\n    digits = filter isDigit file_name\n    validExtensions = [\"txt\", \"exe\", \"dll\"]\n    afterDot = if null dotAndAfter then \"\" else tail dotAndAfter\n    dotAndAfter = dropWhile (\/= '.') file_name","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"\/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_142","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --cambiai is iscritzionis in sa lista chi is indicis no funt unu multiplicu de 3 o 4.--sa funtzione no at a èssere --Pro totu sas intradas in sa lista, sa funtzione at a cuadrare s'intrada intregu si s'inditzu suo est --\" ◊ su chi cheret--  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =","canonical_solution":"sumSquares :: [Int] -> Int\nsumSquares lst = sum $ zipWith transform [0..] lst\n  where\n    transform idx x\n      | idx `mod` 3 == 0 = x * x\n      | idx `mod` 4 == 0 = x * x * x\n      | otherwise        = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_143","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu 1: --s'òrdine de sas paràulas in sa cadena noa depet èssere su matessi de su originale. --chi sas longas sunt nùmeros primos, --E depes torrare una cadena chi cuntenet sas paràulas de sa frase originale, --sa frase cuntenet carchi paràula separada dae unu ispàtziu, --❑ Si ti donat una cadena chi rapresentat una frase, ❑--  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =","canonical_solution":"import Data.List (intercalate)\n\nwordsInSentence :: String -> String\nwordsInSentence sentence = intercalate \" \" $ filter (isPrime . length) (words sentence)\n\nisPrime :: Int -> Bool\nisPrime n | n < 2     = False\n          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_144","nl":"srd_Latn","pl":"hs","prompt":"--Podimus nàrrere chi x e n sunt fratziones vàlidas e non tenent zeru comente a denominadore.--<numerator>\/<denominator> ue siat numerador siat denominador sunt nùmeros intreos positivos. --Siat x siat n, sunt rapresentatzione de cadena de una fratzione, e tenent su formadu sighente, --x * n. Sa funtzione torrat True si x * n est unu nùmeru intreu e False -- Su traballu tuo est de implementare una funtzione chi at a simplificare s'espressione --  >>> simplify \"1\/5\" \"5\/1\"\n--  True\n--  >>> simplify \"1\/6\" \"2\/1\"\n--  False\n--  >>> simplify \"7\/10\" \"10\/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =","canonical_solution":"import Data.Ratio (denominator, numerator, (%))\n\nsimplify :: String -> String -> Bool\nsimplify x n =\n  let (xNum, xDen) = toFraction x\n      (nNum, nDen) = toFraction n\n      result = (xNum * nNum) % (xDen * nDen)\n  in denominator result == 1\n\ntoFraction :: String -> (Integer, Integer)\ntoFraction s =\n  let (numStr, _:denStr) = break (=='\/') s\n  in (read numStr, read denStr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/6\" \"2\/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/1\" \"3\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/10\" \"10\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/10\" \"50\/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/2\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11\/6\" \"6\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/3\" \"5\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/2\" \"3\/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"8\/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"1\/5\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_145","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --ordinados a base de s'indice issoro in sa lista originale.--Nota: si b'at medas elementos cun summa sìmiles de sas tzifras issoro, --in òrdine creschente segundu sa summa de sas tzifras issoro. -- Iscriere una funtzione chi ordinat sa lista de sos intreos --  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =","canonical_solution":"import Data.List (sortBy)\nimport Data.Function (on)\n\norderByPoints :: [Int] -> [Int]\norderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums\n  where\n    sumOfDigits :: Int -> Int\n    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)\n    \n    indexedNums :: [(Int, Int)]\n    indexedNums = zip (map sumOfDigits nums) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_146","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --sa prima e s'ùrtima tzifras de unu nùmeru sunt dispàngias (1, 3, 5, 7, 9).--su nùmeru de elementos in s'elencu chi sunt prus de 10 e ambos -- Iscriere una funtzione chi pigat una lista de nùmeros comente input e torrat --  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =","canonical_solution":"specialfilter :: [Int] -> Int\nspecialfilter nums = length $ filter isSpecial nums\n  where\n    isSpecial n = n > 10 && isOddFirstAndLast (abs n)\n\n    isOddFirstAndLast :: Int -> Bool\n    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit\n      where\n        xStr = show x\n        firstDigit = head xStr\n        lastDigit = last xStr\n\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_147","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --e a[i] + a[j] + a[k] est unu mùltiple de 3. --Torrat su nùmeru de triplicados (a[i], a[j], a[k]) de a ue i < j < k, --Pro cada i (1 ≤ i ≤ n), su balore de a[i] = i * i - i + 1. -- Ti est dadu unu nùmeru intreu positivu n. Deves creare una lista de nùmeros intraeles a de longària n. --  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =","canonical_solution":"getMaxTriples :: Int -> Int\ngetMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]\n  where\n    a = [i * i - i + 1 | i <- [1..n]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_149","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --Podet èssere prevìdidu chi totu sas paràulas ant a tènnere sa matessi longària.--Sa funtzione depet torrare una lista de cadenas in òrdine ordinadu.--Si duas paràulas tenent sa matessi longària, ordinare sa lista in òrdine alfabèticu. --diat dèpere torrare sa lista ordinada cun cussa règula. --S'òrdine de sa lista depet èssere a crèschida pro longària de ogni paràula, e tue --e podet cuntènnere duplicados.--Sa lista est semper una lista de cadenas e mai una lista de nùmeros, --e torrat sa lista chi est resurtada cun un'òrdine ordinadu, --iscancella sos caràteres chi tenent longasas dispàngias dae issa, -- Iscriere una funtzione chi atzetat una lista de cadenas comente a paràmetru, --  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =","canonical_solution":"sortedListSum :: [String] -> [String]\nsortedListSum lst = sortBy compareStrings (filter evenLength lst)\n  where\n    evenLength s = even (length s)\n    compareStrings s1 s2\n      | length s1 == length s2 = compare s1 s2\n      | otherwise = compare (length s1) (length s2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_150","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --unu nùmeru primu e diat dèpere torrare su balore de y in casu contràriu. --Unu programma simpre chi diat dèpere torrare su balore de x si n est --  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =","canonical_solution":"xOrY :: Int -> Int -> Int -> Int\nxOrY n x y = if isPrime n then x else y\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_151","nl":"srd_Latn","pl":"hs","prompt":"--Ignorare sos nùmeros negativos o non intreos.-- Si nos dat una lista de nùmeros, torrat sa summa de sos cuadrados de sos nùmeros --  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =","canonical_solution":"doubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst = \n    sum [x * x | x <- map round lst, x > 0, odd x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_152","nl":"srd_Latn","pl":"hs","prompt":"--esèmpiu: --su balore est 0, e si no est gasi, su balore est sa diferèntzia assoluta intre s'aprovu e su puntu. --Torrat una lista de sa matessi longària chi denotat cantu fiat distante ogni indovinamentu.--Ti sunt dados duos listas de puntuaziones e indovinamentos de longària eguale, in ue cada indice mustrat una currispondèntzia.--Su compitu tuo est de determinare si una persone at indovinadu in manera curreta sos resurtados de unu nùmeru de partzidas.--de seguru chi meritat de si notare e de si cunfrontare.--s'eventu est a sa fine connotu. Is sentimentos e is pensamentos chi tenes in cussu momentu sunt--Penso chi totus nos ammentamus de cussa sentida cando su resurtadu de carchi cosa de meda isperada--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =","canonical_solution":"compare :: [Int] -> [Int] -> [Int]\ncompare game guess = zipWith (\\g s -> abs (g - s)) game guess","tests":"\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_153","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --(sa fortza sua est -1).--torrat \"Slices.SErviNGSliCes\" ca \"SErviNGSliCes\" est s'estensione prus forte --estensiones: ['SErviNGSliCes', 'Cheese', 'StuFfed'] tando diat dèpere --Pro esèmpiu, si ti est dadu \"Slices\" comente a sa classe e un'elencu de sos --iscelta su chi benit a primu in sa lista. --Si b' at duas o prus estensiones cun sa matessi fortza, depes --format: ClassName.StrongestExtensionName. --Deves agatare s'estensione prus forte e torrare una cadena in custa .--in su nùmene de s'estensione, sa fortza est dada dae sa fratzione CAP - SM. --lìteras in su nùmene de s'estensione, e siant SM su nùmeru de lìteras minores --sa fortza de s'estensione est sa chi sighit: Siat CAP su nùmeru de su carattere maiusculu --Sas estensiones sunt de impreare pro carrigare classes agiuntivas a sa classe.-- Ti ant a dare su nùmene de una classe (una cadena) e una lista de estensiones. --  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =","canonical_solution":"strongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions = class_name ++ \".\" ++ strongestExt\n  where\n    calculateStrength :: String -> Int\n    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)\n    \n    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)\n    \n    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)\n    maxStrength ext1 ext2\n      | snd ext1 > snd ext2 = ext1\n      | otherwise           = ext2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_154","nl":"srd_Latn","pl":"hs","prompt":"--Ti sunt dados 2 paràulas. Deves torrare True si sa segunda paràula o una de sas rotatziones suas est una suta-serra in sa prima paràula.--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =","canonical_solution":"cycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b = any (`isInfixOf` a) rotations\n  where\n    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_155","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --DATA unu nùmeru intreu, torrat unu tuple chi tenet su nùmeru de tzifras paris e disparias rispettivamente.--  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =","canonical_solution":"evenOddCount :: Int -> (Int, Int)\nevenOddCount num = (length evens, length odds)\n  where\n    digits = map (read . (:[])) . show . abs $ num\n    evens = filter even digits\n    odds  = filter odd digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_156","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios: --Limìteras: 1 <= num <= 1000 --e torra·lu in lìteras minores. -- Dadu unu nùmeru intreu positivu, otenet s'ecuivalente numèricu romanu suo comente a una cadena, --  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =","canonical_solution":"intToMiniRoman :: Int -> String\nintToMiniRoman number = concatMap (replicateSymbol number) romanNumerals\n  where\n    romanNumerals = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n                     (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n                     (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    \n    replicateSymbol :: Int -> (Int, String) -> String\n    replicateSymbol n (value, symbol)\n      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)\n      | otherwise = \"\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_157","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --90 grados. --Unu triàngulu retzìdu est unu triàngulu in ue unu de sos àngulos est retzìdu o --sos lados formant unu triàngulu retzìculare, Falsos in manera contrària.--Dadu chi sas longas de sos tres lados de unu triàngulu torrant a beru si sos tres lados de su triàngulu sunt longos de su matessi puntu.--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =","canonical_solution":"rightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c = \n    let [x, y, z] = sort [a, b, c]\n    in x^2 + y^2 == z^2\n    where sort = Data.List.sort","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_158","nl":"srd_Latn","pl":"hs","prompt":"--carateres, torrat su chi benit a primu in òrdine lessicogràficu. --Si medas cadenas tenent su nùmeru màssimu de caràteres ùnicos --Sa lista cuntenet paràulas diferentes. Torra sa paràula cun nùmeru màssimu -- Iscriere una funtzione chi atzetat una lista de cadenas. --  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =","canonical_solution":"import Data.List (nub, sort)\n\nfindMax :: [String] -> String\nfindMax words = \n    head . sort . map snd . filter (\\(n, _) -> n == maxUnique) $ wordUniquePairs\n  where\n    wordUniquePairs = [(length . nub $ word, word) | word <- words]\n    maxUnique = maximum $ map fst wordUniquePairs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_159","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpiu: --si non b'at bastante carrotzas abarradas, as a mandigare totu sas carrotzas abarradas, ma a s'imbesse as a tènnere gana.--su nùmeru de zigarros chi abarrant a pustis de sos pranos tuos ] --depes torrare una lista de [ nùmeru totale de zigarros consumados a pustis de sos pranzos, --ma como depes mandigare prus zigarros pro cumpletare sos pranos de sa die.--❑ Ses unu conìgliu affamadu, e as giai papadu unu tzertu nùmeru de zigarros, ❑--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =","canonical_solution":"eat :: Int -> Int -> Int -> [Int]\neat number need remaining\n  | remaining >= need = [number + need, remaining - need]\n  | otherwise = [number + remaining, 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_160","nl":"srd_Latn","pl":"hs","prompt":"--Sa lista de operadores tenet a su mancu un'operadore, e sa lista de operandos tenet a su mancu duos operandos.--S'operandu est una lista de intreos non negativos.--Sa longària de sa lista de operadores est uguale a sa longària de sa lista de operandos mèigu unu.--Nota: --=> resurtadu = 9 --su resurtadu = 2 + 3 * 4 - 5 --lista = [2, 3, 4, 5] --operadore['+', '*', '-'] --Esèmpiu: --Esponentziatzione (**) --Divisione de su pavimentu ( \/\/ ) --Multiplicatzione ( *) --Subratzione ( - ) --Addition ( + ) --Sas operatziones de base de àlgebra: --espressione e torrat s'isbaloramentu de custa espressione. --Sa segunda lista est una lista de intreos. Utilizade sas duas listas pro fraigare s'àlgebra.--Sa prima lista tenet operatziones de base de àlgebra, e sa segunda lista tenet operatziones de base de matemàtica.doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =","canonical_solution":"doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand = evaluate operand operator\n  where\n    evaluate [x] [] = x\n    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops\n      where\n        result = applyOperation op x y\n\n    applyOperation \"+\" a b = a + b\n    applyOperation \"-\" a b = a - b\n    applyOperation \"*\" a b = a * b\n    applyOperation \"\/\/\" a b = a `div` b\n    applyOperation \"**\" a b = a ^ b\n    applyOperation _ _ _ = error \"Unsupported operation\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"\/\/\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_161","nl":"srd_Latn","pl":"hs","prompt":"--Esèmpios --Sa funtzione depet torrare sa cadena chi at tentu su resurtadu.--Si sa cadena no cuntenet lìteras, invertire sa cadena.--si no lassat comente sunt.--si s[i] est una lìtera, invertire sa cassa sua de bassu a artu o a s'imbesse, --☐ Si ti est dadu una cadena de caràteres ☐--  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =","canonical_solution":"solve :: String -> String\nsolve s\n  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s\n  | otherwise = reverse s\n  where\n    toggleCase c\n      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char\n      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_162","nl":"srd_Latn","pl":"hs","prompt":"--Si 'text' est una cadena bòida, torrat Nada. --☐ Si b'at una cadena de testu, torra sa cadena de hash md5 sua.--  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =","canonical_solution":"import qualified Data.ByteString.Char8 as C\nimport qualified Data.Digest.Pure.MD5 as MD5\n\nstringToMd5 :: String -> Maybe String\nstringToMd5 text\n  | null text = Nothing\n  | otherwise = Just $ show $ MD5.md5 $ C.pack text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_163","nl":"srd_Latn","pl":"hs","prompt":"--Pro esèmpiu: --e b, in òrdine creschente. --Dae duos intreos positivos a e b, torrat sas tzifras paris intre a e b.--  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =","canonical_solution":"generateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b = filter even [min a b .. max a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()"}]