[{"task_id":"HumanEval_0","nl":"amh_Ethi","pl":"hs","prompt":"-- የዋጋ ግሽበት--በቁጥሮች ዝርዝር ውስጥ ከሁለት ቁጥሮች መካከል አንዱ ከሌላው ጋር ቅርብ ከሆነ ቼክ ያድርጉ--  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =","canonical_solution":"hasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold = any (\\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a \/= b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_1","nl":"amh_Ethi","pl":"hs","prompt":"--በመግቢያ ሕብረቁምፊ ውስጥ ያሉትን ክፍተቶች ችላ ይበሉ--የተለያዩ ቡድኖች ሚዛናዊ ናቸው (እያንዳንዱ ክፍት ብሬክ በትክክል ተዘግቷል) እና እርስ በእርስ አልተጣበቁም ።--እነዚህን ቡድኖች ወደ ተለያዩ ሰንሰለቶች ይለዩና የእነዚህን ዝርዝር ይመልሱ ።--የ \"የተጠለፉ ቅንፍ\" በርካታ ቡድኖች የያዘ አንድ ሕብረቁምፊ ነው. የእርስዎ ግብ ነው --  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =","canonical_solution":"separateParenGroups :: String -> [String]\nseparateParenGroups paren_string = go paren_string 0 [] \"\" []\n  where\n    go [] _ _ current acc = if null current then acc else acc ++ [current]\n    go (x:xs) depth stack current acc\n      | x == ' ' = go xs depth stack current acc\n      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc\n      | x == ')' =\n          let newCurrent = current ++ [x]\n              newDepth = depth - 1\n          in if newDepth == 0\n             then go xs newDepth (tail stack) \"\" (acc ++ [newCurrent])\n             else go xs newDepth (tail stack) newCurrent acc\n      | otherwise = error \"Unexpected character\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_2","nl":"amh_Ethi","pl":"hs","prompt":"--የቁጥር አሥርኛ ክፍል ይመልሱ. --(የቀሪው ክፍል ሁልጊዜ ከ 1 ያነሰ ነው) ።--እና ሙሉ ቁጥር ክፍል (ከቀረበው ቁጥር ያነሰ ትልቁ ሙሉ ቁጥር) እና አሥርዮሽ --❑ አዎንታዊ የሆነ ተንሳፋፊ ነጥብ ቁጥር ከተሰጠ፣ ወደ ❑ ሊበታተን ይችላል--  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =","canonical_solution":"truncateNumber :: Float -> Float\ntruncateNumber number = number - fromIntegral (floor number)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_3","nl":"amh_Ethi","pl":"hs","prompt":"--በዚህ ነጥብ ላይ ተግባር እውነት መመለስ አለበት. አለበለዚያ ግን ሐሰት መመለስ አለበት.--የእርስዎ ተግባር በማንኛውም ነጥብ ላይ የሂሳብ ቀሪ ከዜሮ በታች ቢወድቅ ማወቅ ነው, እና --በባንክ ሂሳብ ላይ የሚደረጉ ተቀማጭ እና የማስወጣት ስራዎች ዝርዝር ይሰጥዎታል--  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =","canonical_solution":"belowZero :: [Int] -> Bool\nbelowZero operations = any (< 0) $ scanl (+) 0 operations","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_4","nl":"amh_Ethi","pl":"hs","prompt":"--MAD = አማካይ  x - x_mean --ንጥረ ነገር እና ማዕከላዊ ነጥብ (በዚህ ሁኔታ አማካይ)--አማካይ ፍፁም መዛባት በእያንዳንዱ  መካከል ያለው አማካይ ፍፁም ልዩነት ነው--በዚህ የውሂብ ስብስብ አማካይ አካባቢ.--❑ ለተሰጠ የግብዓት ቁጥሮች ዝርዝር አማካይ ፍፁም መዛባት አስቀምጥ--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =","canonical_solution":"meanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers = sum absoluteDifferences \/ fromIntegral (length numbers)\n  where\n    mean = sum numbers \/ fromIntegral (length numbers)\n    absoluteDifferences = map (\\x -> abs (x - mean)) numbers","tests":"\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_5","nl":"amh_Ethi","pl":"hs","prompt":"--በሁለት ተከታታይ የግብዓት ዝርዝር ክፍሎች መካከል 'የመለያ' ቁጥር ያስገቡ--  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =","canonical_solution":"intersperse :: [Int] -> Int -> [Int]\nintersperse [] _ = []\nintersperse [x] _ = [x]\nintersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_6","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ (() (()) ከፍተኛው ሁለት ደረጃዎች አሉት ፣ ((())) ደግሞ ሶስት አለው ። --ለእያንዳንዱ ቡድን ጥልቀት ያለው የቅንፍ ደረጃ ይለጥፉ።-- የዚህ ተግባር ግብዓት በቦታዎች የተለዩ የተጣበቁ ቅንፍዎችን በርካታ ቡድኖችን የሚወክል ሰንሰለት ነው ።--  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =","canonical_solution":"parseNestedParens :: String -> [Int]\nparseNestedParens paren_string = map maxDepth (words paren_string)\n  where\n    maxDepth :: String -> Int\n    maxDepth = go 0 0\n      where\n        go :: Int -> Int -> String -> Int\n        go currentDepth maxDepth [] = maxDepth\n        go currentDepth maxDepth (c:cs)\n          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs\n          | c == ')'  = go (currentDepth - 1) maxDepth cs\n          | otherwise = go currentDepth maxDepth cs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_7","nl":"amh_Ethi","pl":"hs","prompt":"--❑ የተሰጡትን ንዑስ ገመዶች ብቻ የያዘውን የ ገመዶች ዝርዝር ማጣራት--  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =","canonical_solution":"filterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring = filter (substring `isInfixOf`) strings\n  where isInfixOf = isInfixOf","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_8","nl":"amh_Ethi","pl":"hs","prompt":"--ባዶ ድምር እኩል መሆን አለበት 0 እና ባዶ ምርት እኩል መሆን አለበት 1.--❑ ለተሰጠ የሙሉ ቁጥሮች ዝርዝር፣ በዝርዝሩ ውስጥ ያሉትን የሙሉ ቁጥሮች ድምር እና ውጤት ያካተተ የቱፕል ቁጥር ይመልሱ--  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =","canonical_solution":"sumProduct :: [Int] -> (Int, Int)\nsumProduct numbers = (sum numbers, product numbers)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_9","nl":"amh_Ethi","pl":"hs","prompt":"-- አድራሻ--❑ ከተሰጠ የሙሉ ቁጥሮች ዝርዝር እስከ ተሰጠበት ጊዜ ድረስ የተገኘውን ከፍተኛውን የቁጥር ዝርዝር ያመነጫል።--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =","canonical_solution":"rollingMax :: [Int] -> [Int]\nrollingMax = scanl1 max","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_10","nl":"amh_Ethi","pl":"hs","prompt":"--- ከፓሊንድሮም ቅጥያ በፊት የሚመጣ የቁጥር ቅድመ ቅጥያ ወደ ገመድ መጨረሻው ኋላ ይጨምሩ ።--- አንድ palindrome ነው የተሰጠውን ሕብረቁምፊ ረዥሙ postfix ያግኙ. --የአልጎሪዝም ሀሳብ ቀላል ነው: --☞ በተሰጠው ሕብረቁምፊ የሚጀምር አጭሩን ፓሊንድሮም ፈልግ።--  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =","canonical_solution":"makePalindrome :: String -> String\nmakePalindrome string = string ++ reverse (take (length string - palindromeLength) string)\n  where\n    palindromeLength = longestPalindromicSuffix string\n\nlongestPalindromicSuffix :: String -> Int\nlongestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]\n\nisPalindrome :: String -> Bool\nisPalindrome s = s == reverse s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_11","nl":"amh_Ethi","pl":"hs","prompt":"--በእነዚህ ግብዓቶች ላይ የሁለትዮሽ XOR ያከናውኑ እና ውጤቱን እንደ ሰንሰለት ይመልሱ ።--፦ ግብዓት ሁለት ሕብረቁምፊዎች ናቸው ሀ እና ቢ በ 1 እና በ 0 ብቻ የተዋቀሩ ናቸው--  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =","canonical_solution":"stringXor :: String -> String -> String\nstringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_12","nl":"amh_Ethi","pl":"hs","prompt":"--ተመሳሳይ ርዝመት ያላቸው ሕብረቁምፊዎች። የግብዓት ዝርዝር ባዶ ከሆነ ምንም አይመልስም።--❑ ከዝርዝሩ ውስጥ በጣም ረጅሙን ይመልሱ ❑ ብዙ ከሆነ የመጀመሪያውን ይመልሱ ❑ ብዙ ከሆነ የመጀመሪያውን ይመልሱ ❑ ብዙ ከሆነ የመጀመሪያውን ይመልሱ ❑ ብዙ ከሆነ ሁለተኛውን ይመልሱ--  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =","canonical_solution":"longest :: [String] -> Maybe String\nlongest [] = Nothing\nlongest strings = Just $ foldl1 (\\acc x -> if length x > length acc then x else acc) strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_13","nl":"amh_Ethi","pl":"hs","prompt":"--የሁለት ሙሉ ቁጥሮች ሀ እና ለ ትልቁን የጋራ አከፋፋይ ይመልሱ--  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =","canonical_solution":"greatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b\n  | b == 0    = a\n  | otherwise = greatestCommonDivisor b (a `mod` b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_14","nl":"amh_Ethi","pl":"hs","prompt":"--☞ የሁሉም ቅድመ-ጥቅሶች ዝርዝር ከ አጭር እስከ ረዥሙ የግብዓት ሕብረቁምፊ ይመልሳል--  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =","canonical_solution":"allPrefixes :: String -> [String]\nallPrefixes string = [take n string | n <- [1 .. length string]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_15","nl":"amh_Ethi","pl":"hs","prompt":"--❑ ከ0 እስከ n ድረስ ያሉ ቦታ-የተገደቡ ቁጥሮች የያዘውን ሰንሰለት ይመልሳል።--  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =","canonical_solution":"stringSequence :: Int -> String\nstringSequence n = unwords $ map show [0..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_16","nl":"amh_Ethi","pl":"hs","prompt":"--❑ አንድን ሕብረቁምፊ ስጥ፣ ስንት የተለያዩ ቁምፊዎች (የቁምፊውን ቁጥር ሳያካትት) እንዳሉት ❑ አንድን ሕብረቁምፊ ስጥ፣ ስንት የተለያዩ ቁምፊዎች እንዳሉት ❑ አንድን ሕብረቁምፊ ስጥ፣ ስንት የተለያዩ ቁምፊዎች እንዳሉት ❑ አንድን ሕብረቁምፊ ስጥ፣ ስንት የተለያዩ ቁምፊዎች እንዳሉት ❑ አንድን ሕብረቁምፊ ስጥ፣ ስንት የተለያዩ ቁምፊዎች እንዳሉት ❑ አንድን ሕብረቁምፊ ስጥ፣ ስንት የተለያዩ ቁምፊዎች እንዳሉት ❑ አንድን ሕብረቁምፊ ስጥ፣--  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =","canonical_solution":"import Data.Char (toLower)\nimport Data.Set (fromList, size)\n\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string = size . fromList $ map toLower string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_17","nl":"amh_Ethi","pl":"hs","prompt":"--'ሃያሳ' - የክዋተር ኖት፣ አንድ ምት የሚቆይ--'ኦ ዳክዬ' - ግማሽ ማስታወሻ፣ ሁለት ድብደባዎች ይቆያል።--'ኦ' - ሙሉ ማስታወሻ፣ አራት ምት ይይዛል--አንድ አፈ ታሪክ አለ--የመጨረሻው አይደለም።--የእርስዎ ተግባር ይህን ሕብረቁምፊ ለመተንተን እና እያንዳንዱ ምን ያህል ምት የሚያደርግ ጋር የሚዛመድ ኢንቲጀር ዝርዝር መመለስ ነው --❑ የዚህ ተግባር ግብዓት ልዩ በሆነ የአስኪ ቅርጸት የሙዚቃ ማስታወሻዎችን የሚወክል ገመድ ነው።--  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =","canonical_solution":"parseMusic :: String -> [Int]\nparseMusic music_string = map beats (words music_string)\n  where\n    beats \"o\" = 4\n    beats \"o|\" = 2\n    beats \".|\" = 1\n    beats _ = 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_18","nl":"amh_Ethi","pl":"hs","prompt":"--❑ አንድን ንዑስ ሰንሰለት በዋናው ሰንሰለት ውስጥ ምን ያህል ጊዜ ማግኘት እንደሚቻል ይፈልጉ። ተደጋግፎ የሚከሰተውን ይቁጠሩ--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =","canonical_solution":"howManyTimes :: String -> String -> Int\nhowManyTimes string substring\n  | null substring = 0\n  | otherwise = length . filter isPrefixOfSubstring $ tails string\n  where\n    isPrefixOfSubstring = isPrefixOf substring\n    isPrefixOf :: Eq a => [a] -> [a] -> Bool\n    isPrefixOf prefix str = prefix `isPrefixOf` str","tests":"\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_19","nl":"amh_Ethi","pl":"hs","prompt":"--ከትንሹ እስከ ትልቁ የተደረደሩ ቁጥሮች ያሉት ሕብረቁምፊ ይመልሱ --ትክክለኛ ምርጫዎች ‹ዜሮ› ፣ ‹አንድ› ፣ ‹ሁለት› ፣ ‹ሶስት› ፣ ‹አራት› ፣ ‹አምስት› ፣ ‹ስድስት› ፣ ‹ሰባት› ፣ ‹ስምንት› እና ‹ዘጠኝ› ናቸው ። --፦ ግብዓት ከ ‹ዜሮ› እስከ ‹ዘጠኝ› ባሉ ቁጥሮች የተወሰነ የቦታ ሰንሰለት ነው ።--  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =","canonical_solution":"import Data.List (sort)\nimport Data.Maybe (fromJust)\nimport Data.Map (Map, fromList, lookup)\n\nsortNumbers :: String -> String\nsortNumbers numbers = unwords $ map snd $ sort $ map (\\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)\n  where\n    wordToNumber :: Map String Int\n    wordToNumber = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4),\n                             (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_20","nl":"amh_Ethi","pl":"hs","prompt":"--ሌሎች እና በቅደም ተከተል ይመልሱ (አነስተኛ ቁጥር ፣ ትልቅ ቁጥር) ።--❑ ከተሰጡት ቁጥሮች ዝርዝር (ከሁለት በላይ ርዝመት ያላቸው) ከሁለቱ መካከል ለእያንዳንዱ ቅርብ የሆኑትን ይምረጡና ይመልሱ--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =","canonical_solution":"findClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)\n  where\n    sortedNumbers = sort numbers\n    minByDiff (a1, b1) (a2, b2)\n      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)\n      | otherwise = (a2, b2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_21","nl":"amh_Ethi","pl":"hs","prompt":"--ስለዚህ ትንሹ ቁጥር 0 ይሆናል ትልቁ ቁጥር ደግሞ 1 ይሆናል--የቁጥሮች ዝርዝር (ቢያንስ ሁለት ንጥረ ነገሮች) የተሰጠ ፣ ወደዚያ ዝርዝር ቀጥተኛ ለውጥ ያድርጉ ፣--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =","canonical_solution":"rescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers = map (\\x -> (x - minVal) \/ range) numbers\n  where\n    minVal = minimum numbers\n    maxVal = maximum numbers\n    range = maxVal - minVal","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_23","nl":"amh_Ethi","pl":"hs","prompt":"--የተሰጠውን የ string ርዝመት ይመልሳል--  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =","canonical_solution":"strlen :: String -> Int\nstrlen string = length string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_24","nl":"amh_Ethi","pl":"hs","prompt":"--❑ ለተሰጠ ቁጥር n፣ nን በእኩል የሚከፋፍለውን ትልቁን ቁጥር ከ n ያነሰውን ፈልግ።--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =","canonical_solution":"largestDivisor :: Int -> Int\nlargestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_25","nl":"amh_Ethi","pl":"hs","prompt":"--የግብዓት ቁጥር የሁሉም ነገሮች እኩል መሆን አለበት--እያንዳንዱን ምክንያት በፋክተሪዜሽን ውስጥ ስንት ጊዜ እንደሚታይ ቁጥር ቁጥር መዘርዘር አለበት ።--☞ የተሰጠውን ጠቅላላ ቁጥር ከትንሹ እስከ ትልቁ በቅደም ተከተል የዋና አባላቱን ዝርዝር ይመልሳል።--  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =","canonical_solution":"factorize :: Int -> [Int]\nfactorize n = factorize' n 2\n  where\n    factorize' 1 _ = []\n    factorize' m f\n      | m `mod` f == 0 = f : factorize' (m `div` f) f\n      | otherwise      = factorize' m (f + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_26","nl":"amh_Ethi","pl":"hs","prompt":"--በግብዓት ውስጥ ተመሳሳይ ግራ ንጥረ ነገሮች ቅደም ተከተል ጠብቅ. --❑ ከጠቅላላ ቁጥሮች ዝርዝር ውስጥ ከአንድ ጊዜ በላይ የሚከሰቱትን ሁሉ አስወግድ።--  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =","canonical_solution":"removeDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers = filter (\\x -> count x numbers == 1) numbers\n  where\n    count x = length . filter (== x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_27","nl":"amh_Ethi","pl":"hs","prompt":"--❑ ለተሰጠ ሰንሰለት፣ ትናንሽ ፊደላትን ወደ ትልቅ ፊደል እና ትልቅ ፊደላትን ወደ ትንሽ ፊደል ይለውጡ--  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =","canonical_solution":"flipCase :: String -> String\nflipCase = map flipChar\n  where\n    flipChar c\n      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)\n      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_28","nl":"amh_Ethi","pl":"hs","prompt":"--❑ የሰንሰለት ዝርዝሮችን ወደ አንድ ነጠላ ሰንሰለት ማገናኘት--  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =","canonical_solution":"concatenate :: [String] -> String\nconcatenate strings = concat strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_29","nl":"amh_Ethi","pl":"hs","prompt":"--❑ የተሰጡትን ቅድመ-አገባቦች የሚጀምሩትን ብቻ የቁምፊዎች ዝርዝር ማጣራት።--  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =","canonical_solution":"filterByPrefix strings prefix = filter (isPrefixOf prefix) strings\n  where\n    isPrefixOf pfx str = take (length pfx) str == pfx","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_30","nl":"amh_Ethi","pl":"hs","prompt":"--❑ በዝርዝሩ ውስጥ ያሉትን አዎንታዊ ቁጥሮች ብቻ ይመልሱ--  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =","canonical_solution":"getPositive :: [Int] -> [Int]\ngetPositive l = filter (> 0) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_31","nl":"amh_Ethi","pl":"hs","prompt":"--የተሰጠው ቁጥር ዋና ከሆነ እውነት ይመልሳል ፣ አለበለዚያ ግን ሐሰት ነው።--  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =","canonical_solution":"isPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = not (any (\\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_33","nl":"amh_Ethi","pl":"hs","prompt":"--የ \"l\" ተመጣጣኝ መረጃ ጠቋሚዎች እሴቶች ጋር, ነገር ግን የተደረደሩ.--l' በሶስት የማይከፋፈሉ ኢንዴክሶች ውስጥ ከ l ጋር ተመሳሳይ ነው ፣ በሶስት የሚከፋፈሉ ኢንዴክሶች ውስጥ ግን እሴቶቹ እኩል ናቸው ።--ይህ ተግባር ዝርዝር ይወስዳል እና እንደ ዝርዝር ይመልሳል--  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =","canonical_solution":"sortThird :: [Int] -> [Int]\nsortThird l = map selectElem indexed\n  where\n    indexed = zip [0..] l\n    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]\n    sortedThirdElems = sortedElems thirdIndicesElems\n    sortedElems = id -- or List.sort if imported\n    selectElem (i, x)\n      | i `mod` 3 == 0 = head sortedThirdElems\n      | otherwise = x\n    replaceSortedElem xs sorted = map selectElem indexed\n      where\n        replaceElem i (x:xs)\n          | i == 0 = x:xs\n          | otherwise = replaceElem (i - 1) xs\n        selectElem (i, x)\n          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)\n          | otherwise = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_34","nl":"amh_Ethi","pl":"hs","prompt":"--❑ በዝርዝር ውስጥ የተደረደሩ ልዩ ንጥረ ነገሮችን ይመልሳል--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =","canonical_solution":"unique :: [Int] -> [Int]\nunique l = sort $ nub l\n  where\n    -- | Remove duplicate elements from a list.\n    nub :: (Eq a) => [a] -> [a]\n    nub [] = []\n    nub (x:xs) = x : nub (filter (\/= x) xs)\n\n    -- | Sort a list of elements (using QuickSort algorithm).\n    sort :: (Ord a) => [a] -> [a]\n    sort [] = []\n    sort (x:xs) =\n      let smallerSorted = sort [a | a <- xs, a <= x]\n          biggerSorted = sort [a | a <- xs, a > x]\n      in  smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_35","nl":"amh_Ethi","pl":"hs","prompt":"--❑ በዝርዝሩ ውስጥ ከፍተኛውን ንጥረ ነገር ይመልሳል።--  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =","canonical_solution":"maxElement :: [Int] -> Int\nmaxElement [] = error \"List cannot be empty\"\nmaxElement (x:xs) = maxElementHelper xs x\n  where\n    maxElementHelper [] currentMax = currentMax\n    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_36","nl":"amh_Ethi","pl":"hs","prompt":"--❑ የቁጥር 7 ቁጥር በ 11 ወይም በ 13 በሚከፋፈሉ ከ n በታች ባሉ ቁጥሮች ውስጥ የሚከሰትበትን ቁጥር ይመልሱ--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =","canonical_solution":"fizzBuzz :: Int -> Int\nfizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_37","nl":"amh_Ethi","pl":"hs","prompt":"--የ l እኩል መረጃ ጠቋሚዎች እሴቶች, ነገር ግን የተደረደሩ.--l' ከ l ጋር ተመሳሳይ ነው በድርድር መረጃ ጠቋሚዎች ውስጥ ፣ የእሱ እሴቶች በድርድር መረጃ ጠቋሚዎች ውስጥ እኩል ናቸው --ይህ ተግባር ዝርዝር ይወስዳል እና እንደ ዝርዝር ይመልሳል--  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =","canonical_solution":"sortEven :: [Int] -> [Int]\nsortEven l = merge odds sortedEvens\n  where\n    (odds, evens) = partitionList l\n    sortedEvens = sort evens\n\n    partitionList :: [Int] -> ([Int], [Int])\n    partitionList [] = ([], [])\n    partitionList [x] = ([x], [])\n    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)\n      where\n        (xsOdds, xsEvens) = partitionList xs\n\n    merge :: [Int] -> [Int] -> [Int]\n    merge [] ys = ys\n    merge (x:xs) [] = x:xs\n    merge (x:xs) (y:ys) = x:y:merge xs ys","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_39","nl":"amh_Ethi","pl":"hs","prompt":"--prime_fib የፊቦናቺ ቁጥር የሆነ n-ኛ ቁጥርን ይመልሳል እንዲሁም እሱ ደግሞ ፕራይም ነው።--  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =","canonical_solution":"primeFib :: Int -> Int\nprimeFib n = primeFibs !! (n - 1)\n  where\n    primeFibs = filter isPrime fibs\n    fibs = map fst $ iterate (\\(a, b) -> (b, a + b)) (0, 1)\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2 = False\n  | k == 2 = True\n  | even k = False\n  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]\n  where\n    upperLimit = floor . sqrt $ fromIntegral k","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_40","nl":"amh_Ethi","pl":"hs","prompt":"--ድምር ወደ ዜሮ፣ እና ካልሆነ ሐሰት--ይህ  ዝርዝር ውስጥ ሦስት የተለያዩ ንጥረ ነገሮች አሉ ከሆነ እውነት ይመልሳል--triples_sum_to_zero የሙሉ ቁጥሮች ዝርዝር እንደ ግብዓት ይወስዳል።--  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =","canonical_solution":"triplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]\n  where\n    tails [] = []\n    tails xs@(_:xs') = xs : tails xs'","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_41","nl":"amh_Ethi","pl":"hs","prompt":"--ይህ ተግባር እንዲህ ያሉ ግጭቶች ቁጥር ያስወጣል.--በቦታቸው ላይ እንደማይወጋጩ --ይሁን እንጂ መኪኖቹ እጅግ በጣም ጠንካራና ጠንካራ ስለሆኑ መሄዳቸውን ይቀጥላሉ።--ከግራ ወደ ቀኝ የሚንቀሳቀስ መኪና ከቀኝ ወደ ግራ የሚንቀሳቀስ መኪና ሲመታ--ሁሉም መኪኖች በተመሳሳይ ፍጥነት ይንቀሳቀሳሉ ሁለት መኪኖች ይጋጫሉ ይባላል--ከቀኝ ወደ ግራ እየነዱ ነው ። ሁለቱ የመኪናዎች ስብስቦች ከ ጂ.ኤም.ኤ.ኤ. በጣም ርቀው ይጀምራሉ--n መኪኖች ከግራ ወደ ቀኝ እየነዱ ናቸው፤ በተመሳሳይ ጊዜ ደግሞ n የተለያዩ መኪኖች --❑ መንገድን አስቡት ፍጹም ቀጥ ያለና ማለቂያ የሌለው መስመር ነውcarRaceCollision :: Int -> Int\ncarRaceCollision n =","canonical_solution":"carRaceCollision :: Int -> Int\ncarRaceCollision n = n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_42","nl":"amh_Ethi","pl":"hs","prompt":"--በ 1 የተጨመሩ አባሎችን ይዘው ዝርዝር ይመልሳሉ።--  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =","canonical_solution":"incrList :: [Int] -> [Int]\nincrList l = map (+1) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_43","nl":"amh_Ethi","pl":"hs","prompt":"--ድምር ወደ ዜሮ፣ እና ካልሆነ ሐሰት--ይህ  ዝርዝር ውስጥ ሁለት የተለያዩ ንጥረ ነገሮች አሉ ከሆነ እውነት ይመልሳል--pairs_sum_to_zero የሙሉ ቁጥሮች ዝርዝር እንደ ግብዓት ይወስዳል።--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =","canonical_solution":"pairsSumToZero :: [Int] -> Bool\npairsSumToZero l = any (\\x -> -x `elem` l) l && (length l > 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_44","nl":"amh_Ethi","pl":"hs","prompt":"--የቤዝ ቁጥሮች ከ10 ያነሱ ናቸው።--ከለውጡ በኋላ የሰንሰለት ውክልና ይመልሱ.--የቁጥር መሰረትን ከቁጥር x ወደ መሰረትን መቀየር።--  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =","canonical_solution":"changeBase :: Int -> Int -> String\nchangeBase x base\n  | x < base  = show x\n  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_45","nl":"amh_Ethi","pl":"hs","prompt":"--☞ የሶስት ማዕዘን ጎን ርዝመት እና ከፍተኛ የመመለሻ ቦታ።--  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =","canonical_solution":"triangleArea :: Int -> Int -> Float\ntriangleArea a h = 0.5 * fromIntegral a * fromIntegral h","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_46","nl":"amh_Ethi","pl":"hs","prompt":"--እባክዎን የ fib4 ቁጥር ቅደም ተከተል n-ኛ ንጥረ ነገር በብቃት ለማስላት ተግባር ይፃፉ። ተደጋጋሚነት አይጠቀሙ። --fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) --fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --የ Fib4 ቁጥር ቅደም ተከተል ከፊቦናቺ ቅደም ተከተል ጋር ተመሳሳይ የሆነ ቅደም ተከተል ነው ይህም እንደሚከተለው ተገልጿል--  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =","canonical_solution":"fib4 :: Int -> Int\nfib4 n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 2\n  | n == 3 = 0\n  | otherwise = iter 0 0 2 0 n\n  where\n    iter a b c d 4 = a + b + c + d\n    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_47","nl":"amh_Ethi","pl":"hs","prompt":"--በዝርዝሩ ውስጥ ያሉትን ንጥረ ነገሮች መካከለኛ ይመልሳል--  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =","canonical_solution":"median :: [Int] -> Float\nmedian l \n  | odd n     = fromIntegral $ sorted !! mid\n  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) \/ 2\n  where\n    sorted = sort l\n    n = length l\n    mid = n `div` 2\n    sort = sortBy compare","tests":"\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_48","nl":"amh_Ethi","pl":"hs","prompt":"--የተሰጠው ሕብረቁምፊ ፓሊንድሮም መሆኑን ያረጋግጣል--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =","canonical_solution":"isPalindrome :: String -> Bool\nisPalindrome text = text == reverse text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_49","nl":"amh_Ethi","pl":"hs","prompt":"--2n ሞዱሎ ፒ (ቁጥርን ልብ ይበሉ) ይመልሱ--  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =","canonical_solution":"modp :: Int -> Int -> Int\nmodp n p = powMod 2 n p\n\npowMod :: Int -> Int -> Int -> Int\npowMod base exp modulus\n  | modulus == 1 = 0\n  | exp == 0     = 1\n  | exp == 1     = base `mod` modulus\n  | otherwise    = if odd exp\n                   then (base * halfExp * halfExp) `mod` modulus\n                   else (halfExp * halfExp) `mod` modulus\n  where\n    halfExp = powMod base (exp `div` 2) modulus","tests":"\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_51","nl":"amh_Ethi","pl":"hs","prompt":"--remove_vowels የቁምፊዎችን ይዘው ያለ ድምጽ ፊደሎች የሚመልስ ተግባር ነው።--  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =","canonical_solution":"removeVowels :: String -> String\nremoveVowels text = filter (`notElem` \"aeiouAEIOU\") text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_52","nl":"amh_Ethi","pl":"hs","prompt":"--በዝርዝሩ ውስጥ ያሉ ሁሉም ቁጥሮች ከደረጃው በታች ከሆኑ እውነት ይመልሳል ።--  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =","canonical_solution":"belowThreshold l t = all (< t) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_53","nl":"amh_Ethi","pl":"hs","prompt":"--ሁለት ቁጥሮች x እና y ን መጨመር--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =","canonical_solution":"add :: Int -> Int -> Int\nadd x y = x + y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_54","nl":"amh_Ethi","pl":"hs","prompt":"--❑ ሁለት ቃላት ተመሳሳይ ቁምፊዎች እንዳሏቸው ያረጋግጡ።--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =","canonical_solution":"import Data.List (nub, sort)\n\nsameChars :: String -> String -> Bool\nsameChars s0 s1 = sort (nub s0) == sort (nub s1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_55","nl":"amh_Ethi","pl":"hs","prompt":"--፦ n-ኛውን የፊቦናቺ ቁጥር ይመልሱ--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =","canonical_solution":"fib :: Int -> Int\nfib n = fibHelper 0 1 n\n  where\n    fibHelper a _ 0 = a\n    fibHelper a b n = fibHelper b (a + b) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_56","nl":"amh_Ethi","pl":"hs","prompt":"--እያንዳንዱ የመክፈቻ ክፈፍ ተጓዳኝ የመዝጊያ ክፈፍ ካለው እውነት ይመልሱ ።-- የ \"<\" እና \">\" ሰንሰለት ነው።--  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBrackets brackets 0 == 0\n\ncheckBrackets :: String -> Int -> Int\ncheckBrackets [] n = n\ncheckBrackets (x:xs) n\n  | n < 0 = -1\n  | x == '<' = checkBrackets xs (n + 1)\n  | x == '>' = checkBrackets xs (n - 1)\n  | otherwise = checkBrackets xs n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_57","nl":"amh_Ethi","pl":"hs","prompt":"--❑ እውነት ይመለስ የዝርዝር አካላት በሞኖቶኒክ እየጨመሩ ወይም እየቀነሱ ናቸው--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =","canonical_solution":"monotonic :: [Int] -> Bool\nmonotonic l = increasing l || decreasing l\n  where\n    increasing xs = all (uncurry (<=)) (zip xs (tail xs))\n    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_58","nl":"amh_Ethi","pl":"hs","prompt":"--❑ ለሁለት ዝርዝሮች የተደረደሩ ልዩ የጋራ ንጥረ ነገሮችን ይመልሱ--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =","canonical_solution":"common :: [Int] -> [Int] -> [Int]\ncommon l1 l2 = uniqueSortedCommon\n  where\n    commonElements = filter (`elem` l2) l1\n    uniqueCommon = removeDuplicates commonElements\n    uniqueSortedCommon = sort uniqueCommon\n\n    removeDuplicates :: [Int] -> [Int]\n    removeDuplicates = foldr (\\x seen -> if x `elem` seen then seen else x : seen) []\n\n    sort :: [Int] -> [Int]\n    sort [] = []\n    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)\n      where\n        lesser  = filter (< p) xs\n        greater = filter (>= p) xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_59","nl":"amh_Ethi","pl":"hs","prompt":"--n> 1 እና ፕራይም አይደለም እንበል--  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =","canonical_solution":"largestPrimeFactor :: Int -> Int\nlargestPrimeFactor n = helper n 2\n  where\n    helper n factor\n      | factor * factor > n = n\n      | n `mod` factor == 0 = helper (n `div` factor) factor\n      | otherwise = helper n (factor + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_60","nl":"amh_Ethi","pl":"hs","prompt":"--sum_to_n ከ1 እስከ n ያሉትን ቁጥሮች የሚደመር ተግባር ነው።--  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =","canonical_solution":"sumToN :: Int -> Int\nsumToN n = sum [1..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_61","nl":"amh_Ethi","pl":"hs","prompt":"--እያንዳንዱ የመክፈቻ ክፈፍ ተጓዳኝ የመዝጊያ ክፈፍ ካለው እውነት ይመልሱ ።-- የ \"(\" እና \"\") ዎች ሰንሰለት ነው።--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBalance brackets 0\n  where\n    checkBalance [] 0 = True\n    checkBalance [] _ = False\n    checkBalance (x:xs) n\n      | x == '('  = checkBalance xs (n + 1)\n      | x == ')' && n > 0 = checkBalance xs (n - 1)\n      | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_62","nl":"amh_Ethi","pl":"hs","prompt":"--የዚህን ፖሊኖም ተመሳሳይ ቅርፅ ያለው ድሪቭየት ይመልሱ --xs[0] + xs[1] * x + xs[2] * x^2 + .... --xs የ polynomial ተባባሪዎችን ይወክላል--  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =","canonical_solution":"derivative :: [Int] -> [Int]\nderivative xs = zipWith (*) (tail xs) [1..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_63","nl":"amh_Ethi","pl":"hs","prompt":"--እባክዎን የ fibfib ቁጥር ቅደም ተከተል n-ኛ ንጥረ ነገር በብቃት ለማስላት ተግባር ይፃፉ ።--fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3)) ነው ።--fib fib ((2) == 1 --0  የፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊፊ--0  የፊብፊብ--የፊብፊብ ቁጥር ቅደም ተከተል ከፊቦናቺ ቅደም ተከተል ጋር ተመሳሳይ የሆነ ቅደም ተከተል ነው ይህም እንደሚከተለው ተገልጿል--  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =","canonical_solution":"fibfib :: Int -> Int\nfibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibs !! n\n  where\n    fibs = 0 : 0 : 1 : zipWith3 (\\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_64","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--በቃል መጨረሻ ላይ ብቻ የሚገኝ የቃላት ዓይነት ነው።--በዚህ ሁኔታ ውስጥ ያሉ ድምፆች ‹a›፣ ‹e›፣ ‹i›፣ ‹o›፣ ‹u› ናቸው ። እዚህ ላይ ‹y› እንዲሁ ሀ ነው ።--አንድ ቃል እንደ ግብዓት እና በሰንሰለት ውስጥ የድምጽ ፊደላት ቁጥር ይመልሳል. -- የቃላት ብዛት የሚወክል የቁጥር ሰንሰለት የሚወስድ ተግባር ፃፍ--  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =","canonical_solution":"vowelsCount :: String -> Int\nvowelsCount s = length $ filter isVowel $ zip s [1..]\n  where\n    isVowel (c, pos) =\n      let lowercaseC = toLower c\n          isRegularVowel = lowercaseC `elem` \"aeiou\"\n          isLastCharY = lowercaseC == 'y' && pos == length s\n      in isRegularVowel || isLastCharY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_65","nl":"amh_Ethi","pl":"hs","prompt":"--shift > የቁጥሮች ብዛት ከሆነ ፣ የቁጥሮች ቁጥር ይመለስ ።--ውጤቱን እንደ ሕብረቁምፊ ይመልሱ.--የ xን አሃዝ በክብ መልክ መቀየር፣ አሃዞቹን ወደ ቀኝ መቀየር--  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =","canonical_solution":"circularShift :: Int -> Int -> String\ncircularShift x shift =\n  let digits = show x\n      len = length digits\n      effectiveShift = shift `mod` len\n  in if shift > len\n     then reverse digits\n     else let (begin, end) = splitAt (len - effectiveShift) digits\n          in end ++ begin","tests":"\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_66","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --የ ASCII ኮዶች--አንድን ሕብረቁምፊ እንደ ግብዓት የሚወስድ እና የላይኛው ቁምፊዎች ድምር ብቻ የሚመልስ ተግባር ይጻፉ' --ተልዕኮ--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =","canonical_solution":"digitsum :: String -> Int\ndigitsum s = sum $ map fromEnum $ filter isUpper s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_67","nl":"amh_Ethi","pl":"hs","prompt":"--ለ examble: --በቅርጫቱ ውስጥ በቅርጫቱ ውስጥ ያሉትን የማንጎ ፍሬዎች ቁጥር ይመልሱ ።--ብርቱካናማ እና ፖም እና የፍራፍሬዎችን ጠቅላላ ቁጥር የሚወክል ሙሉ ቁጥር --አጠቃላይ ቁጥርን የሚወክለው ሰንሰለት ሲሰጥ--በፍራፍሬ ቅርጫት ውስጥ የሚሰራጩት --❑ በዚህ ተግባር ውስጥ፣ የተወሰኑ ፖም እና ብርቱካናማዎችን የሚወክል ሰንሰለት ይሰጥዎታል።--  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =","canonical_solution":"import Text.Read (readMaybe)\n\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n = n - totalApplesOranges\n  where\n    totalApplesOranges = sum $ map (readNumber . words) [\"apples\", \"oranges\"]\n    readNumber keyword = case dropWhile (not . (==\" \") . dropWhile (\/=' ')) $ words s of\n      [] -> 0\n      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_68","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ 1፦--ምንም አይነት እሴት ከሌለ ወይም የተሰጠው ዝርዝር ባዶ ከሆነ ፣ [] ይመልሱ ።--የተቆረጠው ኖድ በዝርዝር ውስጥ መመለስ አለበት፣ [ smalest_value፣ ኢንዴክሱ ], --ተመሳሳይ አነስተኛ እኩል ዋጋ ያላቸው በርካታ ኖዶች ከተገኙ አነስተኛውን መረጃ ጠቋሚ ያለው ኖድ ይመልሱ ። --የተቆረጠው ኖድ አነስተኛውን እኩል ዋጋ ያለው ኖድ መሆን አለበት።--የእርስዎ ተግባር አንደኛው አንጓን በመቁረጥ መመለስ ነው።--❑ \"አሉታዊ ያልሆኑ የሙሉ ቁጥር ኖዶች ያሉት የዛፍ ቅርንጫፍ የሚወክል ዝርዝር ሲሰጥ--  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =","canonical_solution":"pluck :: [Int] -> [Int]\npluck arr = case filter (\\(x, _) -> even x) (zip arr [0..]) of\n    [] -> []\n    evens -> let (value, index) = minimum evens in [value, index]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_69","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --እንደዚህ አይነት ዋጋ ከሌለ - 1 ይመልሳል።--የሙሉ ቁጥር ድግግሞሽ በዝርዝሩ ውስጥ የሚታይበት ብዛት ነው።--ዜሮ ሲሆን፣ እና ከጠቅላላው ቁጥር እሴት በላይ ወይም እኩል የሆነ ድግግሞሽ አለው።--√ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √ የፕሮጀክት ዝርዝር √--  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nsearch :: [Int] -> Int\nsearch lst = \n    let frequencies = map (\\g -> (head g, length g)) . group . sort $ lst\n        candidates = filter (\\(val, freq) -> freq >= val) frequencies\n    in case candidates of\n         [] -> -1\n         _  -> fst . maximum $ candidates","tests":"\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_70","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ከዚያም የተቀሩት ሙሉ ቁጥሮች ከፍተኛ, ከዚያም ዝቅተኛ እና የመሳሰሉት.--ያልተለመደ መደርደር, እናንተ ዝቅተኛ ዋጋ ጋር መጀመር ጊዜ ነው, --❑ የሙሉ ቁጥሮች ዝርዝር ከተሰጠ፣ ዝርዝር በተለየ ቅደም ተከተል ይመልሳል።--  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =","canonical_solution":"strangeSortList :: [Int] -> [Int]\nstrangeSortList [] = []\nstrangeSortList lst = go (sort lst) True\n  where\n    go [] _ = []\n    go xs toggle\n      | toggle    = head xs : go (tail xs) False\n      | otherwise = last xs : go (init xs) True","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_71","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦-- ከሦስተኛው ወገን ይልቅ--የሶስት ጎኖች ድምር ከየትኛውም ሁለት ጎኖች ይበልጣል--አለበለዚያ መልሶ -1 --ሶስት ጎኖች ትክክለኛ ሶስት ማዕዘን የሚያደርጉ ከሆነ ሶስት ማዕዘን ወደ 2 አሃዝ ነጥብ ይደርሳል.--የሶስቱን ጎኖች ርዝመት ስናነሳ የሶስቱን ጎኖች ስፋት እንመልሳለን--  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =","canonical_solution":"import Text.Printf (printf)\n\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c\n    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))\n    | otherwise = -1\n  where\n    s = (fromIntegral (a + b + c)) \/ 2\n    isValidTriangle x y z = x + y > z && x + z > y && y + z > x\n    roundToTwoDecimals x = read (printf \"%.2f\" x) :: Float","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_72","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--የቁጥር q ሚዛናዊ ከሆነ ይበርራል (ፓሊንድሮም ዝርዝር ነው) እና የቁጥር q እኩል ከሆነ ወይም ከከፍተኛው ክብደት w በታች ከሆነ--☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ ☞ --  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =","canonical_solution":"willItFly :: [Int] -> Int -> Bool\nwillItFly q w = isPalindrome q && sum q <= w\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome xs = xs == reverse xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_73","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--አንድ ለውጥ ውስጥ, አንድ አባል ሌላ ማንኛውም አባል መቀየር ይችላሉ. --ዝርዝሩን ፓሊንድሮም ለማድረግ መለወጥ ያስፈልጋል። ፓሊንድሮም ዝርዝር --☞ ከጠቅላላ ቁጥሮች ዝርዝር ውስጥ፣ የቁጥር ብዛት ያላቸው አባላትን ☞ ማግኘት--  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =","canonical_solution":"smallestChange :: [Int] -> Int\nsmallestChange arr = sum $ zipWith (\\x y -> if x \/= y then 1 else 0) arr (reverse arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_74","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ሁለቱ ዝርዝሮች ተመሳሳይ ቁጥር ያላቸው ካሉ የመጀመሪያውን ዝርዝር ይመልሱ ።--በዝርዝሩ ውስጥ ባሉ ሁሉም የቁምፊዎች ብዛት ከሌላው ዝርዝር ያነሰ ነው ።--❑ ሁለት የሰንሰለት ዝርዝሮችን የሚቀበል እና የያዘውን ዝርዝር የሚመልስ ተግባር ይጻፉ--  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =","canonical_solution":"totalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2\n  | totalChars lst1 < totalChars lst2 = lst1\n  | totalChars lst1 > totalChars lst2 = lst2\n  | otherwise = lst1\n  where\n    totalChars = sum . map length","tests":"\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_75","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--(ሀ) ከ100 በታች መሆኑን ማወቅ--በሌላ በኩል ደግሞ ሐሰት ነው።--፦ የተሰጠው ቁጥር የ3 ዋና ቁጥሮች ማባዛት ከሆነ እውነት የሚመልስ ተግባር ጻፍ።--  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =","canonical_solution":"isMultiplyPrime :: Int -> Bool\nisMultiplyPrime a = any isTriplePrimeProduct primeTriples\n  where\n    primes = filter isPrime [2..99]\n    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]\n    isTriplePrimeProduct (x, y, z) = x * y * z == a\n\nisPrime :: Int -> Bool\nisPrime n \n  | n < 2     = False\n  | otherwise = not (any (\\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_76","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--x የ n ቀላል ኃይል ነው n**int=x --n ኃይል እና በሌሎች ሁኔታዎች ሐሰት ነው ።--የእርስዎ ተግባር ቁጥር x ቀላል ከሆነ እውነት የሚመልስ ተግባር መጻፍ ነው--  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =","canonical_solution":"isSimplePower :: Int -> Int -> Bool\nisSimplePower x n\n  | x < 1 || n < 1 = False\n  | n == 1 = x == 1\n  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_77","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ማስታወሻ: ግብዓት ሁልጊዜ ትክክል ነው ብሎ ማሰብ ይችላል.--ይህ ኢንጌር የሙሉ ቁጥር ኪዩብ ከሆነ--ሀን የሚወስድ እና እውነት የሚመልስ ተግባር ይጻፉ።--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =","canonical_solution":"iscube :: Int -> Bool\niscube a = let n = round (fromIntegral a ** (1\/3)) in n^3 == a","tests":"\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_78","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --እና ምልክቶች A,B,C,D,E,F ሁልጊዜ ትልቅ ፊደል ነው.--ማስታወሻ: የግብዓት ሁልጊዜ ትክክል ወይም ባዶ ሕብረቁምፊ ነው ማሰብ ይችላሉ, --ቢ (= አስር ቁጥር 11) ፣ ዲ (= አስር ቁጥር 13) ።--ስለዚህ የሚከተሉትን አሃዞች መወሰን አለብህ: 2, 3, 5, 7, --ፕራይም ቁጥሮች 2, 3, 5, 7, 11, 13, 17,... ናቸው--የሃሳ አሃዝ አሃዝ አሃዞች 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ናቸው--ከ1 በላይ የሆነ ሁለት ትናንሽ የተፈጥሮ ቁጥሮች ውጤት ያልሆነ) ።--ቁጥሮች ፕራይም ናቸው (ፕራይም ቁጥር ወይም ፕራይም የሆነ የተፈጥሮ ቁጥር ነው)--አንድ hexadecimal ቁጥር እንደ አንድ ሕብረቁምፊ እና hexadecimal ቁጥር ይቆጥራል --❑ ተቀባይ የሆነ ተግባር እንዲጽፉ ተልዕኮ ተሰጥቷችኋል--  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =","canonical_solution":"hexKey :: String -> Int\nhexKey num = length . filter (`elem` primeHexDigits) $ num\n  where\n    primeHexDigits = \"2357BD\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_79","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ተጨማሪዎቹ ፊደላት ቅርጸቱን ለማሻሻል ያገለግላሉ።--በሰንሰለት መጀመሪያ እና መጨረሻ ላይ ተጨማሪ ሁለት ቁምፊዎች 'db' ይኖራሉ።--እያንዳንዱ የቁጥር ቁምፊ '0' ወይም '1' ይሆናል።--የሁለትዮሽ ቅርጸት. ተግባር አንድ ሕብረቁምፊ መመለስ አለበት, እያንዳንዱ ቁምፊ አንድ ሁለትዮሽ  የሚወክል ጋር.--❑ አሥርታዊ ቅርፅ ያለው ቁጥር ይሰጥዎታል እና ስራዎ ወደ ❑ መቀየር ነው--  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =","canonical_solution":"decimalToBinary :: Int -> String\ndecimalToBinary decimal = \"db\" ++ toBinary decimal ++ \"db\"\n  where\n    toBinary 0 = \"0\"\n    toBinary n = reverse (binaryHelper n)\n\n    binaryHelper 0 = \"\"\n    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_80","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--አንድ ሕብረቁምፊ ሃፍስ ነው ርዝመቱ ቢያንስ 3 ከሆነ እና እያንዳንዱ 3 ተከታታይ ፊደላት የተለዩ ናቸው --የእርስዎ ተግባር ሕብረቁምፊው haphs ወይም አይደለም ከሆነ ማረጋገጥ ነው.--❑ አንድ የስልክ ቁጥር ይሰጥሃል።--  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =","canonical_solution":"isHappy :: String -> Bool\nisHappy s\n  | length s < 3 = False\n  | otherwise = all distinctTriples (windows 3 s)\n  where\n    distinctTriples [x, y, z] = x \/= y && y \/= z && x \/= z\n    distinctTriples _ = False\n    windows n xs\n      | length xs < n = []\n      | otherwise = take n xs : windows n (tail xs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_81","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--0 E --> 0.0 ዲ- --> 0.7 ዲ --> 1 ዲ+ --3 C- --> 1.7 ሴ--2 ሲ + --> 2.3 ቢ- --> 2.7 ቢ --> 3 ቢ + --3 A- --> 3.7 A --4 A+ --አማካይ ፦ የፊደል ደረጃ ፦--የሚከተለውን ሰንጠረዥ በመጠቀም የፊደል ደረጃዎች ዝርዝር ማውጣት የሚችል ተግባር: --ለተማሪዎች የተወሰኑ የ GPA ዝርዝር ሰጥታችኋል እናም መጻፍ አለባችሁ --ብቸኛው ችግር ደግሞ ለደረጃ አሰጣጥ የተጠቀመችበትን ኮድ ማጣቷ ነው።--መምህሩ የራሷን የአልጎሪዝም ደረጃ አሰጣጥ እያደረገች ነው።--የሴሚስተሩ የመጨረሻ ሳምንት ሲሆን መምህሩ ውጤቱን መስጠት አለበት--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =","canonical_solution":"numericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades = map gpaToLetterGrade grades\n  where\n    gpaToLetterGrade gpa\n      | gpa == 4.0 = \"A+\"\n      | gpa > 3.7  = \"A\"\n      | gpa > 3.3  = \"A-\"\n      | gpa > 3.0  = \"B+\"\n      | gpa > 2.7  = \"B\"\n      | gpa > 2.3  = \"B-\"\n      | gpa > 2.0  = \"C+\"\n      | gpa > 1.7  = \"C\"\n      | gpa > 1.3  = \"C-\"\n      | gpa > 1.0  = \"D+\"\n      | gpa > 0.7  = \"D\"\n      | gpa > 0.0  = \"D-\"\n      | otherwise  = \"E\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_82","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ርዝመት የመጀመሪያ ቁጥር ነው ወይም ካልሆነ ሐሰት ነው --❑ አንድን ሕብረቁምፊ የሚወስድ እና ሕብረቁምፊው ❑ እውነት ከሆነ እውነት የሚል ተግባር ጻፍ--  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =","canonical_solution":"primeLength :: String -> Bool\nprimeLength string = isPrime (length string)\n\nisPrime :: Int -> Bool\nisPrime n\n  | n < 2     = False\n  | n == 2    = True\n  | even n    = False\n  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_83","nl":"amh_Ethi","pl":"hs","prompt":"--በ1 የሚጀምሩ ወይም የሚጨርሱ አዎንታዊ ሙሉ ቁጥሮች --❑ n አዎንታዊ ቁጥር ሲሰጥ የ n-አሃዝ ቁጥሮች ቁጥርን ይመልሱstartsOneEnds :: Int -> Int\nstartsOneEnds n =","canonical_solution":"startsOneEnds :: Int -> Int\nstartsOneEnds n\n  | n <= 0    = 0\n  | n == 1    = 1\n  | otherwise = 18 * 10^(n-2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_84","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ --❑ N የተባለ አዎንታዊ ቁጥር ከተሰጠ፣ የቁጥሮች ድምርን በሁለትዮሽ መልክ መልሶ ያቅርብ።--  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 ≤ N ≤ 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =","canonical_solution":"solve :: Int -> String\nsolve N = toBinary (sumOfDigits N)\n  where\n    sumOfDigits 0 = 0\n    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)\n\n    toBinary 0 = \"0\"\n    toBinary n = reverse (toBinary' n)\n      where\n        toBinary' 0 = \"\"\n        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_85","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --በባዶ ያልሆነ የሙሉ ቁጥሮች ዝርዝር ውስጥ በመጀመሪያ በባዶ ቁጥሮች ላይ ያሉትን እኩል ቁጥሮች ይጨምሩ--  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =","canonical_solution":"add :: [Int] -> Int\nadd lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_86","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ማስታወሻ፦ የቃላት ቅደም ተከተል እና የዓረፍተ ነገሩ ክፍተት መከበር አለበት።--የ ASCII ዋጋን መሠረት በማድረግ በደረጃ ቅደም ተከተል--ሁሉም ቁምፊዎች በተደራጁበት አዲስ ቃል ተተክተዋል --የታዘዘ ስሪት ሕብረቁምፊ, ሁሉም ቃላት (በቦታ የተለዩ) --❑ አንድን ሕብረቁምፊ የሚወስድ እና የተደራጀውን ስሪት የሚመልስ ተግባር ጻፍ።--  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =","canonical_solution":"import Data.List (sort)\nimport Data.Char (isAlpha)\n\nantiShuffle :: String -> String\nantiShuffle s = unwords $ map sortWord (wordsAndSpaces s)\n  where\n    sortWord word = if all isAlpha word then sort word else word\n    wordsAndSpaces [] = []\n    wordsAndSpaces xs = if head xs == ' ' \n                        then \" \" : wordsAndSpaces (dropWhile (== ' ') xs)\n                        else let (word, rest) = break (== ' ') xs\n                             in word : wordsAndSpaces rest","tests":"\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_87","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --በተጨማሪም የረድፉን ኮርዲኔቶች በኮሎምቦች በወረደ ቅደም ተከተል ይደርጁ።--ኮርዲኔቶችን በመጀመሪያ በረድፎች በዝቅተኛ ቅደም ተከተል ይደርጁ ።--እያንዳንዱ የቁጥር ሰንሰለት በ 0 የሚጀምር የቁጥር ሰንሰለት ነው።--እና እንደ  የ tuples ዝርዝር, [(x1, y1), (x2, y2) ...] ይመለሳል--lst እና ሙሉ ቁጥር x ከተሰጠ በዝርዝሩ ውስጥ ሙሉ ቁጥር x ን ፈልግ--እያንዳንዱ ረድፍ የተለያዩ አምዶች ሊይዝ ይችላል።--ይህም ማትሪክስ ጋር ተመሳሳይ ነው, ይሁን እንጂ, ማትሪክስ በተለየ, --❑ ሁለት አቅጣጫዊ መረጃዎች ይሰጡሃል፣ በተጣመሩ ዝርዝሮች መልክ፣--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =","canonical_solution":"getRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x = concatMap processRow (zip [0..] lst)\n  where\n    processRow (rowIndex, row) = \n      let colIndices = reverse $ findIndices (== x) row\n      in [(rowIndex, colIndex) | colIndex <- colIndices]\n\nfindIndices :: (a -> Bool) -> [a] -> [Int]\nfindIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_88","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --* የተሰጠውን ዝርዝር አይቀይሩ--ማስታወሻ: --ወይም ደግሞ በዝቅተኛ ቅደም ተከተል ይደርሳል ድምር ((የመጀመሪያው መረጃ ጠቋሚ ዋጋ ፣ የመጨረሻው መረጃ ጠቋሚ ዋጋ) እኩል ከሆነ።--የተሰጠውን ዝርዝር በዝቅተኛ ቅደም ተከተል ይደርሳሉ ፣ ድምር ((የመጀመሪያው መረጃ ጠቋሚ ዋጋ ፣ የመጨረሻው መረጃ ጠቋሚ ዋጋ) ያልተለመደ ከሆነ ፣ --√ የንቁ ቁጥሮች ዝርዝር ከተሰጠ በኋላ ከተሰጠው ዝርዝር ውስጥ √ን መልሶ ያቅርቡ--  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =","canonical_solution":"sortArray :: [Int] -> [Int]\nsortArray array\n  | null array = array\n  | otherwise =\n    let first = head array\n        last = last array\n        sumFirstLast = first + last\n    in if odd sumFirstLast\n       then sort array\n       else reverse (sort array)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_89","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ወደ ታች በሁለት እጥፍ ወደ ሁለት ቦታዎች ይዛወሩ ።--ፊደሎቹ --ፊደል እየተዘዋወረ ጋር የተመሰጠረ ሕብረቁምፊ ይመልሳል. --❑ አንድን ሕብረቁምፊ እንደ ክርክር የሚወስድ ተግባር ኢንክሪፕት ይፍጠሩ እና ❑--  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =","canonical_solution":"encrypt :: String -> String\nencrypt s = map shiftChar s\n  where\n    shiftChar c\n      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')\n      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_90","nl":"amh_Ethi","pl":"hs","prompt":"--ምንም ነገር የለም ከሆነ ምንም ነገር አይመልሱ.--የዝርዝሩን 2ኛ ትንሹን ንጥረ ነገር የሚመልስ next_smallest () ተግባር ይጻፉ።--❑ የሙሉ ቁጥሮች ዝርዝር ተሰጥቶሃል።--  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =","canonical_solution":"nextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =\n  let uniqueSorted = removeDuplicates $ quicksort lst\n  in if length uniqueSorted < 2\n     then Nothing\n     else Just (uniqueSorted !! 1)\n\nremoveDuplicates :: (Ord a) => [a] -> [a]\nremoveDuplicates = foldr (\\x acc -> if x `elem` acc then acc else x : acc) []\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_91","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ዓረፍተ ነገሮች በ ‹› ፣ ‹› ወይም ‹!› የተዋቀሩ ናቸው ።--አሰልቺነት በ\"እኔ\" የሚጀምር ዓረፍተ ነገር ነው።--❑ አንድ ቃል ይሰጥሃል፤ ግዴታህም ቁጥሩን መቁጠር ነው።--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =","canonical_solution":"isBored :: String -> Int\nisBored s = length $ filter (startsWithI . words) $ splitSentences s\n  where\n    splitSentences :: String -> [String]\n    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters \".?!\"\n    \n    splitOnDelimiters :: String -> String -> [String]\n    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of\n      \"\" -> []\n      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''\n    \n    startsWithI :: [String] -> Bool\n    startsWithI [] = False\n    startsWithI (x:_) = map toLower x == \"i\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_92","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --በሌሎች ሁኔታዎች ሁሉ ሐሰት ይመለሳል--ከቁጥሮች አንዱ ከሌሎቹ ሁለት ድምር ጋር እኩል ከሆነ እና ሁሉም ቁጥሮች ሙሉ ቁጥሮች ከሆኑ እውነት ይመልሳል --❑ 3 ቁጥሮች የሚይዙ ተግባር ይፍጠሩ--  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =","canonical_solution":"anyInt :: Float -> Float -> Float -> Bool\nanyInt x y z\n  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =\n      x == y + z || y == x + z || z == x + y\n  | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_93","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ፊደላትን ብቻ ይያዙ።--በእንግሊዝኛ ፊደል ውስጥ የሚገኝ የቃላት አጠራር።--ከሁለት ቦታ ቀድመው የሚመጡ ፊደላት ያሉት መልእክት--የሁሉም ፊደላት ካሴል የሚቀይርበት፣ የሁሉም ድምፆች የሚተካበት መንገድ --❑ አንድን መልዕክት የሚወስድ እና እንዲህ ያለውን መልእክት የሚቀይር ተግባር ጻፍ።--  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =","canonical_solution":"encode :: String -> String\nencode = map transformChar\n  where\n    transformChar :: Char -> Char\n    transformChar c\n      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c\n      | otherwise      = swapCase c c\n      where\n        lowerC = toLower c\n\n    isVowel :: Char -> Bool\n    isVowel c = c `elem` \"aeiou\"\n\n    swapCase :: Char -> Char -> Char\n    swapCase origC c\n      | isUpper origC = toLower c\n      | otherwise     = toUpper c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_94","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ትልቁን ዋና ዋጋ ማግኘት እና የቁጥሮች ድምር መመለስ አለብዎት።--❑ የሙሉ ቁጥሮች ዝርዝር ተሰጥቶሃል።--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =","canonical_solution":"skjkasdkd :: [Int] -> Int\nskjkasdkd lst = sumDigits (largestPrime lst)\n\n-- Function to check if a number is prime\nisPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]\n\n-- Integer square root using binary search, O(log n)\nisqrt :: Int -> Int\nisqrt n = floor . sqrt $ fromIntegral n\n\n-- Function to find the largest prime in the list\nlargestPrime :: [Int] -> Int\nlargestPrime = foldr (\\x acc -> if isPrime x && x > acc then x else acc) 0\n\n-- Function to calculate the sum of the digits of a number\nsumDigits :: Int -> Int\nsumDigits 0 = 0\nsumDigits n = n `mod` 10 + sumDigits (n `div` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_95","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ተግባር መመለስ አለበት ሐሰት የተሰጠው ማህበር ዝርዝር ባዶ ነው. --ካሴ ወይም ሁሉም ቁልፎች በከፍተኛ ፊደል ውስጥ ያሉ ሕብረቁምፊዎች ናቸው ፣ አለበለዚያ False ይመልሳል።--❑ ሁሉም ቁልፎች ከታች ያሉ ❑ ውስጥ ያሉ ሕብረቁምፊዎች ከሆኑ እውነት ይመልሱ--  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =","canonical_solution":"import Data.Char (isUpper, isLower)\n\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase [] = False\ncheckDictCase dict = all isLower allKeys || all isUpper allKeys\n  where\n    allKeys = concatMap fst dict","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_96","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦ --ከ n ያነሱ እና ዋና ቁጥሮች የሆኑ ኢንቲጀሮች --❑ አሉታዊ ያልሆነን ሙሉ ቁጥር የሚወስድ እና የመጀመሪያዎቹን n ዎች ዝርዝር የሚመልስ ተግባር ተግባራዊ ማድረግ--  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =","canonical_solution":"countUpTo :: Int -> [Int]\ncountUpTo n = filter isPrime [2..n-1]\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_97","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ግብዓት ሁልጊዜ ትክክለኛ ነው እንበል.--የዩኒቲ አሃዞቻቸው እጥፍ ነው።--፪ ሙሉ ቁጥሮች የሚወስደውንና የሚመለሰውን ተግባር ያጠናቅቁ--  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =","canonical_solution":"multiply :: Int -> Int -> Int\nmultiply a b = (abs a `mod` 10) * (abs b `mod` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_98","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--❑ አንድን string s ስጥ፣ በቁጥር ቁጥር ውስጥ ያሉትን የ uppercase vowels ቁጥር ቆጥሩ።--  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =","canonical_solution":"countUpper :: String -> Int\ncountUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` \"AEIOU\"]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_99","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ከሁለት ሙሉ ቁጥሮች፣ ከዜሮ አጠገብ አዙረው።--እና ወደ እሱ በጣም ቅርብ የሆነውን ኢንቲጀር ይመልሳል ቁጥሩ እኩል ከሆነ --❑ አንድን ቁጥር የሚወክል ዋጋ (ሰንሰለት) የሚወስድ ተግባር ይፍጠሩ--  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =","canonical_solution":"closestInteger :: String -> Int\nclosestInteger value = \n  let n = read value :: Double\n  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_100","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --i በደረጃው ውስጥ ያሉትን የድንጋዮች ብዛት ይወክላል (i+1) ።-- ውስጥ ዝርዝር ውስጥ በእያንዳንዱ ደረጃ ውስጥ ድንጋዮች ቁጥር ይመልሳል, የት አካል--- n እኩል ከሆነ ቀጣዩ እኩል ቁጥር።--- n ያልተለመደ ከሆነ ቀጣዩ ያልተለመደ ቁጥር።--በቀጣዩ ደረጃ ላይ ያሉት የድንጋዮች ብዛት: --የመጀመሪያው ደረጃ n ድንጋዮች አሉት ።--❑ n አዎንታዊ ቁጥር ከተሰጠ ከ n ደረጃዎች የድንጋይ ክምር መጣል አለብህ።--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =","canonical_solution":"makeAPile :: Int -> [Int]\nmakeAPile n = take n [n, n + 2 ..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_101","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ሕብረቁምፊውን በቃላት ለመከፋፈል እና የቃላቱን ዝርዝር ለመመለስ።--በኮማ ወይም በቦታ የተለዩ ቃላት ይሰጡሃል።--  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =","canonical_solution":"wordsString :: String -> [String]\nwordsString s = words $ map (\\c -> if c == ',' then ' ' else c) s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_102","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--እንደዚህ አይነት ቁጥር የለም፣ ስለዚህ ተግባሩ -1 መመለስ አለበት።--ትልቁን የቁጥር ቁጥር በ [x, y] ክልል ውስጥ ነው--ይህ ተግባር ሁለት አዎንታዊ ቁጥሮች x እና y ይወስዳል እና ይመልሳል --  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =","canonical_solution":"chooseNum :: Int -> Int -> Int\nchooseNum x y\n    | x > y = -1\n    | even upperBound = upperBound\n    | even (upperBound - 1) = upperBound - 1\n    | otherwise = -1\n  where\n    upperBound = max x y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_104","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ማስታወሻ: የተመለሰው ዝርዝር እየጨመረ በሚሄድ ቅደም ተከተል መደርደር አለበት ።--ምንም አይነት የቁጥር ቁጥር የሌለው--☞ የ አዎንታዊ ሙሉ ቁጥሮች ዝርዝር x የተሰጠው. ሁሉንም ☞ የተደረደሩ ዝርዝር መመለስ--  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =","canonical_solution":"uniqueDigits :: [Int] -> [Int]\nuniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_105","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--\"አንድ፣ ሁለት፣ ሦስት፣ አራት፣ አምስት፣ ስድስት፣ ሰባት፣ ስምንት፣ ዘጠኝ\"--የተገኘውን ዝርዝር ይለውጡ እና እያንዳንዱን አሃዝ በተዛማጅ ስሙ ይተኩ ከ -- የጠቅላላ ቁጥሮች ዝርዝር ሲሰጥ ከ1 እስከ 9 ድረስ ያሉትን ጠቅላላ ቁጥሮች ይለዩ--  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the list is empty, return an empty list:\n--  >>> byLength []\n--  []\n--  If the list has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =","canonical_solution":"byLength :: [Int] -> [String]\nbyLength arr = map digitName . reverse . sort . filter isValid $ arr\n  where\n    isValid x = x >= 1 && x <= 9\n    digitName x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"\n      _ -> error \"Unexpected number\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_106","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--የ i ፋክቶሪያል ከ 1 እስከ i ያሉትን ቁጥሮች ማባዛት ነው (1 * 2 * ... * i) ።--i ከ1 ይጀምራል--ወይም ከ1 እስከ i ያሉ ቁጥሮች ድምር --እና መጠን n የሆነ ዝርዝር ይመልሳል፣ ይህም ማለት በ ኢንዴክስ i ላይ ያለው የ ኤለመንት ዋጋ የ i ፋክቶሪያል ከሆነ i እኩል ነው --f ን እንደ ፓራሜትር የሚወስድ ተግባር ተግባራዊ ማድረግ፣--  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =","canonical_solution":"f :: Int -> [Int]\nf n = map g [1..n]\n  where\n    g i\n      | even i    = factorial i\n      | otherwise = sum [1..i]\n    \n    factorial 0 = 1\n    factorial m = product [1..m]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_107","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ 1፦--በቁጥር ክልል ውስጥ የሚወድቁ የሙሉ ቁጥር ፓሊንድሮሞች ((1, n) ጨምሮ) ።--፦ n የተባለ አዎንታዊ ቁጥር ስናቀርብ፣ የሁለትዮሽ ቁጥርን እንመልሳለን--  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =","canonical_solution":"evenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n = (length evens, length odds)\n  where\n    isPalindrome x = show x == reverse (show x)\n    palindromes = filter isPalindrome [1..n]\n    evens = filter even palindromes\n    odds  = filter odd palindromes","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_108","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ -123 ፊርማዎቹ -1, 2 እና 3 ናቸው።--አንድ ቁጥር አሉታዊ ከሆነ የመጀመሪያ ፊርማው ቁጥር አሉታዊ ይሆናል:--የቁጥር ድምር > 0 ያለው የቁጥር ብዛት --☞ የሙሉ ቁጥሮች ዝርዝር የሚወስድ እና የሚመልስ function count_nums ይጻፉ።--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =","canonical_solution":"countNums :: [Int] -> Int\ncountNums arr = length $ filter ((> 0) . sumDigits) arr\n  where\n    sumDigits 0 = 0\n    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)\n                  in sum digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_109","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ማስታወሻ: የተሰጠው ዝርዝር ልዩ የሆኑ ንጥረ ነገሮችን እንዳለው ዋስትና ተሰጥቶታል ።--የተሰጠው ዝርዝር ባዶ ከሆነ True ይመልሳል።--ከዚያም እውነተኛ መመለስ አለበለዚያም ሐሰት መመለስ.--ከላይ የተጠቀሰውን ተግባር በመፈጸም የተደረደሩትን ዝርዝር ማግኘት የሚቻል ከሆነ--በዝርዝሩ ውስጥ ያለው የመነሻ ቦታ ማለትም 0 ኛ መረጃ ጠቋሚ --የዝርዝሩ የመጨረሻው አካል ወደ  ይዛወራል።--አንድ የ ቀኝ ሽግግር ክወና ማለት የዝርዝሩን ንጥረ ነገሮች በሙሉ በአንድ ማዛወር ማለት ነው--በቀኝ በኩል ያለውን እንቅስቃሴ በተለያዩ ጊዜያት ማከናወን ይችላሉ።--በተሰጠው ዝርዝር ውስጥ የሚከተለው ተግባር: -- በመፈፀም ዝርዝር በማይቀንስ ቅደም ተከተል መደርደር ይቻላል ።--በዝርዝሩ ውስጥ ያሉት ቁጥሮች በዘፈቀደ ይደረጋሉ ። የእርስዎ ተግባር መወሰን ነው--የ N ሙሉ ቁጥሮች ዝርዝር አለን arr[1], arr[2], ..., arr[N]--  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given list.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  list by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =","canonical_solution":"moveOneBall :: [Int] -> Bool\nmoveOneBall [] = True\nmoveOneBall arr = canBeSorted (arr ++ arr)\n  where\n    n = length arr\n    canBeSorted xs = any isSorted (take n <$> tails xs)\n    isSorted ys = and $ zipWith (<=) ys (tail ys)\n    tails [] = []\n    tails l@(_:xs) = l : tails xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_110","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--አለበለዚያ \"አይ\" መልሶ ይልኩ--ሁሉም የ lst1 ንጥረ ነገሮች እኩል እንዲሆኑ ፣ \"አዎ\" ይመልሱ ።--ይህ LST1 እና LST2 መካከል አካላት ለመለዋወጥ የሚቻል ከሆነ --በ lst1 እና lst2 መካከል በሚለዋወጡ ንጥረ ነገሮች ብዛት ላይ ምንም ገደብ የለም ።--የ1ኛውን ዝርዝር የሁለት ቁጥር ብቻ ያካተተ እንዲሆን ማድረግ።--እና የንጥረ ነገሮች ልውውጥ ማከናወን ይቻል እንደሆነ ይወስናል -- በዚህ ችግር ውስጥ, እናንተ ቁጥሮች ሁለት ዝርዝሮች የሚወስድ አንድ ተግባር ተግባራዊ ይሆናል, --  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =","canonical_solution":"exchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | all even lst1 = \"YES\"\n  | null oddLst1 || null evenLst2 = \"NO\"\n  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)\n                in if possibility then \"YES\" else \"NO\"\n  where\n    oddLst1 = filter odd lst1\n    evenLst2 = filter even lst2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_111","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--በርካታ ፊደላት ተመሳሳይ ክስተት ካላቸው ሁሉንም መልሰው ያቅርቡ--በጣም ብዙ ጊዜ የተደጋገመውን እና ተመጣጣኝ ቁጥርን የያዘውን ደብዳቤ --❑ የቁጥር ሰንሰለት የተሰጠው ቦታ የተለዩ አነስተኛ ፊደላት የሚወክሉ ሲሆን፣ የግንኙነት ዝርዝር ይመልሱ--  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nhistogram :: String -> [(String, Int)]\nhistogram input =\n  let wordsList = words input\n      grouped = group $ sort wordsList\n      countList = map (\\ws -> (head ws, length ws)) grouped\n      maxCount = if null countList then 0 else maximum $ map snd countList\n  in filter ((== maxCount) . snd) countList","tests":"\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_112","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ --እርስዎ ውጤት ሕብረቁምፊ እና እውነተኛ \/ ሐሰት ለ ማረጋገጥ የያዘ አንድ tuple መመለስ አለበት. --አንድ ሕብረቁምፊ ወደ ኋላም ሆነ ወደ ፊት ተመሳሳይ ከሆነ ፓሊንድሮም ይባላል።--ከዚያም ውጤቱ ሕብረቁምፊ ፓሊንድሮም መሆኑን ያረጋግጡ።--እኛ ሁለት ሕብረቁምፊዎች የተሰጡ ናቸው s እና c, አንተ c ውስጥ ማንኛውም ቁምፊ እኩል ናቸው s ውስጥ ቁምፊዎች በሙሉ መሰረዝ አላቸው --ተልዕኮ--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =","canonical_solution":"import Data.List (filter)\n\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =\n  let result = filter (`notElem` c) s\n  in (result, result == reverse result)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_113","nl":"amh_Ethi","pl":"hs","prompt":"-- የግብዓት i'th ሕብረቁምፊ ውስጥ ያልተለመዱ አሃዞች--\" የት ሁሉ i ዎቹ ቁጥር ጋር መተካት አለበት --እያንዳንዱ የግብዓት i ንጥረ ነገር በ ውስጥ ያሉ ያልተለመዱ ንጥረ ነገሮች ቁጥር መሆን አለበት--እያንዳንዱ ሕብረቁምፊዎች ብቻ አሃዞች ያካተተ የት ሕብረቁምፊዎች ዝርዝር የተሰጠው, አንድ ዝርዝር መመለስ.--  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =","canonical_solution":"oddCount :: [String] -> [String]\noddCount lst = map formatString lst\n  where\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"\n\n    countOdds :: String -> Int\n    countOdds str = length $ filter isOddDigit str\n\n    formatString :: String -> String\n    formatString str =\n      let oddCount = countOdds str in\n      \"the number of odd elements \" ++ show oddCount ++ \n      \"n the str\" ++ show oddCount ++ \"ng \" ++ show oddCount ++\n      \" of the \" ++ show oddCount ++ \"nput.\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_114","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ -- የቁጥር--❑ የጠቅላላ ቁጥሮች ዝርዝር ከተሰጠ፣ ከማንኛውም ባዶ ያልሆነ ንዑስ ዝርዝር አነስተኛውን ድምር ፈልግ።--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =","canonical_solution":"minsubarraysum :: [Int] -> Int\nminsubarraysum nums = minimum $ scanl1 (\\acc x -> min x (acc + x)) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_115","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ 1፦--ወደ ታች ወደ ቆሻሻዎች ያስፈልገናል ጊዜ ቁጥር ውፅዓት. --የእርስዎ ተግባር ጉድጓዶቹን ለማውጣት ባልዲዎችን መጠቀም ነው.--ሁሉም ባልዲዎች ተመሳሳይ አቅም አላቸው ።--እያንዳንዱ ጉድጓድ ውኃ ለማውጣት የሚውል አንድ ባልዲ አለው።--እና እያንዳንዱ 1 በአንድ ረድፍ ውስጥ አንድ ነጠላ የውሃ አሃድ ይወክላል ።--❑ እያንዳንዱ መስመር አንድን ጉድጓድ ይወክላል፣--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =","canonical_solution":"maxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity = ceiling (fromIntegral totalWater \/ fromIntegral capacity)\n  where\n    totalWater = sum (map sum grid)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_116","nl":"amh_Ethi","pl":"hs","prompt":"--እንደሚከተለው መፈጸም አለበት: --ተመሳሳይ ቁጥር ላላቸው ሰዎች በአስርዮሽ ዋጋ ላይ ተመስርተው ይደርሳሉ ።--የሁለትዮሽ ውክልናቸው ውስጥ ያሉ የአንድዎች ቁጥር በዝቅተኛ ቅደም ተከተል።--በዚህ ካታ ውስጥ፣ አሉታዊ ያልሆኑ ሙሉ ቁጥሮች ዝርዝር በ--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =","canonical_solution":"import Data.Bits (popCount)\nimport Data.List (sortBy)\n\nsortArray :: [Int] -> [Int]\nsortArray arr = sortBy compareOnesAndValues arr\n  where\n    compareOnesAndValues x y =\n      let onesX = popCount x\n          onesY = popCount y\n      in if onesX == onesY\n         then compare x y\n         else compare onesX onesY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_117","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ማስታወሻ: የግብዓት ሕብረቁምፊ ፊደላት እና ክፍተቶች ብቻ ይዟል ሊያስቡ ይችላሉ.--s ባዶ ከሆነ ተግባር ባዶ ዝርዝር መመለስ አለበት።--n የቃላት ቅደም ተከተል፣ እነዚህ ቃላት በ s ውስጥ እንዲገኙ።--በትክክል የያዘውን ከ s ሰንሰለት ውስጥ ያሉትን ሁሉንም ቃላት ዝርዝር የሚመልስ ተግባር --s እና n የተፈጥሮ ቁጥር የተሰጠ, እርስዎ ተግባራዊ ለማድረግ ተልዕኮ ተደርጓል --  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =","canonical_solution":"selectWords :: String -> Int -> [String]\nselectWords s n = filter (\\word -> countConsonants word == n) (words s)\n  where\n    countConsonants = length . filter (`elem` consonants)\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_118","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--የተሰጠው ሕብረቁምፊ የእንግሊዝኛ ፊደል ብቻ ይዟል ብሎ ማሰብ ይችላል.--ከላይ የተጠቀሱትን ሁኔታዎች የሚያሟላ ማንኛውም ድምጽ ያለው ፊደል ያግኙ።--መጀመሪያ እና መጨረሻ ላይ የድምጽ ፊደሎች አይቆጠሩም. ባዶ ሕብረቁምፊ ይመልሱ ካልሆነ --ከቃሉ በስተቀኝ በኩል ሁለት የቃላት ፊደላት (የቁጥር ልዩነት) ።--❑ አንድ ቃል ተሰጥቶሃል፤ ግዴታህ ደግሞ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑ ❑--  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =","canonical_solution":"getClosestVowel :: String -> String\ngetClosestVowel word = go (reverse word) False\n  where\n    vowels = \"aeiouAEIOU\"\n    go [] _ = \"\"\n    go (x:xs) lastWasConsonant\n      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False\n      | x `notElem` vowels = go xs True\n      | otherwise = go xs False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_119","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ጥሩ ሕብረቁምፊ ለማድረግ መንገድ ካለ 'አዎ' ይመልሱ፣ አለበለዚያ ደግሞ 'አይደለም' ይመልሱ --\"()) \" የሚለው ቃል አይደለም።--ሚዛናዊ ናቸው ለምሳሌ: '(()))) ጥሩ ነው ፣ እና --አንድ ሰንሰለት S ጥሩ ነው ተብሎ ይታሰባል እና ሁሉም በ S ውስጥ ያሉ ቅንፎች ብቻ --የተወሰነ ቅደም ተከተል፣ ውጤቱ ጥሩ ይሆናል--የእርስዎ ስራ ሁለቱንም ሕብረቁምፊዎች ማገናኘት ይቻል እንደሆነ ማረጋገጥ ነው--በቅንፍ \" ((\" ወይም በቅንፍ \") \" ብቻ።--❑ ሁለት የቁምፊዎች ዝርዝር ይሰጥሃል፣ ሁለቱም የቁምፊዎች ዝርዝር ክፍት ነው።--  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =","canonical_solution":"matchParens :: [String] -> String\nmatchParens [a, b] =\n    if isValid (a ++ b) || isValid (b ++ a) then \"Yes\" else \"No\"\n  where\n    isValid :: String -> Bool\n    isValid = go 0\n      where\n        go 0 [] = True\n        go _ [] = False\n        go n (x:xs)\n            | x == '('  = go (n + 1) xs\n            | x == ')'  = n > 0 && go (n - 1) xs\n    isValid _ = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_120","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ 1፦--ርዝመት k ጋር ከፍተኛው k ቁጥሮች ውስጥ arr. --፦ የጠቅላላ ቁጥሮች ዝርዝር እና k አዎንታዊ ቁጥር የተሰጠ፣ የተደረደሩ ዝርዝር ይመልሱ ፦--  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the list will be in the range of [1, 1000].\n--  2. The elements in the list will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =","canonical_solution":"maximum :: [Int] -> Int -> [Int]\nmaximum arr k = take k $ reverse $ sort arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_121","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --❑ ባዶ ያልሆነ የሙሉ ቁጥሮች ዝርዝር ከተሰጠ በባዶ አቋም ላይ ያሉትን የሁሉም ነጠላ ንጥረ ነገሮች ድምር ይመልሱ--  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =","canonical_solution":"solution :: [Int] -> Int\nsolution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_122","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--የ arr የመጀመሪያዎቹን k ንጥረ ነገሮች ሁለት አሃዞች ካላቸው ንጥረ ነገሮች ድምር። --በቁጥር k እና በቁጥር arr የተሰጡን ኢንቲጀሮች ዝርዝር ተመልሰው ይልኩ--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =","canonical_solution":"addElements :: [Int] -> Int -> Int\naddElements arr k = sum $ filter (\\x -> x >= -99 && x <= 99) $ take k arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_123","nl":"amh_Ethi","pl":"hs","prompt":"--get_odd_collatz(5) ይመልሳል [1, 5] # የ 5 ኮላቲዝ ቅደም ተከተል [5, 16, 8, 4, 2, 1] ነው፣ ስለዚህ ያልተለመዱ ቁጥሮች 1 እና 5 ብቻ ናቸው። --ለምሳሌ፦--በተጨመረው ቅደም ተከተል የተደረደሩ ተመላሽ ዝርዝር --ኮላዝ () ፩ ነው [1]--ማስታወሻ: --n ምንም ይሁን ምን ምን ተከታታይነት ሁልጊዜ 1 ይደርሳል.--ቀዳሚው ቃል ነጠላ ከሆነ ቀጣዩ ቃል 3 እጥፍ ነው--ቀዳሚው ቃል እንደሚከተለው ከሆነ: ቀዳሚው ቃል እኩል ከሆነ ቀጣዩ ቃል ከ  ግማሽ ነው--እንደሚከተለው ይጀምሩ: ከማንኛውም አዎንታዊ ኢንቲጀር n ይጀምሩ ከዚያም እያንዳንዱ ቃል ከ --የኮላትስ ግምታዊ ሀሳብ በሂሳብ ውስጥ የተገለፀውን ቅደም ተከተል የሚመለከት ግምታዊ ሀሳብ ነው --❑ n የተባለ አዎንታዊ ቁጥር ሲሰጠኝ በኮላዝ ቅደም ተከተል ውስጥ ያሉትን ያልተለመዱ ቁጥሮች የያዘ የተደረደሩ ዝርዝር ይመልሱ--  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =","canonical_solution":"getOddCollatz :: Int -> [Int]\ngetOddCollatz n = sort . filter odd $ collatzSequence n\n  where\n    collatzSequence 1 = [1]\n    collatzSequence x\n      | even x    = x : collatzSequence (x `div` 2)\n      | otherwise = x : collatzSequence (3 * x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_124","nl":"amh_Ethi","pl":"hs","prompt":"--4፤ ቀኑ በሚከተለው ቅርጸት መሆን አለበት፡- ሚሜ-ዲዲ-ዓዓዓ --3 ወር ከ1 በታች ወይም ከ12 በላይ መሆን የለበትም።--2. ቀናት ቁጥር 1 ያነሰ ወይም ወራት 31 ቀናት በላይ አይደለም 1,3,5,7,8,10,12. እና ቀናት ቁጥር 1 ያነሰ ወይም ወራት 30 ቀናት በላይ አይደለም 4,6,9,11 ነው. እና, ቀናት ቁጥር 1 ያነሰ ወይም ወር 2 ለ 29 በላይ አይደለም.--1. የ ቀን ሕብረቁምፊ ባዶ አይደለም.--ቀኑ የሚሰራው የሚከተሉት ደንቦች በሙሉ ከተሟሉ ነው: --ቀን ትክክለኛ ከሆነ እውነት ይመልሳል ካልሆነ ግን ሐሰት ነው።--የተሰጠውን ቀን የሚፈቅድ ተግባር መጻፍ አለብህ--  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06\/04\/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =","canonical_solution":"import Text.Read (readMaybe)\nimport Data.List.Split (splitOn)\n\nvalidDate :: String -> Bool\nvalidDate date =\n    case splitOn \"-\" date of\n        [m, d, y] -> isValidMonthDayYear m d y\n        _         -> False\n\nisValidMonthDayYear :: String -> String -> String -> Bool\nisValidMonthDayYear m d y =\n    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of\n        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day\n        _ -> False\n\nisValidMonth :: Int -> Bool\nisValidMonth month = month >= 1 && month <= 12\n\nisValidDay :: Int -> Int -> Bool\nisValidDay month day\n    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31\n    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30\n    | month == 2                           = day >= 1 && day <= 29\n    | otherwise                            = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_126","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ቁጥር ፣ False ይመልሱ አሉታዊ ቁጥሮች እና ሙሉ ቁጥሮች ብቻ አይወስዱ ።--ዝርዝር ከአንድ በላይ ቅጂዎች ካሉት --የቁጥሮች ዝርዝር ከተሰጠ በኋላ የተደረደሩ ወይም ያልተደረደሩ ሆነው ይመልሱ--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =","canonical_solution":"isSorted :: [Int] -> Bool\nisSorted lst = go lst Nothing\n  where\n    go [] _ = True\n    go [x] _ = True\n    go (x:y:xs) prev\n      | x > y = False\n      | x == y && prev == Just x = False\n      | otherwise = go (y:xs) (Just x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_127","nl":"amh_Ethi","pl":"hs","prompt":"--[የመግቢያ\/የመውጫ] ናሙናዎች: --ሁለቱ ክፍተቶች የማይገናኙ ከሆነ \"አይ\" ይመልሱ--አለበለዚያ \"አይሆንም\" የሚል መልስ ይስጡ--የመንገዱ ርዝመት የመጀመሪያ ቁጥር ከሆነ \"YES\" ይመልሱ--ርዝመቱ 1 የሆነ፣ ይህም ፕራይም ቁጥር አይደለም።--ምሳሌ፣ የ (1, 3), (2, 4) ክፍተቶች መቋረጫ (2, 3) ነው--ክፍተቶች ዋና ቁጥር ነው።--የእርስዎ ተግባር እነዚህ ሁለት መካከል መገናኛ ርዝመት እንደሆነ ለመወሰን ነው --ለእያንዳንዱ የተሰጠ ክፍተት ፣ ጅማሬው ከ መጨረሻው ያነሰ ወይም እኩል ነው ተብሎ ይገመታል ።-- መጀመሪያና መጨረሻ--የተሰጡት ክፍተቶች የተዘጉ ናቸው ይህም ማለት ክፍተቱ (መጀመሪያ ፣ መጨረሻ) --እያንዳንዱ ክፍተት ሁለት ሙሉ ቁጥሮች ናቸው ለምሳሌ ክፍተት = (መጀመሪያ ፣ መጨረሻ) = (1, 2)--ሁለት ጊዜ ክፍተት ተሰጥቶሃል፣--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =","canonical_solution":"intersection :: (Int, Int) -> (Int, Int) -> String\nintersection (start1, end1) (start2, end2) = \n    if intersectionLength > 0 && isPrime intersectionLength\n    then \"YES\"\n    else \"NO\"\n  where\n    intersectionStart = max start1 start2\n    intersectionEnd = min end1 end2\n    intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    isPrime :: Int -> Bool\n    isPrime n\n      | n <= 1 = False\n      | n == 2 = True\n      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_128","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--ማስታወሻ: ባዶ ለ ምንም ነገር መመለስ--በዝርዝሩ ውስጥ ያሉትን ቁጥሮች በ1፣ በ-1 ወይም በ0 ይወክላል።--የሙሉ ቁጥሮች ብዛት ድምር በሁሉም ምልክቶች ውጤት ተመንጨ --☞ የሙሉ ቁጥሮች ዝርዝር ተሰጥቶሃል እና መመለስ አለብህ ☞--  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =","canonical_solution":"prodSigns :: [Int] -> Maybe Int\nprodSigns [] = Nothing\nprodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_129","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ዝቅተኛው መንገድ የሚያልፋቸውን ሕዋሳት ላይ እሴቶች የተደረደሩ ዝርዝር ይመልሳል.--መልሱ ልዩ እንደሆነ ዋስትና ተሰጥቶታል።--lst_A[j] = lst_B[j]  የክፍያ መጠኖች--lst_A[i] < lst_B[i] እና ለማንኛውም j (1 <= j <i) እኛ አለን --lst_B, በሌላ አነጋገር, አንድ ኢንቲጀር ኢንዴክስ i (1 <= i <= k)  አለ--(እኛ lst_A እና lst_B እንላቸዋለን) ፣ lst_A በቃል አፃፃፍ አነስተኛ ነው --A እና B የሚሄዱትን ህዋሳት ላይ እሴቶችን በቅደም ተከተል ዝርዝር ካደረጉ በኋላ --አንድ መንገድ ሀ (የ k ርዝመት) ከ መንገድ ቢ (የ k ርዝመት) ያነሰ ነው ተብሎ ይታሰባል --ከመስመር ውጪ መሆን አትችልም።--የግድ የተለየ) ።--k ርዝመት ያለው መንገድ ማለት በትክክል k ሴሎችን መጎብኘት ማለት መሆኑን ልብ ይበሉ (አይደለም)--     --በሌላ አነጋገር, አንተ የአሁኑ ጋር አንድ ጠርዝ የሚጋሩ ሕዋሳት መሄድ ይችላሉ --ከማንኛውም ህዋስ፣ እና በእያንዳንዱ ደረጃ ወደ ማንኛውም የጎረቤት ህዋስ መሄድ ይችላሉ፣ --k ርዝመት ያለው አነስተኛውን መንገድ መፈለግ አለብህ። መጀመር ትችላለህ።--የክፍያ መጠኑ በገጹ ውስጥ አንድ ጊዜ ብቻ ይታያል።--እያንዳንዱ የክፍሉ ክፍል እሴት ይዟል። እያንዳንዱ ሙሉ ቁጥር በ [1, N * N] ክልል ውስጥ ይገኛል--በ N ረድፎች እና N አምዶች (N >= 2) እና k አዎንታዊ ቁጥር ያለው ፍርግርግ ሲሰጠን፣--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =","canonical_solution":"import Data.List (sort, sortBy)\nimport Data.Ord (comparing)\nimport Control.Monad (guard)\n\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k = head $ sort paths\n  where\n    n = length grid\n    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]\n    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n      where\n        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n\n    value (r, c) = grid !! r !! c\n    paths = do\n      start <- cells\n      findPaths k [start]\n    findPaths 1 path = return $ map value path\n    findPaths l path@(current:_) = do\n      next <- neighbors current\n      findPaths (l-1) (next : path)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_130","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --የቲሪቦናቺ ተከታታይ የመጀመሪያዎቹ n + 1 ቁጥሮች።--አንተ አንድ ያልሆነ አሉታዊ ቁጥር n ተሰጥቶሃል, አንተ  ዝርዝር መመለስ አለብን--= 2 + 3 + 3 = 8 ነው--ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት ሶስት....--3 ነው--ትሪአንድ (2) = 1 + (2 \/ 2) = 2 --ለምሳሌ፦--n = n-1 + n-2 + n-1 ከሆነ n ያልተለመደ ነው።--n እኩል ከሆነ 1 + n \/ 2 ነው።--tri(1) = 3 --የቲቢኖቺ ቅደም ተከተል የሚገለጸው በሚከተለው መደጋገም ነው: --ይሁን እንጂ ሰዎች የማያውቁት ነገር የትሪቦናቺ ቅደም ተከተል ነው።--ሁሉም ሰው የፊቦናቺን ቅደም ተከተል ያውቃል፣ በ1950 በሂሳብ ሊቃውንት በጥልቀት ተምረዋል።--  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =","canonical_solution":"tri :: Int -> [Int]\ntri n = map tribonacci [0..n]\n  where\n    -- Define the recursive function to calculate the tribonacci value for a given n\n    tribonacci :: Int -> Int\n    tribonacci 0 = 1\n    tribonacci 1 = 3\n    tribonacci x\n      | even x    = 1 + x `div` 2\n      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_131","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ሁሉም አሃዞች እኩል ከሆኑ 0 ይመልሱ --√ n የተባለ አዎንታዊ ቁጥር ሲሰጠን የንዑስ ቁጥሮች እጥፍ ተመላሽ አድርግ።--  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =","canonical_solution":"digits :: Int -> Int\ndigits n\n  | null oddDigits = 0\n  | otherwise      = product oddDigits\n  where\n    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_132","nl":"amh_Ethi","pl":"hs","prompt":"--ቢያንስ አንድ የክፍል ቅደም ተከተል የተጣበቀበት --ተግባር መለወጥ አለበት እውነት ከሆነ እና ብቻ ከሆነ ብራኬቶች አንድ ትክክለኛ subsequence አለ --☞ አንድን ሰንሰለት እንደ ግብዓት የሚወስድ ተግባር ይፍጠሩ ይህም ካሬ ቅንፍ ብቻ ይይዛል።--  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =","canonical_solution":"isNested :: String -> Bool\nisNested string = go string 0 False\n  where\n    go [] _ nested = nested\n    go (x:xs) depth nested\n      | x == '['  = go xs (depth + 1) (nested || depth >= 1)\n      | x == ']' && depth > 0 = go xs (depth - 1) nested\n      | otherwise = go xs depth nested","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_133","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --እያንዳንዱን ዝርዝር በከፍተኛ ደረጃ ያጠጉት--የተሰጠውን ዝርዝር ውስጥ ያሉትን የቁጥሮች ካሬ ድምር መመለስ አለብዎት፣ --የቁጥሮች ዝርዝር ተሰጥቶሃል።--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =","canonical_solution":"import Data.List (foldl')\nimport Prelude hiding (sum)\n\nsumSquares :: [Float] -> Int\nsumSquares lst = foldl' (\\acc x -> acc + ceiling x ^ 2) 0 lst","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_134","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ማስታወሻ: \"ቃል\" በቦታ የተለዩ የፊደላት ቡድን ነው።--የቃላት ክፍል ሲሆን በሌላ በኩል ደግሞ ሐሰት ነው።--የተሰጠውን ሕብረቁምፊ አንድ ፊደል ቁምፊ ነው እና አይደለም -- የመጨረሻው ቁምፊ  ከሆነ እውነት የሚመልስ ተግባር ይፍጠሩ--  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =","canonical_solution":"checkIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt = \n    let trimmed = reverse . dropWhile (== ' ') $ reverse txt\n    in case trimmed of\n        [] -> False\n        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_135","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --እኩል እሴቶች--እንደዚህ አይነት አካል የለም ከዚያም ይመለሱ -1. የተሰጠው ዝርዝር አይይዝም --ከቀዳሚው አካል ጋር እኩል ወይም ይበልጣል አይደለም ከሆነ-- አንድ አባል ትልቁን ማውጫ የሚመልስ ተግባር ይፍጠሩ ይህም --  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =","canonical_solution":"canArrange :: [Int] -> Int\ncanArrange arr = go arr (-1) 0\n  where\n    go [] maxIdx _ = maxIdx\n    go [_] maxIdx _ = maxIdx\n    go (x:y:xs) maxIdx idx\n      | x >= y    = go (y:xs) idx (idx + 1)\n      | otherwise = go (y:xs) maxIdx (idx + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_136","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --አሉታዊ ወይም አዎንታዊ ኢንቲጀር ከሌለ, ምንም እንደ ይመልሳል.-- አዎንታዊ የሆኑ ሙሉ ቁጥሮች ዝርዝር ውስጥ--ትልቁ አሉታዊ ኢንቲጀር ሲሆን 'b' ትንሹ ነው--ሀ ሀ የሆነ ቦታ አንድ tuple (ሀ, b) የሚመልስ ተግባር ይፍጠሩ --  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =","canonical_solution":"largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst = (largestNegative, smallestPositive)\n  where\n    negatives = filter (< 0) lst\n    positives = filter (> 0) lst\n    largestNegative = if null negatives then Nothing else Just (maximum negatives)\n    smallestPositive = if null positives then Nothing else Just (minimum positives)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_138","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ --፦ የተሰጠው ቁጥር n በትክክል የ 4 አዎንታዊ የቁጥር ድምር ሆኖ ሊጻፍ ይችል እንደሆነ መገምገም--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =","canonical_solution":"isEqualToSumEven :: Int -> Bool\nisEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_139","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--የት n > 0 --ብራዚላዊ_ፋክቶሪያል (n) = n! * (n-1)! * (n-2)! * ... * 1! --የብራዚል ፋክቶሪያል እንዲህ ነው:--  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =","canonical_solution":"specialFactorial :: Int -> Int\nspecialFactorial n = product [factorial x | x <- [1..n]]\n  where\n    factorial 0 = 1\n    factorial k = k * factorial (k - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_140","nl":"amh_Ethi","pl":"hs","prompt":"--ከዚያም ሁሉንም ተከታታይ ክፍተቶች በ -  ይተኩ--እና አንድ ሕብረቁምፊ ከ 2 ተከታታይ ክፍተቶች ካለው, --❑ የጽሑፍ ሰንሰለት ሲሰጥ፣ በውስጡ ያሉትን ክፍተቶች በሙሉ በስር ምልክት ይተኩ፣--  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =","canonical_solution":"fixSpaces :: String -> String\nfixSpaces text = concatMap replaceSpaces (groupSpaces text)\n  where\n    groupSpaces :: String -> [String]\n    groupSpaces [] = []\n    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest\n\n    replaceSpaces :: String -> String\n    replaceSpaces spaces@(x:_)\n      | x == ' ' && length spaces > 2 = \"-\"\n      | x == ' ' = replicate (length spaces) '_'\n      | otherwise = spaces","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_141","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --- የ ንዑስ ገመድ በኋላ ነጥብ ከእነዚህ ውስጥ አንዱ መሆን አለበት: ['txt', 'exe', 'dll'] --የላቲን ፊደል ('a'-'z' እና 'A'-'Z') ።--- ከዶት በፊት ያለው ንዑስ ሰንሰለት ባዶ መሆን የለበትም፣ እና የሚጀምረው በ ፊደል ነው ከ --- የፋይሉ ስም አንድ ነጥብ ብቻ ይዟል።--- የፋይሉ ስም ከሶስት አሃዝ በላይ ('0'-'9') መሆን የለበትም።--ተሟልተዋል: --አንድ የፋይል ስም የሚሰራ የሚሆነው የሚከተሉት ሁኔታዎች በሙሉ ከተሟሉ ብቻ ነው--የፋይሉ ስም ትክክለኛ ከሆነ 'አዎ' ይለካል ፣ አለበለዚያ 'አይሆንም' ይመልሳል ።--የፋይል ስም የሚወክል ሰንሰለት የሚወስድ እና የሚመልስ ተግባር ይፍጠሩ--  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =","canonical_solution":"import Data.Char (isDigit, isLetter)\n\nfileNameCheck :: String -> String\nfileNameCheck file_name \n  | countDots \/= 1 = \"No\"\n  | length digits > 3 = \"No\"\n  | null beforeDot || not (isLetter (head beforeDot)) = \"No\"\n  | afterDot `notElem` validExtensions = \"No\"\n  | otherwise = \"Yes\"\n  where \n    (beforeDot, afterDot) = span (\/= '.') file_name\n    countDots = length $ filter (== '.') file_name\n    digits = filter isDigit file_name\n    validExtensions = [\"txt\", \"exe\", \"dll\"]\n    afterDot = if null dotAndAfter then \"\" else tail dotAndAfter\n    dotAndAfter = dropWhile (\/= '.') file_name","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"\/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_142","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --በዝርዝሩ ውስጥ ያሉትን አንቀጾች ይለውጡ ኢንዴክሶቻቸው የ 3 ወይም የ 4 እጥፍ አይደሉም ። ከዚያ ተግባሩ የሁሉም ግቤቶች ድምር ይመልሳል ።--የ 3 እጥፍ ሲሆን ኢንዴክሱ የ 4 እጥፍ ከሆነ እና የ 3 እጥፍ ካልሆነ የሙሉ ቁጥርን ግቤት ይጨምራል።--ይህ ተግባር የሙሉ ቁጥሮች ዝርዝር ይወስዳል። ለዝርዝሩ ውስጥ ላሉት ሁሉም ግቤቶች ፣ ተግባሩ ኢንዴክሱ ሀ ከሆነ የሙሉ ቁጥር ግቤቱን ካሬ ያደርገዋል ።--\" ፦--  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =","canonical_solution":"sumSquares :: [Int] -> Int\nsumSquares lst = sum $ zipWith transform [0..] lst\n  where\n    transform idx x\n      | idx `mod` 3 == 0 = x * x\n      | idx `mod` 4 == 0 = x * x * x\n      | otherwise        = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_143","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ 1፦--በአዲሱ ሰንሰለት ውስጥ ያሉት ቃላት ቅደም ተከተል ከመጀመሪያው ጋር ተመሳሳይ መሆን አለበት ።--ርዝመቶቹም አቢይ ቁጥሮች ናቸው፣--እና ከዋናው ዓረፍተ ነገር ቃላትን የያዘ ሰንሰለት መመለስ አለብዎት ፣ --ዓረፍተ ነገሩ በቦታ የተለዩ አንዳንድ ቃላትን ይ containsል ፣ --❑ አንድን ዓረፍተ ነገር የሚወክል ሰንሰለት ተሰጥቶሃል፣--  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =","canonical_solution":"import Data.List (intercalate)\n\nwordsInSentence :: String -> String\nwordsInSentence sentence = intercalate \" \" $ filter (isPrime . length) (words sentence)\n\nisPrime :: Int -> Bool\nisPrime n | n < 2     = False\n          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_144","nl":"amh_Ethi","pl":"hs","prompt":"--x እና n ትክክለኛ ክፍልፋዮች ናቸው እና እንደ አጠራሩ ዜሮ የላቸውም ብለው ሊገምቱ ይችላሉ።--<numerator>\/<denominator> ይህም ቁጥርና አጠራር አዎንታዊ ሙሉ ቁጥሮች ናቸው።--x እና n ሁለቱም የቁጥር ቅደም ተከተል የቁጥር ቅደም ተከተል ናቸው፣ እና የሚከተለውን ቅርጸት አላቸው፣--x * n የ ተግባር x * n ወደ ሙሉ ቁጥር እና ሐሰት  የሚገመግም ከሆነ እውነት ይመልሳል--የእርስዎ ተግባር አገላለጽ ለማቅለል አንድ ተግባር ተግባራዊ ለማድረግ ነው --  >>> simplify \"1\/5\" \"5\/1\"\n--  True\n--  >>> simplify \"1\/6\" \"2\/1\"\n--  False\n--  >>> simplify \"7\/10\" \"10\/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =","canonical_solution":"import Data.Ratio (denominator, numerator, (%))\n\nsimplify :: String -> String -> Bool\nsimplify x n =\n  let (xNum, xDen) = toFraction x\n      (nNum, nDen) = toFraction n\n      result = (xNum * nNum) % (xDen * nDen)\n  in denominator result == 1\n\ntoFraction :: String -> (Integer, Integer)\ntoFraction s =\n  let (numStr, _:denStr) = break (=='\/') s\n  in (read numStr, read denStr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/6\" \"2\/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/1\" \"3\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/10\" \"10\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/10\" \"50\/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/2\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11\/6\" \"6\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/3\" \"5\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/2\" \"3\/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"8\/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"1\/5\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_145","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--በዋናው ዝርዝር ውስጥ ባለው መረጃ ጠቋሚ መሠረት ያዘዟቸው።--ማስታወሻ: ቁጥራቸው ተመሳሳይ የሆነ በርካታ ቁጥሮች ካሉ --በቁጥራቸው ብዛት መሠረት በዝቅተኛ ቅደም ተከተል --፦ የተሰጠውን የሙሉ ቁጥሮች ዝርዝር የሚደርደር ተግባር ጻፍ።--  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =","canonical_solution":"import Data.List (sortBy)\nimport Data.Function (on)\n\norderByPoints :: [Int] -> [Int]\norderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums\n  where\n    sumOfDigits :: Int -> Int\n    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)\n    \n    indexedNums :: [(Int, Int)]\n    indexedNums = zip (map sumOfDigits nums) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_146","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--የአንድ ቁጥር የመጀመሪያ እና የመጨረሻ አሃዞች ነጠላ (1, 3, 5, 7, 9) ናቸው።--በዝርዝሩ ውስጥ ከ 10 በላይ የሆኑትን እና ሁለቱንም --የቁጥሮች ዝርዝር እንደ ግብዓት የሚወስድ እና የሚመልስ ተግባር ይጻፉ።--  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =","canonical_solution":"specialfilter :: [Int] -> Int\nspecialfilter nums = length $ filter isSpecial nums\n  where\n    isSpecial n = n > 10 && isOddFirstAndLast (abs n)\n\n    isOddFirstAndLast :: Int -> Bool\n    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit\n      where\n        xStr = show x\n        firstDigit = head xStr\n        lastDigit = last xStr\n\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_147","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ: --እና ሀ [i] + ሀ [j] + ሀ [k] የ3 እጥፍ ነው።--i < j < k,  የሆነበት የሶስትዮሽ (a[i], a[j], a[k]) ቁጥርን ይመልሱ--ለእያንዳንዱ i (1 ≤ i ≤ n) ፣ የ a [i] = i * i - i + 1 ዋጋ።--n የተባለ አዎንታዊ ቁጥር ተሰጥቶሃል፤ n የሆነ የቁጥር ዝርዝር መፍጠር አለብህ።--  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =","canonical_solution":"getMaxTriples :: Int -> Int\ngetMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]\n  where\n    a = [i * i - i + 1 | i <- [1..n]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_149","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--ሁሉም ቃላት እኩል ርዝመት ይኖራቸዋል ብለህ ታስብ ይሆናል።--ተግባሩ በተደረደሩ ቅደም ተከተል የሰንሰለት ዝርዝር መመለስ አለበት።--ሁለት ቃላት ተመሳሳይ ርዝመት ካላቸው ዝርዝሩን በፊደል አጻጻፍ አደረጃጀት ይደርሱ።--በዚህ ደንብ መሠረት የተደረደሩትን ዝርዝር መመለስ አለበት ።--የዝርዝሩ ቅደም ተከተል በእያንዳንዱ ቃል ርዝመት ላይ መጨመር አለበት፣ እና እርስዎ --እንዲሁም ሁለት ቅጂዎች ሊይዝ ይችላል።--ዝርዝሩ ሁልጊዜ የቁምፊዎች ዝርዝር ነው እና የቁጥሮች ዝርዝር በጭራሽ አይደለም ፣--እና የተገኘውን ዝርዝር በተደረደሩ ቅደም ተከተል ይመልሳል ፣ --ከእሱ ጋር ያልተለመዱ ርዝመቶች ያላቸውን ሕብረቁምፊዎች ይሰርዛል ፣ --❑ የቁምፊዎች ዝርዝር እንደ መለኪያ የሚቀበል ተግባር ጻፍ፣--  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =","canonical_solution":"sortedListSum :: [String] -> [String]\nsortedListSum lst = sortBy compareStrings (filter evenLength lst)\n  where\n    evenLength s = even (length s)\n    compareStrings s1 s2\n      | length s1 == length s2 = compare s1 s2\n      | otherwise = compare (length s1) (length s2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_150","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --አንድ ዋና ቁጥር እና y ዋጋ መመለስ አለበት አለበለዚያ. --n ከሆነ የ x ዋጋን የሚመልስ ቀላል ፕሮግራም--  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =","canonical_solution":"xOrY :: Int -> Int -> Int -> Int\nxOrY n x y = if isPrime n then x else y\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_151","nl":"amh_Ethi","pl":"hs","prompt":"--በዝርዝሩ ውስጥ ያሉ ያልተለመዱ ቁጥሮች አሉታዊ የሆኑትን ወይም ሙሉ ቁጥሮች ያልሆኑትን ቁጥሮች ችላ ይበሉ--የቁጥሮች ዝርዝር ሲሰጥ የቁጥሮች ካሬ ድምርን ይመልሱ--  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =","canonical_solution":"doubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst = \n    sum [x * x | x <- map round lst, x > 0, odd x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_152","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--ዋጋው 0 ነው ፣ ካልሆነ ደግሞ ዋጋው በግምቱ እና በደረጃው መካከል ያለው ፍጹም ልዩነት ነው።--እያንዳንዱ ግምታዊ ግምታዊ ግምታዊ ግምታዊ ግምታዊ ግምታዊ ዝርዝር ይመለስ.--እኩል ርዝመት ያላቸው ሁለት የደረጃዎች ዝርዝር እና ግምቶች ይሰጡዎታል ፣ እያንዳንዱ መረጃ ጠቋሚ ግጥሚያ ያሳያል ።--የእርስዎ ተግባር አንድ ሰው በትክክል ግጥሚያዎች በርካታ ውጤቶች ገምቷል እንደሆነ መወሰን ነው.-- የኤሌክትሮኒክስ ቴክኖሎጂን በተመለከተ--በዚህ ጊዜ የሚሰማዎት ስሜት እና ሀሳብ --❑ ለረጅም ጊዜ ሲጠበቅ የነበረው ነገር ሲመጣ የሚሰማንን ስሜት ሁላችንም እናስታውሳለን ብዬ አስባለሁ።--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =","canonical_solution":"compare :: [Int] -> [Int] -> [Int]\ncompare game guess = zipWith (\\g s -> abs (g - s)) game guess","tests":"\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_153","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--(ጥንካሬው -1) ነው።--\"Slices.SERVINGSliCes\" መልሶ ያቀርባል ምክንያቱም \"SERVINGSliCes\" በጣም ጠንካራው ቅጥያ ስለሆነ --ቅጥያዎች: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ከዚያ እርስዎ ማድረግ ያለብዎት --ለምሳሌ ያህል, እርስዎ \"ቁርጥራጮች\" እንደ ክፍል እና ዝርዝር የተሰጠ ከሆነ --በዝርዝሩ ውስጥ መጀመሪያ የሚመጣውን ይምረጡ።--ሁለት ወይም ከዚያ በላይ ተመሳሳይ ጥንካሬ ያላቸው ቅጥያዎች ካሉ, እርስዎ ማድረግ ያለብዎት--ቅርጸት: ClassName.StrongestExtensionName. --በጣም ጠንካራውን ቅጥያ ፈልጎ እዚህ ውስጥ አንድ ሕብረቁምፊ መመለስ አለብዎት--በኤክስቴንሽኑ ስም ውስጥ ያለው ጥንካሬ በ CAP - SM ክፍልፋይ ይሰጣል ።--በኤክስቴንሽኑ ስም ውስጥ ያሉ ፊደላት እና SM የትንሽ ፊደላት ቁጥር ይሁን --የኤክስቴንሽኑ ጥንካሬ እንደሚከተለው ነው: CAP የዋና ፊደል ቁጥር ይሁን --ቅጥያዎቹ ለክፍል ተጨማሪ ክፍሎችን ለመጫን ጥቅም ላይ ይውላሉ ።--❑ የክፍል ስም (የአንድ ሕብረቁምፊ) እና የቅጥያዎች ዝርዝር ይሰጥሃል።--  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =","canonical_solution":"strongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions = class_name ++ \".\" ++ strongestExt\n  where\n    calculateStrength :: String -> Int\n    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)\n    \n    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)\n    \n    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)\n    maxStrength ext1 ext2\n      | snd ext1 > snd ext2 = ext1\n      | otherwise           = ext2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_154","nl":"amh_Ethi","pl":"hs","prompt":"--ሁለት ቃላት ተሰጥተውሃል:: ሁለተኛው ቃል ወይም ማንኛውም መዞሩ የመጀመሪያውን ቃል ውስጥ የንዑስ ሰንሰለት ከሆነ እውነት መመለስ አለብህ--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =","canonical_solution":"cycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b = any (`isInfixOf` a) rotations\n  where\n    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_155","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--☞ አንድ ሙሉ ቁጥር ከተሰጠ፣ በቅደም ተከተል የቁጥር ብዛት ያላቸው እና ያልተለመዱ ቁጥሮች ያሉት አንድ ጥምር ይመልሳል።--  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =","canonical_solution":"evenOddCount :: Int -> (Int, Int)\nevenOddCount num = (length evens, length odds)\n  where\n    digits = map (read . (:[])) . show . abs $ num\n    evens = filter even digits\n    odds  = filter odd digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_156","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ገደቦች: 1 <= ቁጥር <= 1000 --እና በትንሽ ፊደል መልሰው።--❑ አዎንታዊ የሆነን ሙሉ ቁጥር ስጥ፣ የሮማን አሃዝ እኩል የሆነን እንደ ሰንሰለት ❑ አዎንታዊ የሆነን ሙሉ ቁጥር ስጥ፣ የሮማን አሃዝ እኩል የሆነን እንደ ሰንሰለት ❑ አዎንታዊ የሆነን ሙሉ ቁጥር ስጥ፣ የሮማን አሃዝ እኩል የሆነን እንደ ሰንሰለት ❑--  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =","canonical_solution":"intToMiniRoman :: Int -> String\nintToMiniRoman number = concatMap (replicateSymbol number) romanNumerals\n  where\n    romanNumerals = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n                     (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n                     (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    \n    replicateSymbol :: Int -> (Int, String) -> String\n    replicateSymbol n (value, symbol)\n      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)\n      | otherwise = \"\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_157","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--90 ዲግሪ--ቀጥ ያለ ማዕዘን ያለው ሶስት ማዕዘን አንድ ማዕዘን ቀጥ ያለ ማዕዘን ወይም --ጎኖች ቀኝ ማዕዘን ያለው ሶስት ማዕዘን ያደርጉታል ፣ አለበለዚያ ሐሰት ነው ።--የሶስት ማዕዘን ጎኖች ርዝመት ከተሰጠ እውነት ይመልሳል--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =","canonical_solution":"rightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c = \n    let [x, y, z] = sort [a, b, c]\n    in x^2 + y^2 == z^2\n    where sort = Data.List.sort","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_158","nl":"amh_Ethi","pl":"hs","prompt":"--ፊደላት ፣ በቃል ቅደም ተከተል ውስጥ መጀመሪያ የሚመጣውን ይመልሱ ።--በርካታ ሕብረቁምፊዎች ቢኖሩ ከፍተኛው ልዩ --ዝርዝሩ የተለያዩ ቃላትን ይዟል። ከፍተኛውን ቁጥር  ይዞ ቃሉን ይመልሱ-- strings ዝርዝር የሚቀበል ተግባር ይጻፉ.--  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =","canonical_solution":"import Data.List (nub, sort)\n\nfindMax :: [String] -> String\nfindMax words = \n    head . sort . map snd . filter (\\(n, _) -> n == maxUnique) $ wordUniquePairs\n  where\n    wordUniquePairs = [(length . nub $ word, word) | word <- words]\n    maxUnique = maximum $ map fst wordUniquePairs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_159","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌ፦--በቂ የሆነ የቀረ ካሮት ከሌለ የቀረውን ካሮት ሁሉ ትበላለህ፤ ሆኖም ግን አሁንም ትራባለህ።--] --[ከመመገብህ በኋላ የበላሃቸው ካሮት ብዛት፣ --አሁን ግን የቀኑን ምግብ ለማጠናቀቅ ተጨማሪ ካሮት መብላት ያስፈልግሃል።--❑ የተራበ ጥንቸል ነህ፤ የተወሰነውን የካሮት መጠን በልተሃል፤--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =","canonical_solution":"eat :: Int -> Int -> Int -> [Int]\neat number need remaining\n  | remaining >= need = [number + need, remaining - need]\n  | otherwise = [number + remaining, 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_160","nl":"amh_Ethi","pl":"hs","prompt":"--የኦፕሬተር ዝርዝር ቢያንስ አንድ ኦፕሬተር አለው፤ የኦፕሬንድ ዝርዝር ደግሞ ቢያንስ ሁለት ኦፕሬንድ አለው።--ኦፐራንድ አሉታዊ ያልሆኑ ሙሉ ቁጥሮች ዝርዝር ነው።--የኦፕሬተር ዝርዝር ርዝመት ከኦፕሬንድ ዝርዝር ርዝመት ሲቀነስ አንድ ነው ።--ማስታወሻ: --=> ውጤት = 9 --ውጤቱ 2 + 3 * 4 - 5 ነው--ዝርዝር = [2, 3, 4, 5] --ኦፕሬተር['+'፣ '*'፣ '-'] --ምሳሌ፦--የቁጥር አሃዝ (**) --የመሬት ክፍልፋይ ( \/\/ ) --ማባዛት ( *) --መቀነስ ( - ) --መጨመር (+) --መሰረታዊ የአልጀብራ ስራዎች: --መግለጫ እና የዚህን አገላለጽ ግምገማ ይመልሱ ።--ሁለተኛው ዝርዝር የሙሉ ቁጥሮች ዝርዝር ነው። አልጀብሪክን ለመገንባት ሁለቱ የተሰጡ ዝርዝሮችን ይጠቀሙ --ሁለት ዝርዝር ኦፕሬተሮች እና ኦፐራንዶች ሲሰጡ የመጀመሪያው ዝርዝር መሰረታዊ የአልጀብራ ስራዎች አሉትdoAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =","canonical_solution":"doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand = evaluate operand operator\n  where\n    evaluate [x] [] = x\n    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops\n      where\n        result = applyOperation op x y\n\n    applyOperation \"+\" a b = a + b\n    applyOperation \"-\" a b = a - b\n    applyOperation \"*\" a b = a * b\n    applyOperation \"\/\/\" a b = a `div` b\n    applyOperation \"**\" a b = a ^ b\n    applyOperation _ _ _ = error \"Unsupported operation\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"\/\/\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_161","nl":"amh_Ethi","pl":"hs","prompt":"--ምሳሌዎች --ተግባሩ የተገኘውን ሰንሰለት መመለስ አለበት።--ሰንሰለቱ ምንም ፊደላት ከሌለው ሰንሰለቱን ይለውጡት።--አለበለዚያ እንደነበረው ይቀጥል።--s[i] ፊደል ከሆነ፣ ፊደሉን ከታች ወደ ላይ ወይም በተቃራኒው ይለውጡ፣ --❑ አንድ የስልክ ቁጥር ይሰጥሃል።--  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =","canonical_solution":"solve :: String -> String\nsolve s\n  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s\n  | otherwise = reverse s\n  where\n    toggleCase c\n      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char\n      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_162","nl":"amh_Ethi","pl":"hs","prompt":"--'text' ባዶ የሆነ ሕብረቁምፊ ከሆነ፣ ምንም አይመልስም።--❑ የ'ጽሑፍ' የተባለ የቁምፊ ቁጥር ከተሰጠ፣ የ md5 ሃሽ ተመጣጣኝ የሆነውን የቁምፊ ቁጥር ይመልስ።--  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =","canonical_solution":"import qualified Data.ByteString.Char8 as C\nimport qualified Data.Digest.Pure.MD5 as MD5\n\nstringToMd5 :: String -> Maybe String\nstringToMd5 text\n  | null text = Nothing\n  | otherwise = Just $ show $ MD5.md5 $ C.pack text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_163","nl":"amh_Ethi","pl":"hs","prompt":"--ለምሳሌ፦--እና ለ፣ በማደግ ላይ።--ሁለት አዎንታዊ ሙሉ ቁጥሮች ሀ እና ለ የተሰጡ ከሆነ በ a እና b መካከል ያለውን እኩል ቁጥር ይመልሱ--  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =","canonical_solution":"generateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b = filter even [min a b .. max a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()"}]