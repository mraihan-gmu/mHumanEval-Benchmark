task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,mos_Latn,hs,"--B sẽn dat n maan bũmb ningã--Ges-y sã n yaa sõor a yiib n pẽ taab n yɩɩd --  >>> hasCloseElements [1.0,2.0,3.0] 0.5
--  False
--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3
--  True
hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold =","hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold = any (\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a /= b]","
main :: IO ()
main = do
  let candidate = hasCloseElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_1,mos_Latn,hs,"--Ra ges-y zĩ-zãrs nins sẽn be sõsgã pʋgẽ wã ye.--B sẽn yãkd b sullã to-to wã zemsame (yẽk fãa sẽn pakã sɛgdame tɩ zemsã) la b pa kẽed taab ye.--welg-y sull-kãng n welg-a n lebg sõor-yend n lebg n wa ne b sõorã. --Fõn-kãng sẽn kẽed ne tʋʋm kãnga yaa sõn-vãoog sẽn tar sull wʋsg sẽn naag taab n be ne kãn-kãe.--  >>> separateParenGroups ""( ) (( )) (( )( ))""
--  [""()"",""(())"",""(()())""]
separateParenGroups :: String -> [String]
separateParenGroups paren_string =","separateParenGroups :: String -> [String]
separateParenGroups paren_string = go paren_string 0 [] """" []
  where
    go [] _ _ current acc = if null current then acc else acc ++ [current]
    go (x:xs) depth stack current acc
      | x == ' ' = go xs depth stack current acc
      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc
      | x == ')' =
          let newCurrent = current ++ [x]
              newDepth = depth - 1
          in if newDepth == 0
             then go xs newDepth (tail stack) """" (acc ++ [newCurrent])
             else go xs newDepth (tail stack) newCurrent acc
      | otherwise = error ""Unexpected character""","
main :: IO ()
main = do
  let candidate = separateParenGroups
  if candidate ""(()()) ((())) () ((())()())"" == [""(()())"",""((()))"",""()"",""((())()())""] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [""()"",""(())"",""((()))"",""(((())))""] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [""(()(())((())))""] then pure () else error ""assertion failed""
  if candidate ""( ) (( )) (( )( ))"" == [""()"",""(())"",""(()())""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_2,mos_Latn,hs,"--Rɩk sõorã n lebg n wa. --(Bãng-y tɩ bũmb ning sẽn ketã yaa bilf n yɩɩd a ye bala.)--la pʋɩ-sʋk (sẽn yaa a soab sẽn yaa-a kãseng n yɩɩd yaa a sẽn yaa-a bilf n yɩɩd sõor ning b sẽn kõ wã) la pʋɩ-sʋk --D sã n ges tɩ yaa sõor sẽn yaa sõma, d tõe n welga rẽ n lebg --  >>> truncateNumber 3.5
--  0.5
truncateNumber :: Float -> Float
truncateNumber number =","truncateNumber :: Float -> Float
truncateNumber number = number - fromIntegral (floor number)","
main :: IO ()
main = do
  let candidate = truncateNumber
  if candidate 3.5 == 0.5 then pure () else error ""assertion failed""
  if candidate 1.25 == 0.25 then pure () else error ""assertion failed""
  if candidate 123.0 == 0.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_3,mos_Latn,hs,"--Rẽ poore, a segd n lebg n togsa sɩd bala. Sã n pa rẽ, a segd n lebg n togsa ziri.--y tʋʋmda yaa yãag sã n mikame tɩ wakat ning fãa, y ligdã sãnda paoogame n ta zéro, la --A kõ-y-la bĩngr la b yiisr tʋʋm-te-kãsems b bĩngr-n-taagẽ wã sẽn sɩng ne .--  >>> belowZero [1,2,3]
--  False
--  >>> belowZero [1,2,(-4),5]
--  True
belowZero :: [Int] -> Bool
belowZero operations =","belowZero :: [Int] -> Bool
belowZero operations = any (< 0) $ scanl (+) 0 operations","
main :: IO ()
main = do
  let candidate = belowZero
  if candidate [] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-4),5,6] == True then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error ""assertion failed""
  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_4,mos_Latn,hs,"--MAD = average. x - x_mean. --B sẽn boond tɩ "" Elements "" wã la b sẽn boond tɩ "" Centre "" wã (dẽnd sẽn dat n yeel tɩ "" moyenne "" wã): --Sẽn yaa bũmb ning fãa la b sẽn maan tɩ b pa tõe n bãngã yaa tɩ b sẽn pa tõe n bãngã yaa bũmb ning fãa la b sẽn pa tõe n bãngã.--Sẽn yɩɩd fãa, b sẽn na n maan to-to n tõog n paam n maan woto wã yaa bũmb sẽn yaa toor ne b sẽn da tagsdã.--Sẽn na yɩl n bãng sõor nins sẽn be sõor ning pʋgẽ wã, bɩ y bãng sẽn yaa to-to tɩ b pa tũ taab ye.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]
--  1.0
meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers =","meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers = sum absoluteDifferences / fromIntegral (length numbers)
  where
    mean = sum numbers / fromIntegral (length numbers)
    absoluteDifferences = map (\x -> abs (x - mean)) numbers","
main :: IO ()
main = do
  let candidate = meanAbsoluteDeviation
  if candidate [1.0,2.0] == 0.5 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_5,mos_Latn,hs,"--☐ Sõngd-y tɩ y bãng n yãk sõor sẽn zems ne y sẽn datã.--  >>> intersperse [] 4
--  []
--  >>> intersperse [1,2,3] 4
--  [1,4,2,4,3]
intersperse :: [Int] -> Int -> [Int]
intersperse numbers delimeter =","intersperse :: [Int] -> Int -> [Int]
intersperse [] _ = []
intersperse [x] _ = [x]
intersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","
main :: IO ()
main = do
  let candidate = intersperse
  if candidate [] 7 == [] then pure () else error ""assertion failed""
  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error ""assertion failed""
  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_6,mos_Latn,hs,"--Wala makre, (() (()) tara sẽn yɩɩd bĩis a yiib n beẽ, t'a ((())) tar a tãabo. --Sẽn kẽed ne sull fãa, wilg-y sẽn kẽed ne sull fãa n yɩɩd fãa.-- Fõn-kãng sẽn kẽed ne tʋʋm kãnga yaa sõn-vãoog sẽn wilgd sull wʋsg sẽn be gãn-vãoog sẽn be b toore, tɩ zĩ-zãrsã welg-ba.--  >>> parseNestedParens ""(()()) ((())) () ((())()())""
--  [2,3,1,3]
parseNestedParens :: String -> [Int]
parseNestedParens paren_string =","parseNestedParens :: String -> [Int]
parseNestedParens paren_string = map maxDepth (words paren_string)
  where
    maxDepth :: String -> Int
    maxDepth = go 0 0
      where
        go :: Int -> Int -> String -> Int
        go currentDepth maxDepth [] = maxDepth
        go currentDepth maxDepth (c:cs)
          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs
          | c == ')'  = go (currentDepth - 1) maxDepth cs
          | otherwise = go currentDepth maxDepth cs","
main :: IO ()
main = do
  let candidate = parseNestedParens
  if candidate ""(()()) ((())) () ((())()())"" == [2,3,1,3] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [4] then pure () else error ""assertion failed""
  pure ()"
HumanEval_7,mos_Latn,hs,"--☐ Sõng-y tɩ y bãng y sẽn tõe n maan to-to n paam tɩ b kõ yãmb sõng-y-yã--  >>> filterBySubstring [] ""a""
--  []
--  >>> filterBySubstring [""abc"",""bacd"",""cde"",""array""] ""a""
--  [""abc"",""bacd"",""array""]
filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring =","filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring = filter (substring `isInfixOf`) strings
  where isInfixOf = isInfixOf","
main :: IO ()
main = do
  let candidate = filterBySubstring
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""aaaxxy"",""john doe"",""xxxAAA"",""xxx""] ""xx"" == [""xxx"",""aaaxxy"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""grunt"",""trumpet"",""prune"",""gruesome""] ""run"" == [""grunt"",""prune""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_8,mos_Latn,hs,"--Sẽn pa be wã segd n yɩɩ 0 tɩ sẽn pa be wã segd n yɩɩ 1.--☐ Sã n yaa ne sõor sẽn kõ, lebg n wa ne tuple sẽn naag ne sõor la sẽn paasd sõor fãa sẽn be sõor-kãng pʋgẽ wã.--  >>> sumProduct []
--  (0, 1)
--  >>> sumProduct [1,2,3,4]
--  (10, 24)
sumProduct :: [Int] -> (Int, Int)
sumProduct numbers =","sumProduct :: [Int] -> (Int, Int)
sumProduct numbers = (sum numbers, product numbers)","
main :: IO ()
main = do
  let candidate = sumProduct
  if candidate [] == (0, 1) then pure () else error ""assertion failed""
  if candidate [1,1,1] == (3, 1) then pure () else error ""assertion failed""
  if candidate [100,0] == (100, 0) then pure () else error ""assertion failed""
  if candidate [3,5,7] == (15, 105) then pure () else error ""assertion failed""
  if candidate [10] == (10, 10) then pure () else error ""assertion failed""
  pure ()"
HumanEval_9,mos_Latn,hs,"--B sẽn na n maan to-to wã.--◯ Ne sõor sẽn kõ sẽn yaa sõor sẽn pa zãngã, d na n paama sõor sẽn yaa kãn-kãe n yɩɩd sẽn yãe hal tɩ ta wakat ning b sẽn kõ wã.--  >>> rollingMax [1,2,3,2,3,4,2]
--  [1,2,3,3,3,4,4]
rollingMax :: [Int] -> [Int]
rollingMax numbers =","rollingMax :: [Int] -> [Int]
rollingMax = scanl1 max","
main :: IO ()
main = do
  let candidate = rollingMax
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error ""assertion failed""
  pure ()"
HumanEval_10,mos_Latn,hs,"--- Add to the end of the string reverse of a string prefix that comes before the palindromic suffix.  tall n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas n paas--- Bao-y n bãng-y sẽn yaa to-to tɩ y sã n wa kõ-y sõor a woto, y sã n wa paam-a, a yɩ-la wa palindrõme.--A sẽn dat n maan bũmb ningã yaa nana:--Bao-y palindrom ning sẽn yaa zulumsi, n sɩng ne sõor sẽn be wã.--  >>> makePalindrome """"
--  """"
--  >>> makePalindrome ""cat""
--  ""catac""
--  >>> makePalindrome ""cata""
--  ""catac""
makePalindrome :: String -> String
makePalindrome string =","makePalindrome :: String -> String
makePalindrome string = string ++ reverse (take (length string - palindromeLength) string)
  where
    palindromeLength = longestPalindromicSuffix string

longestPalindromicSuffix :: String -> Int
longestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]

isPalindrome :: String -> Bool
isPalindrome s = s == reverse s","
main :: IO ()
main = do
  let candidate = makePalindrome
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""x"" == ""x"" then pure () else error ""assertion failed""
  if candidate ""xyz"" == ""xyzyx"" then pure () else error ""assertion failed""
  if candidate ""xyx"" == ""xyx"" then pure () else error ""assertion failed""
  if candidate ""jerry"" == ""jerryrrej"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_11,mos_Latn,hs,"--Bõn-kãens fãa zug bɩ y maan XOR sẽn yaa yiib-n-soab n lebg n wa ne bi-beoog sẽn yaa sõor sẽn yaa toore.--☐ A la b yaa sõor sẽn pa ta a ye la a ye.--  >>> stringXor ""010"" ""110""
--  ""100""
stringXor :: String -> String -> String
stringXor a b =","stringXor :: String -> String -> String
stringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","
main :: IO ()
main = do
  let candidate = stringXor
  if candidate ""111000"" ""101010"" == ""010010"" then pure () else error ""assertion failed""
  if candidate ""1"" ""1"" == ""0"" then pure () else error ""assertion failed""
  if candidate ""0101"" ""0000"" == ""0101"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_12,mos_Latn,hs,"--B sã n wa lebg n wa ne bũmb ye, yaa tɩ b sã n wa lebg n wa ne bũmb ye.--D sã n na n yã sõor sẽn yaa zulumsi, d na n lebg n wa ne pipi sõorã.--  >>> longest []
--  Just (Nothing)
--  >>> longest [""a"",""b"",""c""]
--  Just (""a"")
--  >>> longest [""a"",""bb"",""ccc""]
--  Just (""ccc"")
longest :: [String] -> Maybe String
longest strings =","longest :: [String] -> Maybe String
longest [] = Nothing
longest strings = Just $ foldl1 (\acc x -> if length x > length acc then x else acc) strings","
main :: IO ()
main = do
  let candidate = longest
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == Just (""x"") then pure () else error ""assertion failed""
  if candidate [""x"",""yyy"",""zzzz"",""www"",""kkkk"",""abc""] == Just (""zzzz"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_13,mos_Latn,hs,"--D lebg n wa ne a la b sẽn yaa nimero a yiib sẽn yaa zãngã pʋɩtb sẽn yaa kãseng n yɩɩdã.--  >>> greatestCommonDivisor 3 5
--  1
--  >>> greatestCommonDivisor 25 15
--  5
greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b =","greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b
  | b == 0    = a
  | otherwise = greatestCommonDivisor b (a `mod` b)","
main :: IO ()
main = do
  let candidate = greatestCommonDivisor
  if candidate 3 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 15 == 5 then pure () else error ""assertion failed""
  if candidate 49 14 == 7 then pure () else error ""assertion failed""
  if candidate 144 60 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_14,mos_Latn,hs,"--☐ A lebg n wa ne a prefiks fãa sẽn sɩng ne sẽn yaa-a n yao n ta sẽn yaa-a n zãag n yɩɩdã ☐ A lebg n wa ne a prefiks fãa sẽn sɩng ne sẽn yaa-a n zãag n yɩɩdã ☐ A lebg n wa ne a prefiks fãa sẽn sɩng ne sẽn yaa-a n zãag n yɩɩdã ☐--  >>> allPrefixes ""abc""
--  [""a"",""ab"",""abc""]
allPrefixes :: String -> [String]
allPrefixes string =","allPrefixes :: String -> [String]
allPrefixes string = [take n string | n <- [1 .. length string]]","
main :: IO ()
main = do
  let candidate = allPrefixes
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""asdfgh"" == [""a"",""as"",""asd"",""asdf"",""asdfg"",""asdfgh""] then pure () else error ""assertion failed""
  if candidate ""WWW"" == [""W"",""WW"",""WWW""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_15,mos_Latn,hs,"--A lebgda sõor sẽn tar zĩ-zãrg n sɩng ne 0 n ta n fãa.--  >>> stringSequence 0
--  ""0""
--  >>> stringSequence 5
--  ""0 1 2 3 4 5""
stringSequence :: Int -> String
stringSequence n =","stringSequence :: Int -> String
stringSequence n = unwords $ map show [0..n]","
main :: IO ()
main = do
  let candidate = stringSequence
  if candidate 0 == ""0"" then pure () else error ""assertion failed""
  if candidate 3 == ""0 1 2 3"" then pure () else error ""assertion failed""
  if candidate 10 == ""0 1 2 3 4 5 6 7 8 9 10"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_16,mos_Latn,hs,"--◯ Sõng-y n bãng-y sõor ning sẽn be sõng-kãng pʋgẽ wã sẽn yaa to-to wã.--  >>> countDistinctCharacters ""xyzXYZ""
--  3
--  >>> countDistinctCharacters ""Jerry""
--  4
countDistinctCharacters :: String -> Int
countDistinctCharacters string =","import Data.Char (toLower)
import Data.Set (fromList, size)

countDistinctCharacters :: String -> Int
countDistinctCharacters string = size . fromList $ map toLower string","
main :: IO ()
main = do
  let candidate = countDistinctCharacters
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abcde"" == 5 then pure () else error ""assertion failed""
  if candidate ""abcdecadeCADE"" == 5 then pure () else error ""assertion failed""
  if candidate ""aaaaAAAAaaaa"" == 1 then pure () else error ""assertion failed""
  if candidate ""Jerry jERRY JeRRRY"" == 5 then pure () else error ""assertion failed""
  pure ()"
HumanEval_17,mos_Latn,hs,"--'Hak' yaa yɩɩl sẽn tar koe-zug a naas sẽn kaoosd wakat a ye.--""O"" yaa ""o"" sẽn dat n yeel tɩ ""bũmb fãa"".--'o' - yɩɩll fãa, sẽn kaoosd wakat a naas --Ad kɩbar sẽn wilgd rẽ:--pa yaoolem ye.--Y tʋʋmda yaa y sẽn na n bãng n welg sõor kãnga n lebg n wa ne sõor sẽn zems ne sõor ning sẽn zems ne b sẽn na n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll tɩ yɩll n yɩll n yɩll n yɩll n yɩll tɩ yɩll n yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll tɩ yɩll n yɩll--◯ Fõn-kãng sẽn kẽed ne bũmb ningã yaa yɩɩl-yɩɩll sẽn yaa toore, sẽn yaa ASCII sẽn yaa toore.--  >>> parseMusic ""o o| .| o| o| .| .| .| .| o o""
--  [4,2,1,2,2,1,1,1,1,4,4]
parseMusic :: String -> [Int]
parseMusic music_string =","parseMusic :: String -> [Int]
parseMusic music_string = map beats (words music_string)
  where
    beats ""o"" = 4
    beats ""o|"" = 2
    beats "".|"" = 1
    beats _ = 0","
main :: IO ()
main = do
  let candidate = parseMusic
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""o o o o"" == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate "".| .| .| .|"" == [1,1,1,1] then pure () else error ""assertion failed""
  if candidate ""o| o| .| .| o o o o"" == [2,2,1,1,4,4,4,4] then pure () else error ""assertion failed""
  if candidate ""o| .| o| .| o o| o o|"" == [2,1,2,1,4,2,4,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_18,mos_Latn,hs,"--Bao-y n bãng-y naoor a wãn la y tõe n yã sõor sẽn yaa toore, la y sõd sẽn yaa toore.--  >>> howManyTimes """" ""a""
--  0
--  >>> howManyTimes ""aaa"" ""a""
--  3
--  >>> howManyTimes ""aaaa"" ""aa""
--  3
howManyTimes :: String -> String -> Int
howManyTimes string substring =","howManyTimes :: String -> String -> Int
howManyTimes string substring
  | null substring = 0
  | otherwise = length . filter isPrefixOfSubstring $ tails string
  where
    isPrefixOfSubstring = isPrefixOf substring
    isPrefixOf :: Eq a => [a] -> [a] -> Bool
    isPrefixOf prefix str = prefix `isPrefixOf` str","
main :: IO ()
main = do
  let candidate = howManyTimes
  if candidate """" ""x"" == 0 then pure () else error ""assertion failed""
  if candidate ""xyxyxyx"" ""x"" == 4 then pure () else error ""assertion failed""
  if candidate ""cacacacac"" ""cac"" == 4 then pure () else error ""assertion failed""
  if candidate ""john doe"" ""john"" == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_19,mos_Latn,hs,"--lebg n wa ne sõor sẽn tũ sor n sɩng ne yaoolem n tɩ ta yaoolem --B sẽn tõe n yãk n yãkã yaa 'fɩt', 'yẽng', 'a yiib', 'a tãab', 'a naas', 'a nu', 'a yoob', 'a yopoe', 'a nii' la 'a wɛ.' --ẽtɛrnetã yaa sõor sẽn sɩng ne 'fɩ' n tɩ ta 'kɩɩs' sẽn tar zĩ-zãrg n be.--  >>> sortNumbers ""three one five""
--  ""one three five""
sortNumbers :: String -> String
sortNumbers numbers =","import Data.List (sort)
import Data.Maybe (fromJust)
import Data.Map (Map, fromList, lookup)

sortNumbers :: String -> String
sortNumbers numbers = unwords $ map snd $ sort $ map (\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)
  where
    wordToNumber :: Map String Int
    wordToNumber = fromList [(""zero"", 0), (""one"", 1), (""two"", 2), (""three"", 3), (""four"", 4),
                             (""five"", 5), (""six"", 6), (""seven"", 7), (""eight"", 8), (""nine"", 9)]","
main :: IO ()
main = do
  let candidate = sortNumbers
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""three"" == ""three"" then pure () else error ""assertion failed""
  if candidate ""three five nine"" == ""three five nine"" then pure () else error ""assertion failed""
  if candidate ""five zero four seven nine eight"" == ""zero four five seven eight nine"" then pure () else error ""assertion failed""
  if candidate ""six five four three two one zero"" == ""zero one two three four five six"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_20,mos_Latn,hs,"--B sã n wa rat n bãng b sẽn na n maan to-to, b segd n lebg n wa ne b sẽn pʋɩt to-to wã (b sã n dat n bãng b sõor sẽn paood to-to, b segd n lebg n wa ne b sõor sẽn yɩɩd to-to).--◯ Sõdg sõor sẽn be wã pʋgẽ (sẽn zems a yiib n zãrge) n yãk la a lebg n wa ne a yiib sẽn pẽ ne a yembr fãa --  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]
--  (2.0, 2.2)
--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]
--  (2.0, 2.0)
findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers =","findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)
  where
    sortedNumbers = sort numbers
    minByDiff (a1, b1) (a2, b2)
      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)
      | otherwise = (a2, b2)","
main :: IO ()
main = do
  let candidate = findClosestElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_21,mos_Latn,hs,"--Sẽn na yɩl tɩ sõor ning sẽn yaa bilf n yɩɩdã lebg 0 la sẽn yaa kãseng n yɩɩdã lebg 1 --☐ B sã n kõ sõor sõor (sẽn ta a yiib), b rɩkda lineer tɩbsg n na n dɩk sõor kãng n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]
--  [0.0,0.25,0.5,0.75,1.0]
rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers =","rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers = map (\x -> (x - minVal) / range) numbers
  where
    minVal = minimum numbers
    maxVal = maximum numbers
    range = maxVal - minVal","
main :: IO ()
main = do
  let candidate = rescaleToUnit
  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error ""assertion failed""
  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error ""assertion failed""
  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  pure ()"
HumanEval_23,mos_Latn,hs,"--D lebg n wa ne sõor-kẽengã sẽn kõ wã woglem --  >>> strlen """"
--  0
--  >>> strlen ""abc""
--  3
strlen :: String -> Int
strlen string =","strlen :: String -> Int
strlen string = length string","
main :: IO ()
main = do
  let candidate = strlen
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""x"" == 1 then pure () else error ""assertion failed""
  if candidate ""asdasnakj"" == 9 then pure () else error ""assertion failed""
  pure ()"
HumanEval_24,mos_Latn,hs,"--Sẽn na n yɩlẽ n bãng sõor sẽn yaa kãseng n yɩɩd n n welg n n ye, n ya bilf n yɩɩd n.--  >>> largestDivisor 15
--  5
largestDivisor :: Int -> Int
largestDivisor n =","largestDivisor :: Int -> Int
largestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = largestDivisor
  if candidate 3 == 1 then pure () else error ""assertion failed""
  if candidate 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 == 5 then pure () else error ""assertion failed""
  if candidate 100 == 50 then pure () else error ""assertion failed""
  if candidate 49 == 7 then pure () else error ""assertion failed""
  pure ()"
HumanEval_25,mos_Latn,hs,"--Sõngd n bãngame tɩ f sã n na n gʋls sõor-kãng n paase, f segd n karma rẽ ne bũmb nins fãa sẽn naag n gʋlsã.--B segd n sõdga yel-bũndã naoor sẽn zems ne naoor ning a sẽn pukd yel-bũndã pʋgẽ wã.--A lebgda sõor sẽn na n yɩll n bãng pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi koees nins sẽn yaa pipi wã.--  >>> factorize 8
--  [2,2,2]
--  >>> factorize 25
--  [5,5]
--  >>> factorize 70
--  [2,5,7]
factorize :: Int -> [Int]
factorize n =","factorize :: Int -> [Int]
factorize n = factorize' n 2
  where
    factorize' 1 _ = []
    factorize' m f
      | m `mod` f == 0 = f : factorize' (m `div` f) f
      | otherwise      = factorize' m (f + 1)","
main :: IO ()
main = do
  let candidate = factorize
  if candidate 2 == [2] then pure () else error ""assertion failed""
  if candidate 4 == [2,2] then pure () else error ""assertion failed""
  if candidate 8 == [2,2,2] then pure () else error ""assertion failed""
  if candidate 57 == [3,19] then pure () else error ""assertion failed""
  if candidate 3249 == [3,3,19,19] then pure () else error ""assertion failed""
  if candidate 185193 == [3,3,3,19,19,19] then pure () else error ""assertion failed""
  if candidate 20577 == [3,19,19,19] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_26,mos_Latn,hs,"--B bas tɩ b sẽn gʋls bũmb ningã ket n yaa woto.--◯ Y sã n na n sõd sõor sẽn yaa zãng n yãk n yiis bũmb nins fãa sẽn be sõor kãng pʋgẽ n yɩɩd vugr bala.--  >>> removeDuplicates [1,2,3,2,4]
--  [1,3,4]
removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers =","removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers = filter (\x -> count x numbers == 1) numbers
  where
    count x = length . filter (== x)","
main :: IO ()
main = do
  let candidate = removeDuplicates
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error ""assertion failed""
  pure ()"
HumanEval_27,mos_Latn,hs,"--❑ Ne sõn-vãoog sẽn kõ, lebg-y lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg n lebg lɛtr-bõoneg ❑--  >>> flipCase ""Hello""
--  ""hELLO""
flipCase :: String -> String
flipCase string =","flipCase :: String -> String
flipCase = map flipChar
  where
    flipChar c
      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)
      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)
      | otherwise = c","
main :: IO ()
main = do
  let candidate = flipCase
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hello!"" == ""hELLO!"" then pure () else error ""assertion failed""
  if candidate ""These violent delights have violent ends"" == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_28,mos_Latn,hs,"--❑ Gʋls-y sõor sẽn yaa to-to wã n lebg sõor a ye.--  >>> concatenate []
--  """"
--  >>> concatenate [""a"",""b"",""c""]
--  ""abc""
concatenate :: [String] -> String
concatenate strings =","concatenate :: [String] -> String
concatenate strings = concat strings","
main :: IO ()
main = do
  let candidate = concatenate
  if candidate [] == """" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == ""xyz"" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z"",""w"",""k""] == ""xyzwk"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_29,mos_Latn,hs,"--◯ Filtreer-y sõor nins sẽn sɩng ne prefix sẽn kõ wã bal n kõ sõor nins sẽn be sõor-n-bayã pʋgẽ wã.--  >>> filterByPrefix [] ""a""
--  []
--  >>> filterByPrefix [""abc"",""bcd"",""cde"",""array""] ""a""
--  [""abc"",""array""]
filterByPrefix :: [String] -> String -> [String]
filterByPrefix strings prefix =","filterByPrefix strings prefix = filter (isPrefixOf prefix) strings
  where
    isPrefixOf pfx str = take (length pfx) str == pfx","
main :: IO ()
main = do
  let candidate = filterByPrefix
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_30,mos_Latn,hs,"--A lebgda sõor nins sẽn be sõor-rãmbã pʋgẽ wã bal sẽn yaa sõma wã.--  >>> getPositive [(-1),2,(-4),5,6]
--  [2,5,6]
--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  [5,3,2,3,9,123,1]
getPositive :: [Int] -> [Int]
getPositive l =","getPositive :: [Int] -> [Int]
getPositive l = filter (> 0) l","
main :: IO ()
main = do
  let candidate = getPositive
  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error ""assertion failed""
  if candidate [(-1),(-2)] == [] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_31,mos_Latn,hs,"--A sã n kõ sõor sẽn yaa pipi, a lebgda sɩda, sã n pa woto a lebgda ziri.--  >>> isPrime 6
--  False
--  >>> isPrime 101
--  True
--  >>> isPrime 11
--  True
--  >>> isPrime 13441
--  True
--  >>> isPrime 61
--  True
--  >>> isPrime 4
--  False
--  >>> isPrime 1
--  False
isPrime :: Int -> Bool
isPrime n =","isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = not (any (\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","
main :: IO ()
main = do
  let candidate = isPrime
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 101 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 13441 == True then pure () else error ""assertion failed""
  if candidate 61 == True then pure () else error ""assertion failed""
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 1 == False then pure () else error ""assertion failed""
  if candidate 5 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 17 == True then pure () else error ""assertion failed""
  if candidate 85 == False then pure () else error ""assertion failed""
  if candidate 77 == False then pure () else error ""assertion failed""
  if candidate 255379 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_33,mos_Latn,hs,"--B sẽn maan to-to n na n bãng n yãk b sẽn na n maan to-to n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam--l' yaa a yembr ne l sẽn kẽed ne vɛrse nins sẽn pa tõe n pʋɩ ne tãabã wɛɛngẽ, tɩ b vɛrse nins sẽn tõe n pʋɩ ne tãabã wɛɛngẽ wã yaa a yembr --Fõn-kãng rɩkda sõor sẽn yaa l n lebg n wa ne sõor sẽn yaa l sẽn yaa woto --  >>> sortThird [1,2,3]
--  [1,2,3]
--  >>> sortThird [5,6,3,4,8,9,2]
--  [2,6,3,4,8,9,5]
sortThird :: [Int] -> [Int]
sortThird l =","sortThird :: [Int] -> [Int]
sortThird l = map selectElem indexed
  where
    indexed = zip [0..] l
    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]
    sortedThirdElems = sortedElems thirdIndicesElems
    sortedElems = id -- or List.sort if imported
    selectElem (i, x)
      | i `mod` 3 == 0 = head sortedThirdElems
      | otherwise = x
    replaceSortedElem xs sorted = map selectElem indexed
      where
        replaceElem i (x:xs)
          | i == 0 = x:xs
          | otherwise = replaceElem (i - 1) xs
        selectElem (i, x)
          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)
          | otherwise = x","
main :: IO ()
main = do
  let candidate = sortThird
  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error ""assertion failed""
  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error ""assertion failed""
  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error ""assertion failed""
  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_34,mos_Latn,hs,"--☐ A sẽn na n wa ne bũmb ning sẽn na n wa ne bũmb ning sẽn na n wa ne bũmb ning sẽn na n wa ne bũmb ning sẽn na n wa ne bũmb ning--  >>> unique [5,3,5,2,3,3,9,0,123]
--  [0,2,3,5,9,123]
unique :: [Int] -> [Int]
unique l =","unique :: [Int] -> [Int]
unique l = sort $ nub l
  where
    -- | Remove duplicate elements from a list.
    nub :: (Eq a) => [a] -> [a]
    nub [] = []
    nub (x:xs) = x : nub (filter (/= x) xs)

    -- | Sort a list of elements (using QuickSort algorithm).
    sort :: (Ord a) => [a] -> [a]
    sort [] = []
    sort (x:xs) =
      let smallerSorted = sort [a | a <- xs, a <= x]
          biggerSorted = sort [a | a <- xs, a > x]
      in  smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = unique
  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error ""assertion failed""
  pure ()"
HumanEval_35,mos_Latn,hs,"--A lebgda bũmb ning sẽn yaa kãseng n yɩɩdã sõor pʋgẽ.--  >>> maxElement [1,2,3]
--  3
--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  123
maxElement :: [Int] -> Int
maxElement l =","maxElement :: [Int] -> Int
maxElement [] = error ""List cannot be empty""
maxElement (x:xs) = maxElementHelper xs x
  where
    maxElementHelper [] currentMax = currentMax
    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","
main :: IO ()
main = do
  let candidate = maxElement
  if candidate [1,2,3] == 3 then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error ""assertion failed""
  pure ()"
HumanEval_36,mos_Latn,hs,"--Rɩkd sõor ning sẽn zems naoor ning sõor 7 sẽn pukd n sẽn pa ta n sẽn tõe n pʋɩ ne 11 bɩ 13 wã.--  >>> fizzBuzz 50
--  0
--  >>> fizzBuzz 78
--  2
--  >>> fizzBuzz 79
--  3
fizzBuzz :: Int -> Int
fizzBuzz n =","fizzBuzz :: Int -> Int
fizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","
main :: IO ()
main = do
  let candidate = fizzBuzz
  if candidate 50 == 0 then pure () else error ""assertion failed""
  if candidate 78 == 2 then pure () else error ""assertion failed""
  if candidate 79 == 3 then pure () else error ""assertion failed""
  if candidate 100 == 3 then pure () else error ""assertion failed""
  if candidate 200 == 6 then pure () else error ""assertion failed""
  if candidate 4000 == 192 then pure () else error ""assertion failed""
  if candidate 10000 == 639 then pure () else error ""assertion failed""
  if candidate 100000 == 8026 then pure () else error ""assertion failed""
  pure ()"
HumanEval_37,mos_Latn,hs,"--Yaa sẽn na yɩl n bãng n bãng n paas n paasã.--l' yaa a yembr ne l sẽn be ne sẽn pa yɩ-b toor-toorã, tɩ b sẽn be ne sẽn yaa-b toor-toorã yaa a yembr --Fõn-kãng rɩkda sõor sẽn yaa l n lebg n wa ne sõor sẽn yaa l sẽn yaa woto --  >>> sortEven [1,2,3]
--  [1,2,3]
--  >>> sortEven [5,6,3,4]
--  [3,6,5,4]
sortEven :: [Int] -> [Int]
sortEven l =","sortEven :: [Int] -> [Int]
sortEven l = merge odds sortedEvens
  where
    (odds, evens) = partitionList l
    sortedEvens = sort evens

    partitionList :: [Int] -> ([Int], [Int])
    partitionList [] = ([], [])
    partitionList [x] = ([x], [])
    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)
      where
        (xsOdds, xsEvens) = partitionList xs

    merge :: [Int] -> [Int] -> [Int]
    merge [] ys = ys
    merge (x:xs) [] = x:xs
    merge (x:xs) (y:ys) = x:y:merge xs ys","
main :: IO ()
main = do
  let candidate = sortEven
  if candidate [1,2,3] == [1,2,3] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error ""assertion failed""
  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_39,mos_Latn,hs,"--prime_fib lebgda sõor n-ẽeg sẽn yaa Fibonacci sõor la sẽn yaa sõor sẽn yaa pipi.--  >>> primeFib 1
--  2
--  >>> primeFib 2
--  3
--  >>> primeFib 3
--  5
--  >>> primeFib 4
--  13
--  >>> primeFib 5
--  89
primeFib :: Int -> Int
primeFib n =","primeFib :: Int -> Int
primeFib n = primeFibs !! (n - 1)
  where
    primeFibs = filter isPrime fibs
    fibs = map fst $ iterate (\(a, b) -> (b, a + b)) (0, 1)

isPrime :: Int -> Bool
isPrime k
  | k < 2 = False
  | k == 2 = True
  | even k = False
  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]
  where
    upperLimit = floor . sqrt $ fromIntegral k","
main :: IO ()
main = do
  let candidate = primeFib
  if candidate 1 == 2 then pure () else error ""assertion failed""
  if candidate 2 == 3 then pure () else error ""assertion failed""
  if candidate 3 == 5 then pure () else error ""assertion failed""
  if candidate 4 == 13 then pure () else error ""assertion failed""
  if candidate 5 == 89 then pure () else error ""assertion failed""
  if candidate 6 == 233 then pure () else error ""assertion failed""
  if candidate 7 == 1597 then pure () else error ""assertion failed""
  if candidate 8 == 28657 then pure () else error ""assertion failed""
  if candidate 9 == 514229 then pure () else error ""assertion failed""
  if candidate 10 == 433494437 then pure () else error ""assertion failed""
  pure ()"
HumanEval_40,mos_Latn,hs,"--Sã n pa woto, yaa ziri.--a sã n be bũmb a tãab sẽn yaa toor-toore, n yaa --ã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã aã--  >>> triplesSumToZero [1,3,5,0]
--  False
--  >>> triplesSumToZero [1,3,(-2),1]
--  True
--  >>> triplesSumToZero [1,2,3,7]
--  False
--  >>> triplesSumToZero [2,4,(-5),3,9,7]
--  True
--  >>> triplesSumToZero [1]
--  False
triplesSumToZero :: [Int] -> Bool
triplesSumToZero l =","triplesSumToZero :: [Int] -> Bool
triplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]
  where
    tails [] = []
    tails xs@(_:xs') = xs : tails xs'","
main :: IO ()
main = do
  let candidate = triplesSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-1)] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [1,2,5,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,9,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-100)] == False then pure () else error ""assertion failed""
  if candidate [100,3,5,(-100)] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_41,mos_Latn,hs,"--Tʋʋm kãnga wilgda b sẽn maan b sẽn dat n maan bũmb ningã.--B sẽn da wa n kẽnd to-to wã, wa b pa tol n wa wẽ taab ye.--La b sẽn da tõe n maan bũmb ninsã ra pa tõe n sãam b sũur ye.--Soab sẽn kẽnd n ya goabg n kẽng rɩtg sã n wa wẽed soab sẽn kẽnd n ya rɩtg n kẽng goabga.--B yetame tɩ mobill a yiib n wa n lʋɩ taaba.--Soabd a yiib n sɩng n be yɩɩg ne --n mobillã kẽndame n ya goabg n kẽng rɩtgo; wakat yɛng pʋgẽ, mobill n to n be be.--Tags-y n ges-y sor sẽn yaa tɩrga, n tar woglem sẽn pa tõe n bãng n bilg ye.carRaceCollision :: Int -> Int
carRaceCollision n =","carRaceCollision :: Int -> Int
carRaceCollision n = n","
main :: IO ()
main = do
  let candidate = carRaceCollision
  if candidate 2 == 4 then pure () else error ""assertion failed""
  if candidate 3 == 9 then pure () else error ""assertion failed""
  if candidate 4 == 16 then pure () else error ""assertion failed""
  if candidate 8 == 64 then pure () else error ""assertion failed""
  if candidate 10 == 100 then pure () else error ""assertion failed""
  pure ()"
HumanEval_42,mos_Latn,hs,"--A lebg n wa ne sõor sẽn paasd a 1 n kõ-a.--  >>> incrList [1,2,3]
--  [2,3,4]
--  >>> incrList [5,3,5,2,3,3,9,0,123]
--  [6,4,6,3,4,4,10,1,124]
incrList :: [Int] -> [Int]
incrList l =","incrList :: [Int] -> [Int]
incrList l = map (+1) l","
main :: IO ()
main = do
  let candidate = incrList
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [4,3,2] then pure () else error ""assertion failed""
  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error ""assertion failed""
  pure ()"
HumanEval_43,mos_Latn,hs,"--Sã n pa woto, yaa ziri.--a sã n be bũmb a yiib sẽn yaa toor-toore, n yaa --Pairs_sum_to_zero rɩkda nimero rãmb sõor sẽn yaa sõma n lebg a sẽn datã.--  >>> pairsSumToZero [1,3,5,0]
--  False
--  >>> pairsSumToZero [1,3,(-2),1]
--  False
--  >>> pairsSumToZero [1,2,3,7]
--  False
--  >>> pairsSumToZero [2,4,(-5),3,5,7]
--  True
--  >>> pairsSumToZero [1]
--  False
pairsSumToZero :: [Int] -> Bool
pairsSumToZero l =","pairsSumToZero :: [Int] -> Bool
pairsSumToZero l = any (\x -> -x `elem` l) l && (length l > 1)","
main :: IO ()
main = do
  let candidate = pairsSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,5,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_44,mos_Latn,hs,"--Bãngr-gomdã sõor pa ta 10 ye.--lebg n wa ne sõor sẽn yaa toore, n lebg n wa ne sõor sẽn yaa toore. --☐ Y sã n dat n bãng y sẽn tõe n maan to-to n paam n lebg n wa, bɩ y ges video wã sẽn be tẽngrã.--  >>> changeBase 8 3
--  ""22""
--  >>> changeBase 8 2
--  ""1000""
--  >>> changeBase 7 2
--  ""111""
changeBase :: Int -> Int -> String
changeBase x base =","changeBase :: Int -> Int -> String
changeBase x base
  | x < base  = show x
  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","
main :: IO ()
main = do
  let candidate = changeBase
  if candidate 8 3 == ""22"" then pure () else error ""assertion failed""
  if candidate 9 3 == ""100"" then pure () else error ""assertion failed""
  if candidate 234 2 == ""11101010"" then pure () else error ""assertion failed""
  if candidate 16 2 == ""10000"" then pure () else error ""assertion failed""
  if candidate 8 2 == ""1000"" then pure () else error ""assertion failed""
  if candidate 7 2 == ""111"" then pure () else error ""assertion failed""
  if candidate 2 3 == ""2"" then pure () else error ""assertion failed""
  if candidate 3 4 == ""3"" then pure () else error ""assertion failed""
  if candidate 4 5 == ""4"" then pure () else error ""assertion failed""
  if candidate 5 6 == ""5"" then pure () else error ""assertion failed""
  if candidate 6 7 == ""6"" then pure () else error ""assertion failed""
  if candidate 7 8 == ""7"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_45,mos_Latn,hs,"--A triangle's longitude and high return area for a triangle. A triangle's longitude and high return area for a triangle. A triangle's longitude and high return area for a triangle.--  >>> triangleArea 5 3
--  7.5
triangleArea :: Int -> Int -> Float
triangleArea a h =","triangleArea :: Int -> Int -> Float
triangleArea a h = 0.5 * fromIntegral a * fromIntegral h","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 5 3 == 7.5 then pure () else error ""assertion failed""
  if candidate 2 2 == 2.0 then pure () else error ""assertion failed""
  if candidate 10 8 == 40.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_46,mos_Latn,hs,"--Gʋls-y n gʋls-y tʋʋm-noor sẽn na n sõng tɩ b bãng fib4 sõor pʋɩ-sʋkã n-n-soab sẽn yaa a soaba.--Fib 4 (n) -> Fib 4 (n-1) + Fib 4 (n-2) + Fib 4 (n-3) + Fib 4 (n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --Fib4 sõor pʋga yaa pʋga sẽn wõnd Fibbonacci pʋga sẽn yaa wa sẽn pʋgdã:--  >>> fib4 5
--  4
--  >>> fib4 6
--  8
--  >>> fib4 7
--  14
fib4 :: Int -> Int
fib4 n =","fib4 :: Int -> Int
fib4 n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 2
  | n == 3 = 0
  | otherwise = iter 0 0 2 0 n
  where
    iter a b c d 4 = a + b + c + d
    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","
main :: IO ()
main = do
  let candidate = fib4
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 28 then pure () else error ""assertion failed""
  if candidate 10 == 104 then pure () else error ""assertion failed""
  if candidate 12 == 386 then pure () else error ""assertion failed""
  pure ()"
HumanEval_47,mos_Latn,hs,"--☐ A A A--  >>> median [3,1,2,4,5]
--  3.0
--  >>> median [(-10),4,6,1000,10,20]
--  15.0
median :: [Int] -> Float
median l =","median :: [Int] -> Float
median l 
  | odd n     = fromIntegral $ sorted !! mid
  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) / 2
  where
    sorted = sort l
    n = length l
    mid = n `div` 2
    sort = sortBy compare","
main :: IO ()
main = do
  let candidate = median
  if candidate [3,1,2,4,5] == 3.0 then pure () else error ""assertion failed""
  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error ""assertion failed""
  if candidate [5] == 5.0 then pure () else error ""assertion failed""
  if candidate [6,5] == 5.5 then pure () else error ""assertion failed""
  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_48,mos_Latn,hs,"--A gesda sã n yaa tɩlɛ tɩ b kõ kõ-a sõor sẽn yaa wa palindrõme.--  >>> isPalindrome """"
--  True
--  >>> isPalindrome ""aba""
--  True
--  >>> isPalindrome ""aaaaa""
--  True
--  >>> isPalindrome ""zbcd""
--  False
isPalindrome :: String -> Bool
isPalindrome text =","isPalindrome :: String -> Bool
isPalindrome text = text == reverse text","
main :: IO ()
main = do
  let candidate = isPalindrome
  if candidate """" == True then pure () else error ""assertion failed""
  if candidate ""aba"" == True then pure () else error ""assertion failed""
  if candidate ""aaaaa"" == True then pure () else error ""assertion failed""
  if candidate ""zbcd"" == False then pure () else error ""assertion failed""
  if candidate ""xywyx"" == True then pure () else error ""assertion failed""
  if candidate ""xywyz"" == False then pure () else error ""assertion failed""
  if candidate ""xywzx"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_49,mos_Latn,hs,"--D lebg n wa ne 2^n modulo p (yẽes sõorã).--  >>> modp 3 5
--  3
--  >>> modp 1101 101
--  2
--  >>> modp 0 101
--  1
--  >>> modp 3 11
--  8
--  >>> modp 100 101
--  1
modp :: Int -> Int -> Int
modp n p =","modp :: Int -> Int -> Int
modp n p = powMod 2 n p

powMod :: Int -> Int -> Int -> Int
powMod base exp modulus
  | modulus == 1 = 0
  | exp == 0     = 1
  | exp == 1     = base `mod` modulus
  | otherwise    = if odd exp
                   then (base * halfExp * halfExp) `mod` modulus
                   else (halfExp * halfExp) `mod` modulus
  where
    halfExp = powMod base (exp `div` 2) modulus","
main :: IO ()
main = do
  let candidate = modp
  if candidate 3 5 == 3 then pure () else error ""assertion failed""
  if candidate 1101 101 == 2 then pure () else error ""assertion failed""
  if candidate 0 101 == 1 then pure () else error ""assertion failed""
  if candidate 3 11 == 8 then pure () else error ""assertion failed""
  if candidate 100 101 == 1 then pure () else error ""assertion failed""
  if candidate 30 5 == 4 then pure () else error ""assertion failed""
  if candidate 31 5 == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_51,mos_Latn,hs,"--remove_vowels yaa tʋʋm-noor sẽn dɩkd sõn-vɩɩs n lebgd n lebd ne sõn-vɩɩs sẽn pa be.--  >>> removeVowels """"
--  """"
--  >>> removeVowels ""abcdef""
--  ""bcdf""
--  >>> removeVowels ""aaaaa""
--  """"
--  >>> removeVowels ""aaBAA""
--  ""B""
--  >>> removeVowels ""zbcd""
--  ""zbcd""
removeVowels :: String -> String
removeVowels text =","removeVowels :: String -> String
removeVowels text = filter (`notElem` ""aeiouAEIOU"") text","
main :: IO ()
main = do
  let candidate = removeVowels
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""abcdef
ghijklm"" == ""bcdf
ghjklm"" then pure () else error ""assertion failed""
  if candidate ""fedcba"" == ""fdcb"" then pure () else error ""assertion failed""
  if candidate ""eeeee"" == """" then pure () else error ""assertion failed""
  if candidate ""acBAA"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""EcBOO"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""ybcd"" == ""ybcd"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_52,mos_Latn,hs,"-- sã n yaa tɩ sõor fãa sẽn be l-ẽ wã pa ta t- ye. --  >>> belowThreshold [1,2,4,10] 100
--  True
--  >>> belowThreshold [1,20,4,10] 5
--  False
belowThreshold :: [Int] -> Int -> Bool
belowThreshold l t =",belowThreshold l t = all (< t) l,"
main :: IO ()
main = do
  let candidate = belowThreshold
  if candidate [1,2,4,10] 100 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 5 == False then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 21 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 22 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 11 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_53,mos_Latn,hs,"--Add a 2 numbers x and y.--  >>> add 2 3
--  5
--  >>> add 5 7
--  12
add :: Int -> Int -> Int
add x y =","add :: Int -> Int -> Int
add x y = x + y","
main :: IO ()
main = do
  let candidate = add
  if candidate 0 1 == 1 then pure () else error ""assertion failed""
  if candidate 1 0 == 1 then pure () else error ""assertion failed""
  if candidate 2 3 == 5 then pure () else error ""assertion failed""
  if candidate 5 7 == 12 then pure () else error ""assertion failed""
  if candidate 7 5 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_54,mos_Latn,hs,"--◯ Ges-y gom-biis a yiib sã n tara yʋy sẽn yaa a yembre.--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc""
--  True
--  >>> sameChars ""abcd"" ""dddddddabc""
--  True
--  >>> sameChars ""dddddddabc"" ""abcd""
--  True
--  >>> sameChars ""eabcd"" ""dddddddabc""
--  False
--  >>> sameChars ""abcd"" ""dddddddabce""
--  False
--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc""
--  False
sameChars :: String -> String -> Bool
sameChars s0 s1 =","import Data.List (nub, sort)

sameChars :: String -> String -> Bool
sameChars s0 s1 = sort (nub s0) == sort (nub s1)","
main :: IO ()
main = do
  let candidate = sameChars
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddeddabc"" == True then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabc"" == True then pure () else error ""assertion failed""
  if candidate ""dddddddabc"" ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""eabcd"" ""dddddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabcf"" == False then pure () else error ""assertion failed""
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""aabb"" ""aaccc"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_55,mos_Latn,hs,"--Retournez n-ème Fibonacci à la n--  >>> fib 10
--  55
--  >>> fib 1
--  1
--  >>> fib 8
--  21
fib :: Int -> Int
fib n =","fib :: Int -> Int
fib n = fibHelper 0 1 n
  where
    fibHelper a _ 0 = a
    fibHelper a b n = fibHelper b (a + b) (n - 1)","
main :: IO ()
main = do
  let candidate = fib
  if candidate 10 == 55 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 8 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 89 then pure () else error ""assertion failed""
  if candidate 12 == 144 then pure () else error ""assertion failed""
  pure ()"
HumanEval_56,mos_Latn,hs,"--Return True sã n yaa tɩ yalgr fãa tara yalgr sẽn zems ne a sẽn na n baasã. --""<"" la "">"" la b sẽn gʋls n be gãn-vãoogã pʋgẽ.--  >>> correctBracketing ""<""
--  False
--  >>> correctBracketing ""<>""
--  True
--  >>> correctBracketing ""<<><>>""
--  True
--  >>> correctBracketing ""><<>""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBrackets brackets 0 == 0

checkBrackets :: String -> Int -> Int
checkBrackets [] n = n
checkBrackets (x:xs) n
  | n < 0 = -1
  | x == '<' = checkBrackets xs (n + 1)
  | x == '>' = checkBrackets xs (n - 1)
  | otherwise = checkBrackets xs n","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""<>"" == True then pure () else error ""assertion failed""
  if candidate ""<<><>>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<<><><>><>><<><><<>>>"" == True then pure () else error ""assertion failed""
  if candidate ""<<<><>>>>"" == False then pure () else error ""assertion failed""
  if candidate ""><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<"" == False then pure () else error ""assertion failed""
  if candidate ""<<<<"" == False then pure () else error ""assertion failed""
  if candidate "">"" == False then pure () else error ""assertion failed""
  if candidate ""<<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>>><>"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_57,mos_Latn,hs,"--Return True yaa sõor sẽn paasd bɩ sẽn boogd wakat fãa.--  >>> monotonic [1,2,4,20]
--  True
--  >>> monotonic [1,20,4,10]
--  False
--  >>> monotonic [4,1,0,(-10)]
--  True
monotonic :: [Int] -> Bool
monotonic l =","monotonic :: [Int] -> Bool
monotonic l = increasing l || decreasing l
  where
    increasing xs = all (uncurry (<=)) (zip xs (tail xs))
    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","
main :: IO ()
main = do
  let candidate = monotonic
  if candidate [1,2,4,10] == True then pure () else error ""assertion failed""
  if candidate [1,2,4,20] == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] == False then pure () else error ""assertion failed""
  if candidate [4,1,0,(-10)] == True then pure () else error ""assertion failed""
  if candidate [4,1,1,0] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,2,5,60] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,60] == True then pure () else error ""assertion failed""
  if candidate [9,9,9,9] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_58,mos_Latn,hs,"--A lebg n wa ne bũmb sẽn yaa toor ne taab n be sõor a yiib pʋgẽ.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]
--  [1,5,653]
--  >>> common [5,3,2,8] [3,2]
--  [2,3]
common :: [Int] -> [Int] -> [Int]
common l1 l2 =","common :: [Int] -> [Int] -> [Int]
common l1 l2 = uniqueSortedCommon
  where
    commonElements = filter (`elem` l2) l1
    uniqueCommon = removeDuplicates commonElements
    uniqueSortedCommon = sort uniqueCommon

    removeDuplicates :: [Int] -> [Int]
    removeDuplicates = foldr (\x seen -> if x `elem` seen then seen else x : seen) []

    sort :: [Int] -> [Int]
    sort [] = []
    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)
      where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs","
main :: IO ()
main = do
  let candidate = common
  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error ""assertion failed""
  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_59,mos_Latn,hs,"--D lebg n wa ne n-yẽgd ning sẽn yaa kãseng n yɩɩdã. D ges n > 1 t'a pa pipi.--  >>> largestPrimeFactor 13195
--  29
--  >>> largestPrimeFactor 2048
--  2
largestPrimeFactor :: Int -> Int
largestPrimeFactor n =","largestPrimeFactor :: Int -> Int
largestPrimeFactor n = helper n 2
  where
    helper n factor
      | factor * factor > n = n
      | n `mod` factor == 0 = helper (n `div` factor) factor
      | otherwise = helper n (factor + 1)","
main :: IO ()
main = do
  let candidate = largestPrimeFactor
  if candidate 15 == 5 then pure () else error ""assertion failed""
  if candidate 27 == 3 then pure () else error ""assertion failed""
  if candidate 63 == 7 then pure () else error ""assertion failed""
  if candidate 330 == 11 then pure () else error ""assertion failed""
  if candidate 13195 == 29 then pure () else error ""assertion failed""
  pure ()"
HumanEval_60,mos_Latn,hs,"--Sum_to_n yaa tʋʋm-noor sẽn na n sõd sõor sẽn yi 1 n ta n.--  >>> sumToN 30
--  465
--  >>> sumToN 100
--  5050
--  >>> sumToN 5
--  15
--  >>> sumToN 10
--  55
--  >>> sumToN 1
--  1
sumToN :: Int -> Int
sumToN n =","sumToN :: Int -> Int
sumToN n = sum [1..n]","
main :: IO ()
main = do
  let candidate = sumToN
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 66 then pure () else error ""assertion failed""
  if candidate 30 == 465 then pure () else error ""assertion failed""
  if candidate 100 == 5050 then pure () else error ""assertion failed""
  pure ()"
HumanEval_61,mos_Latn,hs,"--Return True sã n yaa tɩ yalgr fãa tara yalgr sẽn zems ne a sẽn na n baasã. --"" (c) "" yaa "" (d) "" la "" (d) "" sõor sẽn yaa toore.--  >>> correctBracketing ""(""
--  False
--  >>> correctBracketing ""()""
--  True
--  >>> correctBracketing ""(()())""
--  True
--  >>> correctBracketing "")(()""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBalance brackets 0
  where
    checkBalance [] 0 = True
    checkBalance [] _ = False
    checkBalance (x:xs) n
      | x == '('  = checkBalance xs (n + 1)
      | x == ')' && n > 0 = checkBalance xs (n - 1)
      | otherwise = False","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""()"" == True then pure () else error ""assertion failed""
  if candidate ""(()())"" == True then pure () else error ""assertion failed""
  if candidate ""()()(()())()"" == True then pure () else error ""assertion failed""
  if candidate ""()()((()()())())(()()(()))"" == True then pure () else error ""assertion failed""
  if candidate ""((()())))"" == False then pure () else error ""assertion failed""
  if candidate "")(()"" == False then pure () else error ""assertion failed""
  if candidate ""("" == False then pure () else error ""assertion failed""
  if candidate ""(((("" == False then pure () else error ""assertion failed""
  if candidate "")"" == False then pure () else error ""assertion failed""
  if candidate ""(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())())(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())()))()"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_62,mos_Latn,hs,"--D lebg n wa ne polynôme kãnga sẽn yit zĩig a ye wã.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --Xs makda polynom koeefɩtensa.--  >>> derivative [3,1,2,4,5]
--  [1,4,12,20]
--  >>> derivative [1,2,3]
--  [2,6]
derivative :: [Int] -> [Int]
derivative xs =","derivative :: [Int] -> [Int]
derivative xs = zipWith (*) (tail xs) [1..]","
main :: IO ()
main = do
  let candidate = derivative
  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,6] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [2,2] then pure () else error ""assertion failed""
  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error ""assertion failed""
  if candidate [1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_63,mos_Latn,hs,"--Yãk-y n tool-y-yã sẽn na yɩl n bãng n-rɩtg ning sẽn be nimero rãmb nins sẽn yaa to-to wã pʋgẽ wã.--fibrÃ£n (n) == fibrÃ£n (n-1) + fibrÃ£n (n-2) + fibrÃ£n (n-3). --fib fib ((2) == 1 --fibfib ((1) == 0 --fib fib ((0) == 0 --FibFib sõor pʋga yaa pʋga sẽn wõnd Fibbonacci pʋga sẽn yaa wa sẽn pʋgdã:--  >>> fibfib 1
--  0
--  >>> fibfib 5
--  4
--  >>> fibfib 8
--  24
fibfib :: Int -> Int
fibfib n =","fibfib :: Int -> Int
fibfib n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 1
  | otherwise = fibs !! n
  where
    fibs = 0 : 0 : 1 : zipWith3 (\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","
main :: IO ()
main = do
  let candidate = fibfib
  if candidate 2 == 1 then pure () else error ""assertion failed""
  if candidate 1 == 0 then pure () else error ""assertion failed""
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 24 then pure () else error ""assertion failed""
  if candidate 10 == 81 then pure () else error ""assertion failed""
  if candidate 12 == 274 then pure () else error ""assertion failed""
  if candidate 14 == 927 then pure () else error ""assertion failed""
  pure ()"
HumanEval_64,mos_Latn,hs,"--Makre: --B sã n gʋlsd gom-bilã n na n wilg tɩ gom-bilã tara vɛrse, b tõe n gʋls-a lame n lebg tɩ vɛrse.--B sẽn boond tɩ vokaalã yaa a, e, i, o, u.--A sã n wa lebg n wa, a na n lebg n wa ne vokaal-rãmb sõor sẽn be sõor-gãndã pʋgẽ.--Gʋls-y tʋʋm-noor ning sẽn boond tɩ vowels_count sẽn dɩkd n makd --  >>> vowelsCount ""abcde""
--  2
--  >>> vowelsCount ""ACEDY""
--  3
vowelsCount :: String -> Int
vowelsCount s =","vowelsCount :: String -> Int
vowelsCount s = length $ filter isVowel $ zip s [1..]
  where
    isVowel (c, pos) =
      let lowercaseC = toLower c
          isRegularVowel = lowercaseC `elem` ""aeiou""
          isLastCharY = lowercaseC == 'y' && pos == length s
      in isRegularVowel || isLastCharY","
main :: IO ()
main = do
  let candidate = vowelsCount
  if candidate ""abcde"" == 2 then pure () else error ""assertion failed""
  if candidate ""Alone"" == 3 then pure () else error ""assertion failed""
  if candidate ""key"" == 2 then pure () else error ""assertion failed""
  if candidate ""bye"" == 1 then pure () else error ""assertion failed""
  if candidate ""keY"" == 2 then pure () else error ""assertion failed""
  if candidate ""bYe"" == 1 then pure () else error ""assertion failed""
  if candidate ""ACEDY"" == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_65,mos_Latn,hs,"--Sã n yaa shift > sõor sẽn yaa sõor bala, lebg n wa ne sõor sẽn yaa sõor bala.--la a lebg n wa ne a sẽn wat ne wã wa sõor sẽn yaa sõor-yoodre. --❑ Gʋls-y x sẽn yaa sõor sẽn yaa zãngã n gilg n ges-a, la y gilg n ges-a n kẽng rɩtgo.--  >>> circularShift 12 1
--  ""21""
--  >>> circularShift 12 2
--  ""12""
circularShift :: Int -> Int -> String
circularShift x shift =","circularShift :: Int -> Int -> String
circularShift x shift =
  let digits = show x
      len = length digits
      effectiveShift = shift `mod` len
  in if shift > len
     then reverse digits
     else let (begin, end) = splitAt (len - effectiveShift) digits
          in end ++ begin","
main :: IO ()
main = do
  let candidate = circularShift
  if candidate 100 2 == ""001"" then pure () else error ""assertion failed""
  if candidate 12 2 == ""12"" then pure () else error ""assertion failed""
  if candidate 97 8 == ""79"" then pure () else error ""assertion failed""
  if candidate 12 1 == ""21"" then pure () else error ""assertion failed""
  if candidate 11 101 == ""11"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_66,mos_Latn,hs,"--Makre: --ASCII kood dãmba. --Gʋls-y tʋʋm-noor sẽn na n dɩk sõor sẽn yaa wa kõom n lebg ne sõor sẽn yaa pipi sõorã balã.'--Tʋʋmd sẽn yaa tɩlae.--  >>> digitsum """"
--  0
--  >>> digitsum ""abAB""
--  131
--  >>> digitsum ""abcCd""
--  67
--  >>> digitsum ""helloE""
--  69
--  >>> digitsum ""woArBld""
--  131
--  >>> digitsum ""aAaaaXa""
--  153
digitsum :: String -> Int
digitsum s =","digitsum :: String -> Int
digitsum s = sum $ map fromEnum $ filter isUpper s","
main :: IO ()
main = do
  let candidate = digitsum
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abAB"" == 131 then pure () else error ""assertion failed""
  if candidate ""abcCd"" == 67 then pure () else error ""assertion failed""
  if candidate ""helloE"" == 69 then pure () else error ""assertion failed""
  if candidate ""woArBld"" == 131 then pure () else error ""assertion failed""
  if candidate ""aAaaaXa"" == 153 then pure () else error ""assertion failed""
  if candidate "" How are yOu?"" == 151 then pure () else error ""assertion failed""
  if candidate ""You arE Very Smart"" == 327 then pure () else error ""assertion failed""
  pure ()"
HumanEval_67,mos_Latn,hs,"--n na n yɩ a soabã: --Sebrã pʋgẽ, wilg-y mangã biis sõor sẽn be sebrã pʋgẽ. --yaa pom-pemb la a ka-bõoneg la sõor sẽn yaa zãng sẽn makd biisã fãa sõore --D sã n ges sõor ning sẽn makd  wã fãa sẽn yaa a wãnã, d na n yeelame tɩ  yaa a wãnã.--B sẽn pʋɩt-b tɩɩsã biis koglg pʋgẽ wã yaa woto:--◯ Tʋʋm kãnga pʋgẽ, b na n kõ-y-la sõor sẽn makd kʋɩl-zẽed la kʋɩl-bõoneg sõore.--  >>> fruitDistribution ""5 apples and 6 oranges"" 19
--  8
--  >>> fruitDistribution ""0 apples and 1 oranges"" 3
--  2
--  >>> fruitDistribution ""2 apples and 3 oranges"" 100
--  95
--  >>> fruitDistribution ""100 apples and 1 oranges"" 120
--  19
fruitDistribution :: String -> Int -> Int
fruitDistribution s n =","import Text.Read (readMaybe)

fruitDistribution :: String -> Int -> Int
fruitDistribution s n = n - totalApplesOranges
  where
    totalApplesOranges = sum $ map (readNumber . words) [""apples"", ""oranges""]
    readNumber keyword = case dropWhile (not . (=="" "") . dropWhile (/=' ')) $ words s of
      [] -> 0
      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","
main :: IO ()
main = do
  let candidate = fruitDistribution
  if candidate ""5 apples and 6 oranges"" 19 == 8 then pure () else error ""assertion failed""
  if candidate ""5 apples and 6 oranges"" 21 == 10 then pure () else error ""assertion failed""
  if candidate ""0 apples and 1 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""1 apples and 0 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 100 == 95 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 5 == 0 then pure () else error ""assertion failed""
  if candidate ""1 apples and 100 oranges"" 120 == 19 then pure () else error ""assertion failed""
  pure ()"
HumanEval_68,mos_Latn,hs,"--Makr a 1: --Sã n pa be vɛrse-rãmb sẽn yaa pa-kẽema, bɩ sõor ning b sẽn kõ wã sã n yaa zaalem, lebg n wa [].--B segd n lebg n waa ne nod ning b sẽn yãkã ne sõor sẽn yaa [ smalest_value, a indeksã ], --Sã n mikame tɩ nod-dãmb wʋsg sẽn tar yaoolem n-yẽgd sẽn yaa bilf n yɩɩd fãa wã, lebg n wa ne nod-dãmb nins sẽn tar yaoolem n-yẽgdã. --B sẽn yãk-a wã segd n yɩɩ sẽn pa tar-a n yɩɩd fãa.--Yãmb tʋʋmda yaa y sẽn na n yãk bãnd a yembr n lebs-a.--""Y sã n kõ-d sõor sẽn makd tɩɩg wil sẽn tar nimero sẽn pa wẽns n be a pʋgẽ wã, --  >>> pluck [4,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 2:
--  >>> pluck [1,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 3:
--  >>> pluck []
--  []
--  Example 4:
--  >>> pluck [5,0,3,0,4,2]
--  [0,1]
--  Explanation: 0 is the smallest value, but  there are two zeros,
--  so we will choose the first zero, which has the smallest index.
--  Constraints:
--  * 1 <= nodes.length <= 10000
--  * 0 <= node.value
pluck :: [Int] -> [Int]
pluck arr =","pluck :: [Int] -> [Int]
pluck arr = case filter (\(x, _) -> even x) (zip arr [0..]) of
    [] -> []
    evens -> let (value, index) = minimum evens in [value, index]","
main :: IO ()
main = do
  let candidate = pluck
  if candidate [4,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error ""assertion failed""
  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error ""assertion failed""
  if candidate [5,4,8,4,8] == [4,1] then pure () else error ""assertion failed""
  if candidate [7,6,7,1] == [6,1] then pure () else error ""assertion failed""
  if candidate [7,9,7,1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_69,mos_Latn,hs,"--Makre: --Sã n pa be tɩla woto, lebg n wa ne -1.--Sõor sẽn yaa zãng naoor a wãn la b yãt-a sõorã pʋgẽ.--yaa zaalem, la a naoor yaa n yɩɩd bɩ n zemsa ne nimero-rãmbã meng sẽn yaa sõma wã.--B kõ-y-la sõor sẽn pa zaalem sẽn na n yɩll n bãng sã n yaa sõma bɩ pa sõma.--  >>> search [4,1,2,2,3,1]
--  2
--  >>> search [1,2,2,3,3,3,4,4,4]
--  3
--  >>> search [5,5,4,4,4]
--  (-1)
search :: [Int] -> Int
search lst =","import Data.List (group, sort)
import Data.Ord (comparing)

search :: [Int] -> Int
search lst = 
    let frequencies = map (\g -> (head g, length g)) . group . sort $ lst
        candidates = filter (\(val, freq) -> freq >= val) frequencies
    in case candidates of
         [] -> -1
         _  -> fst . maximum $ candidates","
main :: IO ()
main = do
  let candidate = search
  if candidate [5,5,5,5,1] == 1 then pure () else error ""assertion failed""
  if candidate [4,1,4,1,4,4] == 4 then pure () else error ""assertion failed""
  if candidate [3,3] == (-1) then pure () else error ""assertion failed""
  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error ""assertion failed""
  if candidate [2,3,3,2,2] == 2 then pure () else error ""assertion failed""
  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error ""assertion failed""
  if candidate [3,2,8,2] == 2 then pure () else error ""assertion failed""
  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error ""assertion failed""
  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error ""assertion failed""
  if candidate [1,9,10,1,3] == 1 then pure () else error ""assertion failed""
  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error ""assertion failed""
  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error ""assertion failed""
  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error ""assertion failed""
  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error ""assertion failed""
  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error ""assertion failed""
  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error ""assertion failed""
  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error ""assertion failed""
  if candidate [10] == (-1) then pure () else error ""assertion failed""
  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error ""assertion failed""
  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error ""assertion failed""
  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error ""assertion failed""
  if candidate [3,10,10,9,2] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_70,mos_Latn,hs,"--Makre: --Rẽ poore, yaa sẽn ketã fãa n na n yɩ wʋsgo, tɩ rẽ poor bɩ yɩ bilfu, la woto.--Yaa y sã n sɩng ne minimã, --☐ D sã n kõ sõor sẽn yaa zãng sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor--  >>> strangeSortList [1,2,3,4]
--  [1,4,2,3]
--  >>> strangeSortList [5,5,5,5]
--  [5,5,5,5]
--  >>> strangeSortList []
--  []
strangeSortList :: [Int] -> [Int]
strangeSortList lst =","strangeSortList :: [Int] -> [Int]
strangeSortList [] = []
strangeSortList lst = go (sort lst) True
  where
    go [] _ = []
    go xs toggle
      | toggle    = head xs : go (tail xs) False
      | otherwise = last xs : go (init xs) True","
main :: IO ()
main = do
  let candidate = strangeSortList
  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error ""assertion failed""
  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error ""assertion failed""
  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error ""assertion failed""
  if candidate [111111] == [111111] then pure () else error ""assertion failed""
  pure ()"
HumanEval_71,mos_Latn,hs,"--Makre: --Yaa a tãab-n-soabã n yɩɩd a to wã.--B sẽn boond tɩ triyangl tɩ "" triyangl sẽn tar nens a tãabã "" yaa b sẽn sã n get tɩ b sẽn sõd a yiibã fãa yaa wʋsgo .--Sã n pa rẽ bɩ y lebs n gʋls tɩ -1 --B sã n na n maan tɩ nug-rɩtg a tãabã lebg wa nug-rɩtg sẽn zemsã, b na n kɩtame tɩ nug-rɩtgã lebg nug-rɩtg a yiib sẽn zems zĩ-n-vẽenemã.--D sã n ges sẽn yaa a soab n yaa a tãabã, d na n yeelame tɩ d na n paama a sẽn yaa a soabã.--  >>> triangleArea 3 4 5
--  6.0
--  >>> triangleArea 1 2 10
--  (-1).0
triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c =","import Text.Printf (printf)

triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c
    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))
    | otherwise = -1
  where
    s = (fromIntegral (a + b + c)) / 2
    isValidTriangle x y z = x + y > z && x + z > y && y + z > x
    roundToTwoDecimals x = read (printf ""%.2f"" x) :: Float","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 3 4 5 == 6.0 then pure () else error ""assertion failed""
  if candidate 1 2 10 == (-1).0 then pure () else error ""assertion failed""
  if candidate 4 8 5 == 8.18 then pure () else error ""assertion failed""
  if candidate 2 2 2 == 1.73 then pure () else error ""assertion failed""
  if candidate 1 2 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 10 5 7 == 16.25 then pure () else error ""assertion failed""
  if candidate 2 6 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 1 1 1 == 0.43 then pure () else error ""assertion failed""
  if candidate 2 2 10 == (-1).0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_72,mos_Latn,hs,"--Makre: --Yĩngr q na n yɩga sã n yaa tɩlɛ (a yaa palindrom lisi) la a wilã sõor sã n pa ta bɩ n zemsa ne zɩɩm sẽn tõe n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll n yɩll--☐ A. A. A. A. A.--  >>> willItFly [1,2] 5
--  False
--  # 1+2 is less than the maximum possible weight, but it's unbalanced.
--  >>> willItFly [3,2,3] 1
--  False
--  # it's balanced, but 3+2+3 is more than the maximum possible weight.
--  >>> willItFly [3,2,3] 9
--  True
--  # 3+2+3 is less than the maximum possible weight, and it's balanced.
--  >>> willItFly [3] 5
--  True
--  # 3 is less than the maximum possible weight, and it's balanced.
willItFly :: [Int] -> Int -> Bool
willItFly q w =","willItFly :: [Int] -> Int -> Bool
willItFly q w = isPalindrome q && sum q <= w

isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs","
main :: IO ()
main = do
  let candidate = willItFly
  if candidate [3,2,3] 9 == True then pure () else error ""assertion failed""
  if candidate [1,2] 5 == False then pure () else error ""assertion failed""
  if candidate [3] 5 == True then pure () else error ""assertion failed""
  if candidate [3,2,3] 1 == False then pure () else error ""assertion failed""
  if candidate [1,2,3] 6 == False then pure () else error ""assertion failed""
  if candidate [5] 5 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_73,mos_Latn,hs,"--Wala makre: --yaa wa b sẽn gʋlsd n lebgd n lebgd n lebgdẽ. Y tõe n toeema bũmb a ye n lebg bũmb a to.--yaa tɩlɛ tɩ b toeeme n na n kɩt tɩ sõsgã yɩ wa palindrom.--D sã n kõ sõor sẽn yaa zãng n sõdge, bao-y bũmb nins sõor sẽn yaa bilf n tõe n yɩ a soaba.--  >>> smallestChange [1,2,3,5,4,7,9,6]
--  4
--  >>> smallestChange [1,2,3,4,3,2,2]
--  1
--  >>> smallestChange [1,2,3,2,1]
--  0
smallestChange :: [Int] -> Int
smallestChange arr =","smallestChange :: [Int] -> Int
smallestChange arr = sum $ zipWith (\x y -> if x /= y then 1 else 0) arr (reverse arr)","
main :: IO ()
main = do
  let candidate = smallestChange
  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error ""assertion failed""
  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,2,3,2,1] == 0 then pure () else error ""assertion failed""
  if candidate [3,1,1,3] == 0 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_74,mos_Latn,hs,"--Makre --Sã n yaa sõor a ye la b gʋlsd b yiibã fãa pʋgẽ, lebg n gʋls pipi sõorã.--Bãngr-gomdã sõor sẽn yaa bilfã bee sõor a taabã fãa pʋgẽ.--Gʋls tʋʋm-noor sẽn deegd sõor a yiib n lebg n wat ne sõor ning sẽn tar --  >>> totalMatch [] []
--  []
--  >>> totalMatch [""hi"",""admin""] [""hI"",""Hi""]
--  [""hI"",""Hi""]
--  >>> totalMatch [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""]
--  [""hi"",""admin""]
--  >>> totalMatch [""hi"",""admin""] [""hI"",""hi"",""hi""]
--  [""hI"",""hi"",""hi""]
--  >>> totalMatch [""4""] [""1"",""2"",""3"",""4"",""5""]
--  [""4""]
totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2 =","totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2
  | totalChars lst1 < totalChars lst2 = lst1
  | totalChars lst1 > totalChars lst2 = lst2
  | otherwise = lst1
  where
    totalChars = sum . map length","
main :: IO ()
main = do
  let candidate = totalMatch
  if candidate [] [] == [] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi""] == [""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [""4""] [""1"",""2"",""3"",""4"",""5""] == [""4""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""Hi""] == [""hI"",""Hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hi""] == [""hI"",""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hii""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [] [""this""] == [] then pure () else error ""assertion failed""
  if candidate [""this""] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_75,mos_Latn,hs,"--Makre: --D bãng tɩ a yaa bilf n yɩɩd 100.--La b pa sɩd ye.--Gʋls-y tʋʋm-noor sẽn na n lebg n wa ne sɩd sã n yaa sõor ning b sẽn kõ wã yaa sõor a 3 sẽn yaa pipi sõor b sẽn dɩk n mak ne taaba.--  >>> isMultiplyPrime 30
--  True
--  30 = 2 * 3 * 5
isMultiplyPrime :: Int -> Bool
isMultiplyPrime a =","isMultiplyPrime :: Int -> Bool
isMultiplyPrime a = any isTriplePrimeProduct primeTriples
  where
    primes = filter isPrime [2..99]
    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]
    isTriplePrimeProduct (x, y, z) = x * y * z == a

isPrime :: Int -> Bool
isPrime n 
  | n < 2     = False
  | otherwise = not (any (\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","
main :: IO ()
main = do
  let candidate = isMultiplyPrime
  if candidate 5 == False then pure () else error ""assertion failed""
  if candidate 30 == True then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == False then pure () else error ""assertion failed""
  if candidate 125 == True then pure () else error ""assertion failed""
  if candidate 105 == True then pure () else error ""assertion failed""
  if candidate 126 == False then pure () else error ""assertion failed""
  if candidate 729 == False then pure () else error ""assertion failed""
  if candidate 891 == False then pure () else error ""assertion failed""
  if candidate 1001 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_76,mos_Latn,hs,"--Wala makre: --x yaa n sẽn tar pãng bala, n**int=x --n yaa ziri, la a pa sɩd ye.--Y tʋʋmda yaa gʋls tʋʋm-noor sẽn lebg n wa ne sɩd sã n yaa tɩ sõor a ye yaa x bala.--  >>> isSimplePower 1 4
--  True
--  >>> isSimplePower 2 2
--  True
--  >>> isSimplePower 8 2
--  True
--  >>> isSimplePower 3 2
--  False
--  >>> isSimplePower 3 1
--  False
--  >>> isSimplePower 5 3
--  False
isSimplePower :: Int -> Int -> Bool
isSimplePower x n =","isSimplePower :: Int -> Int -> Bool
isSimplePower x n
  | x < 1 || n < 1 = False
  | n == 1 = x == 1
  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","
main :: IO ()
main = do
  let candidate = isSimplePower
  if candidate 16 2 == True then pure () else error ""assertion failed""
  if candidate 143214 16 == False then pure () else error ""assertion failed""
  if candidate 4 2 == True then pure () else error ""assertion failed""
  if candidate 9 3 == True then pure () else error ""assertion failed""
  if candidate 16 4 == True then pure () else error ""assertion failed""
  if candidate 24 2 == False then pure () else error ""assertion failed""
  if candidate 128 4 == False then pure () else error ""assertion failed""
  if candidate 12 6 == False then pure () else error ""assertion failed""
  if candidate 1 1 == True then pure () else error ""assertion failed""
  if candidate 1 12 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_77,mos_Latn,hs,"--Makre: --Sebre: y tõe n tagsame tɩ sẽn kẽed ne wã yaa wakat fãa. --sã n yaa tɩ Ingegrã yaa koe-zĩig sẽn yaa zãngã.--Gʋls-y tʋʋm-noor sẽn na n dɩk sõor sẽn yaa zãng n lebg tɩ True.--  >>> iscube 1
--  True
--  >>> iscube 2
--  False
--  >>> iscube (-1)
--  True
--  >>> iscube 64
--  True
--  >>> iscube 0
--  True
--  >>> iscube 180
--  False
iscube :: Int -> Bool
iscube a =","iscube :: Int -> Bool
iscube a = let n = round (fromIntegral a ** (1/3)) in n^3 == a","
main :: IO ()
main = do
  let candidate = iscube
  if candidate 1 == True then pure () else error ""assertion failed""
  if candidate 2 == False then pure () else error ""assertion failed""
  if candidate (-1) == True then pure () else error ""assertion failed""
  if candidate 64 == True then pure () else error ""assertion failed""
  if candidate 180 == False then pure () else error ""assertion failed""
  if candidate 1000 == True then pure () else error ""assertion failed""
  if candidate 0 == True then pure () else error ""assertion failed""
  if candidate 1729 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_78,mos_Latn,hs,"--Makre: --la b sẽn gʋlsd-b tɩ A, B, C, D, E, F wã fãa yaa kãsenga. --Sebr: y tõe n tagsame tɩ sẽn kẽed ne wã yaa sõma wakat fãa bɩ yaa vɛɛre.--B (= piig pʋɩɩr 11), D (= piig pʋɩɩr 13). --Woto wã, y segd n baoo sõor sẽn yaa 2, 3, 5, 7, --Sõor a yiib n tãag a nu, a nu, a yopoe, a piig la a yembr, a piig la a tãab, a piig la a yopoe, a piig la a yopoe, a piig la a yopoe, a piig la a yopoe, ...--B sẽn boond tɩ hexadecimalã yaa 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.--yaa 1 n yɩɩd tɩ pa wil-bõoneg a yiib sẽn yaa bõones n yɩɩd rẽ ye).--Bõn-dãmb sẽn yaa pipi sõor (bɩ pipi sõor yaa pipi sõor --a hexadecimal sõor wa sõor sẽn yaa sõor sẽn yaa hexadecimal sõor --B yeel-y lame tɩ y gʋls tʋʋm-noor sẽn deegd --  >>> hexKey ""AB""
--  1
--  >>> hexKey ""1077E""
--  2
--  >>> hexKey ""ABED1A33""
--  4
--  >>> hexKey ""123456789ABCDEF0""
--  6
--  >>> hexKey ""2020""
--  2
hexKey :: String -> Int
hexKey num =","hexKey :: String -> Int
hexKey num = length . filter (`elem` primeHexDigits) $ num
  where
    primeHexDigits = ""2357BD""","
main :: IO ()
main = do
  let candidate = hexKey
  if candidate ""AB"" == 1 then pure () else error ""assertion failed""
  if candidate ""1077E"" == 2 then pure () else error ""assertion failed""
  if candidate ""ABED1A33"" == 4 then pure () else error ""assertion failed""
  if candidate ""2020"" == 2 then pure () else error ""assertion failed""
  if candidate ""123456789ABCDEF0"" == 6 then pure () else error ""assertion failed""
  if candidate ""112233445566778899AABBCCDDEEFF00"" == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_79,mos_Latn,hs,"--Makre: --B sẽn yãkd lɛtrã n paasã yaa sẽn na yɩl n sõng-a t'a yɩ sõma. --B na n paama 'db' n paas sõor a yiib sõorã sɩngr la a baasgẽ.--Bõn-naandg fãa sẽn be sõor-gãndã pʋgẽ na n yɩɩ '0' bɩ '1'.--yaa binɛɛr sõor sẽn yaa toore. Tʋʋmdã segd n lebg n waa ne sõor sẽn yaa toore, tɩ makrã fãa makd binɛɛr sõor --B na n kõ-y-la sõor sẽn yaa tɩlɛ tɩ y tek n lebg tɩ .--  >>> decimalToBinary 15
--  ""db1111db""
--  >>> decimalToBinary 32
--  ""db100000db""
decimalToBinary :: Int -> String
decimalToBinary decimal =","decimalToBinary :: Int -> String
decimalToBinary decimal = ""db"" ++ toBinary decimal ++ ""db""
  where
    toBinary 0 = ""0""
    toBinary n = reverse (binaryHelper n)

    binaryHelper 0 = """"
    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","
main :: IO ()
main = do
  let candidate = decimalToBinary
  if candidate 0 == ""db0db"" then pure () else error ""assertion failed""
  if candidate 32 == ""db100000db"" then pure () else error ""assertion failed""
  if candidate 103 == ""db1100111db"" then pure () else error ""assertion failed""
  if candidate 15 == ""db1111db"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_80,mos_Latn,hs,"--Wala makre: --Sõngr yaa haps sã n yaa a woglem yaa 3 la sã n yaa tɩlɛ tɩ b welg lɛtbr a 3 fãa sẽn pʋgl taab toore.--Yãmb tʋʋmda yaa ges y sã n tara haphs bɩ pa rẽ.--B kõ-y-la sõor sẽn yaa sõor-yende.--  >>> isHappy ""a""
--  False
--  >>> isHappy ""aa""
--  False
--  >>> isHappy ""abcd""
--  True
--  >>> isHappy ""aabb""
--  False
--  >>> isHappy ""adb""
--  True
--  >>> isHappy ""xyy""
--  False
isHappy :: String -> Bool
isHappy s =","isHappy :: String -> Bool
isHappy s
  | length s < 3 = False
  | otherwise = all distinctTriples (windows 3 s)
  where
    distinctTriples [x, y, z] = x /= y && y /= z && x /= z
    distinctTriples _ = False
    windows n xs
      | length xs < n = []
      | otherwise = take n xs : windows n (tail xs)","
main :: IO ()
main = do
  let candidate = isHappy
  if candidate ""a"" == False then pure () else error ""assertion failed""
  if candidate ""aa"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""adb"" == True then pure () else error ""assertion failed""
  if candidate ""xyy"" == False then pure () else error ""assertion failed""
  if candidate ""iopaxpoi"" == True then pure () else error ""assertion failed""
  if candidate ""iopaxioi"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_81,mos_Latn,hs,"--Makre: --0.0 E --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 B+ --> 3.3 A- --> 3.7 A --4.0 A + --GPA. r-y sõor --yaa tʋʋm-noor sẽn tõe n yiis lɛt-rãmb sõor n tũnug ne taabl ning sẽn pʋgdã: --A kõ-y-la karen-biis kẽer sẽn paam minim minim minim sõor n gʋls n kõ-yã.--Yaa a sẽn da tũnugd ne n makd nebã n pa le miẽ wã bal n kɩt t'a pa le tõe n bãng b sẽn maand bũmb ningã ye.--Karen-saambã maana a meng sẽn na yɩl n mak b karen-biisã.--Yaa semɛstrã yaoolem semen la karen-saambã segd n kõo karen-biisã makrã.--  >>> gradeEquation [4.0,3,1.7,2,3.5]
--  [""A+"",""B"",""C-"",""C"",""A-""]
numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades =","numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades = map gpaToLetterGrade grades
  where
    gpaToLetterGrade gpa
      | gpa == 4.0 = ""A+""
      | gpa > 3.7  = ""A""
      | gpa > 3.3  = ""A-""
      | gpa > 3.0  = ""B+""
      | gpa > 2.7  = ""B""
      | gpa > 2.3  = ""B-""
      | gpa > 2.0  = ""C+""
      | gpa > 1.7  = ""C""
      | gpa > 1.3  = ""C-""
      | gpa > 1.0  = ""D+""
      | gpa > 0.7  = ""D""
      | gpa > 0.0  = ""D-""
      | otherwise  = ""E""","
main :: IO ()
main = do
  let candidate = numericalLetterGrade
  if candidate [4.0,3,1.7,2,3.5] == [""A+"",""B"",""C-"",""C"",""A-""] then pure () else error ""assertion failed""
  if candidate [1.2] == [""D+""] then pure () else error ""assertion failed""
  if candidate [0.5] == [""D-""] then pure () else error ""assertion failed""
  if candidate [0.0] == [""E""] then pure () else error ""assertion failed""
  if candidate [1.0,0.3,1.5,2.8,3.3] == [""D"",""D-"",""C-"",""B"",""B+""] then pure () else error ""assertion failed""
  if candidate [0.0,0.7] == [""E"",""D-""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_82,mos_Latn,hs,"--Makre --length yaa pipi sõor bɩ pa sɩda --Gʋls-y tʋʋm-noor sẽn na n dɩk n lebg n wa ne Vɛrse sã n yaa tɩ vɛrse wã yaa ẽ-vɛrse.--  >>> primeLength ""Hello""
--  True
--  >>> primeLength ""abcdcba""
--  True
--  >>> primeLength ""kittens""
--  True
--  >>> primeLength ""orange""
--  False
primeLength :: String -> Bool
primeLength string =","primeLength :: String -> Bool
primeLength string = isPrime (length string)

isPrime :: Int -> Bool
isPrime n
  | n < 2     = False
  | n == 2    = True
  | even n    = False
  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = primeLength
  if candidate ""Hello"" == True then pure () else error ""assertion failed""
  if candidate ""abcdcba"" == True then pure () else error ""assertion failed""
  if candidate ""kittens"" == True then pure () else error ""assertion failed""
  if candidate ""orange"" == False then pure () else error ""assertion failed""
  if candidate ""wow"" == True then pure () else error ""assertion failed""
  if candidate ""world"" == True then pure () else error ""assertion failed""
  if candidate ""MadaM"" == True then pure () else error ""assertion failed""
  if candidate ""Wow"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""HI"" == True then pure () else error ""assertion failed""
  if candidate ""go"" == True then pure () else error ""assertion failed""
  if candidate ""gogo"" == False then pure () else error ""assertion failed""
  if candidate ""aaaaaaaaaaaaaaa"" == False then pure () else error ""assertion failed""
  if candidate ""Madam"" == True then pure () else error ""assertion failed""
  if candidate ""M"" == False then pure () else error ""assertion failed""
  if candidate ""0"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_83,mos_Latn,hs,"--yaa sõor sẽn yaa sõma sẽn sɩng ne 1 bɩ sẽn baas ne 1 --❑ D sã n kõ sõor sẽn yaa sõma n, d na n leoka sõor ning sẽn tar n-digitã sõore.startsOneEnds :: Int -> Int
startsOneEnds n =","startsOneEnds :: Int -> Int
startsOneEnds n
  | n <= 0    = 0
  | n == 1    = 1
  | otherwise = 18 * 10^(n-2)","
main :: IO ()
main = do
  let candidate = startsOneEnds
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 2 == 18 then pure () else error ""assertion failed""
  if candidate 3 == 180 then pure () else error ""assertion failed""
  if candidate 4 == 1800 then pure () else error ""assertion failed""
  if candidate 5 == 18000 then pure () else error ""assertion failed""
  pure ()"
HumanEval_84,mos_Latn,hs,"--Makre --☐ D sã n kõ sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma--  >>> solve 1000
--  ""1""
--  >>> solve 150
--  ""110""
--  >>> solve 147
--  ""1100""
--  Variables:
--  @N integer
--  Constraints: 0 ≤ N ≤ 10000.
--  Output:
--  a string of binary number
solve :: Int -> String
solve N =","solve :: Int -> String
solve N = toBinary (sumOfDigits N)
  where
    sumOfDigits 0 = 0
    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)

    toBinary 0 = ""0""
    toBinary n = reverse (toBinary' n)
      where
        toBinary' 0 = """"
        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","
main :: IO ()
main = do
  let candidate = solve
  if candidate 1000 == ""1"" then pure () else error ""assertion failed""
  if candidate 150 == ""110"" then pure () else error ""assertion failed""
  if candidate 147 == ""1100"" then pure () else error ""assertion failed""
  if candidate 333 == ""1001"" then pure () else error ""assertion failed""
  if candidate 963 == ""10010"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_85,mos_Latn,hs,"--Makre: --◯ D sã n kõ sõor sẽn pa zaalem, d na n deng n sõd-a-la ne sõor sẽn pa yembr sẽn yaa a toore.--  >>> add [4,2,6,7]
--  2
add :: [Int] -> Int
add lst =","add :: [Int] -> Int
add lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","
main :: IO ()
main = do
  let candidate = add
  if candidate [4,88] == 88 then pure () else error ""assertion failed""
  if candidate [4,5,6,7,2,122] == 122 then pure () else error ""assertion failed""
  if candidate [4,0,6,7] == 0 then pure () else error ""assertion failed""
  if candidate [4,4,6,8] == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_86,mos_Latn,hs,"--Wala makre: --Sebrã pʋgẽ, y segd n tũuda gom-biisã sẽn be zĩig ningã, la y pa segd n bas zĩ-zulungã ye.--Yaa sẽn na n yɩlẽ n paam n paas b sẽn da get b yellã.--B ledga gom-paall sẽn na n yɩll tɩ b gʋlsd b fãa ne --B sẽn kõ sor tɩ b gʋls sõssã to-to wã yaa sõss nins fãa sẽn be be wã (b sẽn welg ne zĩiga) --❑ Gʋls-y tʋʋm-noor sẽn dɩkd sõn-vãoog n lebg n wat ne a sẽn be sor zug to-to.--  >>> antiShuffle ""Hi""
--  ""Hi""
--  >>> antiShuffle ""hello""
--  ""ehllo""
--  >>> antiShuffle ""Hello World!!!""
--  ""Hello !!!Wdlor""
antiShuffle :: String -> String
antiShuffle s =","import Data.List (sort)
import Data.Char (isAlpha)

antiShuffle :: String -> String
antiShuffle s = unwords $ map sortWord (wordsAndSpaces s)
  where
    sortWord word = if all isAlpha word then sort word else word
    wordsAndSpaces [] = []
    wordsAndSpaces xs = if head xs == ' ' 
                        then "" "" : wordsAndSpaces (dropWhile (== ' ') xs)
                        else let (word, rest) = break (== ' ') xs
                             in word : wordsAndSpaces rest","
main :: IO ()
main = do
  let candidate = antiShuffle
  if candidate ""Hi"" == ""Hi"" then pure () else error ""assertion failed""
  if candidate ""hello"" == ""ehllo"" then pure () else error ""assertion failed""
  if candidate ""number"" == ""bemnru"" then pure () else error ""assertion failed""
  if candidate ""abcd"" == ""abcd"" then pure () else error ""assertion failed""
  if candidate ""Hello World!!!"" == ""Hello !!!Wdlor"" then pure () else error ""assertion failed""
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hi. My name is Mister Robot. How are you?"" == "".Hi My aemn is Meirst .Rboot How aer ?ouy"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_87,mos_Latn,hs,"--Makre: --Sẽn paase, bɩ y welg sõsdã zĩis n welge.--Rɩk-y n ges-y zĩ-kãens sẽn be zĩig ningã n sɩng ne sõor sẽn zẽkdẽ wã.--Tʋʋmdã fãa yaa sẽn na n sɩng ne 0 (rɩɩɩlgo, kolõns).--la lebg n wa ne tuple rãmb sõor sẽn yaa woto: [(x1, y1), (x2, y2) ...] tɩ --D sã n kõ tɩ lst yaa sõor sẽn pa rẽnd n yaa x, bɩ d bao sõor sẽn pa rẽnd n yaa x sõor ning sẽn be sõor-kãng pʋgẽ wã, --Sõsg fãa tõe n tara sull sõor sẽn yaa toor-toore.--yaa wa matriksi, la pa wa matriksi wã ye.--B kõ-y-la dʋrwa-rãmb sẽn yaa wa b sẽn ningd-b b taab n beẽ wã.--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1
--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]
--  >>> getRow [] 1
--  []
--  >>> getRow [[],[1],[1,2,3]] 3
--  [(2, 2)]
getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x =","getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x = concatMap processRow (zip [0..] lst)
  where
    processRow (rowIndex, row) = 
      let colIndices = reverse $ findIndices (== x) row
      in [(rowIndex, colIndex) | colIndex <- colIndices]

findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","
main :: IO ()
main = do
  let candidate = getRow
  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error ""assertion failed""
  if candidate [] 1 == [] then pure () else error ""assertion failed""
  if candidate [[1]] 2 == [] then pure () else error ""assertion failed""
  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_88,mos_Latn,hs,"--Makre: --* ra toeem sõsg ning b sẽn kõ wã ye. --Sebr a ye: --Wala makre, y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore, bɩ y sã n wa ne sõor sẽn yaa toor-toore.--y na n welga sõor ning sẽn be wã ne sẽn yikd-a wã, sã n yaa tɩ sõor ning sẽn yaa (( pipi indeksã yõodo, yaoolem indeksã yõodo) yaa pa-yende, --D sã n kõ sõor sẽn pa zuloees n lebg n wa ne sõor a ye sẽn pa zuloees n wa n lebg n wa ne sõor a ye sẽn pa zuloees n wa ne sõor a ye sẽn yaa zuloees n wa ne sõor a ye, d na n lebg n wa ne sõor a ye sẽn yaa zuloees n wa ne sõor a ye sẽn yaa zuloees n wa ne sõor a ye.--  >>> sortArray []
--  []
--  >>> sortArray [5]
--  [5]
--  >>> sortArray [2,4,3,0,1,5]
--  [0,1,2,3,4,5]
--  >>> sortArray [2,4,3,0,1,5,6]
--  [6,5,4,3,2,1,0]
sortArray :: [Int] -> [Int]
sortArray array =","sortArray :: [Int] -> [Int]
sortArray array
  | null array = array
  | otherwise =
    let first = head array
        last = last array
        sumFirstLast = first + last
    in if odd sumFirstLast
       then sort array
       else reverse (sort array)","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5] == [5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error ""assertion failed""
  if candidate [2,1] == [1,2] then pure () else error ""assertion failed""
  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error ""assertion failed""
  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error ""assertion failed""
  pure ()"
HumanEval_89,mos_Latn,hs,"--Wala makre: --B sẽn na n maan to-to tɩ b sẽn na n maan to-to wã yɩ sõma n yɩɩda, yaa b sẽn na n maan to-to wã.--B segd n wẽnemda lɛtbã sẽn na yɩl tɩ lɛtbã --lebgda sõor sẽn kẽed ne alfabɛtã sẽn lebg n lebg n wa. --☐ A F.A.--  >>> encrypt ""hi""
--  ""lm""
--  >>> encrypt ""asdfghjkl""
--  ""ewhjklnop""
--  >>> encrypt ""gf""
--  ""kj""
--  >>> encrypt ""et""
--  ""ix""
encrypt :: String -> String
encrypt s =","encrypt :: String -> String
encrypt s = map shiftChar s
  where
    shiftChar c
      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')
      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')
      | otherwise = c","
main :: IO ()
main = do
  let candidate = encrypt
  if candidate ""hi"" == ""lm"" then pure () else error ""assertion failed""
  if candidate ""asdfghjkl"" == ""ewhjklnop"" then pure () else error ""assertion failed""
  if candidate ""gf"" == ""kj"" then pure () else error ""assertion failed""
  if candidate ""et"" == ""ix"" then pure () else error ""assertion failed""
  if candidate ""faewfawefaewg"" == ""jeiajeaijeiak"" then pure () else error ""assertion failed""
  if candidate ""hellomyfriend"" == ""lippsqcjvmirh"" then pure () else error ""assertion failed""
  if candidate ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"" == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" then pure () else error ""assertion failed""
  if candidate ""a"" == ""e"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_90,mos_Latn,hs,"--D sã n pa tar bũmb sẽn wilgd tɩ bũmb n be, d pa segd n lebs ye.--gʋls tʋʋm-noor sẽn boond tɩ next_smallest (), sẽn na n lebg n wa ne sõor a yiib-n-soab sẽn yaa bilfr n yɩɩd sõorã pʋgẽ. --B kõ-y-la sõor sẽn yaa zãng n gʋls n tool-y.--  >>> nextSmallest [1,2,3,4,5]
--  Just (2)
--  >>> nextSmallest [5,1,4,3,2]
--  Just (2)
--  >>> nextSmallest []
--  Just (Nothing)
--  >>> nextSmallest [1,1]
--  Just (Nothing)
nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =","nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =
  let uniqueSorted = removeDuplicates $ quicksort lst
  in if length uniqueSorted < 2
     then Nothing
     else Just (uniqueSorted !! 1)

removeDuplicates :: (Ord a) => [a] -> [a]
removeDuplicates = foldr (\x acc -> if x `elem` acc then acc else x : acc) []

quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = nextSmallest
  if candidate [1,2,3,4,5] == Just (2) then pure () else error ""assertion failed""
  if candidate [5,1,4,3,2] == Just (2) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1,1,1,0] == Just (1) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error ""assertion failed""
  pure ()"
HumanEval_91,mos_Latn,hs,"--Wala makre: --B boonda gom-biis ne '.', '?' bɩ '!'. --A sẽn yaa sũ-sãang soab yaa gom-bi-kãngã sẽn sɩng ne ""m"" wã.--B na n kõ-y-la gom-biis sõor wʋsgo, la y tʋʋmd yaa sõdga sõorã.--  >>> isBored ""Hello world""
--  0
--  >>> isBored ""The sky is blue. The sun is shining. I love this weather""
--  1
isBored :: String -> Int
isBored S =","isBored :: String -> Int
isBored s = length $ filter (startsWithI . words) $ splitSentences s
  where
    splitSentences :: String -> [String]
    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters "".?!""
    
    splitOnDelimiters :: String -> String -> [String]
    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of
      """" -> []
      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''
    
    startsWithI :: [String] -> Bool
    startsWithI [] = False
    startsWithI (x:_) = map toLower x == ""i""","
main :: IO ()
main = do
  let candidate = isBored
  if candidate ""Hello world"" == 0 then pure () else error ""assertion failed""
  if candidate ""Is the sky blue?"" == 0 then pure () else error ""assertion failed""
  if candidate ""I love It !"" == 1 then pure () else error ""assertion failed""
  if candidate ""bIt"" == 0 then pure () else error ""assertion failed""
  if candidate ""I feel good today. I will be productive. will kill It"" == 2 then pure () else error ""assertion failed""
  if candidate ""You and I are going for a walk"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_92,mos_Latn,hs,"--Makre --A sã n pa woto, a lebgda ziri.--A sã n lebg n lebg n wa n na n wilg tɩ sõor a ye yaa a yiib a taabã sõor sẽn na n yɩ to-to wã, la tɩ sõor fãa yaa sõor sẽn pa zãngã.--Na n maana fõnzã-rãmb sẽn na n dɩkd sõor a tãabo.--  >>> anyInt 5 2 7
--  True
--  >>> anyInt 3 2 2
--  False
--  >>> anyInt 3 (-2) 1
--  True
--  >>> anyInt 3.6 -2.2 2
--  False
anyInt :: Float -> Float -> Float -> Bool
anyInt x y z =","anyInt :: Float -> Float -> Float -> Bool
anyInt x y z
  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =
      x == y + z || y == x + z || z == x + y
  | otherwise = False","
main :: IO ()
main = do
  let candidate = anyInt
  if candidate 2.0 3.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 2.5 2.0 3.0 == False then pure () else error ""assertion failed""
  if candidate 1.5 5.0 3.5 == False then pure () else error ""assertion failed""
  if candidate 2.0 6.0 2.0 == False then pure () else error ""assertion failed""
  if candidate 4.0 2.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.2 2.2 2.2 == False then pure () else error ""assertion failed""
  if candidate (-4).0 6.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.0 1.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_93,mos_Latn,hs,"--Makre: --Yaa lɛtrã bal la y segd n ges n bãnge.--Yaa vokaal sẽn be ãngilindã babg ning b sẽn gʋls ne ãngilindã pʋgẽ.--Koe-no-kãng ne lɛtr ning sẽn be zĩ-bõoneg a yiib taoorã --A sẽn maand woto wã, a toeema lɛtbã fãa sẽn yaa kãs-kãs-kãsã, n ledg vokaall fãa sẽn be  pʋgẽ wã.--Gʋls-y tʋʋm-noor sẽn na n dɩk koɛɛg n ning-a ẽtɛgnetã pʋgẽ.--  >>> encode ""test""
--  ""TGST""
--  >>> encode ""This is a message""
--  ""tHKS KS C MGSSCGG""
encode :: String -> String
encode message =","encode :: String -> String
encode = map transformChar
  where
    transformChar :: Char -> Char
    transformChar c
      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c
      | otherwise      = swapCase c c
      where
        lowerC = toLower c

    isVowel :: Char -> Bool
    isVowel c = c `elem` ""aeiou""

    swapCase :: Char -> Char -> Char
    swapCase origC c
      | isUpper origC = toLower c
      | otherwise     = toUpper c","
main :: IO ()
main = do
  let candidate = encode
  if candidate ""TEST"" == ""tgst"" then pure () else error ""assertion failed""
  if candidate ""Mudasir"" == ""mWDCSKR"" then pure () else error ""assertion failed""
  if candidate ""YES"" == ""ygs"" then pure () else error ""assertion failed""
  if candidate ""This is a message"" == ""tHKS KS C MGSSCGG"" then pure () else error ""assertion failed""
  if candidate ""I DoNt KnOw WhAt tO WrItE"" == ""k dQnT kNqW wHcT Tq wRkTg"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_94,mos_Latn,hs,"--Makre: --Y segd n baoo pipi sõor ning sẽn yaa kãseng n yɩɩdã n lebs a sõorã sõor sẽn yaa a sõorã.--B kõ-y-la sõor sẽn yaa zãng n gʋls n tool-y.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]
--  10
--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]
--  25
--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]
--  13
--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]
--  11
--  >>> skjkasdkd [0,81,12,3,1,21]
--  3
--  >>> skjkasdkd [0,8,1,2,1,7]
--  7
skjkasdkd :: [Int] -> Int
skjkasdkd lst =","skjkasdkd :: [Int] -> Int
skjkasdkd lst = sumDigits (largestPrime lst)

-- Function to check if a number is prime
isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]

-- Integer square root using binary search, O(log n)
isqrt :: Int -> Int
isqrt n = floor . sqrt $ fromIntegral n

-- Function to find the largest prime in the list
largestPrime :: [Int] -> Int
largestPrime = foldr (\x acc -> if isPrime x && x > acc then x else acc) 0

-- Function to calculate the sum of the digits of a number
sumDigits :: Int -> Int
sumDigits 0 = 0
sumDigits n = n `mod` 10 + sumDigits (n `div` 10)","
main :: IO ()
main = do
  let candidate = skjkasdkd
  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error ""assertion failed""
  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error ""assertion failed""
  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error ""assertion failed""
  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error ""assertion failed""
  if candidate [0,81,12,3,1,21] == 3 then pure () else error ""assertion failed""
  if candidate [0,8,1,2,1,7] == 7 then pure () else error ""assertion failed""
  if candidate [8191] == 19 then pure () else error ""assertion failed""
  if candidate [8191,123456,127,7] == 19 then pure () else error ""assertion failed""
  if candidate [127,97,8192] == 10 then pure () else error ""assertion failed""
  pure ()"
HumanEval_95,mos_Latn,hs,"--Makre: --Fõn-sɛkdã segd n lebg n waame False yaa tɩ lagem-n-taar sõor ning b sẽn kõ wã yaa zaalem. --B sã n pa gʋlsd-a tɩ yɩ tɩlɛ bɩ b fãa yaa gãn-biis sẽn be tɩ b gʋlsd-a tɩ yɩ tɩlɛ, sã n pa rẽ bɩ b lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n lebg n n n n n n n n--☐ A sẽn kõ tõnd lagem-n-taar sõorã, lebg n wa ne True sã n yaa tɩ b fãa yaa sõor sẽn yaa zuloees sẽn yaa n-bãngr ☐ A sẽn kõ tõnd lagem-n-taar sõorã, lebg n wa ne True sã n yaa tɩ b fãa yaa sõor sẽn yaa zuloees sẽn yaa n-bãngr ☐ A sẽn kõ tõnd lagem-n-taar sõor sẽn yaa n-bãngr ☐--  >>> checkDictCase [(""a"", ""apple""), (""b"", ""banana"")]
--  True
--  >>> checkDictCase [(""a"", ""apple""), (""A"", ""banana""), (""B"", ""banana"")]
--  False
--  >>> checkDictCase [(""a"", ""apple""), (8, ""banana""), (""a"", ""apple"")]
--  False
--  >>> checkDictCase [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")]
--  False
--  >>> checkDictCase [(""STATE"", ""NC""), (""ZIP"", ""12345"")]
--  True
checkDictCase :: [(String, String)] -> Bool
checkDictCase dict =","import Data.Char (isUpper, isLower)

checkDictCase :: [(String, String)] -> Bool
checkDictCase [] = False
checkDictCase dict = all isLower allKeys || all isUpper allKeys
  where
    allKeys = concatMap fst dict","
main :: IO ()
main = do
  let candidate = checkDictCase
  if candidate [(""p"", ""pineapple""), (""b"", ""banana"")] == True then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""A"", ""banana""), (""B"", ""banana"")] == False then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""5"", ""banana""), (""a"", ""apple"")] == False then pure () else error ""assertion failed""
  if candidate [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")] == False then pure () else error ""assertion failed""
  if candidate [(""STATE"", ""NC""), (""ZIP"", ""12345"")] == True then pure () else error ""assertion failed""
  if candidate [(""fruit"", ""Orange""), (""taste"", ""Sweet"")] == True then pure () else error ""assertion failed""
  if candidate [] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_96,mos_Latn,hs,"--Wala makre: --yaa sõor sẽn yaa sõor sẽn yaa pipi n yɩɩd n.--☐ D rɩk n kõ sõor sẽn pa zʋʋg n lebg n wa ne pipi n wã sõor sõor sõor ☐ D rɩk n kõ sõor sẽn pa zʋʋg n lebg n wa ne pipi n wã sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor--  >>> countUpTo 5
--  [2,3]
--  >>> countUpTo 11
--  [2,3,5,7]
--  >>> countUpTo 0
--  []
--  >>> countUpTo 20
--  [2,3,5,7,11,13,17,19]
--  >>> countUpTo 1
--  []
--  >>> countUpTo 18
--  [2,3,5,7,11,13,17]
countUpTo :: Int -> [Int]
countUpTo n =","countUpTo :: Int -> [Int]
countUpTo n = filter isPrime [2..n-1]

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = countUpTo
  if candidate 5 == [2,3] then pure () else error ""assertion failed""
  if candidate 6 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 7 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 10 == [2,3,5,7] then pure () else error ""assertion failed""
  if candidate 0 == [] then pure () else error ""assertion failed""
  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error ""assertion failed""
  if candidate 1 == [] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error ""assertion failed""
  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error ""assertion failed""
  pure ()"
HumanEval_97,mos_Latn,hs,"--Makre: --D gesame tɩ b sẽn gʋls bũmb ningã yaa sõma wakat fãa.--b sullã wilã sẽn yaa to-to wã. --◯ Tʋʋmd ning sẽn dɩkd nimero-rãmb a yiib n lebg n watã ◯--  >>> multiply 148 412
--  16
--  >>> multiply 19 28
--  72
--  >>> multiply 2020 1851
--  0
--  >>> multiply 14 (-15)
--  20
multiply :: Int -> Int -> Int
multiply a b =","multiply :: Int -> Int -> Int
multiply a b = (abs a `mod` 10) * (abs b `mod` 10)","
main :: IO ()
main = do
  let candidate = multiply
  if candidate 148 412 == 16 then pure () else error ""assertion failed""
  if candidate 19 28 == 72 then pure () else error ""assertion failed""
  if candidate 2020 1851 == 0 then pure () else error ""assertion failed""
  if candidate 14 (-15) == 20 then pure () else error ""assertion failed""
  if candidate 76 67 == 42 then pure () else error ""assertion failed""
  if candidate 17 27 == 49 then pure () else error ""assertion failed""
  if candidate 0 1 == 0 then pure () else error ""assertion failed""
  if candidate 0 0 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_98,mos_Latn,hs,"--Wala makre: --❑ D sã n kõ-y sõor sẽn yaa s, bɩ y sõd koees nins sẽn be tɩ b gʋlsd ne koees sẽn yaa zuloees n yɩɩd a taabã.--  >>> countUpper ""aBCdEf""
--  1
--  >>> countUpper ""abcdefg""
--  0
--  >>> countUpper ""dBBE""
--  0
countUpper :: String -> Int
countUpper s =","countUpper :: String -> Int
countUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` ""AEIOU""]","
main :: IO ()
main = do
  let candidate = countUpper
  if candidate ""aBCdEf"" == 1 then pure () else error ""assertion failed""
  if candidate ""abcdefg"" == 0 then pure () else error ""assertion failed""
  if candidate ""dBBE"" == 0 then pure () else error ""assertion failed""
  if candidate ""B"" == 0 then pure () else error ""assertion failed""
  if candidate ""U"" == 1 then pure () else error ""assertion failed""
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""EEEE"" == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_99,mos_Latn,hs,"--Makre --Ne f sẽn na n yãkd koe-zĩis a yiib n na n dɩk n togl n zãag ne zéro wã.--sã n yaa tɩ sõorã yaa toore, --☐ D na n maana tʋʋm-noor sẽn na n dɩkd sõor sẽn makd sõor n kõ ☐ D na n maana tʋʋm-noor sẽn na n dɩkd sõor sẽn makd sõor n kõ ☐ D na n maana tʋʋm-noor sẽn na n dɩk sõor sẽn makd sõor ☐--  >>> closestInteger ""10""
--  10
--  >>> closestInteger ""15.3""
--  15
--  Note:
--  Rounding away from zero means that if the given number is equidistant
--  from two integers, the one you should return is the one that is the
--  farthest from zero. For example closest_integer(""14.5"") should
--  return 15 and closest_integer(""-14.5"") should return -15.
closestInteger :: String -> Int
closestInteger value =","closestInteger :: String -> Int
closestInteger value = 
  let n = read value :: Double
  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","
main :: IO ()
main = do
  let candidate = closestInteger
  if candidate ""10"" == 10 then pure () else error ""assertion failed""
  if candidate ""14.5"" == 15 then pure () else error ""assertion failed""
  if candidate ""-15.5"" == (-16) then pure () else error ""assertion failed""
  if candidate ""15.3"" == 15 then pure () else error ""assertion failed""
  if candidate ""0"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_100,mos_Latn,hs,"--Makre: --i yaa kugã sõor sẽn be zĩigã (i+1). --D lebg n wa ne kug sõor sẽn be sull fãa pʋgẽ, tɩ elemẽ wã be --- sã n yaa tɩ n yaa tɩle. --- sã n yaa n yaa pa-yɛlga, yaa sõor sẽn pʋgd n pa-yɛlga. --B sẽn na n tall kug-bõonesã to-to wã yaa: --Pipi sullã tara kug n.--◯ Y sã n kõ-d sõor sẽn yaa sõma n tãag n, y segd n talla kug-rãmb n tigim taab n maan tãngã.--  >>> makeAPile 3
--  [3,5,7]
makeAPile :: Int -> [Int]
makeAPile n =","makeAPile :: Int -> [Int]
makeAPile n = take n [n, n + 2 ..]","
main :: IO ()
main = do
  let candidate = makeAPile
  if candidate 3 == [3,5,7] then pure () else error ""assertion failed""
  if candidate 4 == [4,6,8,10] then pure () else error ""assertion failed""
  if candidate 5 == [5,7,9,11,13] then pure () else error ""assertion failed""
  if candidate 6 == [6,8,10,12,14,16] then pure () else error ""assertion failed""
  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error ""assertion failed""
  pure ()"
HumanEval_101,mos_Latn,hs,"--Wala makre: --n welg sõsgã n lebg gom-biis sõor sõor sõor n lebg n wa. --Y na n paama gom-biis sẽn welg ne vɛrse-rãmb la zĩ-zãrs n na n wilg y sẽn segd n maan to-to.--  >>> wordsString ""Hi, my name is John""
--  [""Hi"",""my"",""name"",""is"",""John""]
--  >>> wordsString ""One, two, three, four, five, six""
--  [""One"",""two"",""three"",""four"",""five"",""six""]
wordsString :: String -> [String]
wordsString s =","wordsString :: String -> [String]
wordsString s = words $ map (\c -> if c == ',' then ' ' else c) s","
main :: IO ()
main = do
  let candidate = wordsString
  if candidate ""Hi, my name is John"" == [""Hi"",""my"",""name"",""is"",""John""] then pure () else error ""assertion failed""
  if candidate ""One, two, three, four, five, six"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate ""Hi, my name"" == [""Hi"",""my"",""name""] then pure () else error ""assertion failed""
  if candidate ""One,, two, three, four, five, six,"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""ahmed     , gamal"" == [""ahmed"",""gamal""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_102,mos_Latn,hs,"--Wala makre: --sã n pa be sõor a woto, a segd n lebg n waa ne -1.--Sã n yaa tɩ  yaa sõor sẽn yaa zall n yɩɩd sẽn be zallã pʋgẽ [x, y] sẽn naag ne a taabã fãa.--Fõn-kãng rɩkda sõor a yiib sẽn yaa sõma, n boond tɩ x la y, n lebg n wa ne --  >>> chooseNum 12 15
--  14
--  >>> chooseNum 13 12
--  (-1)
chooseNum :: Int -> Int -> Int
chooseNum x y =","chooseNum :: Int -> Int -> Int
chooseNum x y
    | x > y = -1
    | even upperBound = upperBound
    | even (upperBound - 1) = upperBound - 1
    | otherwise = -1
  where
    upperBound = max x y","
main :: IO ()
main = do
  let candidate = chooseNum
  if candidate 12 15 == 14 then pure () else error ""assertion failed""
  if candidate 13 12 == (-1) then pure () else error ""assertion failed""
  if candidate 33 12354 == 12354 then pure () else error ""assertion failed""
  if candidate 5234 5233 == (-1) then pure () else error ""assertion failed""
  if candidate 6 29 == 28 then pure () else error ""assertion failed""
  if candidate 27 10 == (-1) then pure () else error ""assertion failed""
  if candidate 7 7 == (-1) then pure () else error ""assertion failed""
  if candidate 546 546 == 546 then pure () else error ""assertion failed""
  pure ()"
HumanEval_104,mos_Latn,hs,"--Wala makre: --Sebr ning b sẽn lebg n kõ wã segd n yɩɩ ne sor sẽn na n paasdẽ.--B sẽn boond tɩ ""rɩtbã"" wã pa be ye.--☐ D sã n kõ sõor sẽn yaa sõma n yɩɩd sõor fãa x, d na n lebg n kõ-a-la sõor sẽn yaa sõma n yɩɩd fãa ☐ D sã n kõ sõor sẽn yaa sõma n yɩɩd fãa x, d na n lebg n kõ-a-la sõor sẽn yaa sõma n yɩɩd fãa x.--  >>> uniqueDigits [15,33,1422,1]
--  [1,15,33]
--  >>> uniqueDigits [152,323,1422,10]
--  []
uniqueDigits :: [Int] -> [Int]
uniqueDigits x =","uniqueDigits :: [Int] -> [Int]
uniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","
main :: IO ()
main = do
  let candidate = uniqueDigits
  if candidate [15,33,1422,1] == [1,15,33] then pure () else error ""assertion failed""
  if candidate [152,323,1422,10] == [] then pure () else error ""assertion failed""
  if candidate [12345,2033,111,151] == [111,151] then pure () else error ""assertion failed""
  if candidate [135,103,31] == [31,135] then pure () else error ""assertion failed""
  pure ()"
HumanEval_105,mos_Latn,hs,"--Wala makre: --""Yɛl a yembr"", ""a yiib"", ""a tãab"", ""a naas"", ""a nu"", ""a yoob"", ""a yopoe"", ""a nii"", ""a wɛ"". --n lebg n wa n gʋls sõor ning sẽn wa ne wã, la d ledg sõor fãa ne a yʋʋr sẽn zems ne --☐ D sã n kõ-y sõor sẽn yaa zãng sõor sõor sõor sẽn yaa 1 n tãag 9 sẽn kẽed fãa, ☐--  >>> byLength [2,1,1,4,5,8,2,3]
--  [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""]
--  If the list is empty, return an empty list:
--  >>> byLength []
--  []
--  If the list has any strange number ignore it:
--  >>> byLength [1,(-1),55]
--  [""One""]
byLength :: [Int] -> [String]
byLength arr =","byLength :: [Int] -> [String]
byLength arr = map digitName . reverse . sort . filter isValid $ arr
  where
    isValid x = x >= 1 && x <= 9
    digitName x = case x of
      1 -> ""One""
      2 -> ""Two""
      3 -> ""Three""
      4 -> ""Four""
      5 -> ""Five""
      6 -> ""Six""
      7 -> ""Seven""
      8 -> ""Eight""
      9 -> ""Nine""
      _ -> error ""Unexpected number""","
main :: IO ()
main = do
  let candidate = byLength
  if candidate [2,1,1,4,5,8,2,3] == [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-1),55] == [""One""] then pure () else error ""assertion failed""
  if candidate [1,(-1),3,2] == [""Three"",""Two"",""One""] then pure () else error ""assertion failed""
  if candidate [9,4,8] == [""Nine"",""Eight"",""Four""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_106,mos_Latn,hs,"--Makre: --i koees-rãmbã yaa sõor nins sẽn yit 1 n tɩ ta i wã koees-rãmb (1 * 2 * ... * i).--i sɩngda ne 1. --Wala makre, sõor a 1 n tɩ ta i wã sõor fãa.--la a lebg n wa ne sõor sẽn yaa n, tɩ elemẽ wã sẽn be indeks i wã makrã yaa i wã faktoriyelã, sã n yaa tɩ i yaa paalle --D rɩk f sẽn yaa n n yɩt wa paramɛt, n--  >>> f 5
--  [1,2,6,24,15]
f :: Int -> [Int]
f n =","f :: Int -> [Int]
f n = map g [1..n]
  where
    g i
      | even i    = factorial i
      | otherwise = sum [1..i]
    
    factorial 0 = 1
    factorial m = product [1..m]","
main :: IO ()
main = do
  let candidate = f
  if candidate 5 == [1,2,6,24,15] then pure () else error ""assertion failed""
  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  if candidate 3 == [1,2,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_107,mos_Latn,hs,"--Makr a 1: --Sõor a yiib-n-soab sẽn yaa wa palindrom sẽn be ãnduni wã pʋgẽ.--☐ D sã n kõ sõor sẽn yaa sõma n kõ-y-yã, lebg n wa ne sõor sẽn yaa sõma n pa sõma.--  >>> evenOddPalindrome 3
--  (1, 2)
--  Explanation:
--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
--  Example 2:
--  >>> evenOddPalindrome 12
--  (4, 6)
--  Explanation:
--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
--  Note:
--  1. 1 <= n <= 10^3
--  2. returned tuple has the number of even and odd integer palindromes respectively.
evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n =","evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n = (length evens, length odds)
  where
    isPalindrome x = show x == reverse (show x)
    palindromes = filter isPalindrome [1..n]
    evens = filter even palindromes
    odds  = filter odd palindromes","
main :: IO ()
main = do
  let candidate = evenOddPalindrome
  if candidate 123 == (8, 13) then pure () else error ""assertion failed""
  if candidate 12 == (4, 6) then pure () else error ""assertion failed""
  if candidate 3 == (1, 2) then pure () else error ""assertion failed""
  if candidate 63 == (6, 8) then pure () else error ""assertion failed""
  if candidate 25 == (5, 6) then pure () else error ""assertion failed""
  if candidate 19 == (4, 6) then pure () else error ""assertion failed""
  if candidate 9 == (4, 5) then pure () else error ""assertion failed""
  if candidate 1 == (0, 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_108,mos_Latn,hs,"--Wala makre, -123 tara nimero -1, 2 la 3.--Sã n yaa sõor sẽn pa sõma, a pipi sifrã sẽn tar bãndã na n yɩɩ wẽnga: --yaa sõor ning sẽn be elemẽ wã tɩ b sõor sõor sẽn yaa > 0. --Gʋls tʋʋm-noor sẽn boond tɩ count_nums sẽn dɩkd nimero rãmb sõor n lebg n watẽ.--  >>> countNums []
--  0
--  >>> countNums [(-1),11,(-11)]
--  1
--  >>> countNums [1,1,2]
--  3
countNums :: [Int] -> Int
countNums arr =","countNums :: [Int] -> Int
countNums arr = length $ filter ((> 0) . sumDigits) arr
  where
    sumDigits 0 = 0
    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)
                  in sum digits","
main :: IO ()
main = do
  let candidate = countNums
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),0] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error ""assertion failed""
  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error ""assertion failed""
  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error ""assertion failed""
  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_109,mos_Latn,hs,"--Wala makre: --Sebrã pʋgẽ, b wilgame tɩ b na n paama bũmb sẽn yaa toor fasɩ ne a taabã.--Sã n yaa tɩ listã yaa zaalem bɩ lebg n wa True. --n lebg n wa True, n lebg n wa False.--Sã n tõe n paama sõdg sẽn welg sõma wã ne tʋʋm ning sẽn be yĩngrã --Yaa sõor ning b sẽn sɩng n gʋlsd sõor-kãngã pʋgẽ wã, sẽn dat n yeel tɩ 0 soabã.--B na n kɩtame tɩ sõor ning sẽn pʋglã lebg --Zĩ-yerdg a ye rɩtgo rat n yeelame tɩ y na n toeema bũmb nins fãa sẽn be sõsgã pʋgẽ wã ne a ye.--Y tõe n maana rɩtg n tees n kẽng rɩtg naoor wʋsgo.--tʋʋm kãnga sẽn be sõsg ning sẽn pʋɩtã pʋgẽ: --yaa ne  sẽn na n maan tɩ b tõog n welg sõor sẽn pa na n boog n paase.--Y na n bao n bãnga y sã n tõe n paama y sẽn datã.--Tõnd tara sõor sẽn yaa 'arr' sẽn tar nimero rãmb n yaa arr[1], arr[2], ..., arr[N].--  >>> moveOneBall [3,4,5,1,2]
--  True
--  Explanation: By performin 2 right shift operations, non-decreasing order can
--  be achieved for the given list.
--  >>> moveOneBall [3,5,4,1,2]
--  False
--  Explanation:It is not possible to get non-decreasing order for the given
--  list by performing any number of right shift operations.
moveOneBall :: [Int] -> Bool
moveOneBall arr =","moveOneBall :: [Int] -> Bool
moveOneBall [] = True
moveOneBall arr = canBeSorted (arr ++ arr)
  where
    n = length arr
    canBeSorted xs = any isSorted (take n <$> tails xs)
    isSorted ys = and $ zipWith (<=) ys (tail ys)
    tails [] = []
    tails l@(_:xs) = l : tails xs","
main :: IO ()
main = do
  let candidate = moveOneBall
  if candidate [3,4,5,1,2] == True then pure () else error ""assertion failed""
  if candidate [3,5,10,1,2] == True then pure () else error ""assertion failed""
  if candidate [4,3,1,2] == False then pure () else error ""assertion failed""
  if candidate [3,5,4,1,2] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_110,mos_Latn,hs,"--Wala makre: --Sã n pa woto bɩ y lebs n gʋls tɩ ""AO"".--Y sã n dat tɩ lst1 wã fãa yɩ pa-yemsã, lebg n wa ne ""YƐƐ"".--Sã n tõe n tek n tek bũmb nins sẽn be lst1 la lst2 wã n maan --B pa mi bũmb ning sẽn kɩt tɩ b tõe n tek n dɩk n dɩk n maan yel-gɛtb nins sẽn be lst1 la lst2 wã ye.--B sẽn maan to-to n na n kɩt tɩ sõor ning b sẽn gʋls tɩ ""lst1"" wã yɩ sõor sẽn yaa pa-kẽengã balã.--la a bãngd sã n tõe n maana bũmb a taab n tek ne taaba --Yel kãnga pʋgẽ, y na n maana tʋʋm sẽn na n dɩk sõor sõor a yiib n kõ-yã,--  >>> exchange [1,2,3,4] [1,2,3,4]
--  ""YES""
--  >>> exchange [1,2,3,4] [1,5,3,4]
--  ""NO""
--  It is assumed that the input lists will be non-empty.
exchange :: [Int] -> [Int] -> String
exchange lst1 lst2 =","exchange :: [Int] -> [Int] -> String
exchange lst1 lst2
  | all even lst1 = ""YES""
  | null oddLst1 || null evenLst2 = ""NO""
  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)
                in if possibility then ""YES"" else ""NO""
  where
    oddLst1 = filter odd lst1
    evenLst2 = filter even lst2","
main :: IO ()
main = do
  let candidate = exchange
  if candidate [1,2,3,4] [1,2,3,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [1,5,3,4] == ""NO"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [2,1,4,3] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,3] == ""NO"" then pure () else error ""assertion failed""
  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == ""NO"" then pure () else error ""assertion failed""
  if candidate [100,200] [200,200] == ""YES"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_111,mos_Latn,hs,"--Makre: --Y sã n yãt seb-biis wʋsg sẽn gomd bũmb a ye, bɩ y lebs-b fãa. --Yaa lɛtr ning b sẽn lebg n gʋls n yɩɩd la b sõd-a n yɩɩda.--☐ D sã n kõ-y sõor sẽn makd lɛt-rãmb sẽn welg ne zĩ-zãrsã, lebg n wa ne lagem-n-taar sõor ☐ D sã n kõ-y sõor sẽn makd lɛt-rãmb sẽn welg ne zĩ-zãrsã, lebg n wa ne lagem-n-taar sõor ☐--  >>> histogram ""a b c""
--  [(""a"", 1), (""b"", 1), (""c"", 1)]
--  >>> histogram ""a b b a""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""a b c a b""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""b b b b a""
--  [(""b"", 4)]
--  >>> histogram """"
--  []
histogram :: String -> [(String, Int)]
histogram test =","import Data.List (group, sort)
import Data.Ord (comparing)

histogram :: String -> [(String, Int)]
histogram input =
  let wordsList = words input
      grouped = group $ sort wordsList
      countList = map (\ws -> (head ws, length ws)) grouped
      maxCount = if null countList then 0 else maximum $ map snd countList
  in filter ((== maxCount) . snd) countList","
main :: IO ()
main = do
  let candidate = histogram
  if candidate ""a b b a"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c a b"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c d g"" == [(""a"", 1), (""b"", 1), (""c"", 1), (""d"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""b b b b a"" == [(""b"", 4)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""a"" == [(""a"", 1)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_112,mos_Latn,hs,"--Makre --Y segd n lebg n waa ne tuple sẽn tar sẽn wat ne wã la True/False n na n gesã.--B boondame tɩ palindrôme sã n yaa wa sẽn be taoor la poorẽ wã bala.--Rẽ poor bɩ y ges sã n yaa tɩ b sẽn gʋls n lebg n wa wã yaa palindrome. --B kõ-d-la sõn-vãoog a yiib sẽn boond tɩ s la c, tɩ d segd n yiis a fãa sẽn yaa wa a sẽn be a pʋgẽ wã.--Tʋʋmd sẽn yaa tɩlae.--  >>> reverseDelete ""abcde"" ""ae""
--  (""bcd"", False)
--  >>> reverseDelete ""abcdef"" ""b""
--  (""acdef"", False)
--  >>> reverseDelete ""abcdedcba"" ""ab""
--  (""cdedc"", True)
reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =","import Data.List (filter)

reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =
  let result = filter (`notElem` c) s
  in (result, result == reverse result)","
main :: IO ()
main = do
  let candidate = reverseDelete
  if candidate ""abcde"" ""ae"" == (""bcd"", False) then pure () else error ""assertion failed""
  if candidate ""abcdef"" ""b"" == (""acdef"", False) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""ab"" == (""cdedc"", True) then pure () else error ""assertion failed""
  if candidate ""dwik"" ""w"" == (""dik"", False) then pure () else error ""assertion failed""
  if candidate ""a"" ""a"" == ("""", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" """" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""v"" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""vabba"" ""v"" == (""abba"", True) then pure () else error ""assertion failed""
  if candidate ""mamma"" ""mia"" == ("""", True) then pure () else error ""assertion failed""
  pure ()"
HumanEval_113,mos_Latn,hs,"--Yaa sẽn na n yɩlẽ tɩ b bãng b sẽn tõe n maan to-to n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam--"" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""--Yɩl n bãng tɩ b sã n wa yãk bũmb fãa, a segd n yɩɩ ""tʋʋm-te-paalsã sõor sẽn yaa a yembr ne b sẽn yãkd bũmb ning fãa wã"".--☐ A string list, where each string consists of only digits, return a list. ☐ A string list, where each string consists of only digits, return a list.--  >>> oddCount [""1234567""]
--  [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
--  >>> oddCount [""3"",""11111111""]
--  [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""]
oddCount :: [String] -> [String]
oddCount lst =","oddCount :: [String] -> [String]
oddCount lst = map formatString lst
  where
    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""

    countOdds :: String -> Int
    countOdds str = length $ filter isOddDigit str

    formatString :: String -> String
    formatString str =
      let oddCount = countOdds str in
      ""the number of odd elements "" ++ show oddCount ++ 
      ""n the str"" ++ show oddCount ++ ""ng "" ++ show oddCount ++
      "" of the "" ++ show oddCount ++ ""nput.""","
main :: IO ()
main = do
  let candidate = oddCount
  if candidate [""1234567""] == [""the number of odd elements 4n the str4ng 4 of the 4nput.""] then pure () else error ""assertion failed""
  if candidate [""3"",""11111111""] == [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""] then pure () else error ""assertion failed""
  if candidate [""271"",""137"",""314""] == [""the number of odd elements 2n the str2ng 2 of the 2nput."",""the number of odd elements 3n the str3ng 3 of the 3nput."",""the number of odd elements 2n the str2ng 2 of the 2nput.""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_114,mos_Latn,hs,"--Makre --Yaa sõor wʋsgo.--D sã n kõ-y sõor sẽn yaa zãngã, bɩ y bao sõor ning sẽn yaa bilf n yɩɩd sõor nins sẽn pa zãngã fãa.--  >>> minsubarraysum [2,3,4,1,2,4]
--  1
--  >>> minsubarraysum [(-1),(-2),(-3)]
--  (-6)
minsubarraysum :: [Int] -> Int
minsubarraysum nums =","minsubarraysum :: [Int] -> Int
minsubarraysum nums = minimum $ scanl1 (\acc x -> min x (acc + x)) nums","
main :: IO ()
main = do
  let candidate = minsubarraysum
  if candidate [2,3,4,1,2,4] == 1 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error ""assertion failed""
  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error ""assertion failed""
  if candidate [0,10,20,1000000] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [10,11,13,8,3,4] == 3 then pure () else error ""assertion failed""
  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error ""assertion failed""
  if candidate [(-10)] == (-10) then pure () else error ""assertion failed""
  if candidate [7] == 7 then pure () else error ""assertion failed""
  if candidate [1,(-1)] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_115,mos_Latn,hs,"--Makr a 1: --Wilg-y y sẽn segd n sik ko-bĩn-dãmbã naoor a wãn to.--Yãmb tʋʋmda yaa y rɩk ko-bĩnd n kʋɩl bulsa.--la ko-bĩn fãa tara pãng a yembr bala.--B sẽn boond tɩ ""ko-bĩng"" wã yaa ko-bĩng sẽn tõe n dɩk koom n yiis ko-bĩng fãa pʋgẽ.--la 1 fãa sẽn be be wã makda koom ye. --A kõ-y-la bĩis-rãmb sẽn yaa wa rʋʋnd-rʋʋnd sẽn tar bĩis-rãmb n be be.--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1
--  6
--  Example 2:
--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2
--  5
--  Example 3:
--  >>> maxFill [[0,0,0],[0,0,0]] 5
--  0
--  Constraints:
--  * all wells have the same length
--  * 1 <= grid.length <= 10^2
--  * 1 <= grid[:,1].length <= 10^2
--  * grid[i][j] -> 0 | 1
--  * 1 <= capacity <= 10
maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity =","maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity = ceiling (fromIntegral totalWater / fromIntegral capacity)
  where
    totalWater = sum (map sum grid)","
main :: IO ()
main = do
  let candidate = maxFill
  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error ""assertion failed""
  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error ""assertion failed""
  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_116,mos_Latn,hs,"--Yaa woto la b segd n maan-a: --Sã n yaa 1 wã sõor sẽn zem taaba, bɩ y welg n tik desimallã zugu.--B sẽn gʋlsd b toorã pʋgẽ, b sõorã yaa sõor sẽn yikd n dabda.--◯ Kata wã pʋgẽ, y segd n welga sõor sẽn pa-a wẽnemd sõor sẽn zems ne ◯ wã.--  >>> sortArray [1,5,2,3,4]
--  [1,2,3,4,5]
--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]
--  [(-6),(-5),(-4),(-3),(-2)]
--  >>> sortArray [1,0,2,3,4]
--  [0,1,2,3,4]
sortArray :: [Int] -> [Int]
sortArray arr =","import Data.Bits (popCount)
import Data.List (sortBy)

sortArray :: [Int] -> [Int]
sortArray arr = sortBy compareOnesAndValues arr
  where
    compareOnesAndValues x y =
      let onesX = popCount x
          onesY = popCount y
      in if onesX == onesY
         then compare x y
         else compare onesX onesY","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error ""assertion failed""
  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error ""assertion failed""
  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error ""assertion failed""
  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  pure ()"
HumanEval_117,mos_Latn,hs,"--Makre: --Sebre: y tõe n tagsame tɩ b sẽn gʋlsd-a wã yaa lɛtɛɛr dãmb la zĩ-zãrs bala.--Sã n yaa tɩ s yaa zaalem, tʋʋm-kãng segd n lebg n waa ne sõor sẽn pa zaalem. --n gom-biis sẽn yaa wa taab n be sõss nins sẽn be sõssã pʋgẽ wã.--a tʋʋm-noor sẽn lebg n wa ne gom-biis nins fãa sẽn yit s-yẽgẽ wã sẽn tar  sẽn zems zãng n be be wã.--☐ y sã n kõ-y sõor sẽn yaa s la n, y na n maana ☐ y sã n kõ-y sõor sẽn yaa s la n, y na n maana ☐ y sã n kõ-y sõor sẽn yaa n, y na n maana ☐ y sã n kõ-y sõor sẽn yaa n--  >>> selectWords ""Mary had a little lamb"" 4
--  [""little""]
--  >>> selectWords ""Mary had a little lamb"" 3
--  [""Mary"",""lamb""]
--  >>> selectWords ""simple white space"" 2
--  []
--  >>> selectWords ""Hello world"" 4
--  [""world""]
--  >>> selectWords ""Uncle sam"" 3
--  [""Uncle""]
selectWords :: String -> Int -> [String]
selectWords s n =","selectWords :: String -> Int -> [String]
selectWords s n = filter (\word -> countConsonants word == n) (words s)
  where
    countConsonants = length . filter (`elem` consonants)
    consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ""","
main :: IO ()
main = do
  let candidate = selectWords
  if candidate ""Mary had a little lamb"" 4 == [""little""] then pure () else error ""assertion failed""
  if candidate ""Mary had a little lamb"" 3 == [""Mary"",""lamb""] then pure () else error ""assertion failed""
  if candidate ""simple white space"" 2 == [] then pure () else error ""assertion failed""
  if candidate ""Hello world"" 4 == [""world""] then pure () else error ""assertion failed""
  if candidate ""Uncle sam"" 3 == [""Uncle""] then pure () else error ""assertion failed""
  if candidate """" 4 == [] then pure () else error ""assertion failed""
  if candidate ""a b c d e f"" 1 == [""b"",""c"",""d"",""f""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_118,mos_Latn,hs,"--Makre: --Y tõe n tagsame tɩ sõor ning b sẽn kõ wã tara ãngilind lɛtɛɛr bal bala.--Bao-y tɩ gom-biis nins sẽn be yĩngrã pids-yã.--B pa na n geelg gom-biis nins sẽn sɩng la b sẽn baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng la b baas ne gom-biis nins sẽn pa sɩng ye.--B sã n gʋlsd gomdã n sɩng ne a rɩtgo, b gʋlsda gomdã ne gom-biis a yiib sẽn be rɩtgã (sẽn zems ne b sẽn gʋlsd-a to-to wã).--B kõ-y-la gomde. Y tʋʋmda yaa yãag vokaal ning sẽn pẽ-a n yɩɩd sẽn be ẽ-rɩtgẽ wã.--  >>> getClosestVowel ""yogurt""
--  ""u""
--  >>> getClosestVowel ""FULL""
--  ""U""
--  >>> getClosestVowel ""quick""
--  """"
--  >>> getClosestVowel ""ab""
--  """"
getClosestVowel :: String -> String
getClosestVowel word =","getClosestVowel :: String -> String
getClosestVowel word = go (reverse word) False
  where
    vowels = ""aeiouAEIOU""
    go [] _ = """"
    go (x:xs) lastWasConsonant
      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False
      | x `notElem` vowels = go xs True
      | otherwise = go xs False","
main :: IO ()
main = do
  let candidate = getClosestVowel
  if candidate ""yogurt"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""full"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""easy"" == """" then pure () else error ""assertion failed""
  if candidate ""eAsy"" == """" then pure () else error ""assertion failed""
  if candidate ""ali"" == """" then pure () else error ""assertion failed""
  if candidate ""bad"" == ""a"" then pure () else error ""assertion failed""
  if candidate ""most"" == ""o"" then pure () else error ""assertion failed""
  if candidate ""ab"" == """" then pure () else error ""assertion failed""
  if candidate ""ba"" == """" then pure () else error ""assertion failed""
  if candidate ""quick"" == """" then pure () else error ""assertion failed""
  if candidate ""anime"" == ""i"" then pure () else error ""assertion failed""
  if candidate ""Asia"" == """" then pure () else error ""assertion failed""
  if candidate ""Above"" == ""o"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_119,mos_Latn,hs,"--Makre: --D sã n tõe n maan sõn-vãoog sẽn yaa sõma, d segd n lebg n togsa 'N-yẽe' bala.--"" (()) "" pa woto ye. --Wala makre: "" ' (_) ' yaa sõma, tɩ "" ' (_) ' yaa sõma, tɩ "" ' (_) ' yaa sõma, tɩ "" ' (_) ' yaa sõma, tɩ "" ' (_) ' yaa sõma, tɩ "" ' (_) yaa sõma.--B getame tɩ sõor sẽn yaa sõma yaa sã n yaa tɩ sõor ning sẽn be S pʋgẽ wã fãa yaa sõma --B sã n wa na n yãk yam n maan bũmb a to, b na n wa paama sõor sẽn zemsã.--Yãmb tʋʋmd yaa y ges sã n tõe n kɩtame tɩ b rɩk b yiibã n kẽ ne taaba.--yaa "" (("" bɩ "" "") bal la b be.--B kõ-y-la sõor sẽn tar koees sẽn yaa vɛrse-rãmb a yiib sẽn tar vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb sẽn yaa vɛrse-rãmb--  >>> matchParens [""()("","")""]
--  ""Yes""
--  >>> matchParens ["")"","")""]
--  ""No""
matchParens :: [String] -> String
matchParens lst =","matchParens :: [String] -> String
matchParens [a, b] =
    if isValid (a ++ b) || isValid (b ++ a) then ""Yes"" else ""No""
  where
    isValid :: String -> Bool
    isValid = go 0
      where
        go 0 [] = True
        go _ [] = False
        go n (x:xs)
            | x == '('  = go (n + 1) xs
            | x == ')'  = n > 0 && go (n - 1) xs
    isValid _ = False","
main :: IO ()
main = do
  let candidate = matchParens
  if candidate [""()("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"","")""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()(())"",""())())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")())"",""(()()(""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(())))"",""(()())((""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""()"",""())""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()("",""()))()""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(((("",""((())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")(()"",""(()(""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")("","")(""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"",""(""] == ""Yes"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_120,mos_Latn,hs,"--Makr a 1: --yaa k la sẽn yɩɩd k sõor sẽn yaa arr. --☐ D sã n kõ sõor sẽn yaa sõma n yaa sõor sẽn yaa sõma n yaa k, d na n lebg n kõ sõor sẽn yaa sõma n yaa sõma n yaa sõma.--  >>> maximum [(-3),(-4),5] 3
--  [(-4),(-3),5]
--  Example 2:
--  >>> maximum [4,(-4),4] 2
--  [4,4]
--  Example 3:
--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1
--  [2]
--  Note:
--  1. The length of the list will be in the range of [1, 1000].
--  2. The elements in the list will be in the range of [-1000, 1000].
--  3. 0 <= k <= len(arr)
maximum :: [Int] -> Int -> [Int]
maximum arr k =","maximum :: [Int] -> Int -> [Int]
maximum arr k = take k $ reverse $ sort arr","
main :: IO ()
main = do
  let candidate = maximum
  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error ""assertion failed""
  if candidate [4,(-4),4] 2 == [4,4] then pure () else error ""assertion failed""
  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error ""assertion failed""
  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error ""assertion failed""
  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error ""assertion failed""
  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error ""assertion failed""
  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error ""assertion failed""
  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error ""assertion failed""
  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error ""assertion failed""
  if candidate [(-10),10] 2 == [(-10),10] then pure () else error ""assertion failed""
  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_121,mos_Latn,hs,"--Makre --☐ D sã n kõ sõor sẽn pa zaalem, d na n leoka bũmb nins fãa sẽn yaa zall n be zall zĩ-yendã.--  >>> solution [5,8,7,1]
--  12
--  >>> solution [3,3,3,3,3]
--  9
--  >>> solution [30,13,24,321]
--  0
solution :: [Int] -> Int
solution lst =","solution :: [Int] -> Int
solution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","
main :: IO ()
main = do
  let candidate = solution
  if candidate [5,8,7,1] == 12 then pure () else error ""assertion failed""
  if candidate [3,3,3,3,3] == 9 then pure () else error ""assertion failed""
  if candidate [30,13,24,321] == 0 then pure () else error ""assertion failed""
  if candidate [5,9] == 5 then pure () else error ""assertion failed""
  if candidate [2,4,8] == 0 then pure () else error ""assertion failed""
  if candidate [30,13,23,32] == 23 then pure () else error ""assertion failed""
  if candidate [3,13,2,9] == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_122,mos_Latn,hs,"--Makre: --yaa sẽn zems ne a yiib n yɩɩd sẽn sɩng ne a yiib n soabã fãa sẽn yaa a yiib n soabã fãa sẽn sɩng ne a yiib n soabã fãa sẽn sɩng ne a yiib n soabã fãa.--D sã n kõ sõor sẽn pa zaalem sẽn yaa nimero rãmb sẽn yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma n yaa sõma.--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4
--  24
--  Constraints:
--  1. 1 <= len(arr) <= 100
--  2. 1 <= k <= len(arr)
addElements :: [Int] -> Int -> Int
addElements arr k =","addElements :: [Int] -> Int -> Int
addElements arr k = sum $ filter (\x -> x >= -99 && x <= 99) $ take k arr","
main :: IO ()
main = do
  let candidate = addElements
  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error ""assertion failed""
  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error ""assertion failed""
  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error ""assertion failed""
  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error ""assertion failed""
  if candidate [1] 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_123,mos_Latn,hs,"--get_odd_collatz(5) lebgda [1, 5] # Collatz rũmsa sẽn na n yɩll n paam 5 yaa [5, 16, 8, 4, 2, 1], woto wã, sõor nins sẽn pa yɩllã yaa 1 la 5 bal bala. --Wala makre: --2. b sẽn lebg n wa ne sõor sẽn welge, n paasdẽ. --1. Collatz ((1) yaa [1]. --Sebr a ye: --B sẽn yetã yaa tɩ baa n sã n yaa n to-to, a ket n yaa 1 wakat fãa.--Sã n yaa tɩ sẽn deng-a wã yaa pa yembr, sẽn pʋgd-a wã yaa sẽn deng-a wã naoor a 3.--Sẽn deng-a wã yaa woto: sã n yaa tɩ sẽn deng-a wã yaa pa-yembr bɩ pa-yembr, sẽn pʋgdã yaa pʋɩ-sʋk --yaa woto: sɩng ne nimero fãa sẽn yaa sõma n. Rẽ poore, b na n paama sull fãa ne --Collatz sẽn yetã yaa bãng-bãngr sẽn kẽed ne matematiksã sẽn tɩ loe ne yel-bũndã sẽn yaa to-to wã.--☐ D sã n kõ sõor sẽn yaa sõma n kõ sõor sẽn yaa toor-toore n kõ-d sõor sẽn yaa toor-toore.--  >>> getOddCollatz 5
--  [1,5]
getOddCollatz :: Int -> [Int]
getOddCollatz n =","getOddCollatz :: Int -> [Int]
getOddCollatz n = sort . filter odd $ collatzSequence n
  where
    collatzSequence 1 = [1]
    collatzSequence x
      | even x    = x : collatzSequence (x `div` 2)
      | otherwise = x : collatzSequence (3 * x + 1)","
main :: IO ()
main = do
  let candidate = getOddCollatz
  if candidate 14 == [1,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 5 == [1,5] then pure () else error ""assertion failed""
  if candidate 12 == [1,3,5] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_124,mos_Latn,hs,"--4. Sebrã segd n yɩɩ woto: mm-dd-yyyy --3. Kiisã pa segd n ta 1 bɩ n yɩɩd 12 ye.--Yaa tɩ b sã n na n maan b sẽn datã, b na n paama kibs sẽn na n yɩll tɩ b bãng b sẽn segd n maan bũmb ning yʋʋmd fãa.--1. Dati wã sõor pa zaalem ye.--Sebrã yaa sõma, sã n yaa tɩ noy nins sẽn pʋgdã fãa la b tũuda: --sã n pa woto, a lebgda True.--Y segd n gʋlsa tʋʋm-noor sẽn na n wilg tɩ daarã yaa sɩda, la --  >>> validDate ""03-11-2000""
--  True
--  >>> validDate ""15-01-2012""
--  False
--  >>> validDate ""04-0-2040""
--  False
--  >>> validDate ""06-04-2020""
--  True
--  >>> validDate ""06/04/2020""
--  False
validDate :: String -> Bool
validDate date =","import Text.Read (readMaybe)
import Data.List.Split (splitOn)

validDate :: String -> Bool
validDate date =
    case splitOn ""-"" date of
        [m, d, y] -> isValidMonthDayYear m d y
        _         -> False

isValidMonthDayYear :: String -> String -> String -> Bool
isValidMonthDayYear m d y =
    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of
        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day
        _ -> False

isValidMonth :: Int -> Bool
isValidMonth month = month >= 1 && month <= 12

isValidDay :: Int -> Int -> Bool
isValidDay month day
    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31
    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30
    | month == 2                           = day >= 1 && day <= 29
    | otherwise                            = False","
main :: IO ()
main = do
  let candidate = validDate
  if candidate ""03-11-2000"" == True then pure () else error ""assertion failed""
  if candidate ""15-01-2012"" == False then pure () else error ""assertion failed""
  if candidate ""04-0-2040"" == False then pure () else error ""assertion failed""
  if candidate ""06-04-2020"" == True then pure () else error ""assertion failed""
  if candidate ""01-01-2007"" == True then pure () else error ""assertion failed""
  if candidate ""03-32-2011"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""04-31-3000"" == False then pure () else error ""assertion failed""
  if candidate ""06-06-2005"" == True then pure () else error ""assertion failed""
  if candidate ""21-31-2000"" == False then pure () else error ""assertion failed""
  if candidate ""04-12-2003"" == True then pure () else error ""assertion failed""
  if candidate ""04122003"" == False then pure () else error ""assertion failed""
  if candidate ""20030412"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04-12"" == False then pure () else error ""assertion failed""
  if candidate ""04-2003"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_126,mos_Latn,hs,"--Makre --Sõor a ye, lebg n wa ne False.--Sã n yaa tɩ sõorã yaa toor n yɩɩd a yembr bala, --◯ Sõd-y sõor sõor sẽn be wã, n wilg b sẽn welge, bɩ b sẽn pa welge.--  >>> isSorted [5]
--  True
--  >>> isSorted [1,2,3,4,5]
--  True
--  >>> isSorted [1,3,2,4,5]
--  False
--  >>> isSorted [1,2,3,4,5,6]
--  True
--  >>> isSorted [1,2,3,4,5,6,7]
--  True
--  >>> isSorted [1,3,2,4,5,6,7]
--  False
--  >>> isSorted [1,2,2,3,3,4]
--  True
--  >>> isSorted [1,2,2,2,3,4]
--  False
isSorted :: [Int] -> Bool
isSorted lst =","isSorted :: [Int] -> Bool
isSorted lst = go lst Nothing
  where
    go [] _ = True
    go [x] _ = True
    go (x:y:xs) prev
      | x > y = False
      | x == y && prev == Just x = False
      | otherwise = go (y:xs) (Just x)","
main :: IO ()
main = do
  let candidate = isSorted
  if candidate [5] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,7] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  if candidate [1] == True then pure () else error ""assertion failed""
  if candidate [3,2,1] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,2,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,3,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,3,3,4] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_127,mos_Latn,hs,"--[Kõosg bɩ b sẽn yiisd-a] makrã: --Sã n pa be tɩ b yiibã kẽed taaba, lebg n wa ne ""AO"".--Sã n pa rẽ bɩ y lebs n gʋls ""AO"". --Sã n yaa sõor sẽn yaa pipi, lebg n wa ne ""YƐƐ"", --a woglem yaa 1. A pa pipi sõor ye.--Makre, sẽn kẽed ne seg-taabã (1, 3), (2, 4) yaa (2, 3) --A yaa pipi sõor sẽn yaa tɩlɛ.--Yãmb tʋʋmd yaa n bãng tɩ bãmb b yiibã sẽn kẽed taab to-to wã zulumsi yaa a wãn bala.--Sẽn na yɩl n bãng sẽn sɩng to-to, d segd n tẽega tɩ sẽn sɩng to-to wã yaa bilf n yɩɩd sẽn na n baas to-to wã bɩ n zemse.--A na n sɩnga ne a baasgo.--B sẽn kõ wã yaa b sẽn na n wa baas n yeel tɩ b sẽn na n sɩng la b baasã yaa:--sẽn be tɩ wakat fãa yaa sõor sẽn pa zʋʋg a ye. Wala makre, wakat = (sẽn sɩngda, sẽn baasda) = (1, 2).--B kõ-y-la wakat a yiib n na n zĩnd n gese.--  >>> intersection (1, 2) (2, 3)
--  ""NO""
--  >>> intersection ((-1), 1) (0, 4)
--  ""NO""
--  >>> intersection ((-3), (-1)) ((-5), 5)
--  ""YES""
intersection :: (Int, Int) -> (Int, Int) -> String
intersection interval1 interval2 =","intersection :: (Int, Int) -> (Int, Int) -> String
intersection (start1, end1) (start2, end2) = 
    if intersectionLength > 0 && isPrime intersectionLength
    then ""YES""
    else ""NO""
  where
    intersectionStart = max start1 start2
    intersectionEnd = min end1 end2
    intersectionLength = intersectionEnd - intersectionStart + 1
    
    isPrime :: Int -> Bool
    isPrime n
      | n <= 1 = False
      | n == 2 = True
      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","
main :: IO ()
main = do
  let candidate = intersection
  if candidate (1, 2) (2, 3) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-1), 1) (0, 4) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-3), (-1)) ((-5), 5) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-2), 2) ((-4), 0) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-11), 2) ((-1), (-1)) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (3, 5) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (1, 2) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-2), (-2)) ((-3), (-2)) == ""NO"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_128,mos_Latn,hs,"--Makre: --Note: return Nothing for empty arr.   yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa yaa--B sã n na n gʋls sõor fãa sẽn be sõor-kãngã pʋgẽ wã, b na n gʋls-a-la 1 bɩ 1 bɩ 0.--Yaa sõor sẽn yaa tɩlɛ tɩ f sõor fãa lebg n lebg n leb n n lebg n lebgã.--B kõ-y-la sõor sẽn yaa zãng n tog n lebg n wa.--  >>> prodSigns [1,2,2,(-4)]
--  Just (9)
--  >>> prodSigns [0,1]
--  Just (0)
--  >>> prodSigns []
--  Just (Nothing)
prodSigns :: [Int] -> Maybe Int
prodSigns arr =","prodSigns :: [Int] -> Maybe Int
prodSigns [] = Nothing
prodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","
main :: IO ()
main = do
  let candidate = prodSigns
  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error ""assertion failed""
  if candidate [0,1] == Just (0) then pure () else error ""assertion failed""
  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error ""assertion failed""
  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,0] == Just (0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_129,mos_Latn,hs,"--Makre: --D lebg n wa ne cell-dãmb nins sẽn be sor ning sẽn yaa bilf n yɩɩd n na n tũ wã.--B tõe n kɩsa sɩd tɩ b leokrã yaa toor fasɩ ne a taabã. --A = A b.--tɩ lst_A[i] < lst_B[i] la ne j fãa (1 <= j < i) d tara --yaa sẽn na n yɩlẽ n bãng tɩ b sã n dɩk n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n na n mak n mak n na n mak n mak n mak n na n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n mak n--(D bool-b lame tɩ lst_A la lst_B), lst_A yaa sõsg-yend sẽn yaa bil --B sã n wa gʋlsd b sẽn gʋlsd bũmb ning b zĩ-gũbrẽ wã, b na n yeelame tɩ A la B sẽn gʋlsã yaa --B getame tɩ sor A (a woglem k) yaa bilf n yɩɩd sor B (a woglem k) sã n yaa --Y YÃMB pa tõe n pa yã-b ye.--b pa segd n welg taab ye).--D bãng tɩ k k k k k k k k-yẽng n be sorã pʋgẽ wã rat n yeelame tɩ d kẽe k sel-rãmb bala (ka --cellã --yaa woto, y tõe n kẽnga sɛb nins sẽn tar noor ne yãmbã pʋsẽ.--Y tõe n yii sel buud fãa, la y tõe n kẽnga sel a to sẽn pẽ-a wã pʋgẽ, --Y segd n baoo sor ning sẽn yaa bilf n yɩɩd n tõe n yã n sɩng ne --yaa vugr bal la b yãend sẽn kẽed ne b sẽn na n maan bũmb ning fãa.--Sõng-y tɩ y bãng tɩ f sã n na n sõdga f sẽn dat n maan bũmb ningã, f na n sõdga a soabã.--√ D sã n kõ-a √ n sull la √ n sull (N >= 2) la √ k sẽn yaa sõor sẽn yaa sõma, √ k yaa sõor sẽn yaa sõma.--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3
--  [1,2,1]
--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1
--  [1]
minpath :: [[Int]] -> Int -> [Int]
minpath grid k =","import Data.List (sort, sortBy)
import Data.Ord (comparing)
import Control.Monad (guard)

minpath :: [[Int]] -> Int -> [Int]
minpath grid k = head $ sort paths
  where
    n = length grid
    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]
    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
      where
        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n
    value (r, c) = grid !! r !! c
    paths = do
      start <- cells
      findPaths k [start]
    findPaths 1 path = return $ map value path
    findPaths l path@(current:_) = do
      next <- neighbors current
      findPaths (l-1) (next : path)","
main :: IO ()
main = do
  let candidate = minpath
  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error ""assertion failed""
  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error ""assertion failed""
  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error ""assertion failed""
  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error ""assertion failed""
  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error ""assertion failed""
  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error ""assertion failed""
  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_130,mos_Latn,hs,"--Makre: --n + 1 pipi Tribonacci sõor pʋga. --B kõ-y-la nimero sẽn pa wẽnemd n n-yẽng n na n lebg n wa ne --= 2 + 3 + 3 = 8 --tri(3) = tri(2) + tri(1) + tri(4) --tri(4) = 3 --tri(2) = 1 + (2 / 2) = 2 --Wala makre: --tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), sã n yaa tɩ n yaa pa-yende. --tri (n) = 1 + n / 2, sã n yaa tɩ n yaa pa-yende. --tri(1) = 3 --A Tribonacci siglg yaa woto: --La bũmb ning nebã sẽn pa mi yaa Tribonacci siglgã.--Ned fãa mii Fibonacci rũmsa, a paama vaeesg wʋsg ne matematiks rãmba yʋʋmd 1900 wã.--  >>> tri 3
--  [1,3,2,8]
tri :: Int -> [Int]
tri n =","tri :: Int -> [Int]
tri n = map tribonacci [0..n]
  where
    -- Define the recursive function to calculate the tribonacci value for a given n
    tribonacci :: Int -> Int
    tribonacci 0 = 1
    tribonacci 1 = 3
    tribonacci x
      | even x    = 1 + x `div` 2
      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","
main :: IO ()
main = do
  let candidate = tri
  if candidate 3 == [1,3,2,8] then pure () else error ""assertion failed""
  if candidate 4 == [1,3,2,8,3] then pure () else error ""assertion failed""
  if candidate 5 == [1,3,2,8,3,15] then pure () else error ""assertion failed""
  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error ""assertion failed""
  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error ""assertion failed""
  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error ""assertion failed""
  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error ""assertion failed""
  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error ""assertion failed""
  if candidate 0 == [1] then pure () else error ""assertion failed""
  if candidate 1 == [1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_131,mos_Latn,hs,"--Wala makre: --D lebg n wa ne 0 sã n yaa tɩ sõor fãa yaa pa-yembr bala. --☐ D sã n kõ sõor sẽn yaa sõma n, d na n lebg n togsa sõor sẽn yaa toorã sẽn lebg to-to wã.--  >>> digits 1
--  1
--  >>> digits 4
--  0
--  >>> digits 235
--  15
digits :: Int -> Int
digits n =","digits :: Int -> Int
digits n
  | null oddDigits = 0
  | otherwise      = product oddDigits
  where
    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","
main :: IO ()
main = do
  let candidate = digits
  if candidate 5 == 5 then pure () else error ""assertion failed""
  if candidate 54 == 5 then pure () else error ""assertion failed""
  if candidate 120 == 1 then pure () else error ""assertion failed""
  if candidate 5014 == 5 then pure () else error ""assertion failed""
  if candidate 98765 == 315 then pure () else error ""assertion failed""
  if candidate 5576543 == 2625 then pure () else error ""assertion failed""
  if candidate 2468 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_132,mos_Latn,hs,"--sẽn na n yɩlẽ n paam tɩ b bãng b sẽn tõe n maan to-to n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam n paam--Fõn-kãng segd n lebg n waame tɩ yaa True sã n yaa tɩlɛ tɩ b tũ ne gãntig-n-bãngr sẽn yaa sõma -- Yãk fõntr sẽn na n dɩk n kõ-y sõor sẽn tar n be ne gãn-taase bala.--  >>> isNested ""[[]]""
--  True
--  >>> isNested ""[]]]]]]][[[[[]""
--  False
--  >>> isNested ""[][]""
--  False
--  >>> isNested ""[]""
--  False
--  >>> isNested ""[[][]]""
--  True
--  >>> isNested ""[[]][[""
--  True
isNested :: String -> Bool
isNested string =","isNested :: String -> Bool
isNested string = go string 0 False
  where
    go [] _ nested = nested
    go (x:xs) depth nested
      | x == '['  = go xs (depth + 1) (nested || depth >= 1)
      | x == ']' && depth > 0 = go xs (depth - 1) nested
      | otherwise = go xs depth nested","
main :: IO ()
main = do
  let candidate = isNested
  if candidate ""[[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]][[[[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[][]"" == False then pure () else error ""assertion failed""
  if candidate ""[]"" == False then pure () else error ""assertion failed""
  if candidate ""[[[[]]]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]]]]]"" == False then pure () else error ""assertion failed""
  if candidate ""[][][[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[]]"" == False then pure () else error ""assertion failed""
  if candidate ""[[]][["" == True then pure () else error ""assertion failed""
  if candidate ""[[][]]"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""[[[[[[[["" == False then pure () else error ""assertion failed""
  if candidate ""]]]]]]]]"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_133,mos_Latn,hs,"--Makre: --Sẽn deng fãa, y na n deng n kẽnga ne bũmb ning sẽn be sõsgã pʋgẽ wã n tɩ ta a sẽn be yĩngrã.--Y segd n lebg n togsa sõor nins b sẽn kõ sõor sõor sõor sõorã pʋgẽ wã sẽn lebg koabg zugã sõore, --B kõ-y-la sõor sõor sõor n gʋls n tool-y-yã.--  >>> lst [1.0,2.0,3.0]
--  14
--  >>> lst [1.0,4.0,9.0]
--  98
--  >>> lst [1.0,3.0,5.0,7.0]
--  84
--  >>> lst [1.4,4.2,0.0]
--  29
--  >>> lst [-2.4,1.0,1.0]
--  6
sumSquares :: [Float] -> Int
sumSquares lst =","import Data.List (foldl')
import Prelude hiding (sum)

sumSquares :: [Float] -> Int
sumSquares lst = foldl' (\acc x -> acc + ceiling x ^ 2) 0 lst","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error ""assertion failed""
  if candidate [1.4,4.2,0.0] == 29 then pure () else error ""assertion failed""
  if candidate [-2.4,1.0,1.0] == 6 then pure () else error ""assertion failed""
  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error ""assertion failed""
  if candidate [10000.0,10000.0] == 200000000 then pure () else error ""assertion failed""
  if candidate [-1.4,4.6,6.3] == 75 then pure () else error ""assertion failed""
  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error ""assertion failed""
  if candidate [0.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0] == 1 then pure () else error ""assertion failed""
  if candidate [-1.0,1.0,0.0] == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_134,mos_Latn,hs,"--Makre: --Sebr ning sẽn yaa ""word"" wã yaa seb-biis sull b sẽn welg ne zĩiga.--Yaa gom-bilã babg la a to wã yaa ziri.--yaa alphabẽ wã sebre la pa --Na n wa ne tʋʋm-noor sẽn na n lebg tɩ True sã n yaa tɩlɛ tɩ ẽtɛg-n-soabã --  >>> checkIfLastCharIsALetter ""apple pie""
--  False
--  >>> checkIfLastCharIsALetter ""apple pi e""
--  True
--  >>> checkIfLastCharIsALetter ""apple pi e ""
--  False
--  >>> checkIfLastCharIsALetter """"
--  False
checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt =","checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt = 
    let trimmed = reverse . dropWhile (== ' ') $ reverse txt
    in case trimmed of
        [] -> False
        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","
main :: IO ()
main = do
  let candidate = checkIfLastCharIsALetter
  if candidate ""apple"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e"" == True then pure () else error ""assertion failed""
  if candidate ""eeeee"" == False then pure () else error ""assertion failed""
  if candidate ""A"" == True then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie "" == False then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie 1"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""eeeee e "" == False then pure () else error ""assertion failed""
  if candidate ""apple pie"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e "" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_135,mos_Latn,hs,"--Makre: --B sẽn tõe n maan to-to n paam n maan woto wã--sã n pa be yel-bũndã, lebg n wa ne -1. Sõdg ning sẽn kõ wã pa na n tall --pa yɩɩd bɩ pa zem bũmb ning sẽn deng-a wã ye.--D na n maana tʋʋm-noor sẽn na n lebg n wa ne elemẽ wã sẽn yaa kãseng n yɩɩdã --  >>> canArrange [1,2,4,3,5]
--  3
--  >>> canArrange [1,2,3]
--  (-1)
canArrange :: [Int] -> Int
canArrange arr =","canArrange :: [Int] -> Int
canArrange arr = go arr (-1) 0
  where
    go [] maxIdx _ = maxIdx
    go [_] maxIdx _ = maxIdx
    go (x:y:xs) maxIdx idx
      | x >= y    = go (y:xs) idx (idx + 1)
      | otherwise = go (y:xs) maxIdx (idx + 1)","
main :: IO ()
main = do
  let candidate = canArrange
  if candidate [1,2,4,3,5] == 3 then pure () else error ""assertion failed""
  if candidate [1,2,4,5] == (-1) then pure () else error ""assertion failed""
  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error ""assertion failed""
  if candidate [4,8,5,7,3] == 4 then pure () else error ""assertion failed""
  if candidate [] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_136,mos_Latn,hs,"--Makre: --Sã n pa be nimero sẽn pa sõma bɩ nimero sẽn yaa sõma, lebg-y-b tɩ bũmb ye.--Yaa sõor sẽn yaa sõma n yɩɩd sõor sẽn yaa sõma fãa.--Yaa sẽn yaa-a kãseng n yɩɩd ne nimero-rãmb nins sẽn yaa wẽnsã sʋka, la b yaa sẽn yaa-a bilf n yɩɩda --D na n maana fɩkson sẽn na n lebg n wa ne tuple (a, b), tɩ 'a' yaa --  >>> largestSmallestIntegers [2,4,1,3,5,7]
--  (Nothing, 1)
--  >>> largestSmallestIntegers []
--  (Nothing, Nothing)
--  >>> largestSmallestIntegers [0]
--  (Nothing, Nothing)
largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst =","largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst = (largestNegative, smallestPositive)
  where
    negatives = filter (< 0) lst
    positives = filter (> 0) lst
    largestNegative = if null negatives then Nothing else Just (maximum negatives)
    smallestPositive = if null positives then Nothing else Just (minimum positives)","
main :: IO ()
main = do
  let candidate = largestSmallestIntegers
  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error ""assertion failed""
  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error ""assertion failed""
  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error ""assertion failed""
  if candidate [] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [0] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_138,mos_Latn,hs,"--Makre --☐ Ges-y sã n tõe n gʋlsa sõor ning sẽn yaa n-rɩk n yaa sõor sẽn yaa n-rɩk n yaa a 4 sẽn yaa sõma n yaa pa-kẽema.--  >>> isEqualToSumEven 4
--  False
--  >>> isEqualToSumEven 6
--  False
--  >>> isEqualToSumEven 8
--  True
isEqualToSumEven :: Int -> Bool
isEqualToSumEven n =","isEqualToSumEven :: Int -> Bool
isEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","
main :: IO ()
main = do
  let candidate = isEqualToSumEven
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == True then pure () else error ""assertion failed""
  if candidate 11 == False then pure () else error ""assertion failed""
  if candidate 12 == True then pure () else error ""assertion failed""
  if candidate 13 == False then pure () else error ""assertion failed""
  if candidate 16 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_139,mos_Latn,hs,"--Wala makre: --n > 0 --brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! --B sẽn boond tɩ ""factoire brésilien"" yaa woto:--  >>> specialFactorial 4
--  288
--  The function will receive an integer as input and should return the special
--  factorial of this integer.
specialFactorial :: Int -> Int
specialFactorial n =","specialFactorial :: Int -> Int
specialFactorial n = product [factorial x | x <- [1..n]]
  where
    factorial 0 = 1
    factorial k = k * factorial (k - 1)","
main :: IO ()
main = do
  let candidate = specialFactorial
  if candidate 4 == 288 then pure () else error ""assertion failed""
  if candidate 5 == 34560 then pure () else error ""assertion failed""
  if candidate 7 == 125411328000 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_140,mos_Latn,hs,"--Rẽ poor bɩ y lebs n ning zĩ-zãrs nins fãa sẽn pʋgl taabã ne - --la sã n yaa tɩ sõor sẽn yɩɩd zĩ-yend a yiib n pʋgd taaba, --❑ Y sã n kõ-y sõssã sõor sẽn yaa sõor-koɛɛga, y na n ledga zĩ-zãrsã fãa ne vɛrse-rãmb sẽn be tẽngre, ❑ Y sã n kõ-y sõor-koɛɛga, y na n ledga vɛrse-rãmb nins sẽn be tẽngre wã ne vɛrse-rãmb sẽn be tẽngre.--  >>> fixSpaces "" Example""
--  ""Example""
--  >>> fixSpaces "" Example 1""
--  ""Example_1""
--  >>> fixSpaces "" Example 2""
--  ""_Example_2""
--  >>> fixSpaces "" Example 3""
--  ""_Example-3""
fixSpaces :: String -> String
fixSpaces text =","fixSpaces :: String -> String
fixSpaces text = concatMap replaceSpaces (groupSpaces text)
  where
    groupSpaces :: String -> [String]
    groupSpaces [] = []
    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest

    replaceSpaces :: String -> String
    replaceSpaces spaces@(x:_)
      | x == ' ' && length spaces > 2 = ""-""
      | x == ' ' = replicate (length spaces) '_'
      | otherwise = spaces","
main :: IO ()
main = do
  let candidate = fixSpaces
  if candidate ""Example"" == ""Example"" then pure () else error ""assertion failed""
  if candidate ""Mudasir Hanif "" == ""Mudasir_Hanif_"" then pure () else error ""assertion failed""
  if candidate ""Yellow Yellow  Dirty  Fellow"" == ""Yellow_Yellow__Dirty__Fellow"" then pure () else error ""assertion failed""
  if candidate ""Exa   mple"" == ""Exa-mple"" then pure () else error ""assertion failed""
  if candidate ""   Exa 1 2 2 mple"" == ""-Exa_1_2_2_mple"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_141,mos_Latn,hs,"--Makre: --- B sẽn na n gʋls-a to-to wã segd n yɩɩ woto: ['txt', 'exe', 'dll'] --b sẽn gʋls ne latinã ('a'-'z' la 'A'-'Z'). --- Bãng-y tɩ b sã n gʋls tɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ  bɩ --- Fãllã yʋʋr tara zĩ-yend bala.--- A ka segd n tall sõor sẽn yɩɩd nimero a tãab ye ('0' - '9') file wã yʋʋr pʋgẽ ye. --b sẽn pidsd: --B geta file yʋʋr t'a yaa sõma, sã n yaa tɩ bũmb nins fãa sẽn pʋgdã zemsa ne-a --'Yes' sã n yaa tɩlɛ tɩ fÃ£a wã yʋʋr yɩ sõma, la sã n pa woto, a lebgda 'Nii' ye. --◯ B na n maana tʋʋm-noor sẽn na n dɩk n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall n tall--  >>> fileNameCheck ""example.txt""
--  ""Yes""
--  >>> fileNameCheck ""1example.dll""
--  ""No""
fileNameCheck :: String -> String
fileNameCheck file_name =","import Data.Char (isDigit, isLetter)

fileNameCheck :: String -> String
fileNameCheck file_name 
  | countDots /= 1 = ""No""
  | length digits > 3 = ""No""
  | null beforeDot || not (isLetter (head beforeDot)) = ""No""
  | afterDot `notElem` validExtensions = ""No""
  | otherwise = ""Yes""
  where 
    (beforeDot, afterDot) = span (/= '.') file_name
    countDots = length $ filter (== '.') file_name
    digits = filter isDigit file_name
    validExtensions = [""txt"", ""exe"", ""dll""]
    afterDot = if null dotAndAfter then """" else tail dotAndAfter
    dotAndAfter = dropWhile (/= '.') file_name","
main :: IO ()
main = do
  let candidate = fileNameCheck
  if candidate ""example.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1example.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s1sdf3.asd"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""K.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""MY16FILE3.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""His12FILE94.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_Y.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""?aREYA.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""/this_is_valid.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.wow"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txtexe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""#this2_i4s_5valid.ten"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""@this1_is6_valid.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_12valid.6exe4.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""all.exe.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_No.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""Is3youfault.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""no_one#knows.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1I563_Yes3.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_Yes3.txtt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final..txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final132"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_f4indsartal132."" == ""No"" then pure () else error ""assertion failed""
  if candidate "".txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s."" == ""No"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_142,mos_Latn,hs,"--Makre: --n toeemd sõor nins sẽn be sõor ning pʋgẽ tɩ b nimero wã pa 3 bɩ 4 naoor ye. Tʋʋmdã na n lebg n waa ne sõor nins fãa sẽn be sõorã pʋgẽ wã.--A sã n yaa 4 naoor wʋsgo, la a sã n pa 3 naoor wʋsgo, a na n wẽe nimero-rãmb nins sẽn be wã tɩ b lebg a yiib n paase.--Tʋʋm kãnga na n dɩka sõor sẽn yaa zãng sõor sõor sõor fãa pʋgẽ, tʋʋma na n tõoga sõor sẽn yaa zãng sõorã sã n yaa a --""--  >>> lst
--  [1,2,3]
--  >>> lst
--  []
--  >>> lst
--  [(-1),(-5),2,(-1),(-5)]
sumSquares :: [Int] -> Int
sumSquares lst =","sumSquares :: [Int] -> Int
sumSquares lst = sum $ zipWith transform [0..] lst
  where
    transform idx x
      | idx `mod` 3 == 0 = x * x
      | idx `mod` 4 == 0 = x * x * x
      | otherwise        = x","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1,2,3] == 6 then pure () else error ""assertion failed""
  if candidate [1,4,9] == 14 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error ""assertion failed""
  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error ""assertion failed""
  if candidate [0] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error ""assertion failed""
  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error ""assertion failed""
  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error ""assertion failed""
  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error ""assertion failed""
  pure ()"
HumanEval_143,mos_Latn,hs,"--Makr a 1: --Gom-biis nins sẽn be sõssã sẽn yaa to-to wã segd n yɩɩ wa pipi sõsgã.--sẽn tar sõor sẽn yaa sõor pipi wã, --la y segd n lebg n waa ne sõsg sẽn naag ne gom-bil ning b sẽn da gʋls pipi wã, --vɛrse wã tara gom-biis kẽer sẽn welg ne zĩ-zãrgre, --B kõ-y-la sõsg sẽn makd gom-bi-yendã.--  >>> wordsInSentence ""This is a test""
--  ""is""
--  Example 2:
--  >>> wordsInSentence ""lets go for swimming""
--  ""go for""
--  Constraints:
--  * 1 <= len(sentence) <= 100
--  * sentence contains only letters
wordsInSentence :: String -> String
wordsInSentence sentence =","import Data.List (intercalate)

wordsInSentence :: String -> String
wordsInSentence sentence = intercalate "" "" $ filter (isPrime . length) (words sentence)

isPrime :: Int -> Bool
isPrime n | n < 2     = False
          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = wordsInSentence
  if candidate ""This is a test"" == ""is"" then pure () else error ""assertion failed""
  if candidate ""lets go for swimming"" == ""go for"" then pure () else error ""assertion failed""
  if candidate ""there is no place available here"" == ""there is no place"" then pure () else error ""assertion failed""
  if candidate ""Hi I am Hussein"" == ""Hi am Hussein"" then pure () else error ""assertion failed""
  if candidate ""go for it"" == ""go for it"" then pure () else error ""assertion failed""
  if candidate ""here"" == """" then pure () else error ""assertion failed""
  if candidate ""here is"" == ""is"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_144,mos_Latn,hs,"--Y tõe n yeelame tɩ x, la n yaa wil-bɛɛg sẽn zems la b pa tar zéro wa b sẽn boond-a wã ye.--B sẽn boond tɩ ""numerator"" la ""denominator"" wã fãa yaa sõor sẽn yaa sõma.--Sã n pa rẽ, b yiibã fãa, x la n, yaa wilgr sẽn yaa wa b sẽn gʋls n wilg wilgr toɛy-toɛy n yaa to-to wã, la b tara seb-kãngã: --x * n. Tʋʋmdã lebgda True sã n yaa tɩ x * n yaa sõor sẽn yaa zãng la False --Y tʋʋmda yaa f sẽn na n maan tʋʋm-noor sẽn na n kɩt tɩ koe-kãngã yɩ nana.--  >>> simplify ""1/5"" ""5/1""
--  True
--  >>> simplify ""1/6"" ""2/1""
--  False
--  >>> simplify ""7/10"" ""10/2""
--  False
simplify :: String -> String -> Bool
simplify x n =","import Data.Ratio (denominator, numerator, (%))

simplify :: String -> String -> Bool
simplify x n =
  let (xNum, xDen) = toFraction x
      (nNum, nDen) = toFraction n
      result = (xNum * nNum) % (xDen * nDen)
  in denominator result == 1

toFraction :: String -> (Integer, Integer)
toFraction s =
  let (numStr, _:denStr) = break (=='/') s
  in (read numStr, read denStr)","
main :: IO ()
main = do
  let candidate = simplify
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/6"" ""2/1"" == False then pure () else error ""assertion failed""
  if candidate ""5/1"" ""3/1"" == True then pure () else error ""assertion failed""
  if candidate ""7/10"" ""10/2"" == False then pure () else error ""assertion failed""
  if candidate ""2/10"" ""50/10"" == True then pure () else error ""assertion failed""
  if candidate ""7/2"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""11/6"" ""6/1"" == True then pure () else error ""assertion failed""
  if candidate ""2/3"" ""5/2"" == False then pure () else error ""assertion failed""
  if candidate ""5/2"" ""3/5"" == False then pure () else error ""assertion failed""
  if candidate ""2/4"" ""8/4"" == True then pure () else error ""assertion failed""
  if candidate ""2/4"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""1/5"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_145,mos_Latn,hs,"--Wala makre: --B na n tũnuga ne b sẽn gʋls b rãmb to-to wã n sõd-ba.--Sebr ning sẽn be seb-kãngã pʋgẽ wã yaa:--b sẽn sõd-b ne sõor sẽn yikd n paasdẽ wã. --Gʋls-y tʋʋm-noor sẽn na n welg sõor-kãens sẽn be wã.--  >>> orderByPoints [1,11,(-1),(-11),(-12)]
--  [(-1),(-11),1,(-12),11]
--  >>> orderByPoints []
--  []
orderByPoints :: [Int] -> [Int]
orderByPoints nums =","import Data.List (sortBy)
import Data.Function (on)

orderByPoints :: [Int] -> [Int]
orderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums
  where
    sumOfDigits :: Int -> Int
    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)
    
    indexedNums :: [(Int, Int)]
    indexedNums = zip (map sumOfDigits nums) nums","
main :: IO ()
main = do
  let candidate = orderByPoints
  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error ""assertion failed""
  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error ""assertion failed""
  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_146,mos_Latn,hs,"--Wala makre: --Sõor pipi la yaoolem sifr yaa toor-toore (1, 3, 5, 7, 9).--Elemẽ rãmb sõor sẽn yɩɩd 10 la b yiibã fãa --Gʋls-y tʋʋm-noor sẽn na n dɩk sõor sõor n kõ n lebg n wa.--  >>> specialfilter [15,(-73),14,(-15)]
--  1
--  >>> specialfilter [33,(-2),(-3),45,21,109]
--  2
specialfilter :: [Int] -> Int
specialfilter nums =","specialfilter :: [Int] -> Int
specialfilter nums = length $ filter isSpecial nums
  where
    isSpecial n = n > 10 && isOddFirstAndLast (abs n)

    isOddFirstAndLast :: Int -> Bool
    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit
      where
        xStr = show x
        firstDigit = head xStr
        lastDigit = last xStr

    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""","
main :: IO ()
main = do
  let candidate = specialfilter
  if candidate [5,(-2),1,(-5)] == 0 then pure () else error ""assertion failed""
  if candidate [15,(-73),14,(-15)] == 1 then pure () else error ""assertion failed""
  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error ""assertion failed""
  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error ""assertion failed""
  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_147,mos_Latn,hs,"--Makre: --la a[i] + a[j] + a[k] yaa 3 naoor wʋsgo. --lebg n wa ne a tãag a (a[i], a[j], a[k]) zĩig ning i < j < k, --Sẽn na yɩl n bãng i fãa (1 ≤ i ≤ n), a[i] = i * i - i + 1 yõodo. --Yãmb paama sõor sẽn yaa sõma n. Y segd n maana sõor sẽn yaa sõma n sõore n zãntlem n.--  >>> getMaxTriples 5
--  1
--  Explanation: 
--  a = [1, 3, 7, 13, 21]
--  The only valid triple is (1, 7, 13).
getMaxTriples :: Int -> Int
getMaxTriples n =","getMaxTriples :: Int -> Int
getMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]
  where
    a = [i * i - i + 1 | i <- [1..n]]","
main :: IO ()
main = do
  let candidate = getMaxTriples
  if candidate 5 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 4 then pure () else error ""assertion failed""
  if candidate 10 == 36 then pure () else error ""assertion failed""
  if candidate 100 == 53361 then pure () else error ""assertion failed""
  pure ()"
HumanEval_149,mos_Latn,hs,"--Wala makre: --Y tõe n tagsame tɩ gom-biis fãa woglem na n yɩɩ a yembre.--Tʋʋmdã segd n lebg n waa ne sõor sẽn be sõor pʋga.--Gom-biis a yiib sã n tar woglem sẽn zem taaba, bɩ y sõd-bã ne lɛbɛɛre. --B segd n lebs-a-la sõor ning b sẽn sõdgã ne noor kãng n welge.--Sõssã sõor segd n yɩɩ sẽn zẽkd n dabda, la y segd n --la a tõe n tara sẽn yaa a yiib-n-soaba.--Sõngrã yaa sõngr sẽn tar sõor-n-bay wakat fãa, la a pa tol n yaa sõor-n-bay ye.--la a lebg n wa ne sõor sẽn pʋɩ-sʋk sẽn na n yɩlẽ, --a yiisda sõn-vãoog nins sẽn tar woglem sẽn pa yembr ne yẽ wã, --☐ Gʋls-y tʋʋm-noy sẽn sak n deeg sõor sẽn yaa sõor sẽn yaa sõor n na n yɩ y sẽn datã, ☐ Gʋls-y tʋʋm-noy sẽn na n sak n yɩ y sẽn datã, ☐ Gʋls-y tʋʋm-noy sẽn na n yɩ y sẽn datã--  >>> listSort [""aa"",""a"",""aaa""]
--  [""aa""]
--  >>> listSort [""ab"",""a"",""aaa"",""cd""]
--  [""ab"",""cd""]
sortedListSum :: [String] -> [String]
sortedListSum lst =","sortedListSum :: [String] -> [String]
sortedListSum lst = sortBy compareStrings (filter evenLength lst)
  where
    evenLength s = even (length s)
    compareStrings s1 s2
      | length s1 == length s2 = compare s1 s2
      | otherwise = compare (length s1) (length s2)","
main :: IO ()
main = do
  let candidate = sortedListSum
  if candidate [""aa"",""a"",""aaa""] == [""aa""] then pure () else error ""assertion failed""
  if candidate [""school"",""AI"",""asdf"",""b""] == [""AI"",""asdf"",""school""] then pure () else error ""assertion failed""
  if candidate [""d"",""b"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""d"",""dcba"",""abcd"",""a""] == [""abcd"",""dcba""] then pure () else error ""assertion failed""
  if candidate [""AI"",""ai"",""au""] == [""AI"",""ai"",""au""] then pure () else error ""assertion failed""
  if candidate [""a"",""b"",""b"",""c"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""aaaa"",""bbbb"",""dd"",""cc""] == [""cc"",""dd"",""aaaa"",""bbbb""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_150,mos_Latn,hs,"--Makre: --a yaa pipi sõor la a segd n lebg n wa ne y sẽn yaa to-to wã.--A yaa porograme sẽn na n lebg n wa ne x sẽn yaa a soaba, sã n yaa t'a n yaa --  >>> xOrY 7 34 12
--  34
--  >>> xOrY 15 8 5
--  5
xOrY :: Int -> Int -> Int -> Int
xOrY n x y =","xOrY :: Int -> Int -> Int -> Int
xOrY n x y = if isPrime n then x else y

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = xOrY
  if candidate 7 34 12 == 34 then pure () else error ""assertion failed""
  if candidate 15 8 5 == 5 then pure () else error ""assertion failed""
  if candidate 3 33 5212 == 33 then pure () else error ""assertion failed""
  if candidate 1259 3 52 == 3 then pure () else error ""assertion failed""
  if candidate 7919 (-1) 12 == (-1) then pure () else error ""assertion failed""
  if candidate 3609 1245 583 == 583 then pure () else error ""assertion failed""
  if candidate 91 56 129 == 129 then pure () else error ""assertion failed""
  if candidate 6 34 1234 == 1234 then pure () else error ""assertion failed""
  if candidate 1 2 0 == 0 then pure () else error ""assertion failed""
  if candidate 2 2 0 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_151,mos_Latn,hs,"--B sã n pa sõor sẽn zems bɩ sã n pa sõor sẽn yaa sõma, bɩ y bas n pa ges-b ye.--D sã n kõ sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor sõor--  >>> doubleTheDifference [1,3,2,0]
--  10
--  >>> doubleTheDifference [(-1),(-2),0]
--  0
--  >>> doubleTheDifference [9,(-2)]
--  81
--  >>> doubleTheDifference [0]
--  0
--  If the input list is empty, return 0.
doubleTheDifference :: [Float] -> Int
doubleTheDifference lst =","doubleTheDifference :: [Float] -> Int
doubleTheDifference lst = 
    sum [x * x | x <- map round lst, x > 0, odd x]","
main :: IO ()
main = do
  let candidate = doubleTheDifference
  if candidate [.0] == 0 then pure () else error ""assertion failed""
  if candidate [5.0,4.0] == 25 then pure () else error ""assertion failed""
  if candidate [0.1,0.2,0.3] == 0 then pure () else error ""assertion failed""
  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error ""assertion failed""
  if candidate [0.2,3.0,5.0] == 34 then pure () else error ""assertion failed""
  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error ""assertion failed""
  pure ()"
HumanEval_152,mos_Latn,hs,"--Makre: --yaa 0, la sã n pa woto, yaa sẽn pa tũ ne makrã la sẽn pa tũ ne makrã.--D na n leoka sõor sẽn yaa zãngã n wilg b sẽn pa bãng bũmb ning fãa to-to wã.--B kõ-y-la sõor a yiib sẽn tar makrã la b sẽn tõe n bãngã sẽn yaa zãngã, tɩ b fãa makd taab sõma.--Yãmb tʋʋmd yaa y bãng ned sã n da togsa b sẽn na n wa ne bũmb ninsã tɩ zemse.--Yaa sɩd tɩ d segd n ges-a lame n mak-a ne taaba.--Y sẽn mi bũmb ning sẽn maan-y wã, y sẽn tagsd bũmb ning la y sẽn tagsd bũmb ning sasa wã, yaa y sẽn na n bãng-a to-to wã.--M tagsdame tɩ tõnd fãa tẽra sũ-sãang ning d sẽn da tar d sẽn da gũ n kaoosã sẽn wa n wa ne wã.--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]
--  [0,0,0,0,3,3]
--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]
--  [4,4,1,0,0,6]
compare :: [Int] -> [Int] -> [Int]
compare game guess =","compare :: [Int] -> [Int] -> [Int]
compare game guess = zipWith (\g s -> abs (g - s)) game guess","
main :: IO ()
main = do
  let candidate = compare
  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error ""assertion failed""
  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error ""assertion failed""
  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error ""assertion failed""
  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_153,mos_Latn,hs,"--Makre: --(a pãng yaa -1).--lebg n wa ne ""Slices.SErviNGSliCes"" bala ""SErviNGSliCes"" yaa paasg sẽn yaa kãsenga --y segd n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n ẽe n n ẽe n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n--Wala makre, b sã n kõ-y ""Slices"" sẽn yaa sullã la --Y sã n dat n bãng y sẽn tõe n maan to-to, bɩ y yãk pipi soabã.--Y sã n wa tar y sẽkã n paasdẽ, y segd n ẽnega y sẽkã n paasdẽ.--format: ClassName.StrongestExtensionName. --Y segd n baoo sẽn yaa pãng n yɩɩdã n lebg n wa ne sõor sẽn be --Sẽn paasd-a pãnga, a yʋʋr pʋgẽ, yaa CAP - SM sẽn yaa wilgrã n wilgd pãng ning a sẽn tarã.--gʋls-biis sẽn be paasgã yʋʋr pʋgẽ, la bɩ SM yɩ lɛt-bõoneg sõor --Sẽn paasd-a pãng yaa woto: Bɩ CAP yɩ sõor sẽn be gãneg-kãsengã pʋgẽ --B na n dɩka yel-gɛtbã n ning karen-biis a taab karen-bi-kãng pʋgẽ.--Y na n paama karen-saamb yʋʋr (sull sẽn yaa) la sõor sẽn tar paasg n paasã.--  >>> strongestExtension ""my_class"" [""AA"",""Be"",""CC""]
--  ""my_class.AA""
strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions =","strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions = class_name ++ ""."" ++ strongestExt
  where
    calculateStrength :: String -> Int
    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)
    
    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)
    
    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)
    maxStrength ext1 ext2
      | snd ext1 > snd ext2 = ext1
      | otherwise           = ext2","
main :: IO ()
main = do
  let candidate = strongestExtension
  if candidate ""Watashi"" [""tEN"",""niNE"",""eIGHt8OKe""] == ""Watashi.eIGHt8OKe"" then pure () else error ""assertion failed""
  if candidate ""Boku123"" [""nani"",""NazeDa"",""YEs.WeCaNe"",""32145tggg""] == ""Boku123.YEs.WeCaNe"" then pure () else error ""assertion failed""
  if candidate ""__YESIMHERE"" [""t"",""eMptY"",""nothing"",""zeR00"",""NuLl__"",""123NoooneB321""] == ""__YESIMHERE.NuLl__"" then pure () else error ""assertion failed""
  if candidate ""K"" [""Ta"",""TAR"",""t234An"",""cosSo""] == ""K.TAR"" then pure () else error ""assertion failed""
  if candidate ""__HAHA"" [""Tab"",""123"",""781345"",""-_-""] == ""__HAHA.123"" then pure () else error ""assertion failed""
  if candidate ""YameRore"" [""HhAas"",""okIWILL123"",""WorkOut"",""Fails"",""-_-""] == ""YameRore.okIWILL123"" then pure () else error ""assertion failed""
  if candidate ""finNNalLLly"" [""Die"",""NowW"",""Wow"",""WoW""] == ""finNNalLLly.WoW"" then pure () else error ""assertion failed""
  if candidate ""_"" [""Bb"",""91245""] == ""_.Bb"" then pure () else error ""assertion failed""
  if candidate ""Sp"" [""671235"",""Bb""] == ""Sp.671235"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_154,mos_Latn,hs,"--B kõ-y-la gom-biis a yiibu. Y segd n lebg n wa ne True sã n yaa gom-biis a yiib-n-soabã bɩ a rotations a to wã yaa substring sẽn be pipi gom-bi-kãng pʋgẽ.--  >>> cycpatternCheck ""abcd"" ""abd""
--  False
--  >>> cycpatternCheck ""hello"" ""ell""
--  True
--  >>> cycpatternCheck ""whassup"" ""psus""
--  False
--  >>> cycpatternCheck ""abab"" ""baa""
--  True
--  >>> cycpatternCheck ""efef"" ""eeff""
--  False
--  >>> cycpatternCheck ""himenss"" ""simen""
--  True
cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b =","cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b = any (`isInfixOf` a) rotations
  where
    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","
main :: IO ()
main = do
  let candidate = cycpatternCheck
  if candidate ""xyzw"" ""xyw"" == False then pure () else error ""assertion failed""
  if candidate ""yello"" ""ell"" == True then pure () else error ""assertion failed""
  if candidate ""whattup"" ""ptut"" == False then pure () else error ""assertion failed""
  if candidate ""efef"" ""fee"" == True then pure () else error ""assertion failed""
  if candidate ""abab"" ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""winemtt"" ""tinem"" == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_155,mos_Latn,hs,"--Makre: --☐ A la bonne valeur. ☐ A la bonne valeur.--  >>> evenOddCount (-12)
--  (1, 1)
--  >>> evenOddCount 123
--  (1, 2)
evenOddCount :: Int -> (Int, Int)
evenOddCount num =","evenOddCount :: Int -> (Int, Int)
evenOddCount num = (length evens, length odds)
  where
    digits = map (read . (:[])) . show . abs $ num
    evens = filter even digits
    odds  = filter odd digits","
main :: IO ()
main = do
  let candidate = evenOddCount
  if candidate 7 == (0, 1) then pure () else error ""assertion failed""
  if candidate (-78) == (1, 1) then pure () else error ""assertion failed""
  if candidate 3452 == (2, 2) then pure () else error ""assertion failed""
  if candidate 346211 == (3, 3) then pure () else error ""assertion failed""
  if candidate (-345821) == (3, 3) then pure () else error ""assertion failed""
  if candidate (-2) == (1, 0) then pure () else error ""assertion failed""
  if candidate (-45347) == (2, 3) then pure () else error ""assertion failed""
  if candidate 0 == (1, 0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_156,mos_Latn,hs,"--Makre: --B sẽn tõe n maan to-to n paam n kẽe bãaga--la y lebs-a ne gʋls-biis sẽn yaa bilfr. --☐ D sã n kõ sõor sẽn yaa sõma, d na n paama a sẽn zem ne Rom sõor sẽn yaa wa b sẽn gʋlsd sõor toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy n gʋlsd sõor toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy toɛy-toɛy toɛy-toɛy toɛy-toɛy toɛy toɛy-toɛy toɛy toɛy-toɛy--  >>> intToMiniRoman 19
--  ""xix""
--  >>> intToMiniRoman 152
--  ""clii""
--  >>> intToMiniRoman 426
--  ""cdxxvi""
intToMiniRoman :: Int -> String
intToMiniRoman number =","intToMiniRoman :: Int -> String
intToMiniRoman number = concatMap (replicateSymbol number) romanNumerals
  where
    romanNumerals = [(1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
                     (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
                     (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""), (1, ""i"")]
    
    replicateSymbol :: Int -> (Int, String) -> String
    replicateSymbol n (value, symbol)
      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)
      | otherwise = """"","
main :: IO ()
main = do
  let candidate = intToMiniRoman
  if candidate 19 == ""xix"" then pure () else error ""assertion failed""
  if candidate 152 == ""clii"" then pure () else error ""assertion failed""
  if candidate 251 == ""ccli"" then pure () else error ""assertion failed""
  if candidate 426 == ""cdxxvi"" then pure () else error ""assertion failed""
  if candidate 500 == ""d"" then pure () else error ""assertion failed""
  if candidate 1 == ""i"" then pure () else error ""assertion failed""
  if candidate 4 == ""iv"" then pure () else error ""assertion failed""
  if candidate 43 == ""xliii"" then pure () else error ""assertion failed""
  if candidate 90 == ""xc"" then pure () else error ""assertion failed""
  if candidate 94 == ""xciv"" then pure () else error ""assertion failed""
  if candidate 532 == ""dxxxii"" then pure () else error ""assertion failed""
  if candidate 900 == ""cm"" then pure () else error ""assertion failed""
  if candidate 994 == ""cmxciv"" then pure () else error ""assertion failed""
  if candidate 1000 == ""m"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_157,mos_Latn,hs,"--Makre: --Yaa digri 90.--A rectangle triangle yaa triangle a ye sẽn tar rectangle bɩ --A na n yɩɩ wa nug-rɩtg sẽn yaa goosneerã.--D sã n ges sẽn yaa a tãabã sẽn yaa to-to wã, d na n lebg n togsa sɩd tɩ b sã n kõ a tãabã, b na n togsa sɩd tɩ b sã n kõ a tãabã, b na n togsa sɩd tɩ b sã n kõ a tãabã, b na n togsa sɩd me.--  >>> rightAngleTriangle 3 4 5
--  True
--  >>> rightAngleTriangle 1 2 3
--  False
rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c =","rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c = 
    let [x, y, z] = sort [a, b, c]
    in x^2 + y^2 == z^2
    where sort = Data.List.sort","
main :: IO ()
main = do
  let candidate = rightAngleTriangle
  if candidate 3 4 5 == True then pure () else error ""assertion failed""
  if candidate 1 2 3 == False then pure () else error ""assertion failed""
  if candidate 10 6 8 == True then pure () else error ""assertion failed""
  if candidate 2 2 2 == False then pure () else error ""assertion failed""
  if candidate 7 24 25 == True then pure () else error ""assertion failed""
  if candidate 10 5 7 == False then pure () else error ""assertion failed""
  if candidate 5 12 13 == True then pure () else error ""assertion failed""
  if candidate 15 8 17 == True then pure () else error ""assertion failed""
  if candidate 48 55 73 == True then pure () else error ""assertion failed""
  if candidate 1 1 1 == False then pure () else error ""assertion failed""
  if candidate 2 2 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_158,mos_Latn,hs,"--n lebg n wa ne a soab sẽn yɩ pipi n zĩnd gom-biis nins sẽn be seb-vãoogã pʋgẽ wã. --Sã n yaa sõor sẽn yaa toor n yɩɩd la b tõe n tall n gʋls sõor wʋsgo, --Sõngrã tara gom-biis toor-toor. lebg n wa ne gom-biis sõor sẽn yaa wʋsgo --❑ Gʋls-y tʋʋm-noy sẽn sakd sõor-koɛɛg sẽn yaa sõor wʋsgo.--  >>> findMax [""name"",""of"",""string""]
--  ""string""
--  >>> findMax [""name"",""enam"",""game""]
--  ""enam""
--  >>> findMax [""aaaaaaa"",""bb"",""cc""]
--  ""aaaaaaa""
findMax :: [String] -> String
findMax words =","import Data.List (nub, sort)

findMax :: [String] -> String
findMax words = 
    head . sort . map snd . filter (\(n, _) -> n == maxUnique) $ wordUniquePairs
  where
    wordUniquePairs = [(length . nub $ word, word) | word <- words]
    maxUnique = maximum $ map fst wordUniquePairs","
main :: IO ()
main = do
  let candidate = findMax
  if candidate [""name"",""of"",""string""] == ""string"" then pure () else error ""assertion failed""
  if candidate [""name"",""enam"",""game""] == ""enam"" then pure () else error ""assertion failed""
  if candidate [""aaaaaaa"",""bb"",""cc""] == ""aaaaaaa"" then pure () else error ""assertion failed""
  if candidate [""abc"",""cba""] == ""abc"" then pure () else error ""assertion failed""
  if candidate [""play"",""this"",""game"",""of"",""footbott""] == ""footbott"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""gonna"",""rock""] == ""gonna"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""a"",""mad"",""nation""] == ""nation"" then pure () else error ""assertion failed""
  if candidate [""this"",""is"",""a"",""prrk""] == ""this"" then pure () else error ""assertion failed""
  if candidate [""b""] == ""b"" then pure () else error ""assertion failed""
  if candidate [""play"",""play"",""play""] == ""play"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_159,mos_Latn,hs,"--Makre: --Sã n pa be tɩ karotã kell n sekã, y na n wãba karotã fãa sẽn kellã, la y na n ket n tara kom.--[Yãk-y n tool-y neda]--y segd n lebg n wa ne [ sõor ning y sẽn dɩt tɩ b sa wã poore, --La masã, y segd n dɩta karot n paase, n na n dɩ n sa.--Yãmb yaa bõang kom sẽn tar wʋsgo, la y zoe n dɩka zũnzũy sõor sẽn zems wʋsgo.--  >>> eat 5 6 10
--  [11,4]
--  >>> eat 4 8 9
--  [12,1]
--  >>> eat 1 10 10
--  [11,0]
--  >>> eat 2 11 5
--  [7,0]
--  Variables:
--  @number : integer
--  the number of carrots that you have eaten.
--  @need : integer
--  the number of carrots that you need to eat.
--  @remaining : integer
--  the number of remaining carrots thet exist in stock
--  Constrain:
--  * 0 <= number <= 1000
--  * 0 <= need <= 1000
--  * 0 <= remaining <= 1000
--  Have fun :)
eat :: Int -> Int -> Int -> [Int]
eat number need remaining =","eat :: Int -> Int -> Int -> [Int]
eat number need remaining
  | remaining >= need = [number + need, remaining - need]
  | otherwise = [number + remaining, 0]","
main :: IO ()
main = do
  let candidate = eat
  if candidate 5 6 10 == [11,4] then pure () else error ""assertion failed""
  if candidate 4 8 9 == [12,1] then pure () else error ""assertion failed""
  if candidate 1 10 10 == [11,0] then pure () else error ""assertion failed""
  if candidate 2 11 5 == [7,0] then pure () else error ""assertion failed""
  if candidate 4 5 7 == [9,2] then pure () else error ""assertion failed""
  if candidate 4 5 1 == [5,0] then pure () else error ""assertion failed""
  pure ()"
HumanEval_160,mos_Latn,hs,"--Tʋʋmd-mitbã sõor tara tʋʋm-mit a yembr n tãag tʋʋma sõor tara tʋʋma a yiib n tãag tʋʋma.--Operand yaa sõor sẽn pa-wʋmd sẽn yaa zãng sõor sõor sõore.--Operatɛɛrã sõor yaa wa operandã sõor sẽn kong a ye.--Sebr a ye: --=> B sẽn wa n yãkd a soabã yaa 9 --Rẽ kɩtame tɩ b lebg 2 + 3 * 4 - 5 --Sõdg-y sõsgã sẽn na n yɩ to-to.--so-toakã['+', '*', '-'] --Makre: --B sẽn tõe n maan to-to n wilg tɩ b yaa to-to wã (**) --Roog pʋɩ-sʋka ( // ) --Yaa f sẽn na n dɩk n paasã la f na n dɩk n paasã.--B sẽn yãkd bũmb ningã ( - ) --Sẽn paasd (+) --Alzebrã tʋʋm-noodã yaa: --D sã n wa rat n bãng bũmb ning sẽn kɩt tɩ d gom woto wã, d segd n bao n bãnga d sẽn na n gom to-to.--Sebr a yiib-n-soabã yaa sõor sẽn yaa zãng sõor sõore.--A sã n kõ tõnd sõor a yiib sẽn wilgd tʋʋm-tʋmd la tʋʋm-tʋmd sẽn yaa a soaba. pipi sõorã tara alzebr tʋʋm-tʋʋm sẽn yaa kãsems la ẽ, a sã n kõ tõnd sõor a yiib sẽn wilgd tʋʋm-tʋmd la tʋʋm-tʋmd sẽn yaa a soaba, d na n yeelame tɩ b sõorã yaa a woto:doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand =","doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand = evaluate operand operator
  where
    evaluate [x] [] = x
    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops
      where
        result = applyOperation op x y

    applyOperation ""+"" a b = a + b
    applyOperation ""-"" a b = a - b
    applyOperation ""*"" a b = a * b
    applyOperation ""//"" a b = a `div` b
    applyOperation ""**"" a b = a ^ b
    applyOperation _ _ _ = error ""Unsupported operation""","
main :: IO ()
main = do
  let candidate = doAlgebra
  if candidate [""**"",""*"",""+""] [2,3,4,5] == 37 then pure () else error ""assertion failed""
  if candidate [""+"",""*"",""-""] [2,3,4,5] == 9 then pure () else error ""assertion failed""
  if candidate [""//"",""*""] [7,3,4] == 8 then pure () else error ""assertion failed""
  pure ()"
HumanEval_161,mos_Latn,hs,"--Makre --Fõn-kãng segd n lebg n waa ne sõor sẽn wa ne wã.--Sã n pa be lɛta a ye, bɩ y wẽnemd-a.--Sã n pa rẽ bɩ y bas-a a sẽn yaa to-to wã.--sã n yaa lɛtgre, bɩ f lebg n tek a sẽn be wã n sɩng ne a sẽn be tẽngrã n kẽng a sẽn be a zugẽ wã, bɩ a sẽn be a poorẽ wã n baas ne a sẽn be a poorẽ wã, --B kõ-y-la sõor sẽn yaa sõor-yende.--  >>> solve ""1234""
--  ""4321""
--  >>> solve ""ab""
--  ""AB""
--  >>> solve ""#a@C""
--  ""#A@c""
solve :: String -> String
solve s =","solve :: String -> String
solve s
  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s
  | otherwise = reverse s
  where
    toggleCase c
      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char
      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char
      | otherwise = c","
main :: IO ()
main = do
  let candidate = solve
  if candidate ""AsDf"" == ""aSdF"" then pure () else error ""assertion failed""
  if candidate ""1234"" == ""4321"" then pure () else error ""assertion failed""
  if candidate ""ab"" == ""AB"" then pure () else error ""assertion failed""
  if candidate ""#a@C"" == ""#A@c"" then pure () else error ""assertion failed""
  if candidate ""#AsdfW^45"" == ""#aSDFw^45"" then pure () else error ""assertion failed""
  if candidate ""#6@2"" == ""2@6#"" then pure () else error ""assertion failed""
  if candidate ""#$a^D"" == ""#$A^d"" then pure () else error ""assertion failed""
  if candidate ""#ccc"" == ""#CCC"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_162,mos_Latn,hs,"--Sã n yaa 'text' yaa gom-bi-sɛka, lebg n wa ne Bõn-zaala. --☐ A nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã nã--  >>> stringToMd5 ""Hello world""
--  Just (""3e25960a79dbc69b674cd4ec67a72c62"")
stringToMd5 :: String -> Maybe String
stringToMd5 text =","import qualified Data.ByteString.Char8 as C
import qualified Data.Digest.Pure.MD5 as MD5

stringToMd5 :: String -> Maybe String
stringToMd5 text
  | null text = Nothing
  | otherwise = Just $ show $ MD5.md5 $ C.pack text","
main :: IO ()
main = do
  let candidate = stringToMd5
  if candidate ""Hello world"" == Just (""3e25960a79dbc69b674cd4ec67a72c62"") then pure () else error ""assertion failed""
  if candidate """" == Just (Nothing) then pure () else error ""assertion failed""
  if candidate ""A B C"" == Just (""0ef78513b0cb8cef12743f5aeb35f888"") then pure () else error ""assertion failed""
  if candidate ""password"" == Just (""5f4dcc3b5aa765d61d8327deb882cf99"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_163,mos_Latn,hs,"--Wala makre: --la b, sẽn na yɩl tɩ b sõorã paasdẽ. --D sã n kõ sõor sẽn yaa sõma a la b, d na n leoka sõor ning sẽn be a la b sʋka.--  >>> generateIntegers 2 8
--  [2,4,6,8]
--  >>> generateIntegers 8 2
--  [2,4,6,8]
--  >>> generateIntegers 10 14
--  []
generateIntegers :: Int -> Int -> [Int]
generateIntegers a b =","generateIntegers :: Int -> Int -> [Int]
generateIntegers a b = filter even [min a b .. max a b]","
main :: IO ()
main = do
  let candidate = generateIntegers
  if candidate 2 10 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 10 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 132 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 17 89 == [] then pure () else error ""assertion failed""
  pure ()"
