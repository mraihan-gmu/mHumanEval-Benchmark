[{"task_id":"HumanEval_0","nl":"hrv_Latn","pl":"go_test.go","prompt":"package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/              \/\/Provjerite jesu li u datoj listi brojeva, bilo koji dva broja bliža jedna drugoj od \/\/ >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n\/\/ true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n","canonical_solution":"package has_close_elements_test\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\n\/\/ Check if in given list of numbers, are any two numbers closer to each other than\n\/\/ given threshold.\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n\tsort.Float64s(numbers)\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tif math.Abs(numbers[i+1]-numbers[i]) < threshold {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestHasCloseElements(t *testing.T) {\n\ttestCases := []struct {\n\t\tnumbers   []float64\n\t\tthreshold float64\n\t\texpected  bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, false},\n\t\t{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},\n\t\t{[]float64{1.5, 1.8, 2.2}, 0.3, true},\n\t\t{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase%d\", i+1), func(t *testing.T) {\n\t\t\tresult := has_close_elements(tc.numbers, tc.threshold)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestHas_Close_Elements(t *testing.T) {\n  candidate := has_close_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_1","nl":"hrv_Latn","pl":"go_test.go","prompt":"package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ignorirajte sve prostore u ulaznom nizu.\/\/Odvojene skupine su uravnotežene (svaka otvorena brace je pravilno zatvorena) i nisu ugniježđene jedna unutar druge.\/\/Odvojite te grupe u zasebne nizove i vratite popis tih.\/\/Uvod za ovu funkciju je niz koji sadrži više grupa ugnežđenih zagrada.\/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n","canonical_solution":"package separate_paren_groups\n\nfunc separate_paren_groups(paren_string string) []string {\n\tvar result []string\n\tvar currentGroup []rune\n\topenCount := 0\n\n\tfor _, char := range paren_string {\n\t\tif char == '(' {\n\t\t\topenCount++\n\t\t\tcurrentGroup = append(currentGroup, char)\n\t\t} else if char == ')' {\n\t\t\topenCount--\n\t\t\tcurrentGroup = append(currentGroup, char)\n\n\t\t\tif openCount == 0 {\n\t\t\t\tresult = append(result, string(currentGroup))\n\t\t\t\tcurrentGroup = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}","tests":"func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_2","nl":"hrv_Latn","pl":"go_test.go","prompt":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća decimalni dio broja. \/\/(Ostali dio uvijek manji od 1).\/\/i cijeli dio (najveći cijeli broj manji od datog broja) i decimalni \/\/S obzirom na pozitivan broj plutajuće tačke, može se razložiti u \/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n","canonical_solution":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive floating point number, it can be decomposed into\n\/\/ an integer part (largest integer smaller than given number) and decimals\n\/\/ (leftover part always smaller than 1).\n\/\/ Return the decimal part of the number.\n\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n    integerPart := int(number)\n    return number - float64(integerPart)\n}\n\nfunc TestTruncateNumber(t *testing.T) {\n    testCases := []struct {\n        input float64\n        expected float64\n    }{\n        {3.5, 0.5},\n        {0.0, 0.0},\n        {7.25, 0.25},\n        {4.99, 0.99},\n        {2.0, 0.0},\n    }\n\n    for _, tc := range testCases {\n        result := truncate_number(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %.2f, got %.2f\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(truncate_number(3.5)) \/\/ Should print 0.5\n    fmt.Println(truncate_number(7.25)) \/\/ Should print 0.25\n}","tests":"func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_3","nl":"hrv_Latn","pl":"go_test.go","prompt":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/U tom trenutku funkcija bi trebala vratiti istinitu. Inače bi trebala vratiti lažno.\/\/Vaš zadatak je otkriti je li u bilo kojoj točki saldo računa pao ispod nule, i \/\/Dobiješ popis operacija uplate i povlačenja na bankovnom računu koji počinje sa \/\/ >>> below_zero([]int{1, 2, 3})\n\/\/ false\n\/\/ >>> below_zero([]int{1, 2, -4, 5})\n\/\/ true\nfunc below_zero(operations []int) bool {\n","canonical_solution":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc below_zero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestBelowZero(t *testing.T) {\n    testCases := []struct {\n        operations []int\n        expected   bool\n    }{\n        {[]int{1, 2, 3}, false},\n        {[]int{1, 2, -4, 5}, true},\n        {[]int{0, -1, 1}, true},\n        {[]int{}, false},\n        {[]int{-1, 1, -1, 1}, true},\n    }\n    for _, tc := range testCases {\n        result := below_zero(tc.operations)\n        if result != tc.expected {\n            t.Errorf(\"below_zero(%v) = %v; want %v\", tc.operations, result, tc.expected)\n        }\n    }\n}","tests":"func TestBelow_Zero(t *testing.T) {\n  candidate := below_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: false },\n     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },\n     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },\n     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_4","nl":"hrv_Latn","pl":"go_test.go","prompt":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/MAD = prosjek. x - x_mean. \/\/element i središnju točku (u ovom slučaju sredina): \/\/Prosječna apsolutna devijacija je prosječna apsolutna razlika između svakog od njih.\/\/oko prosjeka ovog skupa podataka. \/\/Za dat popis ulaznih brojeva izračunati prosječnu apsolutnu devijaciju \/\/ >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n\/\/ 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n","canonical_solution":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc mean_absolute_deviation(numbers []float64) float64 {\n    var sum float64\n    for _, num := range numbers {\n        sum += num\n    }\n    mean := sum \/ float64(len(numbers))\n\n    var madSum float64\n    for _, num := range numbers {\n        madSum += math.Abs(num - mean)\n    }\n    return madSum \/ float64(len(numbers))\n}\n\nfunc TestMeanAbsoluteDeviation(t *testing.T) {\n    tests := []struct {\n        input []float64\n        want  float64\n    }{\n        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},\n        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},\n        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"mean_absolute_deviation(%v)\", test.input), func(t *testing.T) {\n            got := mean_absolute_deviation(test.input)\n            if got != test.want {\n                t.Errorf(\"mean_absolute_deviation(%v) = %v; want %v\", test.input, got, test.want)\n            }\n        })\n    }\n}","tests":"func TestMean_Absolute_Deviation(t *testing.T) {\n  candidate := mean_absolute_deviation\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_5","nl":"hrv_Latn","pl":"go_test.go","prompt":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Upisati broj \"delimeter\" između svake dvije uzastopne elemente ulazne liste `brojevi' \/\/ >>> intersperse([]int{}, 4)\n\/\/ []int{}\n\/\/ >>> intersperse([]int{1, 2, 3}, 4)\n\/\/ []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n","canonical_solution":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc intersperse(numbers []int, delimiter int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := make([]int, 0, len(numbers)*2-1)\n    for i, num := range numbers {\n        if i > 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, num)\n    }\n    return result\n}\n\nfunc TestIntersperse(t *testing.T) {\n    testCases := []struct{\n        input []int\n        delimiter int\n        expected []int\n    }{\n        {[]int{}, 4, []int{}},\n        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},\n        {[]int{1}, 4, []int{1}},\n        {[]int{1, 2}, 4, []int{1, 4, 2}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v, %d\", tc.input, tc.delimiter), func(t *testing.T) {\n            result := intersperse(tc.input, tc.delimiter)\n            if !equal(result, tc.expected) {\n                t.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    \n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"func TestIntersperse(t *testing.T) {\n  candidate := intersperse\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}, 7), expected: []int{} },\n     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },\n     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_6","nl":"hrv_Latn","pl":"go_test.go","prompt":"package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer, (() (()) ima najviše dvije razine gnijezdenja, dok ((())) ima tri. \/\/Za svaku od grupa, iznos najduže razine ugnežđivanja zagrada. \/\/Uvod za ovu funkciju je niz koji predstavlja više grupa za ugnežđene zagrade odvojene razmakovima.\/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n","canonical_solution":"func parse_nested_parens(paren_string string) []int {\n    groups := strings.Fields(paren_string)\n    depths := make([]int, len(groups))\n\n    for i, group := range groups {\n        maxDepth, currentDepth := 0, 0\n        for _, char := range group {\n            if char == '(' {\n                currentDepth++\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == ')' {\n                currentDepth--\n            }\n        }\n        depths[i] = maxDepth\n    }\n\n    return depths\n}","tests":"func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_7","nl":"hrv_Latn","pl":"go_test.go","prompt":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Filtrirajte ulazni popis niza samo za one koji sadrže datog podniza \/\/ >>> filter_by_substring([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strings []string, substring string) []string {\n","canonical_solution":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc filter_by_substring(strings []string, substring string) []string {\n    var result []string\n    for _, str := range strings {\n        if strings.Contains(str, substring) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterBySubstring(t *testing.T) {\n    tests := []struct {\n        input    []string\n        substring string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"bacd\", \"array\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_substring(test.input, test.substring)\n        if fmt.Sprintf(\"%q\", result) != fmt.Sprintf(\"%q\", test.expected) {\n            t.Errorf(\"filter_by_substring(%q, %q) = %q; expected %q\", test.input, test.substring, result, test.expected)\n        }\n    }\n}","tests":"func TestFilter_By_Substring(t *testing.T) {\n  candidate := filter_by_substring\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"), expected: []string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"), expected: []string{\"grunt\", \"prune\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_8","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Prazna suma treba biti jednaka 0 i prazan proizvod jednaka 1. \/\/Za dat popis cijelih brojeva, vratite popis koji se sastoji od zbroja i proizvoda svih cijelih brojeva na popisu. \/\/ >>> sum_product([]int{})\n\/\/ []interface{}{0, 1}\n\/\/ >>> sum_product([]int{1, 2, 3, 4})\n\/\/ []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n","canonical_solution":"func sum_product(numbers []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n}","tests":"func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_9","nl":"hrv_Latn","pl":"go_test.go","prompt":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/U slijedu.\/\/Iz datog popisa cijelih brojeva generirajte popis najvećih elemenata koji su pronađeni do datog trenutka.\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n","canonical_solution":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a given list of integers, generate a list of rolling maximum element found until given moment\n\/\/ in the sequence.\n\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result := make([]int, len(numbers))\n    maxSoFar := numbers[0]\n    for i, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result[i] = maxSoFar\n    }\n    return result\n}\n\nfunc TestRollingMax(t *testing.T) {\n    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) \/\/ should output []int{1, 2, 3, 3, 3, 4, 4}\n}","tests":"func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_10","nl":"hrv_Latn","pl":"go_test.go","prompt":"package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/- Dodajte na kraj niza obrnuto prefiks niza koji dolazi prije palindromskog sufiksa.\/\/- Pronađite najduži postfix ponuđenog niza koji je palindrom. \/\/Algoritam je jednostavan:\/\/Nađite najkraći palindrom koji počinje datim nizom. \/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunc make_palindrome(myString string) string {\n","canonical_solution":"package make_palindrome_test\n\nimport (\n    \"testing\"\n)\n\nfunc make_palindrome(myString string) string {\n    if len(myString) <= 1 {\n        return myString\n    }\n    \n    \/\/ Helper function to check if a string is a palindrome\n    isPalindrome := func(s string) bool {\n        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n            if s[i] != s[j] {\n                return false\n            }\n        }\n        return true\n    }\n\n    \/\/ Start from the whole string and reduce until we find a palindrome\n    for i := len(myString); i > 0; i-- {\n        if isPalindrome(myString[len(myString)-i:]) {\n            prefix := myString[:len(myString)-i]\n            \/\/ Reverse the prefix and append to original string\n            reversedPrefix := reverse(prefix)\n            return myString + reversedPrefix\n        }\n    }\n\n    \/\/ If no palindromic suffix is found, return original string with reverse appended\n    return myString + reverse(myString)\n}\n\n\/\/ Helper function to reverse a string\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc TestMakePalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"cat\", \"catac\"},\n        {\"cata\", \"catac\"},\n    }\n\n    for _, test := range tests {\n        result := make_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"make_palindrome(%q) = %q; expected %q\", test.input, result, test.expected)\n        }\n    }\n}","tests":"func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_11","nl":"hrv_Latn","pl":"go_test.go","prompt":"package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Izvršite binarni XOR na ovim ulazima i vratite rezultat također kao niz. \/\/Unos su dva niza a i b koji se sastoje samo od 1 i 0 .\/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunc string_xor(a string, b string) string {\n","canonical_solution":"result := make([]byte, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\tresult[i] = '0'\n\t\t} else {\n\t\t\tresult[i] = '1'\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_13","nl":"hrv_Latn","pl":"go_test.go","prompt":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vratite najveći zajednički dijelica dvaju cijelih brojeva a i b \/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n","canonical_solution":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return a greatest common divisor of two integers a and b\n\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n    for b != 0 {\n        a, b = b, a%b\n    }\n    return a\n}\n\nfunc TestGreatestCommonDivisor(t *testing.T) {\n    tests := []struct {\n        a, b   int\n        expect int\n    }{\n        {3, 5, 1},\n        {25, 15, 5},\n        {54, 24, 6},\n        {48, 18, 6},\n        {101, 103, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.a, test.b), func(t *testing.T) {\n            result := greatest_common_divisor(test.a, test.b)\n            if result != test.expect {\n                t.Errorf(\"expected %d, got %d\", test.expect, result)\n            }\n        })\n    }\n}","tests":"func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual: candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected: 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_14","nl":"hrv_Latn","pl":"go_test.go","prompt":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća popis svih prefiksa od najkraćeg do najdužeg ulaznog niza \/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n","canonical_solution":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list of all prefixes from shortest to longest of the input string\n\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n    var prefixes []string\n    for i := 1; i <= len(myString); i++ {\n        prefixes = append(prefixes, myString[:i])\n    }\n    return prefixes\n}\n\nfunc TestAllPrefixes(t *testing.T) {\n    result := all_prefixes(\"abc\")\n    expected := []string{\"a\", \"ab\", \"abc\"}\n    for i, v := range result {\n        if v != expected[i] {\n            t.Errorf(\"Test failed, expected %v, got %v\", expected[i], v)\n        }\n    }\n    fmt.Println(\"Test passed\")\n}","tests":"func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_15","nl":"hrv_Latn","pl":"go_test.go","prompt":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća niz koji sadrži brojeve ograničene prostorom od 0 do n.\/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n","canonical_solution":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\n\/\/ Return a string containing space-delimited numbers starting from 0 upto n inclusive.\nfunc string_sequence(n int) string {\n    var parts []string\n    for i := 0; i <= n; i++ {\n        parts = append(parts, fmt.Sprintf(\"%d\", i))\n    }\n    return strings.Join(parts, \" \")\n}\n\nfunc TestStringSequence(t *testing.T) {\n    result := string_sequence(0)\n    expected := \"0\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n    \n    result = string_sequence(5)\n    expected = \"0 1 2 3 4 5\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n}","tests":"func TestString_Sequence(t *testing.T) {\n  candidate := string_sequence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"0\" },\n     { actual: candidate(3), expected: \"0 1 2 3\" },\n     { actual: candidate(10), expected: \"0 1 2 3 4 5 6 7 8 9 10\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_16","nl":"hrv_Latn","pl":"go_test.go","prompt":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ako je string, saznajte koliko različitih znakova (bez obzira na veličinu) ima.\/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunc count_distinct_characters(myString string) int {\n","canonical_solution":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc count_distinct_characters(myString string) int {\n    characterMap := make(map[rune]bool)\n    for _, char := range strings.ToLower(myString) {\n        characterMap[char] = true\n    }\n    return len(characterMap)\n}\n\nfunc TestCountDistinctCharacters(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected int\n    }{\n        {\"xyzXYZ\", 3},\n        {\"Jerry\", 4},\n        {\"\", 0},\n        {\"Hello, World!\", 10},\n    }\n\n    for _, testCase := range testCases {\n        result := count_distinct_characters(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", testCase.input, testCase.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input '%s': got %d\\n\", testCase.input, result)\n        }\n    }\n}","tests":"func TestCount_Distinct_Characters(t *testing.T) {\n  candidate := count_distinct_characters\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abcde\"), expected: 5 },\n     { actual: candidate(\"abcdecadeCADE\"), expected: 5 },\n     { actual: candidate(\"aaaaAAAAaaaa\"), expected: 1 },\n     { actual: candidate(\"Jerry jERRY JeRRRY\"), expected: 5 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_17","nl":"hrv_Latn","pl":"go_test.go","prompt":"package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/'Hajka' - četvrt nota, traje jedan udarac.\/\/'O sačekaj' - pola note, traje dva udaraca.\/\/'O' - cijela nota, traje četiri udarca.\/\/Evo legende:\/\/Ne posljednji.\/\/Vaš zadatak je da analizirate ovaj niz i vratite listu cijelih brojeva koji odgovaraju broju otkucaja svakog \/\/Uvod za ovu funkciju je niz koji predstavlja glazbene note u posebnom ASCII formatu.\/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n","canonical_solution":"package parse_music_test\n\nimport (\n    \"strings\"\n)\n\nfunc parse_music(music_string string) []int {\n    notes := strings.Fields(music_string)\n    beats := make([]int, len(notes))\n    for i, note := range notes {\n        switch note {\n        case \"o\":\n            beats[i] = 4\n        case \"o|\":\n            beats[i] = 2\n        case \".|\":\n            beats[i] = 1\n        }\n    }\n    return beats\n}","tests":"func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_18","nl":"hrv_Latn","pl":"go_test.go","prompt":"package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Pronađite koliko puta se određeni podstrin može naći u izvornom nizu.\/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunc how_many_times(myString string, substring string) int {\n","canonical_solution":"func how_many_times(myString string, substring string) int {\n    if len(substring) == 0 {\n        return 0\n    }\n\n    count := 0\n    for i := 0; i <= len(myString)-len(substring); i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHowManyTimes(t *testing.T) {\n    tests := []struct {\n        myString  string\n        substring string\n        expected  int\n    }{\n        {\"\", \"a\", 0},\n        {\"aaa\", \"a\", 3},\n        {\"aaaa\", \"aa\", 3},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%s in %s\", test.substring, test.myString), func(t *testing.T) {\n            result := how_many_times(test.myString, test.substring)\n            if result != test.expected {\n                t.Errorf(\"Expected %d but got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n     { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_19","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća niz brojeva sortiran od najmanjeg do najvećeg \/\/Važeće opcije su \"nula\", \"jedan\", \"dva\", \"tri\", \"četiri\", \"pet\", \"šest\", \"sedam\", \"osam\" i \"devet\". \/\/Unos je prostorno ograničen niz brojeva od \"nula\" do \"devet\".\/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunc sort_numbers(numbers string) string {\n","canonical_solution":"package sort_numbers_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc sort_numbers(numbers string) string {\n    wordsToNumbers := map[string]int{\n        \"zero\":  0,\n        \"one\":   1,\n        \"two\":   2,\n        \"three\": 3,\n        \"four\":  4,\n        \"five\":  5,\n        \"six\":   6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\":  9,\n    }\n    \n    numbersToWords := []string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    \n    words := strings.Fields(numbers)\n    numberInts := make([]int, len(words))\n    \n    for i, word := range words {\n        numberInts[i] = wordsToNumbers[word]\n    }\n    \n    sort.Ints(numberInts)\n    \n    sortedWords := make([]string, len(words))\n    for i, num := range numberInts {\n        sortedWords[i] = numbersToWords[num]\n    }\n    \n    return strings.Join(sortedWords, \" \")\n}","tests":"func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_20","nl":"hrv_Latn","pl":"go_test.go","prompt":"package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/U slučaju da se ne može dobiti odgovor, možete ga vratiti po redu (manji broj, veći broj).\/\/Iz ponuđene liste brojeva (dužine najmanje dva) odaberite i vratite dva koja su najbliža svakom \/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\/\/ []interface{}{2.0, 2.2}\n\/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n\/\/ []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n","canonical_solution":"package find_closest_elements_test\n\nimport (\n    \"math\"\n    \"sort\"\n)\n\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n    \n    \/\/ Create a sorted copy of the numbers\n    sortedNumbers := make([]float64, len(numbers))\n    copy(sortedNumbers, numbers)\n    sort.Float64s(sortedNumbers)\n    \n    \/\/ Initialize the minimum difference and result\n    minDiff := math.MaxFloat64\n    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}\n    \n    \/\/ Iterate over the sorted numbers to find the closest pair\n    for i := 1; i < len(sortedNumbers); i++ {\n        diff := sortedNumbers[i] - sortedNumbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            result[0] = sortedNumbers[i-1]\n            result[1] = sortedNumbers[i]\n        }\n    }\n    \n    return result\n}","tests":"func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_21","nl":"hrv_Latn","pl":"go_test.go","prompt":"package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Tako da će najmanji broj postati 0 a najveći broj 1 .\/\/Ako je data lista brojeva (od najmanje dva elementa), primijenite linearnu transformaciju na tu listu, \/\/ >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\/\/ []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64) []float64 {\n","canonical_solution":"package rescale_to_unit_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc rescale_to_unit(numbers []float64) []float64 {\n\tif len(numbers) < 2 {\n\t\treturn numbers\n\t}\n\t\n\tminVal := numbers[0]\n\tmaxVal := numbers[0]\n\tfor _, num := range numbers {\n\t\tif num < minVal {\n\t\t\tminVal = num\n\t\t} else if num > maxVal {\n\t\t\tmaxVal = num\n\t\t}\n\t}\n\n\tscale := maxVal - minVal\n\tif scale == 0 {\n\t\treturn make([]float64, len(numbers))\n\t}\n\n\trescaled := make([]float64, len(numbers))\n\tfor i, num := range numbers {\n\t\trescaled[i] = (num - minVal) \/ scale\n\t}\n\n\treturn rescaled\n}\n\nfunc TestRescaleToUnit(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},\n\t\t{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},\n\t\t{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := rescale_to_unit(test.input)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}","tests":"func TestRescale_To_Unit(t *testing.T) {\n  candidate := rescale_to_unit\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },\n     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },\n     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_22","nl":"hrv_Latn","pl":"go_test.go","prompt":"package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Filter date liste bilo koje gothon vrijednosti samo za cijele brojeve \/\/ >>> filter_integers([]float64{\"a\", 3.14, 5})\n\/\/ []int{5}\n\/\/ >>> filter_integers([]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}})\n\/\/ []int{1, 2, 3}\nfunc filter_integers(values []interface{}) []int {\n","canonical_solution":"func filter_integers(values []interface{}) []int {\n    var result []int\n    for _, v := range values {\n        if intValue, ok := v.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n\nfunc TestFilterIntegers(t *testing.T) {\n    cases := []struct {\n        input    []interface{}\n        expected []int\n    }{\n        {\n            input:    []interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n            expected: []int{1, 2, 3},\n        },\n        {\n            input:    []interface{}{\"a\", 3.14, 5},\n            expected: []int{5},\n        },\n    }\n\n    for _, c := range cases {\n        result := filter_integers(c.input)\n        if !equal(result, c.expected) {\n            t.Errorf(\"filter_integers(%v) == %v, expected %v\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_23","nl":"hrv_Latn","pl":"go_test.go","prompt":"package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vratite dužinu datog niza.\/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunc strlen(myString string) int {\n","canonical_solution":"return len(myString)\n}","tests":"func TestStrlen(t *testing.T) {\n  candidate := strlen\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"x\"), expected: 1 },\n     { actual: candidate(\"asdasnakj\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_24","nl":"hrv_Latn","pl":"go_test.go","prompt":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Za dan broj n, pronađite najveći broj koji n podijeli ravnomjerno, manji od n \/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n","canonical_solution":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n    for i := n\/2; i > 0; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1\n}\n\nfunc TestLargestDivisor(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {15, 5},\n        {100, 50},\n        {49, 7},\n        {81, 27},\n        {1, 1},\n    }\n\n    for _, c := range cases {\n        result := largest_divisor(c.input)\n        if result != c.expected {\n            t.Errorf(\"largest_divisor(%d) == %d, expected %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(largest_divisor(15))\n}","tests":"func TestLargest_Divisor(t *testing.T) {\n  candidate := largest_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: 1 },\n     { actual: candidate(7), expected: 1 },\n     { actual: candidate(10), expected: 5 },\n     { actual: candidate(100), expected: 50 },\n     { actual: candidate(49), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_25","nl":"hrv_Latn","pl":"go_test.go","prompt":"package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Broj ulaza treba biti jednak proizvodu svih faktora.\/\/Svaki od faktora treba navesti broj puta koji odgovara broju puta u kojima se pojavljuje u faktorizaciji.\/\/Vraća popis primarnih činitelja datog broja u redoslijedu od najmanjeg do najvećeg.\/\/ >>> factorize(8)\n\/\/ []int{2, 2, 2}\n\/\/ >>> factorize(25)\n\/\/ []int{5, 5}\n\/\/ >>> factorize(70)\n\/\/ []int{2, 5, 7}\nfunc factorize(n int) []int {\n","canonical_solution":"package factorize\n\nfunc factorize(n int) []int {\n\tvar factors []int\n\tfor i := 2; i*i <= n; i++ {\n\t\tfor n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn \/= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}","tests":"func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_26","nl":"hrv_Latn","pl":"go_test.go","prompt":"package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ostavite redoslijed elemenata isti kao i u ulazu.\/\/Iz popisa cijelih brojeva, uklonite sve elemente koji se pojavljuju više od jednom.\/\/ >>> remove_duplicates([]int{1, 2, 3, 2, 4})\n\/\/ []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n","canonical_solution":"package remove_duplicates_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc remove_duplicates(numbers []int) []int {\n\tcounts := make(map[int]int)\n\tfor _, num := range numbers {\n\t\tcounts[num]++\n\t}\n\n\tresult := []int{}\n\tfor _, num := range numbers {\n\t\tif counts[num] == 1 {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestRemoveDuplicates(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},\n\t\t{[]int{1, 1, 1, 1}, []int{}},\n\t\t{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},\n\t\t{[]int{5, 5, 5, 6}, []int{6}},\n\t\t{[]int{9, 8, 9, 8, 7}, []int{7}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"remove_duplicates(%v)\", test.input), func(t *testing.T) {\n\t\t\tresult := remove_duplicates(test.input)\n\t\t\tif len(result) != len(test.expected) {\n\t\t\t\tt.Errorf(\"Expected length %d, got %d\", len(test.expected), len(result))\n\t\t\t}\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", test.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_27","nl":"hrv_Latn","pl":"go_test.go","prompt":"package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Za dat niz, prebacite male znakove u velike i velike u male. \/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunc flip_case(myString string) string {\n","canonical_solution":"func flip_case(myString string) string {\n\tvar result []rune\n\tfor _, char := range myString {\n\t\tif char >= 'a' && char <= 'z' {\n\t\t\tresult = append(result, char-('a'-'A'))\n\t\t} else if char >= 'A' && char <= 'Z' {\n\t\t\tresult = append(result, char+('a'-'A'))\n\t\t} else {\n\t\t\tresult = append(result, char)\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestFlip_Case(t *testing.T) {\n  candidate := flip_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hello!\"), expected: \"hELLO!\" },\n     { actual: candidate(\"These violent delights have violent ends\"), expected: \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_28","nl":"hrv_Latn","pl":"go_test.go","prompt":"package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Da li je moguće da se sve strune povežu u jedan niz?\/\/ >>> concatenate([]string{})\n\/\/ \"\"\n\/\/ >>> concatenate([]string{\"a\", \"b\", \"c\"})\n\/\/ \"abc\"\nfunc concatenate(strings []string) string {\n","canonical_solution":"result := \"\"\n    for _, str := range strings {\n        result += str\n    }\n    return result\n}","tests":"func TestConcatenate(t *testing.T) {\n  candidate := concatenate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}), expected: \"\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\"}), expected: \"xyz\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\", \"w\", \"k\"}), expected: \"xyzwk\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_29","nl":"hrv_Latn","pl":"go_test.go","prompt":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Filtrirajte ulaznu listu niza samo za one koji počinju određenim prefiksom.\/\/ >>> filter_by_prefix([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"array\"}\nfunc filter_by_prefix(strings []string, prefix string) []string {\n","canonical_solution":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Filter an input list of strings only for ones that start with a given prefix.\nfunc filter_by_prefix(strings []string, prefix string) []string {\n    var result []string\n    for _, str := range strings {\n        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterByPrefix(t *testing.T) {\n    tests := []struct {\n        input    []string\n        prefix   string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"array\"}},\n        {[]string{\"hello\", \"helium\", \"world\"}, \"he\", []string{\"hello\", \"helium\"}},\n        {[]string{\"banana\", \"band\", \"bandana\"}, \"ban\", []string{\"banana\", \"band\", \"bandana\"}},\n        {[]string{\"apple\", \"ape\", \"apricot\"}, \"ap\", []string{\"apple\", \"ape\", \"apricot\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_prefix(test.input, test.prefix)\n        if !equal(result, test.expected) {\n            t.Errorf(\"filter_by_prefix(%v, %s) = %v; expected %v\", test.input, test.prefix, result, test.expected)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_By_Prefix(t *testing.T) {\n  candidate := filter_by_prefix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_30","nl":"hrv_Latn","pl":"go_test.go","prompt":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća samo pozitivne brojeve iz popisa. \/\/ >>> get_positive([]int{-1, 2, -4, 5, 6})\n\/\/ []int{2, 5, 6}\n\/\/ >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int {\n","canonical_solution":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return only positive numbers in the list.\nfunc get_positive(l []int) []int {\n    var positiveNumbers []int\n    for _, num := range l {\n        if num > 0 {\n            positiveNumbers = append(positiveNumbers, num)\n        }\n    }\n    return positiveNumbers\n}\n\nfunc TestGetPositive(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output []int\n    }{\n        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},\n    }\n    \n    for _, test := range tests {\n        result := get_positive(test.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", test.output) {\n            t.Errorf(\"Expected %v, got %v\", test.output, result)\n        }\n    }\n}","tests":"func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1, -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_31","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vrati vrijednost istinita ako je dat broj prvi, i lažna u suprotnom.\/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunc is_prime(n int) bool {\n","canonical_solution":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_prime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPrime(t *testing.T) {\n    testCases := []struct {\n        number   int\n        expected bool\n    }{\n        {6, false},\n        {101, true},\n        {11, true},\n        {13441, true},\n        {61, true},\n        {4, false},\n        {1, false},\n    }\n\n    for _, testCase := range testCases {\n        result := is_prime(testCase.number)\n        if result != testCase.expected {\n            t.Errorf(\"is_prime(%d) = %v; want %v\", testCase.number, result, testCase.expected)\n        } else {\n            fmt.Printf(\"Test Passed: is_prime(%d) = %v\\n\", testCase.number, result)\n        }\n    }\n}","tests":"func TestIs_Prime(t *testing.T) {\n  candidate := is_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(6), expected: false },\n     { actual: candidate(101), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(13441), expected: true },\n     { actual: candidate(61), expected: true },\n     { actual: candidate(4), expected: false },\n     { actual: candidate(1), expected: false },\n     { actual: candidate(5), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(17), expected: true },\n     { actual: candidate(85), expected: false },\n     { actual: candidate(77), expected: false },\n     { actual: candidate(255379), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_33","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/U skladu s člankom 2. stavkom 1.\/\/l' je identičan l u indeksu koji se ne dijeli s troje, dok su njegove vrijednosti u indeksu koji se dijeli s troje jednake \/\/Ova funkcija uzima popis l i vraća popis l' takvog da \/\/ >>> sort_third([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n\/\/ []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n","canonical_solution":"package sort_third_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_third(l []int) []int {\n    type pair struct {\n        index int\n        value int\n    }\n\n    \/\/ Collect the pairs where indices are divisible by 3\n    sortSection := []pair{}\n\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            sortSection = append(sortSection, pair{index: i, value: l[i]})\n        }\n    }\n\n    \/\/ Sort this section based on the values\n    sort.Slice(sortSection, func(i, j int) bool {\n        return sortSection[i].value < sortSection[j].value\n    })\n\n    \/\/ Generate result slice\n    result := make([]int, len(l))\n    copy(result, l)\n\n    \/\/ Fill the sorted values back to the result\n    for _, p := range sortSection {\n        result[p.index] = p.value\n    }\n\n    return result\n}","tests":"func TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_34","nl":"hrv_Latn","pl":"go_test.go","prompt":"package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća sortirane jedinstvene elemente u listi\/\/ >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{0, 2, 3, 5, 9, 123}\nfunc unique(l []int) []int {\n","canonical_solution":"package unique_test\n\nimport (\n    \"sort\"\n)\n\nfunc unique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    for _, value := range l {\n        uniqueMap[value] = true\n    }\n\n    uniqueSlice := make([]int, 0, len(uniqueMap))\n    for key := range uniqueMap {\n        uniqueSlice = append(uniqueSlice, key)\n    }\n\n    sort.Ints(uniqueSlice)\n    return uniqueSlice\n}","tests":"func TestUnique(t *testing.T) {\n  candidate := unique\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_35","nl":"hrv_Latn","pl":"go_test.go","prompt":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća najveći element u popisu. \/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n","canonical_solution":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return maximum element in the list.\n\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n    if len(l) == 0 {\n        panic(\"Empty list has no maximum value\")\n    }\n    max := l[0]\n    for _, value := range l {\n        if value > max {\n            max = value\n        }\n    }\n    return max\n}\n\nfunc TestMaxElement(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 3},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},\n        {[]int{-1, -2, -3, -4}, -1},\n        {[]int{9, 9, 9, 9}, 9},\n    }\n\n    for _, testCase := range testCases {\n        result := max_element(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input %v, expected %d, got %d\", testCase.input, testCase.expected, result)\n        }\n    }\n}","tests":"func TestMax_Element(t *testing.T) {\n  candidate := max_element\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 3 },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_36","nl":"hrv_Latn","pl":"go_test.go","prompt":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća broj puta broja 7 koji se pojavljuje u cijelim brojevima manjim od n koji su podijeljivi s 11 ili 13. \/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunc fizz_buzz(n int) int {\n","canonical_solution":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc fizz_buzz(n int) int {\n    count := 0\n    for i := 0; i < n; i++ {\n        if i % 11 == 0 || i % 13 == 0 {\n            count += countSevens(i)\n        }\n    }\n    return count\n}\n\nfunc countSevens(num int) int {\n    strNum := strconv.Itoa(num)\n    count := 0\n    for _, c := range strNum {\n        if c == '7' {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestFizzBuzz(t *testing.T) {\n    tests := []struct {\n        input int\n        expected int\n    }{\n        {50, 0},\n        {78, 2},\n        {79, 3},\n    }\n\n    for _, test := range tests {\n        result := fizz_buzz(test.input)\n        if result != test.expected {\n            t.Errorf(\"fizz_buzz(%d) = %d; expected %d\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(fizz_buzz(50)) \/\/ 0\n    fmt.Println(fizz_buzz(78)) \/\/ 2\n    fmt.Println(fizz_buzz(79)) \/\/ 3\n}","tests":"func TestFizz_Buzz(t *testing.T) {\n  candidate := fizz_buzz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(50), expected: 0 },\n     { actual: candidate(78), expected: 2 },\n     { actual: candidate(79), expected: 3 },\n     { actual: candidate(100), expected: 3 },\n     { actual: candidate(200), expected: 6 },\n     { actual: candidate(4000), expected: 192 },\n     { actual: candidate(10000), expected: 639 },\n     { actual: candidate(100000), expected: 8026 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_37","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/To je ujedno i najvažniji faktor za procjenu vrijednosti.\/\/l' je identičan l u neparnim indeksima, dok su njegove vrijednosti u parnim indeksima jednake \/\/Ova funkcija uzima popis l i vraća popis l' takvog da \/\/ >>> sort_even([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_even([]int{5, 6, 3, 4})\n\/\/ []int{3, 6, 5, 4}\nfunc sort_even(l []int) []int {\n","canonical_solution":"package sort_even_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_even(l []int) []int {\n    if len(l) < 2 {\n        return l\n    }\n    \n    \/\/ Extract even indices\n    evens := []int{}\n    for i := 0; i < len(l); i += 2 {\n        evens = append(evens, l[i])\n    }\n    \n    \/\/ Sort even-indexed elements\n    sort.Ints(evens)\n    \n    \/\/ Merge sorted evens back into the original list\n    j := 0\n    for i := 0; i < len(l); i += 2 {\n        l[i] = evens[j]\n        j++\n    }\n\n    return l\n}","tests":"func TestSort_Even(t *testing.T) {\n  candidate := sort_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },\n     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_39","nl":"hrv_Latn","pl":"go_test.go","prompt":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/prime_fib vraća n-ti broj koji je Fibonaccijev broj i također je prvi. \/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunc prime_fib(n int) int {\n","canonical_solution":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ isPrime checks if a number is prime\nfunc isPrime(num int) bool {\n    if num <= 1 {\n        return false\n    }\n    if num <= 3 {\n        return true\n    }\n    if num%2 == 0 || num%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= num; i += 6 {\n        if num%i == 0 || num%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nfunc prime_fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    a, b := 1, 1\n    count := 0\n    for count < n {\n        a, b = b, a+b\n        if isPrime(a) {\n            count++\n        }\n    }\n    return a\n}\n\nfunc TestPrimeFib(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {1, 2},\n        {2, 3},\n        {3, 5},\n        {4, 13},\n        {5, 89},\n    }\n\n    for _, test := range tests {\n        result := prime_fib(test.input)\n        if result != test.expected {\n            t.Errorf(\"prime_fib(%d) = %d; expected %d\", test.input, result, test.expected)\n        } else {\n            fmt.Printf(\"prime_fib(%d) = %d\\n\", test.input, result)\n        }\n    }\n}","tests":"func TestPrime_Fib(t *testing.T) {\n  candidate := prime_fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 2 },\n     { actual: candidate(2), expected: 3 },\n     { actual: candidate(3), expected: 5 },\n     { actual: candidate(4), expected: 13 },\n     { actual: candidate(5), expected: 89 },\n     { actual: candidate(6), expected: 233 },\n     { actual: candidate(7), expected: 1597 },\n     { actual: candidate(8), expected: 28657 },\n     { actual: candidate(9), expected: 514229 },\n     { actual: candidate(10), expected: 433494437 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_40","nl":"hrv_Latn","pl":"go_test.go","prompt":"package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sumi na nulu, i pogrešno inače.\/\/vraća vrijednost istinita ako su u popisu tri različita elementa koja \/\/triples_sum_to_zero uzima popis cijelih brojeva kao ulaz.\/\/ >>> triples_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1})\n\/\/ false\nfunc triples_sum_to_zero(l []int) bool {\n","canonical_solution":"func triples_sum_to_zero(l []int) bool {\n    n := len(l)\n    if n < 3 {\n        return false\n    }\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}\n\nfunc TestTriplesSumToZero(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, true},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 9, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, test := range tests {\n        result := triples_sum_to_zero(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %v, expected %v, got %v\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1}))              \/\/ false\n}","tests":"func TestTriples_Sum_To_Zero(t *testing.T) {\n  candidate := triples_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -1}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{1, 2, 5, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -100}), expected: false },\n     { actual: candidate([]int{100, 3, 5, -100}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_41","nl":"hrv_Latn","pl":"go_test.go","prompt":"package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ova funkcija daje broj takvih sudara. \/\/U svojoj putanji kao da se nisu sudarili.\/\/Međutim, kola su beskrajno čvrsta i jaka; kao rezultat toga, oni se nastavljaju kretati.\/\/Kada auto koji se kreće s lijeva na desno udari auto koji se kreće s desna na lijevo.\/\/Svi se automobili kreću istom brzinom.\/\/Dva para automobila su počela vrlo daleko od...\/\/n automobila vozi s lijeva na desno; istovremeno, drugačiji skup od n automobila \/\/Zamislite put koji je savršeno ravna beskonačno duga linija.func car_race_collision(n int) int {\n","canonical_solution":"package car_race_collision_test\n\nimport (\n    \"testing\"\n)\n\nfunc car_race_collision(n int) int {\n    return n\n}\n\nfunc TestCarRaceCollision(t *testing.T) {\n    cases := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 2},\n        {3, 3},\n        {10, 10},\n        {0, 0},\n    }\n\n    for _, c := range cases {\n        result := car_race_collision(c.n)\n        if result != c.expected {\n            t.Errorf(\"car_race_collision(%d) == %d, expected %d\", c.n, result, c.expected)\n        }\n    }\n}","tests":"func TestCar_Race_Collision(t *testing.T) {\n  candidate := car_race_collision\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 4 },\n     { actual: candidate(3), expected: 9 },\n     { actual: candidate(4), expected: 16 },\n     { actual: candidate(8), expected: 64 },\n     { actual: candidate(10), expected: 100 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_42","nl":"hrv_Latn","pl":"go_test.go","prompt":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Popis povratnih elemenata povećan za 1. \/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n","canonical_solution":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list with elements incremented by 1.\n\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n    result := make([]int, len(l))\n    for i, val := range l {\n        result[i] = val + 1\n    }\n    return result\n}\n\nfunc TestIncrList(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{1, 2, 3}, []int{2, 3, 4}},\n        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},\n    }\n\n    for _, c := range cases {\n        result := incr_list(c.input)\n        for i := range result {\n            if result[i] != c.expected[i] {\n                t.Errorf(\"incr_list(%v) == %v, expected %v\", c.input, result, c.expected)\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(incr_list([]int{1, 2, 3}))          \/\/ should print [2, 3, 4]\n    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) \/\/ should print [6, 4, 6, 3, 4, 4, 10, 1, 124]\n}","tests":"func TestIncr_List(t *testing.T) {\n  candidate := incr_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },\n     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_43","nl":"hrv_Latn","pl":"go_test.go","prompt":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sumi na nulu, i pogrešno inače.\/\/vraća vrijednost istinita ako postoje dva različita elementa na popisu koji \/\/pairs_sum_to_zero uzima popis cijelih brojeva kao ulaz. \/\/ >>> pairs_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([]int{1})\n\/\/ false\nfunc pairs_sum_to_zero(l []int) bool {\n","canonical_solution":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pairs_sum_to_zero(l []int) bool {\n    numSet := make(map[int]struct{})\n    for _, num := range l {\n        if _, found := numSet[-num]; found {\n            return true\n        }\n        numSet[num] = struct{}{}\n    }\n    return false\n}\n\nfunc TestPairsSumToZero(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, false},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 5, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, tc := range testCases {\n        result := pairs_sum_to_zero(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"pairs_sum_to_zero(%v) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %v, result: %v\\n\", tc.input, result)\n        }\n    }\n}","tests":"func TestPairs_Sum_To_Zero(t *testing.T) {\n  candidate := pairs_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_44","nl":"hrv_Latn","pl":"go_test.go","prompt":"package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Broj baze je manji od 10.\/\/povratni string prikaz nakon pretvorbe. \/\/Promjenite numeričku bazu ulaznog broja x u bazu.\/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunc change_base(x int, base int) string {\n","canonical_solution":"package change_base_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc change_base(x int, base int) string {\n    if base < 2 || base > 9 {\n        return \"\"\n    }\n\n    result := \"\"\n    for x > 0 {\n        remainder := x % base\n        result = strconv.Itoa(remainder) + result\n        x = x \/ base\n    }\n    \n    if result == \"\" {\n        return \"0\"\n    }\n    return result\n}\n\nfunc TestChangeBase(t *testing.T) {\n    tests := []struct {\n        x      int\n        base   int\n        result string\n    }{\n        {8, 3, \"22\"},\n        {8, 2, \"1000\"},\n        {7, 2, \"111\"},\n        {0, 2, \"0\"},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d to base %d\", test.x, test.base), func(t *testing.T) {\n            res := change_base(test.x, test.base)\n            if res != test.result {\n                t.Errorf(\"expected %s, got %s\", test.result, res)\n            }\n        })\n    }\n}","tests":"func TestChange_Base(t *testing.T) {\n  candidate := change_base\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(8, 3), expected: \"22\" },\n     { actual: candidate(9, 3), expected: \"100\" },\n     { actual: candidate(234, 2), expected: \"11101010\" },\n     { actual: candidate(16, 2), expected: \"10000\" },\n     { actual: candidate(8, 2), expected: \"1000\" },\n     { actual: candidate(7, 2), expected: \"111\" },\n     { actual: candidate(2, 3), expected: \"2\" },\n     { actual: candidate(3, 4), expected: \"3\" },\n     { actual: candidate(4, 5), expected: \"4\" },\n     { actual: candidate(5, 6), expected: \"5\" },\n     { actual: candidate(6, 7), expected: \"6\" },\n     { actual: candidate(7, 8), expected: \"7\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_45","nl":"hrv_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/S obzirom na dužinu strane i visoku površinu povratka za trougao.\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given length of a side and height return area for a triangle.\n\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n    return 0.5 * float64(a) * float64(h)\n}\n\nfunc TestTriangleArea(t *testing.T) {\n    cases := []struct {\n        a, h int\n        expected float64\n    }{\n        {5, 3, 7.5},\n        {6, 4, 12.0},\n        {10, 2, 10.0},\n        {8, 5, 20.0},\n    }\n    \n    for _, c := range cases {\n        result := triangle_area(c.a, c.h)\n        if result != c.expected {\n            t.Errorf(\"triangle_area(%d, %d) == %f, expected %f\", c.a, c.h, result, c.expected)\n        } else {\n            fmt.Printf(\"triangle_area(%d, %d) == %f\\n\", c.a, c.h, result)\n        }\n    }\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 3), expected: 7.5 },\n     { actual: candidate(2, 2), expected: 2.0 },\n     { actual: candidate(10, 8), expected: 40.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_46","nl":"hrv_Latn","pl":"go_test.go","prompt":"package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Molimo napišite funkciju koja će učinkovito izračunati n-ti element fib4 niza brojeva.\/\/(i) u slučaju da se ne može utvrditi da je to uobičajeno,\/\/- Da, da, da, da, da, da, da, da.\/\/- Da, da, da.\/\/- Da, da, da, da, da, da, da, da, da.\/\/fib4 ((0)) -> 0 \/\/Fib4 brojni niz je niz sličan Fibbonaccijevom nizu koji je definiran na sljedeći način: \/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunc fib4(n int) int {\n","canonical_solution":"func fib4(n int) int {\n    if n < 0 {\n        return 0\n    }\n    \n    seq := []int{0, 0, 2, 0}\n    \n    if n < 4 {\n        return seq[n]\n    }\n    \n    for i := 4; i <= n; i++ {\n        next := seq[0] + seq[1] + seq[2] + seq[3]\n        seq[0] = seq[1]\n        seq[1] = seq[2]\n        seq[2] = seq[3]\n        seq[3] = next\n    }\n    \n    return seq[3]\n}","tests":"func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_47","nl":"hrv_Latn","pl":"go_test.go","prompt":"package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Povratna medijana elemenata na popisu l. \/\/ >>> median([]int{3, 1, 2, 4, 5})\n\/\/ 3\n\/\/ >>> median([]int{-10, 4, 6, 1000, 10, 20})\n\/\/ 15.0\nfunc median(l []int) float64 {\n","canonical_solution":"package median_test\n\nimport (\n    \"sort\"\n)\n\nfunc median(l []int) float64 {\n    sort.Ints(l)\n    n := len(l)\n    if n%2 == 1 {\n        return float64(l[n\/2])\n    }\n    mid1, mid2 := l[(n\/2)-1], l[n\/2]\n    return float64(mid1+mid2) \/ 2.0\n}","tests":"func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}), expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_48","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Provjerava je li dat niz palindrom.\/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunc is_palindrome(text string) bool {\n","canonical_solution":"package is_palindrome_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    n := len(text)\n    for i := 0; i < n\/2; i++ {\n        if text[i] != text[n-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"\", true},\n        {\"aba\", true},\n        {\"aaaaa\", true},\n        {\"zbcd\", false},\n    }\n\n    for _, test := range tests {\n        result := is_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %v, but got %v\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_49","nl":"hrv_Latn","pl":"go_test.go","prompt":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vratite 2^n modulo p (budu svjesni brojeva).\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunc modp(n int, p int) int {\n","canonical_solution":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return 2^n modulo p (be aware of numerics).\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n    }\n    result := 1\n    base := 2\n    for n > 0 {\n        if n%2 == 1 {\n            result = (result * base) % p\n        }\n        base = (base * base) % p\n        n \/= 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T) {\n    tests := []struct {\n        n, p int\n        expected int\n    }{\n        {3, 5, 3},\n        {1101, 101, 2},\n        {0, 101, 1},\n        {3, 11, 8},\n        {100, 101, 1},\n    }\n\n    for _, test := range tests {\n        result := modp(test.n, test.p)\n        if result != test.expected {\n            t.Errorf(\"modp(%d, %d) = %d; expected %d\", test.n, test.p, result, test.expected)\n        } else {\n            fmt.Printf(\"modp(%d, %d) = %d; passed\\n\", test.n, test.p, result)\n        }\n    }\n}","tests":"func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_51","nl":"hrv_Latn","pl":"go_test.go","prompt":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/remove_vowels je funkcija koja uzima niz i vraća niz bez samoglasnika. \/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunc remove_vowels(text string) string {\n","canonical_solution":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc remove_vowels(text string) string {\n    vowels := \"aeiouAEIOU\"\n    var result strings.Builder\n    for _, char := range text {\n        if !strings.ContainsRune(vowels, char) {\n            result.WriteRune(char)\n        }\n    }\n    return result.String()\n}\n\nfunc TestRemoveVowels(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"abcdef\", \"bcdf\"},\n        {\"aaaaa\", \"\"},\n        {\"aaBAA\", \"B\"},\n        {\"zbcd\", \"zbcd\"},\n    }\n\n    for _, test := range tests {\n        if output := remove_vowels(test.input); output != test.expected {\n            t.Errorf(\"remove_vowels(%q) = %q; expected %q\", test.input, output, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    test := &testing.T{}\n    TestRemoveVowels(test)\n    if test.Failed() {\n        fmt.Println(\"Tests failed!\")\n    } else {\n        fmt.Println(\"All tests passed!\")\n    }\n}","tests":"func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual: candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_52","nl":"hrv_Latn","pl":"go_test.go","prompt":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vratiti vrijednost true ako su svi brojevi u popisu l ispod praga t. \/\/ >>> below_threshold([]int{1, 2, 4, 10}, 100)\n\/\/ true\n\/\/ >>> below_threshold([]int{1, 20, 4, 10}, 5)\n\/\/ false\nfunc below_threshold(l []int, t int) bool {\n","canonical_solution":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if all numbers in the list l are below threshold t.\nfunc below_threshold(l []int, t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ Example test cases\nfunc TestBelowThreshold(t *testing.T) {\n    if !below_threshold([]int{1, 2, 4, 10}, 100) {\n        t.Error(\"Expected true, got false\")\n    }\n    if below_threshold([]int{1, 20, 4, 10}, 5) {\n        t.Error(\"Expected false, got true\")\n    }\n}\n\nfunc main() {\n    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) \/\/ true\n    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  \/\/ false\n}","tests":"func TestBelow_Threshold(t *testing.T) {\n  candidate := below_threshold\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },\n     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_53","nl":"hrv_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Dodaj dva broja x i y.\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n","canonical_solution":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Add two numbers x and y\n\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc TestAdd(t *testing.T) {\n    testCases := []struct {\n        x, y, expected int\n    }{\n        {2, 3, 5},\n        {5, 7, 12},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"add(%d,%d)\", tc.x, tc.y), func(t *testing.T) {\n            result := add(tc.x, tc.y)\n            if result != tc.expected {\n                t.Errorf(\"Expected %d, got %d\", tc.expected, result)\n            }\n        })\n    }\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0, 1), expected: 1 },\n     { actual: candidate(1, 0), expected: 1 },\n     { actual: candidate(2, 3), expected: 5 },\n     { actual: candidate(5, 7), expected: 12 },\n     { actual: candidate(7, 5), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_54","nl":"hrv_Latn","pl":"go_test.go","prompt":"package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Provjerite imaju li dvije riječi iste znakove.\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunc same_chars(s0 string, s1 string) bool {\n","canonical_solution":"package same_chars_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc same_chars(s0 string, s1 string) bool {\n\tcountChars := func(s string) map[rune]int {\n\t\tcount := make(map[rune]int)\n\t\tfor _, char := range s {\n\t\t\tcount[char]++\n\t\t}\n\t\treturn count\n\t}\n\n\tcount0 := countChars(s0)\n\tcount1 := countChars(s1)\n\n\tfor char := range count0 {\n\t\tif count1[char] < count0[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor char := range count1 {\n\t\tif count0[char] < count1[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc TestSameChars(t *testing.T) {\n\ttests := []struct {\n\t\ts0     string\n\t\ts1     string\n\t\tresult bool\n\t}{\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddeddabc\", true},\n\t\t{\"abcd\", \"dddddddabc\", true},\n\t\t{\"dddddddabc\", \"abcd\", true},\n\t\t{\"eabcd\", \"dddddddabc\", false},\n\t\t{\"abcd\", \"dddddddabce\", false},\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddddabc\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s vs %s\", test.s0, test.s1), func(t *testing.T) {\n\t\t\tif got := same_chars(test.s0, test.s1); got != test.result {\n\t\t\t\tt.Errorf(\"same_chars(%q, %q) = %v; want %v\", test.s0, test.s1, got, test.result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSame_Chars(t *testing.T) {\n  candidate := same_chars\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"), expected: true },\n     { actual: candidate(\"abcd\", \"dddddddabc\"), expected: true },\n     { actual: candidate(\"dddddddabc\", \"abcd\"), expected: true },\n     { actual: candidate(\"eabcd\", \"dddddddabc\"), expected: false },\n     { actual: candidate(\"abcd\", \"dddddddabcf\"), expected: false },\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"), expected: false },\n     { actual: candidate(\"aabb\", \"aaccc\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_55","nl":"hrv_Latn","pl":"go_test.go","prompt":"package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vratite n-ti Fibonaccijev broj. \/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunc fib(n int) int {\n","canonical_solution":"if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}","tests":"func TestFib(t *testing.T) {\n  candidate := fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10), expected: 55 },\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(8), expected: 21 },\n     { actual: candidate(11), expected: 89 },\n     { actual: candidate(12), expected: 144 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_56","nl":"hrv_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/return true ako svaka otvorena zagrada ima odgovarajuću zatvaranju zagrada. \/\/brackets je niz \"<\" i \">\". \/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '<' {\n            balance++\n        } else if char == '>' {\n            balance--\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected bool\n    }{\n        {input: \"<\", expected: false},\n        {input: \"<>\", expected: true},\n        {input: \"<<><>>\", expected: true},\n        {input: \"><<>\", expected: false},\n        {input: \"<<>>\", expected: true},\n        {input: \"><\", expected: false},\n    }\n\n    for _, tc := range testCases {\n        result := correct_bracketing(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %q\\n\", tc.input)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_57","nl":"hrv_Latn","pl":"go_test.go","prompt":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća vrijednost istinita ako su elementi popisa monotonski rastući ili opadajući.\/\/ >>> monotonic([]int{1, 2, 4, 20})\n\/\/ true\n\/\/ >>> monotonic([]int{1, 20, 4, 10})\n\/\/ false\n\/\/ >>> monotonic([]int{4, 1, 0, -10})\n\/\/ true\nfunc monotonic(l []int) bool {\n","canonical_solution":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if list elements are monotonically increasing or decreasing.\nfunc monotonic(l []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    increasing := true\n    decreasing := true\n\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n        }\n        if l[i] < l[i-1] {\n            increasing = false\n        }\n    }\n\n    return increasing || decreasing\n}\n\nfunc TestMonotonic(t *testing.T) {\n    fmt.Println(monotonic([]int{1, 2, 4, 20})) \/\/ true\n    fmt.Println(monotonic([]int{1, 20, 4, 10})) \/\/ false\n    fmt.Println(monotonic([]int{4, 1, 0, -10})) \/\/ true\n}","tests":"func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_58","nl":"hrv_Latn","pl":"go_test.go","prompt":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vraća sortirane jedinstvene zajedničke elemente za dvije liste.\/\/ >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n\/\/ []int{1, 5, 653}\n\/\/ >>> common([]int{5, 3, 2, 8}, []int{3, 2})\n\/\/ []int{2, 3}\nfunc common(l1 []int, l2 []int) []int {\n","canonical_solution":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc common(l1 []int, l2 []int) []int {\n    set1 := make(map[int]struct{})\n    set2 := make(map[int]struct{})\n    commonSet := make(map[int]struct{})\n    \n    \/\/ Fill set1 with elements of l1\n    for _, num := range l1 {\n        set1[num] = struct{}{}\n    }\n    \n    \/\/ Fill set2 with elements of l2\n    for _, num := range l2 {\n        if _, found := set1[num]; found {\n            commonSet[num] = struct{}{}\n        }\n        set2[num] = struct{}{}\n    }\n    \n    result := make([]int, 0, len(commonSet))\n    \n    \/\/ Collect common elements\n    for num := range commonSet {\n        result = append(result, num)\n    }\n    \n    \/\/ Sort the result\n    sort.Ints(result)\n    \n    return result\n}\n\nfunc TestCommon(t *testing.T) {\n    cases := []struct {\n        l1, l2 []int\n        expected []int\n    }{\n        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},\n        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},\n    }\n    \n    for _, c := range cases {\n        result := common(c.l1, c.l2)\n        if !equal(result, c.expected) {\n            t.Errorf(\"common(%v, %v) == %v, expected %v\", c.l1, c.l2, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_59","nl":"hrv_Latn","pl":"go_test.go","prompt":"package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vratite najveći primarni faktor od n. Pretpostavimo da je n > 1 i nije primarno. \/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunc largest_prime_factor(n int) int {\n","canonical_solution":"package largest_prime_factor_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc largest_prime_factor(n int) int {\n\tlargestFactor := 1\n\tdiv := 2\n\n\tfor n > 1 {\n\t\tif n%div == 0 {\n\t\t\tlargestFactor = div\n\t\t\tn \/= div\n\t\t} else {\n\t\t\tdiv++\n\t\t}\n\t}\n\n\treturn largestFactor\n}\n\nfunc TestLargestPrimeFactor(t *testing.T) {\n\ttests := []struct{\n\t\tn int\n\t\texpected int\n\t} {\n\t\t{13195, 29},\n\t\t{2048, 2},\n\t\t{123456, 643},\n\t\t{100, 5},\n\t\t{999, 37},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d\", test.n), func(t *testing.T) {\n\t\t\tif result := largest_prime_factor(test.n); result != test.expected {\n\t\t\t\tt.Errorf(\"largest_prime_factor(%d) = %d; expected %d\", test.n, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual: candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195), expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_60","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/sum_to_n je funkcija koja zbrojiti brojeve od 1 do n. \/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunc sum_to_n(n int) int {\n","canonical_solution":"func sum_to_n(n int) int {\n    return n * (n + 1) \/ 2\n}\n\nfunc TestSumToN(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {30, 465},\n        {100, 5050},\n        {5, 15},\n        {10, 55},\n        {1, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"sum_to_n(%d)\", test.input), func(t *testing.T) {\n            result := sum_to_n(test.input)\n            if result != test.expected {\n                t.Errorf(\"Expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestSum_To_N(t *testing.T) {\n  candidate := sum_to_n\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(6), expected: 21 },\n     { actual: candidate(11), expected: 66 },\n     { actual: candidate(30), expected: 465 },\n     { actual: candidate(100), expected: 5050 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_61","nl":"hrv_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/return true ako svaka otvorena zagrada ima odgovarajuću zatvaranju zagrada. \/\/brackets je niz \"(\" i \")\". \/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '(' {\n            balance++\n        } else if char == ')' {\n            balance--\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"(\", false},\n        {\"()\", true},\n        {\"(()())\", true},\n        {\")(()\", false},\n        {\"\", true},\n        {\"((()))\", true},\n        {\"(()\", false},\n        {\"())\", false},\n    }\n\n    for _, tt := range tests {\n        result := correct_bracketing(tt.input)\n        if result != tt.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; want %v\", tt.input, result, tt.expected)\n        } else {\n            fmt.Printf(\"correct_bracketing(%q) = %v\\n\", tt.input, result)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_62","nl":"hrv_Latn","pl":"go_test.go","prompt":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vratite izvedenu od ovog polinoma u istom obliku.\/\/xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/xs predstavlja koeficijent polinoma.\/\/ >>> derivative([]int{3, 1, 2, 4, 5})\n\/\/ []int{1, 4, 12, 20}\n\/\/ >>> derivative([]int{1, 2, 3})\n\/\/ []int{2, 6}\nfunc derivative(xs []int) []int {\n","canonical_solution":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ xs represent coefficients of a polynomial.\n\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\/\/ Return derivative of this polynomial in the same form.\nfunc derivative(xs []int) []int {\n    if len(xs) <= 1 {\n        return []int{}\n    }\n    \n    derived := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        derived[i-1] = xs[i] * i\n    }\n    return derived\n}\n\nfunc TestDerivative(t *testing.T) {\n    testCases := []struct{\n        input []int\n        expected []int\n    }{\n        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},\n        {[]int{1, 2, 3}, []int{2, 6}},\n        {[]int{1}, []int{}},\n        {[]int{}, []int{}},\n    }\n\n    for _, testCase := range testCases {\n        result := derivative(testCase.input)\n        if !equal(result, testCase.expected) {\n            t.Errorf(\"For input %v, expected %v, but got %v\", \n                     testCase.input, testCase.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestDerivative(t *testing.T) {\n  candidate := derivative\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },\n     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },\n     { actual: candidate([]int{1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_63","nl":"hrv_Latn","pl":"go_test.go","prompt":"package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Molimo napišite funkciju koja će učinkovito izračunati n-ti element niza brojeva fibfib. \/\/fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3). \/\/- Da, da.\/\/- Da, da, da.\/\/Fibfib ((0) == 0 \/\/FibFib brojni niz je niz sličan Fibbonaccijevom nizu koji je definiran na sljedeći način: \/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunc fibfib(n int) int {\n","canonical_solution":"func fibfib(n int) int {\n    if n == 0 || n == 1 {\n        return 0\n    } else if n == 2 {\n        return 1\n    }\n\n    a, b, c := 0, 0, 1\n    for i := 3; i <= n; i++ {\n        next := a + b + c\n        a = b\n        b = c\n        c = next\n    }\n    return c\n}","tests":"func TestFibfib(t *testing.T) {\n  candidate := fibfib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 1 },\n     { actual: candidate(1), expected: 0 },\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 24 },\n     { actual: candidate(10), expected: 81 },\n     { actual: candidate(12), expected: 274 },\n     { actual: candidate(14), expected: 927 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_64","nl":"hrv_Latn","pl":"go_test.go","prompt":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/samoglasnik, ali samo kada je na kraju date riječi.\/\/Glagolovi u ovom slučaju su \"a\", \"e\", \"i\", \"o\", \"u\".\/\/Riječ kao ulaz i vraća broj samoglasnika u nizu.\/\/Napišite funkciju vowels_count koja uzima niz koji predstavlja \/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunc vowels_count(s string) int {\n","canonical_solution":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc vowels_count(s string) int {\n    count := 0\n    s = strings.ToLower(s)\n    vowels := \"aeiou\"\n    for i, char := range s {\n        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestVowelsCount(t *testing.T) {\n    tests := []struct {\n        input  string\n        output int\n    }{\n        {\"abcde\", 2},\n        {\"ACEDY\", 3},\n        {\"xyz\", 1},\n        {\"plenty\", 1},\n        {\"queue\", 3},\n    }\n\n    for _, test := range tests {\n        result := vowels_count(test.input)\n        if result != test.output {\n            t.Errorf(\"Expected %d, but got %d for input %s\", test.output, result, test.input)\n        } else {\n            fmt.Printf(\"Success: got %d for input %s\\n\", result, test.input)\n        }\n    }\n}","tests":"func TestVowels_Count(t *testing.T) {\n  candidate := vowels_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\"), expected: 2 },\n     { actual: candidate(\"Alone\"), expected: 3 },\n     { actual: candidate(\"key\"), expected: 2 },\n     { actual: candidate(\"bye\"), expected: 1 },\n     { actual: candidate(\"keY\"), expected: 2 },\n     { actual: candidate(\"bYe\"), expected: 1 },\n     { actual: candidate(\"ACEDY\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_65","nl":"hrv_Latn","pl":"go_test.go","prompt":"package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ako je shift > broj znamenki, povratne znamenke su obrnute. \/\/i vratiti rezultat kao niz. \/\/Okruglo pomjeramo cifre cijelog broja x, pomjeramo cifre desno pomjeranjem.\/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunc circular_shift(x int, shift int) string {\n","canonical_solution":"package circular_shift_test\n\nimport (\n    \"strconv\"\n)\n\nfunc circular_shift(x int, shift int) string {\n    strX := strconv.Itoa(x)\n    numDigits := len(strX)\n\n    if shift > numDigits {\n        \/\/ Reverse the digits if shift is greater than the number of digits\n        reversed := make([]byte, numDigits)\n        for i := 0; i < numDigits; i++ {\n            reversed[i] = strX[numDigits-i-1]\n        }\n        return string(reversed)\n    } else {\n        \/\/ Perform a circular shift\n        shift = shift % numDigits\n        return strX[numDigits-shift:] + strX[:numDigits-shift]\n    }\n}","tests":"func TestCircular_Shift(t *testing.T) {\n  candidate := circular_shift\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(100, 2), expected: \"001\" },\n     { actual: candidate(12, 2), expected: \"12\" },\n     { actual: candidate(97, 8), expected: \"79\" },\n     { actual: candidate(12, 1), expected: \"21\" },\n     { actual: candidate(11, 101), expected: \"11\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_66","nl":"hrv_Latn","pl":"go_test.go","prompt":"package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/ASCII kodovi. \/\/Napisati funkciju koja uzima niz kao ulaz i vraća samo zbir gornjih znakova' \/\/Zadatak \/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunc digitSum(s string) int {\n","canonical_solution":"func digitSum(s string) int {\n    sum := 0\n    for _, char := range s {\n        if char >= 'A' && char <= 'Z' {\n            sum += int(char)\n        }\n    }\n    return sum\n}","tests":"func TestDigitsum(t *testing.T) {\n  candidate := digitSum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abAB\"), expected: 131 },\n     { actual: candidate(\"abcCd\"), expected: 67 },\n     { actual: candidate(\"helloE\"), expected: 69 },\n     { actual: candidate(\"woArBld\"), expected: 131 },\n     { actual: candidate(\"aAaaaXa\"), expected: 153 },\n     { actual: candidate(\" How are yOu?\"), expected: 151 },\n     { actual: candidate(\"You arE Very Smart\"), expected: 327 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_67","nl":"hrv_Latn","pl":"go_test.go","prompt":"package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Za izgovor: \/\/u košarici, vratite broj plodova mango u košari. \/\/Pomorandže i jabuke i cijeli broj koji predstavlja ukupan broj plodova \/\/Jabuka, naranče i mango, s obzirom na niz koji predstavlja ukupan broj \/\/koji su raspoređeni u košari s voćem koju sadrži ta košara.\/\/U ovom zadatku, dat će vam se niz koji predstavlja broj jabuka i naranča.\/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunc fruit_distribution(s string, n int) int {\n","canonical_solution":"package fruit_distribution_test\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"testing\"\n)\n\nfunc fruit_distribution(s string, n int) int {\n    re := regexp.MustCompile(`(\\d+) apples and (\\d+) oranges`)\n    matches := re.FindStringSubmatch(s)\n    \n    if len(matches) != 3 {\n        return -1 \/\/ Could return an error or a sentinel value if input format is incorrect\n    }\n\n    apples, _ := strconv.Atoi(matches[1])\n    oranges, _ := strconv.Atoi(matches[2])\n\n    mangoes := n - (apples + oranges)\n    return mangoes\n}\n\nfunc TestFruitDistribution(t *testing.T) {\n    var tests = []struct {\n        description string\n        inputString string\n        totalFruits int\n        expected    int\n    }{\n        {\"Test case 1\", \"5 apples and 6 oranges\", 19, 8},\n        {\"Test case 2\", \"0 apples and 1 oranges\", 3, 2},\n        {\"Test case 3\", \"2 apples and 3 oranges\", 100, 95},\n        {\"Test case 4\", \"100 apples and 1 oranges\", 120, 19},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.description, func(t *testing.T) {\n            result := fruit_distribution(tt.inputString, tt.totalFruits)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}\n\nfunc main() {\n    fmt.Println(fruit_distribution(\"5 apples and 6 oranges\", 19)) \/\/ 8\n    fmt.Println(fruit_distribution(\"0 apples and 1 oranges\", 3))  \/\/ 2\n    fmt.Println(fruit_distribution(\"2 apples and 3 oranges\", 100)) \/\/ 95\n    fmt.Println(fruit_distribution(\"100 apples and 1 oranges\", 120)) \/\/ 19\n}","tests":"func TestFruit_Distribution(t *testing.T) {\n  candidate := fruit_distribution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"5 apples and 6 oranges\", 19), expected: 8 },\n     { actual: candidate(\"5 apples and 6 oranges\", 21), expected: 10 },\n     { actual: candidate(\"0 apples and 1 oranges\", 3), expected: 2 },\n     { actual: candidate(\"1 apples and 0 oranges\", 3), expected: 2 },\n     { actual: candidate(\"2 apples and 3 oranges\", 100), expected: 95 },\n     { actual: candidate(\"2 apples and 3 oranges\", 5), expected: 0 },\n     { actual: candidate(\"1 apples and 100 oranges\", 120), expected: 19 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_68","nl":"hrv_Latn","pl":"go_test.go","prompt":"package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer 1: \/\/Ako nema parnih vrijednosti ili je navedena lista prazna, vratite [].\/\/Određeni čvor treba vratiti u listi, [small_value, njegov indeks], \/\/Ako se nađe više čvorova s istom najmanjom parnom vrijednošću, vrati čvor s najmanjim indeksom. \/\/Odabran čvor treba biti čvor s najmanjom parnom vrijednošću.\/\/Vaš zadatak je da izvadite jedan od čvorova i vratite ga.\/\/\"Dano popis koji predstavlja grana stabla koja ima ne-negativne čitav broj čvorova \/\/ >>> pluck([]int{4, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([]int{1, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([]int{})\n\/\/ []int{}\n\/\/ Example 4:\n\/\/ >>> pluck([]int{5, 0, 3, 0, 4, 2})\n\/\/ []int{0, 1}\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunc pluck(arr []int) []int {\n","canonical_solution":"package pluck_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ pluck function that implements the solution as described in the problem\nfunc pluck(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn []int{}\n\t}\n\n\tsmallestEvenValue := -1\n\tindex := -1\n\n\tfor i, val := range arr {\n\t\tif val%2 == 0 {\n\t\t\tif smallestEvenValue == -1 || val < smallestEvenValue {\n\t\t\t\tsmallestEvenValue = val\n\t\t\t\tindex = i\n\t\t\t}\n\t\t}\n\t}\n\n\tif index == -1 {\n\t\treturn []int{}\n\t}\n\n\treturn []int{smallestEvenValue, index}\n}\n\n\/\/ Example unit tests can be implemented by using the testing package\nfunc TestPluck(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{4, 2, 3}, []int{2, 1}},\n\t\t{[]int{1, 2, 3}, []int{2, 1}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := pluck(test.input)\n\t\tif len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {\n\t\t\tt.Errorf(\"pluck(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_69","nl":"hrv_Latn","pl":"go_test.go","prompt":"package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Ako takva vrijednost ne postoji, vraća se -1. \/\/Čestoća čitavog broja je broj puta kad se pojavljuje na popisu.\/\/nula, i ima učestalost veću ili jednaku vrijednosti samog čitavog broja. \/\/Dobivate neprazan popis pozitivnih cijela brojeva. Vratite najveći cijeli broj koji je veći od \/\/ >>> search([]int{4, 1, 2, 2, 3, 1})\n\/\/ 2\n\/\/ >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})\n\/\/ 3\n\/\/ >>> search([]int{5, 5, 4, 4, 4})\n\/\/ -1\nfunc search(lst []int) int {\n","canonical_solution":"package search_test\n\nimport \"sort\"\n\nfunc search(lst []int) int {\n\tfrequency := make(map[int]int)\n\n\tfor _, num := range lst {\n\t\tfrequency[num]++\n\t}\n\n\tcandidates := []int{}\n\tfor num, count := range frequency {\n\t\tif count >= num {\n\t\t\tcandidates = append(candidates, num)\n\t\t}\n\t}\n\n\tif len(candidates) == 0 {\n\t\treturn -1\n\t}\n\n\tsort.Ints(candidates)\n\treturn candidates[len(candidates)-1]\n}","tests":"func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3, 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n     { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}), expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_70","nl":"hrv_Latn","pl":"go_test.go","prompt":"package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/onda maksimalni od preostalih cifara, onda minimalni i tako dalje.\/\/Čudno sortiranje, je kad počnete s minimalnom vrijednošću, \/\/Ako je data lista cijelih brojeva, vrati popis u neobičnom redoslijedu.\/\/ >>> strange_sort_list([]int{1, 2, 3, 4})\n\/\/ []int{1, 4, 2, 3}\n\/\/ >>> strange_sort_list([]int{5, 5, 5, 5})\n\/\/ []int{5, 5, 5, 5}\n\/\/ >>> strange_sort_list([]int{})\n\/\/ []int{}\nfunc strange_sort_list(lst []int) []int {\n","canonical_solution":"package strange_sort_list_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc strange_sort_list(lst []int) []int {\n\tif len(lst) == 0 {\n\t\treturn lst\n\t}\n\t\n\tsort.Ints(lst)\n\tres := make([]int, len(lst))\n\tleft, right := 0, len(lst)-1\n\ti := 0\n\n\tfor left <= right {\n\t\tif i%2 == 0 {\n\t\t\tres[i] = lst[left]\n\t\t\tleft++\n\t\t} else {\n\t\t\tres[i] = lst[right]\n\t\t\tright--\n\t\t}\n\t\ti++\n\t}\n\n\treturn res\n}\n\nfunc TestStrangeSortList(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []int\n\t\toutput []int\n\t}{\n\t\t{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},\n\t\t{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},\n\t}\n\tfor _, test := range tests {\n\t\tif res := strange_sort_list(test.input); !equal(res, test.output) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.output, res)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tfmt.Println(strange_sort_list([]int{1, 2, 3, 4})) \/\/ Should print [1 4 2 3]\n}","tests":"func TestStrange_Sort_List(t *testing.T) {\n  candidate := strange_sort_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },\n     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },\n     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },\n     { actual: candidate([]int{111111}), expected: []int{111111} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_71","nl":"hrv_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/nego treća strana.\/\/Tri strane čine valjan trokut kad je zbroj bilo koje dvije strane veći.\/\/U suprotnom povratak -1 \/\/U slučaju da se u skladu s člankom 2. stavkom 1. točkom (b) točke (i) primjenjuje na sve druge točke, to se primjenjuje na sve druge točke.\/\/S obzirom na dužine tri strane trokut, vratimo površinu \/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunc triangle_area(a int, b int, c int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"math\"\n)\n\nfunc triangle_area(a int, b int, c int) float64 {\n    \/\/ Check for the validity of the triangle\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    \/\/ Calculate the semi-perimeter\n    s := float64(a+b+c) \/ 2\n    \/\/ Calculate the area using Heron's formula\n    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    \/\/ Round the result to 2 decimal places\n    return math.Round(area*100) \/ 100.0\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: 6.0 },\n     { actual: candidate(1, 2, 10), expected: -1 },\n     { actual: candidate(4, 8, 5), expected: 8.18 },\n     { actual: candidate(2, 2, 2), expected: 1.73 },\n     { actual: candidate(1, 2, 3), expected: -1 },\n     { actual: candidate(10, 5, 7), expected: 16.25 },\n     { actual: candidate(2, 6, 3), expected: -1 },\n     { actual: candidate(1, 1, 1), expected: 0.43 },\n     { actual: candidate(2, 2, 10), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_72","nl":"hrv_Latn","pl":"go_test.go","prompt":"package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/Objekt q će letjeti ako je uravnotežen (to je palindromska lista) i suma njegovih elemenata je manja od ili jednaka najvećoj mogućoj težini w.\/\/Napišite funkciju koja vraća istinitu ako objekt q leti, i lažno u suprotnom. \/\/ >>> will_it_fly([]int{1, 2}, 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([]int{3}, 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w int) bool {\n","canonical_solution":"func will_it_fly(q []int, w int) bool {\n    sum := 0\n    n := len(q)\n\n    \/\/ Calculate the sum of the elements in q\n    for _, value := range q {\n        sum += value\n    }\n\n    \/\/ Check if sum is greater than the maximum possible weight\n    if sum > w {\n        return false\n    }\n\n    \/\/ Check if the list is a palindrome\n    for i := 0; i < n\/2; i++ {\n        if q[i] != q[n-i-1] {\n            return false\n        }\n    }\n\n    \/\/ If the list is balanced and sum is less than or equal to w\n    return true\n}","tests":"func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_73","nl":"hrv_Latn","pl":"go_test.go","prompt":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/U jednoj promjeni možete promijeniti jedan element u bilo koji drugi element.\/\/palidromni popis je popis koji \/\/S obzirom na popis cijelih brojeva, pronađite minimalni broj elemenata koji \/\/ >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})\n\/\/ 4\n\/\/ >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})\n\/\/ 1\n\/\/ >>> smallest_change([]int{1, 2, 3, 2, 1})\n\/\/ 0\nfunc smallest_change(arr []int) int {\n","canonical_solution":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc smallest_change(arr []int) int {\n    n := len(arr)\n    changes := 0\n    for i := 0; i < n\/2; i++ {\n        if arr[i] != arr[n-i-1] {\n            changes++\n        }\n    }\n    return changes\n}\n\nfunc TestSmallestChange(t *testing.T) {\n    tests := []struct{\n        input []int\n        expected int\n    }{\n        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},\n        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},\n        {[]int{1, 2, 3, 2, 1}, 0},\n    }\n\n    for _, test := range tests {\n        result := smallest_change(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %v, expected %d but got %d\", test.input, test.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", test.input)\n        }\n    }\n}","tests":"func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_74","nl":"hrv_Latn","pl":"go_test.go","prompt":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/Ako su dvije liste iste broja znakova, vratite prvu listu.\/\/Ukupan broj znakova u svim nizovima liste manji je od drugog popisa.\/\/Napišite funkciju koja prihvaća dvije liste niza i vraća listu koja ima \/\/ >>> total_match([]string{}, []string{})\n\/\/ []string{}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n\/\/ []string{\"hI\", \"Hi\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"})\n\/\/ []string{\"hi\", \"admin\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\/\/ []string{\"hI\", \"hi\", \"hi\"}\n\/\/ >>> total_match([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"})\n\/\/ []string{\"4\"}\nfunc total_match(lst1 []string, lst2 []string) []string {\n","canonical_solution":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ total_match function returns the list with the smaller total character count.\n\/\/ If both lists have the same character count, it returns the first list.\nfunc total_match(lst1 []string, lst2 []string) []string {\n    sumChars := func(lst []string) int {\n        total := 0\n        for _, str := range lst {\n            total += len(str)\n        }\n        return total\n    }\n    \n    sum1 := sumChars(lst1)\n    sum2 := sumChars(lst2)\n\n    if sum1 <= sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\n\/\/ Test functions can go below to verify the behavior of total_match.\nfunc TestTotalMatch(t *testing.T) {\n    cases := []struct {\n        lst1      []string\n        lst2      []string\n        expected  []string\n    }{\n        {[]string{}, []string{}, []string{}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}, []string{\"hI\", \"Hi\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}, []string{\"hi\", \"admin\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}, []string{\"hI\", \"hi\", \"hi\"}},\n        {[]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}, []string{\"4\"}},\n    }\n\n    for _, c := range cases {\n        result := total_match(c.lst1, c.lst2)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"total_match(%v, %v) == %v, expected %v\", c.lst1, c.lst2, result, c.expected)\n        }\n    }\n}","tests":"func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_75","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/Znajući da je (a) manje od 100.\/\/i pogrešno u suprotnom.\/\/Napišite funkciju koja vraća vrijednost istinita ako je dat broj množenje 3 prostih broja \/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a int) bool {\n","canonical_solution":"func is_multiply_prime(a int) bool {\n\tif a < 2 {\n\t\treturn false\n\t}\n\n\tprimeNumbers := generatePrimesUpTo(100)\n\t\n\tfor i := 0; i < len(primeNumbers); i++ {\n\t\tfor j := i; j < len(primeNumbers); j++ {\n\t\t\tfor k := j; k < len(primeNumbers); k++ {\n\t\t\t\tif primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc generatePrimesUpTo(max int) []int {\n\tisPrime := make([]bool, max+1)\n\tfor i := 2; i <= max; i++ {\n\t\tisPrime[i] = true\n\t}\n\tfor i := 2; i*i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tfor j := i * i; j <= max; j += i {\n\t\t\t\tisPrime[j] = false\n\t\t\t}\n\t\t}\n\t}\n\tvar primes []int\n\tfor i := 2; i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\treturn primes\n}","tests":"func TestIs_Multiply_Prime(t *testing.T) {\n  candidate := is_multiply_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: false },\n     { actual: candidate(30), expected: true },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: false },\n     { actual: candidate(125), expected: true },\n     { actual: candidate(105), expected: true },\n     { actual: candidate(126), expected: false },\n     { actual: candidate(729), expected: false },\n     { actual: candidate(891), expected: false },\n     { actual: candidate(1001), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_76","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/x je jednostavan moć od n ako je n**int=x \/\/moć n i false u ostalim slučajevima. \/\/Vaš zadatak je napisati funkciju koja vraća vrijednost true ako je broj x jednostavan \/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunc is_simple_power(x int, n int) bool {\n","canonical_solution":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_simple_power(x int, n int) bool {\n    if n <= 1 {\n        return x == 1\n    }\n    \n    current := n\n    for current <= x {\n        if current == x {\n            return true\n        }\n        current *= n\n    }\n    return false\n}\n\nfunc TestIsSimplePower(t *testing.T) {\n    tests := []struct {\n        x, n     int\n        expected bool\n    }{\n        {1, 4, true},\n        {2, 2, true},\n        {8, 2, true},\n        {3, 2, false},\n        {3, 1, false},\n        {5, 3, false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.x, test.n), func(t *testing.T) {\n            result := is_simple_power(test.x, test.n)\n            if result != test.expected {\n                t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_77","nl":"hrv_Latn","pl":"go_test.go","prompt":"package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Napomena: možete pretpostaviti da je ulazni podaci uvijek valjani.\/\/ako je ovaj ingeger kub nekog cijelog broja.\/\/Napišite funkciju koja uzima cijeli broj a i vraća vrijednost true.\/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunc iscube(a int) bool {\n","canonical_solution":"package iscube_test\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc iscube(a int) bool {\n\tif a < 0 {\n\t\ta = -a\n\t}\n\tcubeRoot := math.Cbrt(float64(a))\n\treturn cubeRoot == float64(int(cubeRoot))\n}\n\nfunc TestIsCube(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{1, true},\n\t\t{2, false},\n\t\t{-1, true},\n\t\t{64, true},\n\t\t{0, true},\n\t\t{180, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"iscube(%d)\", test.input), func(t *testing.T) {\n\t\t\tresult := iscube(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestIscube(t *testing.T) {\n  candidate := iscube\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: true },\n     { actual: candidate(2), expected: false },\n     { actual: candidate(-1), expected: true },\n     { actual: candidate(64), expected: true },\n     { actual: candidate(180), expected: false },\n     { actual: candidate(1000), expected: true },\n     { actual: candidate(0), expected: true },\n     { actual: candidate(1729), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_78","nl":"hrv_Latn","pl":"go_test.go","prompt":"package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/i simboli A,B,C,D,E,F su uvijek veliki.\/\/Napomena: možete pretpostaviti ulazni je uvijek ispravna ili prazna niz, \/\/B (= desetka 11), D (= desetka 13). \/\/Dakle, morate odrediti broj sljedećih znamenki: 2, 3, 5, 7, \/\/Primi brojevi su 2, 3, 5, 7, 11, 13, 17,...\/\/Hexadecimalne cifre su 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/\/veći od 1 koji nije proizvod dva manja prirodnih broja).\/\/Brojke koje su primne (primi broj, ili prvenstveni broj, je prirodni broj)\/\/Šesnaestkočni broj kao niz i broji broj šesnaestkočnih \/\/Dobio si zadatak da napišeš funkciju koja prima \/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunc hex_key(num string) int {\n","canonical_solution":"func hex_key(num string) int {\n    primeDigits := map[rune]struct{}{\n        '2': {},\n        '3': {},\n        '5': {},\n        '7': {},\n        'B': {},\n        'D': {},\n    }\n\n    count := 0\n    for _, digit := range num {\n        if _, found := primeDigits[digit]; found {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHexKey(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"AB\", 1},\n        {\"1077E\", 2},\n        {\"ABED1A33\", 4},\n        {\"123456789ABCDEF0\", 6},\n        {\"2020\", 2},\n        {\"\", 0},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"hex_key(%s)\", test.input), func(t *testing.T) {\n            result := hex_key(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_79","nl":"hrv_Latn","pl":"go_test.go","prompt":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Dodatni znakovi su tu da pomognu u formatu.\/\/Bit će dodatnih nekoliko znakova 'db' na početku i na kraju niza. \/\/Svaki znak u nizu bit će \"0\" ili \"1\".\/\/Funkcija bi trebala vratiti niz, s svakim znakom koji predstavlja binarni \/\/Dobićete broj u decimalnom obliku i vaš zadatak je da ga pretvorite u \/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n","canonical_solution":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n\/\/ You will be given a number in decimal form and your task is to convert it to\n\/\/ binary format. The function should return a string, with each character representing a binary\n\/\/ number. Each character in the string will be '0' or '1'.\n\/\/ There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n\/\/ The extra characters are there to help with the format.\n\/\/ Examples:\n\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    binary := strconv.FormatInt(int64(decimal), 2)\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimalToBinary(t *testing.T) {\n    tests := []struct {\n        input  int\n        output string\n    }{\n        {15, \"db1111db\"},\n        {32, \"db100000db\"},\n        {0, \"db0db\"},\n        {1, \"db1db\"},\n        {255, \"db11111111db\"},\n    }\n\n    for _, test := range tests {\n        result := decimal_to_binary(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %d, expected %s, but got %s\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(decimal_to_binary(15))  \/\/ Output: db1111db\n    fmt.Println(decimal_to_binary(32))  \/\/ Output: db100000db\n    fmt.Println(decimal_to_binary(255)) \/\/ Output: db11111111db\n}","tests":"func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_80","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/String je hapgo ako je njegova dužina najmanje 3 i svakih 3 uzastopna slova su različita \/\/Vaš zadatak je provjeriti je li string hapgo ili ne.\/\/Dobivate niz s.\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunc is_happy(s string) bool {\n","canonical_solution":"func is_happy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i <= len(s)-3; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestIs_Happy(t *testing.T) {\n  candidate := is_happy\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a\"), expected: false },\n     { actual: candidate(\"aa\"), expected: false },\n     { actual: candidate(\"abcd\"), expected: true },\n     { actual: candidate(\"aabb\"), expected: false },\n     { actual: candidate(\"adb\"), expected: true },\n     { actual: candidate(\"xyy\"), expected: false },\n     { actual: candidate(\"iopaxpoi\"), expected: true },\n     { actual: candidate(\"iopaxioi\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_81","nl":"hrv_Latn","pl":"go_test.go","prompt":"package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/0.0 E \/\/> 0, 0 D- \/\/> 0,7 D \/\/> 1,0 D+ \/\/> 1,3 C- \/\/> 1,7 °C \/\/> 2,0 °C+ \/\/> 2.3 B- \/\/> 2,7 B \/\/> 3,0 B+ \/\/> 3.3 A- \/\/> 3,7 A \/\/4.0 A+ \/\/Prosjek ocjene.\/\/funkcija koja može izvesti popis razredova slova koristeći sljedeću tabelu: \/\/Dala ti je listu prosjeka nekih učenika i moraš pisati.\/\/Jedini problem je što je izgubila kod koji je koristila za ocjenjivanje.\/\/Učiteljica je napravila svoj algoritam za ocjenjivanje.\/\/Posljednji je tjedan semestra i učiteljica mora dati ocjene.\/\/ >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})\n\/\/ []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\nfunc numerical_letter_grade(grades []float64) []string {\n","canonical_solution":"func numerical_letter_grade(grades []float64) []string {\n    letterGrades := []string{}\n    for _, grade := range grades {\n        if grade == 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if grade > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if grade > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if grade > 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if grade > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if grade > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if grade > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if grade > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if grade > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if grade > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if grade > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if grade > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}","tests":"func TestNumerical_Letter_Grade(t *testing.T) {\n  candidate := numerical_letter_grade\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"} },\n     { actual: candidate([]float64{1.2}), expected: []string{\"D+\"} },\n     { actual: candidate([]float64{0.5}), expected: []string{\"D-\"} },\n     { actual: candidate([]float64{0.0}), expected: []string{\"E\"} },\n     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"} },\n     { actual: candidate([]float64{0.0, 0.7}), expected: []string{\"E\", \"D-\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_82","nl":"hrv_Latn","pl":"go_test.go","prompt":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/dužina je prvi broj ili pogrešan inače \/\/Napišite funkciju koja uzima niz i vraća vrijednost true ako niz \/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunc prime_length(myString string) bool {\n","canonical_solution":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc prime_length(myString string) bool {\n    length := len(myString)\n    return isPrime(length)\n}\n\nfunc TestPrimeLength(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected bool\n    }{\n        {\"Hello\", true},\n        {\"abcdcba\", true},\n        {\"kittens\", true},\n        {\"orange\", false},\n    }\n\n    for _, testCase := range testCases {\n        result := prime_length(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"prime_length(%v) returned %v, expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(prime_length(\"Hello\"))  \/\/ true\n    fmt.Println(prime_length(\"abcdcba\"))  \/\/ true\n    fmt.Println(prime_length(\"kittens\"))  \/\/ true\n    fmt.Println(prime_length(\"orange\"))  \/\/ false\n}","tests":"func TestPrime_Length(t *testing.T) {\n  candidate := prime_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello\"), expected: true },\n     { actual: candidate(\"abcdcba\"), expected: true },\n     { actual: candidate(\"kittens\"), expected: true },\n     { actual: candidate(\"orange\"), expected: false },\n     { actual: candidate(\"wow\"), expected: true },\n     { actual: candidate(\"world\"), expected: true },\n     { actual: candidate(\"MadaM\"), expected: true },\n     { actual: candidate(\"Wow\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"HI\"), expected: true },\n     { actual: candidate(\"go\"), expected: true },\n     { actual: candidate(\"gogo\"), expected: false },\n     { actual: candidate(\"aaaaaaaaaaaaaaa\"), expected: false },\n     { actual: candidate(\"Madam\"), expected: true },\n     { actual: candidate(\"M\"), expected: false },\n     { actual: candidate(\"0\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_83","nl":"hrv_Latn","pl":"go_test.go","prompt":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Pozitivni cijeli brojevi koji počinju ili završavaju sa 1.\/\/Ako je n pozitivan cijeli broj, vratite broj n-cifrenih brojeva func starts_one_ends(n int) int {\n","canonical_solution":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return the count of the numbers of n-digit\n\/\/ positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n    if n == 1 {\n        return 1\n    }\n\n    countStart1 := 1 * pow(10, n-1)\n    countEnd1 := 9 * pow(10, n-2)\n    \n    return countStart1 + countEnd1\n}\n\nfunc pow(base, exp int) int {\n    if exp == 0 {\n        return 1\n    }\n    result := 1\n    for i := 0; i < exp; i++ {\n        result *= base\n    }\n    return result\n}\n\nfunc TestStartsOneEnds(t *testing.T) {\n    tests := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 19},\n        {3, 189},\n        {4, 1899},\n        {5, 18999},\n    }\n\n    for _, tt := range tests {\n        testname := fmt.Sprintf(\"n=%d\", tt.n)\n        t.Run(testname, func(t *testing.T) {\n            result := starts_one_ends(tt.n)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}","tests":"func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected: 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_84","nl":"hrv_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer \/\/Ako je dato pozitivan cijeli broj N, vratite ukupnu sumu njegovih cifara u binarnom obliku. \/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunc solve(N int) string {\n","canonical_solution":"func solve(N int) string {\n    sum := 0\n    for N > 0 {\n        sum += N % 10\n        N \/= 10\n    }\n    return fmt.Sprintf(\"%b\", sum)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1000), expected: \"1\" },\n     { actual: candidate(150), expected: \"110\" },\n     { actual: candidate(147), expected: \"1100\" },\n     { actual: candidate(333), expected: \"1001\" },\n     { actual: candidate(963), expected: \"10010\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_85","nl":"hrv_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/S obzirom na ne-praznu listu cijelih brojeva lst. Dodaj parni elementi koji su na neparnim indeksima .. \/\/ >>> add([]int{4, 2, 6, 7})\n\/\/ 2\nfunc add(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        if lst[i]%2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 88}), expected: 88 },\n     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },\n     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },\n     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_86","nl":"hrv_Latn","pl":"go_test.go","prompt":"package anti_shuffle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Napomena: Uređenje riječi i praznih mjesta u rečenici treba zadržati. \/\/U porastu prema vrijednosti ASCII. \/\/zamijenjene novom riječju u kojoj su svi znakovi raspoređeni u \/\/Redovita verzija niza, je niz u kojem su sve riječi (odvojene razmakom) \/\/Napišite funkciju koja uzima niz i vraća poresku verziju.\/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s string) string {\n","canonical_solution":"package anti_shuffle_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc anti_shuffle(s string) string {\n    \/\/ Split the input string into words based on spaces\n    words := strings.Fields(s)\n\n    \/\/ Iterate over each word\n    for i, word := range words {\n        \/\/ Convert the word to a slice of runes for sorting\n        runes := []rune(word)\n        \/\/ Sort the runes using custom comparison\n        sort.Slice(runes, func(i, j int) bool {\n            return runes[i] < runes[j]\n        })\n        \/\/ Reassign the sorted runes back to the word\n        words[i] = string(runes)\n    }\n\n    \/\/ Rejoin the words into a single string, keeping original spaces\n    result := \"\"\n    inputIndex := 0\n\n    for _, word := range words {\n        \/\/ Add the spaces prior to the current word\n        for inputIndex < len(s) && s[inputIndex] == ' ' {\n            result += \" \"\n            inputIndex++\n        }\n        \/\/ Add the current sorted word\n        result += word\n        inputIndex += len(word)\n    }\n\n    \/\/ Add trailing spaces, if any.\n    for inputIndex < len(s) && s[inputIndex] == ' ' {\n        result += \" \"\n        inputIndex++\n    }\n\n    return result\n}","tests":"func TestAnti_Shuffle(t *testing.T) {\n  candidate := anti_shuffle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi\"), expected: \"Hi\" },\n     { actual: candidate(\"hello\"), expected: \"ehllo\" },\n     { actual: candidate(\"number\"), expected: \"bemnru\" },\n     { actual: candidate(\"abcd\"), expected: \"abcd\" },\n     { actual: candidate(\"Hello World!!!\"), expected: \"Hello !!!Wdlor\" },\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hi. My name is Mister Robot. How are you?\"), expected: \".Hi My aemn is Meirst .Rboot How aer ?ouy\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_87","nl":"hrv_Latn","pl":"go_test.go","prompt":"package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Također, sortirajte koordinate reda po stupcima u silaznom redu.\/\/Sortirajte koordinate po redovima u rastućem redu.\/\/Svaki popis je koordinata - (red, stubovi), počevši od 0. \/\/i povratni popis popisa, [(x1, y1), (x2, y2) ...] tako da \/\/S obzirom na lst, i cijeli broj x, pronađite cijeli brojevi x na popisu, \/\/U svakom redu može biti različit broj stupova.\/\/koja je slična matrici, međutim, za razliku od matrica, \/\/Dobivate dvodimenzionalne podatke, kao ugnežđene liste, \/\/ >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n\/\/ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n\/\/ >>> get_row([][]int{}, 1)\n\/\/ [][]interface{}{}\n\/\/ >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n\/\/ [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n","canonical_solution":"package get_row_test\n\nimport (\n\t\"sort\"\n)\n\nfunc get_row(lst [][]int, x int) [][]interface{} {\n\tvar result [][]interface{}\n\n\tfor i, row := range lst {\n\t\tvar temp []interface{}\n\t\tfor j, value := range row {\n\t\t\tif value == x {\n\t\t\t\ttemp = append(temp, []interface{}{i, j})\n\t\t\t}\n\t\t}\n\t\t\/\/ Sort columns in descending order for the current row\n\t\tsort.Slice(temp, func(a, b int) bool {\n\t\t\treturn temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)\n\t\t})\n\t\tresult = append(result, temp...)\n\t}\n\n\t\/\/ result is already sorted by rows since we've traversed `lst` row by row\n\treturn result\n}","tests":"func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_88","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/* ne mijenjati datog popisa. \/\/Napomena: \/\/ili ga rasporediti u padajućem redu ako je zbir ((prva vrijednost indeksa, posljednja vrijednost indeksa) parna. \/\/Ako je suma ((prva indeksna vrijednost, posljednja indeksna vrijednost) neparna, sortirat ćete dat popis u uzlaznom redu, \/\/Ako je data lista ne-negativnih cijelih brojeva, vratite cogo navedene liste nakon sortiranja, \/\/ >>> sort_array([]int{})\n\/\/ []int{}\n\/\/ >>> sort_array([]int{5})\n\/\/ []int{5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n\/\/ []int{0, 1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n\/\/ []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return append([]int{}, array...)\n    }\n\n    result := append([]int{}, array...) \/\/ Copy the array to avoid mutating the input\n    if (result[0]+result[len(result)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(result))) \/\/ Sort in descending order\n    } else {\n        sort.Ints(result) \/\/ Sort in ascending order\n    }\n\n    return result\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_89","nl":"hrv_Latn","pl":"go_test.go","prompt":"package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/pomak dolje dva puta na dva mjesta.\/\/Alfabet treba biti okrenut na takav način da slova \/\/vraća niz šifriran s abecedom koja se rotira. \/\/Stvorite funkciju koja uzima niz kao argument i \/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunc encrypt(s string) string {\n","canonical_solution":"func encrypt(s string) string {\n    result := []rune(s)\n    for i, char := range result {\n        if char >= 'a' && char <= 'z' {\n            result[i] = 'a' + (char-'a'+4)%26\n        } else if char >= 'A' && char <= 'Z' {\n            result[i] = 'A' + (char-'A'+4)%26\n        }\n    }\n    return string(result)\n}","tests":"func TestEncrypt(t *testing.T) {\n  candidate := encrypt\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hi\"), expected: \"lm\" },\n     { actual: candidate(\"asdfghjkl\"), expected: \"ewhjklnop\" },\n     { actual: candidate(\"gf\"), expected: \"kj\" },\n     { actual: candidate(\"et\"), expected: \"ix\" },\n     { actual: candidate(\"faewfawefaewg\"), expected: \"jeiajeaijeiak\" },\n     { actual: candidate(\"hellomyfriend\"), expected: \"lippsqcjvmirh\" },\n     { actual: candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), expected: \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" },\n     { actual: candidate(\"a\"), expected: \"e\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_91","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Rečenice se razgraničavaju znakom \"\", \"?\" ili \"!\" \/\/Dosada je rečenica koja počinje riječju \"ja\".\/\/Dobićete niz riječi, a vaš zadatak je da prebrojite broj.\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunc is_bored(S string) int {\n","canonical_solution":"package is_bored_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_bored(S string) int {\n    sentences := strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' || r == '?' || r == '!'\n    })\n    count := 0\n    for _, sentence := range sentences {\n        trimmed := strings.TrimSpace(sentence)\n        if strings.HasPrefix(trimmed, \"I \") {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestIsBored(t *testing.T) {\n    tests := []struct {\n        input string\n        want  int\n    }{\n        {\"Hello world\", 0},\n        {\"The sky is blue. The sun is shining. I love this weather\", 1},\n        {\"I am here. I am there. I am everywhere\", 3},\n        {\"What's up? Are you ok? Yes, I am!\", 1},\n        {\"\", 0},\n        {\"I.\", 1},\n        {\"I! am excited. I? am curious\", 2},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"is_bored(%q)\", tt.input), func(t *testing.T) {\n            got := is_bored(tt.input)\n            if got != tt.want {\n                t.Errorf(\"got %d, want %d\", got, tt.want)\n            }\n        })\n    }\n}","tests":"func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"), expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual: candidate(\"I feel good today. I will be productive. will kill It\"), expected: 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_92","nl":"hrv_Latn","pl":"go_test.go","prompt":"package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/Vrati se lažna u svim ostalim slučajevima. \/\/Vraća vrijednost istinita ako je jedan od brojeva jednak zbrojima ostalih dva, a svi brojevi su cijevi. \/\/Stvori funkciju koja uzima 3 broja.\/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunc any_int(x float64, y float64, z float64) bool {\n","canonical_solution":"package any_int_test\n\nimport (\n    \"testing\"\n)\n\nfunc any_int(x float64, y float64, z float64) bool {\n    \/\/ Check if x, y, and z are integers\n    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {\n        return false\n    }\n\n    \/\/ Check if one of the numbers is the sum of the other two\n    if x == y+z || y == x+z || z == x+y {\n        return true\n    }\n\n    return false\n}\n\nfunc TestAnyInt(t *testing.T) {\n    if !any_int(5, 2, 7) {\n        t.Errorf(\"Expected true for any_int(5, 2, 7)\")\n    }\n    if any_int(3, 2, 2) {\n        t.Errorf(\"Expected false for any_int(3, 2, 2)\")\n    }\n    if !any_int(3, -2, 1) {\n        t.Errorf(\"Expected true for any_int(3, -2, 1)\")\n    }\n    if any_int(3.6, -2.2, 2) {\n        t.Errorf(\"Expected false for any_int(3.6, -2.2, 2)\")\n    }\n}","tests":"func TestAny_Int(t *testing.T) {\n  candidate := any_int\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 3, 1), expected: true },\n     { actual: candidate(2.5, 2, 3), expected: false },\n     { actual: candidate(1.5, 5, 3.5), expected: false },\n     { actual: candidate(2, 6, 2), expected: false },\n     { actual: candidate(4, 2, 2), expected: true },\n     { actual: candidate(2.2, 2.2, 2.2), expected: false },\n     { actual: candidate(-4, 6, 2), expected: true },\n     { actual: candidate(2, 1, 1), expected: true },\n     { actual: candidate(3, 4, 7), expected: true },\n     { actual: candidate(3.0, 4, 7), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_93","nl":"hrv_Latn","pl":"go_test.go","prompt":"package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Samo slova.\/\/Samoglasnik u engleskom abecedi.\/\/Poruka s pismom koja se pojavljuje 2 mjesta ispred toga.\/\/Način na koji zamjenjuje case svih slova, zamjenjuje sve samoglasnike u \/\/Napišite funkciju koja uzima poruku i kodira u takvom \/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message string) string {\n","canonical_solution":"package encode_test\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc encode(message string) string {\n\tvar encodedMessage strings.Builder\n\n\t\/\/ Mapping of vowels to the letter appearing 2 places ahead\n\tvowelReplacement := map[rune]rune{\n\t\t'a': 'c',\n\t\t'A': 'C',\n\t\t'e': 'g',\n\t\t'E': 'G',\n\t\t'i': 'k',\n\t\t'I': 'K',\n\t\t'o': 'q',\n\t\t'O': 'Q',\n\t\t'u': 'w',\n\t\t'U': 'W',\n\t}\n\n\tfor _, char := range message {\n\t\tif unicode.IsLetter(char) {\n\t\t\t\/\/ Swap case of the character\n\t\t\tif unicode.IsUpper(char) {\n\t\t\t\tchar = unicode.ToLower(char)\n\t\t\t} else {\n\t\t\t\tchar = unicode.ToUpper(char)\n\t\t\t}\n\n\t\t\t\/\/ Replace vowel if the character is a vowel\n\t\t\tif replacement, isVowel := vowelReplacement[char]; isVowel {\n\t\t\t\tchar = replacement\n\t\t\t}\n\t\t}\n\n\t\tencodedMessage.WriteRune(char)\n\t}\n\n\treturn encodedMessage.String()\n}","tests":"func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_94","nl":"hrv_Latn","pl":"go_test.go","prompt":"package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Morate pronaći najveću primarnu vrijednost i vratiti zbir njegovih cifara.\/\/Dobivate popis cijelih brojeva.\/\/ >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\/\/ 10\n\/\/ >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\/\/ 25\n\/\/ >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\/\/ 13\n\/\/ >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\/\/ 11\n\/\/ >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\/\/ 3\n\/\/ >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\/\/ 7\nfunc skjkasdkd(lst []int) int {\n","canonical_solution":"package skjkasdkd_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\/\/ Function to calculate the sum of digits of a number\nfunc sumOfDigits(n int) int {\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\n\/\/ Function to find the largest prime and return the sum of its digits\nfunc skjkasdkd(lst []int) int {\n\tmaxPrime := -1\n\tfor _, num := range lst {\n\t\tif isPrime(num) && num > maxPrime {\n\t\t\tmaxPrime = num\n\t\t}\n\t}\n\tif maxPrime == -1 {\n\t\treturn 0\n\t}\n\treturn sumOfDigits(maxPrime)\n}\n\nfunc TestSkjkasdkd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},\n\t\t{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},\n\t\t{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},\n\t\t{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},\n\t\t{[]int{0, 81, 12, 3, 1, 21}, 3},\n\t\t{[]int{0, 8, 1, 2, 1, 7}, 7},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tresult := skjkasdkd(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"got %v, want %v\", result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSkjkasdkd(t *testing.T) {\n  candidate := skjkasdkd\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },\n     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },\n     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },\n     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },\n     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },\n     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },\n     { actual: candidate([]int{8191}), expected: 19 },\n     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },\n     { actual: candidate([]int{127, 97, 8192}), expected: 10 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_95","nl":"hrv_Latn","pl":"go_test.go","prompt":"package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Funkcija bi trebala vratiti false ako je data mapa prazna. \/\/case ili svi ključevi su nizovi u velikim slovima, inače vraća false. \/\/Ako je data mapa, vraćamo istinito ako su svi ključevi nizovi u donjem redu.\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunc check_dict_case(dict map[string]string) bool {\n","canonical_solution":"func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n\n    var allLowercase, allUppercase bool\n    for k := range dict {\n        if k != strings.ToLower(k) && k != strings.ToUpper(k) {\n            return false\n        }\n        if k == strings.ToLower(k) {\n            if allUppercase {\n                return false\n            }\n            allLowercase = true\n        }\n        if k == strings.ToUpper(k) {\n            if allLowercase {\n                return false\n            }\n            allUppercase = true\n        }\n    }\n\n    return allLowercase || allUppercase\n}","tests":"func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_96","nl":"hrv_Latn","pl":"go_test.go","prompt":"package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/na primjer: \/\/Cijeli brojevi koji su prvi brojevi i manji od n.\/\/Implementirajte funkciju koja uzima ne-negativni cijeli broj i vraća popis prvih n \/\/ >>> count_up_to(5)\n\/\/ []int{2, 3}\n\/\/ >>> count_up_to(11)\n\/\/ []int{2, 3, 5, 7}\n\/\/ >>> count_up_to(0)\n\/\/ []int{}\n\/\/ >>> count_up_to(20)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17, 19}\n\/\/ >>> count_up_to(1)\n\/\/ []int{}\n\/\/ >>> count_up_to(18)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int {\n","canonical_solution":"func count_up_to(n int) []int {\n\tprimes := []int{}\n\tfor num := 2; num < n; num++ {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\treturn primes\n}\n\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_97","nl":"hrv_Latn","pl":"go_test.go","prompt":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Pretpostavimo da je ulaz uvijek valjan.\/\/proizvod njihovih jediničnih brojeva. \/\/Završite funkciju koja uzima dva cijela broja i vraća \/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunc multiply(a int, b int) int {\n","canonical_solution":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Complete the function that takes two integers and returns \n\/\/ the product of their unit digits.\n\/\/ Assume the input is always valid.\nfunc multiply(a int, b int) int {\n    unitA := abs(a) % 10\n    unitB := abs(b) % 10\n    return unitA * unitB\n}\n\nfunc abs(n int) int {\n    if n < 0 {\n        return -n\n    }\n    return n\n}\n\nfunc TestMultiply(t *testing.T) {\n    fmt.Println(multiply(148, 412)) \/\/ 16\n    fmt.Println(multiply(19, 28))   \/\/ 72\n    fmt.Println(multiply(2020, 1851)) \/\/ 0\n    fmt.Println(multiply(14, -15))  \/\/ 20\n}","tests":"func TestMultiply(t *testing.T) {\n  candidate := multiply\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(148, 412), expected: 16 },\n     { actual: candidate(19, 28), expected: 72 },\n     { actual: candidate(2020, 1851), expected: 0 },\n     { actual: candidate(14, -15), expected: 20 },\n     { actual: candidate(76, 67), expected: 42 },\n     { actual: candidate(17, 27), expected: 49 },\n     { actual: candidate(0, 1), expected: 0 },\n     { actual: candidate(0, 0), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_98","nl":"hrv_Latn","pl":"go_test.go","prompt":"package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/S obzirom na niz s, prebroj veliki samoglasnici u parnim indeksima. \/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunc count_upper(s string) int {\n","canonical_solution":"package count_upper_test\n\nimport (\n    \"testing\"\n)\n\nfunc count_upper(s string) int {\n    uppercaseVowels := \"AEIOU\"\n    count := 0\n    \n    for i := 0; i < len(s); i += 2 {\n        if contains(uppercaseVowels, s[i]) {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfunc contains(vowels string, ch byte) bool {\n    for i := 0; i < len(vowels); i++ {\n        if vowels[i] == ch {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCountUpper(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"aBCdEf\", 1},\n        {\"abcdefg\", 0},\n        {\"dBBE\", 0},\n    }\n\n    for _, test := range tests {\n        result := count_upper(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestCount_Upper(t *testing.T) {\n  candidate := count_upper\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"aBCdEf\"), expected: 1 },\n     { actual: candidate(\"abcdefg\"), expected: 0 },\n     { actual: candidate(\"dBBE\"), expected: 0 },\n     { actual: candidate(\"B\"), expected: 0 },\n     { actual: candidate(\"U\"), expected: 1 },\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"EEEE\"), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_99","nl":"hrv_Latn","pl":"go_test.go","prompt":"package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/Od dva cijela broja, zaokružite ga od nule.\/\/i vraća najbliži cijeli broj. Ako je broj jednako udaljen \/\/Stvorite funkciju koja uzima vrijednost (string) koja predstavlja broj \/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n","canonical_solution":"package closest_integer_test\n\nimport (\n\t\"strconv\"\n\t\"math\"\n)\n\nfunc closest_integer(value string) int {\n\tnum, err := strconv.ParseFloat(value, 64)\n\tif err != nil {\n\t\treturn 0 \/\/ handle error appropriately in real scenarios\n\t}\n\tif num > 0 {\n\t\treturn int(math.Ceil(num - 0.5))\n\t}\n\treturn int(math.Floor(num + 0.5))\n}","tests":"func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_100","nl":"hrv_Latn","pl":"go_test.go","prompt":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/i predstavlja broj kamenja u razini (i+1). \/\/Vraća broj kamenja u svakoj razini u popisu, gdje je element u indeksu \/\/- sljedeći parni broj ako je n par. \/\/- sljedeći neparni broj ako je n neparno. \/\/Broj kamenja u sljedećoj razini je:\/\/Prvi nivo ima n kamenja.\/\/S obzirom na pozitivan cijeli broj n, morate napraviti hrpu od n razina kamenja.\/\/ >>> make_a_pile(3)\n\/\/ []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n","canonical_solution":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc make_a_pile(n int) []int {\n    pile := make([]int, n)\n    currentStones := n\n\n    for i := 0; i < n; i++ {\n        pile[i] = currentStones\n        if n%2 == 0 {\n            currentStones += 2\n        } else {\n            currentStones += 2\n        }\n    }\n\n    return pile\n}\n\nfunc TestMakeAPile(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected []int\n    }{\n        {3, []int{3, 5, 7}},\n        {4, []int{4, 6, 8, 10}},\n        {1, []int{1}},\n        {5, []int{5, 7, 9, 11, 13}},\n    }\n\n    for _, c := range cases {\n        res := make_a_pile(c.input)\n        if fmt.Sprintf(\"%v\", res) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"make_a_pile(%d) == %v, expected %v\", c.input, res, c.expected)\n        }\n    }\n}","tests":"func TestMake_A_Pile(t *testing.T) {\n  candidate := make_a_pile\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{3, 5, 7} },\n     { actual: candidate(4), expected: []int{4, 6, 8, 10} },\n     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },\n     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },\n     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_101","nl":"hrv_Latn","pl":"go_test.go","prompt":"package words_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/da razdvoji niz na riječi i vrati popis riječi.\/\/Dobićete niz riječi odvojenih zarezima ili razmakovima.\/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\nfunc words_string(s string) []string {\n","canonical_solution":"package words_string_test\n\nimport (\n    \"testing\"\n    \"strings\"\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc words_string(s string) []string {\n    re := regexp.MustCompile(`[,\\s]+`)\n    return re.Split(s, -1)\n}\n\nfunc TestWordsString(t *testing.T) {\n    tests := []struct{\n        input string\n        expected []string\n    }{\n        {\"Hi, my name is John\", []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}},\n        {\"One, two, three, four, five, six\", []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}},\n        {\"a,b,c\", []string{\"a\", \"b\", \"c\"}},\n        {\"hello world\", []string{\"hello\", \"world\"}},\n    }\n\n    for _, test := range tests {\n        result := words_string(test.input)\n        if !equal(result, test.expected) {\n            t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestWords_String(t *testing.T) {\n  candidate := words_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi, my name is John\"), expected: []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"} },\n     { actual: candidate(\"One, two, three, four, five, six\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"Hi, my name\"), expected: []string{\"Hi\", \"my\", \"name\"} },\n     { actual: candidate(\"One,, two, three, four, five, six,\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"ahmed     , gamal\"), expected: []string{\"ahmed\", \"gamal\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_102","nl":"hrv_Latn","pl":"go_test.go","prompt":"package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/ako takvog broja nema, onda funkcija treba vratiti -1.\/\/Najveći parni cijeli broj koji je u rasponu [x, y] uključujući.\/\/Ova funkcija uzima dva pozitivna broja x i y i vraća \/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunc choose_num(x int, y int) int {\n","canonical_solution":"func choose_num(x int, y int) int {\n\tif x > y {\n\t\treturn -1\n\t}\n\t\/\/ Start from y and move backwards looking for the largest even number\n\tfor i := y; i >= x; i-- {\n\t\tif i%2 == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc TestChooseNum(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, expected int\n\t}{\n\t\t{12, 15, 14},\n\t\t{13, 12, -1},\n\t\t{4, 10, 10},\n\t\t{5, 5, -1},\n\t\t{6, 6, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"x=%d_y=%d\", test.x, test.y), func(t *testing.T) {\n\t\t\tresult := choose_num(test.x, test.y)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For choose_num(%d, %d), expected %d, but got %d\", test.x, test.y, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestChoose_Num(t *testing.T) {\n  candidate := choose_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(12, 15), expected: 14 },\n     { actual: candidate(13, 12), expected: -1 },\n     { actual: candidate(33, 12354), expected: 12354 },\n     { actual: candidate(5234, 5233), expected: -1 },\n     { actual: candidate(6, 29), expected: 28 },\n     { actual: candidate(27, 10), expected: -1 },\n     { actual: candidate(7, 7), expected: -1 },\n     { actual: candidate(546, 546), expected: 546 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_104","nl":"hrv_Latn","pl":"go_test.go","prompt":"package unique_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Napomena: Povratni popis treba sortirati u porastu.\/\/elementi koji nemaju nijednu parnu cifru.\/\/Ako je data lista pozitivnih cijela brojeva x. vrati sortiranu listu svih \/\/ >>> unique_digits([]int{15, 33, 1422, 1})\n\/\/ []int{1, 15, 33}\n\/\/ >>> unique_digits([]int{152, 323, 1422, 10})\n\/\/ []int{}\nfunc unique_digits(x []int) []int {\n","canonical_solution":"package unique_digits_test\n\nimport (\n    \"sort\"\n)\n\n\/\/ unique_digits returns a sorted list of all elements that don't have any even digit.\nfunc unique_digits(x []int) []int {\n    result := []int{}\n    for _, num := range x {\n        if hasEvenDigit(num) == false {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\n\/\/ hasEvenDigit checks if a given number contains any even digit.\nfunc hasEvenDigit(num int) bool {\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            return true\n        }\n        num \/= 10\n    }\n    return false\n}","tests":"func TestUnique_Digits(t *testing.T) {\n  candidate := unique_digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },\n     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },\n     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },\n     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_105","nl":"hrv_Latn","pl":"go_test.go","prompt":"package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Jedan, dva, tri, četiri, pet, šest, sedam, osam, devet.\/\/preokrenite rezultiranu listu, a zatim zamijenite svaku cifru odgovarajućim imenom iz \/\/S obzirom na popis cijela brojeva, sortirajte cijela brojeva koji su između 1 i 9 uključujući, \/\/ >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})\n\/\/ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\/\/ If the list is empty, return an empty list:\n\/\/ >>> by_length([]int{})\n\/\/ []string{}\n\/\/ If the list has any strange number ignore it:\n\/\/ >>> by_length([]int{1, -1, 55})\n\/\/ []string{\"One\"}\nfunc by_length(arr []int) []string {\n","canonical_solution":"package by_length_test\n\nimport (\n    \"testing\"\n    \"sort\"\n)\n\nfunc by_length(arr []int) []string {\n    \/\/ Filter numbers between 1 and 9\n    filtered := []int{}\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            filtered = append(filtered, num)\n        }\n    }\n\n    \/\/ Sort in ascending order\n    sort.Ints(filtered)\n\n    \/\/ Reverse the sorted slice\n    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {\n        filtered[i], filtered[j] = filtered[j], filtered[i]\n    }\n\n    \/\/ Map numbers to their corresponding names\n    numToString := map[int]string{\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\",\n    }\n\n    \/\/ Create the result slice with names\n    result := []string{}\n    for _, num := range filtered {\n        result = append(result, numToString[num])\n    }\n\n    return result\n}\n\nfunc TestByLength(t *testing.T) {\n    tests := []struct {\n        input []int\n        want  []string\n    }{\n        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}},\n        {[]int{}, []string{}},\n        {[]int{1, -1, 55}, []string{\"One\"}},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n            got := by_length(test.input)\n            if !equals(got, test.want) {\n                t.Errorf(\"got = %v; want %v\", got, test.want)\n            }\n        })\n    }\n}\n\nfunc equals(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_106","nl":"hrv_Latn","pl":"go_test.go","prompt":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/i-ov faktorijal je množenje brojeva od 1 do i (1 * 2 * ... * i).\/\/Počinje od 1.\/\/ili zbir brojeva od 1 do i. \/\/i vraća popis veličine n, tako da je vrijednost elementa na indeksu i faktorijal i ako je i parna \/\/Implementirajte funkciju f koja uzima n kao parametar, \/\/ >>> f(5)\n\/\/ []int{1, 2, 6, 24, 15}\nfunc f(n int) []int {\n","canonical_solution":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc f(n int) []int {\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            result[i-1] = factorial(i)\n        } else {\n            result[i-1] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc factorial(num int) int {\n    if num <= 1 {\n        return 1\n    }\n    return num * factorial(num-1)\n}\n\nfunc sum(num int) int {\n    s := 0\n    for i := 1; i <= num; i++ {\n        s += i\n    }\n    return s\n}\n\nfunc TestF(t *testing.T) {\n    expected := []int{1, 2, 6, 24, 15}\n    result := f(5)\n    if !equals(expected, result) {\n        t.Errorf(\"Expected %v, got %v\", expected, result)\n    }\n}\n\nfunc equals(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(f(5)) \/\/ Output: []int{1, 2, 6, 24, 15}\n}","tests":"func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },\n     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },\n     { actual: candidate(1), expected: []int{1} },\n     { actual: candidate(3), expected: []int{1, 2, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_107","nl":"hrv_Latn","pl":"go_test.go","prompt":"package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer 1: \/\/cijele brojeve palindroma koji su u rasponu od ({1, n}) do ({1, n}).\/\/S obzirom na pozitivan cijeli broj n, vratite popis koji ima broj parnih i neparnih \/\/ >>> even_odd_palindrome(3)\n\/\/ []interface{}{1, 2}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ []interface{}{4, 6}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned list has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n int) []interface{} {\n","canonical_solution":"func isPalindrome(num int) bool {\n    original := num\n    reversed := 0\n    for num > 0 {\n        reversed = reversed*10 + num%10\n        num \/= 10\n    }\n    return original == reversed\n}\n\nfunc even_odd_palindrome(n int) []interface{} {\n    evenCount, oddCount := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n}","tests":"func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8, 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     { actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63), expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5, 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     { actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1), expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_108","nl":"hrv_Latn","pl":"go_test.go","prompt":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer, -123 ima potpisane cifre -1, 2 i 3.\/\/Ako je broj negativan, onda će njegova prva potpisana cifra biti negativna: \/\/Broj elemenata čiji je zbroj cifara > 0. \/\/Napisati funkciju count_nums koja uzima popis cijelih brojeva i vraća \/\/ >>> count_nums([]int{})\n\/\/ 0\n\/\/ >>> count_nums([]int{-1, 11, -11})\n\/\/ 1\n\/\/ >>> count_nums([]int{1, 1, 2})\n\/\/ 3\nfunc count_nums(arr []int) int {\n","canonical_solution":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        digits := num\n        sum := 0\n\n        if digits < 0 {\n            sum = digits % 10\n            digits = -digits \/ 10\n        }\n\n        for digits > 0 {\n            sum += digits % 10\n            digits \/= 10\n        }\n\n        if sum > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCountNums(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{}, 0},\n        {[]int{-1, 11, -11}, 1},\n        {[]int{1, 1, 2}, 3},\n    }\n\n    for _, tc := range testCases {\n        result := count_nums(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %v, got %v\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(count_nums([]int{-1, 11, -11})) \/\/ Output: 1\n    fmt.Println(count_nums([]int{1, 1, 2}))    \/\/ Output: 3\n}","tests":"func TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_109","nl":"hrv_Latn","pl":"go_test.go","prompt":"package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Napomena: Navedeni popis sigurno sadrži jedinstvene elemente.\/\/Ako je navedena lista prazna onda vraćamo valjano.\/\/onda vraćamo istinito ili vraćamo lažno.\/\/Ako je moguće dobiti sortiranu listu izvršavanjem gore navedene operacije \/\/početna pozicija na popisu, tj. 0-ti indeks. \/\/Posljednji element liste će biti premješten na \/\/Jedna desna pomakna operacija znači pomak svih elemenata liste za jedan.\/\/Možete izvesti desnu operaciju pomak bilo koji broj puta.\/\/U slučaju da se ne može izvesti,\/\/je moguće dobiti popis sortiran u redoslijedu bez pada, tako što se izvrši \/\/Brojevi na popisu će biti nasumično raspoređeni.\/\/Imamo popis 'arr' od N cifara arr[1], arr[2], ..., arr[N].\/\/ >>> move_one_ball([]int{3, 4, 5, 1, 2})\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given list.\n\/\/ >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ list by performing any number of right shift operations.\nfunc move_one_ball(arr []int) bool {\n","canonical_solution":"func move_one_ball(arr []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n    }\n\n    \/\/ Detect the point where the order breaks\n    countBreaks := 0\n    index := -1\n\n    for i := 0; i < n; i++ {\n        if arr[i] > arr[(i+1)%n] {\n            countBreaks++\n            index = i\n        }\n    }\n\n    \/\/ If there is at most one point where the order breaks\n    if countBreaks <= 1 {\n        return true\n    }\n\n    return false\n}","tests":"func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_110","nl":"hrv_Latn","pl":"go_test.go","prompt":"package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/U suprotnom, vratite \"NE\". \/\/Ako su svi elementi lst1 parni, vratite \"DA\".\/\/Ako je moguće zamijeniti elemente između lst1 i lst2 da bi se\/\/Nema ograničenja u broju izmjenjenih elemenata između lst1 i lst2. \/\/Da bi se napravio popis parnih brojeva.\/\/i utvrđuje je li moguće izvršiti razmjenu elemenata \/\/U ovom problemu, implementirat ćete funkciju koja uzima dvije liste brojeva, \/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})\n\/\/ \"YES\"\n\/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})\n\/\/ \"NO\"\n\/\/ It is assumed that the input lists will be non-empty.\nfunc exchange(lst1 []int, lst2 []int) string {\n","canonical_solution":"func exchange(lst1 []int, lst2 []int) string {\n    hasEvenInLst2 := false\n    \n    for _, num := range lst2 {\n        if num%2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasEvenInLst2 {\n        return \"NO\"\n    }\n    \n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"YES\"\n        }\n    }\n\n    return \"YES\"\n}","tests":"func TestExchange(t *testing.T) {\n  candidate := exchange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: \"YES\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: \"NO\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: \"NO\" },\n     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: \"NO\" },\n     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: \"YES\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_111","nl":"hrv_Latn","pl":"go_test.go","prompt":"package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/Ako se nekoliko slova pojavljuje na istom mjestu, vratite ih sve.\/\/U ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju, u ovom slučaju\/\/Ako je dat niz koji predstavlja mala slova odvojena prostorom, vratite mapu \/\/ >>> histogram(\"a b c\")\n\/\/ map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ map[string]int{\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ map[string]int{}\nfunc histogram(test string) map[string]int {\n","canonical_solution":"package histogram_test\n\nimport (\n    \"strings\"\n)\n\nfunc histogram(test string) map[string]int {\n    if test == \"\" {\n        return map[string]int{}\n    }\n\n    counts := make(map[string]int)\n    words := strings.Fields(test)\n    \n    var maxCount int\n    for _, word := range words {\n        counts[word]++\n        if counts[word] > maxCount {\n            maxCount = counts[word]\n        }\n    }\n\n    result := make(map[string]int)\n    for key, count := range counts {\n        if count == maxCount {\n            result[key] = count\n        }\n    }\n\n    return result\n}","tests":"func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_112","nl":"hrv_Latn","pl":"go_test.go","prompt":"package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer \/\/Trebate vratiti popis koji sadrži niz rezultata i istinito\/neistinito za provjeru. \/\/Niska se zove palindrom ako se čita isto unazad kao i naprijed.\/\/onda provjerite je li rezultirani niz palindrom. \/\/Imamo dva niza s i c, morate izbrisati sve znakove u s koji su jednaki bilo kojem znaku u c \/\/Zadatak \/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ []interface{}{\"bcd\", false}\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ []interface{}{\"acdef\", false}\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ []interface{}{\"cdedc\", true}\nfunc reverse_delete(s string, c string) []interface{} {\n","canonical_solution":"func reverse_delete(s string, c string) []interface{} {\n    \/\/ Create a map to store the characters to be deleted\n    deleteMap := make(map[rune]bool)\n    for _, ch := range c {\n        deleteMap[ch] = true\n    }\n    \n    \/\/ Filter the string s by removing characters present in deleteMap\n    var filteredString []rune\n    for _, ch := range s {\n        if !deleteMap[ch] {\n            filteredString = append(filteredString, ch)\n        }\n    }\n    \n    \/\/ Check if the filtered string is a palindrome\n    n := len(filteredString)\n    isPalindrome := true\n    for i := 0; i < n\/2; i++ {\n        if filteredString[i] != filteredString[n-1-i] {\n            isPalindrome = false\n            break\n        }\n    }\n    \n    \/\/ Convert filteredString to a string and prepare result\n    resultString := string(filteredString)\n    return []interface{}{resultString, isPalindrome}\n}","tests":"func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\", \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_113","nl":"hrv_Latn","pl":"go_test.go","prompt":"package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/od neparnih cifara u i'th niz ulaza. \/\/\" gdje bi svi i trebali biti zamijenjeni brojem \/\/Svaki element i izlaznih podataka treba biti \"broj neparnih elemenata u \/\/Ako je data lista niza, gdje se svaki niz sastoji samo od cifara, vrati popis.\/\/ >>> odd_count([]string{\"1234567\"})\n\/\/ []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n\/\/ >>> odd_count([]string{\"3\", \"11111111\"})\n\/\/ []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}\nfunc odd_count(lst []string) []string {\n","canonical_solution":"package odd_count_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc odd_count(lst []string) []string {\n\tresult := []string{}\n\tfor _, str := range lst {\n\t\toddCount := 0\n\t\tfor _, char := range str {\n\t\t\tif char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {\n\t\t\t\toddCount++\n\t\t\t}\n\t\t}\n\t\toutput := fmt.Sprintf(\"the number of odd elements %dn the str%1ng %d of the %dnput.\", oddCount, oddCount, oddCount)\n\t\tresult = append(result, output)\n\t}\n\treturn result\n}\n\nfunc TestOddCount(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{[]string{\"1234567\"}, []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}},\n\t\t{[]string{\"3\", \"11111111\"}, []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif result := odd_count(test.input); !equals(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equals(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOdd_Count(t *testing.T) {\n  candidate := odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"1234567\"}), expected: []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"} },\n     { actual: candidate([]string{\"3\", \"11111111\"}), expected: []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"} },\n     { actual: candidate([]string{\"271\", \"137\", \"314\"}), expected: []string{\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_114","nl":"hrv_Latn","pl":"go_test.go","prompt":"package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer \/\/Od brojeva.\/\/S obzirom na popis cijelih brojeva, pronađite minimalni iznos svih ne-praznih pod-lista \/\/ >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n\/\/ 1\n\/\/ >>> minSubArraySum([]int{-1, -2, -3})\n\/\/ -6\nfunc minSubArraySum(nums []int) int {\n","canonical_solution":"if len(nums) == 0 {\n        return 0\n    }\n    \n    minEndingHere := nums[0]\n    minSoFar := nums[0]\n\n    for _, num := range nums[1:] {\n        if minEndingHere > 0 {\n            minEndingHere = num\n        } else {\n            minEndingHere += num\n        }\n        \n        if minEndingHere < minSoFar {\n            minSoFar = minEndingHere\n        }\n    }\n    \n    return minSoFar\n}","tests":"func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     { actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}), expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_115","nl":"hrv_Latn","pl":"go_test.go","prompt":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer 1: \/\/Izdaj broj puta koji trebaš spustiti kante.\/\/Vaš zadatak je da koristite kante da ispraznite bunare.\/\/i sve kante imaju isti kapacitet.\/\/Svaki bunar ima odgovarajuću kantu koja se može koristiti za izvlačenje vode iz njega, \/\/i svaka 1 u redu predstavlja jednu jedinicu vode. \/\/Svaki red predstavlja jedan bunar.\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid [][]int, capacity int) int {\n","canonical_solution":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_fill(grid [][]int, capacity int) int {\n    totalLowerings := 0\n\n    for _, row := range grid {\n        waterInRow := 0\n        \n        for _, cell := range row {\n            if cell == 1 {\n                waterInRow++\n            }\n        }\n\n        totalLowerings += (waterInRow + capacity - 1) \/ capacity\n    }\n\n    return totalLowerings\n}\n\nfunc TestMaxFill(t *testing.T) {\n    tests := []struct {\n        grid     [][]int\n        capacity int\n        expected int\n    }{\n        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},\n        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},\n        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},\n    }\n\n    for _, test := range tests {\n        result := max_fill(test.grid, test.capacity)\n        if result != test.expected {\n            t.Errorf(\"For grid %v with capacity %d, expected %d but got %d\", test.grid, test.capacity, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) \/\/ Output: 6\n    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) \/\/ Output: 5\n    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) \/\/ Output: 0\n}","tests":"func TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_116","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mora se provesti ovako: \/\/Za sličan broj jedinica, sortirajte na temelju decimalne vrijednosti.\/\/Broj jedinica u binarnom prikazu u rastućem redoslijedu.\/\/U ovom Kata, morate sortirati popis ne-negativnih cijelih brojeva prema \/\/ >>> sort_array([]int{1, 5, 2, 3, 4})\n\/\/ []int{1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{-2, -3, -4, -5, -6})\n\/\/ []int{-6, -5, -4, -3, -2}\n\/\/ >>> sort_array([]int{1, 0, 2, 3, 4})\n\/\/ []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(arr []int) []int {\n    sort.Slice(arr, func(i, j int) bool {\n        countOnes := func(x int) int {\n            count := 0\n            for x != 0 {\n                count += x & 1\n                x >>= 1\n            }\n            return count\n        }\n\n        countI := countOnes(arr[i])\n        countJ := countOnes(arr[j])\n\n        if countI == countJ {\n            return arr[i] < arr[j]\n        }\n        return countI < countJ\n    })\n    return arr\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_117","nl":"hrv_Latn","pl":"go_test.go","prompt":"package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Napomena: možete pretpostaviti da unosni niz sadrži samo slova i razmakove.\/\/Ako je niz s prazan, funkcija bi trebala vratiti praznu listu. \/\/n suglasnika, kako bi se ove riječi pojavljuju u nizu s. \/\/funkcija koja vraća popis svih riječi iz niza s koje sadrže točno \/\/S obzirom na niz s i prirodni broj n, dobio si zadatak da implementiraš \/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ []string{\"little\"}\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ []string{\"Mary\", \"lamb\"}\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []string{}\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ []string{\"world\"}\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n","canonical_solution":"package select_words_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc select_words(s string, n int) []string {\n\t\/\/ Define a helper function to check if a character is a consonant.\n\tisConsonant := func(c rune) bool {\n\t\tc = rune(strings.ToLower(string(c))[0])\n\t\treturn c >= 'a' && c <= 'z' && !strings.ContainsRune(\"aeiou\", c)\n\t}\n\n\t\/\/ Split the string into words.\n\twords := strings.Fields(s)\n\tvar result []string\n\n\t\/\/ Iterate over each word.\n\tfor _, word := range words {\n\t\tconsonantCount := 0\n\t\t\/\/ Count the consonants in the word.\n\t\tfor _, char := range word {\n\t\t\tif isConsonant(char) {\n\t\t\t\tconsonantCount++\n\t\t\t}\n\t\t}\n\t\t\/\/ If the number of consonants matches n, add the word to the result.\n\t\tif consonantCount == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc TestSelectWords(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        string\n\t\tn        int\n\t\texpected []string\n\t}{\n\t\t{\"Mary had a little lamb\", 4, []string{\"little\"}},\n\t\t{\"Mary had a little lamb\", 3, []string{\"Mary\", \"lamb\"}},\n\t\t{\"simple white space\", 2, []string{}},\n\t\t{\"Hello world\", 4, []string{\"world\"}},\n\t\t{\"Uncle sam\", 3, []string{\"Uncle\"}},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tresult := select_words(testCase.s, testCase.n)\n\t\tif !equal(result, testCase.expected) {\n\t\t\tt.Errorf(\"For input '%s' with n=%d, expected %v, but got %v\", testCase.s, testCase.n, testCase.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_118","nl":"hrv_Latn","pl":"go_test.go","prompt":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/Možete pretpostaviti da je data stringa sadrži samo engleski pismo. \/\/Nađi samoglasnik koji ispunjava gore navedene uvjete.\/\/Samoglasnici na početku i kraju se ne računaju.\/\/dva suglasnika s desne strane riječi (s obzirom na veličinu). \/\/Vaša zadaća je da pronađete najbliži samoglasnik koji stoji između \/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunc get_closest_vowel(word string) string {\n","canonical_solution":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_closest_vowel(word string) string {\n    vowels := \"aeiouAEIOU\"\n    isVowel := make(map[rune]bool)\n    for _, v := range vowels {\n        isVowel[v] = true\n    }\n    \n    n := len(word)\n    for i := n-2; i > 0; i-- {\n        if isVowel[rune(word[i])] && \n           !isVowel[rune(word[i-1])] && \n           !isVowel[rune(word[i+1])] {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\/\/ Test functions\nfunc TestGetClosestVowel(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"yogurt\", \"u\"},\n        {\"FULL\", \"U\"},\n        {\"quick\", \"\"},\n        {\"ab\", \"\"},\n    }\n    \n    for _, test := range tests {\n        result := get_closest_vowel(test.input)\n        if result != test.expected {\n            t.Errorf(\"get_closest_vowel(%q) = %q; want %q\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(get_closest_vowel(\"yogurt\")) \/\/ Output: \"u\"\n    fmt.Println(get_closest_vowel(\"FULL\"))   \/\/ Output: \"U\"\n    fmt.Println(get_closest_vowel(\"quick\"))  \/\/ Output: \"\"\n    fmt.Println(get_closest_vowel(\"ab\"))     \/\/ Output: \"\"\n}","tests":"func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_119","nl":"hrv_Latn","pl":"go_test.go","prompt":"package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Vratite 'Da' ako postoji način da napravite dobar niz, i vratite 'Ne' u suprotnom.\/\/\" (()) \" nije. \/\/Na primjer: niz '(()))) je dobar, dok je niz \/\/Niz S se smatra dobrim ako i samo ako su sve zagrade u S \/\/neki red, da će rezultirajući niz biti dobar.\/\/Vaš posao je da provjerite je li moguće povezati dvije žice u \/\/samo u zagradama \" ((\") ili u zatvorenim zagradama \") \". \/\/Dobivate popis od dva niza, oba niza se sastoje od open \/\/ >>> match_parens([]string{\"()(\", \")\"})\n\/\/ \"Yes\"\n\/\/ >>> match_parens([]string{\")\", \")\"})\n\/\/ \"No\"\nfunc match_parens(lst []string) string {\n","canonical_solution":"func match_parens(lst []string) string {\n\tleft1, right1 := countParens(lst[0])\n\tleft2, right2 := countParens(lst[1])\n\n\tif left1+left2 == right1+right2 {\n\t\treturn \"Yes\"\n\t}\n\n\tif left1-right1+left2-right2 == 0 {\n\t\treturn \"Yes\"\n\t}\n\n\treturn \"No\"\n}\n\nfunc countParens(s string) (left int, right int) {\n\tfor _, c := range s {\n\t\tif c == '(' {\n\t\t\tleft++\n\t\t} else if c == ')' {\n\t\t\tright++\n\t\t}\n\t}\n\treturn\n}\n\nfunc TestMatchParens(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected string\n\t}{\n\t\t{[]string{\"()(\", \")\"}, \"Yes\"},\n\t\t{[]string{\")\", \")\"}, \"No\"},\n\t\t{[]string{\"(((\", \")))\"}, \"Yes\"},\n\t\t{[]string{\"(\", \")\"}, \"Yes\"},\n\t\t{[]string{\"))(\", \"(\"}, \"No\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tif got := match_parens(test.input); got != test.expected {\n\t\t\t\tt.Errorf(\"match_parens(%v) = %v; want %v\", test.input, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_120","nl":"hrv_Latn","pl":"go_test.go","prompt":"package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer 1: \/\/dužine k s najvećim brojem k u arr. \/\/Ako je data lista cijelih brojeva arr i pozitivan cjelina k, vrati sortiranu listu \/\/ >>> maximum([]int{-3, -4, 5}, 3)\n\/\/ []int{-4, -3, 5}\n\/\/ Example 2:\n\/\/ >>> maximum([]int{4, -4, 4}, 2)\n\/\/ []int{4, 4}\n\/\/ Example 3:\n\/\/ >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)\n\/\/ []int{2}\n\/\/ Note:\n\/\/ 1. The length of the list will be in the range of [1, 1000].\n\/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n","canonical_solution":"package maximum_test\n\nimport (\n    \"sort\"\n)\n\nfunc maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    \n    \/\/ Sort the array\n    sort.Ints(arr)\n    \n    \/\/ Get the last k elements, which are the largest\n    return arr[len(arr)-k:]\n}","tests":"func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_121","nl":"hrv_Latn","pl":"go_test.go","prompt":"package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/S obzirom na nepraznu listu cijelih brojeva, vratite zbir svih neparnih elemenata koji su u parnim položajima. \/\/ >>> solution([]int{5, 8, 7, 1})\n\/\/ 12\n\/\/ >>> solution([]int{3, 3, 3, 3, 3})\n\/\/ 9\n\/\/ >>> solution([]int{30, 13, 24, 321})\n\/\/ 0\nfunc solution(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 0; i < len(lst); i++ {\n        if i%2 == 0 && lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestSolution(t *testing.T) {\n  candidate := solution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },\n     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },\n     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },\n     { actual: candidate([]int{5, 9}), expected: 5 },\n     { actual: candidate([]int{2, 4, 8}), expected: 0 },\n     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },\n     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_122","nl":"hrv_Latn","pl":"go_test.go","prompt":"package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/U slučaju da se primjenjuje jedna od sljedećih formula:\/\/S obzirom na neprazan popis cijelih brojeva arr i cijelog broja k, vratimo \/\/ >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr []int, k int) int {\n","canonical_solution":"func add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd_Elements(t *testing.T) {\n  candidate := add_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },\n     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },\n     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },\n     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },\n     { actual: candidate([]int{1}, 1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_123","nl":"hrv_Latn","pl":"go_test.go","prompt":"package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/get_odd_collatz(5) vraća [1, 5] # Collatz niz za 5 je [5, 16, 8, 4, 2, 1], tako da su neparni brojevi samo 1, i 5. \/\/Na primjer: \/\/2. vraćena lista sortirana u porastu. \/\/1. Collatz(1) je [1]. \/\/Napomena: \/\/Pretpostavka je da bez obzira na vrijednost n, slijed će uvijek dostići 1.\/\/Ako je prethodni izraz neparan, sljedeći izraz je 3 puta prethodni.\/\/Prethodni izraz je pola od \/\/Kao što slijedi: počnite s bilo kojim pozitivnim cijelim brojem n. Zatim se svaki izraz dobiva iz \/\/Collatzova pretpostavka je pretpostavka u matematici koja se odnosi na slijed definiran \/\/S obzirom na pozitivan cijeli broj n, vratite sortiranu listu koja ima neparne brojeve u Collatz slijedu. \/\/ >>> get_odd_collatz(5)\n\/\/ []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n","canonical_solution":"package get_odd_collatz_test\n\nimport (\n    \"sort\"\n)\n\nfunc get_odd_collatz(n int) []int {\n    oddNumbers := make(map[int]bool)\n\n    for n != 1 {\n        if n%2 != 0 {\n            oddNumbers[n] = true\n        }\n        if n%2 == 0 {\n            n \/= 2\n        } else {\n            n = 3*n + 1\n        }\n    }\n\n    \/\/ Add 1 to the set of odd numbers because the sequence always ends at 1\n    oddNumbers[1] = true\n\n    \/\/ Extract the keys, which represent the odd numbers\n    result := make([]int, 0, len(oddNumbers))\n    for num := range oddNumbers {\n        result = append(result, num)\n    }\n\n    \/\/ Sort the result\n    sort.Ints(result)\n\n    return result\n}","tests":"func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_124","nl":"hrv_Latn","pl":"go_test.go","prompt":"package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/4. Datum treba biti u formatu: mm-dd-rrrr \/\/3. Mjeseci ne bi trebali biti manji od 1 ili veći od 12.\/\/Broj dana nije manji od 1 ili veći od 31 dana za mjesece 1,3,5,7,8,10,12. Broj dana nije manji od 1 ili veći od 30 dana za mjesece 4,6,9,11. Broj dana nije manji od 1 ili veći od 29 dana za mjesec 2.\/\/1. niz datuma nije prazan.\/\/Datum je valjan ako su ispunjena sva sljedeća pravila: \/\/vraća vrijednost istinita ako je datum valjan, u suprotnom vrijednost lažna. \/\/Morate napisati funkciju koja potvrđuje datirani niz i \/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunc valid_date(date string) bool {\n","canonical_solution":"func valid_date(date string) bool {\n    if len(date) == 0 {\n        return false\n    }\n\n    var month, day, year int\n    n, err := fmt.Sscanf(date, \"%02d-%02d-%04d\", &month, &day, &year)\n\n    if err != nil || n != 3 {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if month == 2 {\n        if day < 1 || day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n\n    return true\n}","tests":"func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_126","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/Ne pretpostavljajte negativne brojeve i samo cjelokupne brojeve.\/\/Ako popis ima više od jednog duplikata istog \/\/Ako je data lista brojeva, vrati ih, raspoređene ili ne.\/\/ >>> is_sorted([]int{5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n\/\/ false\nfunc is_sorted(lst []int) bool {\n","canonical_solution":"func is_sorted(lst []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    \n    duplicateCount := make(map[int]int)\n\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        duplicateCount[lst[i]]++\n        if duplicateCount[lst[i]] > 1 {\n            return false\n        }\n    }\n    \n    \/\/ Check the last element for duplicate\n    duplicateCount[lst[len(lst)-1]]++\n    if duplicateCount[lst[len(lst)-1]] > 1 {\n        return false\n    }\n\n    return true\n}","tests":"func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_127","nl":"hrv_Latn","pl":"go_test.go","prompt":"package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/[Ulaz\/izlaz] uzorci: \/\/Ako se dva intervala ne prekidaju, vratite \"NE\".\/\/U suprotnom, vratite \"NE\". \/\/Ako je dužina presjeka prost broj, vratite \"DA\", \/\/koji je njegova dužina 1, koji nije prost broj. \/\/Primjer, presjek intervala (1, 3), (2, 4) je (2, 3) \/\/Intervali su prosti brojevi.\/\/Vaš zadatak je da odredite je li dužina presjeka ove dvije \/\/Za svaki dan intervala, pretpostavlja se da je njegov početak manji ili jednak njegovom kraju.\/\/uključuje i početak i kraj. \/\/Ako je to moguće, u nastavku se navodi sljedeća oznaka:\/\/gdje je svaki interval par cijelih brojeva. Na primjer, interval = (početak, kraj) = (1, 2).\/\/Imate dva intervala.\/\/ >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\/\/ \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n","canonical_solution":"package intersection_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to determine if a number is prime\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tif num == 2 {\n\t\treturn true\n\t}\n\tif num%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= num; i += 2 {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n\tstart1, end1 := interval1[0].(int), interval1[1].(int)\n\tstart2, end2 := interval2[0].(int), interval2[1].(int)\n\n\t\/\/ Determine the intersection of two intervals\n\tintersectStart := max(start1, start2)\n\tintersectEnd := min(end1, end2)\n\n\tif intersectStart > intersectEnd {\n\t\treturn \"NO\"\n\t}\n\n\t\/\/ The length of intersection is end - start\n\tlengthOfIntersection := intersectEnd - intersectStart\n\tif isPrime(lengthOfIntersection) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\n\/\/ Helper function to find the maximum of two integers\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\/\/ Helper function to find the minimum of two integers\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc TestIntersection(t *testing.T) {\n\tif intersection([]interface{}{1, 2}, []interface{}{2, 3}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != \"YES\" {\n\t\tt.Error(\"Expected YES\")\n\t}\n}","tests":"func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_129","nl":"hrv_Latn","pl":"go_test.go","prompt":"package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Vraća redoviti popis vrijednosti u ćelijama kroz koje prolazi minimalna putanja. \/\/Garantujemo da je odgovor jedinstven. \/\/lst_A[j] = lst_B[j].\/\/tako da lst_A[i] < lst_B[i] i za bilo koji j (1 <= j < i) imamo \/\/od lst_B, drugim riječima, postoji cjeloviti indeks i (1 <= i <= k) \/\/kroz (nazovimo ih lst_A i lst_B), lst_A je leksikografski manje \/\/Nakon što napravimo redovite liste vrijednosti u ćelijama koje A i B idu \/\/U slučaju da se u jednom od sljedećih slučajeva izračunava u skladu s točkom (b) ili (c) ovog članka, u sljedećem slučaju izračunava se u skladu s točkom (d) ovog članka.\/\/Ne možeš nestati.\/\/Ne nužno različiti).\/\/Napomena: putanje dužine k znači da se posjećuje točno k ćelija (ne \/\/          \/\/Drugim riječima, možete ići u stanice koje dijele rub s vama sadašnje \/\/iz bilo koje stanice, i u svakom koraku možete se preseliti na bilo koju od susjednih stanica, \/\/Morate pronaći minimalni put dužine k u mreži.\/\/uključiv pojavljuje se točno jednom u ćelijama mreže. \/\/Svaka cijela broj u rasponu [1, N * N] \/\/S obzirom na mrežu s N redova i N stupova (N >= 2) i pozitivan cjelokupni broj k, \/\/ >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)\n\/\/ []int{1, 2, 1}\n\/\/ >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)\n\/\/ []int{1}\nfunc minPath(grid [][]int, k int) []int {\n","canonical_solution":"package minPath_test\n\nimport (\n    \"sort\"\n)\n\nfunc minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    \n    var dfs func(x, y, length int, path []int)\n    var minPath []int\n    minPath = make([]int, k)\n    for i := 0; i < k; i++ {\n        minPath[i] = n*n + 1\n    }\n\n    dfs = func(x, y, length int, path []int) {\n        if length == k {\n            if isLess(path, minPath) {\n                copy(minPath, path)\n            }\n            return\n        }\n        \n        for _, dir := range directions {\n            nx, ny := x+dir[0], y+dir[1]\n            if nx >= 0 && ny >= 0 && nx < n && ny < n {\n                path[length] = grid[nx][ny]\n                dfs(nx, ny, length+1, path)\n            }\n        }\n    }\n    \n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            path := make([]int, k)\n            path[0] = grid[i][j]\n            dfs(i, j, 1, path)\n        }\n    }\n    \n    return minPath\n}\n\nfunc isLess(a, b []int) bool {\n    for i := 0; i < len(a); i++ {\n        if a[i] < b[i] {\n            return true\n        }\n        if a[i] > b[i] {\n            return false\n        }\n    }\n    return false\n}","tests":"func TestMinpath(t *testing.T) {\n  candidate := minPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },\n     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },\n     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },\n     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },\n     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },\n     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },\n     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_130","nl":"hrv_Latn","pl":"go_test.go","prompt":"package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Prvi n + 1 brojevi Tribonaccijevog slijeda.\/\/Ako vam je dat ne-negativan cijeli broj n, morate vratiti popis \/\/= 2 + 3 + 3 = 8 \/\/tri(3) = tri(2) + tri(1) + tri(4) \/\/tri(4) = 3 \/\/tri(2) = 1 + (2 \/ 2) = 2 \/\/Na primjer: \/\/tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), ako je n neparno. \/\/tri (n) = 1 + n \/ 2, ako je n parna. \/\/tri(1) = 3 \/\/Tribonaccijeva sekvenca je definirana ponavljanjem: \/\/Međutim, ono što ljudi ne znaju je Tribonaccijev niz.\/\/Svi znaju Fibonaccijev niz, matematičari su ga proučavali u dubini u \/\/ >>> tri(3)\n\/\/ []int{1, 3, 2, 8}\nfunc tri(n int) []int {\n","canonical_solution":"func tri(n int) []int {\n    if n < 0 {\n        return []int{}\n    }\n    sequence := make([]int, n+1)\n    sequence[0] = 1 \/\/ tri(0) is not defined in problem, let's start with tri(1)\n    if n >= 1 {\n        sequence[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            sequence[i] = 1 + i\/2\n        } else {\n            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)\n        }\n    }\n    return sequence\n}\n\nfunc getNextTribonacci(n int) int {\n    if n%2 == 0 {\n        return 1 + n\/2\n    }\n    return getNextTribonacciRec(n+1)\n}\n\nfunc getNextTribonacciRec(n int) int {\n    triNext := make([]int, n+1)\n    triNext[0] = 1 \/\/ again assuming some base start\n    if n >= 1 {\n        triNext[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            triNext[i] = 1 + i\/2\n        } else {\n            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)\n        }\n    }\n    return triNext[n]\n}","tests":"func TestTri(t *testing.T) {\n  candidate := tri\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{1, 3, 2, 8} },\n     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },\n     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },\n     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },\n     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },\n     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },\n     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },\n     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },\n     { actual: candidate(0), expected: []int{1} },\n     { actual: candidate(1), expected: []int{1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_131","nl":"hrv_Latn","pl":"go_test.go","prompt":"package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Vrati 0 ako su sve cifre parne. \/\/Ako je n pozitivan cijeli broj, vratite proizvod neparnih cifara. \/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunc digits(n int) int {\n","canonical_solution":"product := 1\n    hasOdd := false\n\n    for n > 0 {\n        digit := n % 10\n        if digit%2 != 0 {\n            product *= digit\n            hasOdd = true\n        }\n        n \/= 10\n    }\n\n    if hasOdd {\n        return product\n    }\n    return 0\n}","tests":"func TestDigits(t *testing.T) {\n  candidate := digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 5 },\n     { actual: candidate(54), expected: 5 },\n     { actual: candidate(120), expected: 1 },\n     { actual: candidate(5014), expected: 5 },\n     { actual: candidate(98765), expected: 315 },\n     { actual: candidate(5576543), expected: 2625 },\n     { actual: candidate(2468), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_132","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/U ovom slučaju, u sljedećim slučajevima, u skladu s člankom 5. stavkom 1. točka (b) i (c) ovog Priloga, u slučaju da se primjenjuje sljedeće:\/\/Funkcija bi trebala vratiti vrijednost true ako i samo ako postoji valjan niz zagrada \/\/Stvorite funkciju koja uzima niz kao ulaz koji sadrži samo kvadratne zagrade. \/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunc is_nested(myString string) bool {\n","canonical_solution":"func is_nested(myString string) bool {\n\tstack := []rune{}\n\tnestingFound := false\n\n\tfor _, char := range myString {\n\t\tif char == '[' {\n\t\t\tstack = append(stack, char)\n\t\t} else if char == ']' {\n\t\t\tif len(stack) > 0 {\n\t\t\t\tstack = stack[:len(stack)-1]\n\t\t\t\tif len(stack) > 0 {\n\t\t\t\t\tnestingFound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nestingFound\n}","tests":"func TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_133","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Najprije zaokružite svaki element na popisu do gornjeg broja.\/\/Morate vratiti zbroj kvadratnih brojeva na datoj listi, \/\/Dobivate popis brojeva.\/\/ >>> lst([]float64{1.0, 2.0, 3.0})\n\/\/ 14\n\/\/ >>> lst([]float64{1.0, 4.0, 9.0})\n\/\/ 98\n\/\/ >>> lst([]float64{1.0, 3.0, 5.0, 7.0})\n\/\/ 84\n\/\/ >>> lst([]float64{1.4, 4.2, 0.0})\n\/\/ 29\n\/\/ >>> lst([]float64{-2.4, 1.0, 1.0})\n\/\/ 6\nfunc sum_squares(lst []float64) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n\t\"math\"\n)\n\nfunc sum_squares(lst []float64) int {\n\tsum := 0\n\tfor _, num := range lst {\n\t\tceiledNum := math.Ceil(num)\n\t\tsum += int(ceiledNum * ceiledNum)\n\t}\n\treturn sum\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },\n     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },\n     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },\n     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },\n     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },\n     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },\n     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },\n     { actual: candidate([]float64{0.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0}), expected: 1 },\n     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_134","nl":"hrv_Latn","pl":"go_test.go","prompt":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Napomena: \"riječ\" je skupina znakova odvojenih razmakom. \/\/dio riječi, i lažno inače.\/\/je abecedni znak, a ne \/\/Stvorite funkciju koja vraća vrijednost true ako je posljednji znak \/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n","canonical_solution":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"unicode\"\n)\n\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {\n        return false\n    }\n    \n    lastCharIndex := len(txt) - 1\n    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {\n        lastCharIndex--\n    }\n    \n    if lastCharIndex < 0 {\n        return false\n    }\n\n    if !unicode.IsLetter(rune(txt[lastCharIndex])) {\n        return false\n    }\n    \n    \/\/ Check if it's part of a word by looking at the previous character\n    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {\n        return false\n    }\n\n    return true\n}\n\nfunc TestCheckIfLastCharIsALetter(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected bool\n    }{\n        {\"apple pie\", false},\n        {\"apple pi e\", true},\n        {\"apple pi e \", false},\n        {\"\", false},\n        {\"hello world\", true},\n        {\"a \", true},\n        {\" a\", true},\n        {\"abc\", false},\n        {\"abc \", false},\n    }\n\n    for _, c := range cases {\n        t.Run(c.input, func(t *testing.T) {\n            result := check_if_last_char_is_a_letter(c.input)\n            if result != c.expected {\n                t.Errorf(\"Expected %v, got %v for input \\\"%s\\\"\", c.expected, result, c.input)\n            }\n        })\n    }\n}","tests":"func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_135","nl":"hrv_Latn","pl":"go_test.go","prompt":"package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/               \/\/ako takva vrsta elementa ne postoji, onda se vraća -1.\/\/nije veći od ili jednak elementu koji mu neposredno prethodi.\/\/Stvorite funkciju koja vraća najveći indeks elementa koji \/\/ >>> can_arrange([]int{1, 2, 4, 3, 5})\n\/\/ 3\n\/\/ >>> can_arrange([]int{1, 2, 3})\n\/\/ -1\nfunc can_arrange(arr []int) int {\n","canonical_solution":"package can_arrange_test\n\nfunc can_arrange(arr []int) int {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_136","nl":"hrv_Latn","pl":"go_test.go","prompt":"package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Ako nema negativnih ili pozitivnih cijelih brojeva, vratite ih kao nil. \/\/Pozitivnih cijela brojeva u popisu.\/\/Najveći od negativnih cifara, a \"b\" je najmanji \/\/Stvorite funkciju koja vraća popis (a, b), gdje je 'a' \/\/ >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\/\/ []interface{}{nil, 1}\n\/\/ >>> largest_smallest_integers([]int{})\n\/\/ []interface{}{nil, nil}\n\/\/ >>> largest_smallest_integers([]int{0})\n\/\/ []interface{}{nil, nil}\nfunc largest_smallest_integers(lst []int) []interface{} {\n","canonical_solution":"func largest_smallest_integers(lst []int) []interface{} {\n    var largestNegative *int\n    var smallestPositive *int\n\n    for _, num := range lst {\n        if num < 0 {\n            if largestNegative == nil || num > *largestNegative {\n                largestNegative = new(int)\n                *largestNegative = num\n            }\n        } else if num > 0 {\n            if smallestPositive == nil || num < *smallestPositive {\n                smallestPositive = new(int)\n                *smallestPositive = num\n            }\n        }\n    }\n\n    var result = []interface{}{nil, nil}\n    if largestNegative != nil {\n        result[0] = *largestNegative\n    }\n    if smallestPositive != nil {\n        result[1] = *smallestPositive\n    }\n\n    return result\n}","tests":"func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_138","nl":"hrv_Latn","pl":"go_test.go","prompt":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer \/\/Procijenite može li se dati broj n zapisati kao zbroj točno 4 pozitivna parna broja \/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n","canonical_solution":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n\/\/ Example\n\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n    \/\/ The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    \/\/ Therefore, n must be at least 8 and n must be even\n    return n >= 8 && n%2 == 0\n}\n\n\/\/ Testing the function\nfunc TestIsEqualToSumEven(t *testing.T) {\n    cases := []struct {\n        n      int\n        expect bool\n    }{\n        {4, false},\n        {6, false},\n        {8, true},\n        {10, true},\n        {12, true},\n        {14, true},\n        {16, true},\n    }\n\n    for _, c := range cases {\n        result := is_equal_to_sum_even(c.n)\n        if result != c.expect {\n            t.Errorf(\"is_equal_to_sum_even(%d) == %v, expect %v\", c.n, result, c.expect)\n        } else {\n            fmt.Printf(\"Success: is_equal_to_sum_even(%d) == %v\\n\", c.n, result)\n        }\n    }\n}","tests":"func TestIs_Equal_To_Sum_Even(t *testing.T) {\n  candidate := is_equal_to_sum_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: false },\n     { actual: candidate(6), expected: false },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: true },\n     { actual: candidate(11), expected: false },\n     { actual: candidate(12), expected: true },\n     { actual: candidate(13), expected: false },\n     { actual: candidate(16), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_139","nl":"hrv_Latn","pl":"go_test.go","prompt":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/gdje je n > 0 \/\/brazilski_faktorik (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/Brazilski faktorijal je definiran kao: \/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunc special_factorial(n int) int {\n","canonical_solution":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc special_factorial(n int) int {\n    if n <= 0 {\n        return 1\n    }\n    \n    result := 1\n    for i := 1; i <= n; i++ {\n        result *= factorial(i)\n    }\n    \n    return result\n}\n\nfunc factorial(x int) int {\n    if x == 0 {\n        return 1\n    }\n    prod := 1\n    for i := 1; i <= x; i++ {\n        prod *= i\n    }\n    return prod\n}\n\nfunc TestSpecialFactorial(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {4, 288},      \/\/ 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n        {3, 12},       \/\/ 3! * 2! * 1! = 6 * 2 * 1 = 12\n        {2, 2},        \/\/ 2! * 1! = 2 * 1 = 2\n        {1, 1},        \/\/ 1! = 1\n        {0, 1},        \/\/ Edge case for n=0, considered as 1 for special factorial\n    }\n\n    for _, c := range cases {\n        result := special_factorial(c.input)\n        if result != c.expected {\n            t.Errorf(\"special_factorial(%d) == %d, want %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(special_factorial(4)) \/\/ Output: 288\n    fmt.Println(special_factorial(3)) \/\/ Output: 12\n}","tests":"func TestSpecial_Factorial(t *testing.T) {\n  candidate := special_factorial\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: 288 },\n     { actual: candidate(5), expected: 34560 },\n     { actual: candidate(7), expected: 125411328000 },\n     { actual: candidate(1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_140","nl":"hrv_Latn","pl":"go_test.go","prompt":"package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Onda zamijenite sve uzastopne prostore sa - \/\/i ako niz ima više od 2 uzastopna prostora, \/\/Ako je riječ o tekstu, zamjenite sve prostore podvlačenim znakovima, \/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunc fix_spaces(text string) string {\n","canonical_solution":"package fix_spaces_test\n\nimport (\n    \"strings\"\n    \"testing\"\n)\n\nfunc fix_spaces(text string) string {\n    var result string\n    spaceCount := 0\n\n    for _, char := range text {\n        if char == ' ' {\n            spaceCount++\n        } else {\n            if spaceCount == 1 {\n                result += \"_\"\n            } else if spaceCount > 1 {\n                result += \"-\"\n            }\n            result += string(char)\n            spaceCount = 0\n        }\n    }\n\n    \/\/ Handle trailing spaces\n    if spaceCount == 1 {\n        result += \"_\"\n    } else if spaceCount > 1 {\n        result += \"-\"\n    }\n\n    return result\n}\n\nfunc TestFixSpaces(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected string\n    }{\n        {\" Example\", \"Example\"},\n        {\" Example 1\", \"Example_1\"},\n        {\" Example 2\", \"_Example_2\"},\n        {\" Example 3\", \"_Example-3\"},\n        {\" Hello    world\", \"_Hello-world\"},\n        {\"   Leading spaces\", \"-Leading_spaces\"},\n    }\n\n    for _, c := range cases {\n        result := fix_spaces(c.input)\n        if result != c.expected {\n            t.Errorf(\"fix_spaces(%q) == %q, expected %q\", c.input, result, c.expected)\n        }\n    }\n}","tests":"func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n     { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n     { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\" },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n     { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_141","nl":"hrv_Latn","pl":"go_test.go","prompt":"package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/- Podstring nakon točke treba biti jedan od ovih: ['txt', 'exe', 'dll'] \/\/U skladu s člankom 2. stavkom 1.\/\/- Podstrun pred točkom ne smije biti prazan, i počinje sa slovom od \/\/- Ime datoteke sadrži točno jednu točku.\/\/- Naziv datoteke ne smije sadržavati više od tri znamenke ('0'-'9'). \/\/su ispunjeni: \/\/Ime datoteke smatra se valjanim ako i samo ako su ispunjeni svi sljedeći uvjeti:\/\/\"Da\" ako je ime datoteke valjano, a u suprotnom daje \"Ne\". \/\/Stvorite funkciju koja uzima niz koji predstavlja ime datoteke i vraća \/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunc file_name_check(file_name string) string {\n","canonical_solution":"package file_name_check_test\n\nimport (\n    \"strings\"\n    \"unicode\"\n)\n\nfunc file_name_check(file_name string) string {\n    if len(file_name) == 0 {\n        return \"No\"\n    }\n\n    \/\/ Condition 2: Check for exactly one dot\n    dotIndex := strings.LastIndex(file_name, \".\")\n    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {\n        return \"No\"\n    }\n\n    \/\/ Split the file name into two parts\n    namePart := file_name[:dotIndex]\n    extension := file_name[dotIndex+1:]\n\n    \/\/ Condition 4: Check the extension\n    validExtensions := map[string]bool{\n        \"txt\": true,\n        \"exe\": true,\n        \"dll\": true,\n    }\n    if !validExtensions[extension] {\n        return \"No\"\n    }\n\n    \/\/ Condition 3: Check the first character before the dot\n    if !unicode.IsLetter(rune(namePart[0])) {\n        return \"No\"\n    }\n\n    \/\/ Condition 1: Count the digits in the file name\n    digitCount := 0\n    for _, char := range namePart {\n        if unicode.IsDigit(char) {\n            digitCount++\n        }\n    }\n    if digitCount > 3 {\n        return \"No\"\n    }\n\n    \/\/ If all conditions are met, return \"Yes\"\n    return \"Yes\"\n}","tests":"func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual: candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"\/this_is_valid.dll\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n     { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual: candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual: candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     { actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected: \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_142","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/Ako je to moguće, funkcija će vratiti zbir svih unosa.\/\/Množnik od 3 i će kubirati cijeli broj ako je njegov indeks množnik od 4 a ne množnik od 3. Funkcija neće \/\/Ova funkcija će uzeti popis cijelih brojeva. Za sve unose na popisu, funkcija će kvadrirati cijeli broj ako je njen indeks a \/\/\" \/\/ >>> lst\n\/\/ []int{1, 2, 3}\n\/\/ >>> lst\n\/\/ int{}\n\/\/ >>> lst\n\/\/ []int{-1, -5, 2, -1, -5}\nfunc sum_squares(lst []int) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n    \"testing\"\n)\n\nfunc sum_squares(lst []int) int {\n    sum := 0\n    for i, val := range lst {\n        if i%3 == 0 {\n            sum += val * val\n        } else if i%4 == 0 {\n            sum += val * val * val\n        } else {\n            sum += val\n        }\n    }\n    return sum\n}\n\nfunc TestSumSquares(t *testing.T) {\n    tests := []struct {\n        lst      []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 10},   \/\/ 1^2 + 2 + 3 = 10\n        {[]int{}, 0},           \/\/ empty list\n        {[]int{-1, -5, 2, -1, -5}, 0}, \/\/ (-1)^2 + (-5)^3 + 2 + (-1) = -118\n    }\n\n    for _, test := range tests {\n        result := sum_squares(test.lst)\n        if result != test.expected {\n            t.Errorf(\"sum_squares(%v) = %d; expected %d\", test.lst, result, test.expected)\n        }\n    }\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 6 },\n     { actual: candidate([]int{1, 4, 9}), expected: 14 },\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },\n     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },\n     { actual: candidate([]int{0}), expected: 0 },\n     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },\n     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },\n     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },\n     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },\n     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_143","nl":"hrv_Latn","pl":"go_test.go","prompt":"package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer 1: \/\/redoslijed riječi u novom nizu treba biti isti kao i u izvornom.\/\/čije su dužine prosti brojevi, \/\/i morate vratiti niz koji sadrži riječi iz izvorne rečenice, \/\/                                        \/\/Dobivate niz koji predstavlja rečenicu, \/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n","canonical_solution":"package words_in_sentence_test\n\nimport (\n    \"strings\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc words_in_sentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var result []string\n\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result = append(result, word)\n        }\n    }\n\n    return strings.Join(result, \" \")\n}","tests":"func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_144","nl":"hrv_Latn","pl":"go_test.go","prompt":"package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Možete pretpostaviti da su x i n valjani frakcije, i nemaju nuli kao imenovača.\/\/<brojnik>\/<nazivnik> gdje su i brojnik i nazivnik pozitivni cijeli brojevi. \/\/i x i n su nizovi frakcija i imaju sljedeći format, \/\/x * n. Funkcija vraća vrijednost istinita ako je x * n cijela broj i neispravna \/\/Vaš zadatak je da implementirate funkciju koja će pojednostaviti izraz.\/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunc simplify(x string, n string) bool {\n","canonical_solution":"package simplify_test\n\nimport (\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc simplify(x string, n string) bool {\n    \/\/ Split the input strings into numerators and denominators\n    xParts := strings.Split(x, \"\/\")\n    nParts := strings.Split(n, \"\/\")\n\n    \/\/ Convert the string parts to integers\n    xNumerator, _ := strconv.Atoi(xParts[0])\n    xDenominator, _ := strconv.Atoi(xParts[1])\n    nNumerator, _ := strconv.Atoi(nParts[0])\n    nDenominator, _ := strconv.Atoi(nParts[1])\n\n    \/\/ Perform the multiplication (x * n) = (xNumerator\/nDenominator) * (nNumerator\/nDenominator)\n    resultNumerator := xNumerator * nNumerator\n    resultDenominator := xDenominator * nDenominator\n\n    \/\/ Check if the result is a whole number\n    return resultNumerator%resultDenominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n    if !simplify(\"1\/5\", \"5\/1\") {\n        t.Fatalf(\"Expected true, got false\")\n    }\n    if simplify(\"1\/6\", \"2\/1\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n    if simplify(\"7\/10\", \"10\/2\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n}","tests":"func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/6\", \"2\/1\"), expected: false },\n     { actual: candidate(\"5\/1\", \"3\/1\"), expected: true },\n     { actual: candidate(\"7\/10\", \"10\/2\"), expected: false },\n     { actual: candidate(\"2\/10\", \"50\/10\"), expected: true },\n     { actual: candidate(\"7\/2\", \"4\/2\"), expected: true },\n     { actual: candidate(\"11\/6\", \"6\/1\"), expected: true },\n     { actual: candidate(\"2\/3\", \"5\/2\"), expected: false },\n     { actual: candidate(\"5\/2\", \"3\/5\"), expected: false },\n     { actual: candidate(\"2\/4\", \"8\/4\"), expected: true },\n     { actual: candidate(\"2\/4\", \"4\/2\"), expected: true },\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/5\", \"1\/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_145","nl":"hrv_Latn","pl":"go_test.go","prompt":"package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Pored toga, u originalnom popisu su bile redovite po indeksu.\/\/U tom slučaju, u skladu s člankom 5. stavkom 1. točka (b) Uredbe (EU) br.\/\/u porastu prema zbrojima njihovih znamenki. \/\/Napišite funkciju koja raspoređuje datog popisa cijelih brojeva.\/\/ >>> order_by_points([]int{1, 11, -1, -11, -12})\n\/\/ []int{-1, -11, 1, -12, 11}\n\/\/ >>> order_by_points([]int{})\n\/\/ []int{}\nfunc order_by_points(nums []int) []int {\n","canonical_solution":"package order_by_points_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc digitSum(n int) int {\n\tn = abs(n) \/\/ Consider the absolute value for digit sum\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc order_by_points(nums []int) []int {\n\ttype numWithIndex struct {\n\t\tnum   int\n\t\tindex int\n\t}\n\n\tnumsWithIndex := make([]numWithIndex, len(nums))\n\tfor i, num := range nums {\n\t\tnumsWithIndex[i] = numWithIndex{num, i}\n\t}\n\n\tsort.Slice(numsWithIndex, func(i, j int) bool {\n\t\tsumI := digitSum(numsWithIndex[i].num)\n\t\tsumJ := digitSum(numsWithIndex[j].num)\n\t\tif sumI == sumJ {\n\t\t\treturn numsWithIndex[i].index < numsWithIndex[j].index\n\t\t}\n\t\treturn sumI < sumJ\n\t})\n\n\tsortedNums := make([]int, len(nums))\n\tfor i, nwi := range numsWithIndex {\n\t\tsortedNums[i] = nwi.num\n\t}\n\n\treturn sortedNums\n}\n\nfunc TestOrderByPoints(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := order_by_points(tc.input)\n\t\tif !equal(result, tc.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_146","nl":"hrv_Latn","pl":"go_test.go","prompt":"package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Prva i posljednja cifre broja su neparne (1, 3, 5, 7, 9).\/\/broj elemenata u popisu koji su veći od 10 i oba \/\/Napišite funkciju koja uzima popis brojeva kao ulaz i vraća \/\/ >>> specialFilter([]int{15, -73, 14, -15})\n\/\/ 1\n\/\/ >>> specialFilter([]int{33, -2, -3, 45, 21, 109})\n\/\/ 2\nfunc specialFilter(nums []int) int {\n","canonical_solution":"package specialFilter_test\n\nimport (\n\t\"testing\"\n)\n\nfunc specialFilter(nums []int) int {\n\tcount := 0\n\tfor _, num := range nums {\n\t\t\/\/ Consider the absolute value of the number\n\t\tabsNum := abs(num)\n\t\tif absNum > 10 {\n\t\t\tstrNum := fmt.Sprintf(\"%d\", absNum)\n\t\t\tfirstDigit := strNum[0]\n\t\t\tlastDigit := strNum[len(strNum)-1]\n\t\t\tif isOdd(firstDigit) && isOdd(lastDigit) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc isOdd(digit byte) bool {\n\treturn digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'\n}\n\nfunc TestSpecialFilter(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{15, -73, 14, -15}, 1},\n\t\t{[]int{33, -2, -3, 45, 21, 109}, 2},\n\t\t{[]int{8, 4, 12, 55, 99, 111}, 1},\n\t\t{[]int{-11, -22, -33, -44, -55}, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := specialFilter(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"specialFilter(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestSpecialfilter(t *testing.T) {\n  candidate := specialFilter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },\n     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },\n     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },\n     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },\n     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{}), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_147","nl":"hrv_Latn","pl":"go_test.go","prompt":"package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer:\/\/a a[i] + a[j] + a[k] je višekratnik od 3. \/\/Vraća broj trojnika (a[i], a[j], a[k]) od a gdje je i < j < k, \/\/Za svaki i (1 ≤ i ≤ n), vrijednost a[i] = i * i - i + 1. \/\/Dobivate pozitivan cijeli broj n. Morate stvoriti cijeli popis a dužine n.\/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n int) int {\n","canonical_solution":"package get_max_triples_test\n\nimport (\n    \"testing\"\n)\n\nfunc get_max_triples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n    \n    count := 0\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\nfunc TestGetMaxTriples(t *testing.T) {\n    if get_max_triples(5) != 1 {\n        t.Errorf(\"Expected 1 but got %d\", get_max_triples(5))\n    }\n}","tests":"func TestGet_Max_Triples(t *testing.T) {\n  candidate := get_max_triples\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 1 },\n     { actual: candidate(6), expected: 4 },\n     { actual: candidate(10), expected: 36 },\n     { actual: candidate(100), expected: 53361 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_148","nl":"hrv_Latn","pl":"go_test.go","prompt":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/nisu ispravna imena planeta.\/\/Funkcija bi trebala vratiti prazan popis ako je planet1 ili planet2 \/\/blizina suncu.\/\/Nalazi se između orbite planete 1 i orbite planete 2, sortiran po \/\/Funkcija bi trebala vratiti popis svih planeta čije su orbite \/\/Napišite funkciju koja uzima dva imena planeta kao nizove planet1 i planet2. \/\/Uran, Neptun.\/\/je Merkur, sljedeći je Venera, onda Zemlja, Mars, Jupiter, Saturn, \/\/U našem sunčevom sustavu ima osam planeta: najbliža Suncu.\/\/ >>> bf(\"Jupiter\", \"Neptune\")\n\/\/ []interface{}{\"Saturn\", \"Uranus\"}\n\/\/ >>> bf(\"Earth\", \"Mercury\")\n\/\/ \"Venus\"\n\/\/ >>> bf(\"Mercury\", \"Uranus\")\n\/\/ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n","canonical_solution":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Define the solar system slice with planets ordered by their proximity to the Sun\nvar solarSystem = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\nfunc bf(planet1 string, planet2 string) []interface{} {\n    index1 := -1\n    index2 := -1\n\n    \/\/ Find the indices of the given planet names in the solarSystem slice\n    for i, planet := range solarSystem {\n        if planet == planet1 {\n            index1 = i\n        }\n        if planet == planet2 {\n            index2 = i\n        }\n    }\n\n    \/\/ If either planet name is incorrect, return an empty list\n    if index1 == -1 || index2 == -1 {\n        return []interface{}{}\n    }\n\n    \/\/ Ensure index1 is less than index2 to find planets between them\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n\n    \/\/ Collect and return planets that are located between the two indices\n    var planetsBetween []interface{}\n    for i := index1 + 1; i < index2; i++ {\n        planetsBetween = append(planetsBetween, solarSystem[i])\n    }\n    \n    return planetsBetween\n}\n\nfunc TestBf(t *testing.T) {\n    fmt.Println(bf(\"Jupiter\", \"Neptune\")) \/\/ Should print: []interface{}{\"Saturn\", \"Uranus\"}\n    fmt.Println(bf(\"Earth\", \"Mercury\"))  \/\/ Should print: []interface{}{\"Venus\"}\n    fmt.Println(bf(\"Mercury\", \"Uranus\")) \/\/ Should print: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n}","tests":"func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_149","nl":"hrv_Latn","pl":"go_test.go","prompt":"package sorted_list_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/Možete pretpostaviti da će sve riječi imati istu dužinu.\/\/Funkcija bi trebala vratiti popis niza u sortiranom redoslijedu.\/\/Ako su dvije riječi iste dužine, sortirajte popis po abecednom redu. \/\/treba vratiti popis sortiran tim pravilom. \/\/Redoslijed liste treba biti uzlazni po dužini svake riječi, a vi \/\/i može sadržavati duplikate. \/\/Lista je uvijek lista niza i nikada lista brojeva, \/\/i vraća rezultiranu listu u sortiranom redoslijedu, \/\/brisanje struna koje imaju neparne dužine od njega, \/\/Napišite funkciju koja prihvaća popis nizova kao parametar, \/\/ >>> list_sort([]string{\"aa\", \"a\", \"aaa\"})\n\/\/ []string{\"aa\"}\n\/\/ >>> list_sort([]string{\"ab\", \"a\", \"aaa\", \"cd\"})\n\/\/ []string{\"ab\", \"cd\"}\nfunc sorted_list_sum(lst []string) []string {\n","canonical_solution":"package sorted_list_sum_test\n\nimport (\n    \"sort\"\n)\n\nfunc sorted_list_sum(lst []string) []string {\n    \/\/ Filter out strings with odd lengths\n    filtered := []string{}\n    for _, str := range lst {\n        if len(str)%2 == 0 {\n            filtered = append(filtered, str)\n        }\n    }\n\n    \/\/ Sort the filtered list by length, then alphabetically\n    sort.Slice(filtered, func(i, j int) bool {\n        if len(filtered[i]) == len(filtered[j]) {\n            return filtered[i] < filtered[j]\n        }\n        return len(filtered[i]) < len(filtered[j])\n    })\n\n    return filtered\n}","tests":"func TestSorted_List_Sum(t *testing.T) {\n  candidate := sorted_list_sum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"aa\", \"a\", \"aaa\"}), expected: []string{\"aa\"} },\n     { actual: candidate([]string{\"school\", \"AI\", \"asdf\", \"b\"}), expected: []string{\"AI\", \"asdf\", \"school\"} },\n     { actual: candidate([]string{\"d\", \"b\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"d\", \"dcba\", \"abcd\", \"a\"}), expected: []string{\"abcd\", \"dcba\"} },\n     { actual: candidate([]string{\"AI\", \"ai\", \"au\"}), expected: []string{\"AI\", \"ai\", \"au\"} },\n     { actual: candidate([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}), expected: []string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_150","nl":"hrv_Latn","pl":"go_test.go","prompt":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/a prvobroj i treba vratiti vrijednost y u suprotnom. \/\/Jednostavan program koji bi trebao vratiti vrijednost x ako je n \/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunc x_or_y(n int, x int, y int) int {\n","canonical_solution":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc x_or_y(n int, x int, y int) int {\n    if isPrime(n) {\n        return x\n    }\n    return y\n}\n\nfunc TestXOrY(t *testing.T) {\n    cases := []struct{\n        n, x, y, want int\n    }{\n        {7, 34, 12, 34},\n        {15, 8, 5, 5},\n        {2, 10, 20, 10},\n        {1, 5, 15, 15},\n    }\n\n    for _, c := range cases {\n        got := x_or_y(c.n, c.x, c.y)\n        if got != c.want {\n            t.Errorf(\"x_or_y(%d, %d, %d) == %d, want %d\", c.n, c.x, c.y, got, c.want)\n        }\n    }\n}","tests":"func TestX_Or_Y(t *testing.T) {\n  candidate := x_or_y\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7, 34, 12), expected: 34 },\n     { actual: candidate(15, 8, 5), expected: 5 },\n     { actual: candidate(3, 33, 5212), expected: 33 },\n     { actual: candidate(1259, 3, 52), expected: 3 },\n     { actual: candidate(7919, -1, 12), expected: -1 },\n     { actual: candidate(3609, 1245, 583), expected: 583 },\n     { actual: candidate(91, 56, 129), expected: 129 },\n     { actual: candidate(6, 34, 1234), expected: 1234 },\n     { actual: candidate(1, 2, 0), expected: 0 },\n     { actual: candidate(2, 2, 0), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_151","nl":"hrv_Latn","pl":"go_test.go","prompt":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ignorirajte brojeve koji su negativni ili nisu cijevi.\/\/Ako je data lista brojeva, vratite zbir kvadrata brojeva.\/\/ >>> double_the_difference([]int{1, 3, 2, 0})\n\/\/ 10\n\/\/ >>> double_the_difference([]int{-1, -2, 0})\n\/\/ 0\n\/\/ >>> double_the_difference([]int{9, -2})\n\/\/ 81\n\/\/ >>> double_the_difference([]int{0})\n\/\/ 0\n\/\/ If the input list is empty, return 0.\nfunc double_the_difference(lst []float64) int {\n","canonical_solution":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc double_the_difference(lst []float64) int {\n    sum := 0\n    for _, num := range lst {\n        if num >= 0 && math.Mod(num, 1) == 0 {\n            intNum := int(num)\n            if intNum%2 != 0 {\n                sum += intNum * intNum\n            }\n        }\n    }\n    return sum\n}\n\nfunc TestDoubleTheDifference(t *testing.T) {\n    cases := []struct {\n        input []float64\n        expected int\n    }{\n        {input: []float64{1, 3, 2, 0}, expected: 10},\n        {input: []float64{-1, -2, 0}, expected: 0},\n        {input: []float64{9, -2}, expected: 81},\n        {input: []float64{0}, expected: 0},\n        {input: []float64{}, expected: 0},\n    }\n\n    for _, c := range cases {\n        result := double_the_difference(c.input)\n        if result != c.expected {\n            t.Errorf(\"double_the_difference(%v) == %d, want %d\", c.input, result, c.expected)\n        } else {\n            fmt.Printf(\"Test passed for input %v. Result: %d\\n\", c.input, result)\n        }\n    }\n}","tests":"func TestDouble_The_Difference(t *testing.T) {\n  candidate := double_the_difference\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{}), expected: 0 },\n     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },\n     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },\n     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },\n     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },\n     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_152","nl":"hrv_Latn","pl":"go_test.go","prompt":"package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/Ako je vrijednost 0 ili je nula, vrijednost je apsolutna razlika između pretpostavke i rezultata. \/\/Vratite listu iste dužine koja označava koliko je udaljena svaka od pretpostavki.\/\/Dobivate dvije liste rezultata i nagađanja jednake dužine, gdje svaki indeks pokazuje podudaranje.\/\/Vaš zadatak je da utvrdite je li osoba ispravno pogodila rezultate nekoliko utakmica.\/\/Definitivno vrijedi zapisati i usporediti.\/\/Osjećanja i misli koje imate u tom trenutku su...\/\/Mislim da svi pamtimo taj osjećaj kad je rezultat nekog dugo očekivanog\/\/ >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})\n\/\/ []int{0, 0, 0, 0, 3, 3}\n\/\/ >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})\n\/\/ []int{4, 4, 1, 0, 0, 6}\nfunc compare(game []int, guess []int) []int {\n","canonical_solution":"package compare_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := 0; i < len(game); i++ {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n\nfunc TestCompare(t *testing.T) {\n    tests := []struct {\n        game  []int\n        guess []int\n        want  []int\n    }{\n        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},\n        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%v vs %v\", tt.game, tt.guess), func(t *testing.T) {\n            got := compare(tt.game, tt.guess)\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"compare(%v, %v) = %v; want %v\", tt.game, tt.guess, got, tt.want)\n                }\n            }\n        })\n    }\n}","tests":"func TestCompare(t *testing.T) {\n  candidate := compare\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },\n     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },\n     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },\n     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_153","nl":"hrv_Latn","pl":"go_test.go","prompt":"package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/(njegova jačina je -1). \/\/return \"Slices.SErviNGSliCes\" jer je \"SErviNGSliCes\" najjača ekstenzija \/\/['SErviNGSliCes', 'Cheese', 'StuFfed'] onda bi trebali \/\/Na primjer, ako ste dobili \"Slice\" kao razred i popis \/\/Izaberite onu koja je prva na popisu.\/\/Ako postoje dva ili više produženja iste jačine, morate \/\/format: ClassName.StrongestExtensionName. \/\/Trebate pronaći najjači nastavak i vratiti niz u ovom \/\/U imenu dodatka, jačina je navedena kao frakcija CAP - SM. \/\/U nastavku se navodi broj slova u imenu ekstenzije, a SM je broj malih slova \/\/snaga proširenja je sljedeća: neka CAP bude broj velikog slova \/\/Ekstenzije se koriste za učitavanje dodatnih klasa u klasi.\/\/Dobićete ime klase (string) i popis ekstenzija.\/\/ >>> Strongest_Extension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"})\n\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name string, extensions []string) string {\n","canonical_solution":"func Strongest_Extension(class_name string, extensions []string) string {\n    strongestExtension := \"\"\n    maxStrength := -1 << 31\n\n    for _, extension := range extensions {\n        capCount, smCount := 0, 0\n        for _, char := range extension {\n            if char >= 'A' && char <= 'Z' {\n                capCount++\n            } else if char >= 'a' && char <= 'z' {\n                smCount++\n            }\n        }\n        strength := capCount - smCount\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n\n    return fmt.Sprintf(\"%s.%s\", class_name, strongestExtension)\n}","tests":"func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected: \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected: \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\" },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n     { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_154","nl":"hrv_Latn","pl":"go_test.go","prompt":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Dobijate 2 riječi. Morate vratiti istinito ako je druga riječ ili bilo koja od njenih rotacija podstruna u prvoj riječi.\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunc cycpattern_check(a string, b string) bool {\n","canonical_solution":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc cycpattern_check(a string, b string) bool {\n    n := len(b)\n    \n    \/\/ Generate all rotations of b\n    for i := 0; i < n; i++ {\n        rotated := b[i:] + b[:i]\n        if strings.Contains(a, rotated) {\n            return true\n        }\n    }\n    \n    return false\n}","tests":"func TestCycpattern_Check(t *testing.T) {\n  candidate := cycpattern_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"xyzw\", \"xyw\"), expected: false },\n     { actual: candidate(\"yello\", \"ell\"), expected: true },\n     { actual: candidate(\"whattup\", \"ptut\"), expected: false },\n     { actual: candidate(\"efef\", \"fee\"), expected: true },\n     { actual: candidate(\"abab\", \"aabb\"), expected: false },\n     { actual: candidate(\"winemtt\", \"tinem\"), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_155","nl":"hrv_Latn","pl":"go_test.go","prompt":"package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/Ako je dat cijeli broj, vraća popis koji ima broj parnih i neparnih cifara.\/\/ >>> even_odd_count(-12)\n\/\/ []interface{}{1, 1}\n\/\/ >>> even_odd_count(123)\n\/\/ []interface{}{1, 2}\nfunc even_odd_count(num int) []interface{} {\n","canonical_solution":"func even_odd_count(num int) []interface{} {\n    \/\/ Handle negative numbers by taking the absolute value\n    if num < 0 {\n        num = -num\n    }\n    \n    evenCount, oddCount := 0, 0\n\n    \/\/ Iterate over each digit in the number\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            evenCount++\n        } else {\n            oddCount++\n        }\n        num \/= 10\n    }\n\n    return []interface{}{evenCount, oddCount}\n}\n\nfunc TestEvenOddCount(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected []interface{}\n    }{\n        {-12, []interface{}{1, 1}},\n        {123, []interface{}{1, 2}},\n        {2468, []interface{}{4, 0}},\n        {1357, []interface{}{0, 4}},\n        {0, []interface{}{1, 0}},\n    }\n\n    for _, testCase := range testCases {\n        result := even_odd_count(testCase.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", testCase.expected) {\n            t.Errorf(\"even_odd_count(%d) = %v; expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}","tests":"func TestEven_Odd_Count(t *testing.T) {\n  candidate := even_odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7), expected: []interface{}{0, 1} },\n     { actual: candidate(-78), expected: []interface{}{1, 1} },\n     { actual: candidate(3452), expected: []interface{}{2, 2} },\n     { actual: candidate(346211), expected: []interface{}{3, 3} },\n     { actual: candidate(-345821), expected: []interface{}{3, 3} },\n     { actual: candidate(-2), expected: []interface{}{1, 0} },\n     { actual: candidate(-45347), expected: []interface{}{2, 3} },\n     { actual: candidate(0), expected: []interface{}{1, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_156","nl":"hrv_Latn","pl":"go_test.go","prompt":"package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri: \/\/U slučaju da se ne može izvesti ispitivanje, mora se izvesti ispitivanje.\/\/i vratiti ga malim slovima. \/\/S obzirom na pozitivan cijeli broj, dobiti njegov rimski broj ekvivalent kao niz, \/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n","canonical_solution":"package int_to_mini_roman_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc int_to_mini_roman(number int) string {\n\tvals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\tsymbols := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\n\tvar roman strings.Builder\n\n\tfor i := 0; i < len(vals); i++ {\n\t\tfor number >= vals[i] {\n\t\t\tnumber -= vals[i]\n\t\t\troman.WriteString(symbols[i])\n\t\t}\n\t}\n\treturn roman.String()\n}\n\nfunc TestIntToMiniRoman(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected string\n\t}{\n\t\t{19, \"xix\"},\n\t\t{152, \"clii\"},\n\t\t{426, \"cdxxvi\"},\n\t\t{1000, \"m\"},\n\t\t{1, \"i\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d\", tt.input), func(t *testing.T) {\n\t\t\tresult := int_to_mini_roman(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Fatalf(\"expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_157","nl":"hrv_Latn","pl":"go_test.go","prompt":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/90 stupnjeva.\/\/Pravougaoni trougao je trougao u kojem je jedan kut pravougaoni ili \/\/strane formiraju pravougaoni trokut, inače je to pogrešno.\/\/Vratimo vrijednost TRUE ako su tri strane u trokutnom obliku.\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunc right_angle_triangle(a int, b int, c int) bool {\n","canonical_solution":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc right_angle_triangle(a int, b int, c int) bool {\n    \/\/ Squaring the sides\n    a2, b2, c2 := a*a, b*b, c*c\n    \/\/ Check the Pythagorean theorem for the combination of sides\n    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2\n}","tests":"func TestRight_Angle_Triangle(t *testing.T) {\n  candidate := right_angle_triangle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: true },\n     { actual: candidate(1, 2, 3), expected: false },\n     { actual: candidate(10, 6, 8), expected: true },\n     { actual: candidate(2, 2, 2), expected: false },\n     { actual: candidate(7, 24, 25), expected: true },\n     { actual: candidate(10, 5, 7), expected: false },\n     { actual: candidate(5, 12, 13), expected: true },\n     { actual: candidate(15, 8, 17), expected: true },\n     { actual: candidate(48, 55, 73), expected: true },\n     { actual: candidate(1, 1, 1), expected: false },\n     { actual: candidate(2, 2, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_158","nl":"hrv_Latn","pl":"go_test.go","prompt":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/znakova, vratite onaj koji je prvi po leksikografskoj redoslijedu. \/\/Ako više niza ima maksimalni broj jedinstvenih znakova \/\/Popis sadrži različite riječi.\/\/Napišite funkciju koja prihvaća popis nizova.\/\/ >>> find_max([]string{\"name\", \"of\", \"string\"})\n\/\/ \"string\"\n\/\/ >>> find_max([]string{\"name\", \"enam\", \"game\"})\n\/\/ \"enam\"\n\/\/ >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\/\/ \"aaaaaaa\"\nfunc find_max(words []string) string {\n","canonical_solution":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc find_max(words []string) string {\n    maxWord := \"\"\n    maxUnique := 0\n    \n    for _, word := range words {\n        uniqueChars := countUniqueChars(word)\n        if uniqueChars > maxUnique {\n            maxUnique = uniqueChars\n            maxWord = word\n        } else if uniqueChars == maxUnique {\n            if maxWord == \"\" || word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    \n    return maxWord\n}\n\nfunc countUniqueChars(word string) int {\n    charSet := make(map[rune]struct{})\n    for _, c := range word {\n        charSet[c] = struct{}{}\n    }\n    return len(charSet)\n}\n\n\/\/ Test case runs to verify the solution\nfunc TestFindMax(t *testing.T) {\n    testCases := []struct {\n        input []string\n        expected string\n    }{\n        {[]string{\"name\", \"of\", \"string\"}, \"string\"},\n        {[]string{\"name\", \"enam\", \"game\"}, \"enam\"},\n        {[]string{\"aaaaaaa\", \"bb\", \"cc\"}, \"aaaaaaa\"},\n    }\n\n    for _, tc := range testCases {\n        result := find_max(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"For input %v, expected %s, but got %s\", tc.input, tc.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", tc.input)\n        }\n    }\n}","tests":"func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_159","nl":"hrv_Latn","pl":"go_test.go","prompt":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjer: \/\/Ako nema dovoljno šargarepe, pojesti ćete sve šargarepe, ali ćete i dalje biti gladni.\/\/broj mrkve preostale nakon obroka ] \/\/ako je potrebno, morate vratiti popis [ukupnog broja konzumiranih mrkve nakon obroka, \/\/Ali sada moraš jesti više mrkve da završiš dnevni obrok.\/\/Ti si gladan zec, i već si pojeo određeni broj mrkve, \/\/ >>> eat(5, 6, 10)\n\/\/ []int{11, 4}\n\/\/ >>> eat(4, 8, 9)\n\/\/ []int{12, 1}\n\/\/ >>> eat(1, 10, 10)\n\/\/ []int{11, 0}\n\/\/ >>> eat(2, 11, 5)\n\/\/ []int{7, 0}\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n","canonical_solution":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ eat calculates the total number of eaten carrots after meals and the number of carrots left.\nfunc eat(number int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{number + need, remaining - need}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n    tests := []struct {\n        number, need, remaining int\n        expected                []int\n    }{\n        {5, 6, 10, []int{11, 4}},\n        {4, 8, 9, []int{12, 1}},\n        {1, 10, 10, []int{11, 0}},\n        {2, 11, 5, []int{7, 0}},\n    }\n\n    for _, test := range tests {\n        result := eat(test.number, test.need, test.remaining)\n        if result[0] != test.expected[0] || result[1] != test.expected[1] {\n            t.Errorf(\"eat(%d, %d, %d) = %v; expected %v\", test.number, test.need, test.remaining, result, test.expected)\n        }\n    }\n}","tests":"func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_160","nl":"hrv_Latn","pl":"go_test.go","prompt":"package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Popis operatera ima najmanje jednog operatera, a popis operanda ima najmanje dva operanda.\/\/Operand je popis ne-negativnih cijelih brojeva.\/\/Dužina liste operatora jednaka je dužini liste operanda minus jedan.\/\/Napomena: \/\/=> rezultat = 9 \/\/Rezultat je 2 + 3 * 4 - 5 \/\/popis = [2, 3, 4, 5] \/\/Operator ['+', '*', '-'] \/\/Primjer: \/\/Iznos (**) \/\/Podovi podjela ( \/\/) \/\/Množenje (*) \/\/Oduzimanje ( - ) \/\/Dodavanje (+) \/\/Osnovne algebarske operacije:\/\/Izraz i vratiti ocjenu tog izraza. \/\/Drugi popis je popis cijelih brojeva.\/\/Prva lista sadrži osnovne algebarske operacije, a func do_algebra(operator []string, operand []int) int {\n","canonical_solution":"package do_algebra_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc do_algebra(operator []string, operand []int) int {\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n\n    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"\/\/\":\n            result \/= operand[i+1]\n        case \"**\":\n            result = intPow(result, operand[i+1])\n        }\n    }\n\n    return result\n}\n\nfunc intPow(base, exp int) int {\n    result := 1\n    for exp != 0 {\n        if exp%2 == 1 {\n            result *= base\n        }\n        exp \/= 2\n        base *= base\n    }\n    return result\n}\n\nfunc TestDoAlgebra(t *testing.T) {\n    operators := []string{\"+\", \"*\", \"-\"}\n    operands := []int{2, 3, 4, 5}\n    expectedResult := 9\n    result := do_algebra(operators, operands)\n    if result != expectedResult {\n        t.Errorf(\"expected %d but got %d\", expectedResult, result)\n    }\n\n    fmt.Println(\"All tests passed.\")\n}","tests":"func TestDo_Algebra(t *testing.T) {\n  candidate := do_algebra\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}), expected: 37 },\n     { actual: candidate([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}), expected: 9 },\n     { actual: candidate([]string{\"\/\/\", \"*\"}, []int{7, 3, 4}), expected: 8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_161","nl":"hrv_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Primjeri \/\/Funkcija bi trebala vratiti rezultiranu niz.\/\/Ako niza ne sadrži slova, obrnite niz.\/\/Inače, ostavi kako je.\/\/ako je s[i] slovo, preokrenite njegov slučaj od donjeg prema gornjem ili obrnuto, \/\/Dobivate niz s.\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunc solve(s string) string {\n","canonical_solution":"package solve_test\n\nimport (\n    \"unicode\"\n)\n\nfunc solve(s string) string {\n    hasLetter := false\n    result := []rune(s)\n\n    for i, char := range result {\n        if unicode.IsLetter(char) {\n            hasLetter = true\n            if unicode.IsUpper(char) {\n                result[i] = unicode.ToLower(char)\n            } else {\n                result[i] = unicode.ToUpper(char)\n            }\n        }\n    }\n\n    if !hasLetter {\n        \/\/ reverse the string\n        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {\n            result[i], result[j] = result[j], result[i]\n        }\n    }\n\n    return string(result)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_163","nl":"hrv_Latn","pl":"go_test.go","prompt":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Na primjer: \/\/i b, u porastu. \/\/S obzirom na dva pozitivna cijela broja a i b, vratite parne cifre između a \/\/ >>> generate_integers(2, 8)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(8, 2)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(10, 14)\n\/\/ []int{}\nfunc generate_integers(a int, b int) []int {\n","canonical_solution":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc generate_integers(a int, b int) []int {\n    start, end := a, b\n    if a > b {\n        start, end = b, a\n    }\n    \n    result := []int{}\n    for i := start; i <= end; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestGenerateIntegers(t *testing.T) {\n    tests := []struct {\n        a, b int\n        want []int\n    }{\n        {2, 8, []int{2, 4, 6, 8}},\n        {8, 2, []int{2, 4, 6, 8}},\n        {10, 14, []int{}},\n    }\n    \n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"generate_integers(%d, %d)\", tt.a, tt.b), func(t *testing.T) {\n            got := generate_integers(tt.a, tt.b)\n            if len(got) != len(tt.want) {\n                t.Errorf(\"expected %v, got %v\", tt.want, got)\n                return\n            }\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"expected %v, got %v\", tt.want, got)\n                    return\n                }\n            }\n        })\n    }\n}","tests":"func TestGenerate_Integers(t *testing.T) {\n  candidate := generate_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(17, 89), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]