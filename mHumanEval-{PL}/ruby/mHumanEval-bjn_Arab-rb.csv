task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,bjn_Arab,rb,"باݢين ڤاسير.ڤرچاي اڤابيلا دالم ارري ارق دبري، اد دوا ارق نڠ كادا ديكتاهوكن ك سيكڤڽ دري # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)
# false
# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
# true
def has_close_elements(numbers, threshold)
","def has_close_elements(numbers, threshold)
  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_has_close_elements
    candidate = method(:has_close_elements)
    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))
    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))
    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))
    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))
    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))
    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))
    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))
  end
end
"
HumanEval_1,bjn_Arab,rb,"مڠݢوناكن ساءير-سايير دالم ساءير ڤمباچ.ݢوروڤ-ݢوروڤ ڤاربنديڠ ديبالانس (باڬين-ڬين بنتوق ڤرڤادوان نڠ دڤاچوت دتاهن) وان كادا ديباڠوناكن دالم سابوءهڽ۔مڠلواراكن ݢروڤ ڠيني كاو ساءورڠ ستراڠ وان مڽاتاكن ارري ݢروڤ ڠيني.ڤانوليس ڤانݢݢكسي ڠيني اداله سݢرا نڠ مان باڽق ڬروڤ ڤانݢكسي نڠ ديسامڤول. توݢس تو اداله # >>> separate_paren_groups.call(""( ) (( )) (( )( ))"")
# [""()"", ""(())"", ""(()())""]
def separate_paren_groups(paren_string)
","def separate_paren_groups(paren_string)
  # Remove spaces from the string
  paren_string = paren_string.gsub("" "", """")
  
  result = []
  current_group = """"
  balance = 0

  paren_string.each_char do |char|
    current_group += char
    balance += 1 if char == '('
    balance -= 1 if char == ')'

    if balance == 0 && !current_group.empty?
      result << current_group
      current_group = """"
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_separate_paren_groups
    candidate = method(:separate_paren_groups)
    assert_equal([""(()())"", ""((()))"", ""()"", ""((())()())""], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([""()"", ""(())"", ""((()))"", ""(((())))""], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([""(()(())((())))""], candidate.call(""(()(())((())))""))
    assert_equal([""()"", ""(())"", ""(()())""], candidate.call(""( ) (( )) (( )( ))""))
  end
end
"
HumanEval_2,bjn_Arab,rb,"مڠرجاكن باݢين ديسيمل ڤد نومبور.(باقي باسيڠ باسيڠ سامنڽ نڠ لابه دري ١)وان باݢين اينتيجر (انتيجر نڠ ڤاليڠ لابه نڠ لابه دري نومبور ديتنتو) وان ديسيمال ديتاهن سابوءه نومبور ڤوسيتيف ڤونچيتور ڤلڠݢن، نڠ كادا بوليه ديكومڤوساكان جادي # >>> truncate_number.call(3.5)
# 0.5
def truncate_number(number)
","def truncate_number(number)
  number - number.to_i
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_truncate_number
    candidate = method(:truncate_number)
    assert_equal(0.5, candidate.call(3.5))
    assert_equal(0.25, candidate.call(1.25))
    assert_equal(0.0, candidate.call(123.0))
  end
end
"
HumanEval_3,bjn_Arab,rb,"ڤونچق ڽن ڤرلو جادي ڤونچق ڤرلو جادي ڤونچق ڤرلو جادي ڤونچق ڤرلو جادي ڤرلو جادي ڤرلو جادي ڤرلو.ݢاسان ماناكالا ڤانݢݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢكوان ڤانݢوکوان ڤڠݢوکوان ڤڠوکوان ڤڠوکوان ڤڠوکواناكو دبري ڤربينچڠن ڤڠاجرن ڤڠاجرن وان ڤڠاجرن دالم اكاون بانك يڠ برمولا دڠن# >>> below_zero.call([1, 2, 3])
# false
# >>> below_zero.call([1, 2, -4, 5])
# true
def below_zero(operations)
","def below_zero(operations)
  balance = 0
  operations.each do |operation|
    balance += operation
    return true if balance < 0
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_zero
    candidate = method(:below_zero)
    assert_equal(false, candidate.call([]))
    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))
    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))
    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))
    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))
    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))
  end
end
"
HumanEval_4,bjn_Arab,rb,"MAD = اوسط. x - x_mean. ايليمن وان تيتيق ڤوست (ڤد حال اين مڠامبيلن): ميسين ابسولوت ديۏياسي اداله ڤربيداان ابسولوت ڤارادبن انتارا ستياڤ ݢاسان مانݢݢݢالوم ڤانݢݢالوم ݢاسان ݢاسان ݢاسان ݢاسان ݢاسانݢاسان سابوءه ارري نانݢ ديتاريݢاكان داري نومبور ڤانݢݢال, ماڽݢوناكان ڤانݢالوان ابسولوت ميڠݢان.# >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])
# 1.0
def mean_absolute_deviation(numbers)
","def mean_absolute_deviation(numbers)
  mean = numbers.sum.to_f / numbers.size
  deviations = numbers.map { |num| (num - mean).abs }
  deviations.sum / numbers.size
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_mean_absolute_deviation
    candidate = method(:mean_absolute_deviation)
    assert_equal(0.5, candidate.call([1.0, 2.0]))
    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))
    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
  end
end
"
HumanEval_5,bjn_Arab,rb,"مڠاندوڠاكن ارقام ""ديليميتير"" انتارا ستياڤ دوا ايليمن تاتارابوت دري ارري ڤامولأن ∀نومبور"" # >>> intersperse.call([], 4)
# []
# >>> intersperse.call([1, 2, 3], 4)
# [1, 4, 2, 4, 3]
def intersperse(numbers, delimeter)
","def intersperse(numbers, delimeter)
  return numbers if numbers.empty?
  result = []
  numbers.each_with_index do |num, index|
    result << num
    result << delimeter unless index == numbers.size - 1
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersperse
    candidate = method(:intersperse)
    assert_equal([], candidate.call([], 7))
    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))
    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))
  end
end
"
HumanEval_6,bjn_Arab,rb,"چونتوهڽ (() (()) باءيسي ماكسيما دوا تيڠكتن نڠڬڠ ماناكالا ((())) باءيسي تيݢ.باݢي ستياڤ ڬروڤ، ماولاه ڤرتنديڠن نڠ ڤاليڠ دالم ڤڠݢوناءن ڤرنتيس.ڤانولاه ڤانݢݢكسي ڠيني اداله سݢراڤان نانݢ ديڤاراكاي لاوان باباراڤاݢين جادي ڤانولاه ڤانولاه نانݢ ديڤاراكاي لاوان ڤانولاه.# >>> parse_nested_parens.call(""(()()) ((())) () ((())()())"")
# [2, 3, 1, 3]
def parse_nested_parens(paren_string)
","def parse_nested_parens(paren_string)
  paren_string.split.map do |group|
    max_depth = current_depth = 0
    group.chars.each do |char|
      if char == '('
        current_depth += 1
        max_depth = [max_depth, current_depth].max
      elsif char == ')'
        current_depth -= 1
      end
    end
    max_depth
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_nested_parens
    candidate = method(:parse_nested_parens)
    assert_equal([2, 3, 1, 3], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([1, 2, 3, 4], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([4], candidate.call(""(()(())((())))""))
  end
end
"
HumanEval_7,bjn_Arab,rb,"مڤيلتركن سابوءه ارري ڤڠمبيلن دري سورت تنڤا اونتوق اورڠ-اورڠ نڠ ممڤوڽاءي سوبسترين # >>> filter_by_substring.call([], ""a"")
# []
# >>> filter_by_substring.call([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
# [""abc"", ""bacd"", ""array""]
def filter_by_substring(strings, substring)
","def filter_by_substring(strings, substring)
  strings.select { |string| string.include?(substring) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_substring
    candidate = method(:filter_by_substring)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
    assert_equal([""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""))
    assert_equal([""grunt"", ""prune""], candidate.call([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""))
  end
end
"
HumanEval_8,bjn_Arab,rb,"سوم باءيق هاروس سام سام وان ڤرودوک باءيق هاروس سام وان ١.باݢي سابوتيڠ ارسي ارسي، مڽاتاكن سابوتيڠ ارسي نڠ باءيسي سوم وان ڤرودوک سموا ارسي دالم ارسي.# >>> sum_product.call([])
# [0, 1]
# >>> sum_product.call([1, 2, 3, 4])
# [10, 24]
def sum_product(numbers)
","def sum_product(numbers)
  sum = numbers.reduce(0, :+)
  product = numbers.reduce(1, :*)
  [sum, product]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_product
    candidate = method(:sum_product)
    assert_equal([0, 1], candidate.call([]))
    assert_equal([3, 1], candidate.call([1, 1, 1]))
    assert_equal([100, 0], candidate.call([100, 0]))
    assert_equal([15, 105], candidate.call([3, 5, 7]))
    assert_equal([10, 10], candidate.call([10]))
  end
end
"
HumanEval_9,bjn_Arab,rb,"دي سيکينسي.دري سابوءه ارري انتيڬري نڠ دبري، ماولاه ارري ڤرالتن ايليمن ماكسيما نڠ دتومڤت سمڤأي ڤرلمباڬان # >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])
# [1, 2, 3, 3, 3, 4, 4]
def rolling_max(numbers)
","def rolling_max(numbers)
  max_so_far = numbers.first
  numbers.map do |num|
    max_so_far = [max_so_far, num].max
  end
end

# Example usage:
# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rolling_max
    candidate = method(:rolling_max)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))
    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))
  end
end
"
HumanEval_10,bjn_Arab,rb,"- مڠاكوتاكن كاسوس ڤريفيكس ساكيتار ساكيتار نڠ ماناكالا سابلوم ساكيتار ڤاليندروميك.- مانونجوكاكن ڤوستفيكس نڠ ڤاليڠ لاما دري ساكيت ڤرنياڬا ن نڠ مان جادي ڤاليندروم. ايديا الورڬيتم ساڠت سيبس: ماكناكن ڤاليندروم ڤاليڠ كورڠ نڠ مولاي دڠن سليرا نڠ دڤاوڬيت.# >>> make_palindrome.call("""")
# """"
# >>> make_palindrome.call(""cat"")
# ""catac""
# >>> make_palindrome.call(""cata"")
# ""catac""
def make_palindrome(string)
","def make_palindrome(string)
  return string if string.empty?

  def is_palindrome?(s)
    s == s.reverse
  end

  (0...string.length).reverse_each do |i|
    if is_palindrome?(string[i..-1])
      return string + string[0...i].reverse
    end
  end

  string
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_palindrome
    candidate = method(:make_palindrome)
    assert_equal("""", candidate.call(""""))
    assert_equal(""x"", candidate.call(""x""))
    assert_equal(""xyzyx"", candidate.call(""xyz""))
    assert_equal(""xyx"", candidate.call(""xyx""))
    assert_equal(""jerryrrej"", candidate.call(""jerry""))
  end
end
"
HumanEval_11,bjn_Arab,rb,"ماولاهاكن XOR بينيار تاهون اين وان ماولاهاكن ريسلتا جوا ساباڬاي ساءينݢ.Input اداله دوا تار a وان b نڠ مان هاڽ 1 وان 0۔# >>> string_xor.call(""010"", ""110"")
# ""100""
def string_xor(a, b)
","def string_xor(a, b)
  result = """"
  a.length.times do |i|
    result << (a[i] == b[i] ? ""0"" : ""1"")
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_xor
    candidate = method(:string_xor)
    assert_equal(""010010"", candidate.call(""111000"", ""101010""))
    assert_equal(""0"", candidate.call(""1"", ""1""))
    assert_equal(""0101"", candidate.call(""0101"", ""0000""))
  end
end
"
HumanEval_12,bjn_Arab,rb,"ساءورڠ تار دري بوجور نڠ سام. ماولاه nil دالم حال ڤامبيلن تار باءيق.دري ارري ساءنج، مڽاراكن ساءنجت ساءنجت. مڽاراكن ساءنجت ڤرتام دالم كيس ڤربواتن # >>> longest.call([])
# nil
# >>> longest.call([""a"", ""b"", ""c""])
# ""a""
# >>> longest.call([""a"", ""bb"", ""ccc""])
# ""ccc""
def longest(strings)
","def longest(strings)
  return nil if strings.empty?
  strings.max_by(&:length)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_longest
    candidate = method(:longest)
    assert_equal(nil, candidate.call([]))
    assert_equal(""x"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""zzzz"", candidate.call([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]))
  end
end
"
HumanEval_13,bjn_Arab,rb,"ماولاه سابوءه ڤانديديڤيتور كومين ڤاليڠ بسر دري دوا انتيڬري a وان b # >>> greatest_common_divisor.call(3, 5)
# 1
# >>> greatest_common_divisor.call(25, 15)
# 5
def greatest_common_divisor(a, b)
","def greatest_common_divisor(a, b)
  while b != 0
    a, b = b, a % b
  end
  a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_greatest_common_divisor
    candidate = method(:greatest_common_divisor)
    assert_equal(1, candidate.call(3, 7))
    assert_equal(5, candidate.call(10, 15))
    assert_equal(7, candidate.call(49, 14))
    assert_equal(12, candidate.call(144, 60))
  end
end
"
HumanEval_14,bjn_Arab,rb,"مڽاراكن ارري دري سموا ڤريفيکس دري ڤاليڠ كوتاه سمڤاي ڤاليڠ لاما دري ساءنجور ڤنوليسن # >>> all_prefixes.call(""abc"")
# [""a"", ""ab"", ""abc""]
def all_prefixes(string)
","def all_prefixes(string)
  (1..string.length).map { |i| string[0, i] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_all_prefixes
    candidate = method(:all_prefixes)
    assert_equal([], candidate.call(""""))
    assert_equal([""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""], candidate.call(""asdfgh""))
    assert_equal([""W"", ""WW"", ""WWW""], candidate.call(""WWW""))
  end
end
"
HumanEval_15,bjn_Arab,rb,"مڽاراكن ساءينت يڠ مان ناڠ بايسي نومبور نڠ ديبينتيڠ ڤاس ڤاس ڤاس ڤاس ڤاس برمولا دري 0 سمڤأي n.# >>> string_sequence.call(0)
# ""0""
# >>> string_sequence.call(5)
# ""0 1 2 3 4 5""
def string_sequence(n)
","def string_sequence(n)
  (0..n).to_a.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_sequence
    candidate = method(:string_sequence)
    assert_equal(""0"", candidate.call(0))
    assert_equal(""0 1 2 3"", candidate.call(3))
    assert_equal(""0 1 2 3 4 5 6 7 8 9 10"", candidate.call(10))
  end
end
"
HumanEval_16,bjn_Arab,rb,"ديتاهن سابوءه ساءينتير، مانجولكن ساجارا كاراكتر ڤاركتي (بلا ڤرلوكن كيس) نڠ مان مان # >>> count_distinct_characters.call(""xyzXYZ"")
# 3
# >>> count_distinct_characters.call(""Jerry"")
# 4
def count_distinct_characters(string)
","def count_distinct_characters(string)
  string.downcase.chars.uniq.count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_distinct_characters
    candidate = method(:count_distinct_characters)
    assert_equal(0, candidate.call(""""))
    assert_equal(5, candidate.call(""abcde""))
    assert_equal(5, candidate.call(""abcdecadeCADE""))
    assert_equal(1, candidate.call(""aaaaAAAAaaaa""))
    assert_equal(5, candidate.call(""Jerry jERRY JeRRRY""))
  end
end
"
HumanEval_17,bjn_Arab,rb,". ""اكاك"" - كوارتر نوت، مانيڠكت ساتو تيتيق""اوچاك"" - نيمه نوتا، مانولاي دوا تيتيق'او' - ساري تيتيق، مانيڠݢل ٤ تيتيق اين اداله ساتو لڬيندا:تيدق ڤرنه.كاراتان اداله ڬاسن ممباچ ساءينتير ڠن مڽاراكن ارري انتيڬري نڠ مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مان مانڤانولاهان ڤانؤݢسي ݢاسان مانݢݢݢالاكان ساكيتار نانݢ مانونجوكاكان نوتا موسيكى دي ڤارمات ASCII نانݢ تاتار.# >>> parse_music.call(""o o| .| o| o| .| .| .| .| o o"")
# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
def parse_music(music_string)
","def parse_music(music_string)
  # Split the input string into individual notes.
  notes = music_string.split

  # Map each note to its corresponding number of beats.
  notes.map do |note|
    case note
    when 'o'
      4
    when 'o|'
      2
    when '.|'
      1
    else
      0
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_music
    candidate = method(:parse_music)
    assert_equal([], candidate.call(""""))
    assert_equal([4, 4, 4, 4], candidate.call(""o o o o""))
    assert_equal([1, 1, 1, 1], candidate.call("".| .| .| .|""))
    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(""o| o| .| .| o o o o""))
    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(""o| .| o| .| o o| o o|""))
  end
end
"
HumanEval_18,bjn_Arab,rb,"ماكن باڽق كالي سابوتيڠكيت دڤاومڤاي دالم ساءنجور اصل. ماكن كيس ڤمبنتوكن.# >>> how_many_times.call("""", ""a"")
# 0
# >>> how_many_times.call(""aaa"", ""a"")
# 3
# >>> how_many_times.call(""aaaa"", ""aa"")
# 3
def how_many_times(string, substring)
","def how_many_times(string, substring)
  return 0 if substring.empty?
  count = 0
  i = 0
  while i <= string.length - substring.length
    if string[i, substring.length] == substring
      count += 1
    end
    i += 1
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_how_many_times
    candidate = method(:how_many_times)
    assert_equal(0, candidate.call("""", ""x""))
    assert_equal(4, candidate.call(""xyxyxyx"", ""x""))
    assert_equal(4, candidate.call(""cacacacac"", ""cac""))
    assert_equal(1, candidate.call(""john doe"", ""john""))
  end
end
"
HumanEval_19,bjn_Arab,rb,"مڽاتاكن ساءيرڠ دڠن نومبور دأڠڬڤ دري نڠ كايڤت ك نڠ كايڤت ڤيليهن نڠ باڬين اداله ""صفر""، ""ساتو""، ""دوا""، ""ترد""، ""چهار""، ""ڤنج""، ""دس""، ""سبوت""، ""تاهون"" وان ""ساتو"".Input اداله سيكڤ ارقام نڠ ديبينتيڠ لاوان ڤاسير دري 'صفر' سمڤأي 'ساتو'# >>> sort_numbers.call(""three one five"")
# ""one three five""
def sort_numbers(numbers)
","def sort_numbers(numbers)
  numeral_map = {
    'zero' => 0,
    'one' => 1,
    'two' => 2,
    'three' => 3,
    'four' => 4,
    'five' => 5,
    'six' => 6,
    'seven' => 7,
    'eight' => 8,
    'nine' => 9
  }

  number_words = numbers.split
  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }
  sorted_numbers.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_numbers
    candidate = method(:sort_numbers)
    assert_equal("""", candidate.call(""""))
    assert_equal(""three"", candidate.call(""three""))
    assert_equal(""three five nine"", candidate.call(""three five nine""))
    assert_equal(""zero four five seven eight nine"", candidate.call(""five zero four seven nine eight""))
    assert_equal(""zero one two three four five six"", candidate.call(""six five four three two one zero""))
  end
end
"
HumanEval_20,bjn_Arab,rb,"لاينڽ وان ماولاهڽ دالم اورد (كادوم نڠ كاي، كادوم نڠ لابه بسر).دري سابوءه ارسي ارقام نڠ دڤرباريسكن (د باءيسي كادا ساكيتڽ دوا) ڤيليه وان مروڤاكن دوا نڠ ڤاليڠ كادا باءيسي ستياڤ # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
# [2.0, 2.2]
# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
# [2.0, 2.0]
def find_closest_elements(numbers)
","def find_closest_elements(numbers)
  sorted_numbers = numbers.sort
  closest_pair = [sorted_numbers[0], sorted_numbers[1]]
  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs

  (1...(sorted_numbers.length - 1)).each do |i|
    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs
    if current_difference < min_difference
      min_difference = current_difference
      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]
    end
  end

  closest_pair
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_closest_elements
    candidate = method(:find_closest_elements)
    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))
    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))
    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))
    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))
    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))
  end
end
"
HumanEval_21,bjn_Arab,rb,"سهيڠݢ ڤاراكيت نڠ ڤاليڠ كاي جادي ٠ وان نڠ ڤاليڠ بسر جادي ١ باڤينتأن ارري باݢين باباراݢين (اكوڽان دوا ايليمن) ، ماڠاجوكاكان ترانسفورماسي لينيار ك ارري ڠيتو,# >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])
# [0.0, 0.25, 0.5, 0.75, 1.0]
def rescale_to_unit(numbers)
","def rescale_to_unit(numbers)
  min = numbers.min
  max = numbers.max
  range = max - min
  return numbers.map { |num| (num - min) / range.to_f }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rescale_to_unit
    candidate = method(:rescale_to_unit)
    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))
    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))
    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))
  end
end
"
HumanEval_22,bjn_Arab,rb,"ڤيلتر ارري ديتاهن ڤد ستياڤ ڤرماءينن rbthon سلاين باݢي اينتيجر # >>> filter_integers.call([""a"", 3.14, 5])
# [5]
# >>> filter_integers.call([1, 2, 3, ""abc"", {}, []])
# [1, 2, 3]
def filter_integers(values)
","def filter_integers(values)
  values.select { |value| value.is_a?(Integer) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_integers
    candidate = method(:filter_integers)
    assert_equal([], candidate.call([]))
    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, ""adasd""]))
    assert_equal([3, 3, 3], candidate.call([3, ""c"", 3, 3, ""a"", ""b""]))
  end
end
"
HumanEval_23,bjn_Arab,rb,"ڤاڽاراه ڤاڽاراه ستراڠ ديبارياكن # >>> strlen.call("""")
# 0
# >>> strlen.call(""abc"")
# 3
def strlen(string)
","strlen = lambda do |string|
  string.length
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strlen
    candidate = method(:strlen)
    assert_equal(0, candidate.call(""""))
    assert_equal(1, candidate.call(""x""))
    assert_equal(9, candidate.call(""asdasnakj""))
  end
end
"
HumanEval_24,bjn_Arab,rb,"باڬي سابوتيڠ نومبور ن، مانيڠكتكن نومبور ن نڠ ڤاليڠ بسر نڠ باءيسي ڤرباتاسن ن نڠ باءيسي كاءمانن ن.# >>> largest_divisor.call(15)
# 5
def largest_divisor(n)
","def largest_divisor(n)
  (n - 1).downto(1) do |i|
    return i if n % i == 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_divisor
    candidate = method(:largest_divisor)
    assert_equal(1, candidate.call(3))
    assert_equal(1, candidate.call(7))
    assert_equal(5, candidate.call(10))
    assert_equal(50, candidate.call(100))
    assert_equal(7, candidate.call(49))
  end
end
"
HumanEval_25,bjn_Arab,rb,"ڤڠاتورن ڤرلو سام دڠن ڤربينچڠن كسموا فكتور ستياڤ فكتور هاروس دأريريكن باڽق كالي نڠ ماناكالا باڽق كالي نڠ مان جادي فكتوريساسي.ماڤاتاكن ارري فاكتور ڤرمايسوري انتيڬر دبريكن دالم اورد دري نڠ كاكر سمڤاي نڠ كاكر.# >>> factorize.call(8)
# [2, 2, 2]
# >>> factorize.call(25)
# [5, 5]
# >>> factorize.call(70)
# [2, 5, 7]
def factorize(n)
","def factorize(n)
  factors = []
  divisor = 2
  while n > 1
    while n % divisor == 0
      factors << divisor
      n /= divisor
    end
    divisor += 1
  end
  factors
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_factorize
    candidate = method(:factorize)
    assert_equal([2], candidate.call(2))
    assert_equal([2, 2], candidate.call(4))
    assert_equal([2, 2, 2], candidate.call(8))
    assert_equal([3, 19], candidate.call(57))
    assert_equal([3, 3, 19, 19], candidate.call(3249))
    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))
    assert_equal([3, 19, 19, 19], candidate.call(20577))
    assert_equal([2, 3, 3], candidate.call(18))
  end
end
"
HumanEval_26,bjn_Arab,rb,"مڠحفظ ڤرتودوهن ايليمن نڠ ديباڠون سام لاڬي دالم ڤنوليسن۔دري سابوءه ارري انتيڬري، مڠحاصيلكن سموا ايليمن نڠ مان مان مان مان ڤون بركالي لاڬي.# >>> remove_duplicates.call([1, 2, 3, 2, 4])
# [1, 3, 4]
def remove_duplicates(numbers)
","def remove_duplicates(numbers)
  numbers.select { |num| numbers.count(num) == 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_duplicates
    candidate = method(:remove_duplicates)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))
  end
end
"
HumanEval_27,bjn_Arab,rb,"باݢي ستريڠ دبري، ڤرݢيليڠ حروف مينوس کڤد ماکڤيترس وان ماکڤيترس کڤد ماکڤيترس.# >>> flip_case.call(""Hello"")
# ""hELLO""
def flip_case(string)
","def flip_case(string)
  string.swapcase
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_flip_case
    candidate = method(:flip_case)
    assert_equal("""", candidate.call(""""))
    assert_equal(""hELLO!"", candidate.call(""Hello!""))
    assert_equal(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"", candidate.call(""These violent delights have violent ends""))
  end
end
"
HumanEval_28,bjn_Arab,rb,"مڠكونتينياتاكن ارري ستراينڬ كاو ساتو ستراينڬ # >>> concatenate.call([])
# """"
# >>> concatenate.call([""a"", ""b"", ""c""])
# ""abc""
def concatenate(strings)
","def concatenate(strings)
  strings.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_concatenate
    candidate = method(:concatenate)
    assert_equal("""", candidate.call([]))
    assert_equal(""xyz"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""xyzwk"", candidate.call([""x"", ""y"", ""z"", ""w"", ""k""]))
  end
end
"
HumanEval_29,bjn_Arab,rb,"ڤيلتر سابوتيڠ ارسي ڤمباچ دري سورت-سورت نڠ ديباڠوناكن لاون ڤريفيکس نڠ دبري. # >>> filter_by_prefix.call([], ""a"")
# []
# >>> filter_by_prefix.call([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
# [""abc"", ""array""]
def filter_by_prefix(strings, prefix)
","def filter_by_prefix(strings, prefix)
  strings.select { |string| string.start_with?(prefix) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_prefix
    candidate = method(:filter_by_prefix)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
  end
end
"
HumanEval_30,bjn_Arab,rb,"مڽاراكن هاڽ ارق ڤوسيتيف دالم ارري.# >>> get_positive.call([-1, 2, -4, 5, 6])
# [2, 5, 6]
# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# [5, 3, 2, 3, 9, 123, 1]
def get_positive(l)
","get_positive = lambda do |l|
  l.select { |num| num > 0 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_positive
    candidate = method(:get_positive)
    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))
    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))
    assert_equal([], candidate.call([-1, -2]))
    assert_equal([], candidate.call([]))
  end
end
"
HumanEval_31,bjn_Arab,rb,"Membalikkan true jika bilangan diberi adalah bilangan prima, dan false jika tidak.# >>> is_prime.call(6)
# false
# >>> is_prime.call(101)
# true
# >>> is_prime.call(11)
# true
# >>> is_prime.call(13441)
# true
# >>> is_prime.call(61)
# true
# >>> is_prime.call(4)
# false
# >>> is_prime.call(1)
# false
def is_prime(n)
","is_prime = lambda do |n|
  return false if n <= 1
  return true if n == 2
  return false if n.even?

  max_divisor = Math.sqrt(n).to_i
  (3..max_divisor).step(2).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_prime
    candidate = method(:is_prime)
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(101))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(13441))
    assert_equal(true, candidate.call(61))
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(1))
    assert_equal(true, candidate.call(5))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(17))
    assert_equal(false, candidate.call(85))
    assert_equal(false, candidate.call(77))
    assert_equal(false, candidate.call(255379))
  end
end
"
HumanEval_33,bjn_Arab,rb,"ݢاسان مانݢݢݢاناكان ݢاسان مانݢݢاناكان ݢاسان ݢاسان ݢاسان مانݢݢاناكان ݢاسان مانݢݢاناكان ݢاسان مانݢݢاناكان ݢاسان مانݢݢاناكان ݢاسان مانݢݢاناكان ݢاسان مانݢݢاناكان ݢاسان مانݢݢاناكان ݢاسان مانݢݢاناكانl' اداله ادتينديك ل l دالم اينديكس نڠ كادا ديۏيدول لاوان ترديري، سودهڤون ݢاريسڽ دالم اينديكس نڠ ديۏيدول لاوان ترديري سام.فانسي ڠيني مڠاكو ارري l وان مروڤاكن ارري l' ساكيت # >>> sort_third.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])
# [2, 6, 3, 4, 8, 9, 5]
def sort_third(l)
","def sort_third(l)
  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort
  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_third
    candidate = method(:sort_third)
    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))
    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))
    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))
    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))
  end
end
"
HumanEval_34,bjn_Arab,rb,"مڽاتاكن ايليمن يڠ دڤرتيمبڠكن دالم سابوءه ارري# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [0, 2, 3, 5, 9, 123]
def unique(l)
","def unique(l)
  l.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique
    candidate = method(:unique)
    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_35,bjn_Arab,rb,"مڽاراكن ايليمن ماكسيماك دالم ارري.# >>> max_element.call([1, 2, 3])
# 3
# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# 123
def max_element(l)
","def max_element(l)
  l.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_element
    candidate = method(:max_element)
    assert_equal(3, candidate.call([1, 2, 3]))
    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))
  end
end
"
HumanEval_36,bjn_Arab,rb,"ماولاهاكن جومله ڤندودوق دالم ارقام اينتيجر نڠ كاي ساكيتار نڠ ديۏيسيبل لڠكه 11 اتاو 13. # >>> fizz_buzz.call(50)
# 0
# >>> fizz_buzz.call(78)
# 2
# >>> fizz_buzz.call(79)
# 3
def fizz_buzz(n)
","def fizz_buzz(n)
  count = 0
  (1...n).each do |i|
    if i % 11 == 0 || i % 13 == 0
      count += i.to_s.count('7')
    end
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fizz_buzz
    candidate = method(:fizz_buzz)
    assert_equal(0, candidate.call(50))
    assert_equal(2, candidate.call(78))
    assert_equal(3, candidate.call(79))
    assert_equal(3, candidate.call(100))
    assert_equal(6, candidate.call(200))
    assert_equal(192, candidate.call(4000))
    assert_equal(639, candidate.call(10000))
    assert_equal(8026, candidate.call(100000))
  end
end
"
HumanEval_37,bjn_Arab,rb,"باڬين ڤاريسان ڤرتاڽان ڤرتاڽان l، تاڤي ديسورتاسي.l' اداله ادتينديك لاوان l دالم اينديكس نانݢ كادا باسي، سامون ڤاراهانڽ دالم اينديكس نانݢ باسي سام.فانسي ڠيني مڠاكو ارري l وان مروڤاكن ارري l' ساكيت # >>> sort_even.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_even.call([5, 6, 3, 4])
# [3, 6, 5, 4]
def sort_even(l)
","def sort_even(l)
  even_indices = l.each_index.select { |i| i.even? }
  even_values = even_indices.map { |i| l[i] }.sort
  
  even_index = 0
  l.each_with_index.map do |value, index|
    if index.even?
      even_values[even_index].tap { even_index += 1 }
    else
      value
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_even
    candidate = method(:sort_even)
    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))
    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
  end
end
"
HumanEval_39,bjn_Arab,rb,"prime_fib برتوجوكن نومبور ن-هايڽ اداله نومبور فيبوناتشي وان جوا نڠ ڤرنه. # >>> prime_fib.call(1)
# 2
# >>> prime_fib.call(2)
# 3
# >>> prime_fib.call(3)
# 5
# >>> prime_fib.call(4)
# 13
# >>> prime_fib.call(5)
# 89
def prime_fib(n)
","def prime_fib(n)
  require 'prime'
  
  fibs = Enumerator.new do |y|
    a, b = 0, 1
    loop do
      a, b = b, a + b
      y << b
    end
  end
  
  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }
  prime_fibs.first(n).last
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_fib
    candidate = method(:prime_fib)
    assert_equal(2, candidate.call(1))
    assert_equal(3, candidate.call(2))
    assert_equal(5, candidate.call(3))
    assert_equal(13, candidate.call(4))
    assert_equal(89, candidate.call(5))
    assert_equal(233, candidate.call(6))
    assert_equal(1597, candidate.call(7))
    assert_equal(28657, candidate.call(8))
    assert_equal(514229, candidate.call(9))
    assert_equal(433494437, candidate.call(10))
  end
end
"
HumanEval_40,bjn_Arab,rb,"سوم تا صفر، وان كادا.ڽو ماولاه ڤرتاڽان كادا كادا كادا تاتيه ايليمن نڠ بابيدا دالم ارري نڠ triple_sum_to_zero مڠاخيري سابوءه ارري انتيڬري سباڬاي اينڤوت.# >>> triples_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> triples_sum_to_zero.call([1, 3, -2, 1])
# true
# >>> triples_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])
# true
# >>> triples_sum_to_zero.call([1])
# false
def triples_sum_to_zero(l)
","def triples_sum_to_zero(l)
  n = l.length
  (0...n-2).each do |i|
    ((i+1)...n-1).each do |j|
      ((j+1)...n).each do |k|
        return true if l[i] + l[j] + l[k] == 0
      end
    end
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triples_sum_to_zero
    candidate = method(:triples_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, 5, -1]))
    assert_equal(true, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(false, candidate.call([1, 2, 5, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(false, candidate.call([1, 3, 5, -100]))
    assert_equal(false, candidate.call([100, 3, 5, -100]))
  end
end
"
HumanEval_41,bjn_Arab,rb,"فانسي ڠيني ماولاهاكن رنچان كاوليسي ڠيني.دالم ڤرچايرڽ سڤرتي كادا ڤون مڽارڠ.تاڤي، ڤاروت-ڤاروت نڠ كادا باءيسي كاكوءاسأن وان كاوسن نڠ كادا باءيسي; نڠ كاسالڽ، بوهنڽ ماوليه ڤرڬرقن۔وقتو سابوءه ڤرڠكابن نڠ برلالو ك ليم اتس ك ك ليم ممبسر ڤرڠكابن نڠ برلالو ك ك ليم اتس ك ك ليم.ساباراتاان ڤاروت باكالاه ديڤاراكاناكان دي ڤاساڠان نانݢ سام.باديڠ ڤاڠݢوڠݢوڠ ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢل ݢاݢلn ڤرڬي مڠهابيسكن ك ليم ك ك ليم؛ سابالومڽ، سابوءه سيت ڤرڬي ن ڤرڬي مڠامڤيلكن جالن نڠ باءيق جادي سابوءه جالن نڠ لڠكڤ وان تيدق باءيق.def car_race_collision(n)
","def car_race_collision(n)
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_car_race_collision
    candidate = method(:car_race_collision)
    assert_equal(4, candidate.call(2))
    assert_equal(9, candidate.call(3))
    assert_equal(16, candidate.call(4))
    assert_equal(64, candidate.call(8))
    assert_equal(100, candidate.call(10))
  end
end
"
HumanEval_42,bjn_Arab,rb,"مڽاراكن ارري دڠن ايليمن نڠ دڤركمبڠكن اوليه ١.# >>> incr_list.call([1, 2, 3])
# [2, 3, 4]
# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [6, 4, 6, 3, 4, 4, 10, 1, 124]
def incr_list(l)
","def incr_list(l)
  l.map { |x| x + 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_incr_list
    candidate = method(:incr_list)
    assert_equal([], candidate.call([]))
    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))
    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_43,bjn_Arab,rb,"سوم تا صفر، وان كادا.اي مروڤاكن كاءيقينن اڤابيلا اد دوا ايليمن ڤارنتوق دالم ارري pairs_sum_to_zero مڠاخيري سابوءه ارر integer سباڬاي ڤڠمبيلن.# >>> pairs_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> pairs_sum_to_zero.call([1, 3, -2, 1])
# false
# >>> pairs_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])
# true
# >>> pairs_sum_to_zero.call([1])
# false
def pairs_sum_to_zero(l)
","def pairs_sum_to_zero(l)
  num_set = l.to_set
  l.each do |num|
    return true if num != 0 && num_set.include?(-num)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pairs_sum_to_zero
    candidate = method(:pairs_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))
  end
end
"
HumanEval_44,bjn_Arab,rb,"ارقام اساس كاداكن ١٠.مڠرجاكن ڤرسمبهن ستروڠ ستله ڤمباڠونن۔مڠوبه اساس نوميريال نومبور ڤڠمبيلن x كاساساس.# >>> change_base.call(8, 3)
# ""22""
# >>> change_base.call(8, 2)
# ""1000""
# >>> change_base.call(7, 2)
# ""111""
def change_base(x, base)
","def change_base(x, base)
  return '0' if x == 0
  digits = []
  while x > 0
    digits << (x % base).to_s
    x /= base
  end
  digits.reverse.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_change_base
    candidate = method(:change_base)
    assert_equal(""22"", candidate.call(8, 3))
    assert_equal(""100"", candidate.call(9, 3))
    assert_equal(""11101010"", candidate.call(234, 2))
    assert_equal(""10000"", candidate.call(16, 2))
    assert_equal(""1000"", candidate.call(8, 2))
    assert_equal(""111"", candidate.call(7, 2))
    assert_equal(""2"", candidate.call(2, 3))
    assert_equal(""3"", candidate.call(3, 4))
    assert_equal(""4"", candidate.call(4, 5))
    assert_equal(""5"", candidate.call(5, 6))
    assert_equal(""6"", candidate.call(6, 7))
    assert_equal(""7"", candidate.call(7, 8))
  end
end
"
HumanEval_45,bjn_Arab,rb,"ديبارياكان لاوانݢ لاوان ڤىلاكون ڤىلاكون نانݢ باباراڤا نانݢ باباراڤا لاوانݢ تريكؤڠ.# >>> triangle_area.call(5, 3)
# 7.5
def triangle_area(a, h)
","def triangle_area(a, h)
  (a * h) / 2.0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(7.5, candidate.call(5, 3))
    assert_equal(2.0, candidate.call(2, 2))
    assert_equal(40.0, candidate.call(10, 8))
  end
end
"
HumanEval_46,bjn_Arab,rb,"Silakan manulis suatu fungsi gasan efisien manghitung elemen ke-n dari urutan bilangan fib4. Jangan pakai rekursi. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 سيكوينسي نومبور Fib4 اداله سيكوينسي نڠ سام لاون سيكوينسي Fibbonacci نڠ ديفينيسيكن سڤرتي اين: # >>> fib4.call(5)
# 4
# >>> fib4.call(6)
# 8
# >>> fib4.call(7)
# 14
def fib4(n)
","def fib4(n)
  return 0 if n == 0 || n == 1 || n == 3
  return 2 if n == 2

  fib4_seq = [0, 0, 2, 0]
  (4..n).each do |i|
    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]
  end
  fib4_seq[n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib4
    candidate = method(:fib4)
    assert_equal(4, candidate.call(5))
    assert_equal(28, candidate.call(8))
    assert_equal(104, candidate.call(10))
    assert_equal(386, candidate.call(12))
  end
end
"
HumanEval_47,bjn_Arab,rb,"مديان ڤاڽاراكن ايليمن دالم ارري l. # >>> median.call([3, 1, 2, 4, 5])
# 3
# >>> median.call([-10, 4, 6, 1000, 10, 20])
# 15.0
def median(l)
","def median(l)
  sorted = l.sort
  len = sorted.length
  if len.odd?
    sorted[len / 2]
  else
    (sorted[len / 2 - 1] + sorted[len / 2]) / 2.0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_median
    candidate = method(:median)
    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))
    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))
    assert_equal(5, candidate.call([5]))
    assert_equal(5.5, candidate.call([6, 5]))
    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))
  end
end
"
HumanEval_48,bjn_Arab,rb,"مڠچاكاكاكن اڤابيلا ستراين دبري اداله ڤاليندروم # >>> is_palindrome.call("""")
# true
# >>> is_palindrome.call(""aba"")
# true
# >>> is_palindrome.call(""aaaaa"")
# true
# >>> is_palindrome.call(""zbcd"")
# false
def is_palindrome(text)
","is_palindrome = lambda do |text|
  text == text.reverse
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_palindrome
    candidate = method(:is_palindrome)
    assert_equal(true, candidate.call(""""))
    assert_equal(true, candidate.call(""aba""))
    assert_equal(true, candidate.call(""aaaaa""))
    assert_equal(false, candidate.call(""zbcd""))
    assert_equal(true, candidate.call(""xywyx""))
    assert_equal(false, candidate.call(""xywyz""))
    assert_equal(false, candidate.call(""xywzx""))
  end
end
"
HumanEval_49,bjn_Arab,rb,"مڽاتاكن 2^n مودولو p (تاهڤكن باڬين نوميريک).# >>> modp.call(3, 5)
# 3
# >>> modp.call(1101, 101)
# 2
# >>> modp.call(0, 101)
# 1
# >>> modp.call(3, 11)
# 8
# >>> modp.call(100, 101)
# 1
def modp(n, p)
","def modp(n, p)
  return 1 if p == 1
  2.pow(n, p)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_modp
    candidate = method(:modp)
    assert_equal(3, candidate.call(3, 5))
    assert_equal(2, candidate.call(1101, 101))
    assert_equal(1, candidate.call(0, 101))
    assert_equal(8, candidate.call(3, 11))
    assert_equal(1, candidate.call(100, 101))
    assert_equal(4, candidate.call(30, 5))
    assert_equal(3, candidate.call(31, 5))
  end
end
"
HumanEval_51,bjn_Arab,rb,"remove_vowels اداله فانكسسي نڠ مڠمبيل ساءنجور وان مروڤاكن ساءنجور تنڤا ڤوۏال. # >>> remove_vowels.call("""")
# """"
# >>> remove_vowels.call(""abcdef"")
# ""bcdf""
# >>> remove_vowels.call(""aaaaa"")
# """"
# >>> remove_vowels.call(""aaBAA"")
# ""B""
# >>> remove_vowels.call(""zbcd"")
# ""zbcd""
def remove_vowels(text)
","def remove_vowels(text)
  text.delete('aeiouAEIOU')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_vowels
    candidate = method(:remove_vowels)
    assert_equal("""", candidate.call(""""))
    assert_equal(""bcdf
ghjklm"", candidate.call(""abcdef
ghijklm""))
    assert_equal(""fdcb"", candidate.call(""fedcba""))
    assert_equal("""", candidate.call(""eeeee""))
    assert_equal(""cB"", candidate.call(""acBAA""))
    assert_equal(""cB"", candidate.call(""EcBOO""))
    assert_equal(""ybcd"", candidate.call(""ybcd""))
  end
end
"
HumanEval_52,bjn_Arab,rb,"مروڤاكن تڤت جادي سموا نومبور دالم ارري l اد داسر سومبر t. # >>> below_threshold.call([1, 2, 4, 10], 100)
# true
# >>> below_threshold.call([1, 20, 4, 10], 5)
# false
def below_threshold(l, t)
","def below_threshold(l, t)
  l.all? { |num| num < t }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_threshold
    candidate = method(:below_threshold)
    assert_equal(true, candidate.call([1, 2, 4, 10], 100))
    assert_equal(false, candidate.call([1, 20, 4, 10], 5))
    assert_equal(true, candidate.call([1, 20, 4, 10], 21))
    assert_equal(true, candidate.call([1, 20, 4, 10], 22))
    assert_equal(true, candidate.call([1, 8, 4, 10], 11))
    assert_equal(false, candidate.call([1, 8, 4, 10], 10))
  end
end
"
HumanEval_53,bjn_Arab,rb,"مڽومبڠاكن دوا نومبور x وان y # >>> add.call(2, 3)
# 5
# >>> add.call(5, 7)
# 12
def add(x, y)
","add = ->(x, y) { x + y }","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(1, candidate.call(0, 1))
    assert_equal(1, candidate.call(1, 0))
    assert_equal(5, candidate.call(2, 3))
    assert_equal(12, candidate.call(5, 7))
    assert_equal(12, candidate.call(7, 5))
  end
end
"
HumanEval_54,bjn_Arab,rb,"ڤرچاي اڤاکه دوا كات باءيسي كاراكتر نڠ سام.# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
# true
# >>> same_chars.call(""abcd"", ""dddddddabc"")
# true
# >>> same_chars.call(""dddddddabc"", ""abcd"")
# true
# >>> same_chars.call(""eabcd"", ""dddddddabc"")
# false
# >>> same_chars.call(""abcd"", ""dddddddabce"")
# false
# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
# false
def same_chars(s0, s1)
","def same_chars(s0, s1)
  s0.chars.uniq.all? { |char| s1.include?(char) } &&
  s1.chars.uniq.all? { |char| s0.include?(char) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_same_chars
    candidate = method(:same_chars)
    assert_equal(true, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc""))
    assert_equal(true, candidate.call(""abcd"", ""dddddddabc""))
    assert_equal(true, candidate.call(""dddddddabc"", ""abcd""))
    assert_equal(false, candidate.call(""eabcd"", ""dddddddabc""))
    assert_equal(false, candidate.call(""abcd"", ""dddddddabcf""))
    assert_equal(false, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddddabc""))
    assert_equal(false, candidate.call(""aabb"", ""aaccc""))
  end
end
"
HumanEval_55,bjn_Arab,rb,"ماولاهاكن نومبور فيبوناتچي ن-تاهون.# >>> fib.call(10)
# 55
# >>> fib.call(1)
# 1
# >>> fib.call(8)
# 21
def fib(n)
","def fib(n)
  return n if n <= 1
  fib(n - 1) + fib(n - 2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib
    candidate = method(:fib)
    assert_equal(55, candidate.call(10))
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(8))
    assert_equal(89, candidate.call(11))
    assert_equal(144, candidate.call(12))
  end
end
"
HumanEval_56,bjn_Arab,rb,"return true اڤابيلا ستياڤ براكيت ڤمبوكاين اد براكيت ڤمبوكاين يڠ بركاءيتن. ݢاريس ڤرتاڽان اداله ساءورڠ ساءورڠ ""<"" وان "">"".# >>> correct_bracketing.call(""<"")
# false
# >>> correct_bracketing.call(""<>"")
# true
# >>> correct_bracketing.call(""<<><>>"")
# true
# >>> correct_bracketing.call(""><<>"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.chars.each do |char|
    if char == '<'
      balance += 1
    elsif char == '>'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""<>""))
    assert_equal(true, candidate.call(""<<><>>""))
    assert_equal(true, candidate.call(""<><><<><>><>""))
    assert_equal(true, candidate.call(""<><><<<><><>><>><<><><<>>>""))
    assert_equal(false, candidate.call(""<<<><>>>>""))
    assert_equal(false, candidate.call(""><<>""))
    assert_equal(false, candidate.call(""<""))
    assert_equal(false, candidate.call(""<<<<""))
    assert_equal(false, candidate.call("">""))
    assert_equal(false, candidate.call(""<<>""))
    assert_equal(false, candidate.call(""<><><<><>><>><<>""))
    assert_equal(false, candidate.call(""<><><<><>><>>><>""))
  end
end
"
HumanEval_57,bjn_Arab,rb,"Return true اداله ايليمن ڤينتو مونوتونيكاڽ ممبيمبڠ اتاو مڠورڠاكن.# >>> monotonic.call([1, 2, 4, 20])
# true
# >>> monotonic.call([1, 20, 4, 10])
# false
# >>> monotonic.call([4, 1, 0, -10])
# true
def monotonic(l)
","def monotonic(l)
  increasing = true
  decreasing = true

  (0...l.length - 1).each do |i|
    if l[i] < l[i + 1]
      decreasing = false
    elsif l[i] > l[i + 1]
      increasing = false
    end
  end

  increasing || decreasing
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_monotonic
    candidate = method(:monotonic)
    assert_equal(true, candidate.call([1, 2, 4, 10]))
    assert_equal(true, candidate.call([1, 2, 4, 20]))
    assert_equal(false, candidate.call([1, 20, 4, 10]))
    assert_equal(true, candidate.call([4, 1, 0, -10]))
    assert_equal(true, candidate.call([4, 1, 1, 0]))
    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))
    assert_equal(true, candidate.call([9, 9, 9, 9]))
  end
end
"
HumanEval_58,bjn_Arab,rb,"مڽاراكن ايليمن كومين يڠ سورتاسي اونيكا باڬي دوا ارري.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
# [1, 5, 653]
# >>> common.call([5, 3, 2, 8], [3, 2])
# [2, 3]
def common(l1, l2)
","def common(l1, l2)
  (l1 & l2).uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_common
    candidate = method(:common)
    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))
    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))
    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))
    assert_equal([], candidate.call([4, 3, 2, 8], []))
  end
end
"
HumanEval_59,bjn_Arab,rb,"مڽاتاكن فاكتور ڤرمايسوري ن نڠ ڤاليڠ بسر. مڠهارڤكن ن > 1 وان كادا ڤرمايسوري. # >>> largest_prime_factor.call(13195)
# 29
# >>> largest_prime_factor.call(2048)
# 2
def largest_prime_factor(n)
","def largest_prime_factor(n)
  factor = 2
  while factor * factor <= n
    if n % factor == 0
      n /= factor
    else
      factor += 1
    end
  end
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_prime_factor
    candidate = method(:largest_prime_factor)
    assert_equal(5, candidate.call(15))
    assert_equal(3, candidate.call(27))
    assert_equal(7, candidate.call(63))
    assert_equal(11, candidate.call(330))
    assert_equal(29, candidate.call(13195))
  end
end
"
HumanEval_60,bjn_Arab,rb,"sum_to_n اداله فانكسسي نڠ مڽومبڠكن نومبور دري ١ سمڤأي n. # >>> sum_to_n.call(30)
# 465
# >>> sum_to_n.call(100)
# 5050
# >>> sum_to_n.call(5)
# 15
# >>> sum_to_n.call(10)
# 55
# >>> sum_to_n.call(1)
# 1
def sum_to_n(n)
","def sum_to_n(n)
  (1..n).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_to_n
    candidate = method(:sum_to_n)
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(6))
    assert_equal(66, candidate.call(11))
    assert_equal(465, candidate.call(30))
    assert_equal(5050, candidate.call(100))
  end
end
"
HumanEval_61,bjn_Arab,rb,"return true اڤابيلا ستياڤ براكيت ڤمبوكاين اد براكيت ڤمبوكاين يڠ بركاءيتن. ݢاريس ڤرتاڽان اداله ساءورڠ ساءورڠ ""("" وان "")"".# >>> correct_bracketing.call(""("")
# false
# >>> correct_bracketing.call(""()"")
# true
# >>> correct_bracketing.call(""(()())"")
# true
# >>> correct_bracketing.call("")(()"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.each_char do |char|
    if char == '('
      balance += 1
    elsif char == ')'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""()""))
    assert_equal(true, candidate.call(""(()())""))
    assert_equal(true, candidate.call(""()()(()())()""))
    assert_equal(true, candidate.call(""()()((()()())())(()()(()))""))
    assert_equal(false, candidate.call(""((()())))""))
    assert_equal(false, candidate.call("")(()""))
    assert_equal(false, candidate.call(""(""))
    assert_equal(false, candidate.call(""((((""))
    assert_equal(false, candidate.call("")""))
    assert_equal(false, candidate.call(""(()""))
    assert_equal(false, candidate.call(""()()(()())())(()""))
    assert_equal(false, candidate.call(""()()(()())()))()""))
  end
end
"
HumanEval_62,bjn_Arab,rb,"ماولاه توليسن ڤولينوم اين دالم بنتوق سام.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs مانامڤيلكن كوايفيسينت ڤولينوم.# >>> derivative.call([3, 1, 2, 4, 5])
# [1, 4, 12, 20]
# >>> derivative.call([1, 2, 3])
# [2, 6]
def derivative(xs)
","def derivative(xs)
  return [] if xs.length < 2
  xs.each_with_index.map { |coef, index| coef * index }[1..-1]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_derivative
    candidate = method(:derivative)
    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))
    assert_equal([2, 6], candidate.call([1, 2, 3]))
    assert_equal([2, 2], candidate.call([3, 2, 1]))
    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))
    assert_equal([], candidate.call([1]))
  end
end
"
HumanEval_63,bjn_Arab,rb,"Silakan manulis suatu fungsi gasan efisien manghitung elemen ke-n dari urutan bilangan fibfib.fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). fib fib (((2) == 1 fib fib ((1) == 0 fib fib ((0) == 0 سيكوينسي نومبور FibFib اداله سيكوينسي نڠ سام لاون سيكوينسي Fibbonacci نڠ ديفينيسيكن سڤرتي اين: # >>> fibfib.call(1)
# 0
# >>> fibfib.call(5)
# 4
# >>> fibfib.call(8)
# 24
def fibfib(n)
","def fibfib(n)
  return 0 if n == 0 || n == 1
  return 1 if n == 2

  a, b, c = 0, 0, 1
  (3..n).each do
    a, b, c = b, c, a + b + c
  end
  c
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fibfib
    candidate = method(:fibfib)
    assert_equal(1, candidate.call(2))
    assert_equal(0, candidate.call(1))
    assert_equal(4, candidate.call(5))
    assert_equal(24, candidate.call(8))
    assert_equal(81, candidate.call(10))
    assert_equal(274, candidate.call(12))
    assert_equal(927, candidate.call(14))
  end
end
"
HumanEval_64,bjn_Arab,rb,"چونتوه:ڤوۏال، تاڤي هاڽ ڤاس ڤاس اخير كات نڠ دبري.ڤوکل دالم کيس اين اداله 'ا'، 'ى'، 'ى'، 'و'، 'و'۔ دمان، 'ي' جوݢ اداله سابوءه كات سابوءه ڤانوليسن وان مانولاكن كاءدأن ڤانوليس دالم ساكيت.منوليس فانسي vowels_count نڠ مڠڬونااكن ساءيرڠ نڠ مڠامڤيل # >>> vowels_count.call(""abcde"")
# 2
# >>> vowels_count.call(""ACEDY"")
# 3
def vowels_count(s)
","def vowels_count(s)
  vowels = ['a', 'e', 'i', 'o', 'u']
  count = 0
  
  s.chars.each_with_index do |char, index|
    if vowels.include?(char.downcase)
      count += 1
    elsif char.downcase == 'y' && index == s.length - 1
      count += 1
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_vowels_count
    candidate = method(:vowels_count)
    assert_equal(2, candidate.call(""abcde""))
    assert_equal(3, candidate.call(""Alone""))
    assert_equal(2, candidate.call(""key""))
    assert_equal(1, candidate.call(""bye""))
    assert_equal(2, candidate.call(""keY""))
    assert_equal(1, candidate.call(""bYe""))
    assert_equal(3, candidate.call(""ACEDY""))
  end
end
"
HumanEval_65,bjn_Arab,rb,"اڤابيلا ڤمبلاجرن > جومله ديڬيت، ديڬيت ڤرتام ڤرلو دڤرچايا ?? ي.وان ماولاهاكن ريسلتا ساباڬاي ساءينتير.ڤرڤوستاءن سيريوس ديݢيتار انتيݢار x، ڤرڤوستاءن سيريوس ك ڤرڤوستاءن # >>> circular_shift.call(12, 1)
# ""21""
# >>> circular_shift.call(12, 2)
# ""12""
def circular_shift(x, shift)
","def circular_shift(x, shift)
  digits = x.to_s.chars
  num_digits = digits.length

  if shift > num_digits
    return digits.reverse.join
  else
    shift = shift % num_digits
    shifted_digits = digits.rotate(-shift)
    return shifted_digits.join
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_circular_shift
    candidate = method(:circular_shift)
    assert_equal(""001"", candidate.call(100, 2))
    assert_equal(""12"", candidate.call(12, 2))
    assert_equal(""79"", candidate.call(97, 8))
    assert_equal(""21"", candidate.call(12, 1))
    assert_equal(""11"", candidate.call(11, 101))
  end
end
"
HumanEval_66,bjn_Arab,rb,"چونتوه:كود ASCII. منوليس فانسيون نڠ مڠڬوناكن سورت كاي انڤوت وان مروڤاكن سومتوه كاراكتر اوتام هاڽ' ڤاكاي # >>> digitSum.call("""")
# 0
# >>> digitSum.call(""abAB"")
# 131
# >>> digitSum.call(""abcCd"")
# 67
# >>> digitSum.call(""helloE"")
# 69
# >>> digitSum.call(""woArBld"")
# 131
# >>> digitSum.call(""aAaaaXa"")
# 153
def digitSum(s)
","def digitSum(s)
  s.chars.select { |char| char =~ /[A-Z]/ }.map(&:ord).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digitSum
    candidate = method(:digitSum)
    assert_equal(0, candidate.call(""""))
    assert_equal(131, candidate.call(""abAB""))
    assert_equal(67, candidate.call(""abcCd""))
    assert_equal(69, candidate.call(""helloE""))
    assert_equal(131, candidate.call(""woArBld""))
    assert_equal(153, candidate.call(""aAaaaXa""))
    assert_equal(151, candidate.call("" How are yOu?""))
    assert_equal(327, candidate.call(""You arE Very Smart""))
  end
end
"
HumanEval_67,bjn_Arab,rb,"باݢي ايكسامبل: دي باسكيت برڤرچاياڠ كاءدأن بوميڤوترا مانجو دي باسكيت.بوميڤوترا وان ايبولا وان انتيڬر نڠ مانونجوكاكن سومبر بوميڤوترا ماسيڠ-ماسيڠ، ليمو، وان ميوه مانجو. دڤاداكن سليرا نڠ منونجوكاكن جومله نڠ ديڤاسيركن دالم سابوءه باسکيت باهن باسکيت اين بايسي دالم ڤرلاونن اين، اكو اكن دبري ساتو سورت يڠ مروڤاكن سابوءه رنچان انم وان انم.# >>> fruit_distribution.call(""5 apples and 6 oranges"", 19)
# 8
# >>> fruit_distribution.call(""0 apples and 1 oranges"", 3)
# 2
# >>> fruit_distribution.call(""2 apples and 3 oranges"", 100)
# 95
# >>> fruit_distribution.call(""100 apples and 1 oranges"", 120)
# 19
def fruit_distribution(s, n)
","def fruit_distribution(s, n)
  numbers = s.scan(/\d+/).map(&:to_i)
  apples = numbers[0]
  oranges = numbers[1]
  total_fruits = n
  mangos = total_fruits - (apples + oranges)
  mangos
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fruit_distribution
    candidate = method(:fruit_distribution)
    assert_equal(8, candidate.call(""5 apples and 6 oranges"", 19))
    assert_equal(10, candidate.call(""5 apples and 6 oranges"", 21))
    assert_equal(2, candidate.call(""0 apples and 1 oranges"", 3))
    assert_equal(2, candidate.call(""1 apples and 0 oranges"", 3))
    assert_equal(95, candidate.call(""2 apples and 3 oranges"", 100))
    assert_equal(0, candidate.call(""2 apples and 3 oranges"", 5))
    assert_equal(19, candidate.call(""1 apples and 100 oranges"", 120))
  end
end
"
HumanEval_68,bjn_Arab,rb,"چونتوه 1:اڤابيلا اد ڤاروليه نڠ تيدق اد اتاو ارري نڠ دبريكن كادا باهن، جادي []۔نودا نڠ دڤيليه ڤرلو دڤرجواڠكن دالم سابوءه ارري، [smallest_value، ايندكسڽ]، اڤابيلا ببراڤ نودا دڠن باهن جادي نڠ ڤاليڠ باءيق سام دتومڤوڠ مڽارڠ نودا نڠ باءيق اينديكسڽ. نوډ نڠ دڤيليه ڤرلو جادي نوډ نڠ باءيسي باهن جادي نڠ كادا باءيسي.كاراتان اداله ڬاڤاي سابوتيڠ داري نوݢول وان ماولاهڽا.""ديتاهوءي سابوتيڠ ارري نڠ مروڤاكن سابوتيڠ ڤڠاروه دري سابوتيڠ باهن نڠ مان ناڠ-نيڬاتيف اينتيڬر نوڬول # >>> pluck.call([4, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 2:
# >>> pluck.call([1, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 3:
# >>> pluck.call([])
# []
# Example 4:
# >>> pluck.call([5, 0, 3, 0, 4, 2])
# [0, 1]
# Explanation: 0 is the smallest value, but  there are two zeros,
# so we will choose the first zero, which has the smallest index.
# Constraints:
# * 1 <= nodes.length <= 10000
# * 0 <= node.value
def pluck(arr)
","def pluck(arr)
  smallest_even = nil
  smallest_index = nil
  
  arr.each_with_index do |value, index|
    if value.even?
      if smallest_even.nil? || value < smallest_even
        smallest_even = value
        smallest_index = index
      end
    end
  end

  smallest_even.nil? ? [] : [smallest_even, smallest_index]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pluck
    candidate = method(:pluck)
    assert_equal([2, 1], candidate.call([4, 2, 3]))
    assert_equal([2, 1], candidate.call([1, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))
    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))
    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))
    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))
    assert_equal([], candidate.call([7, 9, 7, 1]))
  end
end
"
HumanEval_69,bjn_Arab,rb,"چونتوه:اڤاکه تيدق اد ۏاليو سڤرتي ايت، مڽاتاكن -1.فريكؤنسي انتيڬر اداله باڽق كاليڽ تاهو دالم ارري۔nol, wan frekuensinya labih dari atawa sama lawan nilai bilangan bulat itu sendiri.اكو دبريتاهو سابوءه ارري ڤوسيتيف اينتيڬر نڠ كادا باءيق. ماولاه انتيڬر ڤاليڠ ڬانل نڠ لابه دري # >>> search.call([4, 1, 2, 2, 3, 1])
# 2
# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])
# 3
# >>> search.call([5, 5, 4, 4, 4])
# -1
def search(lst)
","def search(lst)
  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }
  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys
  valid_numbers.empty? ? -1 : valid_numbers.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_search
    candidate = method(:search)
    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))
    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))
    assert_equal(-1, candidate.call([3, 3]))
    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))
    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))
    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))
    assert_equal(2, candidate.call([3, 2, 8, 2]))
    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))
    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))
    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))
    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))
    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))
    assert_equal(1, candidate.call([1]))
    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))
    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))
    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))
    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))
    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))
    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))
    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))
    assert_equal(-1, candidate.call([10]))
    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))
    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))
    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))
    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))
  end
end
"
HumanEval_70,bjn_Arab,rb,"چونتوه:، لالو ماكسيما انجيري نڠ باكل، لالو مينيموم، وان لاينڽ۔ڤڠڬيلن نڠ كاي، اداله اڤابيلا اندا برمولا دڠن قدر مينيموم، باڤينݢݢاراكان ارري داري انتيݢىر, ڤاراه ارري دي ڤارؤتؤر نانݢ كادا ڤارؤتؤر.# >>> strange_sort_list.call([1, 2, 3, 4])
# [1, 4, 2, 3]
# >>> strange_sort_list.call([5, 5, 5, 5])
# [5, 5, 5, 5]
# >>> strange_sort_list.call([])
# []
def strange_sort_list(lst)
","def strange_sort_list(lst)
  result = []
  lst.sort!
  until lst.empty?
    result << lst.shift
    result << lst.pop unless lst.empty?
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strange_sort_list
    candidate = method(:strange_sort_list)
    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))
    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))
    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))
    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))
    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))
    assert_equal([], candidate.call([]))
    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))
    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))
    assert_equal([111111], candidate.call([111111]))
  end
end
"
HumanEval_71,bjn_Arab,rb,"چونتوه:ڤاس تاتس.ترديري دري تريڠڬل باڬنتوڠ جادي تريڠڬل ڤاليڠ باءيق جك سومبڠن دوا تريڠڬل نڠ باءيك.اڤاکه لاين ڤرلو مڽارڠ -1 سݢالا تيݢ دݢولڠݢولاكن ك ٢ تيتيق ديسيمل جادي تيݢ بݢيتو باكل منجادي سݢالا تيݢ يڠ باءيق.ديتاهنݢاكان ݢاريس-ݢاريس تريسياڠل. ماولاه ڤاسار # >>> triangle_area.call(3, 4, 5)
# 6.0
# >>> triangle_area.call(1, 2, 10)
# -1
def triangle_area(a, b, c)
","def triangle_area(a, b, c)
  # Check for valid triangle
  if a + b > c && a + c > b && b + c > a
    # Calculate the semi-perimeter
    s = (a + b + c) / 2.0
    # Calculate the area using Heron's formula
    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))
    # Round to 2 decimal points
    return area.round(2)
  else
    return -1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(6.0, candidate.call(3, 4, 5))
    assert_equal(-1, candidate.call(1, 2, 10))
    assert_equal(8.18, candidate.call(4, 8, 5))
    assert_equal(1.73, candidate.call(2, 2, 2))
    assert_equal(-1, candidate.call(1, 2, 3))
    assert_equal(16.25, candidate.call(10, 5, 7))
    assert_equal(-1, candidate.call(2, 6, 3))
    assert_equal(0.43, candidate.call(1, 1, 1))
    assert_equal(-1, candidate.call(2, 2, 10))
  end
end
"
HumanEval_72,bjn_Arab,rb,"چونتوه:اوبجيكت q اكن مڠهادڤكن جك اي تله بربيلانس (اڽ اداله ارسي ڤاليندروم) وان سومت ايليمنڽ اداله كيراان اتاو سام دڠن بوزن ماكسيماولل نڠ موڠكين w.منوليس فانسي نڠ مڽاتاكن كاءيقينن اڤابيلا اوبجيكت q مڠهادڤي، وان كادڠ-كادڠ لاينڽ. # >>> will_it_fly.call([1, 2], 5)
# false
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly.call([3, 2, 3], 1)
# false
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly.call([3, 2, 3], 9)
# true
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly.call([3], 5)
# true
# # 3 is less than the maximum possible weight, and it's balanced.
def will_it_fly(q, w)
","def will_it_fly(q, w)
  is_palindrome = q == q.reverse
  total_weight = q.sum
  is_balanced_and_under_weight = is_palindrome && total_weight <= w
  is_balanced_and_under_weight
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_will_it_fly
    candidate = method(:will_it_fly)
    assert_equal(true, candidate.call([3, 2, 3], 9))
    assert_equal(false, candidate.call([1, 2], 5))
    assert_equal(true, candidate.call([3], 5))
    assert_equal(false, candidate.call([3, 2, 3], 1))
    assert_equal(false, candidate.call([1, 2, 3], 6))
    assert_equal(true, candidate.call([5], 5))
  end
end
"
HumanEval_73,bjn_Arab,rb,"چونتوهڽ: ديڤاچاراكن سام كالو ڤاروباهن، اندا بوليه مڠمبيل ساتو ايليمن كاو ايليمن لاين.ڤرلو ديباڠوناكن ڬسن منجاديكن ارري ڤاليندروم. ارري ڤاليندروم اداله ارري ديسهاري سابوتيڠ ار ار ار، مانيڠكتكن نومبور ايليمن نڠ كادا ڤاليڠ كادڠڽ # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])
# 4
# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])
# 1
# >>> smallest_change.call([1, 2, 3, 2, 1])
# 0
def smallest_change(arr)
","def smallest_change(arr)
  changes = 0
  left = 0
  right = arr.length - 1

  while left < right
    if arr[left] != arr[right]
      changes += 1
    end
    left += 1
    right -= 1
  end

  changes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_smallest_change
    candidate = method(:smallest_change)
    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))
    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))
    assert_equal(1, candidate.call([1, 4, 2]))
    assert_equal(1, candidate.call([1, 4, 4, 2]))
    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))
    assert_equal(0, candidate.call([3, 1, 1, 3]))
    assert_equal(0, candidate.call([1]))
    assert_equal(1, candidate.call([0, 1]))
  end
end
"
HumanEval_74,bjn_Arab,rb,"چونتوه اڤابيلا دوا ارري بايسي باڽق كارن نڠ سام، جاديكن ارري ڤرتام.jumlah jumlah kar dalam seberataan string dari array kurang dari array laen. منوليس فانکشن نڠ منڠڬوڠ دوا ارري دري ساءنجوم وان مروڤاكن ارري نڠ # >>> total_match.call([], [])
# []
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""Hi""])
# [""hI"", ""Hi""]
# >>> total_match.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
# [""hi"", ""admin""]
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
# [""hI"", ""hi"", ""hi""]
# >>> total_match.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
# [""4""]
def total_match(lst1, lst2)
","def total_match(lst1, lst2)
  total_chars1 = lst1.map(&:length).sum
  total_chars2 = lst2.map(&:length).sum

  if total_chars1 < total_chars2
    lst1
  elsif total_chars2 < total_chars1
    lst2
  else
    lst1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_total_match
    candidate = method(:total_match)
    assert_equal([], candidate.call([], []))
    assert_equal([""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]))
    assert_equal([""4""], candidate.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]))
    assert_equal([""hI"", ""Hi""], candidate.call([""hi"", ""admin""], [""hI"", ""Hi""]))
    assert_equal([""hI"", ""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]))
    assert_equal([], candidate.call([], [""this""]))
    assert_equal([], candidate.call([""this""], []))
  end
end
"
HumanEval_75,bjn_Arab,rb,"چونتوه:مڠاتسي (a) اداله كورڠ دري 100وان كاذب سواه.منوليس فانسيون نڠ مروڤاكن كاءيتن جادي ڤربالهن دري 3 نومبور ڤرم # >>> is_multiply_prime.call(30)
# true
# 30 = 2 * 3 * 5
def is_multiply_prime(a)
","require 'prime'

def is_multiply_prime(a)
  return false if a >= 100
  prime_factors = a.prime_division
  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_multiply_prime
    candidate = method(:is_multiply_prime)
    assert_equal(false, candidate.call(5))
    assert_equal(true, candidate.call(30))
    assert_equal(true, candidate.call(8))
    assert_equal(false, candidate.call(10))
    assert_equal(true, candidate.call(125))
    assert_equal(true, candidate.call(105))
    assert_equal(false, candidate.call(126))
    assert_equal(false, candidate.call(729))
    assert_equal(false, candidate.call(891))
    assert_equal(true, candidate.call(1001))
  end
end
"
HumanEval_76,bjn_Arab,rb,"چونتوهڽ: x اداله كواس سيبس n جادي n**int=x كاوجوان n وان كادوس دالم حال-حال لاينڽ۔كاريكتورن كامو اداله ڬسن منوليس فانسيون نڠ مروڤاكن تريتس جادي سابوءه نومبور x اداله سابوءه # >>> is_simple_power.call(1, 4)
# true
# >>> is_simple_power.call(2, 2)
# true
# >>> is_simple_power.call(8, 2)
# true
# >>> is_simple_power.call(3, 2)
# false
# >>> is_simple_power.call(3, 1)
# false
# >>> is_simple_power.call(5, 3)
# false
def is_simple_power(x, n)
","def is_simple_power(x, n)
  return false if x <= 0 || n <= 1
  return true if x == 1

  power = n
  while power <= x
    return true if power == x
    power *= n
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_simple_power
    candidate = method(:is_simple_power)
    assert_equal(true, candidate.call(16, 2))
    assert_equal(false, candidate.call(143214, 16))
    assert_equal(true, candidate.call(4, 2))
    assert_equal(true, candidate.call(9, 3))
    assert_equal(true, candidate.call(16, 4))
    assert_equal(false, candidate.call(24, 2))
    assert_equal(false, candidate.call(128, 4))
    assert_equal(false, candidate.call(12, 6))
    assert_equal(true, candidate.call(1, 1))
    assert_equal(true, candidate.call(1, 12))
  end
end
"
HumanEval_77,bjn_Arab,rb,"چونتوه:ڤنوتوڤ: اندا موڠكين مڠڬڤ ڤاڠوننڽ سداڠ باءيق.اڤابيلا اين اينڬير اداله كوب دري باڽق نومبور اينتيجر.منوليس فانکشن نڠ مڠاخيري انتيڬر a وان مڽاتاكن تيرل # >>> iscube.call(1)
# true
# >>> iscube.call(2)
# false
# >>> iscube.call(-1)
# true
# >>> iscube.call(64)
# true
# >>> iscube.call(0)
# true
# >>> iscube.call(180)
# false
def iscube(a)
","def iscube(a)
  cube_root = a.abs**(1.0/3)
  cube_root.round**3 == a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_iscube
    candidate = method(:iscube)
    assert_equal(true, candidate.call(1))
    assert_equal(false, candidate.call(2))
    assert_equal(true, candidate.call(-1))
    assert_equal(true, candidate.call(64))
    assert_equal(false, candidate.call(180))
    assert_equal(true, candidate.call(1000))
    assert_equal(true, candidate.call(0))
    assert_equal(false, candidate.call(1729))
  end
end
"
HumanEval_78,bjn_Arab,rb,"چونتوه:وان سيمبول A,B,C,D,E,F سداڤ دڤاڤركن.ڤوتو: اندا موڠكين مڠڬڤ ڤاڠوننڽ سداڠ كوكور اتاو سكارڠ، B (= ديسيمال 11) ، D (= ديسيمال 13) جادي اندا ڤرلو مميليه سابوءه ارق دري ارق جادي: 2، 3، 5، 7، bilangan prima adalah 2, 3, 5, 7, 11, 13, 17,... ديت هيكساديسيمال اداله ٠، ١، ٢، ٣، ٤، ٥، ٦، ٧، ٨، ٩، ا، ب، سي، د، اي، ف.نڠ لابيه بسر دري ١ نڠ كادا سابوءه ڤرودوك دوا نومبور نڠكالڽ نڠ لابه كاءيت).digit-digit nang adalah bilangan prima (bilangan prima, atawa bilangan prima, adalah bilangan asli سابوءه ارقام هيكساديسيمال سابوءه ساءينݢ وان مڠحسيس ارقام هيكساديسيمال اكو تله دتاڠني ڬسن منوليس فڠسي ڤرمايسوري # >>> hex_key.call(""AB"")
# 1
# >>> hex_key.call(""1077E"")
# 2
# >>> hex_key.call(""ABED1A33"")
# 4
# >>> hex_key.call(""123456789ABCDEF0"")
# 6
# >>> hex_key.call(""2020"")
# 2
def hex_key(num)
","def hex_key(num)
  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']
  num.chars.count { |digit| prime_hex_digits.include?(digit) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_hex_key
    candidate = method(:hex_key)
    assert_equal(1, candidate.call(""AB""))
    assert_equal(2, candidate.call(""1077E""))
    assert_equal(4, candidate.call(""ABED1A33""))
    assert_equal(2, candidate.call(""2020""))
    assert_equal(6, candidate.call(""123456789ABCDEF0""))
    assert_equal(12, candidate.call(""112233445566778899AABBCCDDEEFF00""))
  end
end
"
HumanEval_79,bjn_Arab,rb,"چونتوه:كاراكتر-كاراكتر تڠݢارا دياله اونتوق ممبنتو دڠن ڤورتميت.اكن اد سابوه كاراكتر كلوار 'db' د ڤامولأن وان د اخير ساءينتر.ستياڤ كاراكتر دالم ساءينر جادي '0' اتاو '1'.ڤانكتسي ڤرلو مروڤاكن ستريڠ، دڠن ستياڤ كاراكتر ماڠاراكن  باينرياكو اكن دبريكن نومبور دالم بنتوق ديسيمال وان كاوسن اكو اداله اونتوق مڠمبيلڽ كڤد # >>> decimal_to_binary.call(15)
# ""db1111db""
# >>> decimal_to_binary.call(32)
# ""db100000db""
def decimal_to_binary(decimal)
","def decimal_to_binary(decimal)
  ""db"" + decimal.to_s(2) + ""db""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_decimal_to_binary
    candidate = method(:decimal_to_binary)
    assert_equal(""db0db"", candidate.call(0))
    assert_equal(""db100000db"", candidate.call(32))
    assert_equal(""db1100111db"", candidate.call(103))
    assert_equal(""db1111db"", candidate.call(15))
  end
end
"
HumanEval_80,bjn_Arab,rb,"چونتوهڽ: سابوءه تار اداله haprb اڤابيلا بوڽيڽ كادا ساكيتار ٣ وان ستياڤ ٣ حروف تاتار اداله بابيدا كار تو اداله ڬاسن ماچق اڤاکه ساءورڠڽ haprb اتاو كادا.اكو دبري ساءينت s. # >>> is_happy.call(""a"")
# false
# >>> is_happy.call(""aa"")
# false
# >>> is_happy.call(""abcd"")
# true
# >>> is_happy.call(""aabb"")
# false
# >>> is_happy.call(""adb"")
# true
# >>> is_happy.call(""xyy"")
# false
def is_happy(s)
","def is_happy(s)
  return false if s.length < 3
  
  (0..s.length - 3).each do |i|
    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]
  end
  
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_happy
    candidate = method(:is_happy)
    assert_equal(false, candidate.call(""a""))
    assert_equal(false, candidate.call(""aa""))
    assert_equal(true, candidate.call(""abcd""))
    assert_equal(false, candidate.call(""aabb""))
    assert_equal(true, candidate.call(""adb""))
    assert_equal(false, candidate.call(""xyy""))
    assert_equal(true, candidate.call(""iopaxpoi""))
    assert_equal(false, candidate.call(""iopaxioi""))
  end
end
"
HumanEval_81,bjn_Arab,rb,"چونتوه:0.0 اي > 0.0 دي- > 0.7 D > 1.0 دي+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 B- > 2.7 B > 3.0 B+ > 3.3 A- > 3.7 A ٤.٠ ا+ GPA. ݢريد ڤرتاڽاءن.سابوتيڠ فانسي نڠ کاوا ماولاه سابوءه ارري دري ڬريد حروف مڠݢونااكن تابل نڠ ديتوليس: سيدين باڬيتو سابوءه ڤارادبن ڬرجا باءيق باڬي باباراڤا ڤلاجر وان تو هاروس باچاءنسابوتيڠ ڤرلمباݢاان اداله, سيدين ماڽالاه كود ناڠ سيدين ڬونااكان ݢاسان ماڠاراسي.ڤارا ڤارا ڬورو ماوله الڬوريتم ڤرمايسوريڽا اونتوق ماولاه ڬوريتم.ڽو اداله اوڤت اخير سمستير وان ڤارا ڤارا ڬورو هاروس ممبريكن ڬراد # >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])
# [""A+"", ""B"", ""C-"", ""C"", ""A-""]
def numerical_letter_grade(grades)
","def numerical_letter_grade(grades)
  grades.map do |gpa|
    case 
    when gpa == 4.0
      ""A+""
    when gpa > 3.7
      ""A""
    when gpa > 3.3
      ""A-""
    when gpa > 3.0
      ""B+""
    when gpa > 2.7
      ""B""
    when gpa > 2.3
      ""B-""
    when gpa > 2.0
      ""C+""
    when gpa > 1.7
      ""C""
    when gpa > 1.3
      ""C-""
    when gpa > 1.0
      ""D+""
    when gpa > 0.7
      ""D""
    when gpa > 0.0
      ""D-""
    else
      ""E""
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_numerical_letter_grade
    candidate = method(:numerical_letter_grade)
    assert_equal([""A+"", ""B"", ""C-"", ""C"", ""A-""], candidate.call([4.0, 3, 1.7, 2, 3.5]))
    assert_equal([""D+""], candidate.call([1.2]))
    assert_equal([""D-""], candidate.call([0.5]))
    assert_equal([""E""], candidate.call([0.0]))
    assert_equal([""D"", ""D-"", ""C-"", ""B"", ""B+""], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))
    assert_equal([""E"", ""D-""], candidate.call([0.0, 0.7]))
  end
end
"
HumanEval_82,bjn_Arab,rb,"چونتوه length اداله سابوتيڠ نومبور ڤرم اتاو كادا منوليس فانکشن نڠ مڠمبيل ساءينت وان مروڤاكن تريت سچارا سچارا تيدق # >>> prime_length.call(""Hello"")
# true
# >>> prime_length.call(""abcdcba"")
# true
# >>> prime_length.call(""kittens"")
# true
# >>> prime_length.call(""orange"")
# false
def prime_length(string)
","def prime_length(string)
  length = string.length
  return false if length < 2

  (2..Math.sqrt(length)).each do |i|
    return false if length % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_length
    candidate = method(:prime_length)
    assert_equal(true, candidate.call(""Hello""))
    assert_equal(true, candidate.call(""abcdcba""))
    assert_equal(true, candidate.call(""kittens""))
    assert_equal(false, candidate.call(""orange""))
    assert_equal(true, candidate.call(""wow""))
    assert_equal(true, candidate.call(""world""))
    assert_equal(true, candidate.call(""MadaM""))
    assert_equal(true, candidate.call(""Wow""))
    assert_equal(false, candidate.call(""""))
    assert_equal(true, candidate.call(""HI""))
    assert_equal(true, candidate.call(""go""))
    assert_equal(false, candidate.call(""gogo""))
    assert_equal(false, candidate.call(""aaaaaaaaaaaaaaa""))
    assert_equal(true, candidate.call(""Madam""))
    assert_equal(false, candidate.call(""M""))
    assert_equal(false, candidate.call(""0""))
  end
end
"
HumanEval_83,bjn_Arab,rb,"bilangan bulat positif nang dimulai atawa berakhir lawan 1. ديتاهوءاكن سابوءه اينتڬري ڤوسيتيف n، ماولاه ڤندكتن ارق n-انجير def starts_one_ends(n)
","def starts_one_ends(n)
  return 0 if n <= 0

  # Count numbers starting with 1
  start_with_1 = 9 ** (n - 1)

  # Count numbers ending with 1
  end_with_1 = 9 ** (n - 1)

  # Adjust for double counting the number that both starts and ends with 1
  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1
  
  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_starts_one_ends
    candidate = method(:starts_one_ends)
    assert_equal(1, candidate.call(1))
    assert_equal(18, candidate.call(2))
    assert_equal(180, candidate.call(3))
    assert_equal(1800, candidate.call(4))
    assert_equal(18000, candidate.call(5))
  end
end
"
HumanEval_84,bjn_Arab,rb,"چونتوه ديبارياكن سابوتيڠ انتيڬره ڤوسيتيف N، ماولاه سومبڠن ساريڠ دالم ديڬيتڽ دالم بينيار. # >>> solve.call(1000)
# ""1""
# >>> solve.call(150)
# ""110""
# >>> solve.call(147)
# ""1100""
# Variables:
# @N integer
# Constraints: 0 ≤ N ≤ 10000.
# Output:
# a string of binary number
def solve(n)
","def solve(n)
  sum_of_digits = n.to_s.chars.map(&:to_i).sum
  sum_of_digits.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""1"", candidate.call(1000))
    assert_equal(""110"", candidate.call(150))
    assert_equal(""1100"", candidate.call(147))
    assert_equal(""1001"", candidate.call(333))
    assert_equal(""10010"", candidate.call(963))
  end
end
"
HumanEval_85,bjn_Arab,rb,"چونتوه:ديسه سابوتيڠ ارري نان-ڤاكي انتيڬي لست. جومله ايليمن ڤرڤوستاكن نڠ كادا ڤرڤوستاكن..# >>> add.call([4, 2, 6, 7])
# 2
def add(lst)
","def add(lst)
  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(88, candidate.call([4, 88]))
    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))
    assert_equal(0, candidate.call([4, 0, 6, 7]))
    assert_equal(12, candidate.call([4, 4, 6, 8]))
  end
end
"
HumanEval_86,bjn_Arab,rb,"چونتوهڽ: يادداشت: شما بايد ترتيب کلمات و فضاها را در جمله حفظ کنيد.ڤرتمڤورن ڤرڤادوان ڤرڤادوان ڤرڤادوان ڤرڤادوانديڤاراكاكن اوليه سابوءه كات بارو نڠ مان سموا كاراكتر دتربيتاكن د ڤرسيون سورت سورت، اداله سورت د مان سموا كات (ديباݢايكن لاون سڤيس) منوليس فانکشن نڠ مڠمبيل ساءنجور وان مڽارولوي ۏرسي نڠ دأوردرڽ.# >>> anti_shuffle.call(""Hi"")
# ""Hi""
# >>> anti_shuffle.call(""hello"")
# ""ehllo""
# >>> anti_shuffle.call(""Hello World!!!"")
# ""Hello !!!Wdlor""
def anti_shuffle(s)
","def anti_shuffle(s)
  s.split(/(\s+)/).map { |word| word.chars.sort.join }.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_anti_shuffle
    candidate = method(:anti_shuffle)
    assert_equal(""Hi"", candidate.call(""Hi""))
    assert_equal(""ehllo"", candidate.call(""hello""))
    assert_equal(""bemnru"", candidate.call(""number""))
    assert_equal(""abcd"", candidate.call(""abcd""))
    assert_equal(""Hello !!!Wdlor"", candidate.call(""Hello World!!!""))
    assert_equal("""", candidate.call(""""))
    assert_equal("".Hi My aemn is Meirst .Rboot How aer ?ouy"", candidate.call(""Hi. My name is Mister Robot. How are you?""))
  end
end
"
HumanEval_87,bjn_Arab,rb,"چونتوه:جوا, مامبيداكن كؤؤؤردينات رنچان لاوان كولوم ڤاس اوردين نانݢ مانݢݢال.مڠݢابوڠكن كؤؤؤردينات ڤاس اولڽ لاوان رنچان دالم اوردين نانݢ مڠݢابوڠ.ستياڤ ارري اداله كؤوردينات - (ڤاڠكال، كولوم) ، مولاي دڠن 0.وان مڽارولاكن ارري ارري، [(x1، y1) ، (x2، y2) ...] ساكيت ديسليتيڠ lst، وان اينتيڬر x، مانونجوكاكن اينتيڬر x دالم ارري، ستياڤ رنچان موڠكين بايسي باڽق ݢوروس.نڠ سام لاون ماتريكس، تاڤي، كادا لاون ماتريكس، اكو دبري داده ٢ دييمينسيونل، ساباڬاي ارسي نست، # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
# >>> get_row.call([], 1)
# []
# >>> get_row.call([[], [1], [1, 2, 3]], 3)
# [[2, 2]]
def get_row(lst, x)
","def get_row(lst, x)
  result = []

  lst.each_with_index do |row, i|
    row.each_with_index do |value, j|
      result << [i, j] if value == x
    end
  end

  result.sort_by { |coord| [coord[0], -coord[1]] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_row
    candidate = method(:get_row)
    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))
    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([], candidate.call([], 1))
    assert_equal([], candidate.call([[1]], 2))
    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))
  end
end
"
HumanEval_88,bjn_Arab,rb,"چونتوه:* تيدق مڠوبه ارري يڠ دبري. يادداشت:اتاوا مڽارڠڽ دالم اورد نڠ مڽرتاي جادي سومتأنڽ (نڠ ڤرتام باهن ايندكس، نڠ اخير باهن ايندكس) اداله جادي.اكو اكن مڠورڠكن ارري دالم اوردين مڠورڠكن اڤابيلا سوم ((تاهون ايندكس ڤرتام، تاهون ايندكس اخير)) اداله ڤرڬي، ديباريليان سابوتيڠ ارري داري انتيݢىر نانݢاتيف, مامباريليان سابوتيڠ كورب داري ارري نانݢ ديباريليان ستله ڤانݢݢال, # >>> sort_array.call([])
# []
# >>> sort_array.call([5])
# [5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5])
# [0, 1, 2, 3, 4, 5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])
# [6, 5, 4, 3, 2, 1, 0]
def sort_array(array)
","def sort_array(array)
  return array if array.empty? || array.size == 1

  if (array.first + array.last).odd?
    array.sort
  else
    array.sort.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([], candidate.call([]))
    assert_equal([5], candidate.call([5]))
    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))
    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))
    assert_equal([1, 2], candidate.call([2, 1]))
    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))
    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))
  end
end
"
HumanEval_89,bjn_Arab,rb,"چونتوهڽ: ڤرݢيݢانان ڤاساݢين ڤاساݢين ڤاساݢين ڤاساݢين ڤاساݢين ڤاساݢين.ابجد هاروس ديباݢايكن دالم بنتوق نڠ مان حروف مروڤاكن ستريڠ نڠ دڤرچيتق دڠن ابجد دڤرچيتق.ماولايكن كادأن انچريڤت يڠ مڠاخيري ستريڠ سباڬاي ارڬومنت وان # >>> encrypt.call(""hi"")
# ""lm""
# >>> encrypt.call(""asdfghjkl"")
# ""ewhjklnop""
# >>> encrypt.call(""gf"")
# ""kj""
# >>> encrypt.call(""et"")
# ""ix""
def encrypt(s)
","def encrypt(s)
  s.chars.map do |char|
    if char =~ /[a-z]/
      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr
    elsif char =~ /[A-Z]/
      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr
    else
      char
    end
  end.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encrypt
    candidate = method(:encrypt)
    assert_equal(""lm"", candidate.call(""hi""))
    assert_equal(""ewhjklnop"", candidate.call(""asdfghjkl""))
    assert_equal(""kj"", candidate.call(""gf""))
    assert_equal(""ix"", candidate.call(""et""))
    assert_equal(""jeiajeaijeiak"", candidate.call(""faewfawefaewg""))
    assert_equal(""lippsqcjvmirh"", candidate.call(""hellomyfriend""))
    assert_equal(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"", candidate.call(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""))
    assert_equal(""e"", candidate.call(""a""))
  end
end
"
HumanEval_90,bjn_Arab,rb,"مڠرجاكن nil اڤابيلا اد ايليمن نڠ كادا.منوليس فانسي next_smallest (() نڠ مروڤاكن ايليمن كدوا نڠ كادڠ-كادڠ دري ارري. اكو دبري سابوءه ارري انتيڬري.# >>> next_smallest.call([1, 2, 3, 4, 5])
# 2
# >>> next_smallest.call([5, 1, 4, 3, 2])
# 2
# >>> next_smallest.call([])
# nil
# >>> next_smallest.call([1, 1])
# nil
def next_smallest(lst)
","def next_smallest(lst)
  unique_sorted = lst.uniq.sort
  unique_sorted.length >= 2 ? unique_sorted[1] : nil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_next_smallest
    candidate = method(:next_smallest)
    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))
    assert_equal(nil, candidate.call([]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(-35, candidate.call([-35, 34, 12, -45]))
  end
end
"
HumanEval_91,bjn_Arab,rb,"چونتوهڽ: ڤانݢݢكاهان ديݢارݢاكان لاوان '.', '?' اتاوا '!'.. ""بورو"" اداله ساتو ڤرتاڽان نڠ برمولا دڠن كات ""اي"".اكو اكن دبري ساءينج كلمات، وان كار اكو اداله باڽقكن ݢاريسڽ# >>> is_bored.call(""Hello world"")
# 0
# >>> is_bored.call(""The sky is blue. The sun is shining. I love this weather"")
# 1
def is_bored(s)
","def is_bored(s)
  sentences = s.split(/(?<=[.?!])/)
  sentences.count { |sentence| sentence.strip.start_with?('I') }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_bored
    candidate = method(:is_bored)
    assert_equal(0, candidate.call(""Hello world""))
    assert_equal(0, candidate.call(""Is the sky blue?""))
    assert_equal(1, candidate.call(""I love It !""))
    assert_equal(0, candidate.call(""bIt""))
    assert_equal(2, candidate.call(""I feel good today. I will be productive. will kill It""))
    assert_equal(0, candidate.call(""You and I are going for a walk""))
  end
end
"
HumanEval_92,bjn_Arab,rb,"چونتوه مروڤاكن كسالهن دالم حال-حال لاين.مڽاتاكن كاءجاوي سچارا سچارا سچارا اڤابيلا سابوءه ڤاراكيت اداله سام دڠن سومبڠن دوا ڤاراكيت لاين، وان سموا ڤاراكيت اداله اينتڬري.مڠمبيل فڠسي نڠ مڠمبيل 3 ارق.# >>> any_int.call(5, 2, 7)
# true
# >>> any_int.call(3, 2, 2)
# false
# >>> any_int.call(3, -2, 1)
# true
# >>> any_int.call(3.6, -2.2, 2)
# false
def any_int(x, y, z)
","def any_int(x, y, z)
  if [x, y, z].all? { |n| n.is_a?(Integer) }
    x == y + z || y == x + z || z == x + y
  else
    false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_any_int
    candidate = method(:any_int)
    assert_equal(true, candidate.call(2, 3, 1))
    assert_equal(false, candidate.call(2.5, 2, 3))
    assert_equal(false, candidate.call(1.5, 5, 3.5))
    assert_equal(false, candidate.call(2, 6, 2))
    assert_equal(true, candidate.call(4, 2, 2))
    assert_equal(false, candidate.call(2.2, 2.2, 2.2))
    assert_equal(true, candidate.call(-4, 6, 2))
    assert_equal(true, candidate.call(2, 1, 1))
    assert_equal(true, candidate.call(3, 4, 7))
    assert_equal(false, candidate.call(3.0, 4, 7))
  end
end
"
HumanEval_93,bjn_Arab,rb,"چونتوه:مڠادڤاكن هاڽ حروف.ݢاريس ڤرݢونأن دالم ابجد بهاس ايڠݢريس.ڤاچوان دڠن حروف نڠ مان مانونجوك ٢ ڤوست ڤد ڤاس جادي ڤاڤنڽ مڠمبيل كاسوس دري سموا حروف، مڠمبيل سموا ۏوكل د منوليس فانسي نڠ مڠمبيل باريسن، وان مڠكوداكن # >>> encode.call(""test"")
# ""TGST""
# >>> encode.call(""This is a message"")
# ""tHKS KS C MGSSCGG""
def encode(message)
","def encode(message)
  vowels = 'aeiou'
  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}
  
  encoded_message = message.chars.map do |char|
    if vowels.include?(char.downcase)
      new_char = swap_vowels[char.downcase]
      char == char.upcase ? new_char.upcase : new_char.downcase
    else
      char == char.upcase ? char.downcase : char.upcase
    end
  end

  encoded_message.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encode
    candidate = method(:encode)
    assert_equal(""tgst"", candidate.call(""TEST""))
    assert_equal(""mWDCSKR"", candidate.call(""Mudasir""))
    assert_equal(""ygs"", candidate.call(""YES""))
    assert_equal(""tHKS KS C MGSSCGG"", candidate.call(""This is a message""))
    assert_equal(""k dQnT kNqW wHcT Tq wRkTg"", candidate.call(""I DoNt KnOw WhAt tO WrItE""))
  end
end
"
HumanEval_94,bjn_Arab,rb,"چونتوه:اكو ڤرلو مميليه ڤارڠ ڤرتام ڤاليڠ بسر وان مروڤاكن سومبر ديڬيتڽ.اكو دبري سابوءه ارري انتيڬري.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
# 10
# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
# 25
# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
# 13
# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
# 11
# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])
# 3
# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])
# 7
def skjkasdkd(lst)
","def skjkasdkd(lst)
  require 'prime'

  # Find the largest prime number in the array
  largest_prime = lst.select { |num| Prime.prime?(num) }.max
  
  # Return 0 if no prime number is found
  return 0 if largest_prime.nil?

  # Calculate the sum of digits of the largest prime number
  largest_prime.to_s.chars.map(&:to_i).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_skjkasdkd
    candidate = method(:skjkasdkd)
    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))
    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))
    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))
    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))
    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))
    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))
    assert_equal(19, candidate.call([8191]))
    assert_equal(19, candidate.call([8191, 123456, 127, 7]))
    assert_equal(10, candidate.call([127, 97, 8192]))
  end
end
"
HumanEval_95,bjn_Arab,rb,"چونتوه:فانسي ڤرلو مڠرجاكن تاهڤ كسالهن اڤابيلا هاس دبريكن باهن.جادي كاسيس اتاو سموا كاسيس اداله ستريڠ دالم كاسيس اوتام، اڤاڽ جادي كسالهن.ديتاهن سابوءه هاش، ماولاهن ڤرچاي جادي كادا سموا كليدا اداله ساءنجور دالم # >>> check_dict_case.call({""a"" => ""apple"", ""b"" => ""banana""})
# true
# >>> check_dict_case.call({""a"" => ""apple"", ""A"" => ""banana"", ""B"" => ""banana""})
# false
# >>> check_dict_case.call({""a"" => ""apple"", 8 => ""banana"", ""a"" => ""apple""})
# false
# >>> check_dict_case.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""})
# false
# >>> check_dict_case.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""})
# true
def check_dict_case(dict)
","def check_dict_case(dict)
  return false if dict.empty?

  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }
  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }

  lowercase_keys || uppercase_keys
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_dict_case
    candidate = method(:check_dict_case)
    assert_equal(true, candidate.call({""p"" => ""pineapple"", ""b"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""A"" => ""banana"", ""B"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""5"" => ""banana"", ""a"" => ""apple""}))
    assert_equal(false, candidate.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""}))
    assert_equal(true, candidate.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""}))
    assert_equal(true, candidate.call({""fruit"" => ""Orange"", ""taste"" => ""Sweet""}))
    assert_equal(false, candidate.call({}))
  end
end
"
HumanEval_96,bjn_Arab,rb,"چونتوهڽ: integer-an nang adalah bilangan prima wan kurang dari n. مڠيكوت فانسي نڠ مڠاخيري انتيڬر نڠ كادا نڬاتيف وان مروڤاكن ارري نڠ ڤرتام n # >>> count_up_to.call(5)
# [2, 3]
# >>> count_up_to.call(11)
# [2, 3, 5, 7]
# >>> count_up_to.call(0)
# []
# >>> count_up_to.call(20)
# [2, 3, 5, 7, 11, 13, 17, 19]
# >>> count_up_to.call(1)
# []
# >>> count_up_to.call(18)
# [2, 3, 5, 7, 11, 13, 17]
def count_up_to(n)
","def count_up_to(n)
  return [] if n <= 2
  primes = []
  (2...n).each do |num|
    is_prime = true
    (2..Math.sqrt(num)).each do |i|
      if num % i == 0
        is_prime = false
        break
      end
    end
    primes << num if is_prime
  end
  primes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_up_to
    candidate = method(:count_up_to)
    assert_equal([2, 3], candidate.call(5))
    assert_equal([2, 3, 5], candidate.call(6))
    assert_equal([2, 3, 5], candidate.call(7))
    assert_equal([2, 3, 5, 7], candidate.call(10))
    assert_equal([], candidate.call(0))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))
    assert_equal([], candidate.call(1))
    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))
  end
end
"
HumanEval_97,bjn_Arab,rb,"چونتوه:مڠهارڤكن انترس هاڽ سداڠ باءيق.ڤرباتاس ارقام اونيتڽ۔مڽمڤايكن فڠسي يڠ مڠڬوناكن دوا انتيڬر وان مروڤاكن # >>> multiply.call(148, 412)
# 16
# >>> multiply.call(19, 28)
# 72
# >>> multiply.call(2020, 1851)
# 0
# >>> multiply.call(14, -15)
# 20
def multiply(a, b)
","def multiply(a, b)
  a_unit_digit = a.abs % 10
  b_unit_digit = b.abs % 10
  a_unit_digit * b_unit_digit
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_multiply
    candidate = method(:multiply)
    assert_equal(16, candidate.call(148, 412))
    assert_equal(72, candidate.call(19, 28))
    assert_equal(0, candidate.call(2020, 1851))
    assert_equal(20, candidate.call(14, -15))
    assert_equal(42, candidate.call(76, 67))
    assert_equal(49, candidate.call(17, 27))
    assert_equal(0, candidate.call(0, 1))
    assert_equal(0, candidate.call(0, 0))
  end
end
"
HumanEval_98,bjn_Arab,rb,"چونتوهڽ: ديتاهن ساءينت s، مڠحساباكن كاءدأن ڤوکل ڤرتاڤر دالم اينديكس ڤرتاڤر. # >>> count_upper.call(""aBCdEf"")
# 1
# >>> count_upper.call(""abcdefg"")
# 0
# >>> count_upper.call(""dBBE"")
# 0
def count_upper(s)
","def count_upper(s)
  vowels = ['A', 'E', 'I', 'O', 'U']
  count = 0

  s.chars.each_with_index do |char, index|
    if index.even? && vowels.include?(char)
      count += 1
    end
  end

  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_upper
    candidate = method(:count_upper)
    assert_equal(1, candidate.call(""aBCdEf""))
    assert_equal(0, candidate.call(""abcdefg""))
    assert_equal(0, candidate.call(""dBBE""))
    assert_equal(0, candidate.call(""B""))
    assert_equal(1, candidate.call(""U""))
    assert_equal(0, candidate.call(""""))
    assert_equal(2, candidate.call(""EEEE""))
  end
end
"
HumanEval_99,bjn_Arab,rb,"چونتوه دري دوا انتيڬري، ڤوليهڽ دري صفر.وان مروڤاكن انتيڬري نڠ كادا باڬيڽ. اڤابيلا نومبورڽ باڬايماناڤونمڽاتاكن فڠسي يڠ مڠاخيري ڤاريسن (سترن) نڠ مروڤاكن ساتو نومبور # >>> closest_integer.call(""10"")
# 10
# >>> closest_integer.call(""15.3"")
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer(""14.5"") should
# return 15 and closest_integer(""-14.5"") should return -15.
def closest_integer(value)
","def closest_integer(value)
  number = value.to_f
  if number > 0
    (number + 0.5).floor
  else
    (number - 0.5).ceil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_closest_integer
    candidate = method(:closest_integer)
    assert_equal(10, candidate.call(""10""))
    assert_equal(15, candidate.call(""14.5""))
    assert_equal(-16, candidate.call(""-15.5""))
    assert_equal(15, candidate.call(""15.3""))
    assert_equal(0, candidate.call(""0""))
  end
end
"
HumanEval_100,bjn_Arab,rb,"چونتوه:i مانامڤيلكن جومله باتو دالم ليۏيل (i+1).مڽاتاكن ڤڠهادڤن بندا د ستياڤ ليۏل دالم سابوءه ارري، دمان ايليمن د ايندكس - ارقام زوج بعديا وان n جادي عدد زوج. - رقم عادي الجار اذا n عادي. جومله باتو دالم تالينڽ اداله: ڤرتام ناءيك بايسي n باتو.ديسهاراكن سابوءه انتيڬره ڤوسيتيف ن، اندي ڤرلو ماوله سابوءه ڤاسير ن نيتيسن باڬين باهن۔# >>> make_a_pile.call(3)
# [3, 5, 7]
def make_a_pile(n)
","def make_a_pile(n)
  result = []
  current_stones = n
  n.times do
    result << current_stones
    current_stones += 2
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_a_pile
    candidate = method(:make_a_pile)
    assert_equal([3, 5, 7], candidate.call(3))
    assert_equal([4, 6, 8, 10], candidate.call(4))
    assert_equal([5, 7, 9, 11, 13], candidate.call(5))
    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))
    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))
  end
end
"
HumanEval_101,bjn_Arab,rb,"چونتوهڽ: ڬسن ممباڬي ساءنجت كاءاتاءن وان مروڤاكن سابوءه ارري كاءاتاءن.اكو اكن دبري ساءينج كلمات ديبداكن اوليه كوما اتاو سڤيسيس. كاوسن اكو اداله# >>> words_string.call(""Hi, my name is John"")
# [""Hi"", ""my"", ""name"", ""is"", ""John""]
# >>> words_string.call(""One, two, three, four, five, six"")
# [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
def words_string(s)
","def words_string(s)
  s.split(/[\s,]+/)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_string
    candidate = method(:words_string)
    assert_equal([""Hi"", ""my"", ""name"", ""is"", ""John""], candidate.call(""Hi, my name is John""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One, two, three, four, five, six""))
    assert_equal([""Hi"", ""my"", ""name""], candidate.call(""Hi, my name""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One,, two, three, four, five, six,""))
    assert_equal([], candidate.call(""""))
    assert_equal([""ahmed"", ""gamal""], candidate.call(""ahmed     , gamal""))
  end
end
"
HumanEval_102,bjn_Arab,rb,"چونتوهڽ: جادي كادا اد نومبور نڠ كاي، جادي فڠسي ڤرلو مروڤاكن -1.ڤاراكت انجيري ڤاليڠ بسر نڠ اد دالم رنچان [x، y] تامسوك. جادي فانسي ڠيني مڠمبيل دوا نومبور ڤوسيتيف x وان y وان مڽارولاكن # >>> choose_num.call(12, 15)
# 14
# >>> choose_num.call(13, 12)
# -1
def choose_num(x, y)
","def choose_num(x, y)
  return -1 if x > y
  # Start looking from the largest number
  max_even = y.even? ? y : y - 1
  # Iterate downwards to find the biggest even number
  max_even.downto(x) do |n|
    return n if n.even?
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_choose_num
    candidate = method(:choose_num)
    assert_equal(14, candidate.call(12, 15))
    assert_equal(-1, candidate.call(13, 12))
    assert_equal(12354, candidate.call(33, 12354))
    assert_equal(-1, candidate.call(5234, 5233))
    assert_equal(28, candidate.call(6, 29))
    assert_equal(-1, candidate.call(27, 10))
    assert_equal(-1, candidate.call(7, 7))
    assert_equal(546, candidate.call(546, 546))
  end
end
"
HumanEval_103,bjn_Arab,rb,"چونتوه:اڤابيلا n لابه دري m، جادي -1.ڤولاو ڤينڠ ڤد جواب كڤد انتيڬر نڠ كادا ڤاليڠ كاي وان مڠاجرڽ ك باينري.اوسطا انتيڬري دري ن سمڤاي م (مماسوك ن وان م).اكو دبري دوا عدد ساري ڤوسيتيف n وان m، وان كارياكو اداله باڤيسهكن # >>> rounded_avg.call(1, 5)
# ""0b11""
# >>> rounded_avg.call(7, 5)
# -1
# >>> rounded_avg.call(10, 20)
# ""0b1111""
# >>> rounded_avg.call(20, 33)
# ""0b11010""
def rounded_avg(n, m)
","def rounded_avg(n, m)
  return -1 if n > m

  sum = (n..m).reduce(:+)
  count = m - n + 1
  average = (sum.to_f / count).round
  ""0b"" + average.to_i.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rounded_avg
    candidate = method(:rounded_avg)
    assert_equal(""0b11"", candidate.call(1, 5))
    assert_equal(""0b1010"", candidate.call(7, 13))
    assert_equal(""0b1111001010"", candidate.call(964, 977))
    assert_equal(""0b1111100100"", candidate.call(996, 997))
    assert_equal(""0b1011000010"", candidate.call(560, 851))
    assert_equal(""0b101101110"", candidate.call(185, 546))
    assert_equal(""0b110101101"", candidate.call(362, 496))
    assert_equal(""0b1001110010"", candidate.call(350, 902))
    assert_equal(""0b11010111"", candidate.call(197, 233))
    assert_equal(-1, candidate.call(7, 5))
    assert_equal(-1, candidate.call(5, 1))
    assert_equal(""0b101"", candidate.call(5, 5))
  end
end
"
HumanEval_104,bjn_Arab,rb,"چونتوهڽ: يادداشت: ارري برگشتي بايد به ترتيب افزايش ترتيب داده شود.عنصري نڠ كادا بايسي اڤاڤا هيدوڤن جوا.ديتاهوءاكن سابوءه ارري انتيڬري ڤوسيتيف x. ماولاه سابوءه ارري ڤارنتاي ساجومله # >>> unique_digits.call([15, 33, 1422, 1])
# [1, 15, 33]
# >>> unique_digits.call([152, 323, 1422, 10])
# []
def unique_digits(x)
","def unique_digits(x)
  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique_digits
    candidate = method(:unique_digits)
    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))
    assert_equal([], candidate.call([152, 323, 1422, 10]))
    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))
    assert_equal([31, 135], candidate.call([135, 103, 31]))
  end
end
"
HumanEval_105,bjn_Arab,rb,"چونتوهڽ: ""واحد""، ""دوا""، ""ثلاثة""، ""أربعة""، ""خمسة""، ""ستة""، ""سبعة""، ""ثمانية""، ""تسعة"".مڠوروساكن ارري نڠ مانولاي، وان لالو ماڠاجوكن ستياڤ ديڬيت دڠن نام نڠ ماننتو دري ديتاري سابوءه ارري انتيجر، مڠهارڤكن ارري انتيجر نڠ انتارا ١ وان ٩ تامسوك، # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])
# [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
# If the array is empty, return an empty array:
# >>> by_length.call([])
# []
# If the array has any strange number ignore it:
# >>> by_length.call([1, -1, 55])
# [""One""]
def by_length(arr)
","def by_length(arr)
  number_names = {
    1 => ""One"",
    2 => ""Two"",
    3 => ""Three"",
    4 => ""Four"",
    5 => ""Five"",
    6 => ""Six"",
    7 => ""Seven"",
    8 => ""Eight"",
    9 => ""Nine""
  }

  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse
  filtered_sorted_reversed.map { |num| number_names[num] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_by_length
    candidate = method(:by_length)
    assert_equal([""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([""One""], candidate.call([1, -1, 55]))
    assert_equal([""Three"", ""Two"", ""One""], candidate.call([1, -1, 3, 2]))
    assert_equal([""Nine"", ""Eight"", ""Four""], candidate.call([9, 4, 8]))
  end
end
"
HumanEval_106,bjn_Arab,rb,"چونتوه:فاكتوريل i اداله ڤرباتاسن ارقام دري ١ سمڤأي i (1 * 2 * ... * i).i مولا دري ١.اتاوا سومبڠن ارقام دري ١ سمڤأي i.وان مڽاتاكن سابوءه ارري دري سيسي n، سهيڠڬ ڤاليڠ باڽق ايليمن د ايندكس i اداله فاكتوريل i اڤابيلا i اداله ڤرنه مڠمبيل فانسي f نڠ مڠاخيري n ساباڬاي ڤاراميتر، # >>> f.call(5)
# [1, 2, 6, 24, 15]
def f(n)
","def f(n)
  (1..n).map do |i|
    if i.even?
      (1..i).inject(:*) || 1
    else
      (1..i).inject(:+)
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_f
    candidate = method(:f)
    assert_equal([1, 2, 6, 24, 15], candidate.call(5))
    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))
    assert_equal([1], candidate.call(1))
    assert_equal([1, 2, 6], candidate.call(3))
  end
end
"
HumanEval_107,bjn_Arab,rb,"چونتوه 1:palindrom integer نڠ دالم rentang ((1، n) ، تاماسوقڽ. ديتاريڤاكن سابوءه اينتيڬر ڤوسيتيف n، مڽارڠ سابوءه ارري نڠ باءيسي نومبور ڤرڤادوان وان ڤرڤادوان # >>> even_odd_palindrome.call(3)
# [1, 2]
# Explanation:
# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome.call(12)
# [4, 6]
# Explanation:
# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
# 1. 1 <= n <= 10^3
# 2. returned array has the number of even and odd integer palindromes respectively.
def even_odd_palindrome(n)
","def even_odd_palindrome(n)
  even_count = 0
  odd_count = 0

  (1..n).each do |num|
    if num.to_s == num.to_s.reverse
      if num.even?
        even_count += 1
      else
        odd_count += 1
      end
    end
  end

  [even_count, odd_count]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_palindrome
    candidate = method(:even_odd_palindrome)
    assert_equal([8, 13], candidate.call(123))
    assert_equal([4, 6], candidate.call(12))
    assert_equal([1, 2], candidate.call(3))
    assert_equal([6, 8], candidate.call(63))
    assert_equal([5, 6], candidate.call(25))
    assert_equal([4, 6], candidate.call(19))
    assert_equal([4, 5], candidate.call(9))
    assert_equal([0, 1], candidate.call(1))
  end
end
"
HumanEval_108,bjn_Arab,rb,"چونتوهڽ، -123 بايسي تاتاتاتات -1, 2, وان 3.اڤابيلا سابوءه نومبور اداله نݢاتيف، لالو ديݢيت ڤرتامڽ نڠ دتوليس اكن نݢاتيف: jumlah elemen nang jumlah digitnya > 0. منوليس فانسي count_nums نڠ مڠاخيري ارري انتيجر وان مڽاراكن # >>> count_nums.call([])
# 0
# >>> count_nums.call([-1, 11, -11])
# 1
# >>> count_nums.call([1, 1, 2])
# 3
def count_nums(arr)
","def count_nums(arr)
  arr.count do |num|
    num.to_s.chars.map(&:to_i).sum > 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_nums
    candidate = method(:count_nums)
    assert_equal(0, candidate.call([]))
    assert_equal(0, candidate.call([-1, -2, 0]))
    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))
    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))
    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))
    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))
    assert_equal(1, candidate.call([0, 1]))
    assert_equal(1, candidate.call([1]))
  end
end
"
HumanEval_109,bjn_Arab,rb,"چونتوهڽ:ڤنوتوڤن: ارري دبريكن دڬارنتيسكن ڬاڤاي ايليمن ڠونيك.اڤابيلا ارري دبريكن كادا باءيق لالو ريترون تيرل. لالو ريڤورت ڤرچاي اتاو ريڤورت ڤرچاي ڤرچاي.اڤاکه موڠکين اونتوق منداڤتکن ارري يڠ دسيورت اوليه ڤرکارا نڠ دتڠݢوڠجواب ڤوسيسي ڤرتام دالم ارري ايايت ايندكس ك-٠.ايليمن اخير ارري اكن دڤرچاياڠاكن ك سابوتيڠ اوڤراسي ڤمباڠونن ك كيمن مانونجوكاكن ڤمباڠونن سابوتيڠ ايليمن ماتاءن ارري اكو باءيسي كاجين ڬاسن ممباوا اوڤراسي ڤمباڠونن ك كاكي سياڤاڤا ڤرلومباڠ.اوڤراسي نڠ مان ݢاسن ڤد ارري نڠ دبري: ݢاسان ماناكالا سابوءه ارري ديباݢاي دالم اورد نانݢ كادا مانيڠݢلؤڠ لالو مانيڠݢلؤڠ نومبور دالم ارري اكن دأرتواكن سچارا رندوم. كاريا كامو اداله ڬاسن ممنتڤكن اڤابيلاكيت اد سابوءه ارري 'ارر' ناءينتڬير ارر، ارر، ارر، ... ارر.# >>> move_one_ball.call([3, 4, 5, 1, 2])
# true
# Explanation: By performin 2 right shift operations, non-decreasing order can
# be achieved for the given array.
# >>> move_one_ball.call([3, 5, 4, 1, 2])
# false
# Explanation:It is not possible to get non-decreasing order for the given
# array by performing any number of right shift operations.
def move_one_ball(arr)
","def move_one_ball(arr)
  return true if arr.empty?

  n = arr.size
  count_rotation_point = 0
  rotation_index = -1

  (0...n).each do |i|
    next_index = (i + 1) % n
    if arr[i] > arr[next_index]
      count_rotation_point += 1
      rotation_index = next_index
    end
  end

  count_rotation_point <= 1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_move_one_ball
    candidate = method(:move_one_ball)
    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))
    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))
    assert_equal(false, candidate.call([4, 3, 1, 2]))
    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))
    assert_equal(true, candidate.call([]))
  end
end
"
HumanEval_110,bjn_Arab,rb,"چونتوهڽ: اڤاکه لاين، ڤوليه ""لا"".سموا ايليمن lst1 جادي جادي، جاديكن ""YES"".اڤاکه موڠکين ڬاسن مڠمبيل ايليمن انتارا lst1 وان lst2 ݢاسن ممبنتواد نڠ كادا ليميت د اتس كاءدأن ايليمن نڠ ديباڠاراكن انتارا lst1 وان lst2.بينڽا ݢاسان ماولاه lst1 سابوتيڠ ارسي نانݢ تاتامو بايسي ارسي ڤرݢي.وان ماننتوكن اڤاکه موڠكين ڬسن ماولاهاكن سابوءه ايليمن دالم مسئله اين، كامو ممڤركنلكن فانسي يڠ ممباوا دوا ارر ارق، # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])
# ""YES""
# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])
# ""NO""
# It is assumed that the input arrays will be non-empty.
def exchange(lst1, lst2)
","def exchange(lst1, lst2)
  # Check if lst1 already consists solely of even numbers
  return ""YES"" if lst1.all?(&:even?)

  # Check if there are at least as many even numbers in lst2
  # as there are odd numbers in lst1
  odd_count_lst1 = lst1.count(&:odd?)
  even_count_lst2 = lst2.count(&:even?)

  odd_count_lst1 <= even_count_lst2 ? ""YES"" : ""NO""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_exchange
    candidate = method(:exchange)
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))
    assert_equal(""NO"", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))
    assert_equal(""YES"", candidate.call([5, 7, 3], [2, 6, 4]))
    assert_equal(""NO"", candidate.call([5, 7, 3], [2, 6, 3]))
    assert_equal(""NO"", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))
    assert_equal(""YES"", candidate.call([100, 200], [200, 200]))
  end
end
"
HumanEval_111,bjn_Arab,rb,"چونتوه:اڤابيلا ببراڤ حروف بايسي ڤرتنديڠن نڠ سام، جاديكن سمواڽ.ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤن ڤاڤنديتاهن سابوتيڠ سترينݢ نڠ ماامڤيليكن سابوءه حروف ڤاسير نڠ ديباڠوناكن سڤيستيس، ماولاه سابوءه هاش # >>> histogram.call(""a b c"")
# {""a"" => 1, ""b"" => 1, ""c"" => 1}
# >>> histogram.call(""a b b a"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""a b c a b"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""b b b b a"")
# {""b"" => 4}
# >>> histogram.call("""")
# {}
def histogram(test)
","def histogram(test)
  return {} if test.empty?

  count = Hash.new(0)

  test.split.each do |char|
    count[char] += 1
  end

  max_count = count.values.max
  count.select { |_, value| value == max_count }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_histogram
    candidate = method(:histogram)
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b b a""))
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b c a b""))
    assert_equal({""a"" => 1, ""b"" => 1, ""c"" => 1, ""d"" => 1, ""g"" => 1}, candidate.call(""a b c d g""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({""b"" => 4}, candidate.call(""b b b b a""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({}, candidate.call(""""))
    assert_equal({""a"" => 1}, candidate.call(""a""))
  end
end
"
HumanEval_112,bjn_Arab,rb,"چونتوه اندا ڤرلو مروڤاكن سابوءه ارري نڠ مان ساءورڠ تار نڠ دأصل وان ڤرلو ڤرچاي سچارا/كسالهن.سابوتيڠ سݢرا ديڠاراكان ڤاليندروم اڤابيلا ديڤارچاي ڤاليندروم نڠ سام كالو ڤاليندروم.لالو مڠيكوت اڤابيلا سيرڠ ريساليتس اداله ڤاليندروم. كيت دبري دوا تار s وان c، اندا ڤرلو مڠحذير سموا كاراكتر دالم s نڠ سام دڠن كاراكتر دالم c ڤاكاي # >>> reverse_delete.call(""abcde"", ""ae"")
# [""bcd"", false]
# >>> reverse_delete.call(""abcdef"", ""b"")
# [""acdef"", false]
# >>> reverse_delete.call(""abcdedcba"", ""ab"")
# [""cdedc"", true]
def reverse_delete(s, c)
","def reverse_delete(s, c)
  # Remove all characters in c from s
  filtered_string = s.delete(c)
  
  # Check if the filtered string is a palindrome
  is_palindrome = filtered_string == filtered_string.reverse
  
  # Return the result array
  [filtered_string, is_palindrome]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_reverse_delete
    candidate = method(:reverse_delete)
    assert_equal([""bcd"", false], candidate.call(""abcde"", ""ae""))
    assert_equal([""acdef"", false], candidate.call(""abcdef"", ""b""))
    assert_equal([""cdedc"", true], candidate.call(""abcdedcba"", ""ab""))
    assert_equal([""dik"", false], candidate.call(""dwik"", ""w""))
    assert_equal(["""", true], candidate.call(""a"", ""a""))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", """"))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", ""v""))
    assert_equal([""abba"", true], candidate.call(""vabba"", ""v""))
    assert_equal(["""", true], candidate.call(""mamma"", ""mia""))
  end
end
"
HumanEval_113,bjn_Arab,rb,"دالم تارين i'th ڤاڤن.string i dari input. "" di mana semua i harus diganti dengan angka ستياڤ ايليمن i ڤد ڤنوليسن ڤرلو جادي ""باڽق ايليمن ڤد ديبارياكن سابوءه ارري داري ساءنجوم، نڠ ستياڤ ساءنجوم باكونسيڤ ديڠان بݢيني ديݢيت، ماولاه سابوءه ارري.# >>> odd_count.call([""1234567""])
# [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
# >>> odd_count.call([""3"", ""11111111""])
# [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
def odd_count(lst)
","def odd_count(lst)
  lst.map do |num_str|
    count = num_str.count('13579')
    ""the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_odd_count
    candidate = method(:odd_count)
    assert_equal([""the number of odd elements 4n the str4ng 4 of the 4nput.""], candidate.call([""1234567""]))
    assert_equal([""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], candidate.call([""3"", ""11111111""]))
    assert_equal([""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""], candidate.call([""271"", ""137"", ""314""]))
  end
end
"
HumanEval_114,bjn_Arab,rb,"چونتوه ڤانݢݢݢان.ديتاري سابوءه ارري انتيݢري نومر، مانونجوكاكن سوم مينيموم سابوءه ارري نانݢ كادا باءيسي ڤاكيت # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])
# 1
# >>> minSubArraySum.call([-1, -2, -3])
# -6
def minSubArraySum(nums)
","def minSubArraySum(nums)
  min_sum = nums[0]
  current_sum = 0
  nums.each do |num|
    if current_sum > 0
      current_sum = num
    else
      current_sum += num
    end
    min_sum = [min_sum, current_sum].min
  end
  min_sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minSubArraySum
    candidate = method(:minSubArraySum)
    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))
    assert_equal(-6, candidate.call([-1, -2, -3]))
    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))
    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))
    assert_equal(0, candidate.call([0, 10, 20, 1000000]))
    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))
    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))
    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))
    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))
    assert_equal(-10, candidate.call([-10]))
    assert_equal(7, candidate.call([7]))
    assert_equal(-1, candidate.call([1, -1]))
  end
end
"
HumanEval_115,bjn_Arab,rb,"چونتوه 1:ماولاهاكان كاداݢيان نانݢ ڤارلو لاوان ڤانݢݢكيت.كاراتان اداله ڬونا باكيتا ڬسن ماڠكوكاكن كاوسن.وان كادا باكيتس ناڠ سام.ستياڤ بوڠا بايسي باكيتر نڠ باسيڠ نڠ داڤت دڤاكاي ڬسن ماولاه اڤ دريڽ، وان ستياڤ ١ دالم سابوءه رنچق ماامڤيلاكن سابوءه اونيت اءير.اكو دبري سابوتيڠ ريتيكانݢولار ڬريد ڤيڠݢڠ. ستياڤ رينڠ ماامڤيليكن سابوتيڠ ڤيڠݢڠ, # >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
# 6
# Example 2:
# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
# 5
# Example 3:
# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)
# 0
# Constraints:
# * all wells have the same length
# * 1 <= grid.length <= 10^2
# * 1 <= grid[:,1].length <= 10^2
# * grid[i][j] -> 0 | 1
# * 1 <= capacity <= 10
def max_fill(grid, capacity)
","def max_fill(grid, capacity)
  total_water_units = grid.flatten.sum
  (total_water_units.to_f / capacity).ceil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_fill
    candidate = method(:max_fill)
    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))
    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))
    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))
    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))
    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))
  end
end
"
HumanEval_116,bjn_Arab,rb,"ڤرلو دڤرلمباݢاكن لاݢي:باݢي باڽق نڠ سام، ڤاريتاسي داسر دري ارق ديسيمل.باڽق وان دالم ڤرڤريسينتاسي بينيارڽ دالم اورد نڠ مڽرتاي.دالم كاتا اين، كامو مميليقي ارري انتيجر نڠ كادا نڬاتيف سڤرتي# >>> sort_array.call([1, 5, 2, 3, 4])
# [1, 2, 3, 4, 5]
# >>> sort_array.call([-2, -3, -4, -5, -6])
# [-6, -5, -4, -3, -2]
# >>> sort_array.call([1, 0, 2, 3, 4])
# [0, 1, 2, 3, 4]
def sort_array(arr)
","def sort_array(arr)
  arr.sort_by { |n| [n.to_s(2).count('1'), n] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))
    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))
    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))
    assert_equal([], candidate.call([]))
    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))
    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
  end
end
"
HumanEval_117,bjn_Arab,rb,"چونتوه:ڤنوتوڤ: اندا موڠکين مڠهارڤکن سݢالا سݢالا string ڤڠاڤرن هاڽ ممباوا حروف دان ڤاسير.اڤابيلا ساءيرڠ s كادا باءيق لالو فانسي ڤرلو مروڤاكن سابوءه ارري باءيق. n كاسوسن، باڬايماناڤون كاتا-كات ڠيني ڤون دتنتڠ دالم ساءين س.سابوتيڠ فانکشن نڠ ماولاه سابوءه ارري دري ساكوءالومڤوك دري ساءينتير s نڠ مان مان مان ڤون ديتاهن ساءينݢ s وان نومبور نݢيتورال n, اندا بوليه مڠيمڤلينيتاسي # >>> select_words.call(""Mary had a little lamb"", 4)
# [""little""]
# >>> select_words.call(""Mary had a little lamb"", 3)
# [""Mary"", ""lamb""]
# >>> select_words.call(""simple white space"", 2)
# []
# >>> select_words.call(""Hello world"", 4)
# [""world""]
# >>> select_words.call(""Uncle sam"", 3)
# [""Uncle""]
def select_words(s, n)
","def select_words(s, n)
  vowels = ""aeiouAEIOU""
  words = s.split
  words.select do |word|
    consonant_count = word.chars.count { |char| !vowels.include?(char) }
    consonant_count == n
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_select_words
    candidate = method(:select_words)
    assert_equal([""little""], candidate.call(""Mary had a little lamb"", 4))
    assert_equal([""Mary"", ""lamb""], candidate.call(""Mary had a little lamb"", 3))
    assert_equal([], candidate.call(""simple white space"", 2))
    assert_equal([""world""], candidate.call(""Hello world"", 4))
    assert_equal([""Uncle""], candidate.call(""Uncle sam"", 3))
    assert_equal([], candidate.call("""", 4))
    assert_equal([""b"", ""c"", ""d"", ""f""], candidate.call(""a b c d e f"", 1))
  end
end
"
HumanEval_118,bjn_Arab,rb,"چونتوه:اندا موڠكين مڠڬڤ بهاوا string نڠ دبري اداله حروف بهاس ايڠڬريس هاڽ.مانونجوكاكن سابوتيڠ ۏوكال ماڤايكن شرط نڠ ديتڠه.ݢاريس ڤرنه دأول وان اخير تيدق دأڠݢڤ. مڽاتاكن سݢالا سݢالا سݢالا سڤرتي ݢاريس ڤرنه دأڠݢڤدوا كؤنسونانت دري ساكيتار كلمهن (كيس سينسيتيف).اكو دبري ساتو كلمهن. كار اكو اداله اونتوق مميليه ۏوكل نڠ ڤاليڠ كاي د انتارا # >>> get_closest_vowel.call(""yogurt"")
# ""u""
# >>> get_closest_vowel.call(""FULL"")
# ""U""
# >>> get_closest_vowel.call(""quick"")
# """"
# >>> get_closest_vowel.call(""ab"")
# """"
def get_closest_vowel(word)
","def get_closest_vowel(word)
  vowels = ""aeiouAEIOU""
  (1...word.length - 1).reverse_each do |i|
    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])
      return word[i]
    end
  end
  return """"
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_closest_vowel
    candidate = method(:get_closest_vowel)
    assert_equal(""u"", candidate.call(""yogurt""))
    assert_equal(""u"", candidate.call(""full""))
    assert_equal("""", candidate.call(""easy""))
    assert_equal("""", candidate.call(""eAsy""))
    assert_equal("""", candidate.call(""ali""))
    assert_equal(""a"", candidate.call(""bad""))
    assert_equal(""o"", candidate.call(""most""))
    assert_equal("""", candidate.call(""ab""))
    assert_equal("""", candidate.call(""ba""))
    assert_equal("""", candidate.call(""quick""))
    assert_equal(""i"", candidate.call(""anime""))
    assert_equal("""", candidate.call(""Asia""))
    assert_equal(""o"", candidate.call(""Above""))
  end
end
"
HumanEval_119,bjn_Arab,rb,"چونتوه:'Yes' را برميگرداند اگر راهي براي ساختن يك رشته خوب وجود داشته باشد، و در غير اينصورت 'No' را برميگرداند."" (()) "" تيدق.ساج: ساج '((((() ' اداله باءيق، ساج سابوتيڠ ساءينݢ S دأڠݢڤ سباݢاي باءيق اڤابيلا وان هاڽ اڤابيلا سموا ڤرنتيس دالم S سابوءه اوردين، ساكيتار نڠ دأصلاكن اكن باءيق.كاراتان اداله ڬاسن ماناكالا موڠكين ڬاسن ماڠاكوتاكن دوا تار دالم ڤانݢݢݢان "" (("" اتوا ڤانݢݢݢان ڤانݢݢݢݢان "")) "" اكو دبري ساتو ارري دري دوا سورت، كدوا سورت ترماسوق اوڤن # >>> match_parens.call([""()("", "")""])
# ""Yes""
# >>> match_parens.call(["")"", "")""])
# ""No""
def match_parens(lst)
","def match_parens(lst)
  a, b = lst

  # Define a helper method to check if a string is balanced
  def balanced?(s)
    count = 0
    s.each_char do |c|
      count += 1 if c == '('
      count -= 1 if c == ')'
      return false if count < 0
    end
    count == 0
  end

  # Check if either concatenation forms a good string
  if balanced?(a + b) || balanced?(b + a)
    ""Yes""
  else
    ""No""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_match_parens
    candidate = method(:match_parens)
    assert_equal(""Yes"", candidate.call([""()("", "")""]))
    assert_equal(""No"", candidate.call(["")"", "")""]))
    assert_equal(""No"", candidate.call([""(()(())"", ""())())""]))
    assert_equal(""Yes"", candidate.call(["")())"", ""(()()(""]))
    assert_equal(""Yes"", candidate.call([""(())))"", ""(()())((""]))
    assert_equal(""No"", candidate.call([""()"", ""())""]))
    assert_equal(""Yes"", candidate.call([""(()("", ""()))()""]))
    assert_equal(""No"", candidate.call([""(((("", ""((())""]))
    assert_equal(""No"", candidate.call(["")(()"", ""(()(""]))
    assert_equal(""No"", candidate.call(["")("", "")(""]))
    assert_equal(""Yes"", candidate.call([""("", "")""]))
    assert_equal(""Yes"", candidate.call(["")"", ""(""]))
  end
end
"
HumanEval_120,bjn_Arab,rb,"چونتوه 1:با طول k با حداكثر k ارقام در arr.ديتاري سابوءه ارري ارن وان انتيڬر ڤوسيتيف k، مڽارڠ سابوءه ارري نانݢ ديسورت # >>> maximum.call([-3, -4, 5], 3)
# [-4, -3, 5]
# Example 2:
# >>> maximum.call([4, -4, 4], 2)
# [4, 4]
# Example 3:
# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)
# [2]
# Note:
# 1. The length of the array will be in the range of [1, 1000].
# 2. The elements in the array will be in the range of [-1000, 1000].
# 3. 0 <= k <= len(arr)
def maximum(arr, k)
","def maximum(arr, k)
  arr.sort.last(k).sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_maximum
    candidate = method(:maximum)
    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))
    assert_equal([4, 4], candidate.call([4, -4, 4], 2))
    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))
    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))
    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))
    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))
    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))
    assert_equal([5], candidate.call([1, 0, 5, -7], 1))
    assert_equal([-4, 4], candidate.call([4, -4], 2))
    assert_equal([-10, 10], candidate.call([-10, 10], 2))
    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))
  end
end
"
HumanEval_121,bjn_Arab,rb,"چونتوه ديكاتاكن سابوءه ارري انتيجر نڠ كادا كادا باءيق، ماولاه سومتارا كسموا ايليمن نڠ كادا باءيق نڠ دالم ڤوسيسي جوت.# >>> solution.call([5, 8, 7, 1])
# 12
# >>> solution.call([3, 3, 3, 3, 3])
# 9
# >>> solution.call([30, 13, 24, 321])
# 0
def solution(lst)
","def solution(lst)
  lst.each_with_index.reduce(0) do |sum, (val, idx)|
    (idx.even? && val.odd?) ? sum + val : sum
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solution
    candidate = method(:solution)
    assert_equal(12, candidate.call([5, 8, 7, 1]))
    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))
    assert_equal(0, candidate.call([30, 13, 24, 321]))
    assert_equal(5, candidate.call([5, 9]))
    assert_equal(0, candidate.call([2, 4, 8]))
    assert_equal(23, candidate.call([30, 13, 23, 32]))
    assert_equal(3, candidate.call([3, 13, 2, 9]))
  end
end
"
HumanEval_122,bjn_Arab,rb,"چونتوه:سومتاء ايليمن نڠ باكيراڽ دوا ديڬيت دري ايليمن k ڤرتام arr.ديبارياكن سابوءه ارري نانݢ كادا باءيسي اينتيݢار ار وان انتيݢار k, ماولاه # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
# 24
# Constraints:
# 1. 1 <= len(arr) <= 100
# 2. 1 <= k <= len(arr)
def add_elements(arr, k)
","def add_elements(arr, k)
  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add_elements
    candidate = method(:add_elements)
    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))
    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))
    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))
    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))
    assert_equal(1, candidate.call([1], 1))
  end
end
"
HumanEval_123,bjn_Arab,rb,"get_odd_collatz(5) مروڤاكن [1, 5] # سيكسيند كوللاتز ڬسن 5 اداله [5, 16, 8, 4, 2, 1], جادي نومبور بيادڤ اداله 1 وان 5 چونتوهڽ: 2. مڽاراكن ارري دالم اورد ڤرتومبوهن نڠ مڽرتاي.1. كوللاتز ((1) اداله [1].يادداشت:istilah ditambah 1. dugaan adalah bahwa kada paduli nilai n, urutan akan selalu mencapai 1. اڤابيلا تيريم ڤرنه اداله كادڠ، تيريم ڤرنه اداله 3 كالي تيريم ڤرنه.istilah termu sebelumnya: jika istilah termu sebelumnya genap, istilah berikutnya adalah satengah dari سيبڬاي اين: مولاكن دڠن سابوءه اينتيڬر ڤوسيتيف n. لالو ستياڤ تيريم دألوڤاكن دري كونچيڤتور كولاتز اداله كونچيڤتور دالم ماتماتيك نڠ مڠهوبوڠاكن سيكويينس نڠ ديفينيسيكن ديبارياكن سابوءه اينتيڬر ڤوسيتيف n، ماولاه سابوءه ارري نانݢ ديسورت نڠ بايسي نومبور بيادڤ دالم سيكويينس كوللاتز. # >>> get_odd_collatz.call(5)
# [1, 5]
def get_odd_collatz(n)
","def get_odd_collatz(n)
  collatz_sequence = []
  while n != 1
    collatz_sequence << n if n.odd?
    if n.even?
      n = n / 2
    else
      n = 3 * n + 1
    end
  end
  collatz_sequence << 1 if n == 1

  collatz_sequence.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_odd_collatz
    candidate = method(:get_odd_collatz)
    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))
    assert_equal([1, 5], candidate.call(5))
    assert_equal([1, 3, 5], candidate.call(12))
    assert_equal([1], candidate.call(1))
  end
end
"
HumanEval_124,bjn_Arab,rb,"4. تاريخ ڤرلو دالم فورتم: م-د-د-ا.ا.ا.3. بولن هاروس كادا كادا كادا كادا كادا ساكيت داري ١ اتاو لابه داري ١٢.2. كاءداءن هاري تيدق كورڠ دري 1 اتاو لبيه دري 31 هاري باݢي بولن 1,3,5,7,8,10,12. دان كاءداءن هاري تيدق كورڠ دري 1 اتاو لبيه دري 30 هاري باݢي بولن 4,6,9,11. دان، كاءداءن هاري تيدق كورڠ دري 1 اتاو لبيه دري 29 باݢي بولن 2.1. تار تاريخ كادا باءيق.تاريخ نڠ بافايه اڤابيلا سموا قاعده-قاعده نڠ مان ݢاسن:مروڤاكن كاءيقينن اڤابيلا تاريخ ساڠت باءيق لاڬي كادا.اكو ڤرلو منوليس فانكسسي نڠ مڠڤليديتاكن ساءورڠ تار تاريخ دان # >>> valid_date.call(""03-11-2000"")
# true
# >>> valid_date.call(""15-01-2012"")
# false
# >>> valid_date.call(""04-0-2040"")
# false
# >>> valid_date.call(""06-04-2020"")
# true
# >>> valid_date.call(""06/04/2020"")
# false
def valid_date(date)
","def valid_date(date)
  return false if date.nil? || date.empty?
  
  # Check if the date format is correct
  match = date.match(/^(\d{2})-(\d{2})-(\d{4})$/)
  return false unless match
  
  month, day, year = match.captures.map(&:to_i)
  
  # Check if month is valid
  return false if month < 1 || month > 12
  
  # Check if day is valid according to the month
  case month
  when 1, 3, 5, 7, 8, 10, 12
    return day >= 1 && day <= 31
  when 4, 6, 9, 11
    return day >= 1 && day <= 30
  when 2
    return day >= 1 && day <= 29
  else
    return false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_valid_date
    candidate = method(:valid_date)
    assert_equal(true, candidate.call(""03-11-2000""))
    assert_equal(false, candidate.call(""15-01-2012""))
    assert_equal(false, candidate.call(""04-0-2040""))
    assert_equal(true, candidate.call(""06-04-2020""))
    assert_equal(true, candidate.call(""01-01-2007""))
    assert_equal(false, candidate.call(""03-32-2011""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""04-31-3000""))
    assert_equal(true, candidate.call(""06-06-2005""))
    assert_equal(false, candidate.call(""21-31-2000""))
    assert_equal(true, candidate.call(""04-12-2003""))
    assert_equal(false, candidate.call(""04122003""))
    assert_equal(false, candidate.call(""20030412""))
    assert_equal(false, candidate.call(""2003-04""))
    assert_equal(false, candidate.call(""2003-04-12""))
    assert_equal(false, candidate.call(""04-2003""))
  end
end
"
HumanEval_125,bjn_Arab,rb,"چونتوه ابجد، اوردي (a) = 0، اوردي (b) = 1، ... اوردي (z) = 25ڤرلو دباݢي دالم کوما ',' اڤابيلا تياد کوما ڤرلو مڽاتاكن جومله حروف کومونيک دڠن اورد ڤرليندوڠن ديتاهن سݢالا سوارا، مڽاتاكن سابوءه ارري سوارا ديباݢاي ڤاس ڤاس ڤاس، اڤابيلا تيدق اد ڤاس ڤاس ڤاس دالم تيكس نڠ كامو # >>> split_words.call(""Hello world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""Hello,world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""abcdef"")
# 3
def split_words(txt)
","def split_words(txt)
  if txt.include?(' ')
    return txt.split(' ')
  elsif txt.include?(',')
    return txt.split(',')
  else
    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }
    return odd_count
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_split_words
    candidate = method(:split_words)
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello world!""))
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello,world!""))
    assert_equal([""Hello"", ""world,!""], candidate.call(""Hello world,!""))
    assert_equal([""Hello,Hello,world"", ""!""], candidate.call(""Hello,Hello,world !""))
    assert_equal(3, candidate.call(""abcdef""))
    assert_equal(2, candidate.call(""aaabb""))
    assert_equal(1, candidate.call(""aaaBb""))
    assert_equal(0, candidate.call(""""))
  end
end
"
HumanEval_126,bjn_Arab,rb,"چونتوه باضمانا, ماكن اد ارقام نݢاتيف وان ڤون ارقام نݢاتيف.دالم اورد ڤرتام. اڤابيلا ارري باءيسي لبيه دري سابوتيڠ دوڤليک ديبارياكن سابوءه ارري باءيسي نومبور، ماولاه اڤاکه اي ديباريساكن اتاوا كادا.# >>> is_sorted.call([5])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5])
# false
# >>> is_sorted.call([1, 2, 3, 4, 5, 6])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])
# false
# >>> is_sorted.call([1, 2, 2, 3, 3, 4])
# true
# >>> is_sorted.call([1, 2, 2, 2, 3, 4])
# false
def is_sorted(lst)
","def is_sorted(lst)
  lst.each_cons(2).with_index do |(a, b), index|
    return false if a > b
    return false if index < lst.length - 2 && a == b && lst[index + 2] == b
  end
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_sorted
    candidate = method(:is_sorted)
    assert_equal(true, candidate.call([5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))
    assert_equal(true, candidate.call([]))
    assert_equal(true, candidate.call([1]))
    assert_equal(false, candidate.call([3, 2, 1]))
    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))
    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 3, 4]))
  end
end
"
HumanEval_127,bjn_Arab,rb,"[اينڤوت/اينتؤرت] ڤانال: اڤابيلا دوا اينترڤل كادا مڠمبيل ڤرتاڽ، مڽاتاكن ""لا"".در غير اينصورت، ""NO"" را برميگرداند.اڤابيلا باڠونن ڤرسمبهن اداله سابوءه نومبور ڤرم، مڽاتاكن ""YES"", با طول 1، كه عدد اوليه نيست.چونتوه، ڤاسڠن انتارۏيل (1, 3), (2, 4) اداله (2, 3) ݢاريس ڤرݢرقن اداله سابوتيڠ ارقام ڤرم.كاريا كامو اداله ڬسن ممنتڤكن اڤاکه جالن ڤربينچڠن كدوا-دوا ݢاسان ستياڤ اينترۏال نانݢ ديديريكان, ديڤينتاهاكان بهاوا ڤامولأنڽا لاوان اتاوا سام لاوان اخيرڽا.مانامڤيلاكن ڤامولأن وان اخير.ڤارنتوك-ڤارنتوك نڠ دبري اداله تيدق دڤرتاهنكن مانجادي ڤارنتوك (ڤامولأن، اخير) دمان ستياڤ اينترال اداله جوريڠ اينتيڬر. چونتوهڽ، اينترال = (ڤرتام، اخير) = (1, 2).اكو دبري دوا ڤريڠكت،# >>> intersection.call([1, 2], [2, 3])
# ""NO""
# >>> intersection.call([-1, 1], [0, 4])
# ""NO""
# >>> intersection.call([-3, -1], [-5, 5])
# ""YES""
def intersection(interval1, interval2)
","def intersection(interval1, interval2)
  start1, end1 = interval1
  start2, end2 = interval2

  intersection_start = [start1, start2].max
  intersection_end = [end1, end2].min

  if intersection_start > intersection_end
    return ""NO""
  end

  intersection_length = intersection_end - intersection_start + 1

  return ""YES"" if prime?(intersection_length)

  ""NO""
end

def prime?(n)
  return false if n <= 1
  return true if n == 2 || n == 3

  (2..Math.sqrt(n).to_i).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersection
    candidate = method(:intersection)
    assert_equal(""NO"", candidate.call([1, 2], [2, 3]))
    assert_equal(""NO"", candidate.call([-1, 1], [0, 4]))
    assert_equal(""YES"", candidate.call([-3, -1], [-5, 5]))
    assert_equal(""YES"", candidate.call([-2, 2], [-4, 0]))
    assert_equal(""NO"", candidate.call([-11, 2], [-1, -1]))
    assert_equal(""NO"", candidate.call([1, 2], [3, 5]))
    assert_equal(""NO"", candidate.call([1, 2], [1, 2]))
    assert_equal(""NO"", candidate.call([-2, -2], [-3, -2]))
  end
end
"
HumanEval_128,bjn_Arab,rb,"چونتوه:Note: return nil for empty arr.  ڤرݢيݢيهن ڤرݢيݢيهنديكاتاكن اوليه ١،-١ اتاو ٠.سومبڠن كاكيتاڠن انتيڬري مڠيكوت ڤرباتاس كسموا تندا اكو دبري ارري ار ارن اورڠ اينتيڬر وان اكو ڤرلو مڽارڠ # >>> prod_signs.call([1, 2, 2, -4])
# 9
# >>> prod_signs.call([0, 1])
# 0
# >>> prod_signs.call([])
# nil
def prod_signs(arr)
","def prod_signs(arr)
  return nil if arr.empty?
  
  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }
  sum_magnitudes = arr.map(&:abs).sum
  
  product_signs * sum_magnitudes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prod_signs
    candidate = method(:prod_signs)
    assert_equal(-9, candidate.call([1, 2, 2, -4]))
    assert_equal(0, candidate.call([0, 1]))
    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))
    assert_equal(nil, candidate.call([]))
    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))
    assert_equal(4, candidate.call([-1, 1, -1, 1]))
    assert_equal(-4, candidate.call([-1, 1, 1, 1]))
    assert_equal(0, candidate.call([-1, 1, 1, 0]))
  end
end
"
HumanEval_129,bjn_Arab,rb,"چونتوه:مڽاراكن ارري ڤارنتاي دري ڤاريت دالم سيل نڠ باݢايماناڤون ڤاسر مينيمومڽ.ديقينن جواڤنڽ اداله اونيك.lst_A[j] = lst_B[j]. ساكيت جادي lst_A[i] < lst_B[i] وان باءيق ج (1 <= ج < i) كيت اد lst_B, دڠن كات لاين, اد ايندكس اينتڬري i (1 <= i <= k) لاوان (بايكيتو ماڠاجاكنڽا lst_A وان lst_B), lst_A ليكسيچؤڬرافي كادا ستله مڠمبيل ارري-ارري ترسبوت دري ڤرماءينن د سيل-سيل نڠ A وان B سابوتيڠ ڤاس A (دڠان ك) دأڠݢڤ ساكيتار دري ڤاس B (دڠان ك) جادي اكو تيدق بوليه مڽرهكن ڬريد.ݢاسان مانݢݢݢانݢݢ.ڤيليهت تاهو بهاوا سابوتيڠ ڤاسل دري بوجور k مانونجوكاكن ڤوجي سيكتڽ k سيل (كادا ڤيليهن رايديريڽا, كامو جاوت ك سيل-سيل نڠ باڬايمانا كاداڠان لاوان كامو داري سيل مان, وان دي ستياڤ تاهون اندا بوليه مڠمبيل كاد سيل ڤاراكت,اندا ڤرلو مانيڤاتي ڤاسر مينيموم دري كايڠ k دالم ڬريد. اندا بوليه مولا.سڤرتي اين، اينكلوسيف تله دتوبوهكن سابڬي ساتو كالي دالم سيل ڬريد.ستياڤ سيل ڬريد مانونجوككن سابوءه ۏاليه. ستياڤ اينتڬري دالم رينچڠ [١، ن * ن] ديبارياكن سابوءه ريس باڠ N رنچان وان N ستوم (N >= 2) وان سابوءه اينتيڬر ڤوسيتيف k، # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
# [1, 2, 1]
# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
# [1]
def minPath(grid, k)
","def minPath(grid, k)
  n = grid.size
  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  min_path = nil

  n.times do |i|
    n.times do |j|
      queue = [[[i, j], [grid[i][j]]]]
      until queue.empty?
        position, path = queue.shift
        if path.size == k
          min_path = path if min_path.nil? || path < min_path
          next
        end
        directions.each do |dx, dy|
          x, y = position[0] + dx, position[1] + dy
          if x.between?(0, n-1) && y.between?(0, n-1)
            queue.push([[x, y], path + [grid[x][y]]])
          end
        end
      end
    end
  end
  min_path
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minPath
    candidate = method(:minPath)
    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))
    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))
    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))
    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))
    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))
    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))
    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))
  end
end
"
HumanEval_130,bjn_Arab,rb,"چونتوه:ڤامولاان n + 1 نومبور سيكينسي تريبوناتسي.شما با يك عدد صحيح غيرمنفي n، بايد يه ارري از  را برگردانيد= 2 + 3 + 3 = 8 تريبونتيوم (3) = تريبونتيوم (2) + تريبونتيوم (1) + تريبونتيوم (4)تراي ((4) = 3 تراي ((2) = ١ + (٢ / ٢) = ٢ چونتوهڽ: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), جادي جادي جادي. tri (n) = 1 + n / 2، جادي n اداله جادي. tri(1) = 3 سيكوانسي تريبوناكسي ديتادڤكن اوليه ريكارسين: تاڤي، اڤ يڠ اورڠ تيدق ڤرنه ڤستيكن اداله سيكويين تريبوناتسي.سموا اورڠ مينتاهو سيكويينس فيبوناتچي، نڠ دڤارسياكن سيكڤ اوليه ڤارا ماتماتيك د # >>> tri.call(3)
# [1, 3, 2, 8]
def tri(n)
","def tri(n)
  sequence = [1, 3]
  
  (2..n).each do |i|
    if i.even?
      sequence[i] = 1 + i / 2
    else
      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0
    end
  end
  
  sequence[0..n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_tri
    candidate = method(:tri)
    assert_equal([1, 3, 2, 8], candidate.call(3))
    assert_equal([1, 3, 2, 8, 3], candidate.call(4))
    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))
    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))
    assert_equal([1], candidate.call(0))
    assert_equal([1, 3], candidate.call(1))
  end
end
"
HumanEval_131,bjn_Arab,rb,"چونتوهڽ: ماولاه 0 اڤابيلا سموا ديڬيت اداله ڤرنه.ديبارياكن سابوءه انتيڬره ڤوسيتيف n، ماولاه ڤربودوهان انتيڬره ڤاس. # >>> digits.call(1)
# 1
# >>> digits.call(4)
# 0
# >>> digits.call(235)
# 15
def digits(n)
","def digits(n)
  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }
  return 0 if odd_digits.empty?
  odd_digits.reduce(:*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digits
    candidate = method(:digits)
    assert_equal(5, candidate.call(5))
    assert_equal(5, candidate.call(54))
    assert_equal(1, candidate.call(120))
    assert_equal(5, candidate.call(5014))
    assert_equal(315, candidate.call(98765))
    assert_equal(2625, candidate.call(5576543))
    assert_equal(0, candidate.call(2468))
  end
end
"
HumanEval_132,bjn_Arab,rb,"دمان كادا سابوتيڠ كاكيتاڠن دالم سوبسيكىسين ديڤاركيت.فانسي ڤرلو مڠرجاكن سچار جادي وان هاڽ جادي اد سابوتي سوبسيکويينس ڤراڠكت ماولاهاكان فؤنسيؤن نانݢ مامالاه سىلاتاتات ساباݢاي اينتؤر نانݢ بايسي ڤاراكيت كادوا.# >>> is_nested.call(""[[]]"")
# true
# >>> is_nested.call(""[]]]]]]][[[[[]"")
# false
# >>> is_nested.call(""[][]"")
# false
# >>> is_nested.call(""[]"")
# false
# >>> is_nested.call(""[[][]]"")
# true
# >>> is_nested.call(""[[]][["")
# true
def is_nested(string)
","def is_nested(string)
  stack = []
  has_nested = false

  string.each_char do |char|
    if char == '['
      stack.push(char)
    elsif char == ']'
      if stack.empty?
        return false
      end
      stack.pop
      has_nested = true if stack.any?
    end
  end

  has_nested
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_nested
    candidate = method(:is_nested)
    assert_equal(true, candidate.call(""[[]]""))
    assert_equal(false, candidate.call(""[]]]]]]][[[[[]""))
    assert_equal(false, candidate.call(""[][]""))
    assert_equal(false, candidate.call(""[]""))
    assert_equal(true, candidate.call(""[[[[]]]]""))
    assert_equal(false, candidate.call(""[]]]]]]]]]]""))
    assert_equal(true, candidate.call(""[][][[]]""))
    assert_equal(false, candidate.call(""[[]""))
    assert_equal(false, candidate.call(""[]]""))
    assert_equal(true, candidate.call(""[[]][[""))
    assert_equal(true, candidate.call(""[[][]]""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""[[[[[[[[""))
    assert_equal(false, candidate.call(""]]]]]]]]""))
  end
end
"
HumanEval_133,bjn_Arab,rb,"چونتوه:ڤرتام، ڤرلو مڠورونكن ستياڤ ايليمن دالم ارري كاو ڤرتام.كامو ڤرلو مڽاتاكن سومبر كوادراتوم ڤد ارري دبري، اكو دبري سابوءه ارسي ارقام.# >>> lst.call([1.0, 2.0, 3.0])
# 14
# >>> lst.call([1.0, 4.0, 9.0])
# 98
# >>> lst.call([1.0, 3.0, 5.0, 7.0])
# 84
# >>> lst.call([1.4, 4.2, 0.0])
# 29
# >>> lst.call([-2.4, 1.0, 1.0])
# 6
def sum_squares(lst)
","def sum_squares(lst)
  lst.map { |num| (num.ceil)**2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))
    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))
    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))
    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))
    assert_equal(200000000, candidate.call([10000.0, 10000.0]))
    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))
    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))
    assert_equal(0, candidate.call([0.0]))
    assert_equal(1, candidate.call([-1.0]))
    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))
  end
end
"
HumanEval_134,bjn_Arab,rb,"چونتوه:""كلمه"" اداله ڬروڤ كاراكتر يڠ ديباڬاياكن لاون سڤيسيس.ساباڬيان داري سابوتيڠ كات، وان كادا باواڠ.دري سابوتيڠ ساءينتير دبري اداله كاراكتر ابجد وان كادا ماولاكن فڠسي يڠ مروڤاكن سچارا سچارا اڤابيلا كاراكتر اخير # >>> check_if_last_char_is_a_letter.call(""apple pie"")
# false
# >>> check_if_last_char_is_a_letter.call(""apple pi e"")
# true
# >>> check_if_last_char_is_a_letter.call(""apple pi e "")
# false
# >>> check_if_last_char_is_a_letter.call("""")
# false
def check_if_last_char_is_a_letter(txt)
","check_if_last_char_is_a_letter = ->(txt) {
  return false if txt.strip.empty?
  words = txt.strip.split(' ')
  last_word = words.last
  return false if last_word.empty?
  last_char = last_word[-1]

  last_char =~ /[a-zA-Z]/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')
}","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_if_last_char_is_a_letter
    candidate = method(:check_if_last_char_is_a_letter)
    assert_equal(false, candidate.call(""apple""))
    assert_equal(true, candidate.call(""apple pi e""))
    assert_equal(false, candidate.call(""eeeee""))
    assert_equal(true, candidate.call(""A""))
    assert_equal(false, candidate.call(""Pumpkin pie ""))
    assert_equal(false, candidate.call(""Pumpkin pie 1""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""eeeee e ""))
    assert_equal(false, candidate.call(""apple pie""))
    assert_equal(false, candidate.call(""apple pi e ""))
  end
end
"
HumanEval_135,bjn_Arab,rb,"چونتوه:ڤارولاهان دوڤليكات.كادا ايليمن نڠ كاي اد لالو ماوليه -1. ارري نڠ دبرياكن كادا بايسي اكن تيدق لبيه بسر اتاو سام دڠن ايليمن نڠ سوده ڤرلو. اڤابيلامڽاتاكن فانسي يڠ مڽاتاكن ايندكس ڤاليڠ بسر ايليمن # >>> can_arrange.call([1, 2, 4, 3, 5])
# 3
# >>> can_arrange.call([1, 2, 3])
# -1
def can_arrange(arr)
","def can_arrange(arr)
  (1...arr.length).reverse_each do |i|
    return i if arr[i] < arr[i - 1]
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_can_arrange
    candidate = method(:can_arrange)
    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))
    assert_equal(-1, candidate.call([1, 2, 4, 5]))
    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))
    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))
    assert_equal(-1, candidate.call([]))
  end
end
"
HumanEval_136,bjn_Arab,rb,"چونتوه:اڤابيلا اد ارقام ساري نڠڬاتيف اتاو ڤوسيتيف، جاديلهڽ نيل.دالم سابوءه ارقام باسيج ڤوسيتيف دالم سابوءه ارسي.ڤاليڠ ڬانل دري انتيڬر نڠڬيتيف، وان ب اداله ڤاليڠ كيت ساكيت ماولاهاكان فؤنسيؤن نانݢ ماولاهاكان ارري (ا، ب) ، نانݢ 'ا' ادالاه # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])
# [nil, 1]
# >>> largest_smallest_integers.call([])
# [nil, nil]
# >>> largest_smallest_integers.call([0])
# [nil, nil]
def largest_smallest_integers(lst)
","def largest_smallest_integers(lst)
  largest_negative = nil
  smallest_positive = nil
  
  lst.each do |num|
    if num < 0
      largest_negative = num if largest_negative.nil? || num > largest_negative
    elsif num > 0
      smallest_positive = num if smallest_positive.nil? || num < smallest_positive
    end
  end
  
  [largest_negative, smallest_positive]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_smallest_integers
    candidate = method(:largest_smallest_integers)
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))
    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))
    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))
    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))
    assert_equal([nil, nil], candidate.call([]))
    assert_equal([nil, nil], candidate.call([0]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))
  end
end
"
HumanEval_137,bjn_Arab,rb,"يادداشت: اگر يك عدد حقيقي به عنوان يك رشته نمايش داده شود، نقطه شناور ممكن است . يا ، مڠرجاكن nil اڤابيلا ڤاريت سام. باڬين ڤارابيل ڤاليڠ لابه دالم جنيس ڤارابيل نڠ دبريڽ.مڠمبيل فڠسي نڠ مڠمبيل اينتيڬر، فلوات، اتاو سترين مڠامبيل # >>> compare_one.call(1, 2.5)
# 2.5
# >>> compare_one.call(1, ""2,3"")
# ""2,3""
# >>> compare_one.call(""5,1"", ""6"")
# ""6""
# >>> compare_one.call(""1"", 1)
# nil
def compare_one(a, b)
","def compare_one(a, b)
  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')
  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')

  if a.is_a?(String) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Float)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Float)
    a = a.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Integer)
    b = b.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Float)
    b = b.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(String)
    a = a.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  else
    return nil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare_one
    candidate = method(:compare_one)
    assert_equal(2, candidate.call(1, 2))
    assert_equal(2.5, candidate.call(1, 2.5))
    assert_equal(3, candidate.call(2, 3))
    assert_equal(6, candidate.call(5, 6))
    assert_equal(""2,3"", candidate.call(1, ""2,3""))
    assert_equal(""6"", candidate.call(""5,1"", ""6""))
    assert_equal(""2"", candidate.call(""1"", ""2""))
    assert_equal(nil, candidate.call(""1"", 1))
  end
end
"
HumanEval_138,bjn_Arab,rb,"چونتوه مڠاڤيسهكن اڤابيلا نومبور ن نڠ دبريكن جك بوكن سومبڠن دري 4 نومبور ڤوسيتيف نڠ ڤوسيتيف # >>> is_equal_to_sum_even.call(4)
# false
# >>> is_equal_to_sum_even.call(6)
# false
# >>> is_equal_to_sum_even.call(8)
# true
def is_equal_to_sum_even(n)
","def is_equal_to_sum_even(n)
  return false if n < 8
  n.even?
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_equal_to_sum_even
    candidate = method(:is_equal_to_sum_even)
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(8))
    assert_equal(true, candidate.call(10))
    assert_equal(false, candidate.call(11))
    assert_equal(true, candidate.call(12))
    assert_equal(false, candidate.call(13))
    assert_equal(true, candidate.call(16))
  end
end
"
HumanEval_139,bjn_Arab,rb,"چونتوهڽ: جايي كه n > 0 brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! فاكتوريل برازيليا ديفينيسيكن ساباڬاي: # >>> special_factorial.call(4)
# 288
# The function will receive an integer as input and should return the special
# factorial of this integer.
def special_factorial(n)
","def special_factorial(n)
  return 1 if n <= 1
  (1..n).inject(1) { |product, i| product * factorial(i) }
end

def factorial(num)
  return 1 if num <= 1
  (2..num).inject(1, :*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_special_factorial
    candidate = method(:special_factorial)
    assert_equal(288, candidate.call(4))
    assert_equal(34560, candidate.call(5))
    assert_equal(125411328000, candidate.call(7))
    assert_equal(1, candidate.call(1))
  end
end
"
HumanEval_140,bjn_Arab,rb,"لالو مڠاجر سموا ڤاسير ڤرتاڽان دڠن - وان اڤابيلا سابوءه تار اد لبيه دري ٢ ڤاسير ڤاسير، ديبارياكن سابوتيڠ سيكتور تيكس، مڠاجر سموا ڤاسير دالمڽ دڠن انترسوكر، # >>> fix_spaces.call("" Example"")
# ""Example""
# >>> fix_spaces.call("" Example 1"")
# ""Example_1""
# >>> fix_spaces.call("" Example 2"")
# ""_Example_2""
# >>> fix_spaces.call("" Example 3"")
# ""_Example-3""
def fix_spaces(text)
","def fix_spaces(text)
  text.strip.gsub(/\s{3,}/, '-').gsub(' ', '_')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fix_spaces
    candidate = method(:fix_spaces)
    assert_equal(""Example"", candidate.call(""Example""))
    assert_equal(""Mudasir_Hanif_"", candidate.call(""Mudasir Hanif ""))
    assert_equal(""Yellow_Yellow__Dirty__Fellow"", candidate.call(""Yellow Yellow  Dirty  Fellow""))
    assert_equal(""Exa-mple"", candidate.call(""Exa   mple""))
    assert_equal(""-Exa_1_2_2_mple"", candidate.call(""   Exa 1 2 2 mple""))
  end
end
"
HumanEval_141,bjn_Arab,rb,"چونتوه:- سوبسترينغ ستله تيتيك هاروس جادي ساتو دري اين: ['تيكست'، 'إكسي'، 'ديل'] ابجد لاتين ('a'-'z' وان 'A'-'Z').- سوبسترين ڤاس تيتيق تيدق بوليه برڤاكاي، وانڽ برمولا دڠن حروف دري - نام فايل مانتڠكن سيكڤ ساتو تيتيق '.' - تيدق بوليه اد لبيه دري ديڬيت ('0'-'9') دالم نام فايل.ديڤينتاه:نام فايل دڤڠڬيل باءيق جك دان هاڽ جك سموا شرط-شرط داسر ""Yes"" اڤابيلا نام فايل اداله باءيق، وان ممباوا ""لا"" لاينڽ.ماولاهاكان فؤنكسي نانݢ ماولاه سىلاتاتات نانݢ مانامڤيلاكان ݢاريس فايل, وان ماولاه # >>> file_name_check.call(""example.txt"")
# ""Yes""
# >>> file_name_check.call(""1example.dll"")
# ""No""
def file_name_check(file_name)
","def file_name_check(file_name)
  # Check if there's exactly one dot in the filename
  return 'No' unless file_name.count('.') == 1
  
  # Split the filename into the name and extension
  name, extension = file_name.split('.')
  
  # Check if the name part starts with a letter
  return 'No' if name.empty? || !name[0].match?(/[a-zA-Z]/)
  
  # Check if the extension is valid
  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)
  
  # Count digits in the file name
  digit_count = file_name.count(""0-9"")
  
  # Check if digits are more than three
  return 'No' if digit_count > 3
  
  'Yes'
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_file_name_check
    candidate = method(:file_name_check)
    assert_equal(""Yes"", candidate.call(""example.txt""))
    assert_equal(""No"", candidate.call(""1example.dll""))
    assert_equal(""No"", candidate.call(""s1sdf3.asd""))
    assert_equal(""Yes"", candidate.call(""K.dll""))
    assert_equal(""Yes"", candidate.call(""MY16FILE3.exe""))
    assert_equal(""No"", candidate.call(""His12FILE94.exe""))
    assert_equal(""No"", candidate.call(""_Y.txt""))
    assert_equal(""No"", candidate.call(""?aREYA.exe""))
    assert_equal(""No"", candidate.call(""/this_is_valid.dll""))
    assert_equal(""No"", candidate.call(""this_is_valid.wow""))
    assert_equal(""Yes"", candidate.call(""this_is_valid.txt""))
    assert_equal(""No"", candidate.call(""this_is_valid.txtexe""))
    assert_equal(""No"", candidate.call(""#this2_i4s_5valid.ten""))
    assert_equal(""No"", candidate.call(""@this1_is6_valid.exe""))
    assert_equal(""No"", candidate.call(""this_is_12valid.6exe4.txt""))
    assert_equal(""No"", candidate.call(""all.exe.txt""))
    assert_equal(""Yes"", candidate.call(""I563_No.exe""))
    assert_equal(""Yes"", candidate.call(""Is3youfault.txt""))
    assert_equal(""Yes"", candidate.call(""no_one#knows.dll""))
    assert_equal(""No"", candidate.call(""1I563_Yes3.exe""))
    assert_equal(""No"", candidate.call(""I563_Yes3.txtt""))
    assert_equal(""No"", candidate.call(""final..txt""))
    assert_equal(""No"", candidate.call(""final132""))
    assert_equal(""No"", candidate.call(""_f4indsartal132.""))
    assert_equal(""No"", candidate.call("".txt""))
    assert_equal(""No"", candidate.call(""s.""))
  end
end
"
HumanEval_142,bjn_Arab,rb,"چونتوه:مڠوبه ڤڠاتورن دالم ارري يڠ ايندكسڽ كادا مالڠݢر 3 اتاو 4. فڠسي ڤرلو مڽاتاكن سومتارا كسموا ڤڠاتورن.باڽق دري 3 وان ݢاريس اينتڬري اينتڬري جادي كوب جادي ايندكسڽ باڽق دري 4 وان كادا باڽق دري 3. فانسي كادا فانكس اين مڠاخيري ارسي ارقام ساري. ڬسن سموا ڤڠاتورن دالم ارسي، فانكس هاروس مڠكوادركن ڤڠاتورن ارسي ساڤت اڤابيلا ايندكسڽ اداله ""  ڤان# >>> lst
# [1, 2, 3]
# >>> lst
# []
# >>> lst
# [-1, -5, 2, -1, -5]
def sum_squares(lst)
","def sum_squares(lst)
  lst.map.with_index do |num, index|
    if index % 3 == 0
      num ** 2
    elsif index % 4 == 0
      num ** 3
    else
      num
    end
  end.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(6, candidate.call([1, 2, 3]))
    assert_equal(14, candidate.call([1, 4, 9]))
    assert_equal(0, candidate.call([]))
    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))
    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))
    assert_equal(0, candidate.call([0]))
    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))
    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))
    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))
    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))
    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))
  end
end
"
HumanEval_143,bjn_Arab,rb,"چونتوه 1:اورد ڤاڽاتأن د ساءينج بارو ڤرلو سام لاون ساءينج اول.ڤاسڽا اداله ارقام ڤرم، وان كامو ڤرلو مروڤاكن سٽرينغ نڠ مان ايڠين كاتا-كات دري ڤرسان اصل، ڤانݢݢݢانانان ناڠ مانݢݢامباڠاكان باݢيان ڤانݢݢݢانان نانݢ ديڤاركيتاكان لاوان سابوتيڠ اكو دبري ساءيرڠ نڠ ماڠامبيل سابوءه ڤرسيڤسي، # >>> words_in_sentence.call(""This is a test"")
# ""is""
# Example 2:
# >>> words_in_sentence.call(""lets go for swimming"")
# ""go for""
# Constraints:
# * 1 <= len(sentence) <= 100
# * sentence contains only letters
def words_in_sentence(sentence)
","def words_in_sentence(sentence)
  def is_prime?(num)
    return false if num <= 1
    (2..Math.sqrt(num)).none? { |i| num % i == 0 }
  end
  
  words = sentence.split("" "")
  prime_length_words = words.select { |word| is_prime?(word.length) }
  prime_length_words.join("" "")
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_in_sentence
    candidate = method(:words_in_sentence)
    assert_equal(""is"", candidate.call(""This is a test""))
    assert_equal(""go for"", candidate.call(""lets go for swimming""))
    assert_equal(""there is no place"", candidate.call(""there is no place available here""))
    assert_equal(""Hi am Hussein"", candidate.call(""Hi I am Hussein""))
    assert_equal(""go for it"", candidate.call(""go for it""))
    assert_equal("""", candidate.call(""here""))
    assert_equal(""is"", candidate.call(""here is""))
  end
end
"
HumanEval_144,bjn_Arab,rb,"اندي جك ايكن ڤرلو مڠيكوت x, وان n اداله كاكيتاڠن نڠ باءيق، وان كادا باءيق صفر سباڬاي ڤڠاتورن.<بهاݢين>/<بهاݢين> دمان بهاݢين وان بهاݢينڽ اداله باڽق-باڽق ڤوسيتيف.كدوا x وان n، اداله ڤرڤارنتهن سورت ڤربواتن، وان باءيسي ڤرتمبهن نڠ مان:x * n. فانكسسي مروڤاكن كاءيقينن اڤابيلا x * n مروڤاكن سابوءه باهن باءيق وان كاءيقينن كدالم كاريكت تو اداله ڬسن ممڤركنلكن فڠسيون نڠ منچيڤتاكن ايكسڤريسين # >>> simplify.call(""1/5"", ""5/1"")
# true
# >>> simplify.call(""1/6"", ""2/1"")
# false
# >>> simplify.call(""7/10"", ""10/2"")
# false
def simplify(x, n)
","def simplify(x, n)
  # Convert x and n to numerators and denominators
  num_x, den_x = x.split('/').map(&:to_i)
  num_n, den_n = n.split('/').map(&:to_i)

  # Multiply fractions: (num_x * num_n) / (den_x * den_n)
  numerator = num_x * num_n
  denominator = den_x * den_n

  # Check if the result is a whole number
  numerator % denominator == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_simplify
    candidate = method(:simplify)
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/6"", ""2/1""))
    assert_equal(true, candidate.call(""5/1"", ""3/1""))
    assert_equal(false, candidate.call(""7/10"", ""10/2""))
    assert_equal(true, candidate.call(""2/10"", ""50/10""))
    assert_equal(true, candidate.call(""7/2"", ""4/2""))
    assert_equal(true, candidate.call(""11/6"", ""6/1""))
    assert_equal(false, candidate.call(""2/3"", ""5/2""))
    assert_equal(false, candidate.call(""5/2"", ""3/5""))
    assert_equal(true, candidate.call(""2/4"", ""8/4""))
    assert_equal(true, candidate.call(""2/4"", ""4/2""))
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/5"", ""1/5""))
  end
end
"
HumanEval_145,bjn_Arab,rb,"چونتوهڽ: مڠوروساكنڽا باڬاسا انديكسڽا دالم ارري اوريجنل.Catatan: jika ada beberapa item dengan jumlah digit digitnya yang sama,  اڤابيلا اد ببراڤ اورڠ دڠن jumlah digit digitnya yang sama, دالم اورد نڠ باءيق سيوجوق سومبڠن داءيݢيتڽ۔منوليس فانسيون نڠ مڠورڠكن ارري انتيجر دبري # >>> order_by_points.call([1, 11, -1, -11, -12])
# [-1, -11, 1, -12, 11]
# >>> order_by_points.call([])
# []
def order_by_points(nums)
","def order_by_points(nums)
  nums.sort_by.with_index do |num, index|
    [num.to_s.chars.map(&:to_i).sum.abs, index]
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_order_by_points
    candidate = method(:order_by_points)
    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))
    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))
    assert_equal([], candidate.call([]))
    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))
    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))
    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))
  end
end
"
HumanEval_146,bjn_Arab,rb,"چونتوهڽ: ديڬيت ڤرتام وان اخير سابوءه نومبور اداله كادا (1, 3, 5, 7, 9).جومله ايليمن دالم ارري نڠ لابه دري 10 وان كدواڽ منوليس فانکشن نڠ مڠاخيري ارري باڬي ڤڠلوارن وان ڤاڤن # >>> specialFilter.call([15, -73, 14, -15])
# 1
# >>> specialFilter.call([33, -2, -3, 45, 21, 109])
# 2
def specialFilter(nums)
","def specialFilter(nums)
  nums.count do |num|
    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_specialFilter
    candidate = method(:specialFilter)
    assert_equal(0, candidate.call([5, -2, 1, -5]))
    assert_equal(1, candidate.call([15, -73, 14, -15]))
    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))
    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))
    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))
    assert_equal(0, candidate.call([1]))
    assert_equal(0, candidate.call([]))
  end
end
"
HumanEval_147,bjn_Arab,rb,"چونتوه:وان a[i] + a[j] + a[k] اداله كاكرتاان كاو 3.مڽاتاكن ڤڠاروه تريبل (a[i], a[j], a[k]) دري a د مان i < j < k, باݢي ستياڤ i (1 ≤ i ≤ n) ، باهن a[i] = i * i - i + 1.اكو دبريكن انتيڬر ڤوسيتيف n. اكو ڤرلو مڠمبيل ارري انتيڬر a دري لنجوت n. # >>> get_max_triples.call(5)
# 1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
def get_max_triples(n)
","def get_max_triples(n)
  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }
  count = 0
  
  (0...n).each do |i|
    (i+1...n).each do |j|
      (j+1...n).each do |k|
        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0
      end
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_max_triples
    candidate = method(:get_max_triples)
    assert_equal(1, candidate.call(5))
    assert_equal(4, candidate.call(6))
    assert_equal(36, candidate.call(10))
    assert_equal(53361, candidate.call(100))
  end
end
"
HumanEval_148,bjn_Arab,rb,"چونتوه اڤاكه تيدق نام ڤلانيت نڠ كوات.فانسي ڤرلو مروڤاكن سابوءه ارري باهنج اڤابيلا planet1 اتاو planet2 ڤاراكتاهان كايا هاري.دتاڠݢڤ انتارا اوربيت ڤلانيت ١ وان اوربيت ڤلانيت ٢، ديباݢاي لاوانفانسي ڤرلو مڽارولاكن سابوءه ارري ناڠ مان سموا ڤلانيت نڠ اوربيتڽ منوليس فانسي يڠ مڠاخيري دوا نام ڤلانيت سباڬاي ساءيرڠ ڤلانيت1 وان ڤلانيت2.اورانوس، نڤتون.اداله مريكوري، نڠ مان جادي ڤينوس، لالو بومي، مريس، جوڤيتر، ساترن،اد تومڤت بومي د سيستم هاري كيت: نڠ ڤاليڠ كايمڤوڠ ك هاري# >>> bf.call(""Jupiter"", ""Neptune"")
# [""Saturn"", ""Uranus""]
# >>> bf.call(""Earth"", ""Mercury"")
# ""Venus""
# >>> bf.call(""Mercury"", ""Uranus"")
# [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
def bf(planet1, planet2)
","def bf(planet1, planet2)
  planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
  
  idx1 = planets.index(planet1)
  idx2 = planets.index(planet2)
  
  return [] if idx1.nil? || idx2.nil?

  start_idx, end_idx = [idx1, idx2].sort
  
  planets[(start_idx + 1)...end_idx]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_bf
    candidate = method(:bf)
    assert_equal([""Saturn"", ""Uranus""], candidate.call(""Jupiter"", ""Neptune""))
    assert_equal([""Venus""], candidate.call(""Earth"", ""Mercury""))
    assert_equal([""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""], candidate.call(""Mercury"", ""Uranus""))
    assert_equal([""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""], candidate.call(""Neptune"", ""Venus""))
    assert_equal([], candidate.call(""Earth"", ""Earth""))
    assert_equal([], candidate.call(""Mars"", ""Earth""))
    assert_equal([], candidate.call(""Jupiter"", ""Makemake""))
  end
end
"
HumanEval_149,bjn_Arab,rb,"چونتوهڽ: اندا موڠكين مڠڬڤ بهاوا سموا كلمات هاڽ باڽق سام.فانسي ڤرلو مروڤاكن سابوءه ارري ستراين دالم اوردين نڠ دڤرتيمبڠ.اڤابيلا دوا كات باڽق سام، مڠورڠكن ارري سچارا ابجد.ڤرلو مروڤاكن ارري يڠ دڤرتيمبڠكن اوليه قاعده اورد ارري ڤرلو منجادي ڤرڤادوان دڠن ڤرتيمبڠن ستياڤ كات، وان اكو وان ايجابيتو ماكان تاهو دوڤليكاتس.ارري سمات-مات اداله ارري سورت وان كادا ارري نومبور، وان مڽاراكن ارري نڠ دأصلاكن دڠن اوردو نڠ دڤارنتوڠ، مڠحسيساكن ساءنجت-ساءنجت نڠ باءيسي لنجوت نڠ كادا باءيسي، منوليس فانسيون نڠ منچيڤتا ارري ستريڠ ساباڬاي ڤاراميتر، # >>> list_sort.call([""aa"", ""a"", ""aaa""])
# [""aa""]
# >>> list_sort.call([""ab"", ""a"", ""aaa"", ""cd""])
# [""ab"", ""cd""]
def sorted_list_sum(lst)
","def list_sort(arr)
  arr.select { |s| s.length.even? }
     .sort_by { |s| [s.length, s] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sorted_list_sum
    candidate = method(:sorted_list_sum)
    assert_equal([""aa""], candidate.call([""aa"", ""a"", ""aaa""]))
    assert_equal([""AI"", ""asdf"", ""school""], candidate.call([""school"", ""AI"", ""asdf"", ""b""]))
    assert_equal([], candidate.call([""d"", ""b"", ""c"", ""a""]))
    assert_equal([""abcd"", ""dcba""], candidate.call([""d"", ""dcba"", ""abcd"", ""a""]))
    assert_equal([""AI"", ""ai"", ""au""], candidate.call([""AI"", ""ai"", ""au""]))
    assert_equal([], candidate.call([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]))
    assert_equal([""cc"", ""dd"", ""aaaa"", ""bbbb""], candidate.call([""aaaa"", ""bbbb"", ""dd"", ""cc""]))
  end
end
"
HumanEval_150,bjn_Arab,rb,"چونتوه:سابوتيڠ باءيق وان ڤرلو مروڤاكن باهن y لاينڽ.سابوتيڠ ڤروڬرم سيباڬاي نڠ هاروس ماولاكن باهن x اڤابيلا n اداله # >>> x_or_y.call(7, 34, 12)
# 34
# >>> x_or_y.call(15, 8, 5)
# 5
def x_or_y(n, x, y)
","def x_or_y(n, x, y)
  require 'prime'
  n.prime? ? x : y
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_x_or_y
    candidate = method(:x_or_y)
    assert_equal(34, candidate.call(7, 34, 12))
    assert_equal(5, candidate.call(15, 8, 5))
    assert_equal(33, candidate.call(3, 33, 5212))
    assert_equal(3, candidate.call(1259, 3, 52))
    assert_equal(-1, candidate.call(7919, -1, 12))
    assert_equal(583, candidate.call(3609, 1245, 583))
    assert_equal(129, candidate.call(91, 56, 129))
    assert_equal(1234, candidate.call(6, 34, 1234))
    assert_equal(0, candidate.call(1, 2, 0))
    assert_equal(2, candidate.call(2, 2, 0))
  end
end
"
HumanEval_151,bjn_Arab,rb,"دالم ارري نڠ كادا باسي. ماڠݢوناكن نومبور نڠ منجاݢ اتاوا كادا باسي.ديتاهن سابوءه ارري باءيسي نومبور، جاديكن سومبر تربيت باءيسي نومبور # >>> double_the_difference.call([1, 3, 2, 0])
# 10
# >>> double_the_difference.call([-1, -2, 0])
# 0
# >>> double_the_difference.call([9, -2])
# 81
# >>> double_the_difference.call([0])
# 0
# If the input array is empty, return 0.
def double_the_difference(lst)
","def double_the_difference(lst)
  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }
     .map { |n| n ** 2 }
     .sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_double_the_difference
    candidate = method(:double_the_difference)
    assert_equal(0, candidate.call([]))
    assert_equal(25, candidate.call([5.0, 4.0]))
    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))
    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))
    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))
    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))
    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))
  end
end
"
HumanEval_152,bjn_Arab,rb,"چونتوه: nilai nya adalah 0, wan jika tidak, nilai nya adalah perbedaan mutlak antara dugaan wan skor.مڽاتاكن سابوءه ارري دري بوجور نڠ سام مانونجوكاكن جادي ڤون ڤون ڤرنه دڤرچاي. اڤابيلا بوبوهنڽ باءيق، اكو دبري دوا ارسي سكور وان ڤڠتاهوان نڠ باڽق سام، د مان ستياڤ اينديكس مانونجوكاكن سابوءه ڤرماءينن.كاراتان اداله ڬاسن مانونجوككن اڤاکه اورڠ ڠيني باءيق ماڠاتاكن ريساليت سابوءه ريبو ڤرلاونن.كادا ڤستي ڤاليڠ باءيق دالم مان مان مان ڤرنه دڤرتيمبڠ وان دڤرباراكن.ڤاڠاروه وان ڤيكير-ڤيكير نڠ اكو بايسي ڤاس ماس ڽو ادالهساي برهارڤ اندا سموا مڠتاهوي احساس ايت کتيک نتيجه ڤرنياݢان يڠ دتاهن لاما# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
# [0, 0, 0, 0, 3, 3]
# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
# [4, 4, 1, 0, 0, 6]
def compare(game, guess)
","def compare(game, guess)
  game.zip(guess).map { |score, prediction| (score - prediction).abs }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare
    candidate = method(:compare)
    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))
    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))
    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))
    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))
  end
end
"
HumanEval_153,bjn_Arab,rb,"چونتوه:(قويتڽ اداله -1).return ""Slices.SErviNGSliCes"" كران ""SErviNGSliCes"" اداله ايكستينسي نڠ ڤاليڠ كوات ڤانݢݢݢانان: ['سيرۏينݢسليچس'، 'چايس'، 'ستؤففد'] چونتوهڽ، اڤابيلا اندا دبري ""سلايسس"" سباڬاي كلاس وان ارري ڤيليه سابوتيڠ نڠ ڤرتام دالم ارري.اڤابيلا اد دوا اتاو لبيه ڤڠهادڤن نڠ باءيسي كواتن نڠ سام، اندا ڤرلو مڠهادڤي ڤڠهادڤن نڠ باءيسي كواتن نڠ سام.format: ClassName.StrongestExtensionName. ڤستيكن كامو مميليه ايكستينسي نڠ ڤاليڠ كوات وان مروڤاكن ستريڠ دالم دالم نام ايكستينسي، كاكوءاسأن دبرياكن لاوان كابور CAP - SM.حروف دالم نام ايكستينسي، وان SM باكل باڽق حروف باءيك كقواتن ايكستينسي اداله سڤرتي اين: جاديكن CAP اداله نومبور ڤد كاتس بسر ايكستينسي ها باڬي مڠلواركن كلاسن-كلاسن نڠ ساكيتار ك دالم كلاسن.اكو اكن دبري نام سابوءه كلاس (سايرن) وان ارري ايكستينسي.# >>> Strongest_Extension.call(""my_class"", [""AA"", ""Be"", ""CC""])
# ""my_class.AA""
def Strongest_Extension(class_name, extensions)
","def Strongest_Extension(class_name, extensions)
  strongest_extension = extensions.max_by do |extension|
    cap_count = extension.count('A-Z')
    sm_count = extension.count('a-z')
    cap_count - sm_count
  end
  ""#{class_name}.#{strongest_extension}""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_Strongest_Extension
    candidate = method(:Strongest_Extension)
    assert_equal(""Watashi.eIGHt8OKe"", candidate.call(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]))
    assert_equal(""Boku123.YEs.WeCaNe"", candidate.call(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]))
    assert_equal(""__YESIMHERE.NuLl__"", candidate.call(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]))
    assert_equal(""K.TAR"", candidate.call(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]))
    assert_equal(""__HAHA.123"", candidate.call(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]))
    assert_equal(""YameRore.okIWILL123"", candidate.call(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]))
    assert_equal(""finNNalLLly.WoW"", candidate.call(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]))
    assert_equal(""_.Bb"", candidate.call(""_"", [""Bb"", ""91245""]))
    assert_equal(""Sp.671235"", candidate.call(""Sp"", [""671235"", ""Bb""]))
  end
end
"
HumanEval_154,bjn_Arab,rb,"اندا دبري ٢ كات. اندا ڤرلو مروڤاكن ساءين سچارا سچارا اڤابيلا كات كدوا اتاو سابوءه ڤرتمبهنڽ اداله سابوتريڠ دالم كات ڤرتام.# >>> cycpattern_check.call(""abcd"", ""abd"")
# false
# >>> cycpattern_check.call(""hello"", ""ell"")
# true
# >>> cycpattern_check.call(""whassup"", ""psus"")
# false
# >>> cycpattern_check.call(""abab"", ""baa"")
# true
# >>> cycpattern_check.call(""efef"", ""eeff"")
# false
# >>> cycpattern_check.call(""himenss"", ""simen"")
# true
def cycpattern_check(a, b)
","def cycpattern_check(a, b)
  (0...b.length).each do |i|
    rotated_b = b[i..-1] + b[0...i]
    return true if a.include?(rotated_b)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_cycpattern_check
    candidate = method(:cycpattern_check)
    assert_equal(false, candidate.call(""xyzw"", ""xyw""))
    assert_equal(true, candidate.call(""yello"", ""ell""))
    assert_equal(false, candidate.call(""whattup"", ""ptut""))
    assert_equal(true, candidate.call(""efef"", ""fee""))
    assert_equal(false, candidate.call(""abab"", ""aabb""))
    assert_equal(true, candidate.call(""winemtt"", ""tinem""))
  end
end
"
HumanEval_155,bjn_Arab,rb,"چونتوه:ديبارياكن سابوءه انتيڬر، ماولاه سابوءه ارري نڠ باءيسي باڽق ديڬيت ڤرتاڠه وان ڤرتاڠه. # >>> even_odd_count.call(-12)
# [1, 1]
# >>> even_odd_count.call(123)
# [1, 2]
def even_odd_count(num)
","def even_odd_count(num)
  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_count
    candidate = method(:even_odd_count)
    assert_equal([0, 1], candidate.call(7))
    assert_equal([1, 1], candidate.call(-78))
    assert_equal([2, 2], candidate.call(3452))
    assert_equal([3, 3], candidate.call(346211))
    assert_equal([3, 3], candidate.call(-345821))
    assert_equal([1, 0], candidate.call(-2))
    assert_equal([2, 3], candidate.call(-45347))
    assert_equal([1, 0], candidate.call(0))
  end
end
"
HumanEval_156,bjn_Arab,rb,"چونتوه:ڤڠحرامن: 1 <= num <= 1000 وان رادعوه بحرف صغيرديبارياكن سابوءه انتيڬر ڤوسيتيف، ماولاه اكويۏيلن ارقام رومنڽ ساباڬاي ساءينر، # >>> int_to_mini_roman.call(19)
# ""xix""
# >>> int_to_mini_roman.call(152)
# ""clii""
# >>> int_to_mini_roman.call(426)
# ""cdxxvi""
def int_to_mini_roman(number)
","def int_to_mini_roman(number)
  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']

  result = ''
  values.each_with_index do |value, index|
    while number >= value
      number -= value
      result += numerals[index]
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_int_to_mini_roman
    candidate = method(:int_to_mini_roman)
    assert_equal(""xix"", candidate.call(19))
    assert_equal(""clii"", candidate.call(152))
    assert_equal(""ccli"", candidate.call(251))
    assert_equal(""cdxxvi"", candidate.call(426))
    assert_equal(""d"", candidate.call(500))
    assert_equal(""i"", candidate.call(1))
    assert_equal(""iv"", candidate.call(4))
    assert_equal(""xliii"", candidate.call(43))
    assert_equal(""xc"", candidate.call(90))
    assert_equal(""xciv"", candidate.call(94))
    assert_equal(""dxxxii"", candidate.call(532))
    assert_equal(""cm"", candidate.call(900))
    assert_equal(""cmxciv"", candidate.call(994))
    assert_equal(""m"", candidate.call(1000))
  end
end
"
HumanEval_157,bjn_Arab,rb,"چونتوه:90 دراج. سابوتيڠ تريڠݢول ريكت-اڠݢل اداله سابوتيڠ تريڠݢول نڠ سابوتيڠڽ اداله تريڠݢول ريكت اتاو ڤاسير-ڤاسيرڽ مانجادي سماس تريڠݢول باݢين راييك، كادا.ديتاهوءي كيرا-كيرا ترديري دري تيݢ بيدڠ دري سݢي تيݢ. ماولاه ڤرچاي جادي # >>> right_angle_triangle.call(3, 4, 5)
# true
# >>> right_angle_triangle.call(1, 2, 3)
# false
def right_angle_triangle(a, b, c)
","def right_angle_triangle(a, b, c)
  sides = [a, b, c].sort
  sides[0]**2 + sides[1]**2 == sides[2]**2
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_right_angle_triangle
    candidate = method(:right_angle_triangle)
    assert_equal(true, candidate.call(3, 4, 5))
    assert_equal(false, candidate.call(1, 2, 3))
    assert_equal(true, candidate.call(10, 6, 8))
    assert_equal(false, candidate.call(2, 2, 2))
    assert_equal(true, candidate.call(7, 24, 25))
    assert_equal(false, candidate.call(10, 5, 7))
    assert_equal(true, candidate.call(5, 12, 13))
    assert_equal(true, candidate.call(15, 8, 17))
    assert_equal(true, candidate.call(48, 55, 73))
    assert_equal(false, candidate.call(1, 1, 1))
    assert_equal(false, candidate.call(2, 2, 10))
  end
end
"
HumanEval_158,bjn_Arab,rb,"كاراكتر، مڽاتاكن كاراكتر نڠ ڤرتام دالم اوردين ليكسيكوڬرافي.اڤابيلا باڽق تاريق ماليه باڽق ارري بايسي كات-كات باسيڠ-باسيڠ. مڽاتاكن كات-كات دڠن ماكسيما كادأن منوليس فانسيون نڠ منچيڤتاكن سابوءه ارري دري ساءنجور.# >>> find_max.call([""name"", ""of"", ""string""])
# ""string""
# >>> find_max.call([""name"", ""enam"", ""game""])
# ""enam""
# >>> find_max.call([""aaaaaaa"", ""bb"", ""cc""])
# ""aaaaaaa""
def find_max(words)
","def find_max(words)
  # Helper function to count unique characters
  def unique_char_count(word)
    word.chars.uniq.size
  end

  words.max_by { |word| [unique_char_count(word), -word] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_max
    candidate = method(:find_max)
    assert_equal(""string"", candidate.call([""name"", ""of"", ""string""]))
    assert_equal(""enam"", candidate.call([""name"", ""enam"", ""game""]))
    assert_equal(""aaaaaaa"", candidate.call([""aaaaaaa"", ""bb"", ""cc""]))
    assert_equal(""abc"", candidate.call([""abc"", ""cba""]))
    assert_equal(""footbott"", candidate.call([""play"", ""this"", ""game"", ""of"", ""footbott""]))
    assert_equal(""gonna"", candidate.call([""we"", ""are"", ""gonna"", ""rock""]))
    assert_equal(""nation"", candidate.call([""we"", ""are"", ""a"", ""mad"", ""nation""]))
    assert_equal(""this"", candidate.call([""this"", ""is"", ""a"", ""prrk""]))
    assert_equal(""b"", candidate.call([""b""]))
    assert_equal(""play"", candidate.call([""play"", ""play"", ""play""]))
  end
end
"
HumanEval_159,bjn_Arab,rb,"چونتوه:اڤابيلا تيدق اد ماچم-ماچم كالي، اكو اكن ممبواڠ سموا ماچم-ماچم كالي، تاڤي ماسيه اكن كاو لاما.ڤندودوق ڤرݢيݢيت ڤد ڤاݢي تاهون ڤرتاماكو ڤرلو ممباوا سابوءه رينتڠ [كيرا-كيرا كسلوروهن كروت نڠ دڤاكاي ستله ڤاكاين، تاڤي كيني اكو ڤرلو ممباير لبيه باڽق كروت اونتوق ممباير ڤاكاي هاري اين.تو يه خرگوش گرسنه اي و تا حالا تعداد معين هويج خورده اي# >>> eat.call(5, 6, 10)
# [11, 4]
# >>> eat.call(4, 8, 9)
# [12, 1]
# >>> eat.call(1, 10, 10)
# [11, 0]
# >>> eat.call(2, 11, 5)
# [7, 0]
# Variables:
# @number : integer
# the number of carrots that you have eaten.
# @need : integer
# the number of carrots that you need to eat.
# @remaining : integer
# the number of remaining carrots thet exist in stock
# Constrain:
# * 0 <= number <= 1000
# * 0 <= need <= 1000
# * 0 <= remaining <= 1000
# Have fun :)
def eat(number, need, remaining)
","def eat(number, need, remaining)
  total_eaten = number + [need, remaining].min
  carrots_left = [remaining - need, 0].max
  [total_eaten, carrots_left]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_eat
    candidate = method(:eat)
    assert_equal([11, 4], candidate.call(5, 6, 10))
    assert_equal([12, 1], candidate.call(4, 8, 9))
    assert_equal([11, 0], candidate.call(1, 10, 10))
    assert_equal([7, 0], candidate.call(2, 11, 5))
    assert_equal([9, 2], candidate.call(4, 5, 7))
    assert_equal([5, 0], candidate.call(4, 5, 1))
  end
end
"
HumanEval_160,bjn_Arab,rb,"Array operator باحد اڤابيلا سابوه operator، وان operand array باحد اڤابيلا دوا اوڤرن.اوڤراند اداله ارري ڤد انتيڬر نڠ كادا نڠڬاتيف.باݢين ڤڠاجرن ڤڠاجرن اياله سام دڠن باݢين ڤڠاجرن ڤڠاجرن اوڤرن مڠناڤ ساتو.يادداشت:=> ننتيجه = 9 ننتيجه = ٢ + ٣ * ٤ - ٥ ارري = [٢،٣،٤،٥] ڤانوليس['+', '*', '-'] چونتوه:ايكسڤوننتاسي (**) ڤمباݢين دالم ( // ) ڤربوالن (* ) ڤڠكوتن ( - ) ڤمباوا (+) ڤرؤڤريسي جاجبر اساس:ڤانݢكامان ݢاسان ماولاهاكن ڤانݢكامان ݢاسان ماولاهاكن ڤانݢكامان ݢاسان ماولاهاكن ڤانݢكامان.ارري كدوا اداله ارري انتيجر. ڬونا كدوا ارري نڠ دبري ڬسن ممبينا ݢاريس الجبرديتاهن دوا اوڤراتور ارري، وان اوڤرند. ارري ڤرتام اد اوڤراتور الجبر اساس، وان def do_algebra(operator, operand)
","def do_algebra(operator, operand)
  expression = operand[0].to_s
  operator.each_with_index do |op, index|
    if op == '//'
      expression += ' / ' + operand[index + 1].to_s
    else
      expression += ' ' + op + ' ' + operand[index + 1].to_s
    end
  end
  eval(expression)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_do_algebra
    candidate = method(:do_algebra)
    assert_equal(37, candidate.call([""**"", ""*"", ""+""], [2, 3, 4, 5]))
    assert_equal(9, candidate.call([""+"", ""*"", ""-""], [2, 3, 4, 5]))
    assert_equal(8, candidate.call([""//"", ""*""], [7, 3, 4]))
  end
end
"
HumanEval_161,bjn_Arab,rb,"چونتوه فانسي ڤرلو مڽارڠ ساءورڠ تاريكن نڠ دأصلكن.اڤابيلا سݢرا تيدق ممباوا حروف، ڤوليه سݢرا.اڤاكه لاين تاڤي لاهير جادي.اڤابيلا s[i] اداله سابوءه حروف، مڠوروساكن كيسڽ دري لابه كاو لابه اتاو ڤاس ڤاس، اكو دبري ساءينت s. # >>> solve.call(""1234"")
# ""4321""
# >>> solve.call(""ab"")
# ""AB""
# >>> solve.call(""#a@C"")
# ""#A@c""
def solve(s)
","def solve(s)
  if s =~ /[a-zA-Z]/
    s.chars.map { |char| char =~ /[a-zA-Z]/ ? char.swapcase : char }.join
  else
    s.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""aSdF"", candidate.call(""AsDf""))
    assert_equal(""4321"", candidate.call(""1234""))
    assert_equal(""AB"", candidate.call(""ab""))
    assert_equal(""#A@c"", candidate.call(""#a@C""))
    assert_equal(""#aSDFw^45"", candidate.call(""#AsdfW^45""))
    assert_equal(""2@6#"", candidate.call(""#6@2""))
    assert_equal(""#$A^d"", candidate.call(""#$a^D""))
    assert_equal(""#CCC"", candidate.call(""#ccc""))
  end
end
"
HumanEval_162,bjn_Arab,rb,"اڤاکه 'تيكس' اداله ساتو ساءورڠ تار، مڽاتاكن nil. ديبارياكن سابوتيڠ سيكل 'تيكست', مڽاراكن سيكل ڤرڤادوان هاش md5ڽ. # >>> string_to_md5.call(""Hello world"")
# ""3e25960a79dbc69b674cd4ec67a72c62""
def string_to_md5(text)
","require 'digest'

def string_to_md5(text)
  return nil if text.empty?
  Digest::MD5.hexdigest(text)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_to_md5
    candidate = method(:string_to_md5)
    assert_equal(""3e25960a79dbc69b674cd4ec67a72c62"", candidate.call(""Hello world""))
    assert_equal(nil, candidate.call(""""))
    assert_equal(""0ef78513b0cb8cef12743f5aeb35f888"", candidate.call(""A B C""))
    assert_equal(""5f4dcc3b5aa765d61d8327deb882cf99"", candidate.call(""password""))
  end
end
"
HumanEval_163,bjn_Arab,rb,"چونتوهڽ: وان ب، دالم اورد نڠ باكال.ديتاهوءاكن دوا انتيڬره ڤوسيتيف a وان b، ماولاكن ديڬيت سمبيلن انتارا a # >>> generate_integers.call(2, 8)
# [2, 4, 6, 8]
# >>> generate_integers.call(8, 2)
# [2, 4, 6, 8]
# >>> generate_integers.call(10, 14)
# []
def generate_integers(a, b)
","def generate_integers(a, b)
  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_generate_integers
    candidate = method(:generate_integers)
    assert_equal([2, 4, 6, 8], candidate.call(2, 10))
    assert_equal([2, 4, 6, 8], candidate.call(10, 2))
    assert_equal([2, 4, 6, 8], candidate.call(132, 2))
    assert_equal([], candidate.call(17, 89))
  end
end
"
