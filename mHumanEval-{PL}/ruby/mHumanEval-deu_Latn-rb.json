[{"task_id":"HumanEval_0","nl":"deu_Latn","pl":"rb","prompt":"Die Einführung derPrüfen Sie, ob in einem gegebenen Array von Zahlen zwei Zahlen näher zueinander liegen als # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# true\ndef has_close_elements(numbers, threshold)\n","canonical_solution":"def has_close_elements(numbers, threshold)\n  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n  end\nend\n"},{"task_id":"HumanEval_1","nl":"deu_Latn","pl":"rb","prompt":"Die Leerzeichen in der Eingabezeichenfolge werden ignoriert.Die einzelnen Gruppen sind ausgeglichen (jede offene Halterung ist ordnungsgemäß geschlossen) und nicht ineinander eingebettet.Diese Gruppe in separate Zeichenfolgen trennen und das Array davon zurückgeben.Die Eingabe dieser Funktion ist eine Zeichenfolge mit mehreren Gruppen von eingebetteten Klammern.# >>> separate_paren_groups.call(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\ndef separate_paren_groups(paren_string)\n","canonical_solution":"def separate_paren_groups(paren_string)\n  # Remove spaces from the string\n  paren_string = paren_string.gsub(\" \", \"\")\n  \n  result = []\n  current_group = \"\"\n  balance = 0\n\n  paren_string.each_char do |char|\n    current_group += char\n    balance += 1 if char == '('\n    balance -= 1 if char == ')'\n\n    if balance == 0 && !current_group.empty?\n      result << current_group\n      current_group = \"\"\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_separate_paren_groups\n    candidate = method(:separate_paren_groups)\n    assert_equal([\"(()())\", \"((()))\", \"()\", \"((())()())\"], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([\"()\", \"(())\", \"((()))\", \"(((())))\"], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([\"(()(())((())))\"], candidate.call(\"(()(())((())))\"))\n    assert_equal([\"()\", \"(())\", \"(()())\"], candidate.call(\"( ) (( )) (( )( ))\"))\n  end\nend\n"},{"task_id":"HumanEval_2","nl":"deu_Latn","pl":"rb","prompt":"Gibt den Dezimalteil der Zahl zurück. (Überschussanteil immer kleiner als 1).und Ganzzahl (größte Ganzzahl kleiner als die angegebene Zahl) und Dezimalstellen Angesichts einer positiven Gleitkommazahl kann sie in  zerlegt werden.# >>> truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n","canonical_solution":"def truncate_number(number)\n  number - number.to_i\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n  end\nend\n"},{"task_id":"HumanEval_3","nl":"deu_Latn","pl":"rb","prompt":"An diesem Punkt sollte die Funktion true zurückgeben. Ansonsten sollte sie false zurückgeben. Ihre Aufgabe ist es, zu erkennen, ob der Kontostand irgendwann unter Null fällt und Sie erhalten eine Reihe von Ein- und Auszahlungsvorgängen auf einem Bankkonto, die mit  beginnen.# >>> below_zero.call([1, 2, 3])\n# false\n# >>> below_zero.call([1, 2, -4, 5])\n# true\ndef below_zero(operations)\n","canonical_solution":"def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_zero\n    candidate = method(:below_zero)\n    assert_equal(false, candidate.call([]))\n    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))\n    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))\n    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))\n    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))\n    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))\n  end\nend\n"},{"task_id":"HumanEval_4","nl":"deu_Latn","pl":"rb","prompt":"MAD = Durchschnitt. x - x_mean.Element und Mittelpunkt (in diesem Fall Mittelwert): Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen den beiden Die Daten sind in der Regel in der Mitte dieses Datensatzes.Für ein gegebenes Array von Eingangszahlen berechnen Sie die mittlere absolute Abweichung # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n# 1.0\ndef mean_absolute_deviation(numbers)\n","canonical_solution":"def mean_absolute_deviation(numbers)\n  mean = numbers.sum.to_f \/ numbers.size\n  deviations = numbers.map { |num| (num - mean).abs }\n  deviations.sum \/ numbers.size\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0, 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"},{"task_id":"HumanEval_5","nl":"deu_Latn","pl":"rb","prompt":"Zwischen zwei aufeinanderfolgenden Elementen des Eingabearrays ∀numbers\"  ein Zahlenzeichen \"Abgrenzungszeichen\" einfügen.# >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n","canonical_solution":"def intersperse(numbers, delimeter)\n  return numbers if numbers.empty?\n  result = []\n  numbers.each_with_index do |num, index|\n    result << num\n    result << delimeter unless index == numbers.size - 1\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"},{"task_id":"HumanEval_6","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel hat (() (()) maximal zwei Niststufen, während ((())) drei hat. Für jede Gruppe wird die tiefste Ebene der Verankerung von Klammern angegeben. Die Eingabe dieser Funktion ist eine Zeichenfolge, die mehrere Gruppen für eingebettete Klammern darstellt, die durch Leerzeichen getrennt sind.# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n","canonical_solution":"def parse_nested_parens(paren_string)\n  paren_string.split.map do |group|\n    max_depth = current_depth = 0\n    group.chars.each do |char|\n      if char == '('\n        current_depth += 1\n        max_depth = [max_depth, current_depth].max\n      elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"))\n  end\nend\n"},{"task_id":"HumanEval_7","nl":"deu_Latn","pl":"rb","prompt":"Filtern Sie ein Eingabearray nur für Zeichenfolgen, die eine bestimmte Unterzeile enthalten.# >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\ndef filter_by_substring(strings, substring)\n","canonical_solution":"def filter_by_substring(strings, substring)\n  strings.select { |string| string.include?(substring) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"))\n  end\nend\n"},{"task_id":"HumanEval_8","nl":"deu_Latn","pl":"rb","prompt":"Die Summe der leeren Zahlen sollte 0 und das Produkt der leeren Zahlen 1 sein.Für ein gegebenes Array von Ganzzahlen gibt ein Array zurück, das aus einer Summe und einem Produkt aller Ganzzahlen in einem Array besteht. # >>> sum_product.call([])\n# [0, 1]\n# >>> sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n","canonical_solution":"def sum_product(numbers)\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0], candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"},{"task_id":"HumanEval_9","nl":"deu_Latn","pl":"rb","prompt":"in der Reihenfolge.Aus einem gegebenen Array von Ganzen erzeugen wir ein Array mit dem bis zu einem gegebenen Moment gefundenen rollenden Maximalelement.# >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n","canonical_solution":"def rolling_max(numbers)\n  max_so_far = numbers.first\n  numbers.map do |num|\n    max_so_far = [max_so_far, num].max\n  end\nend\n\n# Example usage:\n# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"},{"task_id":"HumanEval_10","nl":"deu_Latn","pl":"rb","prompt":"- Fügen Sie am Ende der String-Rückseite ein String-Präfix hinzu, das vor dem palindromen Suffix kommt.- Finden Sie den längsten Postfix der angegebenen Zeichenfolge, der ein Palindrom ist. Die Idee des Algorithmus ist einfach:Finden Sie das kürzeste Palindrom, das mit einer angegebenen Zeichenfolge beginnt. # >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n","canonical_solution":"def make_palindrome(string)\n  return string if string.empty?\n\n  def is_palindrome?(s)\n    s == s.reverse\n  end\n\n  (0...string.length).reverse_each do |i|\n    if is_palindrome?(string[i..-1])\n      return string + string[0...i].reverse\n    end\n  end\n\n  string\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\", candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"},{"task_id":"HumanEval_11","nl":"deu_Latn","pl":"rb","prompt":"Führen Sie die binäre XOR auf diesen Eingängen aus und geben Sie das Ergebnis auch als Zeichenfolge zurück. Input sind zwei Zeichenketten a und b, die nur aus 1er und 0er bestehen.# >>> string_xor.call(\"010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n","canonical_solution":"def string_xor(a, b)\n  result = \"\"\n  a.length.times do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"},{"task_id":"HumanEval_12","nl":"deu_Latn","pl":"rb","prompt":"Gibt null zurück, wenn das Eingabearray leer ist.Aus einer Reihe von Zeichenfolgen gibt man den längsten zurück.# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n","canonical_solution":"def longest(strings)\n  return nil if strings.empty?\n  strings.max_by(&:length)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n    assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n  end\nend\n"},{"task_id":"HumanEval_13","nl":"deu_Latn","pl":"rb","prompt":"Gibt den größten gemeinsamen Teiler zweier ganzer Zahlen a und b zurück # >>> greatest_common_divisor.call(3, 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a, b)\n","canonical_solution":"def greatest_common_divisor(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3, 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49, 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"},{"task_id":"HumanEval_14","nl":"deu_Latn","pl":"rb","prompt":"Gibt ein Array mit allen Präfixen von der kürzesten bis zur längsten Eingabezeichenfolge zurück.# >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n","canonical_solution":"def all_prefixes(string)\n  (1..string.length).map { |i| string[0, i] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"], candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"WWW\"))\n  end\nend\n"},{"task_id":"HumanEval_15","nl":"deu_Latn","pl":"rb","prompt":"Gibt eine Zeichenfolge mit räumlich begrenzten Zahlen ab, die von 0 bis einschließlich n beginnt. # >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n# \"0 1 2 3 4 5\"\ndef string_sequence(n)\n","canonical_solution":"def string_sequence(n)\n  (0..n).to_a.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_16","nl":"deu_Latn","pl":"rb","prompt":"Finden Sie bei einer Zeichenfolge heraus, wie viele verschiedene Zeichen (unabhängig vom Großbuchstaben) sie enthält.# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n","canonical_solution":"def count_distinct_characters(string)\n  string.downcase.chars.uniq.count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5, candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"},{"task_id":"HumanEval_17","nl":"deu_Latn","pl":"rb","prompt":"\"Häuschen\" - Viertelnoten, dauert einen Takt.\"O\" hat eine halbe Note, dauert zwei Schläge.\"O\" - ganze Note, dauert vier Schläge.Hier ist eine Legende:Nicht zuletzt.Ihre Aufgabe ist es , diese Zeichenfolge zu analysieren und eine Reihe von Ganzzahlen zurückzugeben , die dem Anzahl der Schläge entsprechen .Die Eingabe dieser Funktion ist eine Zeichenfolge, die Musiknoten in einem speziellen ASCII-Format darstellt.# >>> parse_music.call(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n","canonical_solution":"def parse_music(music_string)\n  # Split the input string into individual notes.\n  notes = music_string.split\n\n  # Map each note to its corresponding number of beats.\n  notes.map do |note|\n    case note\n    when 'o'\n      4\n    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1, 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"},{"task_id":"HumanEval_18","nl":"deu_Latn","pl":"rb","prompt":"Finden Sie heraus, wie oft eine bestimmte Unterkette in der ursprünglichen Kette zu finden ist. Zählen Sie die sich überlappenden Fälle. # >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring)\n","canonical_solution":"def how_many_times(string, substring)\n  return 0 if substring.empty?\n  count = 0\n  i = 0\n  while i <= string.length - substring.length\n    if string[i, substring.length] == substring\n      count += 1\n    end\n    i += 1\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\", \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4, candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"john doe\", \"john\"))\n  end\nend\n"},{"task_id":"HumanEval_19","nl":"deu_Latn","pl":"rb","prompt":"Gibt die Zeichenfolge mit Zahlen zurück , die von kleinster zu größter sortiert sind .Die gültigen Optionen sind \"Null\", \"Ein\", \"Zwei\", \"Drei\", \"Vier\", \"Fünf\", \"Sechse\", \"Sieben\", \"Acht\" und \"Neun\". Der Eingang ist eine räumlich begrenzte Zeichenfolge von Ziffern von \"Null\" bis \"Neun\".# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef sort_numbers(numbers)\n","canonical_solution":"def sort_numbers(numbers)\n  numeral_map = {\n    'zero' => 0,\n    'one' => 1,\n    'two' => 2,\n    'three' => 3,\n    'four' => 4,\n    'five' => 5,\n    'six' => 6,\n    'seven' => 7,\n    'eight' => 8,\n    'nine' => 9\n  }\n\n  number_words = numbers.split\n  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }\n  sorted_numbers.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six five four three two one zero\"))\n  end\nend\n"},{"task_id":"HumanEval_20","nl":"deu_Latn","pl":"rb","prompt":"Die Zahl der Zahlen, die in der Tabelle angegeben sind, ist in der Reihenfolge der Zahlen zu wiedergeben (kleine Zahl, größere Zahl).Aus einem vorgegebenen Array von Zahlen (mindestens zwei) wählen und geben Sie zwei aus, die sich jedem am nächsten befinden.# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n","canonical_solution":"def find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs\n\n  (1...(sorted_numbers.length - 1)).each do |i|\n    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs\n    if current_difference < min_difference\n      min_difference = current_difference\n      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    end\n  end\n\n  closest_pair\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n"},{"task_id":"HumanEval_21","nl":"deu_Latn","pl":"rb","prompt":"So dass die kleinste Zahl 0 und die größte 1 wird .Angesichts eines Arrays von Zahlen (von mindestens zwei Elementen) wird eine lineare Transformation auf dieses Array angewendet, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n","canonical_solution":"def rescale_to_unit(numbers)\n  min = numbers.min\n  max = numbers.max\n  range = max - min\n  return numbers.map { |num| (num - min) \/ range.to_f }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\nend\n"},{"task_id":"HumanEval_22","nl":"deu_Latn","pl":"rb","prompt":"Filter nur für ganze Zahlen aus einem gegebenen Array mit beliebigen rbthon-Werten # >>> filter_integers.call([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\ndef filter_integers(values)\n","canonical_solution":"def filter_integers(values)\n  values.select { |value| value.is_a?(Integer) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n    assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\nend\n"},{"task_id":"HumanEval_23","nl":"deu_Latn","pl":"rb","prompt":"Rückgabe der Länge der angegebenen Zeichenfolge # >>> strlen.call(\"\")\n# 0\n# >>> strlen.call(\"abc\")\n# 3\ndef strlen(string)\n","canonical_solution":"strlen = lambda do |string|\n  string.length\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"asdasnakj\"))\n  end\nend\n"},{"task_id":"HumanEval_24","nl":"deu_Latn","pl":"rb","prompt":"Finden Sie für eine gegebene Zahl n die größte Zahl, die n gleichmäßig teilt, kleiner als n # >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n","canonical_solution":"def largest_divisor(n)\n  (n - 1).downto(1) do |i|\n    return i if n % i == 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n  end\nend\n"},{"task_id":"HumanEval_25","nl":"deu_Latn","pl":"rb","prompt":"Die Eingabezahl sollte gleich dem Produkt aller Faktoren sein.Jeder Faktor sollte so angeordnet werden, dass er in der Faktorisierung erscheint.Gibt ein Array von Primfaktoren einer bestimmten ganzen Zahl in der Reihenfolge von kleinsten bis größten zurück.# >>> factorize.call(8)\n# [2, 2, 2]\n# >>> factorize.call(25)\n# [5, 5]\n# >>> factorize.call(70)\n# [2, 5, 7]\ndef factorize(n)\n","canonical_solution":"def factorize(n)\n  factors = []\n  divisor = 2\n  while n > 1\n    while n % divisor == 0\n      factors << divisor\n      n \/= divisor\n    end\n    divisor += 1\n  end\n  factors\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_factorize\n    candidate = method(:factorize)\n    assert_equal([2], candidate.call(2))\n    assert_equal([2, 2], candidate.call(4))\n    assert_equal([2, 2, 2], candidate.call(8))\n    assert_equal([3, 19], candidate.call(57))\n    assert_equal([3, 3, 19, 19], candidate.call(3249))\n    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))\n    assert_equal([3, 19, 19, 19], candidate.call(20577))\n    assert_equal([2, 3, 3], candidate.call(18))\n  end\nend\n"},{"task_id":"HumanEval_26","nl":"deu_Latn","pl":"rb","prompt":"Die Reihenfolge der Elemente bleibt die gleiche wie bei der Eingabe.Entfernen Sie aus einem Array von Ganzzahlen alle Elemente, die mehr als einmal vorkommen. # >>> remove_duplicates.call([1, 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n","canonical_solution":"def remove_duplicates(numbers)\n  numbers.select { |num| numbers.count(num) == 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"},{"task_id":"HumanEval_27","nl":"deu_Latn","pl":"rb","prompt":"Für eine bestimmte Zeichenfolge, kleine Zeichen in Großbuchstaben und Großbuchstaben in kleine Buchstaben umschlagen. # >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n","canonical_solution":"def flip_case(string)\n  string.swapcase\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights have violent ends\"))\n  end\nend\n"},{"task_id":"HumanEval_28","nl":"deu_Latn","pl":"rb","prompt":"Eine Reihe von Zeichenketten in einer einzigen Zeichenkette zusammenführen .# >>> concatenate.call([])\n# \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n","canonical_solution":"def concatenate(strings)\n  strings.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"},{"task_id":"HumanEval_29","nl":"deu_Latn","pl":"rb","prompt":"Filtern Sie ein Eingabearray nur für Zeichenfolgen, die mit einem bestimmten Präfix beginnen. # >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings, prefix)\n","canonical_solution":"def filter_by_prefix(strings, prefix)\n  strings.select { |string| string.start_with?(prefix) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\nend\n"},{"task_id":"HumanEval_30","nl":"deu_Latn","pl":"rb","prompt":"Gibt nur positive Zahlen im Array zurück.# >>> get_positive.call([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n","canonical_solution":"get_positive = lambda do |l|\n  l.select { |num| num > 0 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1, -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_31","nl":"deu_Latn","pl":"rb","prompt":"Gibt die Funktion true zurück, wenn eine gegebene Zahl prim ist, und false, wenn sie nicht prim ist.# >>> is_prime.call(6)\n# false\n# >>> is_prime.call(101)\n# true\n# >>> is_prime.call(11)\n# true\n# >>> is_prime.call(13441)\n# true\n# >>> is_prime.call(61)\n# true\n# >>> is_prime.call(4)\n# false\n# >>> is_prime.call(1)\n# false\ndef is_prime(n)\n","canonical_solution":"is_prime = lambda do |n|\n  return false if n <= 1\n  return true if n == 2\n  return false if n.even?\n\n  max_divisor = Math.sqrt(n).to_i\n  (3..max_divisor).step(2).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_prime\n    candidate = method(:is_prime)\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(101))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(13441))\n    assert_equal(true, candidate.call(61))\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(1))\n    assert_equal(true, candidate.call(5))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(17))\n    assert_equal(false, candidate.call(85))\n    assert_equal(false, candidate.call(77))\n    assert_equal(false, candidate.call(255379))\n  end\nend\n"},{"task_id":"HumanEval_33","nl":"deu_Latn","pl":"rb","prompt":"Die Werte der entsprechenden Indizes von l, aber sortiert.l' ist bei den nicht durch drei teilbaren Indizes identisch mit l, während seine Werte bei den durch drei teilbaren Indizes gleich sind Diese Funktion nimmt ein Array l und gibt ein Array l' zurück, so dass # >>> sort_third.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n","canonical_solution":"def sort_third(l)\n  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort\n  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"},{"task_id":"HumanEval_34","nl":"deu_Latn","pl":"rb","prompt":"Gibt sortierte eindeutige Elemente in einem Array zurück .# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n","canonical_solution":"def unique(l)\n  l.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_35","nl":"deu_Latn","pl":"rb","prompt":"Gibt das maximale Element im Array zurück.# >>> max_element.call([1, 2, 3])\n# 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n","canonical_solution":"def max_element(l)\n  l.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2, 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))\n  end\nend\n"},{"task_id":"HumanEval_36","nl":"deu_Latn","pl":"rb","prompt":"Gibt die Anzahl der Auftritte der Ziffer 7 in ganzen Zahlen kleiner als n zurück, die durch 11 oder 13 teilbar sind. # >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n# 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n","canonical_solution":"def fizz_buzz(n)\n  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 || i % 13 == 0\n      count += i.to_s.count('7')\n    end\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n    assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n    assert_equal(8026, candidate.call(100000))\n  end\nend\n"},{"task_id":"HumanEval_37","nl":"deu_Latn","pl":"rb","prompt":"Die Werte der geraden Indizes von l sind jedoch sortiert.l' ist bei den ungeraden Indizes identisch mit l, während seine Werte bei den geraden Indizes gleich sind.Diese Funktion nimmt ein Array l und gibt ein Array l' zurück, so dass # >>> sort_even.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n","canonical_solution":"def sort_even(l)\n  even_indices = l.each_index.select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  \n  even_index = 0\n  l.each_with_index.map do |value, index|\n    if index.even?\n      even_values[even_index].tap { even_index += 1 }\n    else\n      value\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\nend\n"},{"task_id":"HumanEval_39","nl":"deu_Latn","pl":"rb","prompt":"prime_fib gibt die n-te Zahl zurück, die eine Fibonacci-Zahl ist und auch eine Primzahl ist. # >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n# 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n","canonical_solution":"def prime_fib(n)\n  require 'prime'\n  \n  fibs = Enumerator.new do |y|\n    a, b = 0, 1\n    loop do\n      a, b = b, a + b\n      y << b\n    end\n  end\n  \n  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }\n  prime_fibs.first(n).last\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n    assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n    assert_equal(433494437, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_40","nl":"deu_Latn","pl":"rb","prompt":"Summe auf Null und ansonsten falsch.Es gibt drei verschiedene Elemente in dem Array, die triples_sum_to_zero nimmt ein Array von Ganzzahlen als Eingabe.# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n# >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n","canonical_solution":"def triples_sum_to_zero(l)\n  n = l.length\n  (0...n-2).each do |i|\n    ((i+1)...n-1).each do |j|\n      ((j+1)...n).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false, candidate.call([100, 3, 5, -100]))\n  end\nend\n"},{"task_id":"HumanEval_41","nl":"deu_Latn","pl":"rb","prompt":"Diese Funktion gibt die Anzahl solcher Kollisionen aus. Sie sind in ihrer Flugbahn, als ob sie nicht kollidieren.Die Wagen sind jedoch unendlich robust und stark, und deshalb fahren sie weiter.Wenn ein Auto, das sich von links nach rechts bewegt, ein Auto trifft, das sich von rechts nach links bewegt.Alle Autos bewegen sich mit der gleichen Geschwindigkeit.Die beiden Autos starten sehr weit von dern Autos fahren von links nach rechts; gleichzeitig eine andere Gruppe von n Autos Stellen Sie sich eine Straße vor, die eine perfekt gerade, unendlich lange Linie ist.def car_race_collision(n)\n","canonical_solution":"def car_race_collision(n)\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_42","nl":"deu_Latn","pl":"rb","prompt":"Gibt ein Array mit Elementen zurück, die um 1 erhöht werden.# >>> incr_list.call([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n","canonical_solution":"def incr_list(l)\n  l.map { |x| x + 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_43","nl":"deu_Latn","pl":"rb","prompt":"Summe auf Null und ansonsten falsch.Es gibt zwei verschiedene Elemente in dem Array, die pairs_sum_to_zero nimmt ein Array von Ganzzahlen als Eingabe. # >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1, 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n# false\ndef pairs_sum_to_zero(l)\n","canonical_solution":"def pairs_sum_to_zero(l)\n  num_set = l.to_set\n  l.each do |num|\n    return true if num != 0 && num_set.include?(-num)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"},{"task_id":"HumanEval_44","nl":"deu_Latn","pl":"rb","prompt":"Die Basiszahlen sind kleiner als 10.Rückgabe einer Zeichenfolge nach der Umwandlung.Ändern Sie die numerische Basis der Eingabezahl x in die Basis.# >>> change_base.call(8, 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7, 2)\n# \"111\"\ndef change_base(x, base)\n","canonical_solution":"def change_base(x, base)\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits << (x % base).to_s\n    x \/= base\n  end\n  digits.reverse.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8, 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\", candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7, 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3, 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5, 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7, 8))\n  end\nend\n"},{"task_id":"HumanEval_45","nl":"deu_Latn","pl":"rb","prompt":"Die Länge einer Seite und die hohe Rückkehrfläche eines Dreiecks.# >>> triangle_area.call(5, 3)\n# 7.5\ndef triangle_area(a, h)\n","canonical_solution":"def triangle_area(a, h)\n  (a * h) \/ 2.0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(7.5, candidate.call(5, 3))\n    assert_equal(2.0, candidate.call(2, 2))\n    assert_equal(40.0, candidate.call(10, 8))\n  end\nend\n"},{"task_id":"HumanEval_46","nl":"deu_Latn","pl":"rb","prompt":"Bitte schreiben Sie eine Funktion, um das n-te Element der fib4-Zahlfolge effizient zu berechnen.Die in der Tabelle aufgeführten Angaben sind in der Tabelle zu finden.Die Kommission hat die folgenden Maßnahmen angenommen:Die Ausnahme gilt für dieDie Zahl derDie Zahl derDie Fib4-Zahlenabfolge ist eine Sequenz, die der Fibbonacci-Sequenz ähnelt und wie folgt definiert wird: # >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>> fib4.call(7)\n# 14\ndef fib4(n)\n","canonical_solution":"def fib4(n)\n  return 0 if n == 0 || n == 1 || n == 3\n  return 2 if n == 2\n\n  fib4_seq = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n  end\n  fib4_seq[n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28, candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_47","nl":"deu_Latn","pl":"rb","prompt":"Rückgabe des Medians der Elemente im Array l. # >>> median.call([3, 1, 2, 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n","canonical_solution":"def median(l)\n  sorted = l.sort\n  len = sorted.length\n  if len.odd?\n    sorted[len \/ 2]\n  else\n    (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2.0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5, candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"},{"task_id":"HumanEval_48","nl":"deu_Latn","pl":"rb","prompt":"Prüft, ob die angegebene Zeichenfolge ein Palindrom ist.# >>> is_palindrome.call(\"\")\n# true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\")\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n","canonical_solution":"is_palindrome = lambda do |text|\n  text == text.reverse\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true, candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"},{"task_id":"HumanEval_49","nl":"deu_Latn","pl":"rb","prompt":"Gibt 2^n modulo p zurück (beachten Sie die Zahlen).# >>> modp.call(3, 5)\n# 3\n# >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3, 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n","canonical_solution":"def modp(n, p)\n  return 1 if p == 1\n  2.pow(n, p)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"},{"task_id":"HumanEval_51","nl":"deu_Latn","pl":"rb","prompt":"remove_vowels ist eine Funktion, die String nimmt und String ohne Vokale zurückgibt. # >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n","canonical_solution":"def remove_vowels(text)\n  text.delete('aeiouAEIOU')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\", candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\", candidate.call(\"ybcd\"))\n  end\nend\n"},{"task_id":"HumanEval_52","nl":"deu_Latn","pl":"rb","prompt":"Gibt die Funktion true zurück, wenn alle Zahlen im Array l unterhalb der Schwelle t liegen. # >>> below_threshold.call([1, 2, 4, 10], 100)\n# true\n# >>> below_threshold.call([1, 20, 4, 10], 5)\n# false\ndef below_threshold(l, t)\n","canonical_solution":"def below_threshold(l, t)\n  l.all? { |num| num < t }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_threshold\n    candidate = method(:below_threshold)\n    assert_equal(true, candidate.call([1, 2, 4, 10], 100))\n    assert_equal(false, candidate.call([1, 20, 4, 10], 5))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 21))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 22))\n    assert_equal(true, candidate.call([1, 8, 4, 10], 11))\n    assert_equal(false, candidate.call([1, 8, 4, 10], 10))\n  end\nend\n"},{"task_id":"HumanEval_53","nl":"deu_Latn","pl":"rb","prompt":"Addiere zwei Zahlen x und y.# >>> add.call(2, 3)\n# 5\n# >>> add.call(5, 7)\n# 12\ndef add(x, y)\n","canonical_solution":"add = ->(x, y) { x + y }","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(1, candidate.call(0, 1))\n    assert_equal(1, candidate.call(1, 0))\n    assert_equal(5, candidate.call(2, 3))\n    assert_equal(12, candidate.call(5, 7))\n    assert_equal(12, candidate.call(7, 5))\n  end\nend\n"},{"task_id":"HumanEval_54","nl":"deu_Latn","pl":"rb","prompt":"Prüfen Sie, ob zwei Wörter die gleichen Zeichen haben. # >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n# >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# false\ndef same_chars(s0, s1)\n","canonical_solution":"def same_chars(s0, s1)\n  s0.chars.uniq.all? { |char| s1.include?(char) } &&\n  s1.chars.uniq.all? { |char| s0.include?(char) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false, candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"))\n  end\nend\n"},{"task_id":"HumanEval_55","nl":"deu_Latn","pl":"rb","prompt":"Gib die n-te Fibonacci-Zahl zurück. # >>> fib.call(10)\n# 55\n# >>> fib.call(1)\n# 1\n# >>> fib.call(8)\n# 21\ndef fib(n)\n","canonical_solution":"def fib(n)\n  return n if n <= 1\n  fib(n - 1) + fib(n - 2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89, candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_56","nl":"deu_Latn","pl":"rb","prompt":"return true, wenn jede Öffnungs-Klammer eine entsprechende Schließklammer hat. brackets ist eine Zeichenfolge von \"<\" und \">\". # >>> correct_bracketing.call(\"<\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"<<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.chars.each do |char|\n    if char == '<'\n      balance += 1\n    elsif char == '>'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"<>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true, candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false, candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n    assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\">\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>>><>\"))\n  end\nend\n"},{"task_id":"HumanEval_57","nl":"deu_Latn","pl":"rb","prompt":"Gibt zurück, wenn die Array-Elemente monoton zunehmen oder abnehmen.# >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n# false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n","canonical_solution":"def monotonic(l)\n  increasing = true\n  decreasing = true\n\n  (0...l.length - 1).each do |i|\n    if l[i] < l[i + 1]\n      decreasing = false\n    elsif l[i] > l[i + 1]\n      increasing = false\n    end\n  end\n\n  increasing || decreasing\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2, 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false, candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1, 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\nend\n"},{"task_id":"HumanEval_58","nl":"deu_Latn","pl":"rb","prompt":"Gibt sortierte einzigartige gemeinsame Elemente für zwei Arrays zurück. # >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n","canonical_solution":"def common(l1, l2)\n  (l1 & l2).uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"},{"task_id":"HumanEval_59","nl":"deu_Latn","pl":"rb","prompt":"Gib den größten Primfaktor von n zurück. Angenommen, n > 1 ist kein Primzahl. # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n# 2\ndef largest_prime_factor(n)\n","canonical_solution":"def largest_prime_factor(n)\n  factor = 2\n  while factor * factor <= n\n    if n % factor == 0\n      n \/= factor\n    else\n      factor += 1\n    end\n  end\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n  end\nend\n"},{"task_id":"HumanEval_60","nl":"deu_Latn","pl":"rb","prompt":"sum_to_n ist eine Funktion, die Zahlen von 1 bis n addiert. # >>> sum_to_n.call(30)\n# 465\n# >>> sum_to_n.call(100)\n# 5050\n# >>> sum_to_n.call(5)\n# 15\n# >>> sum_to_n.call(10)\n# 55\n# >>> sum_to_n.call(1)\n# 1\ndef sum_to_n(n)\n","canonical_solution":"def sum_to_n(n)\n  (1..n).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_61","nl":"deu_Latn","pl":"rb","prompt":"return true, wenn jede Öffnungs-Klammer eine entsprechende Schließklammer hat. brackets ist eine Zeichenfolge von \"(\" und \")\". # >>> correct_bracketing.call(\"(\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"(()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.each_char do |char|\n    if char == '('\n      balance += 1\n    elsif char == ')'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true, candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false, candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n    assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\")\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false, candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"()()(()())()))()\"))\n  end\nend\n"},{"task_id":"HumanEval_62","nl":"deu_Latn","pl":"rb","prompt":"Gibt die Ableitung dieses Polynoms in der gleichen Form zurück.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs repräsentieren die Koeffizienten eines Polynoms.# >>> derivative.call([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative.call([1, 2, 3])\n# [2, 6]\ndef derivative(xs)\n","canonical_solution":"def derivative(xs)\n  return [] if xs.length < 2\n  xs.each_with_index.map { |coef, index| coef * index }[1..-1]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2, 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_63","nl":"deu_Latn","pl":"rb","prompt":"Bitte schreiben Sie eine Funktion, um das n-te Element der fibfib-Zahlfolge effizient zu berechnen. Die Zellen sind in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der Regel in der RegelDie Ausnahme gilt für dieDie Kommission hat dieDie Zulassung ist abgeschlossen.Die FibFib-Zahlenabfolge ist eine Sequenz, die der Fibbonacci-Sequenz ähnelt und wie folgt definiert wird: # >>> fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef fibfib(n)\n","canonical_solution":"def fibfib(n)\n  return 0 if n == 0 || n == 1\n  return 1 if n == 2\n\n  a, b, c = 0, 0, 1\n  (3..n).each do\n    a, b, c = b, c, a + b + c\n  end\n  c\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0, candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24, candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274, candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"},{"task_id":"HumanEval_64","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Vokal, aber nur wenn es am Ende des Wortes steht.Die Vokale in diesem Fall sind \"a\", \"e\", \"i\", \"o\", \"u\". Hier ist \"y\" auch ein ein Wort als Eingabe und gibt die Anzahl der Vokale in der Zeichenfolge zurück. Schreiben Sie eine Funktion vowels_count, die eine Zeichenfolge repräsentiert, die # >>> vowels_count.call(\"abcde\")\n# 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n","canonical_solution":"def vowels_count(s)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  \n  s.chars.each_with_index do |char, index|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif char.downcase == 'y' && index == s.length - 1\n      count += 1\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"ACEDY\"))\n  end\nend\n"},{"task_id":"HumanEval_65","nl":"deu_Latn","pl":"rb","prompt":"Wenn shift > Zahl der Ziffern, Rückgabe der Ziffern umgekehrt. und gibt das Ergebnis als Zeichenkette zurück. Kreisförmig verschieben die Ziffern der ganzen Zahl x, verschieben die Ziffern nach rechts durch Verschiebung # >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12, 2)\n# \"12\"\ndef circular_shift(x, shift)\n","canonical_solution":"def circular_shift(x, shift)\n  digits = x.to_s.chars\n  num_digits = digits.length\n\n  if shift > num_digits\n    return digits.reverse.join\n  else\n    shift = shift % num_digits\n    shifted_digits = digits.rotate(-shift)\n    return shifted_digits.join\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100, 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\", candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"11\", candidate.call(11, 101))\n  end\nend\n"},{"task_id":"HumanEval_66","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: ASCII-Codes. Schreiben Sie eine Funktion, die einen String als Eingabe nimmt und nur die Summe der oberen Zeichen zurückgibt' Aufgabe # >>> digitSum.call(\"\")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n# 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n# 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n","canonical_solution":"def digitSum(s)\n  s.chars.select { |char| char =~ \/[A-Z]\/ }.map(&:ord).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131, candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327, candidate.call(\"You arE Very Smart\"))\n  end\nend\n"},{"task_id":"HumanEval_67","nl":"deu_Latn","pl":"rb","prompt":"für Exambel: in dem Korb gibt die Anzahl der Mangofrüchte im Korb zurück. die Orangen und Äpfel und eine ganze Zahl , die die Gesamtzahl der Früchte darstellt Angesichts der Zeichenfolge, die die Gesamtzahl von Die Verteilung erfolgt in einem Korb mit Obst, der in diesem Korb enthalten ist.In dieser Aufgabe erhalten Sie eine Zeichenfolge, die eine Anzahl von Äpfeln und Orangen darstellt.# >>> fruit_distribution.call(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution.call(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution.call(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution.call(\"100 apples and 1 oranges\", 120)\n# 19\ndef fruit_distribution(s, n)\n","canonical_solution":"def fruit_distribution(s, n)\n  numbers = s.scan(\/\\d+\/).map(&:to_i)\n  apples = numbers[0]\n  oranges = numbers[1]\n  total_fruits = n\n  mangos = total_fruits - (apples + oranges)\n  mangos\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fruit_distribution\n    candidate = method(:fruit_distribution)\n    assert_equal(8, candidate.call(\"5 apples and 6 oranges\", 19))\n    assert_equal(10, candidate.call(\"5 apples and 6 oranges\", 21))\n    assert_equal(2, candidate.call(\"0 apples and 1 oranges\", 3))\n    assert_equal(2, candidate.call(\"1 apples and 0 oranges\", 3))\n    assert_equal(95, candidate.call(\"2 apples and 3 oranges\", 100))\n    assert_equal(0, candidate.call(\"2 apples and 3 oranges\", 5))\n    assert_equal(19, candidate.call(\"1 apples and 100 oranges\", 120))\n  end\nend\n"},{"task_id":"HumanEval_68","nl":"deu_Latn","pl":"rb","prompt":"Beispiel 1: Wenn keine paren Werte vorhanden sind oder das angegebene Array leer ist, wird [] zurückgegeben.Der gezupfte Knoten sollte in einem Array, [ smalest_value, seinem Index ],  zurückgegeben werden.Wenn mehrere Knoten mit dem gleichen kleinsten Parwert gefunden werden, wird der Knoten mit dem kleinsten Index zurückgegeben. Der gezupfte Knoten sollte der Knoten mit dem kleinsten geraden Wert sein.Ihre Aufgabe ist es, einen der Knoten zu pflücken und ihn zurückzugeben.\"Angesichts eines Arrays, der einen Zweig eines Baumes repräsentiert, der nicht-negative Ganzzahlknoten hat # >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>> pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n","canonical_solution":"def pluck(arr)\n  smallest_even = nil\n  smallest_index = nil\n  \n  arr.each_with_index do |value, index|\n    if value.even?\n      if smallest_even.nil? || value < smallest_even\n        smallest_even = value\n        smallest_index = index\n      end\n    end\n  end\n\n  smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"},{"task_id":"HumanEval_69","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Wenn kein solcher Wert vorhanden ist, wird -1 zurückgegeben.Die Häufigkeit einer ganzen Zahl ist die Anzahl der Male, die sie im Array erscheint.Die Zahl ist gleich dem Wert der ganzen Zahl selbst.Gibt man Ihnen ein nicht leeres Array von positiven ganzen Zahlen, gibt man die größte ganze Zahl zurück, die größer ist als # >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n","canonical_solution":"def search(lst)\n  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys\n  valid_numbers.empty? ? -1 : valid_numbers.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1, candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1, candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"},{"task_id":"HumanEval_70","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: dann maximal der restlichen Ganzzahlen, dann minimal und so weiter.Seltsame Sortierung, ist, wenn Sie mit dem Mindestwert beginnen, Geben Sie ein Array von Ganzen, und geben Sie das Array in einer seltsamen Reihenfolge zurück.# >>> strange_sort_list.call([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n","canonical_solution":"def strange_sort_list(lst)\n  result = []\n  lst.sort!\n  until lst.empty?\n    result << lst.shift\n    result << lst.pop unless lst.empty?\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\nend\n"},{"task_id":"HumanEval_71","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Die Kommission hat dieDrei Seiten bilden ein gültiges Dreieck , wenn die Summe von zwei Seiten größer ist .Andernfalls wird -1 zurückgegeben.Das Dreieck wird auf 2 Dezimalstellen gerundet, wenn die drei Seiten ein gültiges Dreieck bilden. Angesichts der Längen der drei Seiten eines Dreiecks, gibt die Fläche von  zurück.# >>> triangle_area.call(3, 4, 5)\n# 6.0\n# >>> triangle_area.call(1, 2, 10)\n# -1\ndef triangle_area(a, b, c)\n","canonical_solution":"def triangle_area(a, b, c)\n  # Check for valid triangle\n  if a + b > c && a + c > b && b + c > a\n    # Calculate the semi-perimeter\n    s = (a + b + c) \/ 2.0\n    # Calculate the area using Heron's formula\n    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Round to 2 decimal points\n    return area.round(2)\n  else\n    return -1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(6.0, candidate.call(3, 4, 5))\n    assert_equal(-1, candidate.call(1, 2, 10))\n    assert_equal(8.18, candidate.call(4, 8, 5))\n    assert_equal(1.73, candidate.call(2, 2, 2))\n    assert_equal(-1, candidate.call(1, 2, 3))\n    assert_equal(16.25, candidate.call(10, 5, 7))\n    assert_equal(-1, candidate.call(2, 6, 3))\n    assert_equal(0.43, candidate.call(1, 1, 1))\n    assert_equal(-1, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_72","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Das Objekt q fliegt, wenn es ausgeglichen ist (es ist ein palindromes Array) und die Summe seiner Elemente kleiner oder gleich dem maximal möglichen Gewicht w ist.Schreiben Sie eine Funktion, die true zurückgibt, wenn das Objekt q fliegen wird, und false, wenn nicht. # >>> will_it_fly.call([1, 2], 5)\n# false\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly.call([3, 2, 3], 1)\n# false\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly.call([3, 2, 3], 9)\n# true\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly.call([3], 5)\n# true\n# # 3 is less than the maximum possible weight, and it's balanced.\ndef will_it_fly(q, w)\n","canonical_solution":"def will_it_fly(q, w)\n  is_palindrome = q == q.reverse\n  total_weight = q.sum\n  is_balanced_and_under_weight = is_palindrome && total_weight <= w\n  is_balanced_and_under_weight\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_will_it_fly\n    candidate = method(:will_it_fly)\n    assert_equal(true, candidate.call([3, 2, 3], 9))\n    assert_equal(false, candidate.call([1, 2], 5))\n    assert_equal(true, candidate.call([3], 5))\n    assert_equal(false, candidate.call([3, 2, 3], 1))\n    assert_equal(false, candidate.call([1, 2, 3], 6))\n    assert_equal(true, candidate.call([5], 5))\n  end\nend\n"},{"task_id":"HumanEval_73","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: In einer Änderung können Sie ein Element in ein anderes Element ändern.Eine palindromische Matrix ist eine Matrix, dieFinden Sie bei einem Array arr von Ganzen die Mindestanzahl der Elemente, die # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change.call([1, 2, 3, 2, 1])\n# 0\ndef smallest_change(arr)\n","canonical_solution":"def smallest_change(arr)\n  changes = 0\n  left = 0\n  right = arr.length - 1\n\n  while left < right\n    if arr[left] != arr[right]\n      changes += 1\n    end\n    left += 1\n    right -= 1\n  end\n\n  changes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_smallest_change\n    candidate = method(:smallest_change)\n    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))\n    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))\n    assert_equal(1, candidate.call([1, 4, 2]))\n    assert_equal(1, candidate.call([1, 4, 4, 2]))\n    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))\n    assert_equal(0, candidate.call([3, 1, 1, 3]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(1, candidate.call([0, 1]))\n  end\nend\n"},{"task_id":"HumanEval_74","nl":"deu_Latn","pl":"rb","prompt":"Beispiele Wenn die beiden Arrays die gleiche Anzahl von Zeichen haben, gibt das erste Array zurück.Die Gesamtzahl der Zeichen in allen Zeichenketten des Arrays ist geringer als die der anderen Arrays.Schreiben Sie eine Funktion , die zwei Arrays von Zeichenketten akzeptiert und das Array zurückgibt , das # >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n","canonical_solution":"def total_match(lst1, lst2)\n  total_chars1 = lst1.map(&:length).sum\n  total_chars2 = lst2.map(&:length).sum\n\n  if total_chars1 < total_chars2\n    lst1\n  elsif total_chars2 < total_chars1\n    lst2\n  else\n    lst1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\", \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n    assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"},{"task_id":"HumanEval_75","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Wenn wir wissen, dass (a) kleiner als 100 ist.und anderweitig falsch.Schreiben Sie eine Funktion , die \" true \" liefert , wenn die gegebene Zahl die Multiplikation von 3 Primzahlen ist .# >>> is_multiply_prime.call(30)\n# true\n# 30 = 2 * 3 * 5\ndef is_multiply_prime(a)\n","canonical_solution":"require 'prime'\n\ndef is_multiply_prime(a)\n  return false if a >= 100\n  prime_factors = a.prime_division\n  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_multiply_prime\n    candidate = method(:is_multiply_prime)\n    assert_equal(false, candidate.call(5))\n    assert_equal(true, candidate.call(30))\n    assert_equal(true, candidate.call(8))\n    assert_equal(false, candidate.call(10))\n    assert_equal(true, candidate.call(125))\n    assert_equal(true, candidate.call(105))\n    assert_equal(false, candidate.call(126))\n    assert_equal(false, candidate.call(729))\n    assert_equal(false, candidate.call(891))\n    assert_equal(true, candidate.call(1001))\n  end\nend\n"},{"task_id":"HumanEval_76","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: x ist eine einfache Potenz von n, wenn n**int=x In anderen Fällen ist die Zahl n und false gleich.Ihre Aufgabe ist es, eine Funktion zu schreiben, die true zurückgibt, wenn eine Zahl x eine einfache # >>> is_simple_power.call(1, 4)\n# true\n# >>> is_simple_power.call(2, 2)\n# true\n# >>> is_simple_power.call(8, 2)\n# true\n# >>> is_simple_power.call(3, 2)\n# false\n# >>> is_simple_power.call(3, 1)\n# false\n# >>> is_simple_power.call(5, 3)\n# false\ndef is_simple_power(x, n)\n","canonical_solution":"def is_simple_power(x, n)\n  return false if x <= 0 || n <= 1\n  return true if x == 1\n\n  power = n\n  while power <= x\n    return true if power == x\n    power *= n\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_simple_power\n    candidate = method(:is_simple_power)\n    assert_equal(true, candidate.call(16, 2))\n    assert_equal(false, candidate.call(143214, 16))\n    assert_equal(true, candidate.call(4, 2))\n    assert_equal(true, candidate.call(9, 3))\n    assert_equal(true, candidate.call(16, 4))\n    assert_equal(false, candidate.call(24, 2))\n    assert_equal(false, candidate.call(128, 4))\n    assert_equal(false, candidate.call(12, 6))\n    assert_equal(true, candidate.call(1, 1))\n    assert_equal(true, candidate.call(1, 12))\n  end\nend\n"},{"task_id":"HumanEval_77","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Anmerkung: Sie können davon ausgehen, dass die Eingabe stets gültig ist.Wenn diese Ingeger ein Kubus einer ganzen Zahl ist.Schreiben Sie eine Funktion , die eine ganze Zahl a nimmt und true zurückgibt .# >>> iscube.call(1)\n# true\n# >>> iscube.call(2)\n# false\n# >>> iscube.call(-1)\n# true\n# >>> iscube.call(64)\n# true\n# >>> iscube.call(0)\n# true\n# >>> iscube.call(180)\n# false\ndef iscube(a)\n","canonical_solution":"def iscube(a)\n  cube_root = a.abs**(1.0\/3)\n  cube_root.round**3 == a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_iscube\n    candidate = method(:iscube)\n    assert_equal(true, candidate.call(1))\n    assert_equal(false, candidate.call(2))\n    assert_equal(true, candidate.call(-1))\n    assert_equal(true, candidate.call(64))\n    assert_equal(false, candidate.call(180))\n    assert_equal(true, candidate.call(1000))\n    assert_equal(true, candidate.call(0))\n    assert_equal(false, candidate.call(1729))\n  end\nend\n"},{"task_id":"HumanEval_78","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Die Symbole A, B, C, D, E, F sind immer groß.Hinweis: Sie können davon ausgehen, dass die Eingabe immer korrekt oder leere Zeichenfolge ist, B (= Dezimal 11), D (= Dezimal 13). Also müssen Sie eine Anzahl der folgenden Ziffern bestimmen: 2, 3, 5, 7, Die Primzahlen sind 2, 3, 5, 7, 11, 13, 17,...Die sechzigstelligen Ziffern sind 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.größer als 1, das nicht das Produkt zweier kleinerer natürlicher Zahlen ist).Die Zahlen sind Primzahlen.eine hexadezimalzahl als Zeichenfolge und zählt die Anzahl der hexadezimal Sie wurden beauftragt, eine Funktion zu schreiben, die empfängt.# >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n# >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n","canonical_solution":"def hex_key(num)\n  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n  num.chars.count { |digit| prime_hex_digits.include?(digit) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6, candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"},{"task_id":"HumanEval_79","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Die zusätzlichen Zeichen sind für die Formation von Schriftzeichen gedacht.Es wird ein zusätzliches Zeichenpaar \"db\" am Anfang und am Ende der Zeichenfolge geben.Jedes Zeichen in der Zeichenfolge wird \"0\" oder \"1\" sein.Die Funktion sollte eine Zeichenfolge zurückgeben, wobei jedes Zeichen eine binäre  repräsentiert.Sie erhalten eine Zahl in Dezimalform und Ihre Aufgabe ist es, sie in  umzuwandeln.# >>> decimal_to_binary.call(15)\n# \"db1111db\"\n# >>> decimal_to_binary.call(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal)\n","canonical_solution":"def decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"db\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_decimal_to_binary\n    candidate = method(:decimal_to_binary)\n    assert_equal(\"db0db\", candidate.call(0))\n    assert_equal(\"db100000db\", candidate.call(32))\n    assert_equal(\"db1100111db\", candidate.call(103))\n    assert_equal(\"db1111db\", candidate.call(15))\n  end\nend\n"},{"task_id":"HumanEval_80","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Eine Zeichenfolge ist haprb, wenn ihre Länge mindestens 3 beträgt und alle 3 aufeinanderfolgenden Buchstaben unterschiedlich sind.Ihre Aufgabe ist es zu überprüfen, ob die Zeichenfolge haprb oder nicht.Sie erhalten eine Zeichenfolge s.# >>> is_happy.call(\"a\")\n# false\n# >>> is_happy.call(\"aa\")\n# false\n# >>> is_happy.call(\"abcd\")\n# true\n# >>> is_happy.call(\"aabb\")\n# false\n# >>> is_happy.call(\"adb\")\n# true\n# >>> is_happy.call(\"xyy\")\n# false\ndef is_happy(s)\n","canonical_solution":"def is_happy(s)\n  return false if s.length < 3\n  \n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  \n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true, candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n    assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"iopaxioi\"))\n  end\nend\n"},{"task_id":"HumanEval_81","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: 0,0 E > 0,0 D- > 0,7 D > 1,0 D+ > 1,3 C- > 1,7 °C > 2,0 C+ > 2,3 B- > 2,7 B > 3,0 B+ > 3.3 A- > 3,7 A 4,0 A+ Durchschnitt.Eine Funktion, die eine Reihe von Buchstaben mit der folgenden Tabelle ausgibt: Sie hat dir eine Reihe von Durchschnittswerten für einige Schüler gegeben und du musst schreiben .Das einzige Problem ist, dass sie den Code verloren hat, den sie für die Bewertung benutzt hat.Die Lehrerin hat ihren eigenen Algorithmus für die Bewertung entwickelt.Es ist die letzte Woche des Semesters und die Lehrerin muss die Noten geben .# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\ndef numerical_letter_grade(grades)\n","canonical_solution":"def numerical_letter_grade(grades)\n  grades.map do |gpa|\n    case \n    when gpa == 4.0\n      \"A+\"\n    when gpa > 3.7\n      \"A\"\n    when gpa > 3.3\n      \"A-\"\n    when gpa > 3.0\n      \"B+\"\n    when gpa > 2.7\n      \"B\"\n    when gpa > 2.3\n      \"B-\"\n    when gpa > 2.0\n      \"C+\"\n    when gpa > 1.7\n      \"C\"\n    when gpa > 1.3\n      \"C-\"\n    when gpa > 1.0\n      \"D+\"\n    when gpa > 0.7\n      \"D\"\n    when gpa > 0.0\n      \"D-\"\n    else\n      \"E\"\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_numerical_letter_grade\n    candidate = method(:numerical_letter_grade)\n    assert_equal([\"A+\", \"B\", \"C-\", \"C\", \"A-\"], candidate.call([4.0, 3, 1.7, 2, 3.5]))\n    assert_equal([\"D+\"], candidate.call([1.2]))\n    assert_equal([\"D-\"], candidate.call([0.5]))\n    assert_equal([\"E\"], candidate.call([0.0]))\n    assert_equal([\"D\", \"D-\", \"C-\", \"B\", \"B+\"], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))\n    assert_equal([\"E\", \"D-\"], candidate.call([0.0, 0.7]))\n  end\nend\n"},{"task_id":"HumanEval_82","nl":"deu_Latn","pl":"rb","prompt":"Beispiele length ist eine Primzahl oder falsch .Schreiben Sie eine Funktion , die eine Zeichenfolge nimmt und true zurückgibt , wenn die Zeichenfolge # >>> prime_length.call(\"Hello\")\n# true\n# >>> prime_length.call(\"abcdcba\")\n# true\n# >>> prime_length.call(\"kittens\")\n# true\n# >>> prime_length.call(\"orange\")\n# false\ndef prime_length(string)\n","canonical_solution":"def prime_length(string)\n  length = string.length\n  return false if length < 2\n\n  (2..Math.sqrt(length)).each do |i|\n    return false if length % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_length\n    candidate = method(:prime_length)\n    assert_equal(true, candidate.call(\"Hello\"))\n    assert_equal(true, candidate.call(\"abcdcba\"))\n    assert_equal(true, candidate.call(\"kittens\"))\n    assert_equal(false, candidate.call(\"orange\"))\n    assert_equal(true, candidate.call(\"wow\"))\n    assert_equal(true, candidate.call(\"world\"))\n    assert_equal(true, candidate.call(\"MadaM\"))\n    assert_equal(true, candidate.call(\"Wow\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"HI\"))\n    assert_equal(true, candidate.call(\"go\"))\n    assert_equal(false, candidate.call(\"gogo\"))\n    assert_equal(false, candidate.call(\"aaaaaaaaaaaaaaa\"))\n    assert_equal(true, candidate.call(\"Madam\"))\n    assert_equal(false, candidate.call(\"M\"))\n    assert_equal(false, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_83","nl":"deu_Latn","pl":"rb","prompt":"Positive ganze Zahlen, die mit 1 beginnen oder enden.Gibt man eine positive ganze Zahl n, gibt man die Anzahl der n-stelligen Zahlen zurück.def starts_one_ends(n)\n","canonical_solution":"def starts_one_ends(n)\n  return 0 if n <= 0\n\n  # Count numbers starting with 1\n  start_with_1 = 9 ** (n - 1)\n\n  # Count numbers ending with 1\n  end_with_1 = 9 ** (n - 1)\n\n  # Adjust for double counting the number that both starts and ends with 1\n  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1\n  \n  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n  end\nend\n"},{"task_id":"HumanEval_84","nl":"deu_Latn","pl":"rb","prompt":"Beispiel Geben Sie eine positive ganze Zahl N, und geben Sie die Summe ihrer Ziffern in binärer Form zurück. # >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n# >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n","canonical_solution":"def solve(n)\n  sum_of_digits = n.to_s.chars.map(&:to_i).sum\n  sum_of_digits.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n  end\nend\n"},{"task_id":"HumanEval_85","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Angesichts eines nicht leeren Arrays von Ganzzahlen lst. addieren Sie die geraden Elemente, die an ungeraden Indizes sind .. # >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n","canonical_solution":"def add(lst)\n  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0, candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n  end\nend\n"},{"task_id":"HumanEval_86","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Anmerkung: Sie sollten die Reihenfolge der Wörter und der leeren Stellen im Satz beibehalten. Aufsteigende Reihenfolge auf Basis des ASCII-Wertes.werden durch ein neues Wort ersetzt, in dem alle Zeichen in Geordnete Version von String, ist eine String, in der alle Wörter (durch Leerzeichen getrennt) Schreiben Sie eine Funktion, die eine Zeichenfolge nimmt und eine geordnete Version davon zurückgibt. # >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n","canonical_solution":"def anti_shuffle(s)\n  s.split(\/(\\s+)\/).map { |word| word.chars.sort.join }.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot. How are you?\"))\n  end\nend\n"},{"task_id":"HumanEval_87","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Außerdem werden die Koordinaten der Zeile nach den Spalten in absteigender Reihenfolge sortiert.Koordinaten zunächst in Reihenfolge der Aufstiegsordnung sortieren.Jedes Array ist eine Koordinate - (Reihe, Spalten), beginnend mit 0. und gibt ein Array von Arrays zurück, [(x1, y1), (x2, y2) ...] so dass Geben lst, und Ganzzahl x, finden Sie Ganzzahlen x in der Matrix, Die einzelnen Zeilen können eine unterschiedliche Anzahl von Spalten enthalten.Das ist ähnlich wie Matrix, aber im Gegensatz zu Matrizen, Sie erhalten eine 2D-Daten, als verschachtelte Arrays, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([], 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst, x)\n","canonical_solution":"def get_row(lst, x)\n  result = []\n\n  lst.each_with_index do |row, i|\n    row.each_with_index do |value, j|\n      result << [i, j] if value == x\n    end\n  end\n\n  result.sort_by { |coord| [coord[0], -coord[1]] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"},{"task_id":"HumanEval_88","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: * ändert nicht das gegebene Array. Anmerkung:oder sortieren Sie es in absteigender Reihenfolge, wenn die Summe ((erster Indexwert, letzter Indexwert) gerade ist. Sie werden das gegebene Array in aufsteigender Reihenfolge sortieren, wenn die Summe ((erster Indexwert, letzter Indexwert) ungerade ist, Geben wir ein Array von nicht-negativen ganzen Zahlen, geben wir nach der Sortierung einen Korb des Arrays zurück, # >>> sort_array.call([])\n# []\n# >>> sort_array.call([5])\n# [5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n","canonical_solution":"def sort_array(array)\n  return array if array.empty? || array.size == 1\n\n  if (array.first + array.last).odd?\n    array.sort\n  else\n    array.sort.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"},{"task_id":"HumanEval_89","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Die Zahl der Arbeitsplätze in der Europäischen Union wird um zwei multipliziert.Das Alphabet sollte so gedreht werden , dass die Buchstaben gibt eine mit dem rotierten Alphabet verschlüsselte Zeichenfolge zurück. Erstellen Sie eine Funktion, die einen String als Argument verwendet und # >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"et\")\n# \"ix\"\ndef encrypt(s)\n","canonical_solution":"def encrypt(s)\n  s.chars.map do |char|\n    if char =~ \/[a-z]\/\n      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr\n    elsif char =~ \/[A-Z]\/\n      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr\n    else\n      char\n    end\n  end.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"e\", candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_90","nl":"deu_Latn","pl":"rb","prompt":"Gibt null zurück, wenn kein solches Element vorhanden ist. Schreiben Sie eine Funktion next_smallest (), die das zweitkleinste Element des Arrays zurückgibt. Wir haben ein Array von Ganzzahlen.# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1, 1])\n# nil\ndef next_smallest(lst)\n","canonical_solution":"def next_smallest(lst)\n  unique_sorted = lst.uniq.sort\n  unique_sorted.length >= 2 ? unique_sorted[1] : nil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"},{"task_id":"HumanEval_91","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Die Sätze werden durch \"\", \"?\" oder \"!\" abgegrenzt.Eine Langeweile ist ein Satz, der mit dem Wort \"I\" beginnt.Sie erhalten eine Reihe von Wörtern und Ihre Aufgabe ist es, die Zahl zu zählen.# >>> is_bored.call(\"Hello world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\ndef is_bored(s)\n","canonical_solution":"def is_bored(s)\n  sentences = s.split(\/(?<=[.?!])\/)\n  sentences.count { |sentence| sentence.strip.start_with?('I') }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1, candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"))\n  end\nend\n"},{"task_id":"HumanEval_92","nl":"deu_Latn","pl":"rb","prompt":"Beispiele In allen anderen Fällen wird false zurückgegeben. Gibt als wahr zurück, wenn eine der Zahlen der Summe der anderen beiden entspricht und alle Zahlen ganze Zahlen sind.Erstellen Sie eine Funktion, die 3 Zahlen aufnimmt.# >>> any_int.call(5, 2, 7)\n# true\n# >>> any_int.call(3, 2, 2)\n# false\n# >>> any_int.call(3, -2, 1)\n# true\n# >>> any_int.call(3.6, -2.2, 2)\n# false\ndef any_int(x, y, z)\n","canonical_solution":"def any_int(x, y, z)\n  if [x, y, z].all? { |n| n.is_a?(Integer) }\n    x == y + z || y == x + z || z == x + y\n  else\n    false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_any_int\n    candidate = method(:any_int)\n    assert_equal(true, candidate.call(2, 3, 1))\n    assert_equal(false, candidate.call(2.5, 2, 3))\n    assert_equal(false, candidate.call(1.5, 5, 3.5))\n    assert_equal(false, candidate.call(2, 6, 2))\n    assert_equal(true, candidate.call(4, 2, 2))\n    assert_equal(false, candidate.call(2.2, 2.2, 2.2))\n    assert_equal(true, candidate.call(-4, 6, 2))\n    assert_equal(true, candidate.call(2, 1, 1))\n    assert_equal(true, candidate.call(3, 4, 7))\n    assert_equal(false, candidate.call(3.0, 4, 7))\n  end\nend\n"},{"task_id":"HumanEval_93","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Nur Buchstaben.Vokal im englischen Alphabet.Die Nachricht mit dem Buchstaben , der zwei Plätze davor erscheint .So dass es alle Buchstaben in der Schrift umschlägt und alle Vokale in  ersetzt.Schreiben Sie eine Funktion, die eine Nachricht nimmt und in einer solchen # >>> encode.call(\"test\")\n# \"TGST\"\n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n","canonical_solution":"def encode(message)\n  vowels = 'aeiou'\n  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}\n  \n  encoded_message = message.chars.map do |char|\n    if vowels.include?(char.downcase)\n      new_char = swap_vowels[char.downcase]\n      char == char.upcase ? new_char.upcase : new_char.downcase\n    else\n      char == char.upcase ? char.downcase : char.upcase\n    end\n  end\n\n  encoded_message.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"},{"task_id":"HumanEval_94","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Sie müssen den größten Primwert finden und die Summe seiner Ziffern zurückgeben.Wir haben ein Array von Ganzzahlen.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])\n# 7\ndef skjkasdkd(lst)\n","canonical_solution":"def skjkasdkd(lst)\n  require 'prime'\n\n  # Find the largest prime number in the array\n  largest_prime = lst.select { |num| Prime.prime?(num) }.max\n  \n  # Return 0 if no prime number is found\n  return 0 if largest_prime.nil?\n\n  # Calculate the sum of digits of the largest prime number\n  largest_prime.to_s.chars.map(&:to_i).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_skjkasdkd\n    candidate = method(:skjkasdkd)\n    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))\n    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))\n    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))\n    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))\n    assert_equal(19, candidate.call([8191]))\n    assert_equal(19, candidate.call([8191, 123456, 127, 7]))\n    assert_equal(10, candidate.call([127, 97, 8192]))\n  end\nend\n"},{"task_id":"HumanEval_95","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Die Funktion sollte false zurückgeben, wenn der angegebene Hash leer ist. case oder alle Schlüssel sind Strings in Großbuchstaben, sonst wird false zurückgegeben. Geben Sie einen Hash, gibt wahr zurück, wenn alle Tasten Strings in lower  sind.# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n","canonical_solution":"def check_dict_case(dict)\n  return false if dict.empty?\n\n  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }\n  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }\n\n  lowercase_keys || uppercase_keys\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n"},{"task_id":"HumanEval_96","nl":"deu_Latn","pl":"rb","prompt":"beispielsweise: Ganzzahlen, die Primzahlen sind und kleiner als n sind.Implementieren Sie eine Funktion, die eine nicht-negative ganze Zahl nimmt und ein Array der ersten n zurückgibt.# >>> count_up_to.call(5)\n# [2, 3]\n# >>> count_up_to.call(11)\n# [2, 3, 5, 7]\n# >>> count_up_to.call(0)\n# []\n# >>> count_up_to.call(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to.call(1)\n# []\n# >>> count_up_to.call(18)\n# [2, 3, 5, 7, 11, 13, 17]\ndef count_up_to(n)\n","canonical_solution":"def count_up_to(n)\n  return [] if n <= 2\n  primes = []\n  (2...n).each do |num|\n    is_prime = true\n    (2..Math.sqrt(num)).each do |i|\n      if num % i == 0\n        is_prime = false\n        break\n      end\n    end\n    primes << num if is_prime\n  end\n  primes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([], candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"},{"task_id":"HumanEval_97","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Die Eingabe ist stets gültig.die Zahl der einzelnen Zahlen. Füllen Sie die Funktion aus, die zwei Ganzzahlen nimmt und  zurückgibt.# >>> multiply.call(148, 412)\n# 16\n# >>> multiply.call(19, 28)\n# 72\n# >>> multiply.call(2020, 1851)\n# 0\n# >>> multiply.call(14, -15)\n# 20\ndef multiply(a, b)\n","canonical_solution":"def multiply(a, b)\n  a_unit_digit = a.abs % 10\n  b_unit_digit = b.abs % 10\n  a_unit_digit * b_unit_digit\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_multiply\n    candidate = method(:multiply)\n    assert_equal(16, candidate.call(148, 412))\n    assert_equal(72, candidate.call(19, 28))\n    assert_equal(0, candidate.call(2020, 1851))\n    assert_equal(20, candidate.call(14, -15))\n    assert_equal(42, candidate.call(76, 67))\n    assert_equal(49, candidate.call(17, 27))\n    assert_equal(0, candidate.call(0, 1))\n    assert_equal(0, candidate.call(0, 0))\n  end\nend\n"},{"task_id":"HumanEval_98","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Zählen Sie bei einer Zeichenfolge s die Anzahl der Großvokale in geraden Indizes. # >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n","canonical_solution":"def count_upper(s)\n  vowels = ['A', 'E', 'I', 'O', 'U']\n  count = 0\n\n  s.chars.each_with_index do |char, index|\n    if index.even? && vowels.include?(char)\n      count += 1\n    end\n  end\n\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"EEEE\"))\n  end\nend\n"},{"task_id":"HumanEval_99","nl":"deu_Latn","pl":"rb","prompt":"Beispiele von zwei Ganzzahlen, rundet sie weg von Null.und gibt die ihm nächstgelegene ganze Zahl zurück.Erstellen einer Funktion, die einen Wert (String) als Zahlenwert annimmt # >>> closest_integer.call(\"10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\ndef closest_integer(value)\n","canonical_solution":"def closest_integer(value)\n  number = value.to_f\n  if number > 0\n    (number + 0.5).floor\n  else\n    (number - 0.5).ceil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_100","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: i ist die Anzahl der Steine in der Ebene (i+1). Gibt die Anzahl der Steine in jeder Ebene in einem Array zurück, wobei Element bei Index - die nächste gerade Zahl, wenn n gerade ist. - die nächste ungerade Zahl, wenn n ungerade ist. Die Anzahl der Steine in der nächsten Ebene ist:Die erste Ebene hat n Steine.Angesichts einer positiven ganzen Zahl n, müssen Sie einen Stapel von n Ebenen von Steinen zu machen.# >>> make_a_pile.call(3)\n# [3, 5, 7]\ndef make_a_pile(n)\n","canonical_solution":"def make_a_pile(n)\n  result = []\n  current_stones = n\n  n.times do\n    result << current_stones\n    current_stones += 2\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9, 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"},{"task_id":"HumanEval_101","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: um die Zeichenfolge in Wörter zu teilen und eine Reihe von Wörtern zurückzugeben.Sie erhalten eine Reihe von Wörtern, die durch Kommas oder Leerzeichen getrennt sind.# >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n","canonical_solution":"def words_string(s)\n  s.split(\/[\\s,]+\/)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\", \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two, three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"ahmed     , gamal\"))\n  end\nend\n"},{"task_id":"HumanEval_102","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Es gibt keine solche Zahl, dann sollte die Funktion -1 zurückgeben.größte gerade ganze Zahl, die im Bereich [x, y] inklusive ist.Diese Funktion nimmt zwei positive Zahlen x und y und gibt die # >>> choose_num.call(12, 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n","canonical_solution":"def choose_num(x, y)\n  return -1 if x > y\n  # Start looking from the largest number\n  max_even = y.even? ? y : y - 1\n  # Iterate downwards to find the biggest even number\n  max_even.downto(x) do |n|\n    return n if n.even?\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33, 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28, candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1, candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\nend\n"},{"task_id":"HumanEval_103","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Wenn n größer als m ist, gibt er -1 zurück.Runden Sie die Antwort auf die nächste ganze Zahl und konvertieren Sie diese in binäre Zahlen.Durchschnitt der ganzen Zahlen von n bis m (einschließlich n und m).Sie erhalten zwei positive Ganzzahlen n und m, und Ihre Aufgabe ist es, die  zu berechnen.# >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>> rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n# >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n","canonical_solution":"def rounded_avg(n, m)\n  return -1 if n > m\n\n  sum = (n..m).reduce(:+)\n  count = m - n + 1\n  average = (sum.to_f \/ count).round\n  \"0b\" + average.to_i.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1, 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996, 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362, 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7, 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5, 5))\n  end\nend\n"},{"task_id":"HumanEval_104","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Anmerkung: Das zurückgegebene Array sollte in steigender Reihenfolge sortiert werden.Elemente, die keine gerade Ziffer haben.Geben wir ein Array aus positiven Ganzzahlen x, geben wir ein sortiertes Array mit allen # >>> unique_digits.call([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n","canonical_solution":"def unique_digits(x)\n  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31, 135], candidate.call([135, 103, 31]))\n  end\nend\n"},{"task_id":"HumanEval_105","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: \"Eins\", \"Zwei\", \"Drei\", \"Vier\", \"Fünf\", \"Sechs\", \"Sieben\", \"Acht\", \"Neun\".Das Ergebnis wird in einem Array umgekehrt und jede Ziffer durch den entsprechenden Namen aus  ersetzt.Angesichts eines Arrays von Ganzen, sortieren Sie die Ganzen zwischen 1 und 9 inklusive, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length.call([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n","canonical_solution":"def by_length(arr)\n  number_names = {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\"\n  }\n\n  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse\n  filtered_sorted_reversed.map { |num| number_names[num] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"], candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"], candidate.call([9, 4, 8]))\n  end\nend\n"},{"task_id":"HumanEval_106","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Das Faktorial von i ist die Multiplikation der Zahlen von 1 bis i (1 * 2 * ... * i).i beginnt bei 1.oder die Summe der Zahlen von 1 bis i. und gibt ein Array der Größe n zurück, so dass der Wert des Elements bei Index i das Faktoriale von i ist, wenn i gerade ist Implementieren Sie die Funktion f, die n als Parameter nimmt, # >>> f.call(5)\n# [1, 2, 6, 24, 15]\ndef f(n)\n","canonical_solution":"def f(n)\n  (1..n).map do |i|\n    if i.even?\n      (1..i).inject(:*) || 1\n    else\n      (1..i).inject(:+)\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([1, 2, 6, 24, 15], candidate.call(5))\n    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))\n    assert_equal([1], candidate.call(1))\n    assert_equal([1, 2, 6], candidate.call(3))\n  end\nend\n"},{"task_id":"HumanEval_107","nl":"deu_Latn","pl":"rb","prompt":"Beispiel 1: Ganzzahlenpalindrome, die in den Bereich ((1, n) eingeschlossen fallen. Geben wir eine positive ganze Zahl n, geben wir ein Array zurück, das die Anzahl der geraden und ungeraden Zahlen hat.# >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\ndef even_odd_palindrome(n)\n","canonical_solution":"def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n\n  [even_count, odd_count]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_108","nl":"deu_Latn","pl":"rb","prompt":"z.B. -123 hat die Ziffern -1, 2 und 3.Wenn eine Zahl negativ ist, dann ist ihre erste unterzeichnete Ziffer negativ: die Anzahl der Elemente, deren Ziffernsumme > 0 beträgt. Schreiben Sie eine Funktion count_nums , die ein Array von Ganzzahlen nimmt und zurückgibt # >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n# 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n","canonical_solution":"def count_nums(arr)\n  arr.count do |num|\n    num.to_s.chars.map(&:to_i).sum > 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0, 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_109","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Anmerkung: Die angegebenen Elemente des Arrays sind garantiert einzigartig.Wenn das angegebene Array leer ist, wird true zurückgegeben. dann zurück true oder zurück false. Wenn es möglich ist, das sortierte Array durch die oben genannte Operation zu erhalten die Ausgangsposition im Array, d. h. der 0-te Index. Das letzte Element des Arrays wird zu  verschoben.Eine Rechtsverschiebung bedeutet, dass alle Elemente des Arrays um eins verschoben werden.Sie dürfen die Rechtsschaltvorgänge beliebig oft ausführen.die folgende Operation auf dem gegebenen Array: Es ist möglich, ein Array in nicht abnehmender Reihenfolge zu sortieren, indem man Die Zahlen im Array werden zufällig angeordnet.Wir haben ein Array 'arr' von N Ganzzahlen arr[1], arr[2], ..., arr[N].# >>> move_one_ball.call([3, 4, 5, 1, 2])\n# true\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball.call([3, 5, 4, 1, 2])\n# false\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\ndef move_one_ball(arr)\n","canonical_solution":"def move_one_ball(arr)\n  return true if arr.empty?\n\n  n = arr.size\n  count_rotation_point = 0\n  rotation_index = -1\n\n  (0...n).each do |i|\n    next_index = (i + 1) % n\n    if arr[i] > arr[next_index]\n      count_rotation_point += 1\n      rotation_index = next_index\n    end\n  end\n\n  count_rotation_point <= 1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_move_one_ball\n    candidate = method(:move_one_ball)\n    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))\n    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))\n    assert_equal(false, candidate.call([4, 3, 1, 2]))\n    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))\n    assert_equal(true, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_110","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Ansonsten wird \"NEIN\" zurückgegeben.Wenn alle Elemente von lst1 gleich sind, gibt \"YES\" zurück.Wenn es möglich ist, Elemente zwischen lst1 und lst2 auszutauschen, um Die Anzahl der Elemente, die zwischen lst1 und lst2 ausgetauscht werden können, ist unbegrenzt.Lst1 zu einem Array von nur gerade Zahlen machen.und bestimmt , ob ein Austausch von Elementen möglich ist In diesem Problem werden Sie eine Funktion implementieren, die zwei Arrays von Zahlen nimmt, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\ndef exchange(lst1, lst2)\n","canonical_solution":"def exchange(lst1, lst2)\n  # Check if lst1 already consists solely of even numbers\n  return \"YES\" if lst1.all?(&:even?)\n\n  # Check if there are at least as many even numbers in lst2\n  # as there are odd numbers in lst1\n  odd_count_lst1 = lst1.count(&:odd?)\n  even_count_lst2 = lst2.count(&:even?)\n\n  odd_count_lst1 <= even_count_lst2 ? \"YES\" : \"NO\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_exchange\n    candidate = method(:exchange)\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))\n    assert_equal(\"NO\", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))\n    assert_equal(\"YES\", candidate.call([5, 7, 3], [2, 6, 4]))\n    assert_equal(\"NO\", candidate.call([5, 7, 3], [2, 6, 3]))\n    assert_equal(\"NO\", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\n    assert_equal(\"YES\", candidate.call([100, 200], [200, 200]))\n  end\nend\n"},{"task_id":"HumanEval_111","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Wenn mehrere Buchstaben das gleiche Vorkommen haben, geben Sie alle zurück. Die meisten der in der Tabelle aufgeführten Buchstaben werden in der Tabelle mit den meisten Wiederholungen und der entsprechenden Anzahl angegeben.Geben Sie eine Zeichenfolge, die einen Raum getrennt Kleinbuchstaben darstellt, einen Hash zurückgeben # >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n","canonical_solution":"def histogram(test)\n  return {} if test.empty?\n\n  count = Hash.new(0)\n\n  test.split.each do |char|\n    count[char] += 1\n  end\n\n  max_count = count.values.max\n  count.select { |_, value| value == max_count }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4}, candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_112","nl":"deu_Latn","pl":"rb","prompt":"Beispiel Sie sollten ein Array mit der Ergebniszeichenfolge und der Wahrscheinlichkeit für die Prüfung zurückgeben.Eine Zeichenfolge wird als Palindrom bezeichnet, wenn sie sich nach hinten und nach vorne gleich liest.Dann prüfen, ob die resultierende Zeichenfolge palindrom ist.Wir haben zwei Zeichenketten s und c, Sie müssen alle Zeichen in s löschen, die einem beliebigen Zeichen in c gleich sind.Aufgabe # >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n# >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s, c)\n","canonical_solution":"def reverse_delete(s, c)\n  # Remove all characters in c from s\n  filtered_string = s.delete(c)\n  \n  # Check if the filtered string is a palindrome\n  is_palindrome = filtered_string == filtered_string.reverse\n  \n  # Return the result array\n  [filtered_string, is_palindrome]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\", \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n    assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true], candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"mamma\", \"mia\"))\n  end\nend\n"},{"task_id":"HumanEval_113","nl":"deu_Latn","pl":"rb","prompt":"von ungeraden Ziffern in der i'ten Zeichenfolge der Eingabe.String i der Eingabe\". wobei alle i durch die Zahl  ersetzt werden sollten.Jedes Element i der Ausgabe sollte die Anzahl der ungeraden Elemente in der Geben wir ein Array von Zeichenfolgen, wobei jeder String nur aus Ziffern besteht, gibt ein Array zurück.# >>> odd_count.call([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n","canonical_solution":"def odd_count(lst)\n  lst.map do |num_str|\n    count = num_str.count('13579')\n    \"the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\", \"314\"]))\n  end\nend\n"},{"task_id":"HumanEval_114","nl":"deu_Latn","pl":"rb","prompt":"Beispiel Die Zahl derFinden Sie bei einem Array von ganzen Zahlen die Mindestsumme eines nicht leeren Teilarrays # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n","canonical_solution":"def minSubArraySum(nums)\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    if current_sum > 0\n      current_sum = num\n    else\n      current_sum += num\n    end\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10, candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1, candidate.call([1, -1]))\n  end\nend\n"},{"task_id":"HumanEval_115","nl":"deu_Latn","pl":"rb","prompt":"Beispiel 1: Geben Sie die Anzahl der Absenkungen der Eimer an. Ihre Aufgabe ist es, die Eimer zu benutzen, um die Brunnen zu leeren.und alle Eimer haben die gleiche Kapazität.Jeder Brunnen hat einen entsprechenden Eimer, aus dem Wasser gewonnen werden kann.und jede 1 in einer Reihe repräsentiert eine einzelne Wassereinheit. Jede Reihe repräsentiert einen einzelnen Brunnen.# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n","canonical_solution":"def max_fill(grid, capacity)\n  total_water_units = grid.flatten.sum\n  (total_water_units.to_f \/ capacity).ceil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))\n  end\nend\n"},{"task_id":"HumanEval_116","nl":"deu_Latn","pl":"rb","prompt":"Die Umsetzung muss folgendermaßen erfolgen: Für eine ähnliche Anzahl von Einsen sortieren Sie nach dem Dezimalwert.Anzahl der Einsen in ihrer binären Darstellung in aufsteigender Reihenfolge.In diesem Kata, müssen Sie ein Array von nicht-negativen Ganzzahlen nach sortieren # >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\ndef sort_array(arr)\n","canonical_solution":"def sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"},{"task_id":"HumanEval_117","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Hinweis: Sie können davon ausgehen, dass die Eingabezeichenfolge nur Buchstaben und Leerzeichen enthält.Wenn die Zeichenfolge s leer ist, dann sollte die Funktion ein leeres Array zurückgeben. n Konsonanten, in der Reihenfolge, in der diese Wörter in der Zeichenfolge s erscheinen. Eine Funktion, die ein Array aller Wörter aus String s zurückgibt, die genau  enthalten.Angesichts einer Zeichenfolge s und einer natürlichen Zahl n, haben Sie den Auftrag, um zu implementieren # >>> select_words.call(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words.call(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words.call(\"simple white space\", 2)\n# []\n# >>> select_words.call(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words.call(\"Uncle sam\", 3)\n# [\"Uncle\"]\ndef select_words(s, n)\n","canonical_solution":"def select_words(s, n)\n  vowels = \"aeiouAEIOU\"\n  words = s.split\n  words.select do |word|\n    consonant_count = word.chars.count { |char| !vowels.include?(char) }\n    consonant_count == n\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([], candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"a b c d e f\", 1))\n  end\nend\n"},{"task_id":"HumanEval_118","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Sie können annehmen, dass die angegebene Zeichenfolge nur englische Buchstaben enthält.finden Sie alle Vokale, die die oben genannte Bedingung erfüllen.Vokale am Anfang und am Ende zählen nicht. Gib leere Zeichenfolge zurück, wenn du sie nicht hast.zwei Konsonanten von der rechten Seite des Wortes (Schreibweise).Sie erhalten ein Wort, und Ihre Aufgabe ist es, das nächste Vokal zu finden, das zwischen  und  steht.# >>> get_closest_vowel.call(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n","canonical_solution":"def get_closest_vowel(word)\n  vowels = \"aeiouAEIOU\"\n  (1...word.length - 1).reverse_each do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n      return word[i]\n    end\n  end\n  return \"\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\", candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"Above\"))\n  end\nend\n"},{"task_id":"HumanEval_119","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Gibt 'Ja' zurück, wenn es eine Möglichkeit gibt, eine gute Zeichenfolge zu erstellen, und gibt 'Nein' zurück, wenn es nicht möglich ist.\" (()) \" ist nicht.sind ausgeglichen. Zum Beispiel: die Zeichenfolge \"(()))))) \" ist gut, während die Zeichenfolge Eine Zeichenfolge S gilt als gut, wenn und nur wenn alle Klammern in S einige Ordnung, dass die resultierende Zeichenfolge gut sein wird.Ihre Aufgabe ist es zu überprüfen , ob es möglich ist , die beiden Strings in einer Kette zu verbinden .Nur die Klammern \" ((\") oder die Klammern \") \".Sie erhalten ein Array von zwei Strings, beide Strings bestehen aus offenen # >>> match_parens.call([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n","canonical_solution":"def match_parens(lst)\n  a, b = lst\n\n  # Define a helper method to check if a string is balanced\n  def balanced?(s)\n    count = 0\n    s.each_char do |c|\n      count += 1 if c == '('\n      count -= 1 if c == ')'\n      return false if count < 0\n    end\n    count == 0\n  end\n\n  # Check if either concatenation forms a good string\n  if balanced?(a + b) || balanced?(b + a)\n    \"Yes\"\n  else\n    \"No\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\")())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"(()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n    assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\")(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"},{"task_id":"HumanEval_120","nl":"deu_Latn","pl":"rb","prompt":"Beispiel 1: der Länge k mit maximal k Zahlen in arr. Geben wir ein Array arr von Ganzzahlen und eine positive Ganzzahl k, geben wir ein sortiertes Array zurück.# >>> maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n","canonical_solution":"def maximum(arr, k)\n  arr.sort.last(k).sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n    assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10], candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))\n  end\nend\n"},{"task_id":"HumanEval_121","nl":"deu_Latn","pl":"rb","prompt":"Beispiele Gibt man uns ein nicht leeres Array von Ganzen, gibt man die Summe aller ungeraden Elemente zurück, die sich in geraden Positionen befinden.# >>> solution.call([5, 8, 7, 1])\n# 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24, 321])\n# 0\ndef solution(lst)\n","canonical_solution":"def solution(lst)\n  lst.each_with_index.reduce(0) do |sum, (val, idx)|\n    (idx.even? && val.odd?) ? sum + val : sum\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7, 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0, candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30, 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"},{"task_id":"HumanEval_122","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: die Summe der Elemente mit höchstens zwei Ziffern von den ersten k Elementen von arr. Geben wir ein nicht leeres Array von ganzen Zahlen arr und eine ganze Zahl k, geben wir  zurück.# >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k)\n","canonical_solution":"def add_elements(arr, k)\n  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"},{"task_id":"HumanEval_123","nl":"deu_Latn","pl":"rb","prompt":"get_odd_collatz(5) gibt [1, 5] # Die Collatz-Sequenz für 5 ist [5, 16, 8, 4, 2, 1], also sind die ungeraden Zahlen nur 1, und 5. Zum Beispiel: 2. zurückgegebene Array in zunehmender Reihenfolge sortiert.1. Collatz ((1) ist [1]. Anmerkung:Die Vermutung ist, dass die Folge immer 1 erreicht, egal welchen Wert von n sie hat.Wenn der vorherige Term ungerade ist, ist der nächste Term 3 mal der vorherigen.Vorheriger Term wie folgt: Wenn der vorherige Term gerade ist, ist der nächste Term die Hälfte von Wie folgt: Beginnen Sie mit einer beliebigen positiven ganzen Zahl n. Dann wird jeder Term aus dem  erhalten.Die Collatz-Vermutung ist eine mathematische Vermutung über eine definierte Sequenz .Geben Sie eine positive ganze Zahl n, und geben Sie ein sortiertes Array zurück, das die ungeraden Zahlen in der Collatz-Sequenz enthält. # >>> get_odd_collatz.call(5)\n# [1, 5]\ndef get_odd_collatz(n)\n","canonical_solution":"def get_odd_collatz(n)\n  collatz_sequence = []\n  while n != 1\n    collatz_sequence << n if n.odd?\n    if n.even?\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n  end\n  collatz_sequence << 1 if n == 1\n\n  collatz_sequence.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_odd_collatz\n    candidate = method(:get_odd_collatz)\n    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))\n    assert_equal([1, 5], candidate.call(5))\n    assert_equal([1, 3, 5], candidate.call(12))\n    assert_equal([1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_124","nl":"deu_Latn","pl":"rb","prompt":"4. Das Datum sollte in der Form: mm-dd-aaaa 3. Die Monate sollten nicht weniger als 1 und nicht mehr als 12 sein.2. Die Anzahl der Tage ist nicht weniger als 1 oder höher als 31 Tage für Monate 1,3,5,7,8,10,12. Und die Anzahl der Tage ist nicht weniger als 1 oder höher als 30 Tage für Monate 4,6,9,11. Und die Anzahl der Tage ist nicht weniger als 1 oder höher als 29 für den Monat 2.1. Die Datumszeichenfolge ist nicht leer.Das Datum ist gültig, wenn alle folgenden Regeln erfüllt sind: Gibt als \"true\" zurück, wenn das Datum gültig ist, ansonsten als \"false\". Sie müssen eine Funktion schreiben, die einen bestimmten Datumszeichenreih validiert und # >>> valid_date.call(\"03-11-2000\")\n# true\n# >>> valid_date.call(\"15-01-2012\")\n# false\n# >>> valid_date.call(\"04-0-2040\")\n# false\n# >>> valid_date.call(\"06-04-2020\")\n# true\n# >>> valid_date.call(\"06\/04\/2020\")\n# false\ndef valid_date(date)\n","canonical_solution":"def valid_date(date)\n  return false if date.nil? || date.empty?\n  \n  # Check if the date format is correct\n  match = date.match(\/^(\\d{2})-(\\d{2})-(\\d{4})$\/)\n  return false unless match\n  \n  month, day, year = match.captures.map(&:to_i)\n  \n  # Check if month is valid\n  return false if month < 1 || month > 12\n  \n  # Check if day is valid according to the month\n  case month\n  when 1, 3, 5, 7, 8, 10, 12\n    return day >= 1 && day <= 31\n  when 4, 6, 9, 11\n    return day >= 1 && day <= 30\n  when 2\n    return day >= 1 && day <= 29\n  else\n    return false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_valid_date\n    candidate = method(:valid_date)\n    assert_equal(true, candidate.call(\"03-11-2000\"))\n    assert_equal(false, candidate.call(\"15-01-2012\"))\n    assert_equal(false, candidate.call(\"04-0-2040\"))\n    assert_equal(true, candidate.call(\"06-04-2020\"))\n    assert_equal(true, candidate.call(\"01-01-2007\"))\n    assert_equal(false, candidate.call(\"03-32-2011\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"04-31-3000\"))\n    assert_equal(true, candidate.call(\"06-06-2005\"))\n    assert_equal(false, candidate.call(\"21-31-2000\"))\n    assert_equal(true, candidate.call(\"04-12-2003\"))\n    assert_equal(false, candidate.call(\"04122003\"))\n    assert_equal(false, candidate.call(\"20030412\"))\n    assert_equal(false, candidate.call(\"2003-04\"))\n    assert_equal(false, candidate.call(\"2003-04-12\"))\n    assert_equal(false, candidate.call(\"04-2003\"))\n  end\nend\n"},{"task_id":"HumanEval_125","nl":"deu_Latn","pl":"rb","prompt":"Beispiele Die Angabe der Zahl der in der Tabelle aufgeführten Personen ist in der Tabelle zu finden.sollte auf Kommas aufgeteilt werden ',' wenn keine Kommas vorhanden sind, sollten Sie die Anzahl der kleinsten Buchstaben in ungerader Reihenfolge in der Geben Sie eine Wortfolge an, und geben Sie ein Array von Wörtern zurück, die auf Leerzeichen aufgeteilt sind, wenn es keine Leerzeichen im Text gibt, den Sie # >>> split_words.call(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n","canonical_solution":"def split_words(txt)\n  if txt.include?(' ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }\n    return odd_count\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2, candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n    assert_equal(0, candidate.call(\"\"))\n  end\nend\n"},{"task_id":"HumanEval_126","nl":"deu_Latn","pl":"rb","prompt":"Beispiele Zahl, gibt false zurück.Wenn die Reihe mehr als ein Doppel hat, ist die Zahl der Doppel derselben.Gibt man einem Array von Zahlen, gibt man zurück, ob sie sortiert sind oder nicht.# >>> is_sorted.call([5])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>> is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n","canonical_solution":"def is_sorted(lst)\n  lst.each_cons(2).with_index do |(a, b), index|\n    return false if a > b\n    return false if index < lst.length - 2 && a == b && lst[index + 2] == b\n  end\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true, candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false, candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_127","nl":"deu_Latn","pl":"rb","prompt":"[Eingang\/Ausgang] Proben: Wenn die beiden Intervalle nicht überschneiden, geben Sie \"NEIN\" zurück.Ansonsten wird \"NEIN\" zurückgegeben.Wenn die Länge der Schnittstelle eine Primzahl ist, gibt \"YES\" zurück.Die Länge ist 1, was keine Primzahl ist.Beispiel: Der Schnittpunkt der Intervalle (1, 3), (2, 4) ist (2, 3) ist eine Primzahl.Ihre Aufgabe ist es zu bestimmen, ob die Länge der Schnittstelle dieser beiden Für jedes Intervall wird angenommen, dass sein Anfang kleiner oder gleich seinem Ende ist.Beginn und Ende.Die angegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (Anfang, Ende) wobei jedes Intervall ein ganzzahlige Paar ist.Sie haben zwei Intervalle,# >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\ndef intersection(interval1, interval2)\n","canonical_solution":"def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n\n  if intersection_start > intersection_end\n    return \"NO\"\n  end\n\n  intersection_length = intersection_end - intersection_start + 1\n\n  return \"YES\" if prime?(intersection_length)\n\n  \"NO\"\nend\n\ndef prime?(n)\n  return false if n <= 1\n  return true if n == 2 || n == 3\n\n  (2..Math.sqrt(n).to_i).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1, 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2, 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\", candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2, -2], [-3, -2]))\n  end\nend\n"},{"task_id":"HumanEval_128","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Anmerkung: null für leere arr. von jeder Zahl im Array, repräsentiert durch 1, -1 oder 0. Summe der Größen von Ganzzahlen multipliziert mit dem Produkt aller Zeichen Wir haben ein Array arr von Ganzzahlen und wir müssen zurückgeben.# >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n# >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n","canonical_solution":"def prod_signs(arr)\n  return nil if arr.empty?\n  \n  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }\n  sum_magnitudes = arr.map(&:abs).sum\n  \n  product_signs * sum_magnitudes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"},{"task_id":"HumanEval_129","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Gibt ein geordnetes Array der Werte der Zellen zurück, die der Mindestpfad durchläuft. Die Antwort ist garantiert einmalig. Die Angabe \"A\" ist für die Angabe \"B\" zu verwenden.so dass lst_A[i] < lst_B[i] und für jede j (1 <= j < i) haben wir als lst_B, mit anderen Worten, es gibt einen ganzzahligen Index i (1 <= i <= k) Die beiden Formen der Abgrenzung sind in der Regel gleich.Nach der Anordnung der Arrays der Werte auf den Zellen, die A und B gehen Ein Pfad A (lange k) wird als kleiner als ein Pfad B (lange k) angesehen, wenn Du kannst nicht aus dem Netz verschwinden.nicht unbedingt voneinander abgegrenzt werden).Bitte beachten Sie, dass ein Pfad mit einer Länge k genau k Zellen (nicht Mit anderen Worten, Sie können zu Zellen gehen, die einen Rand mit Ihnen gegenwärtig teilen.von jeder Zelle, und in jedem Schritt können Sie zu einer der Nachbarzellen zu bewegen, Sie müssen den Mindestweg der Länge k im Raster finden.In der Zelle des Rasters erscheint \"inclusive\" genau einmal. Jede Zelle des Rasters enthält einen Wert. Jede ganze Zahl im Bereich [1, N * N] Geben wir ein Raster mit N Zeilen und N Spalten (N >= 2) und einer positiven ganzen Zahl k, # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid, k)\n","canonical_solution":"def minPath(grid, k)\n  n = grid.size\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  min_path = nil\n\n  n.times do |i|\n    n.times do |j|\n      queue = [[[i, j], [grid[i][j]]]]\n      until queue.empty?\n        position, path = queue.shift\n        if path.size == k\n          min_path = path if min_path.nil? || path < min_path\n          next\n        end\n        directions.each do |dx, dy|\n          x, y = position[0] + dx, position[1] + dy\n          if x.between?(0, n-1) && y.between?(0, n-1)\n            queue.push([[x, y], path + [grid[x][y]]])\n          end\n        end\n      end\n    end\n  end\n  min_path\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"},{"task_id":"HumanEval_130","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Die ersten n + 1 Zahlen der Tribonacci-Sequenz.Wir haben eine nicht-negative ganze Zahl n, wir müssen ein Array der  zurückgeben.= 2 + 3 + 3 = 8 Die Angabe der Werte ist in der Tabelle zu finden.tri(4) = 3 tri(2) = 1 + (2 \/ 2) = 2 Zum Beispiel: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist. tri (n) = 1 + n \/ 2, wenn n gerade ist.tri(1) = 3 Die Tribonacci-Sequenz wird durch die Wiederholung definiert: Aber was die Leute nicht wissen, ist die Tribonacci-Sequenz.Jeder kennt die Fibonacci-Sequenz, sie wurde von Mathematikern im Jahr 1900 eingehend untersucht.# >>> tri.call(3)\n# [1, 3, 2, 8]\ndef tri(n)\n","canonical_solution":"def tri(n)\n  sequence = [1, 3]\n  \n  (2..n).each do |i|\n    if i.even?\n      sequence[i] = 1 + i \/ 2\n    else\n      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0\n    end\n  end\n  \n  sequence[0..n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n    assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_131","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Gibt 0 zurück, wenn alle Ziffern gerade sind. Geben Sie eine positive ganze Zahl n, und geben Sie das Produkt der ungeraden Ziffern zurück. # >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n# 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n","canonical_solution":"def digits(n)\n  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }\n  return 0 if odd_digits.empty?\n  odd_digits.reduce(:*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5, candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5, candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625, candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"},{"task_id":"HumanEval_132","nl":"deu_Latn","pl":"rb","prompt":"in dem mindestens eine Klammer in der Nachfolge eingebettet ist. Die Funktion sollte nur dann true zurückgeben, wenn eine gültige Unterfolge von Klammern vorhanden ist.Erstellen einer Funktion, die als Eingabe eine Zeichenfolge verwendet, die nur eckige Klammern enthält. # >>> is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n# false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n# false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\")\n# true\ndef is_nested(string)\n","canonical_solution":"def is_nested(string)\n  stack = []\n  has_nested = false\n\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n    elsif char == ']'\n      if stack.empty?\n        return false\n      end\n      stack.pop\n      has_nested = true if stack.any?\n    end\n  end\n\n  has_nested\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false, candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n    assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false, candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n    assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"[[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"))\n  end\nend\n"},{"task_id":"HumanEval_133","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Runden Sie jedes Element im Array zuerst auf die obere Int (Ciling) ab.Sie müssen die Summe der Quadratzahlen in dem gegebenen Array zurückgeben, Sie erhalten eine Reihe von Zahlen.# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0, 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4, 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map { |num| (num.ceil)**2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0, 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))\n  end\nend\n"},{"task_id":"HumanEval_134","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Anmerkung: \"Wort\" ist eine Gruppe von Zeichen, die durch Leerzeichen getrennt sind.Ein Teil eines Wortes, und sonst falsch.ist ein alphabetisches Zeichen und nicht Erstellen Sie eine Funktion , die true zurückgibt , wenn das letzte Zeichen # >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n","canonical_solution":"check_if_last_char_is_a_letter = ->(txt) {\n  return false if txt.strip.empty?\n  words = txt.strip.split(' ')\n  last_word = words.last\n  return false if last_word.empty?\n  last_char = last_word[-1]\n\n  last_char =~ \/[a-zA-Z]\/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')\n}","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false, candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false, candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false, candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple pi e \"))\n  end\nend\n"},{"task_id":"HumanEval_135","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Die Daten sind in der Regel nicht eindeutig.Wenn kein solches Element vorhanden ist, wird -1 zurückgegeben.ist nicht größer oder gleich dem Element, das unmittelbar davor liegt.Erstellen einer Funktion, die den größten Index eines Elements zurückgibt, das # >>> can_arrange.call([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange.call([1, 2, 3])\n# -1\ndef can_arrange(arr)\n","canonical_solution":"def can_arrange(arr)\n  (1...arr.length).reverse_each do |i|\n    return i if arr[i] < arr[i - 1]\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_can_arrange\n    candidate = method(:can_arrange)\n    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))\n    assert_equal(-1, candidate.call([1, 2, 4, 5]))\n    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))\n    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))\n    assert_equal(-1, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_136","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Wenn keine negativen oder positiven Ganzzahlen vorhanden sind, wird null als Rückgabe angegeben.von positiven Ganzzahlen in einem Array.Die größte der negativen Ganzen, und \"b\" ist die kleinste Erstellen einer Funktion, die ein Array (a, b) zurückgibt, wobei 'a'  ist.# >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n# [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n","canonical_solution":"def largest_smallest_integers(lst)\n  largest_negative = nil\n  smallest_positive = nil\n  \n  lst.each do |num|\n    if num < 0\n      largest_negative = num if largest_negative.nil? || num > largest_negative\n    elsif num > 0\n      smallest_positive = num if smallest_positive.nil? || num < smallest_positive\n    end\n  end\n  \n  [largest_negative, smallest_positive]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil, nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))\n  end\nend\n"},{"task_id":"HumanEval_137","nl":"deu_Latn","pl":"rb","prompt":"Anmerkung: Wenn eine reelle Zahl als Zeichenfolge dargestellt wird, kann die Gleitkomma-Einheit . oder ,  sein.Gibt null zurück, wenn die Werte gleich sind. realer Zahlen und gibt die größere Variable in ihrem gegebenen Variabletyp zurück. Erstellen Sie eine Funktion, die Ganzzahlen, Floats oder Zeichenketten mit der Repräsentation # >>> compare_one.call(1, 2.5)\n# 2.5\n# >>> compare_one.call(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one.call(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one.call(\"1\", 1)\n# nil\ndef compare_one(a, b)\n","canonical_solution":"def compare_one(a, b)\n  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')\n  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')\n\n  if a.is_a?(String) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Float)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Float)\n    a = a.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Integer)\n    b = b.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Float)\n    b = b.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(String)\n    a = a.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  else\n    return nil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare_one\n    candidate = method(:compare_one)\n    assert_equal(2, candidate.call(1, 2))\n    assert_equal(2.5, candidate.call(1, 2.5))\n    assert_equal(3, candidate.call(2, 3))\n    assert_equal(6, candidate.call(5, 6))\n    assert_equal(\"2,3\", candidate.call(1, \"2,3\"))\n    assert_equal(\"6\", candidate.call(\"5,1\", \"6\"))\n    assert_equal(\"2\", candidate.call(\"1\", \"2\"))\n    assert_equal(nil, candidate.call(\"1\", 1))\n  end\nend\n"},{"task_id":"HumanEval_138","nl":"deu_Latn","pl":"rb","prompt":"Beispiel Beurteilen Sie, ob die gegebene Zahl n als die Summe von genau 4 positiven geraden Zahlen geschrieben werden kann.# >>> is_equal_to_sum_even.call(4)\n# false\n# >>> is_equal_to_sum_even.call(6)\n# false\n# >>> is_equal_to_sum_even.call(8)\n# true\ndef is_equal_to_sum_even(n)\n","canonical_solution":"def is_equal_to_sum_even(n)\n  return false if n < 8\n  n.even?\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_equal_to_sum_even\n    candidate = method(:is_equal_to_sum_even)\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(8))\n    assert_equal(true, candidate.call(10))\n    assert_equal(false, candidate.call(11))\n    assert_equal(true, candidate.call(12))\n    assert_equal(false, candidate.call(13))\n    assert_equal(true, candidate.call(16))\n  end\nend\n"},{"task_id":"HumanEval_139","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: wo n > 0 Das ist die gleiche Zahl wie in der Tabelle.Das brasilianische Faktor ist definiert als: # >>> special_factorial.call(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\ndef special_factorial(n)\n","canonical_solution":"def special_factorial(n)\n  return 1 if n <= 1\n  (1..n).inject(1) { |product, i| product * factorial(i) }\nend\n\ndef factorial(num)\n  return 1 if num <= 1\n  (2..num).inject(1, :*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n    assert_equal(1, candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_140","nl":"deu_Latn","pl":"rb","prompt":"Dann ersetzen Sie alle aufeinanderfolgenden Leerzeichen durch - und wenn eine Zeichenfolge mehr als 2 aufeinanderfolgende Leerzeichen enthält, Wenn Sie eine Textfolge erhalten, ersetzen Sie alle Leerzeichen durch Unterstriche, # >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n","canonical_solution":"def fix_spaces(text)\n  text.strip.gsub(\/\\s{3,}\/, '-').gsub(' ', '_')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2 2 mple\"))\n  end\nend\n"},{"task_id":"HumanEval_141","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: - Die Unterkette nach dem Punkt sollte eine dieser sein: ['txt', 'exe', 'dll'] Die Kommission hat die Kommission ersucht, die in Artikel 1 genannten Maßnahmen zu überprüfen.- Die Unterkette vor dem Punkt sollte nicht leer sein, und es beginnt mit einem Buchstaben von - Der Dateiname enthält genau einen Punkt.- Der Name der Datei darf nicht mehr als drei Ziffern (\"0\" - \"9\") umfassen. erfüllt sind: Ein Dateiname gilt als gültig, wenn und nur wenn alle folgenden Bedingungen erfüllt sind:\"Ja\", wenn der Name der Datei gültig ist, und gibt \"Nein\" ansonsten zurück. Erstellen einer Funktion, die eine Zeichenfolge, die den Namen einer Datei darstellt, nimmt und zurückgibt # >>> file_name_check.call(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check.call(\"1example.dll\")\n# \"No\"\ndef file_name_check(file_name)\n","canonical_solution":"def file_name_check(file_name)\n  # Check if there's exactly one dot in the filename\n  return 'No' unless file_name.count('.') == 1\n  \n  # Split the filename into the name and extension\n  name, extension = file_name.split('.')\n  \n  # Check if the name part starts with a letter\n  return 'No' if name.empty? || !name[0].match?(\/[a-zA-Z]\/)\n  \n  # Check if the extension is valid\n  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)\n  \n  # Count digits in the file name\n  digit_count = file_name.count(\"0-9\")\n  \n  # Check if digits are more than three\n  return 'No' if digit_count > 3\n  \n  'Yes'\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_file_name_check\n    candidate = method(:file_name_check)\n    assert_equal(\"Yes\", candidate.call(\"example.txt\"))\n    assert_equal(\"No\", candidate.call(\"1example.dll\"))\n    assert_equal(\"No\", candidate.call(\"s1sdf3.asd\"))\n    assert_equal(\"Yes\", candidate.call(\"K.dll\"))\n    assert_equal(\"Yes\", candidate.call(\"MY16FILE3.exe\"))\n    assert_equal(\"No\", candidate.call(\"His12FILE94.exe\"))\n    assert_equal(\"No\", candidate.call(\"_Y.txt\"))\n    assert_equal(\"No\", candidate.call(\"?aREYA.exe\"))\n    assert_equal(\"No\", candidate.call(\"\/this_is_valid.dll\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.wow\"))\n    assert_equal(\"Yes\", candidate.call(\"this_is_valid.txt\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.txtexe\"))\n    assert_equal(\"No\", candidate.call(\"#this2_i4s_5valid.ten\"))\n    assert_equal(\"No\", candidate.call(\"@this1_is6_valid.exe\"))\n    assert_equal(\"No\", candidate.call(\"this_is_12valid.6exe4.txt\"))\n    assert_equal(\"No\", candidate.call(\"all.exe.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"I563_No.exe\"))\n    assert_equal(\"Yes\", candidate.call(\"Is3youfault.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"no_one#knows.dll\"))\n    assert_equal(\"No\", candidate.call(\"1I563_Yes3.exe\"))\n    assert_equal(\"No\", candidate.call(\"I563_Yes3.txtt\"))\n    assert_equal(\"No\", candidate.call(\"final..txt\"))\n    assert_equal(\"No\", candidate.call(\"final132\"))\n    assert_equal(\"No\", candidate.call(\"_f4indsartal132.\"))\n    assert_equal(\"No\", candidate.call(\".txt\"))\n    assert_equal(\"No\", candidate.call(\"s.\"))\n  end\nend\n"},{"task_id":"HumanEval_142","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Die Funktion ändert die Einträge im Array, deren Indizes nicht ein Vielfaches von 3 oder 4 sind.Die Funktion wird nicht  als ein Vielfaches von 3 und wird den Ganzzahleneintrag kubisieren, wenn sein Index ein Vielfaches von 4 und nicht ein Vielfaches von 3 ist.Diese Funktion nimmt ein Array von Ganzzahlen an. Für alle Einträge im Array wird die Funktion den Ganzzahlen-Eintrag quadrieren, wenn sein Index a  ist.\" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map.with_index do |num, index|\n    if index % 3 == 0\n      num ** 2\n    elsif index % 4 == 0\n      num ** 3\n    else\n      num\n    end\n  end.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(6, candidate.call([1, 2, 3]))\n    assert_equal(14, candidate.call([1, 4, 9]))\n    assert_equal(0, candidate.call([]))\n    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n    assert_equal(0, candidate.call([0]))\n    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))\n    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))\n    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))\n    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))\n    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))\n  end\nend\n"},{"task_id":"HumanEval_143","nl":"deu_Latn","pl":"rb","prompt":"Beispiel 1: Die Reihenfolge der Wörter in der neuen Zeichenfolge sollte die gleiche wie die ursprüngliche sein.deren Längen Primzahlen sind, und Sie müssen eine Zeichenfolge zurückgeben, die die Wörter aus dem ursprünglichen Satz enthält, der Satz enthält einige durch Leerzeichen getrennte Wörter, Sie erhalten eine Zeichenfolge, die einen Satz darstellt, # >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n","canonical_solution":"def words_in_sentence(sentence)\n  def is_prime?(num)\n    return false if num <= 1\n    (2..Math.sqrt(num)).none? { |i| num % i == 0 }\n  end\n  \n  words = sentence.split(\" \")\n  prime_length_words = words.select { |word| is_prime?(word.length) }\n  prime_length_words.join(\" \")\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"))\n  end\nend\n"},{"task_id":"HumanEval_144","nl":"deu_Latn","pl":"rb","prompt":"Man kann annehmen, dass x und n gültige Brüche sind und keinen Null-Nenner haben.<Zähler>\/<Namen­ner>, wobei sowohl Zähler als auch Nenner positive ganze Zahlen sind. Sowohl x als auch n sind String-Darstellungen eines Bruchs und haben das folgende Format:x * n. Die Funktion gibt true zurück, wenn x * n eine ganze Zahl ist und false Ihre Aufgabe ist es , eine Funktion zu implementieren , die den Ausdruck vereinfacht .# >>> simplify.call(\"1\/5\", \"5\/1\")\n# true\n# >>> simplify.call(\"1\/6\", \"2\/1\")\n# false\n# >>> simplify.call(\"7\/10\", \"10\/2\")\n# false\ndef simplify(x, n)\n","canonical_solution":"def simplify(x, n)\n  # Convert x and n to numerators and denominators\n  num_x, den_x = x.split('\/').map(&:to_i)\n  num_n, den_n = n.split('\/').map(&:to_i)\n\n  # Multiply fractions: (num_x * num_n) \/ (den_x * den_n)\n  numerator = num_x * num_n\n  denominator = den_x * den_n\n\n  # Check if the result is a whole number\n  numerator % denominator == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_simplify\n    candidate = method(:simplify)\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/6\", \"2\/1\"))\n    assert_equal(true, candidate.call(\"5\/1\", \"3\/1\"))\n    assert_equal(false, candidate.call(\"7\/10\", \"10\/2\"))\n    assert_equal(true, candidate.call(\"2\/10\", \"50\/10\"))\n    assert_equal(true, candidate.call(\"7\/2\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"11\/6\", \"6\/1\"))\n    assert_equal(false, candidate.call(\"2\/3\", \"5\/2\"))\n    assert_equal(false, candidate.call(\"5\/2\", \"3\/5\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"8\/4\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/5\", \"1\/5\"))\n  end\nend\n"},{"task_id":"HumanEval_145","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Ordnen Sie sie nach ihrem Index im ursprünglichen Array.Anmerkung: Wenn mehrere Posten mit ähnlicher Summe ihrer Ziffern vorliegen, in aufsteigender Reihenfolge nach der Summe ihrer Ziffern. Schreiben Sie eine Funktion , die das gesamte Array von Ganzen sortiert .# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n","canonical_solution":"def order_by_points(nums)\n  nums.sort_by.with_index do |num, index|\n    [num.to_s.chars.map(&:to_i).sum.abs, index]\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"},{"task_id":"HumanEval_146","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Die erste und letzte Ziffer einer Zahl sind ungerade (1, 3, 5, 7, 9).die Anzahl der Elemente im Array, die größer als 10 sind und beide Schreiben Sie eine Funktion , die ein Array von Zahlen als Eingabe nimmt und zurückgibt .# >>> specialFilter.call([15, -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\ndef specialFilter(nums)\n","canonical_solution":"def specialFilter(nums)\n  nums.count do |num|\n    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5, -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_147","nl":"deu_Latn","pl":"rb","prompt":"Beispiel:und a[i] + a[j] + a[k] ist ein Vielfaches von 3.Gibt die Anzahl der Dreifachzahl (a[i], a[j], a[k]) von a zurück, wobei i < j < k, Für jedes i (1 ≤ i ≤ n) ist der Wert von a[i] = i * i - i + 1. Sie erhalten eine positive ganze Zahl n. Sie müssen ein ganzzahliges Array a mit der Länge n erstellen.# >>> get_max_triples.call(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\ndef get_max_triples(n)\n","canonical_solution":"def get_max_triples(n)\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  count = 0\n  \n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      (j+1...n).each do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n    assert_equal(53361, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_148","nl":"deu_Latn","pl":"rb","prompt":"Beispiele sind nicht die richtigen Planetennamen.Die Funktion sollte ein leeres Array zurückgeben, wenn planet1 oder planet2 Die Nähe zur Sonne.zwischen der Umlaufbahn von Planet1 und der Umlaufbahn von Planet2 gelegen, sortiert nach Die Funktion sollte ein Array mit allen Planeten zurückgeben, deren Umlaufbahnen Schreiben Sie eine Funktion, die zwei Planetennamen als Zeichenketten planet1 und planet2 nimmt. Uranus, Neptun.ist Merkur, der nächste ist Venus, dann die Erde, Mars, Jupiter, Saturn,Es gibt acht Planeten in unserem Sonnensystem: die am nächsten zur Sonne .# >>> bf.call(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf.call(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf.call(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\ndef bf(planet1, planet2)\n","canonical_solution":"def bf(planet1, planet2)\n  planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \n  idx1 = planets.index(planet1)\n  idx2 = planets.index(planet2)\n  \n  return [] if idx1.nil? || idx2.nil?\n\n  start_idx, end_idx = [idx1, idx2].sort\n  \n  planets[(start_idx + 1)...end_idx]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_bf\n    candidate = method(:bf)\n    assert_equal([\"Saturn\", \"Uranus\"], candidate.call(\"Jupiter\", \"Neptune\"))\n    assert_equal([\"Venus\"], candidate.call(\"Earth\", \"Mercury\"))\n    assert_equal([\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], candidate.call(\"Mercury\", \"Uranus\"))\n    assert_equal([\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], candidate.call(\"Neptune\", \"Venus\"))\n    assert_equal([], candidate.call(\"Earth\", \"Earth\"))\n    assert_equal([], candidate.call(\"Mars\", \"Earth\"))\n    assert_equal([], candidate.call(\"Jupiter\", \"Makemake\"))\n  end\nend\n"},{"task_id":"HumanEval_149","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: Sie können annehmen, dass alle Wörter die gleiche Länge haben.Die Funktion sollte ein Array von Zeichenfolgen in sortierter Reihenfolge zurückgeben. Wenn zwei Wörter die gleiche Länge haben, sortieren Sie das Array alphabetisch.sollte das Array zurückgeben, das nach dieser Regel sortiert wurde.Die Reihenfolge der Reihe sollte steigen durch Länge jedes Wortes, und Sie und es können doppelte Dokumente enthalten.Das Array ist immer ein Array von Strings und nie ein Array von Zahlen, und gibt das resultierende Array mit einer sortierten Reihenfolge zurück, löscht die Zeichenfolgen, die ungerade Längen von ihm haben, Schreiben Sie eine Funktion, die ein Array von Zeichenketten als Parameter akzeptiert, # >>> list_sort.call([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n","canonical_solution":"def list_sort(arr)\n  arr.select { |s| s.length.even? }\n     .sort_by { |s| [s.length, s] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\", \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"], candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"},{"task_id":"HumanEval_150","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Eine Primzahl und sollte den Wert von y zurückgeben.Ein einfaches Programm, das den Wert von x zurückgibt, wenn n  ist.# >>> x_or_y.call(7, 34, 12)\n# 34\n# >>> x_or_y.call(15, 8, 5)\n# 5\ndef x_or_y(n, x, y)\n","canonical_solution":"def x_or_y(n, x, y)\n  require 'prime'\n  n.prime? ? x : y\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_x_or_y\n    candidate = method(:x_or_y)\n    assert_equal(34, candidate.call(7, 34, 12))\n    assert_equal(5, candidate.call(15, 8, 5))\n    assert_equal(33, candidate.call(3, 33, 5212))\n    assert_equal(3, candidate.call(1259, 3, 52))\n    assert_equal(-1, candidate.call(7919, -1, 12))\n    assert_equal(583, candidate.call(3609, 1245, 583))\n    assert_equal(129, candidate.call(91, 56, 129))\n    assert_equal(1234, candidate.call(6, 34, 1234))\n    assert_equal(0, candidate.call(1, 2, 0))\n    assert_equal(2, candidate.call(2, 2, 0))\n  end\nend\n"},{"task_id":"HumanEval_151","nl":"deu_Latn","pl":"rb","prompt":"Ignorieren Sie Zahlen, die negativ sind oder keine ganzen Zahlen.Gibt man uns ein Array von Zahlen, gibt man die Summe der Quadrate der Zahlen zurück.# >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1, -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n# 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n","canonical_solution":"def double_the_difference(lst)\n  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }\n     .map { |n| n ** 2 }\n     .sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"},{"task_id":"HumanEval_152","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Der Wert ist 0, und wenn nicht, ist der Wert die absolute Differenz zwischen der Vermutung und der Punktzahl. Gibt ein Array der gleichen Länge zurück, das anzeigt, wie weit jede Vermutung entfernt war.Sie erhalten zwei Arrays von Punkten und Vermutungen von gleicher Länge, wobei jeder Index eine Übereinstimmung zeigt.Ihre Aufgabe ist es, festzustellen, ob eine Person die Ergebnisse einer Reihe von Spielen richtig erraten hat.Die Ergebnisse sind auf jeden Fall wert, aufgenommen und verglichen zu werden.Die Gefühle und Gedanken, die Sie in diesem Moment haben, sind Ich glaube , wir alle erinnern uns an dieses Gefühl , wenn das Ergebnis eines lang erwarteten ...# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\ndef compare(game, guess)\n","canonical_solution":"def compare(game, guess)\n  game.zip(guess).map { |score, prediction| (score - prediction).abs }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_153","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: (ihre Stärke beträgt -1).\"Slices.SERVINGSliCes\" zurückgeben, da \"SERVINGSliCes\" die stärkste Erweiterung ist Sie können auch die folgenden Erweiterungen verwenden: ['SErviNGSliCes', 'Cheese', 'StuFfed'], dann sollten Sie Zum Beispiel, wenn Sie \"Slices\" als die Klasse und ein Array der Wählen Sie die, die zuerst im Array erscheint.Wenn zwei oder mehr Extensions mit der gleichen Stärke vorliegen, sollten SieFormat: Klassenname. Stärkste ErweiterungName. Sie sollten die stärkste Erweiterung finden und eine Zeichenkette in diesem zurückgeben .In der Bezeichnung der Erweiterung wird die Stärke durch den Bruchteil CAP - SM angegeben. Buchstaben im Namen der Erweiterung, wobei SM die Anzahl der Kleinbuchstaben Die Stärke der Erweiterung lautet wie folgt: CAP ist die Zahl des Großbuchstabes Die Erweiterungen sollen dazu verwendet werden, zusätzliche Klassen zur Klasse zu laden.Sie erhalten den Namen einer Klasse (eine Zeichenfolge) und ein Array von Erweiterungen.# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n","canonical_solution":"def Strongest_Extension(class_name, extensions)\n  strongest_extension = extensions.max_by do |extension|\n    cap_count = extension.count('A-Z')\n    sm_count = extension.count('a-z')\n    cap_count - sm_count\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\", candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\", candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"_\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\", [\"671235\", \"Bb\"]))\n  end\nend\n"},{"task_id":"HumanEval_154","nl":"deu_Latn","pl":"rb","prompt":"Sie müssen true zurückgeben, wenn das zweite Wort oder eine seiner Rotationen eine Unterkette im ersten Wort ist.# >>> cycpattern_check.call(\"abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n# >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n# >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a, b)\n","canonical_solution":"def cycpattern_check(a, b)\n  (0...b.length).each do |i|\n    rotated_b = b[i..-1] + b[0...i]\n    return true if a.include?(rotated_b)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true, candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"))\n  end\nend\n"},{"task_id":"HumanEval_155","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Geben wir eine ganze Zahl. Gibt eine Reihe zurück, die die Anzahl der geraden und ungeraden Ziffern hat.# >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n# [1, 2]\ndef even_odd_count(num)\n","canonical_solution":"def even_odd_count(num)\n  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"},{"task_id":"HumanEval_156","nl":"deu_Latn","pl":"rb","prompt":"Beispiele: Beschränkungen: 1 <= num <= 1000 und geben Sie es in Kleinbuchstaben zurück. Geben Sie eine positive ganze Zahl, erhalten Sie ihr römisches Zahlenäquivalent als Zeichenfolge, # >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n# \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n","canonical_solution":"def int_to_mini_roman(number)\n  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n  result = ''\n  values.each_with_index do |value, index|\n    while number >= value\n      number -= value\n      result += numerals[index]\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"},{"task_id":"HumanEval_157","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: 90 Grad.Ein rechtwinkliges Dreieck ist ein Dreieck, in dem ein Winkel ein rechter Winkel ist oderDie Seiten bilden ein rechtwinkliges Dreieck, ansonsten falsch.Gibt die Längen der drei Seiten eines Dreiecks zurück, so dass die drei # >>> right_angle_triangle.call(3, 4, 5)\n# true\n# >>> right_angle_triangle.call(1, 2, 3)\n# false\ndef right_angle_triangle(a, b, c)\n","canonical_solution":"def right_angle_triangle(a, b, c)\n  sides = [a, b, c].sort\n  sides[0]**2 + sides[1]**2 == sides[2]**2\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_right_angle_triangle\n    candidate = method(:right_angle_triangle)\n    assert_equal(true, candidate.call(3, 4, 5))\n    assert_equal(false, candidate.call(1, 2, 3))\n    assert_equal(true, candidate.call(10, 6, 8))\n    assert_equal(false, candidate.call(2, 2, 2))\n    assert_equal(true, candidate.call(7, 24, 25))\n    assert_equal(false, candidate.call(10, 5, 7))\n    assert_equal(true, candidate.call(5, 12, 13))\n    assert_equal(true, candidate.call(15, 8, 17))\n    assert_equal(true, candidate.call(48, 55, 73))\n    assert_equal(false, candidate.call(1, 1, 1))\n    assert_equal(false, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_158","nl":"deu_Latn","pl":"rb","prompt":"Die Zahl der Buchstaben, die in der lexikographischen Reihenfolge zuerst erscheinen, wird zurückgegeben.Wenn mehrere Strings haben maximale Anzahl von einzigartigen Das Array enthält verschiedene Wörter. Gibt das Wort mit der maximalen Anzahl zurück.Schreiben Sie eine Funktion, die ein Array von Zeichenketten akzeptiert. # >>> find_max.call([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n","canonical_solution":"def find_max(words)\n  # Helper function to count unique characters\n  def unique_char_count(word)\n    word.chars.uniq.size\n  end\n\n  words.max_by { |word| [unique_char_count(word), -word] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n  end\nend\n"},{"task_id":"HumanEval_159","nl":"deu_Latn","pl":"rb","prompt":"Beispiel: Wenn nicht genug Karotten übrig sind, wirst du alle Karotten essen, aber immer noch hungrig sein.die Anzahl der Karotten, die nach den Mahlzeiten übrig sind] Sie sollten eine Reihe von [ Gesamtzahl der gegessenen Karotten nach den Mahlzeiten, Aber jetzt musst du mehr Karotten essen, um die Mahlzeiten des Tages zu vervollständigen.Du bist ein hungriges Kaninchen, und du hast schon eine bestimmte Anzahl von Karotten gegessen,# >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1, 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number, need, remaining)\n","canonical_solution":"def eat(number, need, remaining)\n  total_eaten = number + [need, remaining].min\n  carrots_left = [remaining - need, 0].max\n  [total_eaten, carrots_left]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1, 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9, 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n  end\nend\n"},{"task_id":"HumanEval_160","nl":"deu_Latn","pl":"rb","prompt":"Operatorarray hat mindestens einen Operator und Operandarray hat mindestens zwei Operanden.Operand ist ein Array von nicht-negativen Ganzzahlen.Die Länge des Operator-Arrays ist gleich der Länge des Operand-Arrays minus eins.Anmerkung:=> Ergebnis = 9 Ergebnis = 2 + 3 * 4 - 5 Die Angabe der Angabe ist in der Tabelle zu finden.der Betreiber['+', '*', '-'] Beispiel: Exponentierung (**) Die Unterteilung der Stockwerke ( \/\/) Multiplikation (*) Abzug ( - ) Zusammensetzung (+) Die grundlegenden Algebraoperationen:Ausdruck und gibt die Auswertung dieses Ausdrucks zurück. Das zweite Array ist ein Array von Ganzzahlen. Verwenden Sie die beiden Arrays, um die Algebra zu erstellen.Angesichts zweier Arrays Operator und Operand. Das erste Array hat grundlegende Algebraoperationen und def do_algebra(operator, operand)\n","canonical_solution":"def do_algebra(operator, operand)\n  expression = operand[0].to_s\n  operator.each_with_index do |op, index|\n    if op == '\/\/'\n      expression += ' \/ ' + operand[index + 1].to_s\n    else\n      expression += ' ' + op + ' ' + operand[index + 1].to_s\n    end\n  end\n  eval(expression)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\", \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\", \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"\/\/\", \"*\"], [7, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_161","nl":"deu_Latn","pl":"rb","prompt":"Beispiele Die Funktion sollte die resultierende Zeichenfolge zurückgeben. Wenn die Zeichenfolge keine Buchstaben enthält, kehren Sie die Zeichenfolge um.Ansonsten bleibt es so.Wenn s[i] ein Buchstabe ist, wird der Groß- und Kleinschriftart von unten nach oben oder umgekehrt umgedreht.Sie erhalten eine Zeichenfolge s.# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n","canonical_solution":"def solve(s)\n  if s =~ \/[a-zA-Z]\/\n    s.chars.map { |char| char =~ \/[a-zA-Z]\/ ? char.swapcase : char }.join\n  else\n    s.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\", candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"#$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"},{"task_id":"HumanEval_162","nl":"deu_Latn","pl":"rb","prompt":"Wenn 'text' eine leere Zeichenfolge ist, wird null zurückgegeben. Geben Sie eine Zeichenfolge \"text\" und geben Sie ihre md5-Hash-Äquivalenz zurück. # >>> string_to_md5.call(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n","canonical_solution":"require 'digest'\n\ndef string_to_md5(text)\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\", candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"))\n  end\nend\n"},{"task_id":"HumanEval_163","nl":"deu_Latn","pl":"rb","prompt":"Zum Beispiel: und b in aufsteigender Reihenfolge.Gibt man zwei positive ganze Zahlen a und b, gibt man die geraden Ziffern zwischen a und b zurück.# >>> generate_integers.call(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10, 14)\n# []\ndef generate_integers(a, b)\n","canonical_solution":"def generate_integers(a, b)\n  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2, 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2, 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n  end\nend\n"}]