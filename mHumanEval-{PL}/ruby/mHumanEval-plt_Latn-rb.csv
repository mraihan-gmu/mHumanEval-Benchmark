task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,plt_Latn,rb,"ny fetra nomena. Jereo raha ao anatin'ny laharana nomena isa, misy isa roa mifanakaiky kokoa noho ny # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)
# false
# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
# true
def has_close_elements(numbers, threshold)
","def has_close_elements(numbers, threshold)
  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_has_close_elements
    candidate = method(:has_close_elements)
    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))
    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))
    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))
    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))
    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))
    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))
    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))
  end
end
"
HumanEval_1,plt_Latn,rb,"Aza dinihina ny toerana rehetra ao amin'ny tadin'ny fidirana.Mifanaraka tsara ny tarika tsirairay (mifamatotra tsara ny fehikibo misokatra tsirairay) ary tsy mifamatotra Manasaraka ireo vondrona ireo ho andian-dahatsoratra misaraka ary mamerina ny laharan'ireo. Ny fampidirana ho an'ity fiasa ity dia tady misy vondrona marobe misy fonosana voatahiry. Ny tanjonao dia ny # >>> separate_paren_groups.call(""( ) (( )) (( )( ))"")
# [""()"", ""(())"", ""(()())""]
def separate_paren_groups(paren_string)
","def separate_paren_groups(paren_string)
  # Remove spaces from the string
  paren_string = paren_string.gsub("" "", """")
  
  result = []
  current_group = """"
  balance = 0

  paren_string.each_char do |char|
    current_group += char
    balance += 1 if char == '('
    balance -= 1 if char == ')'

    if balance == 0 && !current_group.empty?
      result << current_group
      current_group = """"
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_separate_paren_groups
    candidate = method(:separate_paren_groups)
    assert_equal([""(()())"", ""((()))"", ""()"", ""((())()())""], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([""()"", ""(())"", ""((()))"", ""(((())))""], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([""(()(())((())))""], candidate.call(""(()(())((())))""))
    assert_equal([""()"", ""(())"", ""(()())""], candidate.call(""( ) (( )) (( )( ))""))
  end
end
"
HumanEval_2,plt_Latn,rb,"Avereno ny ampahany desimaly amin'ny isa. (ny ampahany sisa tavela dia kely kokoa noho ny 1).sy ampahany amin'ny isa iray manontolo (isa iray manontolo lehibe indrindra kely kokoa noho ny isa nomena) ary ny isa folo Raha nomena isa isa miovaova miova, dia azo zaraina ho # >>> truncate_number.call(3.5)
# 0.5
def truncate_number(number)
","def truncate_number(number)
  number - number.to_i
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_truncate_number
    candidate = method(:truncate_number)
    assert_equal(0.5, candidate.call(3.5))
    assert_equal(0.25, candidate.call(1.25))
    assert_equal(0.0, candidate.call(123.0))
  end
end
"
HumanEval_3,plt_Latn,rb,"amin'io fotoana io dia tokony hiverina ho marina ny fiasa. Raha tsy izany dia tokony hiverina ho diso. Ny asanao dia ny mamantatra raha toa ka latsaka ambanin'ny zero ny fifandanjan'ny kaonty, ary Nomena anao ny karazana tahiry sy fisintomana amin'ny kaonty banky izay manomboka amin'ny # >>> below_zero.call([1, 2, 3])
# false
# >>> below_zero.call([1, 2, -4, 5])
# true
def below_zero(operations)
","def below_zero(operations)
  balance = 0
  operations.each do |operation|
    balance += operation
    return true if balance < 0
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_zero
    candidate = method(:below_zero)
    assert_equal(false, candidate.call([]))
    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))
    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))
    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))
    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))
    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))
  end
end
"
HumanEval_4,plt_Latn,rb,"MAD = salanisa. x - x_mean. singa sy teboka afovoany (midin'ny tranga amin'ity tranga ity): Ny salan'isan'ny fiviliana tanteraka dia ny salan'isan'ny fahasamihafana tanteraka eo amin'ny tsirairay amin'izy ireo.manodidina ny salan'isan'ny angon-drakitra. Ho an'ny laharana nomena isa fidirana, kajy ny Mean Absolute Deviation # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])
# 1.0
def mean_absolute_deviation(numbers)
","def mean_absolute_deviation(numbers)
  mean = numbers.sum.to_f / numbers.size
  deviations = numbers.map { |num| (num - mean).abs }
  deviations.sum / numbers.size
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_mean_absolute_deviation
    candidate = method(:mean_absolute_deviation)
    assert_equal(0.5, candidate.call([1.0, 2.0]))
    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))
    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
  end
end
"
HumanEval_5,plt_Latn,rb,"Ampidiro ny isa ""delimeter"" eo anelanelan'ny singa roa misesy amin'ny laharana fidirana âˆ€numbers"" # >>> intersperse.call([], 4)
# []
# >>> intersperse.call([1, 2, 3], 4)
# [1, 4, 2, 4, 3]
def intersperse(numbers, delimeter)
","def intersperse(numbers, delimeter)
  return numbers if numbers.empty?
  result = []
  numbers.each_with_index do |num, index|
    result << num
    result << delimeter unless index == numbers.size - 1
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersperse
    candidate = method(:intersperse)
    assert_equal([], candidate.call([], 7))
    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))
    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))
  end
end
"
HumanEval_6,plt_Latn,rb,"Ohatra, ny (() (()) dia manana ambaratonga roa farafahakeliny raha toa ka ny ((())) manana telo. Ho an'ny vondrona tsirairay, mamoaka ny ambaratonga lalina indrindra amin'ny fananganana fononteny. Ny fidirana amin'ity fiasa ity dia tady maneho vondrona marobe ho an'ny fonosana voatahiry misaraka amin'ny habaka.# >>> parse_nested_parens.call(""(()()) ((())) () ((())()())"")
# [2, 3, 1, 3]
def parse_nested_parens(paren_string)
","def parse_nested_parens(paren_string)
  paren_string.split.map do |group|
    max_depth = current_depth = 0
    group.chars.each do |char|
      if char == '('
        current_depth += 1
        max_depth = [max_depth, current_depth].max
      elsif char == ')'
        current_depth -= 1
      end
    end
    max_depth
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_nested_parens
    candidate = method(:parse_nested_parens)
    assert_equal([2, 3, 1, 3], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([1, 2, 3, 4], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([4], candidate.call(""(()(())((())))""))
  end
end
"
HumanEval_7,plt_Latn,rb,"Fandinihana ny laharan-dahatsoratra iray misy ny laharana nomena fotsiny ho an'ireo izay misy ny laharana nomena # >>> filter_by_substring.call([], ""a"")
# []
# >>> filter_by_substring.call([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
# [""abc"", ""bacd"", ""array""]
def filter_by_substring(strings, substring)
","def filter_by_substring(strings, substring)
  strings.select { |string| string.include?(substring) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_substring
    candidate = method(:filter_by_substring)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
    assert_equal([""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""))
    assert_equal([""grunt"", ""prune""], candidate.call([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""))
  end
end
"
HumanEval_8,plt_Latn,rb,"Ny sombiny foana dia tokony ho mitovy amin'ny 0 ary ny vokatra foana dia tokony ho mitovy amin'ny 1. Ho an'ny laharana iray nomena isa feno, avereno ny laharana misy ny sombiny sy ny vokatra amin'ny isa feno rehetra ao anaty laharana. # >>> sum_product.call([])
# [0, 1]
# >>> sum_product.call([1, 2, 3, 4])
# [10, 24]
def sum_product(numbers)
","def sum_product(numbers)
  sum = numbers.reduce(0, :+)
  product = numbers.reduce(1, :*)
  [sum, product]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_product
    candidate = method(:sum_product)
    assert_equal([0, 1], candidate.call([]))
    assert_equal([3, 1], candidate.call([1, 1, 1]))
    assert_equal([100, 0], candidate.call([100, 0]))
    assert_equal([15, 105], candidate.call([3, 5, 7]))
    assert_equal([10, 10], candidate.call([10]))
  end
end
"
HumanEval_9,plt_Latn,rb,"ao amin'ny filaharany.Avy amin'ny laharana nomena isa feno, mamorona laharana misy ny singa ambony indrindra hita hatramin'ny fotoana nomena # >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])
# [1, 2, 3, 3, 3, 4, 4]
def rolling_max(numbers)
","def rolling_max(numbers)
  max_so_far = numbers.first
  numbers.map do |num|
    max_so_far = [max_so_far, num].max
  end
end

# Example usage:
# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rolling_max
    candidate = method(:rolling_max)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))
    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))
  end
end
"
HumanEval_10,plt_Latn,rb,"- Ampifanaraho amin'ny faran'ny tadin'ny tadin'ny prefix izay tonga alohan'ny suffix palindromika. - Mitadiava ny postfix lava indrindra amin'ny tady nomena izay palindrome. Tsotra ny hevitra momba ny algorithm: Mitadiava palindrome fohy indrindra izay manomboka amin'ny tady nomena. # >>> make_palindrome.call("""")
# """"
# >>> make_palindrome.call(""cat"")
# ""catac""
# >>> make_palindrome.call(""cata"")
# ""catac""
def make_palindrome(string)
","def make_palindrome(string)
  return string if string.empty?

  def is_palindrome?(s)
    s == s.reverse
  end

  (0...string.length).reverse_each do |i|
    if is_palindrome?(string[i..-1])
      return string + string[0...i].reverse
    end
  end

  string
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_palindrome
    candidate = method(:make_palindrome)
    assert_equal("""", candidate.call(""""))
    assert_equal(""x"", candidate.call(""x""))
    assert_equal(""xyzyx"", candidate.call(""xyz""))
    assert_equal(""xyx"", candidate.call(""xyx""))
    assert_equal(""jerryrrej"", candidate.call(""jerry""))
  end
end
"
HumanEval_11,plt_Latn,rb,"Ataovy binary XOR amin'ireo fidirana ireo ary avereno ny valiny ho toy ny tadiny. Ny fidirana dia tady roa a sy b izay ahitana 1 sy 0 ihany.# >>> string_xor.call(""010"", ""110"")
# ""100""
def string_xor(a, b)
","def string_xor(a, b)
  result = """"
  a.length.times do |i|
    result << (a[i] == b[i] ? ""0"" : ""1"")
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_xor
    candidate = method(:string_xor)
    assert_equal(""010010"", candidate.call(""111000"", ""101010""))
    assert_equal(""0"", candidate.call(""1"", ""1""))
    assert_equal(""0101"", candidate.call(""0101"", ""0000""))
  end
end
"
HumanEval_12,plt_Latn,rb,"Miverina nil raha toa ka foana ny array fidirana. Avy amin'ny andian-dahatsoratra, avereno ny lava indrindra. Avereno ny voalohany raha misy maromaro # >>> longest.call([])
# nil
# >>> longest.call([""a"", ""b"", ""c""])
# ""a""
# >>> longest.call([""a"", ""bb"", ""ccc""])
# ""ccc""
def longest(strings)
","def longest(strings)
  return nil if strings.empty?
  strings.max_by(&:length)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_longest
    candidate = method(:longest)
    assert_equal(nil, candidate.call([]))
    assert_equal(""x"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""zzzz"", candidate.call([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]))
  end
end
"
HumanEval_13,plt_Latn,rb,"Avereno ny mpizara iraisana lehibe indrindra amin'ny isa roa a sy b # >>> greatest_common_divisor.call(3, 5)
# 1
# >>> greatest_common_divisor.call(25, 15)
# 5
def greatest_common_divisor(a, b)
","def greatest_common_divisor(a, b)
  while b != 0
    a, b = b, a % b
  end
  a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_greatest_common_divisor
    candidate = method(:greatest_common_divisor)
    assert_equal(1, candidate.call(3, 7))
    assert_equal(5, candidate.call(10, 15))
    assert_equal(7, candidate.call(49, 14))
    assert_equal(12, candidate.call(144, 60))
  end
end
"
HumanEval_14,plt_Latn,rb,"Miverina ny laharan'ny prefix rehetra manomboka amin'ny fohy indrindra ka hatramin'ny lava indrindra amin'ny tadin'ny fidirana # >>> all_prefixes.call(""abc"")
# [""a"", ""ab"", ""abc""]
def all_prefixes(string)
","def all_prefixes(string)
  (1..string.length).map { |i| string[0, i] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_all_prefixes
    candidate = method(:all_prefixes)
    assert_equal([], candidate.call(""""))
    assert_equal([""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""], candidate.call(""asdfgh""))
    assert_equal([""W"", ""WW"", ""WWW""], candidate.call(""WWW""))
  end
end
"
HumanEval_15,plt_Latn,rb,"Miverina ny tady misy isa voafetra amin'ny habaka manomboka amin'ny 0 ka hatramin'ny n tafiditra. # >>> string_sequence.call(0)
# ""0""
# >>> string_sequence.call(5)
# ""0 1 2 3 4 5""
def string_sequence(n)
","def string_sequence(n)
  (0..n).to_a.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_sequence
    candidate = method(:string_sequence)
    assert_equal(""0"", candidate.call(0))
    assert_equal(""0 1 2 3"", candidate.call(3))
    assert_equal(""0 1 2 3 4 5 6 7 8 9 10"", candidate.call(10))
  end
end
"
HumanEval_16,plt_Latn,rb,"Raha omena tady iray, fantaro hoe firy ny tarehin-tsoratra miavaka (tsy ijerena ny tranga) no ahitana azy # >>> count_distinct_characters.call(""xyzXYZ"")
# 3
# >>> count_distinct_characters.call(""Jerry"")
# 4
def count_distinct_characters(string)
","def count_distinct_characters(string)
  string.downcase.chars.uniq.count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_distinct_characters
    candidate = method(:count_distinct_characters)
    assert_equal(0, candidate.call(""""))
    assert_equal(5, candidate.call(""abcde""))
    assert_equal(5, candidate.call(""abcdecadeCADE""))
    assert_equal(1, candidate.call(""aaaaAAAAaaaa""))
    assert_equal(5, candidate.call(""Jerry jERRY JeRRRY""))
  end
end
"
HumanEval_17,plt_Latn,rb,"'Haheno' - feon-kira efatra, maharitra iray heny 'o "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""'O' - naoty iray manontolo, maharitra efatra beats Indro ny angano: tsy farany. Ny asanao dia ny mamakafaka ity kofehy ity ary mamerina ny laharan'ny isa feno mifanaraka amin'ny isa isa isa ny isa tsirairay.Ny fampidirana ho an'ity asa ity dia tady maneho ny tononkira amin'ny endrika ASCII manokana.# >>> parse_music.call(""o o| .| o| o| .| .| .| .| o o"")
# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
def parse_music(music_string)
","def parse_music(music_string)
  # Split the input string into individual notes.
  notes = music_string.split

  # Map each note to its corresponding number of beats.
  notes.map do |note|
    case note
    when 'o'
      4
    when 'o|'
      2
    when '.|'
      1
    else
      0
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_music
    candidate = method(:parse_music)
    assert_equal([], candidate.call(""""))
    assert_equal([4, 4, 4, 4], candidate.call(""o o o o""))
    assert_equal([1, 1, 1, 1], candidate.call("".| .| .| .|""))
    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(""o| o| .| .| o o o o""))
    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(""o| .| o| .| o o| o o|""))
  end
end
"
HumanEval_18,plt_Latn,rb,"Fantaro hoe impiry ny substring nomena no hita ao amin'ny tadiny tany am-boalohany. Manisa ireo tranga mifandona. # >>> how_many_times.call("""", ""a"")
# 0
# >>> how_many_times.call(""aaa"", ""a"")
# 3
# >>> how_many_times.call(""aaaa"", ""aa"")
# 3
def how_many_times(string, substring)
","def how_many_times(string, substring)
  return 0 if substring.empty?
  count = 0
  i = 0
  while i <= string.length - substring.length
    if string[i, substring.length] == substring
      count += 1
    end
    i += 1
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_how_many_times
    candidate = method(:how_many_times)
    assert_equal(0, candidate.call("""", ""x""))
    assert_equal(4, candidate.call(""xyxyxyx"", ""x""))
    assert_equal(4, candidate.call(""cacacacac"", ""cac""))
    assert_equal(1, candidate.call(""john doe"", ""john""))
  end
end
"
HumanEval_19,plt_Latn,rb,"Avereno ny laharana misy isa voalahatra avy amin'ny kely indrindra ka hatramin'ny lehibe indrindra Ny safidy manan-kery dia ""zero"", ""iray"", ""roa"", ""telo"", ""efatra"", ""dimy"", ""enina"", ""fito"", ""valo"" ary ""sivy"". Ny fidirana dia andian-tarehimarika voafetra amin'ny habaka manomboka amin'ny 'zero' ka hatramin'ny 'sivy'.# >>> sort_numbers.call(""three one five"")
# ""one three five""
def sort_numbers(numbers)
","def sort_numbers(numbers)
  numeral_map = {
    'zero' => 0,
    'one' => 1,
    'two' => 2,
    'three' => 3,
    'four' => 4,
    'five' => 5,
    'six' => 6,
    'seven' => 7,
    'eight' => 8,
    'nine' => 9
  }

  number_words = numbers.split
  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }
  sorted_numbers.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_numbers
    candidate = method(:sort_numbers)
    assert_equal("""", candidate.call(""""))
    assert_equal(""three"", candidate.call(""three""))
    assert_equal(""three five nine"", candidate.call(""three five nine""))
    assert_equal(""zero four five seven eight nine"", candidate.call(""five zero four seven nine eight""))
    assert_equal(""zero one two three four five six"", candidate.call(""six five four three two one zero""))
  end
end
"
HumanEval_20,plt_Latn,rb,"hafa ary avereno araka ny filaharany (isa kely kokoa, isa lehibe kokoa).Avy amin'ny nomerao nomena (izay roa farafahakeliny) dia safidio ary avereno ny roa izay akaiky indrindra amin'ny tsirairay # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
# [2.0, 2.2]
# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
# [2.0, 2.0]
def find_closest_elements(numbers)
","def find_closest_elements(numbers)
  sorted_numbers = numbers.sort
  closest_pair = [sorted_numbers[0], sorted_numbers[1]]
  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs

  (1...(sorted_numbers.length - 1)).each do |i|
    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs
    if current_difference < min_difference
      min_difference = current_difference
      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]
    end
  end

  closest_pair
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_closest_elements
    candidate = method(:find_closest_elements)
    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))
    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))
    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))
    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))
    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))
  end
end
"
HumanEval_21,plt_Latn,rb,"ka ny isa kely indrindra dia ho lasa 0 ary ny isa lehibe indrindra ho lasa 1 Raha omena ny laharana isa (amin'ny singa roa farafahakeliny), ampiharo ny fanovana tsipika amin'io laharana io, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])
# [0.0, 0.25, 0.5, 0.75, 1.0]
def rescale_to_unit(numbers)
","def rescale_to_unit(numbers)
  min = numbers.min
  max = numbers.max
  range = max - min
  return numbers.map { |num| (num - min) / range.to_f }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rescale_to_unit
    candidate = method(:rescale_to_unit)
    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))
    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))
    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))
  end
end
"
HumanEval_22,plt_Latn,rb,"Sivana nomena array misy rbthon soatoavina ho an'ny integers ihany # >>> filter_integers.call([""a"", 3.14, 5])
# [5]
# >>> filter_integers.call([1, 2, 3, ""abc"", {}, []])
# [1, 2, 3]
def filter_integers(values)
","def filter_integers(values)
  values.select { |value| value.is_a?(Integer) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_integers
    candidate = method(:filter_integers)
    assert_equal([], candidate.call([]))
    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, ""adasd""]))
    assert_equal([3, 3, 3], candidate.call([3, ""c"", 3, 3, ""a"", ""b""]))
  end
end
"
HumanEval_23,plt_Latn,rb,"Miverena amin'ny halavan'ny tadin-teny nomena # >>> strlen.call("""")
# 0
# >>> strlen.call(""abc"")
# 3
def strlen(string)
","strlen = lambda do |string|
  string.length
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strlen
    candidate = method(:strlen)
    assert_equal(0, candidate.call(""""))
    assert_equal(1, candidate.call(""x""))
    assert_equal(9, candidate.call(""asdasnakj""))
  end
end
"
HumanEval_24,plt_Latn,rb,"Ho an'ny isa nomena n, tadiavo ny isa lehibe indrindra izay mizara n mitovy, kely kokoa noho ny n # >>> largest_divisor.call(15)
# 5
def largest_divisor(n)
","def largest_divisor(n)
  (n - 1).downto(1) do |i|
    return i if n % i == 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_divisor
    candidate = method(:largest_divisor)
    assert_equal(1, candidate.call(3))
    assert_equal(1, candidate.call(7))
    assert_equal(5, candidate.call(10))
    assert_equal(50, candidate.call(100))
    assert_equal(7, candidate.call(49))
  end
end
"
HumanEval_25,plt_Latn,rb,"Ny isa miditra dia tokony hitovy amin'ny vokatra amin'ny lafin-javatra rehetra Isaky ny mipoitra ao amin'ny famaritana ny isa ny isa tsirairay dia tokony ho isaina ny isa.Miverina ny laharana misy ireo laharam-pahamehana amin'ny isa iray manontolo nomena amin'ny filaharana manomboka amin'ny kely indrindra ka hatramin'ny lehibe indrindra. # >>> factorize.call(8)
# [2, 2, 2]
# >>> factorize.call(25)
# [5, 5]
# >>> factorize.call(70)
# [2, 5, 7]
def factorize(n)
","def factorize(n)
  factors = []
  divisor = 2
  while n > 1
    while n % divisor == 0
      factors << divisor
      n /= divisor
    end
    divisor += 1
  end
  factors
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_factorize
    candidate = method(:factorize)
    assert_equal([2], candidate.call(2))
    assert_equal([2, 2], candidate.call(4))
    assert_equal([2, 2, 2], candidate.call(8))
    assert_equal([3, 19], candidate.call(57))
    assert_equal([3, 3, 19, 19], candidate.call(3249))
    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))
    assert_equal([3, 19, 19, 19], candidate.call(20577))
    assert_equal([2, 3, 3], candidate.call(18))
  end
end
"
HumanEval_26,plt_Latn,rb,"Ataovy mitovy ny filaharan'ny singa sisa tavela amin'ny fidirana.Avy amin'ny array iray misy integer, esory ny singa rehetra izay miseho mihoatra ny indray mandeha. # >>> remove_duplicates.call([1, 2, 3, 2, 4])
# [1, 3, 4]
def remove_duplicates(numbers)
","def remove_duplicates(numbers)
  numbers.select { |num| numbers.count(num) == 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_duplicates
    candidate = method(:remove_duplicates)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))
  end
end
"
HumanEval_27,plt_Latn,rb,"Ho an'ny tadiny iray, afindra amin'ny litera lehibe ny litera kely ary ny litera lehibe ho amin'ny litera kely. # >>> flip_case.call(""Hello"")
# ""hELLO""
def flip_case(string)
","def flip_case(string)
  string.swapcase
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_flip_case
    candidate = method(:flip_case)
    assert_equal("""", candidate.call(""""))
    assert_equal(""hELLO!"", candidate.call(""Hello!""))
    assert_equal(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"", candidate.call(""These violent delights have violent ends""))
  end
end
"
HumanEval_28,plt_Latn,rb,"Manambatra ny andian-dahatsoratra ho lasa andian-dahatsoratra tokana # >>> concatenate.call([])
# """"
# >>> concatenate.call([""a"", ""b"", ""c""])
# ""abc""
def concatenate(strings)
","def concatenate(strings)
  strings.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_concatenate
    candidate = method(:concatenate)
    assert_equal("""", candidate.call([]))
    assert_equal(""xyz"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""xyzwk"", candidate.call([""x"", ""y"", ""z"", ""w"", ""k""]))
  end
end
"
HumanEval_29,plt_Latn,rb,"Ny sivana ny laharana fampidirana dia tsy misy afa-tsy ireo izay manomboka amin'ny prefix nomena. # >>> filter_by_prefix.call([], ""a"")
# []
# >>> filter_by_prefix.call([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
# [""abc"", ""array""]
def filter_by_prefix(strings, prefix)
","def filter_by_prefix(strings, prefix)
  strings.select { |string| string.start_with?(prefix) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_prefix
    candidate = method(:filter_by_prefix)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
  end
end
"
HumanEval_30,plt_Latn,rb,"Miverina isa tsara ao amin'ny array ihany. # >>> get_positive.call([-1, 2, -4, 5, 6])
# [2, 5, 6]
# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# [5, 3, 2, 3, 9, 123, 1]
def get_positive(l)
","get_positive = lambda do |l|
  l.select { |num| num > 0 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_positive
    candidate = method(:get_positive)
    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))
    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))
    assert_equal([], candidate.call([-1, -2]))
    assert_equal([], candidate.call([]))
  end
end
"
HumanEval_31,plt_Latn,rb,"Miverina marina raha misy isa nomena voalohany, ary diso raha tsy izany. # >>> is_prime.call(6)
# false
# >>> is_prime.call(101)
# true
# >>> is_prime.call(11)
# true
# >>> is_prime.call(13441)
# true
# >>> is_prime.call(61)
# true
# >>> is_prime.call(4)
# false
# >>> is_prime.call(1)
# false
def is_prime(n)
","is_prime = lambda do |n|
  return false if n <= 1
  return true if n == 2
  return false if n.even?

  max_divisor = Math.sqrt(n).to_i
  (3..max_divisor).step(2).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_prime
    candidate = method(:is_prime)
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(101))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(13441))
    assert_equal(true, candidate.call(61))
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(1))
    assert_equal(true, candidate.call(5))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(17))
    assert_equal(false, candidate.call(85))
    assert_equal(false, candidate.call(77))
    assert_equal(false, candidate.call(255379))
  end
end
"
HumanEval_33,plt_Latn,rb,"ny soatoavina ny indices mifanaraka amin'ny l, fa voalamina. l' dia mitovy amin'ny l amin'ny indices izay tsy azo zaraina amin'ny telo, raha ny soatoaviny amin'ny indices izay azo zaraina amin'ny telo dia mitovy Ity fiasa ity dia mandray array l ary mamerina array l ' toy izany fa # >>> sort_third.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])
# [2, 6, 3, 4, 8, 9, 5]
def sort_third(l)
","def sort_third(l)
  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort
  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_third
    candidate = method(:sort_third)
    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))
    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))
    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))
    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))
  end
end
"
HumanEval_34,plt_Latn,rb,"Mamerina ireo singa tokana voarindra ao anaty array iray # >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [0, 2, 3, 5, 9, 123]
def unique(l)
","def unique(l)
  l.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique
    candidate = method(:unique)
    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_35,plt_Latn,rb,"Miverina ny singa lehibe indrindra ao amin'ny array. # >>> max_element.call([1, 2, 3])
# 3
# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# 123
def max_element(l)
","def max_element(l)
  l.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_element
    candidate = method(:max_element)
    assert_equal(3, candidate.call([1, 2, 3]))
    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))
  end
end
"
HumanEval_36,plt_Latn,rb,"Avereno ny isan'ny fotoana miseho ny tarehimarika 7 amin'ny isa feno latsaky ny n izay azo zaraina amin'ny 11 na 13. # >>> fizz_buzz.call(50)
# 0
# >>> fizz_buzz.call(78)
# 2
# >>> fizz_buzz.call(79)
# 3
def fizz_buzz(n)
","def fizz_buzz(n)
  count = 0
  (1...n).each do |i|
    if i % 11 == 0 || i % 13 == 0
      count += i.to_s.count('7')
    end
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fizz_buzz
    candidate = method(:fizz_buzz)
    assert_equal(0, candidate.call(50))
    assert_equal(2, candidate.call(78))
    assert_equal(3, candidate.call(79))
    assert_equal(3, candidate.call(100))
    assert_equal(6, candidate.call(200))
    assert_equal(192, candidate.call(4000))
    assert_equal(639, candidate.call(10000))
    assert_equal(8026, candidate.call(100000))
  end
end
"
HumanEval_37,plt_Latn,rb,"ny soatoavina ny na dia indices ny l, fa voalamina. l' dia mitovy amin'ny l amin'ny indices hafahafa, raha mitovy ny lanjany amin'ny indices mitovy Ity fiasa ity dia mandray array l ary mamerina array l ' toy izany fa # >>> sort_even.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_even.call([5, 6, 3, 4])
# [3, 6, 5, 4]
def sort_even(l)
","def sort_even(l)
  even_indices = l.each_index.select { |i| i.even? }
  even_values = even_indices.map { |i| l[i] }.sort
  
  even_index = 0
  l.each_with_index.map do |value, index|
    if index.even?
      even_values[even_index].tap { even_index += 1 }
    else
      value
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_even
    candidate = method(:sort_even)
    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))
    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
  end
end
"
HumanEval_39,plt_Latn,rb,"prime_fib mamerina ny isa n-faha izay isa Fibonacci ary prime ihany koa. # >>> prime_fib.call(1)
# 2
# >>> prime_fib.call(2)
# 3
# >>> prime_fib.call(3)
# 5
# >>> prime_fib.call(4)
# 13
# >>> prime_fib.call(5)
# 89
def prime_fib(n)
","def prime_fib(n)
  require 'prime'
  
  fibs = Enumerator.new do |y|
    a, b = 0, 1
    loop do
      a, b = b, a + b
      y << b
    end
  end
  
  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }
  prime_fibs.first(n).last
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_fib
    candidate = method(:prime_fib)
    assert_equal(2, candidate.call(1))
    assert_equal(3, candidate.call(2))
    assert_equal(5, candidate.call(3))
    assert_equal(13, candidate.call(4))
    assert_equal(89, candidate.call(5))
    assert_equal(233, candidate.call(6))
    assert_equal(1597, candidate.call(7))
    assert_equal(28657, candidate.call(8))
    assert_equal(514229, candidate.call(9))
    assert_equal(433494437, candidate.call(10))
  end
end
"
HumanEval_40,plt_Latn,rb,"Fampidirana ny zero, ary diso raha tsy izany. miverina ho marina raha misy singa telo miavaka ao amin'ny array izay mandray array iray misy integer ho toy ny fidirana ny triples_sum_to_zero. # >>> triples_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> triples_sum_to_zero.call([1, 3, -2, 1])
# true
# >>> triples_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])
# true
# >>> triples_sum_to_zero.call([1])
# false
def triples_sum_to_zero(l)
","def triples_sum_to_zero(l)
  n = l.length
  (0...n-2).each do |i|
    ((i+1)...n-1).each do |j|
      ((j+1)...n).each do |k|
        return true if l[i] + l[j] + l[k] == 0
      end
    end
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triples_sum_to_zero
    candidate = method(:triples_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, 5, -1]))
    assert_equal(true, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(false, candidate.call([1, 2, 5, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(false, candidate.call([1, 3, 5, -100]))
    assert_equal(false, candidate.call([100, 3, 5, -100]))
  end
end
"
HumanEval_41,plt_Latn,rb,"Ity fiasa ity dia mamoaka ny isan'ny fifandonana toy izany. amin'ny lÃ lan-kalehany toy ny tsy nifandona akory. Na izany aza, matanjaka sy matanjaka tsy manam-petra ireo fiara; vokatr'izany, dia mbola mandeha foana izy ireo rehefa misy fiara mihetsika miankavia miankavanana mamely fiara mihetsika miankavanana miankavia.Mifandona ny fiara roa, ary ny hafainganam-pandehan'ny fiara rehetra dia mitovy.Mihazakazaka avy eo ankavanana miankavia ireo fiara roa ireo.Fiara n no mandeha miankavia miankavanana; miaraka amin'izay, fiara n hafa Alao sary an-tsaina ny lÃ lana iray izay tsipika iray mahitsy tanteraka sy tsy manam-petra.def car_race_collision(n)
","def car_race_collision(n)
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_car_race_collision
    candidate = method(:car_race_collision)
    assert_equal(4, candidate.call(2))
    assert_equal(9, candidate.call(3))
    assert_equal(16, candidate.call(4))
    assert_equal(64, candidate.call(8))
    assert_equal(100, candidate.call(10))
  end
end
"
HumanEval_42,plt_Latn,rb,"Miverina array miaraka amin'ny singa nitombo 1. # >>> incr_list.call([1, 2, 3])
# [2, 3, 4]
# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [6, 4, 6, 3, 4, 4, 10, 1, 124]
def incr_list(l)
","def incr_list(l)
  l.map { |x| x + 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_incr_list
    candidate = method(:incr_list)
    assert_equal([], candidate.call([]))
    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))
    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_43,plt_Latn,rb,"Fampidirana ny zero, ary diso raha tsy izany. miverina ho marina raha misy singa roa miavaka ao amin'ny array izay pairs_sum_to_zero dia mandray ny laharan'ny isa manontolo ho toy ny fidirana. # >>> pairs_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> pairs_sum_to_zero.call([1, 3, -2, 1])
# false
# >>> pairs_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])
# true
# >>> pairs_sum_to_zero.call([1])
# false
def pairs_sum_to_zero(l)
","def pairs_sum_to_zero(l)
  num_set = l.to_set
  l.each do |num|
    return true if num != 0 && num_set.include?(-num)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pairs_sum_to_zero
    candidate = method(:pairs_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))
  end
end
"
HumanEval_44,plt_Latn,rb,"Ny isa fototra dia latsaky ny 10.miverina ny fanehoana ny tadin-teny aorian'ny fiovam-po. Ovao ho base ny base nomerika ny input number x. # >>> change_base.call(8, 3)
# ""22""
# >>> change_base.call(8, 2)
# ""1000""
# >>> change_base.call(7, 2)
# ""111""
def change_base(x, base)
","def change_base(x, base)
  return '0' if x == 0
  digits = []
  while x > 0
    digits << (x % base).to_s
    x /= base
  end
  digits.reverse.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_change_base
    candidate = method(:change_base)
    assert_equal(""22"", candidate.call(8, 3))
    assert_equal(""100"", candidate.call(9, 3))
    assert_equal(""11101010"", candidate.call(234, 2))
    assert_equal(""10000"", candidate.call(16, 2))
    assert_equal(""1000"", candidate.call(8, 2))
    assert_equal(""111"", candidate.call(7, 2))
    assert_equal(""2"", candidate.call(2, 3))
    assert_equal(""3"", candidate.call(3, 4))
    assert_equal(""4"", candidate.call(4, 5))
    assert_equal(""5"", candidate.call(5, 6))
    assert_equal(""6"", candidate.call(6, 7))
    assert_equal(""7"", candidate.call(7, 8))
  end
end
"
HumanEval_45,plt_Latn,rb,"Nomena ny halavan'ny lafiny iray sy ny faritra avo hiverenana ho an'ny telozoro. # >>> triangle_area.call(5, 3)
# 7.5
def triangle_area(a, h)
","def triangle_area(a, h)
  (a * h) / 2.0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(7.5, candidate.call(5, 3))
    assert_equal(2.0, candidate.call(2, 2))
    assert_equal(40.0, candidate.call(10, 8))
  end
end
"
HumanEval_46,plt_Latn,rb,"Azafady manorata fiasa iray mba hanisana ny singa faha-n amin'ny filaharan'ny isa fib4. Aza mampiasa fiverenana. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 Ny filaharan'ny isa Fib4 dia filaharana mitovy amin'ny filaharan'i Fibbonacci izay voafaritra toy izao manaraka izao: # >>> fib4.call(5)
# 4
# >>> fib4.call(6)
# 8
# >>> fib4.call(7)
# 14
def fib4(n)
","def fib4(n)
  return 0 if n == 0 || n == 1 || n == 3
  return 2 if n == 2

  fib4_seq = [0, 0, 2, 0]
  (4..n).each do |i|
    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]
  end
  fib4_seq[n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib4
    candidate = method(:fib4)
    assert_equal(4, candidate.call(5))
    assert_equal(28, candidate.call(8))
    assert_equal(104, candidate.call(10))
    assert_equal(386, candidate.call(12))
  end
end
"
HumanEval_47,plt_Latn,rb,"Miverena median ny singa ao amin'ny array l. # >>> median.call([3, 1, 2, 4, 5])
# 3
# >>> median.call([-10, 4, 6, 1000, 10, 20])
# 15.0
def median(l)
","def median(l)
  sorted = l.sort
  len = sorted.length
  if len.odd?
    sorted[len / 2]
  else
    (sorted[len / 2 - 1] + sorted[len / 2]) / 2.0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_median
    candidate = method(:median)
    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))
    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))
    assert_equal(5, candidate.call([5]))
    assert_equal(5.5, candidate.call([6, 5]))
    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))
  end
end
"
HumanEval_48,plt_Latn,rb,"Manamarina raha toa ka palindrome ny tady nomena # >>> is_palindrome.call("""")
# true
# >>> is_palindrome.call(""aba"")
# true
# >>> is_palindrome.call(""aaaaa"")
# true
# >>> is_palindrome.call(""zbcd"")
# false
def is_palindrome(text)
","is_palindrome = lambda do |text|
  text == text.reverse
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_palindrome
    candidate = method(:is_palindrome)
    assert_equal(true, candidate.call(""""))
    assert_equal(true, candidate.call(""aba""))
    assert_equal(true, candidate.call(""aaaaa""))
    assert_equal(false, candidate.call(""zbcd""))
    assert_equal(true, candidate.call(""xywyx""))
    assert_equal(false, candidate.call(""xywyz""))
    assert_equal(false, candidate.call(""xywzx""))
  end
end
"
HumanEval_49,plt_Latn,rb,"Miverena 2^n modulo p (mahafantatra ny isa).# >>> modp.call(3, 5)
# 3
# >>> modp.call(1101, 101)
# 2
# >>> modp.call(0, 101)
# 1
# >>> modp.call(3, 11)
# 8
# >>> modp.call(100, 101)
# 1
def modp(n, p)
","def modp(n, p)
  return 1 if p == 1
  2.pow(n, p)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_modp
    candidate = method(:modp)
    assert_equal(3, candidate.call(3, 5))
    assert_equal(2, candidate.call(1101, 101))
    assert_equal(1, candidate.call(0, 101))
    assert_equal(8, candidate.call(3, 11))
    assert_equal(1, candidate.call(100, 101))
    assert_equal(4, candidate.call(30, 5))
    assert_equal(3, candidate.call(31, 5))
  end
end
"
HumanEval_51,plt_Latn,rb,"remove_vowels dia fiasa izay maka tsipika ary mamerina tsipika tsy misy vowels. # >>> remove_vowels.call("""")
# """"
# >>> remove_vowels.call(""abcdef"")
# ""bcdf""
# >>> remove_vowels.call(""aaaaa"")
# """"
# >>> remove_vowels.call(""aaBAA"")
# ""B""
# >>> remove_vowels.call(""zbcd"")
# ""zbcd""
def remove_vowels(text)
","def remove_vowels(text)
  text.delete('aeiouAEIOU')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_vowels
    candidate = method(:remove_vowels)
    assert_equal("""", candidate.call(""""))
    assert_equal(""bcdf
ghjklm"", candidate.call(""abcdef
ghijklm""))
    assert_equal(""fdcb"", candidate.call(""fedcba""))
    assert_equal("""", candidate.call(""eeeee""))
    assert_equal(""cB"", candidate.call(""acBAA""))
    assert_equal(""cB"", candidate.call(""EcBOO""))
    assert_equal(""ybcd"", candidate.call(""ybcd""))
  end
end
"
HumanEval_52,plt_Latn,rb,"Miverina marina raha ny isa rehetra ao amin'ny array l dia ambany ny fetra t. # >>> below_threshold.call([1, 2, 4, 10], 100)
# true
# >>> below_threshold.call([1, 20, 4, 10], 5)
# false
def below_threshold(l, t)
","def below_threshold(l, t)
  l.all? { |num| num < t }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_threshold
    candidate = method(:below_threshold)
    assert_equal(true, candidate.call([1, 2, 4, 10], 100))
    assert_equal(false, candidate.call([1, 20, 4, 10], 5))
    assert_equal(true, candidate.call([1, 20, 4, 10], 21))
    assert_equal(true, candidate.call([1, 20, 4, 10], 22))
    assert_equal(true, candidate.call([1, 8, 4, 10], 11))
    assert_equal(false, candidate.call([1, 8, 4, 10], 10))
  end
end
"
HumanEval_53,plt_Latn,rb,"Ampio ny isa roa x sy y # >>> add.call(2, 3)
# 5
# >>> add.call(5, 7)
# 12
def add(x, y)
","add = ->(x, y) { x + y }","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(1, candidate.call(0, 1))
    assert_equal(1, candidate.call(1, 0))
    assert_equal(5, candidate.call(2, 3))
    assert_equal(12, candidate.call(5, 7))
    assert_equal(12, candidate.call(7, 5))
  end
end
"
HumanEval_54,plt_Latn,rb,"Jereo raha mitovy ny tarehin-tsoratra amin'ny teny roa. # >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
# true
# >>> same_chars.call(""abcd"", ""dddddddabc"")
# true
# >>> same_chars.call(""dddddddabc"", ""abcd"")
# true
# >>> same_chars.call(""eabcd"", ""dddddddabc"")
# false
# >>> same_chars.call(""abcd"", ""dddddddabce"")
# false
# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
# false
def same_chars(s0, s1)
","def same_chars(s0, s1)
  s0.chars.uniq.all? { |char| s1.include?(char) } &&
  s1.chars.uniq.all? { |char| s0.include?(char) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_same_chars
    candidate = method(:same_chars)
    assert_equal(true, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc""))
    assert_equal(true, candidate.call(""abcd"", ""dddddddabc""))
    assert_equal(true, candidate.call(""dddddddabc"", ""abcd""))
    assert_equal(false, candidate.call(""eabcd"", ""dddddddabc""))
    assert_equal(false, candidate.call(""abcd"", ""dddddddabcf""))
    assert_equal(false, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddddabc""))
    assert_equal(false, candidate.call(""aabb"", ""aaccc""))
  end
end
"
HumanEval_55,plt_Latn,rb,"Avereno ny isa n-n'ny Fibonacci. # >>> fib.call(10)
# 55
# >>> fib.call(1)
# 1
# >>> fib.call(8)
# 21
def fib(n)
","def fib(n)
  return n if n <= 1
  fib(n - 1) + fib(n - 2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib
    candidate = method(:fib)
    assert_equal(55, candidate.call(10))
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(8))
    assert_equal(89, candidate.call(11))
    assert_equal(144, candidate.call(12))
  end
end
"
HumanEval_56,plt_Latn,rb,"Miverina marina raha misy bracket fanokafana mifanitsy amin'ny bracket famaranana. brackets dia andian-dahatsoratra misy ""<"" sy "">"". # >>> correct_bracketing.call(""<"")
# false
# >>> correct_bracketing.call(""<>"")
# true
# >>> correct_bracketing.call(""<<><>>"")
# true
# >>> correct_bracketing.call(""><<>"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.chars.each do |char|
    if char == '<'
      balance += 1
    elsif char == '>'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""<>""))
    assert_equal(true, candidate.call(""<<><>>""))
    assert_equal(true, candidate.call(""<><><<><>><>""))
    assert_equal(true, candidate.call(""<><><<<><><>><>><<><><<>>>""))
    assert_equal(false, candidate.call(""<<<><>>>>""))
    assert_equal(false, candidate.call(""><<>""))
    assert_equal(false, candidate.call(""<""))
    assert_equal(false, candidate.call(""<<<<""))
    assert_equal(false, candidate.call("">""))
    assert_equal(false, candidate.call(""<<>""))
    assert_equal(false, candidate.call(""<><><<><>><>><<>""))
    assert_equal(false, candidate.call(""<><><<><>><>>><>""))
  end
end
"
HumanEval_57,plt_Latn,rb,"Miverina marina dia singa array dia monotonically mitombo na mihena. # >>> monotonic.call([1, 2, 4, 20])
# true
# >>> monotonic.call([1, 20, 4, 10])
# false
# >>> monotonic.call([4, 1, 0, -10])
# true
def monotonic(l)
","def monotonic(l)
  increasing = true
  decreasing = true

  (0...l.length - 1).each do |i|
    if l[i] < l[i + 1]
      decreasing = false
    elsif l[i] > l[i + 1]
      increasing = false
    end
  end

  increasing || decreasing
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_monotonic
    candidate = method(:monotonic)
    assert_equal(true, candidate.call([1, 2, 4, 10]))
    assert_equal(true, candidate.call([1, 2, 4, 20]))
    assert_equal(false, candidate.call([1, 20, 4, 10]))
    assert_equal(true, candidate.call([4, 1, 0, -10]))
    assert_equal(true, candidate.call([4, 1, 1, 0]))
    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))
    assert_equal(true, candidate.call([9, 9, 9, 9]))
  end
end
"
HumanEval_58,plt_Latn,rb,"Miverina ny singa iraisana tokana voalahatra ho an'ny array roa. # >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
# [1, 5, 653]
# >>> common.call([5, 3, 2, 8], [3, 2])
# [2, 3]
def common(l1, l2)
","def common(l1, l2)
  (l1 & l2).uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_common
    candidate = method(:common)
    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))
    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))
    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))
    assert_equal([], candidate.call([4, 3, 2, 8], []))
  end
end
"
HumanEval_59,plt_Latn,rb,"Avereno ny mpanisa voalohany lehibe indrindra amin'ny n. Mihevitra n > 1 ary tsy prime. # >>> largest_prime_factor.call(13195)
# 29
# >>> largest_prime_factor.call(2048)
# 2
def largest_prime_factor(n)
","def largest_prime_factor(n)
  factor = 2
  while factor * factor <= n
    if n % factor == 0
      n /= factor
    else
      factor += 1
    end
  end
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_prime_factor
    candidate = method(:largest_prime_factor)
    assert_equal(5, candidate.call(15))
    assert_equal(3, candidate.call(27))
    assert_equal(7, candidate.call(63))
    assert_equal(11, candidate.call(330))
    assert_equal(29, candidate.call(13195))
  end
end
"
HumanEval_60,plt_Latn,rb,"Ny sum_to_n dia fiasa izay manisa isa manomboka amin'ny 1 ka hatramin'ny n. # >>> sum_to_n.call(30)
# 465
# >>> sum_to_n.call(100)
# 5050
# >>> sum_to_n.call(5)
# 15
# >>> sum_to_n.call(10)
# 55
# >>> sum_to_n.call(1)
# 1
def sum_to_n(n)
","def sum_to_n(n)
  (1..n).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_to_n
    candidate = method(:sum_to_n)
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(6))
    assert_equal(66, candidate.call(11))
    assert_equal(465, candidate.call(30))
    assert_equal(5050, candidate.call(100))
  end
end
"
HumanEval_61,plt_Latn,rb,"Miverina marina raha misy bracket fanokafana mifanitsy amin'ny bracket famaranana. brackets dia andian-dahatsoratra misy ""("" sy "")"". # >>> correct_bracketing.call(""("")
# false
# >>> correct_bracketing.call(""()"")
# true
# >>> correct_bracketing.call(""(()())"")
# true
# >>> correct_bracketing.call("")(()"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.each_char do |char|
    if char == '('
      balance += 1
    elsif char == ')'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""()""))
    assert_equal(true, candidate.call(""(()())""))
    assert_equal(true, candidate.call(""()()(()())()""))
    assert_equal(true, candidate.call(""()()((()()())())(()()(()))""))
    assert_equal(false, candidate.call(""((()())))""))
    assert_equal(false, candidate.call("")(()""))
    assert_equal(false, candidate.call(""(""))
    assert_equal(false, candidate.call(""((((""))
    assert_equal(false, candidate.call("")""))
    assert_equal(false, candidate.call(""(()""))
    assert_equal(false, candidate.call(""()()(()())())(()""))
    assert_equal(false, candidate.call(""()()(()())()))()""))
  end
end
"
HumanEval_62,plt_Latn,rb,"Miverena amin'ny derivatives amin'ity polynÃ´me ity amin'ny endrika mitovy. xs[0] + xs[1] * x + xs[2] * x^2 + .... Ny xs dia maneho ny coefficients amin'ny polynÃ´me iray.# >>> derivative.call([3, 1, 2, 4, 5])
# [1, 4, 12, 20]
# >>> derivative.call([1, 2, 3])
# [2, 6]
def derivative(xs)
","def derivative(xs)
  return [] if xs.length < 2
  xs.each_with_index.map { |coef, index| coef * index }[1..-1]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_derivative
    candidate = method(:derivative)
    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))
    assert_equal([2, 6], candidate.call([1, 2, 3]))
    assert_equal([2, 2], candidate.call([3, 2, 1]))
    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))
    assert_equal([], candidate.call([1]))
  end
end
"
HumanEval_63,plt_Latn,rb,"Azafady soraty ny fiasa iray mba hanisana ny singa faha-n amin'ny filaharan'ny isa fibfib. fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). fifib ((2) == 1 fifib ((1) == 0 fifib ((0) == 0 Ny filaharan'ny isa FibFib dia filaharana mitovy amin'ny filaharan'i Fibbonacci izay voafaritra toy izao manaraka izao: # >>> fibfib.call(1)
# 0
# >>> fibfib.call(5)
# 4
# >>> fibfib.call(8)
# 24
def fibfib(n)
","def fibfib(n)
  return 0 if n == 0 || n == 1
  return 1 if n == 2

  a, b, c = 0, 0, 1
  (3..n).each do
    a, b, c = b, c, a + b + c
  end
  c
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fibfib
    candidate = method(:fibfib)
    assert_equal(1, candidate.call(2))
    assert_equal(0, candidate.call(1))
    assert_equal(4, candidate.call(5))
    assert_equal(24, candidate.call(8))
    assert_equal(81, candidate.call(10))
    assert_equal(274, candidate.call(12))
    assert_equal(927, candidate.call(14))
  end
end
"
HumanEval_64,plt_Latn,rb,"Ohatra: voal, fa rehefa eo amin'ny faran'ny teny nomena ihany. Ny voambolana amin'ity tranga ity dia 'a', 'e', 'i', 'o', 'u'. Eto, 'y' dia a ihany koa teny ho toy ny fidirana ary miverina ny isan'ny vowels ao amin'ny kofehy. Soraty ny fiasan'ny vowels_count izay mandray ny kofehy maneho ny # >>> vowels_count.call(""abcde"")
# 2
# >>> vowels_count.call(""ACEDY"")
# 3
def vowels_count(s)
","def vowels_count(s)
  vowels = ['a', 'e', 'i', 'o', 'u']
  count = 0
  
  s.chars.each_with_index do |char, index|
    if vowels.include?(char.downcase)
      count += 1
    elsif char.downcase == 'y' && index == s.length - 1
      count += 1
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_vowels_count
    candidate = method(:vowels_count)
    assert_equal(2, candidate.call(""abcde""))
    assert_equal(3, candidate.call(""Alone""))
    assert_equal(2, candidate.call(""key""))
    assert_equal(1, candidate.call(""bye""))
    assert_equal(2, candidate.call(""keY""))
    assert_equal(1, candidate.call(""bYe""))
    assert_equal(3, candidate.call(""ACEDY""))
  end
end
"
HumanEval_65,plt_Latn,rb,"Raha miova > isa isa, miverina ny isa mivadika. ary avereno ho toy ny tadiny ny valiny. Mifindra boribory ny tarehimarika amin'ny integer x, mifindra miankavanana ny tarehimarika amin'ny alalan'ny fifindrana # >>> circular_shift.call(12, 1)
# ""21""
# >>> circular_shift.call(12, 2)
# ""12""
def circular_shift(x, shift)
","def circular_shift(x, shift)
  digits = x.to_s.chars
  num_digits = digits.length

  if shift > num_digits
    return digits.reverse.join
  else
    shift = shift % num_digits
    shifted_digits = digits.rotate(-shift)
    return shifted_digits.join
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_circular_shift
    candidate = method(:circular_shift)
    assert_equal(""001"", candidate.call(100, 2))
    assert_equal(""12"", candidate.call(12, 2))
    assert_equal(""79"", candidate.call(97, 8))
    assert_equal(""21"", candidate.call(12, 1))
    assert_equal(""11"", candidate.call(11, 101))
  end
end
"
HumanEval_66,plt_Latn,rb,"Ohatra: Kaody ASCII. Soraty ny fiasa izay mandray ny tady ho toy ny fidirana sy miverina ny sombin'ny ambony ihany no tarehin-tsoratra "" Asa # >>> digitSum.call("""")
# 0
# >>> digitSum.call(""abAB"")
# 131
# >>> digitSum.call(""abcCd"")
# 67
# >>> digitSum.call(""helloE"")
# 69
# >>> digitSum.call(""woArBld"")
# 131
# >>> digitSum.call(""aAaaaXa"")
# 153
def digitSum(s)
","def digitSum(s)
  s.chars.select { |char| char =~ /[A-Z]/ }.map(&:ord).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digitSum
    candidate = method(:digitSum)
    assert_equal(0, candidate.call(""""))
    assert_equal(131, candidate.call(""abAB""))
    assert_equal(67, candidate.call(""abcCd""))
    assert_equal(69, candidate.call(""helloE""))
    assert_equal(131, candidate.call(""woArBld""))
    assert_equal(153, candidate.call(""aAaaaXa""))
    assert_equal(151, candidate.call("" How are yOu?""))
    assert_equal(327, candidate.call(""You arE Very Smart""))
  end
end
"
HumanEval_67,plt_Latn,rb,"ho an'ny examble: ao anaty harona dia avereno ny isan'ny voan'ny manga ao anaty harona. ny voankazo sy ny paoma ary ny isa iray maneho ny isan'ny voankazo rehetra Ohabolana Ny voankazo dia omena ny isa rehetra amin'ny voankazo.izay zaraina ao anaty harona misy voankazo ao anatin'io harona io Amin'ity asa ity, homena tady iray izay maneho ny isa paoma sy voasary ianao # >>> fruit_distribution.call(""5 apples and 6 oranges"", 19)
# 8
# >>> fruit_distribution.call(""0 apples and 1 oranges"", 3)
# 2
# >>> fruit_distribution.call(""2 apples and 3 oranges"", 100)
# 95
# >>> fruit_distribution.call(""100 apples and 1 oranges"", 120)
# 19
def fruit_distribution(s, n)
","def fruit_distribution(s, n)
  numbers = s.scan(/\d+/).map(&:to_i)
  apples = numbers[0]
  oranges = numbers[1]
  total_fruits = n
  mangos = total_fruits - (apples + oranges)
  mangos
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fruit_distribution
    candidate = method(:fruit_distribution)
    assert_equal(8, candidate.call(""5 apples and 6 oranges"", 19))
    assert_equal(10, candidate.call(""5 apples and 6 oranges"", 21))
    assert_equal(2, candidate.call(""0 apples and 1 oranges"", 3))
    assert_equal(2, candidate.call(""1 apples and 0 oranges"", 3))
    assert_equal(95, candidate.call(""2 apples and 3 oranges"", 100))
    assert_equal(0, candidate.call(""2 apples and 3 oranges"", 5))
    assert_equal(19, candidate.call(""1 apples and 100 oranges"", 120))
  end
end
"
HumanEval_68,plt_Latn,rb,"Ohatra 1: Raha tsy misy ny sanda na ny laharana nomena dia foana, miverina []. Ny nodes voafafa dia tokony haverina ao anaty array, [smallest_value, ny index-ny ], Raha misy node maro miaraka amin'ny sanda kely indrindra dia miverina ny node izay manana index kely indrindra. Ny nodes voafafa dia tokony ho ny nodes manana ny kely indrindra na dia ny sanda. Ny asanao dia ny manaisotra ny iray amin'ireo nodes ary mamerina azy.""Raha nomena ny array maneho ny sampana iray amin'ny hazo izay manana node integer tsy miiba # >>> pluck.call([4, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 2:
# >>> pluck.call([1, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 3:
# >>> pluck.call([])
# []
# Example 4:
# >>> pluck.call([5, 0, 3, 0, 4, 2])
# [0, 1]
# Explanation: 0 is the smallest value, but  there are two zeros,
# so we will choose the first zero, which has the smallest index.
# Constraints:
# * 1 <= nodes.length <= 10000
# * 0 <= node.value
def pluck(arr)
","def pluck(arr)
  smallest_even = nil
  smallest_index = nil
  
  arr.each_with_index do |value, index|
    if value.even?
      if smallest_even.nil? || value < smallest_even
        smallest_even = value
        smallest_index = index
      end
    end
  end

  smallest_even.nil? ? [] : [smallest_even, smallest_index]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pluck
    candidate = method(:pluck)
    assert_equal([2, 1], candidate.call([4, 2, 3]))
    assert_equal([2, 1], candidate.call([1, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))
    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))
    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))
    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))
    assert_equal([], candidate.call([7, 9, 7, 1]))
  end
end
"
HumanEval_69,plt_Latn,rb,"Ohatra: Raha tsy misy ny sanda toy izany, miverina -1. Ny fahita matetika amin'ny isa iray dia ny isan'ny fotoana miseho ao amin'ny array.Zero, ary manana matetika lehibe kokoa na mitovy amin'ny sandan'ny integer mihitsy. Nomena anao ny array tsy banga misy integer miampy. avereno ny integer lehibe indrindra izay lehibe kokoa noho # >>> search.call([4, 1, 2, 2, 3, 1])
# 2
# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])
# 3
# >>> search.call([5, 5, 4, 4, 4])
# -1
def search(lst)
","def search(lst)
  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }
  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys
  valid_numbers.empty? ? -1 : valid_numbers.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_search
    candidate = method(:search)
    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))
    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))
    assert_equal(-1, candidate.call([3, 3]))
    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))
    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))
    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))
    assert_equal(2, candidate.call([3, 2, 8, 2]))
    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))
    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))
    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))
    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))
    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))
    assert_equal(1, candidate.call([1]))
    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))
    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))
    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))
    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))
    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))
    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))
    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))
    assert_equal(-1, candidate.call([10]))
    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))
    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))
    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))
    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))
  end
end
"
HumanEval_70,plt_Latn,rb,"Ohatra: avy eo ny isa ambony indrindra amin'ireo isa feno sisa tavela, avy eo ny isa ambany indrindra sy ny sisa.Ny fanasokajiana hafahafa, dia rehefa manomboka amin'ny sanda kely indrindra ianao, Raha nomena ny laharana iray misy isa feno dia avereno amin'ny laharana hafahafa ny laharana.# >>> strange_sort_list.call([1, 2, 3, 4])
# [1, 4, 2, 3]
# >>> strange_sort_list.call([5, 5, 5, 5])
# [5, 5, 5, 5]
# >>> strange_sort_list.call([])
# []
def strange_sort_list(lst)
","def strange_sort_list(lst)
  result = []
  lst.sort!
  until lst.empty?
    result << lst.shift
    result << lst.pop unless lst.empty?
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strange_sort_list
    candidate = method(:strange_sort_list)
    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))
    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))
    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))
    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))
    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))
    assert_equal([], candidate.call([]))
    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))
    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))
    assert_equal([111111], candidate.call([111111]))
  end
end
"
HumanEval_71,plt_Latn,rb,"Ohatra: noho ny lafiny fahatelo.Telozoro manan-kery ny lafiny telo raha lehibe kokoa ny fitambaran'ny lafiny roa.Raha tsy izany dia miverina -1 ny telozoro boribory amin'ny isa 2 desimaly raha toa ka telozoro marina ny lafiny telo. Raha jerena ny halavan'ny lafiny telo amin'ny telozoro iray, avereno ny velaran'ny # >>> triangle_area.call(3, 4, 5)
# 6.0
# >>> triangle_area.call(1, 2, 10)
# -1
def triangle_area(a, b, c)
","def triangle_area(a, b, c)
  # Check for valid triangle
  if a + b > c && a + c > b && b + c > a
    # Calculate the semi-perimeter
    s = (a + b + c) / 2.0
    # Calculate the area using Heron's formula
    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))
    # Round to 2 decimal points
    return area.round(2)
  else
    return -1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(6.0, candidate.call(3, 4, 5))
    assert_equal(-1, candidate.call(1, 2, 10))
    assert_equal(8.18, candidate.call(4, 8, 5))
    assert_equal(1.73, candidate.call(2, 2, 2))
    assert_equal(-1, candidate.call(1, 2, 3))
    assert_equal(16.25, candidate.call(10, 5, 7))
    assert_equal(-1, candidate.call(2, 6, 3))
    assert_equal(0.43, candidate.call(1, 1, 1))
    assert_equal(-1, candidate.call(2, 2, 10))
  end
end
"
HumanEval_72,plt_Latn,rb,"Ohatra: Ny zavatra q dia hanidina raha toa ka voalanjalanja (arakaraka ny palindromika) ary ny fitambaran'ny singa ao aminy dia kely kokoa na mitovy amin'ny lanjany ambony indrindra w.Soraty ny fiasa izay mamerina ny marina raha toa ka hanidina ny zavatra q, ary diso raha tsy izany. # >>> will_it_fly.call([1, 2], 5)
# false
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly.call([3, 2, 3], 1)
# false
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly.call([3, 2, 3], 9)
# true
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly.call([3], 5)
# true
# # 3 is less than the maximum possible weight, and it's balanced.
def will_it_fly(q, w)
","def will_it_fly(q, w)
  is_palindrome = q == q.reverse
  total_weight = q.sum
  is_balanced_and_under_weight = is_palindrome && total_weight <= w
  is_balanced_and_under_weight
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_will_it_fly
    candidate = method(:will_it_fly)
    assert_equal(true, candidate.call([3, 2, 3], 9))
    assert_equal(false, candidate.call([1, 2], 5))
    assert_equal(true, candidate.call([3], 5))
    assert_equal(false, candidate.call([3, 2, 3], 1))
    assert_equal(false, candidate.call([1, 2, 3], 6))
    assert_equal(true, candidate.call([5], 5))
  end
end
"
HumanEval_73,plt_Latn,rb,"Ohatra: dia vakiana mitovy hatrany na miverina na miverina. Amin'ny fanovana iray, azonao atao ny manova singa iray amin'ny singa hafa. Mila ovaina ny array mba ho palindromika.Raha nomena array arr misy integer, dia fantaro ny isa farafahakeliny misy ny singa izay # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])
# 4
# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])
# 1
# >>> smallest_change.call([1, 2, 3, 2, 1])
# 0
def smallest_change(arr)
","def smallest_change(arr)
  changes = 0
  left = 0
  right = arr.length - 1

  while left < right
    if arr[left] != arr[right]
      changes += 1
    end
    left += 1
    right -= 1
  end

  changes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_smallest_change
    candidate = method(:smallest_change)
    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))
    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))
    assert_equal(1, candidate.call([1, 4, 2]))
    assert_equal(1, candidate.call([1, 4, 4, 2]))
    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))
    assert_equal(0, candidate.call([3, 1, 1, 3]))
    assert_equal(0, candidate.call([1]))
    assert_equal(1, candidate.call([0, 1]))
  end
end
"
HumanEval_74,plt_Latn,rb,"Ohatra Raha mitovy isa ny tarehimarika amin'ireo tabilao roa ireo, avereno ny tabilao voalohany.isa tanteraka amin'ny tarehimarika ao amin'ny tsipika rehetra amin'ny array kely kokoa noho ny array hafa. Soraty ny fiasa izay manaiky ny laharana roa misy ny tsipika ary mamerina ny laharana izay manana # >>> total_match.call([], [])
# []
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""Hi""])
# [""hI"", ""Hi""]
# >>> total_match.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
# [""hi"", ""admin""]
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
# [""hI"", ""hi"", ""hi""]
# >>> total_match.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
# [""4""]
def total_match(lst1, lst2)
","def total_match(lst1, lst2)
  total_chars1 = lst1.map(&:length).sum
  total_chars2 = lst2.map(&:length).sum

  if total_chars1 < total_chars2
    lst1
  elsif total_chars2 < total_chars1
    lst2
  else
    lst1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_total_match
    candidate = method(:total_match)
    assert_equal([], candidate.call([], []))
    assert_equal([""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]))
    assert_equal([""4""], candidate.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]))
    assert_equal([""hI"", ""Hi""], candidate.call([""hi"", ""admin""], [""hI"", ""Hi""]))
    assert_equal([""hI"", ""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]))
    assert_equal([], candidate.call([], [""this""]))
    assert_equal([], candidate.call([""this""], []))
  end
end
"
HumanEval_75,plt_Latn,rb,"Ohatra: Fantatra fa (a) dia kely noho ny 100. ary diso raha tsy izany. Soraty ny fiasa izay miverina marina raha toa ka ny isa nomena dia ny fampitomboana ny isa voalohany 3 # >>> is_multiply_prime.call(30)
# true
# 30 = 2 * 3 * 5
def is_multiply_prime(a)
","require 'prime'

def is_multiply_prime(a)
  return false if a >= 100
  prime_factors = a.prime_division
  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_multiply_prime
    candidate = method(:is_multiply_prime)
    assert_equal(false, candidate.call(5))
    assert_equal(true, candidate.call(30))
    assert_equal(true, candidate.call(8))
    assert_equal(false, candidate.call(10))
    assert_equal(true, candidate.call(125))
    assert_equal(true, candidate.call(105))
    assert_equal(false, candidate.call(126))
    assert_equal(false, candidate.call(729))
    assert_equal(false, candidate.call(891))
    assert_equal(true, candidate.call(1001))
  end
end
"
HumanEval_76,plt_Latn,rb,"Ohatra: Ny x dia hery tsotra an'ny n raha n**int=x hery n ary diso amin'ny tranga hafa. Ny asanao dia ny manoratra fiasa izay mamerina marina raha toa ka isa tsotra ny x # >>> is_simple_power.call(1, 4)
# true
# >>> is_simple_power.call(2, 2)
# true
# >>> is_simple_power.call(8, 2)
# true
# >>> is_simple_power.call(3, 2)
# false
# >>> is_simple_power.call(3, 1)
# false
# >>> is_simple_power.call(5, 3)
# false
def is_simple_power(x, n)
","def is_simple_power(x, n)
  return false if x <= 0 || n <= 1
  return true if x == 1

  power = n
  while power <= x
    return true if power == x
    power *= n
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_simple_power
    candidate = method(:is_simple_power)
    assert_equal(true, candidate.call(16, 2))
    assert_equal(false, candidate.call(143214, 16))
    assert_equal(true, candidate.call(4, 2))
    assert_equal(true, candidate.call(9, 3))
    assert_equal(true, candidate.call(16, 4))
    assert_equal(false, candidate.call(24, 2))
    assert_equal(false, candidate.call(128, 4))
    assert_equal(false, candidate.call(12, 6))
    assert_equal(true, candidate.call(1, 1))
    assert_equal(true, candidate.call(1, 12))
  end
end
"
HumanEval_77,plt_Latn,rb,"Ohatra: Fanamarihana: azonao atao ny mihevitra fa manan-kery foana ny fidirana. raha toa ka kibo misy isa iray manontolo io ingeger io. Soraty ny fiasa izay mandray isa iray manontolo a ary mamerina ny marina # >>> iscube.call(1)
# true
# >>> iscube.call(2)
# false
# >>> iscube.call(-1)
# true
# >>> iscube.call(64)
# true
# >>> iscube.call(0)
# true
# >>> iscube.call(180)
# false
def iscube(a)
","def iscube(a)
  cube_root = a.abs**(1.0/3)
  cube_root.round**3 == a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_iscube
    candidate = method(:iscube)
    assert_equal(true, candidate.call(1))
    assert_equal(false, candidate.call(2))
    assert_equal(true, candidate.call(-1))
    assert_equal(true, candidate.call(64))
    assert_equal(false, candidate.call(180))
    assert_equal(true, candidate.call(1000))
    assert_equal(true, candidate.call(0))
    assert_equal(false, candidate.call(1729))
  end
end
"
HumanEval_78,plt_Latn,rb,"Ohatra: ary ny marika A,B,C,D,E,F dia voasoratra lehibe foana. Fanamarihana: azonao atao ny mihevitra fa ny fidirana dia marina foana na tsy misy kofehy, B (= desimaly 11), D (= desimaly 13). Noho izany dia mila mamaritra ny isan'ny isa manaraka ianao: 2, 3, 5, 7, Ny isa voalohany dia 2, 3, 5, 7, 11, 13, 17,... Ny isa enina ambin'ny folo dia 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. lehibe noho ny 1 izay tsy vokatry ny isa roa kely kokoa).isa voalohany (ny isa voalohany, na prime, dia isa voajanahary isa hexadecimal ho toy ny kofehy ary manisa ny isan'ny isa hexadecimal Nasaina nanoratra fiasa izay mandray # >>> hex_key.call(""AB"")
# 1
# >>> hex_key.call(""1077E"")
# 2
# >>> hex_key.call(""ABED1A33"")
# 4
# >>> hex_key.call(""123456789ABCDEF0"")
# 6
# >>> hex_key.call(""2020"")
# 2
def hex_key(num)
","def hex_key(num)
  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']
  num.chars.count { |digit| prime_hex_digits.include?(digit) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_hex_key
    candidate = method(:hex_key)
    assert_equal(1, candidate.call(""AB""))
    assert_equal(2, candidate.call(""1077E""))
    assert_equal(4, candidate.call(""ABED1A33""))
    assert_equal(2, candidate.call(""2020""))
    assert_equal(6, candidate.call(""123456789ABCDEF0""))
    assert_equal(12, candidate.call(""112233445566778899AABBCCDDEEFF00""))
  end
end
"
HumanEval_79,plt_Latn,rb,"Ohatra: Manampy amin'ny endrika ny litera fanampiny. Hisy tarehin-tsoratra fanampiny 'db' eo am-piandohana sy amin'ny faran'ny tadin-teny. Ny tarehimarika tsirairay ao amin'ny tadiny dia ho '0' na '1'.endrika binary. Tokony hamerina tsipika ny fiasa, miaraka amin'ny tarehin-tsoratra tsirairay maneho binary Nomenao isa iray amin'ny endrika desimaly ary ny asanao dia ny hanova azy ho # >>> decimal_to_binary.call(15)
# ""db1111db""
# >>> decimal_to_binary.call(32)
# ""db100000db""
def decimal_to_binary(decimal)
","def decimal_to_binary(decimal)
  ""db"" + decimal.to_s(2) + ""db""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_decimal_to_binary
    candidate = method(:decimal_to_binary)
    assert_equal(""db0db"", candidate.call(0))
    assert_equal(""db100000db"", candidate.call(32))
    assert_equal(""db1100111db"", candidate.call(103))
    assert_equal(""db1111db"", candidate.call(15))
  end
end
"
HumanEval_80,plt_Latn,rb,"Ohatra: Ny tadiny dia haprb raha toa ka 3 farafahakeliny ny halavan'ny tadiny ary samy hafa ny litera 3 misesy rehetra Ny asanao dia ny manamarina raha haprb na tsia ilay tadiny.Nomena tsipika s ianao. # >>> is_happy.call(""a"")
# false
# >>> is_happy.call(""aa"")
# false
# >>> is_happy.call(""abcd"")
# true
# >>> is_happy.call(""aabb"")
# false
# >>> is_happy.call(""adb"")
# true
# >>> is_happy.call(""xyy"")
# false
def is_happy(s)
","def is_happy(s)
  return false if s.length < 3
  
  (0..s.length - 3).each do |i|
    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]
  end
  
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_happy
    candidate = method(:is_happy)
    assert_equal(false, candidate.call(""a""))
    assert_equal(false, candidate.call(""aa""))
    assert_equal(true, candidate.call(""abcd""))
    assert_equal(false, candidate.call(""aabb""))
    assert_equal(true, candidate.call(""adb""))
    assert_equal(false, candidate.call(""xyy""))
    assert_equal(true, candidate.call(""iopaxpoi""))
    assert_equal(false, candidate.call(""iopaxioi""))
  end
end
"
HumanEval_81,plt_Latn,rb,"Ohatra: 0.0 E > 0,0 D- > 0,7 D > 1.0 D+ > 1.3 C- > 1,7 C > 2.0 C+ > 2.3 B- > 2.7 B > 3.0 B+ > 3.3 A- > 3.7 A 4.0 A+ Salanisan'ny mari-pahaizana.fiasa izay afaka mamoaka ny laharan-tsoratra amin'ny alÃ lan'ny tabilao manaraka: Nomeny anao ny salanisan'ny mpianatra sasany ary tsy maintsy manoratra ianao.Ny olana tokana dia very ny kaody nampiasainy tamin'ny fanasokajiana.Ny mpampianatra dia namorona ny algorithm-ny manokana ho an'ny naoty.Herinandro farany amin'ny enim-bolana izao ary tsy maintsy manome naoty ny mpampianatra.# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])
# [""A+"", ""B"", ""C-"", ""C"", ""A-""]
def numerical_letter_grade(grades)
","def numerical_letter_grade(grades)
  grades.map do |gpa|
    case 
    when gpa == 4.0
      ""A+""
    when gpa > 3.7
      ""A""
    when gpa > 3.3
      ""A-""
    when gpa > 3.0
      ""B+""
    when gpa > 2.7
      ""B""
    when gpa > 2.3
      ""B-""
    when gpa > 2.0
      ""C+""
    when gpa > 1.7
      ""C""
    when gpa > 1.3
      ""C-""
    when gpa > 1.0
      ""D+""
    when gpa > 0.7
      ""D""
    when gpa > 0.0
      ""D-""
    else
      ""E""
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_numerical_letter_grade
    candidate = method(:numerical_letter_grade)
    assert_equal([""A+"", ""B"", ""C-"", ""C"", ""A-""], candidate.call([4.0, 3, 1.7, 2, 3.5]))
    assert_equal([""D+""], candidate.call([1.2]))
    assert_equal([""D-""], candidate.call([0.5]))
    assert_equal([""E""], candidate.call([0.0]))
    assert_equal([""D"", ""D-"", ""C-"", ""B"", ""B+""], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))
    assert_equal([""E"", ""D-""], candidate.call([0.0, 0.7]))
  end
end
"
HumanEval_82,plt_Latn,rb,"Ohatra laharana voalohany ny halavany na diso raha tsy izany Soraty ny fiasa izay maka andalana iray ary mamerina marina raha toa ka ny andalana # >>> prime_length.call(""Hello"")
# true
# >>> prime_length.call(""abcdcba"")
# true
# >>> prime_length.call(""kittens"")
# true
# >>> prime_length.call(""orange"")
# false
def prime_length(string)
","def prime_length(string)
  length = string.length
  return false if length < 2

  (2..Math.sqrt(length)).each do |i|
    return false if length % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_length
    candidate = method(:prime_length)
    assert_equal(true, candidate.call(""Hello""))
    assert_equal(true, candidate.call(""abcdcba""))
    assert_equal(true, candidate.call(""kittens""))
    assert_equal(false, candidate.call(""orange""))
    assert_equal(true, candidate.call(""wow""))
    assert_equal(true, candidate.call(""world""))
    assert_equal(true, candidate.call(""MadaM""))
    assert_equal(true, candidate.call(""Wow""))
    assert_equal(false, candidate.call(""""))
    assert_equal(true, candidate.call(""HI""))
    assert_equal(true, candidate.call(""go""))
    assert_equal(false, candidate.call(""gogo""))
    assert_equal(false, candidate.call(""aaaaaaaaaaaaaaa""))
    assert_equal(true, candidate.call(""Madam""))
    assert_equal(false, candidate.call(""M""))
    assert_equal(false, candidate.call(""0""))
  end
end
"
HumanEval_83,plt_Latn,rb,"isa feno miampy izay manomboka na mifarana amin'ny 1. Raha nomena isa iray feno n, avereno ny isan'ny isa n-digit def starts_one_ends(n)
","def starts_one_ends(n)
  return 0 if n <= 0

  # Count numbers starting with 1
  start_with_1 = 9 ** (n - 1)

  # Count numbers ending with 1
  end_with_1 = 9 ** (n - 1)

  # Adjust for double counting the number that both starts and ends with 1
  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1
  
  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_starts_one_ends
    candidate = method(:starts_one_ends)
    assert_equal(1, candidate.call(1))
    assert_equal(18, candidate.call(2))
    assert_equal(180, candidate.call(3))
    assert_equal(1800, candidate.call(4))
    assert_equal(18000, candidate.call(5))
  end
end
"
HumanEval_84,plt_Latn,rb,"Ohatra Nomena isa feno N, avereno ny totalin'ny isa ao aminy amin'ny binary. # >>> solve.call(1000)
# ""1""
# >>> solve.call(150)
# ""110""
# >>> solve.call(147)
# ""1100""
# Variables:
# @N integer
# Constraints: 0 â‰¤ N â‰¤ 10000.
# Output:
# a string of binary number
def solve(n)
","def solve(n)
  sum_of_digits = n.to_s.chars.map(&:to_i).sum
  sum_of_digits.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""1"", candidate.call(1000))
    assert_equal(""110"", candidate.call(150))
    assert_equal(""1100"", candidate.call(147))
    assert_equal(""1001"", candidate.call(333))
    assert_equal(""10010"", candidate.call(963))
  end
end
"
HumanEval_85,plt_Latn,rb,"Ohatra: Nomena laharana iray tsy banga misy isa manontolo aloha. Ampio ireo singa mitovy izay ao amin'ny indice hafahafa.. # >>> add.call([4, 2, 6, 7])
# 2
def add(lst)
","def add(lst)
  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(88, candidate.call([4, 88]))
    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))
    assert_equal(0, candidate.call([4, 0, 6, 7]))
    assert_equal(12, candidate.call([4, 4, 6, 8]))
  end
end
"
HumanEval_86,plt_Latn,rb,"Ohatra: Fanamarihana: Tokony hotandremanao ny filaharan'ny teny sy ny toerana banga ao amin'ny fehezanteny. filaharana miakatra mifototra amin'ny sandan'ny ascii. dia soloina teny vaovao izay ahitana ny tarehin-tsoratra rehetra voalamina ao amin'ny Ny dikan-teny voatondro amin'ny tady, dia tady izay ahitana ny teny rehetra (misaraka amin'ny toerana) Soraty ny fiasa izay maka tady ary mamerina ny dikan-teny voatondro. # >>> anti_shuffle.call(""Hi"")
# ""Hi""
# >>> anti_shuffle.call(""hello"")
# ""ehllo""
# >>> anti_shuffle.call(""Hello World!!!"")
# ""Hello !!!Wdlor""
def anti_shuffle(s)
","def anti_shuffle(s)
  s.split(/(\s+)/).map { |word| word.chars.sort.join }.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_anti_shuffle
    candidate = method(:anti_shuffle)
    assert_equal(""Hi"", candidate.call(""Hi""))
    assert_equal(""ehllo"", candidate.call(""hello""))
    assert_equal(""bemnru"", candidate.call(""number""))
    assert_equal(""abcd"", candidate.call(""abcd""))
    assert_equal(""Hello !!!Wdlor"", candidate.call(""Hello World!!!""))
    assert_equal("""", candidate.call(""""))
    assert_equal("".Hi My aemn is Meirst .Rboot How aer ?ouy"", candidate.call(""Hi. My name is Mister Robot. How are you?""))
  end
end
"
HumanEval_87,plt_Latn,rb,"Ohatra: Ary koa, amboary ny laharana araka ny tsanganana amin'ny filaharana midina.Alaharo amin'ny fiakarana ny laharana voalohany ny laharana voalohany.Ny laharana tsirairay dia ny mpandrindra - (laharana, tsanganana), manomboka amin'ny 0. ary miverina array ny arrays, [(x1, y1), (x2, y2) ...] toy izany fa Raha nomena ny lst, sy ny integer x, dia tadiavo ny integer x ao amin'ny array, Mety misy laharana samihafa ny laharana tsirairay.izay mitovy amin'ny matrix, na izany aza, tsy mitovy amin'ny matrix, Nomena anao ny angona 2 dimensional, toy ny arrays mifangaro, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
# >>> get_row.call([], 1)
# []
# >>> get_row.call([[], [1], [1, 2, 3]], 3)
# [[2, 2]]
def get_row(lst, x)
","def get_row(lst, x)
  result = []

  lst.each_with_index do |row, i|
    row.each_with_index do |value, j|
      result << [i, j] if value == x
    end
  end

  result.sort_by { |coord| [coord[0], -coord[1]] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_row
    candidate = method(:get_row)
    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))
    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([], candidate.call([], 1))
    assert_equal([], candidate.call([[1]], 2))
    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))
  end
end
"
HumanEval_88,plt_Latn,rb,"Ohatra: * aza manova ny array nomena. Fanamarihana: na sokajy amin'ny filaharana midina raha toa ka mitovy ny vola ((ny sanda voalohany, ny sanda farany). Ho sokajiana amin'ny filaharana miakatra ny array nomena raha toa ka tsy mitovy ny sombiny (valiny voalohany, sanda farany) Nomena ny array ny tsy-negative integers, miverina ny corb ny nomena array rehefa avy ny fanasokajiana, # >>> sort_array.call([])
# []
# >>> sort_array.call([5])
# [5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5])
# [0, 1, 2, 3, 4, 5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])
# [6, 5, 4, 3, 2, 1, 0]
def sort_array(array)
","def sort_array(array)
  return array if array.empty? || array.size == 1

  if (array.first + array.last).odd?
    array.sort
  else
    array.sort.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([], candidate.call([]))
    assert_equal([5], candidate.call([5]))
    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))
    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))
    assert_equal([1, 2], candidate.call([2, 1]))
    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))
    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))
  end
end
"
HumanEval_89,plt_Latn,rb,"Ohatra: Miovaova ambany amin'ny roa avoaka amin'ny toerana roa.Tokony hihodina ny abidia mba ho toy ny hoe ny litera mamerina tadiny voahidy amin'ny abidia mihodina. Mamorona endri-javatra iray izay mandray tsipika ho toy ny tohan-kevitra ary # >>> encrypt.call(""hi"")
# ""lm""
# >>> encrypt.call(""asdfghjkl"")
# ""ewhjklnop""
# >>> encrypt.call(""gf"")
# ""kj""
# >>> encrypt.call(""et"")
# ""ix""
def encrypt(s)
","def encrypt(s)
  s.chars.map do |char|
    if char =~ /[a-z]/
      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr
    elsif char =~ /[A-Z]/
      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr
    else
      char
    end
  end.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encrypt
    candidate = method(:encrypt)
    assert_equal(""lm"", candidate.call(""hi""))
    assert_equal(""ewhjklnop"", candidate.call(""asdfghjkl""))
    assert_equal(""kj"", candidate.call(""gf""))
    assert_equal(""ix"", candidate.call(""et""))
    assert_equal(""jeiajeaijeiak"", candidate.call(""faewfawefaewg""))
    assert_equal(""lippsqcjvmirh"", candidate.call(""hellomyfriend""))
    assert_equal(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"", candidate.call(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""))
    assert_equal(""e"", candidate.call(""a""))
  end
end
"
HumanEval_90,plt_Latn,rb,"Miverina nil raha tsy misy singa toy izany. Soraty ny fiasa next_smallest (ny kely indrindra manaraka) izay mamerina ny singa faharoa kely indrindra amin'ny array. Nomena anao ny array iray misy isa feno.# >>> next_smallest.call([1, 2, 3, 4, 5])
# 2
# >>> next_smallest.call([5, 1, 4, 3, 2])
# 2
# >>> next_smallest.call([])
# nil
# >>> next_smallest.call([1, 1])
# nil
def next_smallest(lst)
","def next_smallest(lst)
  unique_sorted = lst.uniq.sort
  unique_sorted.length >= 2 ? unique_sorted[1] : nil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_next_smallest
    candidate = method(:next_smallest)
    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))
    assert_equal(nil, candidate.call([]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(-35, candidate.call([-35, 34, 12, -45]))
  end
end
"
HumanEval_91,plt_Latn,rb,"Ohatra: Ny fehezan-teny dia voafetra amin'ny '.', '?' na '!'. Ny faharerahana dia fehezanteny izay manomboka amin'ny teny hoe ""I"".Homena andian-teny ianao, ary ny asanao dia ny manisa ny isa.# >>> is_bored.call(""Hello world"")
# 0
# >>> is_bored.call(""The sky is blue. The sun is shining. I love this weather"")
# 1
def is_bored(s)
","def is_bored(s)
  sentences = s.split(/(?<=[.?!])/)
  sentences.count { |sentence| sentence.strip.start_with?('I') }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_bored
    candidate = method(:is_bored)
    assert_equal(0, candidate.call(""Hello world""))
    assert_equal(0, candidate.call(""Is the sky blue?""))
    assert_equal(1, candidate.call(""I love It !""))
    assert_equal(0, candidate.call(""bIt""))
    assert_equal(2, candidate.call(""I feel good today. I will be productive. will kill It""))
    assert_equal(0, candidate.call(""You and I are going for a walk""))
  end
end
"
HumanEval_92,plt_Latn,rb,"Ohatra Miverina diso amin'ny tranga hafa rehetra. Mamerina ny marina raha toa ka mitovy amin'ny fitambaran'ny isa roa hafa ny iray amin'ireo isa, ary ny isa rehetra dia isa feno. Mamorona fiasa izay mandray isa 3.# >>> any_int.call(5, 2, 7)
# true
# >>> any_int.call(3, 2, 2)
# false
# >>> any_int.call(3, -2, 1)
# true
# >>> any_int.call(3.6, -2.2, 2)
# false
def any_int(x, y, z)
","def any_int(x, y, z)
  if [x, y, z].all? { |n| n.is_a?(Integer) }
    x == y + z || y == x + z || z == x + y
  else
    false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_any_int
    candidate = method(:any_int)
    assert_equal(true, candidate.call(2, 3, 1))
    assert_equal(false, candidate.call(2.5, 2, 3))
    assert_equal(false, candidate.call(1.5, 5, 3.5))
    assert_equal(false, candidate.call(2, 6, 2))
    assert_equal(true, candidate.call(4, 2, 2))
    assert_equal(false, candidate.call(2.2, 2.2, 2.2))
    assert_equal(true, candidate.call(-4, 6, 2))
    assert_equal(true, candidate.call(2, 1, 1))
    assert_equal(true, candidate.call(3, 4, 7))
    assert_equal(false, candidate.call(3.0, 4, 7))
  end
end
"
HumanEval_93,plt_Latn,rb,"Ohatra: Ataovy ho litera ihany no ampiasainy. voal amin'ny abidy anglisy.ny hafatra miaraka amin'ilay litera izay miseho 2 toerana eo alohan'io fomba izay manova ny endriky ny litera rehetra, manolo ny voambolana rehetra ao amin'ny Soraty ny fiasa izay mandray hafatra, ary mametraka azy ho toy ny # >>> encode.call(""test"")
# ""TGST""
# >>> encode.call(""This is a message"")
# ""tHKS KS C MGSSCGG""
def encode(message)
","def encode(message)
  vowels = 'aeiou'
  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}
  
  encoded_message = message.chars.map do |char|
    if vowels.include?(char.downcase)
      new_char = swap_vowels[char.downcase]
      char == char.upcase ? new_char.upcase : new_char.downcase
    else
      char == char.upcase ? char.downcase : char.upcase
    end
  end

  encoded_message.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encode
    candidate = method(:encode)
    assert_equal(""tgst"", candidate.call(""TEST""))
    assert_equal(""mWDCSKR"", candidate.call(""Mudasir""))
    assert_equal(""ygs"", candidate.call(""YES""))
    assert_equal(""tHKS KS C MGSSCGG"", candidate.call(""This is a message""))
    assert_equal(""k dQnT kNqW wHcT Tq wRkTg"", candidate.call(""I DoNt KnOw WhAt tO WrItE""))
  end
end
"
HumanEval_94,plt_Latn,rb,"Ohatra: Mila mahita ny sanda voalohany lehibe indrindra ianao ary mamerina ny fitambaran'ny tarehimarika ao aminy.Nomena anao ny array iray misy isa feno.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
# 10
# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
# 25
# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
# 13
# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
# 11
# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])
# 3
# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])
# 7
def skjkasdkd(lst)
","def skjkasdkd(lst)
  require 'prime'

  # Find the largest prime number in the array
  largest_prime = lst.select { |num| Prime.prime?(num) }.max
  
  # Return 0 if no prime number is found
  return 0 if largest_prime.nil?

  # Calculate the sum of digits of the largest prime number
  largest_prime.to_s.chars.map(&:to_i).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_skjkasdkd
    candidate = method(:skjkasdkd)
    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))
    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))
    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))
    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))
    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))
    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))
    assert_equal(19, candidate.call([8191]))
    assert_equal(19, candidate.call([8191, 123456, 127, 7]))
    assert_equal(10, candidate.call([127, 97, 8192]))
  end
end
"
HumanEval_95,plt_Latn,rb,"Ohatra: Tokony hamerina ny diso ny fiasa raha toa ka foana ny hash nomena. Raha toa ka ny lakile rehetra dia tadiny amin'ny litera lehibe, raha tsy izany dia miverina diso.Raha nomena ny hash, miverina marina raha toa ka ny lakile rehetra dia tady amin'ny ambany # >>> check_dict_case.call({""a"" => ""apple"", ""b"" => ""banana""})
# true
# >>> check_dict_case.call({""a"" => ""apple"", ""A"" => ""banana"", ""B"" => ""banana""})
# false
# >>> check_dict_case.call({""a"" => ""apple"", 8 => ""banana"", ""a"" => ""apple""})
# false
# >>> check_dict_case.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""})
# false
# >>> check_dict_case.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""})
# true
def check_dict_case(dict)
","def check_dict_case(dict)
  return false if dict.empty?

  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }
  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }

  lowercase_keys || uppercase_keys
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_dict_case
    candidate = method(:check_dict_case)
    assert_equal(true, candidate.call({""p"" => ""pineapple"", ""b"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""A"" => ""banana"", ""B"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""5"" => ""banana"", ""a"" => ""apple""}))
    assert_equal(false, candidate.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""}))
    assert_equal(true, candidate.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""}))
    assert_equal(true, candidate.call({""fruit"" => ""Orange"", ""taste"" => ""Sweet""}))
    assert_equal(false, candidate.call({}))
  end
end
"
HumanEval_96,plt_Latn,rb,"ohatra hoe: Ny isa manontolo izay isa voalohany ary kely kokoa noho ny n. Ampiharo ny asa izay mandray ny tsy-negative integer sy miverina ny array ny voalohany n # >>> count_up_to.call(5)
# [2, 3]
# >>> count_up_to.call(11)
# [2, 3, 5, 7]
# >>> count_up_to.call(0)
# []
# >>> count_up_to.call(20)
# [2, 3, 5, 7, 11, 13, 17, 19]
# >>> count_up_to.call(1)
# []
# >>> count_up_to.call(18)
# [2, 3, 5, 7, 11, 13, 17]
def count_up_to(n)
","def count_up_to(n)
  return [] if n <= 2
  primes = []
  (2...n).each do |num|
    is_prime = true
    (2..Math.sqrt(num)).each do |i|
      if num % i == 0
        is_prime = false
        break
      end
    end
    primes << num if is_prime
  end
  primes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_up_to
    candidate = method(:count_up_to)
    assert_equal([2, 3], candidate.call(5))
    assert_equal([2, 3, 5], candidate.call(6))
    assert_equal([2, 3, 5], candidate.call(7))
    assert_equal([2, 3, 5, 7], candidate.call(10))
    assert_equal([], candidate.call(0))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))
    assert_equal([], candidate.call(1))
    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))
  end
end
"
HumanEval_97,plt_Latn,rb,"Ohatra: Hevero fa manan-kery foana ny fidirana.ny vokatra avy amin'ny tarehimarika misy azy ireo. Fenoy ny fiasa izay maka isa roa sy mamerina # >>> multiply.call(148, 412)
# 16
# >>> multiply.call(19, 28)
# 72
# >>> multiply.call(2020, 1851)
# 0
# >>> multiply.call(14, -15)
# 20
def multiply(a, b)
","def multiply(a, b)
  a_unit_digit = a.abs % 10
  b_unit_digit = b.abs % 10
  a_unit_digit * b_unit_digit
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_multiply
    candidate = method(:multiply)
    assert_equal(16, candidate.call(148, 412))
    assert_equal(72, candidate.call(19, 28))
    assert_equal(0, candidate.call(2020, 1851))
    assert_equal(20, candidate.call(14, -15))
    assert_equal(42, candidate.call(76, 67))
    assert_equal(49, candidate.call(17, 27))
    assert_equal(0, candidate.call(0, 1))
    assert_equal(0, candidate.call(0, 0))
  end
end
"
HumanEval_98,plt_Latn,rb,"Ohatra: Raha nomena ny tsipika s, isao ny isan'ny matoanteny lehibe amin'ny endri-tsoratra mitovy. # >>> count_upper.call(""aBCdEf"")
# 1
# >>> count_upper.call(""abcdefg"")
# 0
# >>> count_upper.call(""dBBE"")
# 0
def count_upper(s)
","def count_upper(s)
  vowels = ['A', 'E', 'I', 'O', 'U']
  count = 0

  s.chars.each_with_index do |char, index|
    if index.even? && vowels.include?(char)
      count += 1
    end
  end

  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_upper
    candidate = method(:count_upper)
    assert_equal(1, candidate.call(""aBCdEf""))
    assert_equal(0, candidate.call(""abcdefg""))
    assert_equal(0, candidate.call(""dBBE""))
    assert_equal(0, candidate.call(""B""))
    assert_equal(1, candidate.call(""U""))
    assert_equal(0, candidate.call(""""))
    assert_equal(2, candidate.call(""EEEE""))
  end
end
"
HumanEval_99,plt_Latn,rb,"Ohatra avy amin'ny isa roa, manodidina azy lavitra ny zero.ary mamerina ny isa iray manontolo akaiky indrindra azy. Raha toa ka mitovy ny elanelana misy eo amin'ny isa iray Mamorona fiasa izay mandray sanda (tsipika) maneho isa # >>> closest_integer.call(""10"")
# 10
# >>> closest_integer.call(""15.3"")
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer(""14.5"") should
# return 15 and closest_integer(""-14.5"") should return -15.
def closest_integer(value)
","def closest_integer(value)
  number = value.to_f
  if number > 0
    (number + 0.5).floor
  else
    (number - 0.5).ceil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_closest_integer
    candidate = method(:closest_integer)
    assert_equal(10, candidate.call(""10""))
    assert_equal(15, candidate.call(""14.5""))
    assert_equal(-16, candidate.call(""-15.5""))
    assert_equal(15, candidate.call(""15.3""))
    assert_equal(0, candidate.call(""0""))
  end
end
"
HumanEval_100,plt_Latn,rb,"Ohatra: i dia maneho ny isan'ny vato ao amin'ny ambaratonga (i+1). Miverina ny isan'ny vato isaky ny ambaratonga ao amin'ny array, izay singa amin'ny index - ny isa manaraka raha n dia isa. - ny isa hafahafa manaraka raha toa ka hafahafa ny n. Ny isan'ny vato ao amin'ny ambaratonga manaraka dia: Ny ambaratonga voalohany dia misy vato n.Raha nomena isa iray n ianao, dia mila manao antontam-bato n.# >>> make_a_pile.call(3)
# [3, 5, 7]
def make_a_pile(n)
","def make_a_pile(n)
  result = []
  current_stones = n
  n.times do
    result << current_stones
    current_stones += 2
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_a_pile
    candidate = method(:make_a_pile)
    assert_equal([3, 5, 7], candidate.call(3))
    assert_equal([4, 6, 8, 10], candidate.call(4))
    assert_equal([5, 7, 9, 11, 13], candidate.call(5))
    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))
    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))
  end
end
"
HumanEval_101,plt_Latn,rb,"Ohatra: mba hizara ny tadiny ho teny ary hamerina ny andian-teny. Homena andian-teny voazarazara amin'ny tsipelina na toerana ianao.# >>> words_string.call(""Hi, my name is John"")
# [""Hi"", ""my"", ""name"", ""is"", ""John""]
# >>> words_string.call(""One, two, three, four, five, six"")
# [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
def words_string(s)
","def words_string(s)
  s.split(/[\s,]+/)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_string
    candidate = method(:words_string)
    assert_equal([""Hi"", ""my"", ""name"", ""is"", ""John""], candidate.call(""Hi, my name is John""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One, two, three, four, five, six""))
    assert_equal([""Hi"", ""my"", ""name""], candidate.call(""Hi, my name""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One,, two, three, four, five, six,""))
    assert_equal([], candidate.call(""""))
    assert_equal([""ahmed"", ""gamal""], candidate.call(""ahmed     , gamal""))
  end
end
"
HumanEval_102,plt_Latn,rb,"Ohatra: tsy misy izany isa izany, dia tokony hamerina -1 ny fiasa.Ny isa mitontaly lehibe indrindra ao anatin'ny elanelana [x, y] tafiditra ao.Ity fiasa ity dia mandray isa roa tsara x sy y ary mamerina ny # >>> choose_num.call(12, 15)
# 14
# >>> choose_num.call(13, 12)
# -1
def choose_num(x, y)
","def choose_num(x, y)
  return -1 if x > y
  # Start looking from the largest number
  max_even = y.even? ? y : y - 1
  # Iterate downwards to find the biggest even number
  max_even.downto(x) do |n|
    return n if n.even?
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_choose_num
    candidate = method(:choose_num)
    assert_equal(14, candidate.call(12, 15))
    assert_equal(-1, candidate.call(13, 12))
    assert_equal(12354, candidate.call(33, 12354))
    assert_equal(-1, candidate.call(5234, 5233))
    assert_equal(28, candidate.call(6, 29))
    assert_equal(-1, candidate.call(27, 10))
    assert_equal(-1, candidate.call(7, 7))
    assert_equal(546, candidate.call(546, 546))
  end
end
"
HumanEval_103,plt_Latn,rb,"Ohatra: Raha n dia lehibe kokoa noho ny m, miverina -1. Ampifanatonana amin'ny isa feno akaiky indrindra ny valiny ary avadiho ho isa binary. salan'isan'ny isa manontolo manomboka amin'ny n ka hatramin'ny m (ao anatin'izany ny n sy ny m).Nomenao isa roa miampy n sy m ianao, ary ny asanao dia ny manisa ny # >>> rounded_avg.call(1, 5)
# ""0b11""
# >>> rounded_avg.call(7, 5)
# -1
# >>> rounded_avg.call(10, 20)
# ""0b1111""
# >>> rounded_avg.call(20, 33)
# ""0b11010""
def rounded_avg(n, m)
","def rounded_avg(n, m)
  return -1 if n > m

  sum = (n..m).reduce(:+)
  count = m - n + 1
  average = (sum.to_f / count).round
  ""0b"" + average.to_i.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rounded_avg
    candidate = method(:rounded_avg)
    assert_equal(""0b11"", candidate.call(1, 5))
    assert_equal(""0b1010"", candidate.call(7, 13))
    assert_equal(""0b1111001010"", candidate.call(964, 977))
    assert_equal(""0b1111100100"", candidate.call(996, 997))
    assert_equal(""0b1011000010"", candidate.call(560, 851))
    assert_equal(""0b101101110"", candidate.call(185, 546))
    assert_equal(""0b110101101"", candidate.call(362, 496))
    assert_equal(""0b1001110010"", candidate.call(350, 902))
    assert_equal(""0b11010111"", candidate.call(197, 233))
    assert_equal(-1, candidate.call(7, 5))
    assert_equal(-1, candidate.call(5, 1))
    assert_equal(""0b101"", candidate.call(5, 5))
  end
end
"
HumanEval_104,plt_Latn,rb,"Ohatra: Fanamarihana: Ny array niverina dia tokony ho sokajiana amin'ny filaharana mitombo. singa tsy misy tarehimarika mitovy. Nomena ny array ny isa tsara x. miverina ny voalamina array rehetra # >>> unique_digits.call([15, 33, 1422, 1])
# [1, 15, 33]
# >>> unique_digits.call([152, 323, 1422, 10])
# []
def unique_digits(x)
","def unique_digits(x)
  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique_digits
    candidate = method(:unique_digits)
    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))
    assert_equal([], candidate.call([152, 323, 1422, 10]))
    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))
    assert_equal([31, 135], candidate.call([135, 103, 31]))
  end
end
"
HumanEval_105,plt_Latn,rb,"Ohatra: ""Iray"", ""Roa"", ""Telo"", ""Efatra"", ""Dimy"", ""Enina"", ""Fito"", ""Valo"", ""Fiwa"". avereno ny laharana, ary avy eo soloy ny isa tsirairay amin'ny anarana mifanaraka aminy avy amin'ny Raha nomena ny laharana iray misy isa feno, amboary ny isa feno izay eo anelanelan'ny 1 sy 9 tafiditra, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])
# [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
# If the array is empty, return an empty array:
# >>> by_length.call([])
# []
# If the array has any strange number ignore it:
# >>> by_length.call([1, -1, 55])
# [""One""]
def by_length(arr)
","def by_length(arr)
  number_names = {
    1 => ""One"",
    2 => ""Two"",
    3 => ""Three"",
    4 => ""Four"",
    5 => ""Five"",
    6 => ""Six"",
    7 => ""Seven"",
    8 => ""Eight"",
    9 => ""Nine""
  }

  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse
  filtered_sorted_reversed.map { |num| number_names[num] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_by_length
    candidate = method(:by_length)
    assert_equal([""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([""One""], candidate.call([1, -1, 55]))
    assert_equal([""Three"", ""Two"", ""One""], candidate.call([1, -1, 3, 2]))
    assert_equal([""Nine"", ""Eight"", ""Four""], candidate.call([9, 4, 8]))
  end
end
"
HumanEval_106,plt_Latn,rb,"Ohatra: ny factoriel an'i dia ny fampitomboana ny isa 1 hatramin'ny i (1 * 2 * ... * i). Manomboka amin'ny 1 aho.na ny fitambaran'ny isa 1 ka hatramin'ny i raha tsy izany. ary mamerina array iray manana habe n, toy ny hoe ny sandan'ny singa ao amin'ny index i dia ny factorial an'i raha toa ka mitovy Ampiharo ny fiasa f izay mandray ny n ho toy ny paramÃ¨tre, # >>> f.call(5)
# [1, 2, 6, 24, 15]
def f(n)
","def f(n)
  (1..n).map do |i|
    if i.even?
      (1..i).inject(:*) || 1
    else
      (1..i).inject(:+)
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_f
    candidate = method(:f)
    assert_equal([1, 2, 6, 24, 15], candidate.call(5))
    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))
    assert_equal([1], candidate.call(1))
    assert_equal([1, 2, 6], candidate.call(3))
  end
end
"
HumanEval_107,plt_Latn,rb,"Ohatra 1: palindrome isa feno izay tafiditra ao anatin'ny elanelana ((1, n), tafiditra ao anatin'izany. Raha nomena isa iray n, avereno ny array izay misy ny isa ny isa sy ny isa tsy mitovy # >>> even_odd_palindrome.call(3)
# [1, 2]
# Explanation:
# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome.call(12)
# [4, 6]
# Explanation:
# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
# 1. 1 <= n <= 10^3
# 2. returned array has the number of even and odd integer palindromes respectively.
def even_odd_palindrome(n)
","def even_odd_palindrome(n)
  even_count = 0
  odd_count = 0

  (1..n).each do |num|
    if num.to_s == num.to_s.reverse
      if num.even?
        even_count += 1
      else
        odd_count += 1
      end
    end
  end

  [even_count, odd_count]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_palindrome
    candidate = method(:even_odd_palindrome)
    assert_equal([8, 13], candidate.call(123))
    assert_equal([4, 6], candidate.call(12))
    assert_equal([1, 2], candidate.call(3))
    assert_equal([6, 8], candidate.call(63))
    assert_equal([5, 6], candidate.call(25))
    assert_equal([4, 6], candidate.call(19))
    assert_equal([4, 5], candidate.call(9))
    assert_equal([0, 1], candidate.call(1))
  end
end
"
HumanEval_108,plt_Latn,rb,"Ohatra, -123 dia manana sonia isa -1, 2, ary 3. Raha diso ny isa iray, dia ho diso koa ny tarehimarika voalohany: ny isan'ny singa izay manana ny totalin'ny tarehimarika > 0. Soraty ny fiasa count_nums izay mandray ny laharan'ny isa manontolo ary mamerina # >>> count_nums.call([])
# 0
# >>> count_nums.call([-1, 11, -11])
# 1
# >>> count_nums.call([1, 1, 2])
# 3
def count_nums(arr)
","def count_nums(arr)
  arr.count do |num|
    num.to_s.chars.map(&:to_i).sum > 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_nums
    candidate = method(:count_nums)
    assert_equal(0, candidate.call([]))
    assert_equal(0, candidate.call([-1, -2, 0]))
    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))
    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))
    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))
    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))
    assert_equal(1, candidate.call([0, 1]))
    assert_equal(1, candidate.call([1]))
  end
end
"
HumanEval_109,plt_Latn,rb,"Ohatra: Fanamarihana: Azo antoka fa manana singa tokana ny array nomena. Raha toa ka foana ny array nomena dia avereno marina. dia avereno ny marina na avereno ny diso. Raha azo atao ny mahazo ny voalamina array amin'ny alalan'ny fanatanterahana ny asa etsy ambony ny toerana fanombohana ao amin'ny array izany hoe ny index faha-0. Ny singa farany amin'ny array dia hoentina any amin'ny Ny fihetsika iray mihetsika miankavanana dia midika hoe mihetsika ny singa rehetra amin'ny array amin'ny iray Afaka manao fiovana havanana imbetsaka ianao.ny fandidiana manaraka eo amin'ny array nomena: Azo atao ny mahazo ny array voalamina amin'ny filaharana tsy mihena amin'ny alalan'ny fanatanterahana ny Ny lahasa ataonao dia ny mamaritra raha Manana array 'arr' misy integer N arr[1], arr[2], ..., arr[N] isika. Ny # >>> move_one_ball.call([3, 4, 5, 1, 2])
# true
# Explanation: By performin 2 right shift operations, non-decreasing order can
# be achieved for the given array.
# >>> move_one_ball.call([3, 5, 4, 1, 2])
# false
# Explanation:It is not possible to get non-decreasing order for the given
# array by performing any number of right shift operations.
def move_one_ball(arr)
","def move_one_ball(arr)
  return true if arr.empty?

  n = arr.size
  count_rotation_point = 0
  rotation_index = -1

  (0...n).each do |i|
    next_index = (i + 1) % n
    if arr[i] > arr[next_index]
      count_rotation_point += 1
      rotation_index = next_index
    end
  end

  count_rotation_point <= 1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_move_one_ball
    candidate = method(:move_one_ball)
    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))
    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))
    assert_equal(false, candidate.call([4, 3, 1, 2]))
    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))
    assert_equal(true, candidate.call([]))
  end
end
"
HumanEval_110,plt_Latn,rb,"Ohatra: Raha tsy izany, avereno ny ""TSIA"". Ny singa rehetra ao amin'ny lst1 ho mitovy, miverina ""YES"". Raha azo atao ny mifanakalo singa eo amin'ny lst1 sy lst2 mba hahatonga Tsy misy fetra ny isan'ny singa mifanakalo eo amin'ny lst1 sy lst2. eo amin'izy ireo mba hahatonga ny LST1 ho tabilao misy isa mitovy ihany.ary mamaritra raha azo atao ny manao fifanakalozana singa Ao anatin'ity olana ity, dia hampihatra fiasa iray izay mandray isa roa, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])
# ""YES""
# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])
# ""NO""
# It is assumed that the input arrays will be non-empty.
def exchange(lst1, lst2)
","def exchange(lst1, lst2)
  # Check if lst1 already consists solely of even numbers
  return ""YES"" if lst1.all?(&:even?)

  # Check if there are at least as many even numbers in lst2
  # as there are odd numbers in lst1
  odd_count_lst1 = lst1.count(&:odd?)
  even_count_lst2 = lst2.count(&:even?)

  odd_count_lst1 <= even_count_lst2 ? ""YES"" : ""NO""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_exchange
    candidate = method(:exchange)
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))
    assert_equal(""NO"", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))
    assert_equal(""YES"", candidate.call([5, 7, 3], [2, 6, 4]))
    assert_equal(""NO"", candidate.call([5, 7, 3], [2, 6, 3]))
    assert_equal(""NO"", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))
    assert_equal(""YES"", candidate.call([100, 200], [200, 200]))
  end
end
"
HumanEval_111,plt_Latn,rb,"Ohatra: Raha misy litera maromaro mitovy, avereno daholo izy rehetra. Ny litera izay miverimberina indrindra ary misy ny isa mifanaraka amin'izany. Raha nomena tady maneho litera kely misaraka amin'ny habaka, avereno ny hash # >>> histogram.call(""a b c"")
# {""a"" => 1, ""b"" => 1, ""c"" => 1}
# >>> histogram.call(""a b b a"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""a b c a b"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""b b b b a"")
# {""b"" => 4}
# >>> histogram.call("""")
# {}
def histogram(test)
","def histogram(test)
  return {} if test.empty?

  count = Hash.new(0)

  test.split.each do |char|
    count[char] += 1
  end

  max_count = count.values.max
  count.select { |_, value| value == max_count }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_histogram
    candidate = method(:histogram)
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b b a""))
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b c a b""))
    assert_equal({""a"" => 1, ""b"" => 1, ""c"" => 1, ""d"" => 1, ""g"" => 1}, candidate.call(""a b c d g""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({""b"" => 4}, candidate.call(""b b b b a""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({}, candidate.call(""""))
    assert_equal({""a"" => 1}, candidate.call(""a""))
  end
end
"
HumanEval_112,plt_Latn,rb,"Ohatra Tokony hamerina array misy ny vokatra tady sy marina / diso ho an'ny fanamarinana. Ny tadiny dia antsoina hoe palindrome raha mitovy ny famakiana azy mihemotra sy miandalana. Avy eo dia jereo raha palindrome ny tadin'ny vokatra. Nomena tady roa isika s sy c, tsy maintsy esorinao ny tarehin-tsoratra rehetra ao amin'ny s izay mitovy amin'ny tarehin-tsoratra rehetra ao amin'ny c Asa # >>> reverse_delete.call(""abcde"", ""ae"")
# [""bcd"", false]
# >>> reverse_delete.call(""abcdef"", ""b"")
# [""acdef"", false]
# >>> reverse_delete.call(""abcdedcba"", ""ab"")
# [""cdedc"", true]
def reverse_delete(s, c)
","def reverse_delete(s, c)
  # Remove all characters in c from s
  filtered_string = s.delete(c)
  
  # Check if the filtered string is a palindrome
  is_palindrome = filtered_string == filtered_string.reverse
  
  # Return the result array
  [filtered_string, is_palindrome]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_reverse_delete
    candidate = method(:reverse_delete)
    assert_equal([""bcd"", false], candidate.call(""abcde"", ""ae""))
    assert_equal([""acdef"", false], candidate.call(""abcdef"", ""b""))
    assert_equal([""cdedc"", true], candidate.call(""abcdedcba"", ""ab""))
    assert_equal([""dik"", false], candidate.call(""dwik"", ""w""))
    assert_equal(["""", true], candidate.call(""a"", ""a""))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", """"))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", ""v""))
    assert_equal([""abba"", true], candidate.call(""vabba"", ""v""))
    assert_equal(["""", true], candidate.call(""mamma"", ""mia""))
  end
end
"
HumanEval_113,plt_Latn,rb,"ny isa tsy mitovy ao amin'ny andalana i'th amin'ny fidirana. izay tokony hosoloina isa  ny i rehetra.Ny singa tsirairay i ny output dia tokony ho ""ny isan'ny singa hafahafa ao amin'ny Raha nomena ny array misy ny string, izay ny string tsirairay dia ahitana ny digit fotsiny, miverena array. # >>> odd_count.call([""1234567""])
# [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
# >>> odd_count.call([""3"", ""11111111""])
# [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
def odd_count(lst)
","def odd_count(lst)
  lst.map do |num_str|
    count = num_str.count('13579')
    ""the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_odd_count
    candidate = method(:odd_count)
    assert_equal([""the number of odd elements 4n the str4ng 4 of the 4nput.""], candidate.call([""1234567""]))
    assert_equal([""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], candidate.call([""3"", ""11111111""]))
    assert_equal([""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""], candidate.call([""271"", ""137"", ""314""]))
  end
end
"
HumanEval_114,plt_Latn,rb,"Ohatra amin'ny isa. Raha nomena ny laharana iray misy ny isa manontolo n, dia fantaro ny isa kely indrindra amin'ny laharana kely tsy banga rehetra # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])
# 1
# >>> minSubArraySum.call([-1, -2, -3])
# -6
def minSubArraySum(nums)
","def minSubArraySum(nums)
  min_sum = nums[0]
  current_sum = 0
  nums.each do |num|
    if current_sum > 0
      current_sum = num
    else
      current_sum += num
    end
    min_sum = [min_sum, current_sum].min
  end
  min_sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minSubArraySum
    candidate = method(:minSubArraySum)
    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))
    assert_equal(-6, candidate.call([-1, -2, -3]))
    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))
    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))
    assert_equal(0, candidate.call([0, 10, 20, 1000000]))
    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))
    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))
    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))
    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))
    assert_equal(-10, candidate.call([-10]))
    assert_equal(7, candidate.call([7]))
    assert_equal(-1, candidate.call([1, -1]))
  end
end
"
HumanEval_115,plt_Latn,rb,"Ohatra 1: Output ny isan'ny fotoana tokony hampidina ny siny. Ny asanao dia ny mampiasa ireo siny mba hanalana ny lavadrano.ary mitovy ny fahafahan'ny siny rehetra. Manana siny mifanaraka amin'izany ny lavaka tsirairay, izay azo ampiasaina hanalana rano avy ao aminy, Ary ny isa 1 tsirairay dia maneho ny rano iray.Misy fantsona boribory mahitsizoro misy lavadrano, ary ny laharana tsirairay dia maneho lavadrano tokana.# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
# 6
# Example 2:
# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
# 5
# Example 3:
# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)
# 0
# Constraints:
# * all wells have the same length
# * 1 <= grid.length <= 10^2
# * 1 <= grid[:,1].length <= 10^2
# * grid[i][j] -> 0 | 1
# * 1 <= capacity <= 10
def max_fill(grid, capacity)
","def max_fill(grid, capacity)
  total_water_units = grid.flatten.sum
  (total_water_units.to_f / capacity).ceil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_fill
    candidate = method(:max_fill)
    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))
    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))
    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))
    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))
    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))
  end
end
"
HumanEval_116,plt_Latn,rb,"Tsy maintsy ampiharina toy izao: Raha mitovy isa ny isa, dia sokajy arakaraka ny sanda desimaly. isa ny isa ao amin'ny fanehoana azy ireo amin'ny filaharana miakatra. Ao anatin'ity Kata ity, tsy maintsy manara-maso ny laharan'ireo isa tsy miiba ianao araka ny # >>> sort_array.call([1, 5, 2, 3, 4])
# [1, 2, 3, 4, 5]
# >>> sort_array.call([-2, -3, -4, -5, -6])
# [-6, -5, -4, -3, -2]
# >>> sort_array.call([1, 0, 2, 3, 4])
# [0, 1, 2, 3, 4]
def sort_array(arr)
","def sort_array(arr)
  arr.sort_by { |n| [n.to_s(2).count('1'), n] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))
    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))
    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))
    assert_equal([], candidate.call([]))
    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))
    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
  end
end
"
HumanEval_117,plt_Latn,rb,"Ohatra: Fanamarihana: azonao atao ny mihevitra ny fampidirana tady afa-tsy misy litera sy ny toerana. Raha toa ka foana ny s, dia tokony hamerina array foana ilay asa. n ny fiombonana, araka ny filaharan'ny teny ao amin'ny tsipika s. fiasa izay mamerina ny laharan'ny teny rehetra avy amin'ny tsipika s izay misy marina Raha nomena ny tsipika s sy ny isa natoraly n, nomena andraikitra ianao hampihatra # >>> select_words.call(""Mary had a little lamb"", 4)
# [""little""]
# >>> select_words.call(""Mary had a little lamb"", 3)
# [""Mary"", ""lamb""]
# >>> select_words.call(""simple white space"", 2)
# []
# >>> select_words.call(""Hello world"", 4)
# [""world""]
# >>> select_words.call(""Uncle sam"", 3)
# [""Uncle""]
def select_words(s, n)
","def select_words(s, n)
  vowels = ""aeiouAEIOU""
  words = s.split
  words.select do |word|
    consonant_count = word.chars.count { |char| !vowels.include?(char) }
    consonant_count == n
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_select_words
    candidate = method(:select_words)
    assert_equal([""little""], candidate.call(""Mary had a little lamb"", 4))
    assert_equal([""Mary"", ""lamb""], candidate.call(""Mary had a little lamb"", 3))
    assert_equal([], candidate.call(""simple white space"", 2))
    assert_equal([""world""], candidate.call(""Hello world"", 4))
    assert_equal([""Uncle""], candidate.call(""Uncle sam"", 3))
    assert_equal([], candidate.call("""", 4))
    assert_equal([""b"", ""c"", ""d"", ""f""], candidate.call(""a b c d e f"", 1))
  end
end
"
HumanEval_118,plt_Latn,rb,"Ohatra: Azonao atao ny mihevitra fa ny andalana nomena dia ahitana litera anglisy ihany. mahita ny voambolana mifanaraka amin'ny fepetra etsy ambony. Tsy isaina ny voambolana eo amin'ny fiandohana sy ny fiafarana. Avereno ny tsipika foana raha tsy izany.ny fiombonana roa avy amin'ny ilany ankavanan'ny teny (mora tohina ny endri-tsoratra). Nomena teny iray ianao. Ny asanao dia ny mahita ny voambolana akaiky indrindra izay eo anelanelan'ny # >>> get_closest_vowel.call(""yogurt"")
# ""u""
# >>> get_closest_vowel.call(""FULL"")
# ""U""
# >>> get_closest_vowel.call(""quick"")
# """"
# >>> get_closest_vowel.call(""ab"")
# """"
def get_closest_vowel(word)
","def get_closest_vowel(word)
  vowels = ""aeiouAEIOU""
  (1...word.length - 1).reverse_each do |i|
    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])
      return word[i]
    end
  end
  return """"
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_closest_vowel
    candidate = method(:get_closest_vowel)
    assert_equal(""u"", candidate.call(""yogurt""))
    assert_equal(""u"", candidate.call(""full""))
    assert_equal("""", candidate.call(""easy""))
    assert_equal("""", candidate.call(""eAsy""))
    assert_equal("""", candidate.call(""ali""))
    assert_equal(""a"", candidate.call(""bad""))
    assert_equal(""o"", candidate.call(""most""))
    assert_equal("""", candidate.call(""ab""))
    assert_equal("""", candidate.call(""ba""))
    assert_equal("""", candidate.call(""quick""))
    assert_equal(""i"", candidate.call(""anime""))
    assert_equal("""", candidate.call(""Asia""))
    assert_equal(""o"", candidate.call(""Above""))
  end
end
"
HumanEval_119,plt_Latn,rb,"Ohatra: Avereno ny 'Eny' raha misy fomba hanaovana tady tsara, ary avereno ny 'Tsia' raha tsy izany. Tsy izany ny "" (()) "".ohatra: ny tady '(())))) ' dia tsara, raha ny tady Ny kofehy S dia heverina ho tsara raha toa ka ny fononteny rehetra ao amin'ny S Misy baiko, fa ny tady vokany dia ho tsara.Ny asanao dia ny manamarina raha azo atao ny mampifandray ireo kofehy roa ireo.eo amin'ny fononteny "" (("") na eo amin'ny fononteny akaiky fotsiny.Nomena anao ny array misy tady roa, samy ahitana open # >>> match_parens.call([""()("", "")""])
# ""Yes""
# >>> match_parens.call(["")"", "")""])
# ""No""
def match_parens(lst)
","def match_parens(lst)
  a, b = lst

  # Define a helper method to check if a string is balanced
  def balanced?(s)
    count = 0
    s.each_char do |c|
      count += 1 if c == '('
      count -= 1 if c == ')'
      return false if count < 0
    end
    count == 0
  end

  # Check if either concatenation forms a good string
  if balanced?(a + b) || balanced?(b + a)
    ""Yes""
  else
    ""No""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_match_parens
    candidate = method(:match_parens)
    assert_equal(""Yes"", candidate.call([""()("", "")""]))
    assert_equal(""No"", candidate.call(["")"", "")""]))
    assert_equal(""No"", candidate.call([""(()(())"", ""())())""]))
    assert_equal(""Yes"", candidate.call(["")())"", ""(()()(""]))
    assert_equal(""Yes"", candidate.call([""(())))"", ""(()())((""]))
    assert_equal(""No"", candidate.call([""()"", ""())""]))
    assert_equal(""Yes"", candidate.call([""(()("", ""()))()""]))
    assert_equal(""No"", candidate.call([""(((("", ""((())""]))
    assert_equal(""No"", candidate.call(["")(()"", ""(()(""]))
    assert_equal(""No"", candidate.call(["")("", "")(""]))
    assert_equal(""Yes"", candidate.call([""("", "")""]))
    assert_equal(""Yes"", candidate.call(["")"", ""(""]))
  end
end
"
HumanEval_120,plt_Latn,rb,"Ohatra 1: ny halavan'ny k miaraka amin'ny isa k ambony indrindra amin'ny arr. Raha nomena array iray misy integer arr sy integer k, avereno ny array voalahatra # >>> maximum.call([-3, -4, 5], 3)
# [-4, -3, 5]
# Example 2:
# >>> maximum.call([4, -4, 4], 2)
# [4, 4]
# Example 3:
# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)
# [2]
# Note:
# 1. The length of the array will be in the range of [1, 1000].
# 2. The elements in the array will be in the range of [-1000, 1000].
# 3. 0 <= k <= len(arr)
def maximum(arr, k)
","def maximum(arr, k)
  arr.sort.last(k).sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_maximum
    candidate = method(:maximum)
    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))
    assert_equal([4, 4], candidate.call([4, -4, 4], 2))
    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))
    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))
    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))
    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))
    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))
    assert_equal([5], candidate.call([1, 0, 5, -7], 1))
    assert_equal([-4, 4], candidate.call([4, -4], 2))
    assert_equal([-10, 10], candidate.call([-10, 10], 2))
    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))
  end
end
"
HumanEval_121,plt_Latn,rb,"Ohatra Raha nomena ny laharana iray tsy banga, avereno ny fitambaran'ny singa rehetra izay ao amin'ny toerana mitovy. # >>> solution.call([5, 8, 7, 1])
# 12
# >>> solution.call([3, 3, 3, 3, 3])
# 9
# >>> solution.call([30, 13, 24, 321])
# 0
def solution(lst)
","def solution(lst)
  lst.each_with_index.reduce(0) do |sum, (val, idx)|
    (idx.even? && val.odd?) ? sum + val : sum
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solution
    candidate = method(:solution)
    assert_equal(12, candidate.call([5, 8, 7, 1]))
    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))
    assert_equal(0, candidate.call([30, 13, 24, 321]))
    assert_equal(5, candidate.call([5, 9]))
    assert_equal(0, candidate.call([2, 4, 8]))
    assert_equal(23, candidate.call([30, 13, 23, 32]))
    assert_equal(3, candidate.call([3, 13, 2, 9]))
  end
end
"
HumanEval_122,plt_Latn,rb,"Ohatra: ny fitambaran'ny singa manana isa roa farafahakeliny avy amin'ny k voalohany amin'ny arr. Raha nomena ny array tsy banga misy integer arr sy integer k, miverina # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
# 24
# Constraints:
# 1. 1 <= len(arr) <= 100
# 2. 1 <= k <= len(arr)
def add_elements(arr, k)
","def add_elements(arr, k)
  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add_elements
    candidate = method(:add_elements)
    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))
    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))
    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))
    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))
    assert_equal(1, candidate.call([1], 1))
  end
end
"
HumanEval_123,plt_Latn,rb,"get_odd_collatz(5) mamerina [1, 5] # Ny filaharan'ny collatz ho an'ny 5 dia [5, 16, 8, 4, 2, 1], ka ny isa tsy mitovy dia ny 1 sy 5 ihany. Ohatra: 2. niverina array nandamina amin'ny fiakarana mba. 1. Ny Collatz(1) dia [1]. Fanamarihana: Ny vinavina dia hoe na inona na inona lanjan'ny n, dia hahatratra 1 foana ny filaharana.Raha toa ka tsy mitovy isa ny fehezanteny teo aloha, dia ho 3 heny ny fehezanteny teo aloha ny fehezanteny manaraka.Ny fehezan-teny teo aloha dia toy izao: raha toa ka mitovy isa ny fehezan-teny teo aloha, ny fehezan-teny manaraka dia ny antsasaky ny toy izao manaraka izao: atombohy amin'ny isa iray manontolo n. Avy eo ny fehezan-teny tsirairay dia azo avy amin'ny Ny vinavinan'i Collatz dia vinavinan'ny matematika izay mikasika ny filaharana voafaritra Raha nomena isa iray n, avereno ny array voalahatra izay manana isa tsy mitovy ao amin'ny filaharan'ny collatz. # >>> get_odd_collatz.call(5)
# [1, 5]
def get_odd_collatz(n)
","def get_odd_collatz(n)
  collatz_sequence = []
  while n != 1
    collatz_sequence << n if n.odd?
    if n.even?
      n = n / 2
    else
      n = 3 * n + 1
    end
  end
  collatz_sequence << 1 if n == 1

  collatz_sequence.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_odd_collatz
    candidate = method(:get_odd_collatz)
    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))
    assert_equal([1, 5], candidate.call(5))
    assert_equal([1, 3, 5], candidate.call(12))
    assert_equal([1], candidate.call(1))
  end
end
"
HumanEval_124,plt_Latn,rb,"4. Tokony ho ao anatin'ny endrika: mm-dd-yyyy  ny datyTsy tokony ho latsaky ny 1 volana na mihoatra ny 12 volana ny volana.Ny isan'ny andro dia tsy latsaky ny 1 na mihoatra ny 31 andro ho an'ny volana 1,3,5,7,8,10,12. Ary ny isan'ny andro dia tsy latsaky ny 1 na mihoatra ny 30 andro ho an'ny volana 4,6,9,11. Ary, ny isan'ny andro dia tsy latsaky ny 1 na mihoatra ny 29 ho an'ny volana 2. 1. Tsy foana ny daty.Marina ny daty raha toa ka voahaja avokoa ireto fitsipika manaraka ireto: miverina marina raha marina ny daty raha tsy izany diso. Tsy maintsy manoratra fiasa izay manamarina ny daty nomena ianao ary # >>> valid_date.call(""03-11-2000"")
# true
# >>> valid_date.call(""15-01-2012"")
# false
# >>> valid_date.call(""04-0-2040"")
# false
# >>> valid_date.call(""06-04-2020"")
# true
# >>> valid_date.call(""06/04/2020"")
# false
def valid_date(date)
","def valid_date(date)
  return false if date.nil? || date.empty?
  
  # Check if the date format is correct
  match = date.match(/^(\d{2})-(\d{2})-(\d{4})$/)
  return false unless match
  
  month, day, year = match.captures.map(&:to_i)
  
  # Check if month is valid
  return false if month < 1 || month > 12
  
  # Check if day is valid according to the month
  case month
  when 1, 3, 5, 7, 8, 10, 12
    return day >= 1 && day <= 31
  when 4, 6, 9, 11
    return day >= 1 && day <= 30
  when 2
    return day >= 1 && day <= 29
  else
    return false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_valid_date
    candidate = method(:valid_date)
    assert_equal(true, candidate.call(""03-11-2000""))
    assert_equal(false, candidate.call(""15-01-2012""))
    assert_equal(false, candidate.call(""04-0-2040""))
    assert_equal(true, candidate.call(""06-04-2020""))
    assert_equal(true, candidate.call(""01-01-2007""))
    assert_equal(false, candidate.call(""03-32-2011""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""04-31-3000""))
    assert_equal(true, candidate.call(""06-06-2005""))
    assert_equal(false, candidate.call(""21-31-2000""))
    assert_equal(true, candidate.call(""04-12-2003""))
    assert_equal(false, candidate.call(""04122003""))
    assert_equal(false, candidate.call(""20030412""))
    assert_equal(false, candidate.call(""2003-04""))
    assert_equal(false, candidate.call(""2003-04-12""))
    assert_equal(false, candidate.call(""04-2003""))
  end
end
"
HumanEval_125,plt_Latn,rb,"Ohatra abidia, ord (a) = 0, ord (b) = 1, ... ord (z) = 25 tokony hozaraina amin'ny commas ',' raha tsy misy commas dia tokony hamerina ny isan'ny litera kely amin'ny filaharana hafahafa ao amin'ny Raha nomena andian-teny, avereno ny andian-teny mizara amin'ny habaka fotsy, raha tsy misy habaka fotsy ao amin'ny lahatsoratra tadiavinao # >>> split_words.call(""Hello world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""Hello,world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""abcdef"")
# 3
def split_words(txt)
","def split_words(txt)
  if txt.include?(' ')
    return txt.split(' ')
  elsif txt.include?(',')
    return txt.split(',')
  else
    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }
    return odd_count
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_split_words
    candidate = method(:split_words)
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello world!""))
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello,world!""))
    assert_equal([""Hello"", ""world,!""], candidate.call(""Hello world,!""))
    assert_equal([""Hello,Hello,world"", ""!""], candidate.call(""Hello,Hello,world !""))
    assert_equal(3, candidate.call(""abcdef""))
    assert_equal(2, candidate.call(""aaabb""))
    assert_equal(1, candidate.call(""aaaBb""))
    assert_equal(0, candidate.call(""""))
  end
end
"
HumanEval_126,plt_Latn,rb,"Ohatra Tsy misy isa ratsy fa isa feno ihany.Raha manana mihoatra ny iray ny duplicate ny array iray ihany Nomena isa maromaro, avereno na voalahatra na tsia izy ireo.# >>> is_sorted.call([5])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5])
# false
# >>> is_sorted.call([1, 2, 3, 4, 5, 6])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])
# false
# >>> is_sorted.call([1, 2, 2, 3, 3, 4])
# true
# >>> is_sorted.call([1, 2, 2, 2, 3, 4])
# false
def is_sorted(lst)
","def is_sorted(lst)
  lst.each_cons(2).with_index do |(a, b), index|
    return false if a > b
    return false if index < lst.length - 2 && a == b && lst[index + 2] == b
  end
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_sorted
    candidate = method(:is_sorted)
    assert_equal(true, candidate.call([5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))
    assert_equal(true, candidate.call([]))
    assert_equal(true, candidate.call([1]))
    assert_equal(false, candidate.call([3, 2, 1]))
    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))
    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 3, 4]))
  end
end
"
HumanEval_127,plt_Latn,rb,"[fidirana/fivoahana] santionany: Raha tsy mifanindry ireo elanelana roa ireo, avereno ny ""TSIA"". Raha tsy izany dia avereno ny ""TSIA"". Raha ny halavan'ny fihaonan-javatra dia isa voalohany, miverina ""Eny"", izay ny halavany dia 1, izay tsy isa voalohany. Ohatra, ny fifandonan'ny elanelana (1, 3), (2, 4) dia (2, 3) isa voalohany ny elanelana. Ny asanao dia ny mamaritra raha ny halavan'ny fihaonan'ireo roa ireo Ho an'ny elanelam-potoana tsirairay, dia heverina fa ny fiandohany dia kely kokoa na mitovy amin'ny fiafarany. ahitana ny fiandohana sy ny fiafarana. Ny elanelam-potoana nomena dia mihidy izay midika fa ny elanelam-potoana (fanombohana, farany) izay ny elanelana tsirairay dia mpivady isa iray. ohatra, elanelana = (fiandohana, fiafarana) = (1, 2).Nomena fotoana roa ianao, # >>> intersection.call([1, 2], [2, 3])
# ""NO""
# >>> intersection.call([-1, 1], [0, 4])
# ""NO""
# >>> intersection.call([-3, -1], [-5, 5])
# ""YES""
def intersection(interval1, interval2)
","def intersection(interval1, interval2)
  start1, end1 = interval1
  start2, end2 = interval2

  intersection_start = [start1, start2].max
  intersection_end = [end1, end2].min

  if intersection_start > intersection_end
    return ""NO""
  end

  intersection_length = intersection_end - intersection_start + 1

  return ""YES"" if prime?(intersection_length)

  ""NO""
end

def prime?(n)
  return false if n <= 1
  return true if n == 2 || n == 3

  (2..Math.sqrt(n).to_i).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersection
    candidate = method(:intersection)
    assert_equal(""NO"", candidate.call([1, 2], [2, 3]))
    assert_equal(""NO"", candidate.call([-1, 1], [0, 4]))
    assert_equal(""YES"", candidate.call([-3, -1], [-5, 5]))
    assert_equal(""YES"", candidate.call([-2, 2], [-4, 0]))
    assert_equal(""NO"", candidate.call([-11, 2], [-1, -1]))
    assert_equal(""NO"", candidate.call([1, 2], [3, 5]))
    assert_equal(""NO"", candidate.call([1, 2], [1, 2]))
    assert_equal(""NO"", candidate.call([-2, -2], [-3, -2]))
  end
end
"
HumanEval_128,plt_Latn,rb,"Ohatra: Fanamarihana: miverina nil ho an'ny foana arr. Isan'ny isa ao amin'ny array, aseho amin'ny 1, -1 na 0. fitambaran'ny haben'ny isa manontolo ampitomboina amin'ny vokatra amin'ny famantarana rehetra Nomena array arr misy integer ianao ary mila miverina # >>> prod_signs.call([1, 2, 2, -4])
# 9
# >>> prod_signs.call([0, 1])
# 0
# >>> prod_signs.call([])
# nil
def prod_signs(arr)
","def prod_signs(arr)
  return nil if arr.empty?
  
  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }
  sum_magnitudes = arr.map(&:abs).sum
  
  product_signs * sum_magnitudes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prod_signs
    candidate = method(:prod_signs)
    assert_equal(-9, candidate.call([1, 2, 2, -4]))
    assert_equal(0, candidate.call([0, 1]))
    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))
    assert_equal(nil, candidate.call([]))
    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))
    assert_equal(4, candidate.call([-1, 1, -1, 1]))
    assert_equal(-4, candidate.call([-1, 1, 1, 1]))
    assert_equal(0, candidate.call([-1, 1, 1, 0]))
  end
end
"
HumanEval_129,plt_Latn,rb,"Ohatra: Miverina ny baiko array ny soatoavina eo amin'ny sela izay ny kely indrindra lalana mandeha amin'ny alalan'ny. Azo antoka fa tsy manam-paharoa ny valiny. lst_A[j] = lst_B[j]. toy ny lst_A[i] < lst_B[i] ary ho an'ny j (1 <= j < i) dia manana noho ny lst_B, amin'ny teny hafa, misy misy integer index i (1 <= i <= k) amin'ny alalan'ny (andao hiantso azy ireo hoe lst_A sy lst_B), lst_A dia kely kokoa ara-lexikografika Rehefa avy nanao ny baiko arrays ny soatoavina eo amin'ny sela izay A sy B handeha Ny lalana A (ny halavan'ny k) dia heverina ho kely kokoa noho ny lalana B (ny halavan'ny k) raha TSY AZO atao ny miala amin'ny tambajotran-tserasera. tsy voatery ho samy hafa).Mariho fa ny lalana ny halavan'ny k dia midika hoe mitsidika ny sela k (tsy ny finday. amin'ny teny hafa, afaka mandeha any amin'ny sela izay mizara sisiny amin'ny anao ianao amin'izao fotoana izao avy amin'ny sela rehetra, ary isaky ny dingana dia afaka mifindra any amin'ny sela mpifanolo-bodirindrina aminy ianao, Mila mahita ny lÃ lana kely indrindra amin'ny halavan'ny k ao amin'ny tambajotra ianao.Indray mandeha ihany no miseho ao amin'ny sela ao amin'ny tambajotra ny inclusive. Ny isa manontolo rehetra ao anatin'ny laharana [1, N * N] Raha misy ny tabilao misy laharana sy tsanganana N (N >= 2) ary k isa feno, dia # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
# [1, 2, 1]
# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
# [1]
def minPath(grid, k)
","def minPath(grid, k)
  n = grid.size
  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  min_path = nil

  n.times do |i|
    n.times do |j|
      queue = [[[i, j], [grid[i][j]]]]
      until queue.empty?
        position, path = queue.shift
        if path.size == k
          min_path = path if min_path.nil? || path < min_path
          next
        end
        directions.each do |dx, dy|
          x, y = position[0] + dx, position[1] + dy
          if x.between?(0, n-1) && y.between?(0, n-1)
            queue.push([[x, y], path + [grid[x][y]]])
          end
        end
      end
    end
  end
  min_path
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minPath
    candidate = method(:minPath)
    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))
    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))
    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))
    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))
    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))
    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))
    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))
  end
end
"
HumanEval_130,plt_Latn,rb,"Ohatra: Ny isa voalohany n + 1 amin'ny filaharan'i Tribonacci. Nomena isa iray tsy miiba n ianao, tsy maintsy mamerina array iray amin'ny = 2 + 3 + 3 = 8 Telo (telo) = telo (droa) + telo (iray) + telo (efatra) tri(4) = 3 tri(2) = 1 + (2 / 2) = 2 Ohatra: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), raha toa ka tsy mitovy isa ny n. tri (n) = 1 + n / 2, raha n dia mitovy isa. tri(1) = 3 Ny fiverenan'ny trangan'ny Tribonacci dia voafaritra amin'ny alalan'ny fiverenan'ny: Na izany aza, ny tsy fantatry ny olona dia ny filaharan'i Tribonacci.Fantatry ny rehetra ny filaharan'i Fibonacci, nianatra lalina tamin'ny alalan'ny matematika izy io tamin'ny taona # >>> tri.call(3)
# [1, 3, 2, 8]
def tri(n)
","def tri(n)
  sequence = [1, 3]
  
  (2..n).each do |i|
    if i.even?
      sequence[i] = 1 + i / 2
    else
      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0
    end
  end
  
  sequence[0..n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_tri
    candidate = method(:tri)
    assert_equal([1, 3, 2, 8], candidate.call(3))
    assert_equal([1, 3, 2, 8, 3], candidate.call(4))
    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))
    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))
    assert_equal([1], candidate.call(0))
    assert_equal([1, 3], candidate.call(1))
  end
end
"
HumanEval_131,plt_Latn,rb,"Ohatra: Miverina 0 raha toa ka mitovy daholo ny isa rehetra. Raha nomena isa iray feno n, avereno ny vokatra avy amin'ny isa tsy mitovy. # >>> digits.call(1)
# 1
# >>> digits.call(4)
# 0
# >>> digits.call(235)
# 15
def digits(n)
","def digits(n)
  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }
  return 0 if odd_digits.empty?
  odd_digits.reduce(:*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digits
    candidate = method(:digits)
    assert_equal(5, candidate.call(5))
    assert_equal(5, candidate.call(54))
    assert_equal(1, candidate.call(120))
    assert_equal(5, candidate.call(5014))
    assert_equal(315, candidate.call(98765))
    assert_equal(2625, candidate.call(5576543))
    assert_equal(0, candidate.call(2468))
  end
end
"
HumanEval_132,plt_Latn,rb,"izay farafahakeliny iray bracket ao amin'ny subsequence dia nested. Ny fiasa dia tokony hiverina marina raha toa ka misy ny manaraka ny fonosana manan-kery Mamorona fiasa izay mandray tady ho toy ny fidirana izay misy fonosana boribory fotsiny. # >>> is_nested.call(""[[]]"")
# true
# >>> is_nested.call(""[]]]]]]][[[[[]"")
# false
# >>> is_nested.call(""[][]"")
# false
# >>> is_nested.call(""[]"")
# false
# >>> is_nested.call(""[[][]]"")
# true
# >>> is_nested.call(""[[]][["")
# true
def is_nested(string)
","def is_nested(string)
  stack = []
  has_nested = false

  string.each_char do |char|
    if char == '['
      stack.push(char)
    elsif char == ']'
      if stack.empty?
        return false
      end
      stack.pop
      has_nested = true if stack.any?
    end
  end

  has_nested
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_nested
    candidate = method(:is_nested)
    assert_equal(true, candidate.call(""[[]]""))
    assert_equal(false, candidate.call(""[]]]]]]][[[[[]""))
    assert_equal(false, candidate.call(""[][]""))
    assert_equal(false, candidate.call(""[]""))
    assert_equal(true, candidate.call(""[[[[]]]]""))
    assert_equal(false, candidate.call(""[]]]]]]]]]]""))
    assert_equal(true, candidate.call(""[][][[]]""))
    assert_equal(false, candidate.call(""[[]""))
    assert_equal(false, candidate.call(""[]]""))
    assert_equal(true, candidate.call(""[[]][[""))
    assert_equal(true, candidate.call(""[[][]]""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""[[[[[[[[""))
    assert_equal(false, candidate.call(""]]]]]]]]""))
  end
end
"
HumanEval_133,plt_Latn,rb,"Ohatra: Ahodina aloha ny singa tsirairay ao amin'ny array ho any amin'ny int ambony indrindra.Mila mamerina ny fitambaran'ny isa miakatra avo roa heny ao amin'ny laharana nomena ianao, Nomena tarehimarika maromaro ianao.# >>> lst.call([1.0, 2.0, 3.0])
# 14
# >>> lst.call([1.0, 4.0, 9.0])
# 98
# >>> lst.call([1.0, 3.0, 5.0, 7.0])
# 84
# >>> lst.call([1.4, 4.2, 0.0])
# 29
# >>> lst.call([-2.4, 1.0, 1.0])
# 6
def sum_squares(lst)
","def sum_squares(lst)
  lst.map { |num| (num.ceil)**2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))
    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))
    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))
    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))
    assert_equal(200000000, candidate.call([10000.0, 10000.0]))
    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))
    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))
    assert_equal(0, candidate.call([0.0]))
    assert_equal(1, candidate.call([-1.0]))
    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))
  end
end
"
HumanEval_134,plt_Latn,rb,"Ohatra: Fanamarihana: ""teny"" dia vondrona litera misaraka amin'ny habaka. ampahany amin'ny teny, ary diso raha tsy izany.ny tsipika nomena dia litera abidia ary tsy Mamorona fiasa izay mamerina ny marina raha toa ka ny tarehin-tsoratra farany # >>> check_if_last_char_is_a_letter.call(""apple pie"")
# false
# >>> check_if_last_char_is_a_letter.call(""apple pi e"")
# true
# >>> check_if_last_char_is_a_letter.call(""apple pi e "")
# false
# >>> check_if_last_char_is_a_letter.call("""")
# false
def check_if_last_char_is_a_letter(txt)
","check_if_last_char_is_a_letter = ->(txt) {
  return false if txt.strip.empty?
  words = txt.strip.split(' ')
  last_word = words.last
  return false if last_word.empty?
  last_char = last_word[-1]

  last_char =~ /[a-zA-Z]/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')
}","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_if_last_char_is_a_letter
    candidate = method(:check_if_last_char_is_a_letter)
    assert_equal(false, candidate.call(""apple""))
    assert_equal(true, candidate.call(""apple pi e""))
    assert_equal(false, candidate.call(""eeeee""))
    assert_equal(true, candidate.call(""A""))
    assert_equal(false, candidate.call(""Pumpkin pie ""))
    assert_equal(false, candidate.call(""Pumpkin pie 1""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""eeeee e ""))
    assert_equal(false, candidate.call(""apple pie""))
    assert_equal(false, candidate.call(""apple pi e ""))
  end
end
"
HumanEval_135,plt_Latn,rb,"Ohatra: Misy lanjany roa.tsy misy singa toy izany dia miverina -1. Ny array nomena dia tsy ahitana Tsy lehibe noho na mitovy amin'ny singa eo alohan'ny azy avy hatrany.Mamorona asa izay miverina ny lehibe indrindra index ny singa izay # >>> can_arrange.call([1, 2, 4, 3, 5])
# 3
# >>> can_arrange.call([1, 2, 3])
# -1
def can_arrange(arr)
","def can_arrange(arr)
  (1...arr.length).reverse_each do |i|
    return i if arr[i] < arr[i - 1]
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_can_arrange
    candidate = method(:can_arrange)
    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))
    assert_equal(-1, candidate.call([1, 2, 4, 5]))
    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))
    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))
    assert_equal(-1, candidate.call([]))
  end
end
"
HumanEval_136,plt_Latn,rb,"Ohatra: Raha tsy misy ny isa isa ratsy na tsara, dia avereno ho nil. amin'ny isa feno ao anaty array.ny lehibe indrindra amin'ny isa miiba, ary ny kely indrindra dia ny ""b"" Mamorona fiasa izay mamerina array (a, b), izay 'a' dia # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])
# [nil, 1]
# >>> largest_smallest_integers.call([])
# [nil, nil]
# >>> largest_smallest_integers.call([0])
# [nil, nil]
def largest_smallest_integers(lst)
","def largest_smallest_integers(lst)
  largest_negative = nil
  smallest_positive = nil
  
  lst.each do |num|
    if num < 0
      largest_negative = num if largest_negative.nil? || num > largest_negative
    elsif num > 0
      smallest_positive = num if smallest_positive.nil? || num < smallest_positive
    end
  end
  
  [largest_negative, smallest_positive]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_smallest_integers
    candidate = method(:largest_smallest_integers)
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))
    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))
    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))
    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))
    assert_equal([nil, nil], candidate.call([]))
    assert_equal([nil, nil], candidate.call([0]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))
  end
end
"
HumanEval_137,plt_Latn,rb,"Fanamarihana: Raha misy isa tena izy aseho amin'ny endriky ny tady, ny teboka mivezivezy dia mety ho . na , Miverina nil raha mitovy ny sanda. isa tena izy, ary miverina ny lehibe kokoa miovaova ao amin'ny nomena karazana miovaova. Mamorona fiasa izay mandray isa manontolo, floats, na tady maneho # >>> compare_one.call(1, 2.5)
# 2.5
# >>> compare_one.call(1, ""2,3"")
# ""2,3""
# >>> compare_one.call(""5,1"", ""6"")
# ""6""
# >>> compare_one.call(""1"", 1)
# nil
def compare_one(a, b)
","def compare_one(a, b)
  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')
  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')

  if a.is_a?(String) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Float)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Float)
    a = a.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Integer)
    b = b.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Float)
    b = b.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(String)
    a = a.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  else
    return nil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare_one
    candidate = method(:compare_one)
    assert_equal(2, candidate.call(1, 2))
    assert_equal(2.5, candidate.call(1, 2.5))
    assert_equal(3, candidate.call(2, 3))
    assert_equal(6, candidate.call(5, 6))
    assert_equal(""2,3"", candidate.call(1, ""2,3""))
    assert_equal(""6"", candidate.call(""5,1"", ""6""))
    assert_equal(""2"", candidate.call(""1"", ""2""))
    assert_equal(nil, candidate.call(""1"", 1))
  end
end
"
HumanEval_138,plt_Latn,rb,"Ohatra Diniho raha azo soratana ho toy ny fitambaran'ny isa 4 marina tsara ny isa n nomena # >>> is_equal_to_sum_even.call(4)
# false
# >>> is_equal_to_sum_even.call(6)
# false
# >>> is_equal_to_sum_even.call(8)
# true
def is_equal_to_sum_even(n)
","def is_equal_to_sum_even(n)
  return false if n < 8
  n.even?
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_equal_to_sum_even
    candidate = method(:is_equal_to_sum_even)
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(8))
    assert_equal(true, candidate.call(10))
    assert_equal(false, candidate.call(11))
    assert_equal(true, candidate.call(12))
    assert_equal(false, candidate.call(13))
    assert_equal(true, candidate.call(16))
  end
end
"
HumanEval_139,plt_Latn,rb,"Ohatra: izay n > 0 brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! Ny factoriel breziliana dia voafaritra toy izao: # >>> special_factorial.call(4)
# 288
# The function will receive an integer as input and should return the special
# factorial of this integer.
def special_factorial(n)
","def special_factorial(n)
  return 1 if n <= 1
  (1..n).inject(1) { |product, i| product * factorial(i) }
end

def factorial(num)
  return 1 if num <= 1
  (2..num).inject(1, :*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_special_factorial
    candidate = method(:special_factorial)
    assert_equal(288, candidate.call(4))
    assert_equal(34560, candidate.call(5))
    assert_equal(125411328000, candidate.call(7))
    assert_equal(1, candidate.call(1))
  end
end
"
HumanEval_140,plt_Latn,rb,"avy eo soloina -  ny toerana rehetra misesyary raha misy tsipika mihoatra ny 2 ny toerana misesy, Raha nomena andinin-teny, soloina soratra ambany ny toerana rehetra ao aminy, # >>> fix_spaces.call("" Example"")
# ""Example""
# >>> fix_spaces.call("" Example 1"")
# ""Example_1""
# >>> fix_spaces.call("" Example 2"")
# ""_Example_2""
# >>> fix_spaces.call("" Example 3"")
# ""_Example-3""
def fix_spaces(text)
","def fix_spaces(text)
  text.strip.gsub(/\s{3,}/, '-').gsub(' ', '_')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fix_spaces
    candidate = method(:fix_spaces)
    assert_equal(""Example"", candidate.call(""Example""))
    assert_equal(""Mudasir_Hanif_"", candidate.call(""Mudasir Hanif ""))
    assert_equal(""Yellow_Yellow__Dirty__Fellow"", candidate.call(""Yellow Yellow  Dirty  Fellow""))
    assert_equal(""Exa-mple"", candidate.call(""Exa   mple""))
    assert_equal(""-Exa_1_2_2_mple"", candidate.call(""   Exa 1 2 2 mple""))
  end
end
"
HumanEval_141,plt_Latn,rb,"Ohatra: - Ny singa fototra aorian'ny teboka dia tokony ho iray amin'ireto: ['txt', 'exe', 'dll'] ny abidy latina ('a'-'z' ary 'A'-'Z'). - Tsy tokony ho foana ny tarehimarika eo alohan'ny teboka, ary manomboka amin'ny litera avy amin'ny - Ny anaran'ny rakitra dia ahitana teboka iray '.' - Tsy tokony hisy tarehimarika mihoatra ny telo ('0'-'9') ao amin'ny anaran'ny rakitra. dia feno: Heverina ho manan-kery ny anaran'ny rakitra raha toa ka mifanaraka amin'ireto fepetra manaraka ireto ny anarana rehetra 'Eny' raha toa ka marina ny anaran'ny rakitra, ary mamerina 'Tsia' raha tsy izany. Mamorona fiasa izay mandray tady maneho ny anaran'ny rakitra, ary miverina # >>> file_name_check.call(""example.txt"")
# ""Yes""
# >>> file_name_check.call(""1example.dll"")
# ""No""
def file_name_check(file_name)
","def file_name_check(file_name)
  # Check if there's exactly one dot in the filename
  return 'No' unless file_name.count('.') == 1
  
  # Split the filename into the name and extension
  name, extension = file_name.split('.')
  
  # Check if the name part starts with a letter
  return 'No' if name.empty? || !name[0].match?(/[a-zA-Z]/)
  
  # Check if the extension is valid
  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)
  
  # Count digits in the file name
  digit_count = file_name.count(""0-9"")
  
  # Check if digits are more than three
  return 'No' if digit_count > 3
  
  'Yes'
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_file_name_check
    candidate = method(:file_name_check)
    assert_equal(""Yes"", candidate.call(""example.txt""))
    assert_equal(""No"", candidate.call(""1example.dll""))
    assert_equal(""No"", candidate.call(""s1sdf3.asd""))
    assert_equal(""Yes"", candidate.call(""K.dll""))
    assert_equal(""Yes"", candidate.call(""MY16FILE3.exe""))
    assert_equal(""No"", candidate.call(""His12FILE94.exe""))
    assert_equal(""No"", candidate.call(""_Y.txt""))
    assert_equal(""No"", candidate.call(""?aREYA.exe""))
    assert_equal(""No"", candidate.call(""/this_is_valid.dll""))
    assert_equal(""No"", candidate.call(""this_is_valid.wow""))
    assert_equal(""Yes"", candidate.call(""this_is_valid.txt""))
    assert_equal(""No"", candidate.call(""this_is_valid.txtexe""))
    assert_equal(""No"", candidate.call(""#this2_i4s_5valid.ten""))
    assert_equal(""No"", candidate.call(""@this1_is6_valid.exe""))
    assert_equal(""No"", candidate.call(""this_is_12valid.6exe4.txt""))
    assert_equal(""No"", candidate.call(""all.exe.txt""))
    assert_equal(""Yes"", candidate.call(""I563_No.exe""))
    assert_equal(""Yes"", candidate.call(""Is3youfault.txt""))
    assert_equal(""Yes"", candidate.call(""no_one#knows.dll""))
    assert_equal(""No"", candidate.call(""1I563_Yes3.exe""))
    assert_equal(""No"", candidate.call(""I563_Yes3.txtt""))
    assert_equal(""No"", candidate.call(""final..txt""))
    assert_equal(""No"", candidate.call(""final132""))
    assert_equal(""No"", candidate.call(""_f4indsartal132.""))
    assert_equal(""No"", candidate.call("".txt""))
    assert_equal(""No"", candidate.call(""s.""))
  end
end
"
HumanEval_142,plt_Latn,rb,"Ohatra: hanova ny fidirana ao amin'ny array izay ny index dia tsy maro ny 3 na 4. ny asa dia avy eo hiverina ny sombin'ny rehetra ny fidirana. Ny isa dia maro an'isa amin'ny 3 ary ho lasa kibo ny isa feno raha toa ka maro an'isa amin'ny 4 ny index-ny fa tsy maro an'isa amin'ny 3. Tsy ho Ity fiasa ity dia handray ny array iray amin'ny integer. Ho an'ny fidirana rehetra ao amin'ny array, ny fiasa dia tokony hampiakatra ny efitra fidirana raha toa ka ny index dia "" # >>> lst
# [1, 2, 3]
# >>> lst
# []
# >>> lst
# [-1, -5, 2, -1, -5]
def sum_squares(lst)
","def sum_squares(lst)
  lst.map.with_index do |num, index|
    if index % 3 == 0
      num ** 2
    elsif index % 4 == 0
      num ** 3
    else
      num
    end
  end.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(6, candidate.call([1, 2, 3]))
    assert_equal(14, candidate.call([1, 4, 9]))
    assert_equal(0, candidate.call([]))
    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))
    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))
    assert_equal(0, candidate.call([0]))
    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))
    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))
    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))
    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))
    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))
  end
end
"
HumanEval_143,plt_Latn,rb,"Ohatra 1: ny filaharan'ny teny ao amin'ny andian-teny vaovao dia tokony hitovy amin'ny tany am-boalohany. izay manana isa voalohany ny halavany, ary tsy maintsy mamerina ny tadiny izay ahitana ny teny avy amin'ny fehezanteny tany am-boalohany ianao, misy teny sasany misaraka amin'ny toerana ny fehezanteny, Nomena tady maneho fehezanteny ianao, # >>> words_in_sentence.call(""This is a test"")
# ""is""
# Example 2:
# >>> words_in_sentence.call(""lets go for swimming"")
# ""go for""
# Constraints:
# * 1 <= len(sentence) <= 100
# * sentence contains only letters
def words_in_sentence(sentence)
","def words_in_sentence(sentence)
  def is_prime?(num)
    return false if num <= 1
    (2..Math.sqrt(num)).none? { |i| num % i == 0 }
  end
  
  words = sentence.split("" "")
  prime_length_words = words.select { |word| is_prime?(word.length) }
  prime_length_words.join("" "")
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_in_sentence
    candidate = method(:words_in_sentence)
    assert_equal(""is"", candidate.call(""This is a test""))
    assert_equal(""go for"", candidate.call(""lets go for swimming""))
    assert_equal(""there is no place"", candidate.call(""there is no place available here""))
    assert_equal(""Hi am Hussein"", candidate.call(""Hi I am Hussein""))
    assert_equal(""go for it"", candidate.call(""go for it""))
    assert_equal("""", candidate.call(""here""))
    assert_equal(""is"", candidate.call(""here is""))
  end
end
"
HumanEval_144,plt_Latn,rb,"Azonao atao ny mihevitra fa x, sy n dia ampahany manan-kery, ary tsy manana zero ho mpisolo anarana. <mpanisa>/<mpanapaka> izay samy isa feno miampy ny mpanisa sy ny mpanapaka. Samy fanehoana andian-dahatsoratra ny ampahany ny x sy ny n, ary manana ity endrika manaraka ity, x * n. Mamerina ny valiny marina raha toa ka manombana ho isa iray manontolo ny x * n ary diso Ny asanao dia ny hampihatra ny fiasa izay hanatsotra ny fitenenana # >>> simplify.call(""1/5"", ""5/1"")
# true
# >>> simplify.call(""1/6"", ""2/1"")
# false
# >>> simplify.call(""7/10"", ""10/2"")
# false
def simplify(x, n)
","def simplify(x, n)
  # Convert x and n to numerators and denominators
  num_x, den_x = x.split('/').map(&:to_i)
  num_n, den_n = n.split('/').map(&:to_i)

  # Multiply fractions: (num_x * num_n) / (den_x * den_n)
  numerator = num_x * num_n
  denominator = den_x * den_n

  # Check if the result is a whole number
  numerator % denominator == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_simplify
    candidate = method(:simplify)
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/6"", ""2/1""))
    assert_equal(true, candidate.call(""5/1"", ""3/1""))
    assert_equal(false, candidate.call(""7/10"", ""10/2""))
    assert_equal(true, candidate.call(""2/10"", ""50/10""))
    assert_equal(true, candidate.call(""7/2"", ""4/2""))
    assert_equal(true, candidate.call(""11/6"", ""6/1""))
    assert_equal(false, candidate.call(""2/3"", ""5/2""))
    assert_equal(false, candidate.call(""5/2"", ""3/5""))
    assert_equal(true, candidate.call(""2/4"", ""8/4""))
    assert_equal(true, candidate.call(""2/4"", ""4/2""))
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/5"", ""1/5""))
  end
end
"
HumanEval_145,plt_Latn,rb,"Ohatra: Alaharo araka ny index-ny ao amin'ny array voalohany izy ireo.Fanamarihana: raha misy laharana maromaro mitovy ny isa amin'ny tarehimarika, amin'ny fiakarana araka ny fitambaran'ny tarehimarika. Soraty ny fiasa izay mandamina ny laharana nomena ny isa manontolo # >>> order_by_points.call([1, 11, -1, -11, -12])
# [-1, -11, 1, -12, 11]
# >>> order_by_points.call([])
# []
def order_by_points(nums)
","def order_by_points(nums)
  nums.sort_by.with_index do |num, index|
    [num.to_s.chars.map(&:to_i).sum.abs, index]
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_order_by_points
    candidate = method(:order_by_points)
    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))
    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))
    assert_equal([], candidate.call([]))
    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))
    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))
    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))
  end
end
"
HumanEval_146,plt_Latn,rb,"Ohatra: ny isa voalohany sy farany dia tsy mitovy isa (1, 3, 5, 7, 9). ny isan'ny singa ao amin'ny array izay lehibe kokoa noho ny 10 sy ny roa Soraty ny fiasa izay mandray ny laharan'ny isa ho toy ny fidirana sy ny fiverenana # >>> specialFilter.call([15, -73, 14, -15])
# 1
# >>> specialFilter.call([33, -2, -3, 45, 21, 109])
# 2
def specialFilter(nums)
","def specialFilter(nums)
  nums.count do |num|
    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_specialFilter
    candidate = method(:specialFilter)
    assert_equal(0, candidate.call([5, -2, 1, -5]))
    assert_equal(1, candidate.call([15, -73, 14, -15]))
    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))
    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))
    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))
    assert_equal(0, candidate.call([1]))
    assert_equal(0, candidate.call([]))
  end
end
"
HumanEval_147,plt_Latn,rb,"Ohatra: ary a[i] + a[j] + a[k] dia in-3 . Avereno ny isan'ny telo (a[i], a[j], a[k]) ny a izay i < j < k, Ho an'ny tsirairay i (1 â‰¤ i â‰¤ n), ny sandan'ny a[i] = i * i - i + 1. Nomena isa iray n ianao. Tsy maintsy mamorona array iray a misy laharana n ianao.# >>> get_max_triples.call(5)
# 1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
def get_max_triples(n)
","def get_max_triples(n)
  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }
  count = 0
  
  (0...n).each do |i|
    (i+1...n).each do |j|
      (j+1...n).each do |k|
        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0
      end
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_max_triples
    candidate = method(:get_max_triples)
    assert_equal(1, candidate.call(5))
    assert_equal(4, candidate.call(6))
    assert_equal(36, candidate.call(10))
    assert_equal(53361, candidate.call(100))
  end
end
"
HumanEval_148,plt_Latn,rb,"Ohatra tsy anarana marina ho an'ny planeta.Tokony hamerina array foana ny fiasa raha planet1 na planet2 ny akaiky ny masoandro. eo anelanelan'ny lalan'ny planeta1 sy ny lalan'ny planeta2, voalamina araka ny Tokony hamerina ny laharana misy ny planeta rehetra izay ny orbitany dia Soraty ny fiasa izay mandray anarana planeta roa ho toy ny kofehy planet1 sy planet2. Uranus, Neptune. dia i Mercure, ny manaraka dia i VÃ©nus, avy eo ny Tany, Mars, Jupiter, Saturne, Misy planeta valo ao amin'ny rafi-masoandro misy antsika: ny akaiky indrindra ny Masoandro.# >>> bf.call(""Jupiter"", ""Neptune"")
# [""Saturn"", ""Uranus""]
# >>> bf.call(""Earth"", ""Mercury"")
# ""Venus""
# >>> bf.call(""Mercury"", ""Uranus"")
# [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
def bf(planet1, planet2)
","def bf(planet1, planet2)
  planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
  
  idx1 = planets.index(planet1)
  idx2 = planets.index(planet2)
  
  return [] if idx1.nil? || idx2.nil?

  start_idx, end_idx = [idx1, idx2].sort
  
  planets[(start_idx + 1)...end_idx]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_bf
    candidate = method(:bf)
    assert_equal([""Saturn"", ""Uranus""], candidate.call(""Jupiter"", ""Neptune""))
    assert_equal([""Venus""], candidate.call(""Earth"", ""Mercury""))
    assert_equal([""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""], candidate.call(""Mercury"", ""Uranus""))
    assert_equal([""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""], candidate.call(""Neptune"", ""Venus""))
    assert_equal([], candidate.call(""Earth"", ""Earth""))
    assert_equal([], candidate.call(""Mars"", ""Earth""))
    assert_equal([], candidate.call(""Jupiter"", ""Makemake""))
  end
end
"
HumanEval_149,plt_Latn,rb,"Ohatra: Mety hieritreritra ianao fa ho mitovy ny halavan'ny teny rehetra.Tokony hamerina ny laharan-dahatsoratra voarindra ny fiasa. Raha mitovy ny halavan'ny teny roa, dia amboary araka ny abidia ny tabilao. Tokony hamerina ny array voalahatra araka io fitsipika io. Tokony hiakatra araka ny halavan'ny teny tsirairay ny filaharan'ny tabilao, ary ianao ary mety misy dika mitovy. Ny array dia array misy tady foana fa tsy array misy isa, ary mamerina ny array vokany miaraka amin'ny baiko voalahatra, hamafana ireo kofehy izay manana halava tsy mitovy aminy, Soraty ny fiasa izay manaiky ny andian-tsipika ho toy ny masontsivana, # >>> list_sort.call([""aa"", ""a"", ""aaa""])
# [""aa""]
# >>> list_sort.call([""ab"", ""a"", ""aaa"", ""cd""])
# [""ab"", ""cd""]
def sorted_list_sum(lst)
","def list_sort(arr)
  arr.select { |s| s.length.even? }
     .sort_by { |s| [s.length, s] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sorted_list_sum
    candidate = method(:sorted_list_sum)
    assert_equal([""aa""], candidate.call([""aa"", ""a"", ""aaa""]))
    assert_equal([""AI"", ""asdf"", ""school""], candidate.call([""school"", ""AI"", ""asdf"", ""b""]))
    assert_equal([], candidate.call([""d"", ""b"", ""c"", ""a""]))
    assert_equal([""abcd"", ""dcba""], candidate.call([""d"", ""dcba"", ""abcd"", ""a""]))
    assert_equal([""AI"", ""ai"", ""au""], candidate.call([""AI"", ""ai"", ""au""]))
    assert_equal([], candidate.call([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]))
    assert_equal([""cc"", ""dd"", ""aaaa"", ""bbbb""], candidate.call([""aaaa"", ""bbbb"", ""dd"", ""cc""]))
  end
end
"
HumanEval_150,plt_Latn,rb,"Ohatra: isa voalohany ary tokony hamerina ny sandan'ny y raha tsy izany. Fandaharana tsotra izay tokony hamerina ny sandan'ny x raha n dia # >>> x_or_y.call(7, 34, 12)
# 34
# >>> x_or_y.call(15, 8, 5)
# 5
def x_or_y(n, x, y)
","def x_or_y(n, x, y)
  require 'prime'
  n.prime? ? x : y
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_x_or_y
    candidate = method(:x_or_y)
    assert_equal(34, candidate.call(7, 34, 12))
    assert_equal(5, candidate.call(15, 8, 5))
    assert_equal(33, candidate.call(3, 33, 5212))
    assert_equal(3, candidate.call(1259, 3, 52))
    assert_equal(-1, candidate.call(7919, -1, 12))
    assert_equal(583, candidate.call(3609, 1245, 583))
    assert_equal(129, candidate.call(91, 56, 129))
    assert_equal(1234, candidate.call(6, 34, 1234))
    assert_equal(0, candidate.call(1, 2, 0))
    assert_equal(2, candidate.call(2, 2, 0))
  end
end
"
HumanEval_151,plt_Latn,rb,"Tsy miraharaha ireo isa izay miiba na tsy isa feno.Nomena isa maromaro, avereno ny fitambaran'ny kianjan'ny isa # >>> double_the_difference.call([1, 3, 2, 0])
# 10
# >>> double_the_difference.call([-1, -2, 0])
# 0
# >>> double_the_difference.call([9, -2])
# 81
# >>> double_the_difference.call([0])
# 0
# If the input array is empty, return 0.
def double_the_difference(lst)
","def double_the_difference(lst)
  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }
     .map { |n| n ** 2 }
     .sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_double_the_difference
    candidate = method(:double_the_difference)
    assert_equal(0, candidate.call([]))
    assert_equal(25, candidate.call([5.0, 4.0]))
    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))
    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))
    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))
    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))
    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))
  end
end
"
HumanEval_152,plt_Latn,rb,"ohatra: ny sanda dia 0, ary raha tsy izany, ny sanda dia ny fahasamihafana tanteraka eo amin'ny vinavina sy ny isa. Miverena amina array mitovy halava izay manondro ny halaviran'ny vinavina tsirairay. Raha marina ny vinavinan'izy ireo, Nomena anao ny isa roa sy ny vinavina roa mitovy ny halavany, izay ahitana ny fitoviana ny index tsirairay. Ny asanao dia ny mamaritra raha nisy olona naminavina tsara ny vokatry ny lalao maromaro.Tena mendrika ny hanamarihana sy hampitahana izany. Ny fihetseham-po sy ny eritreritrao amin'io fotoana io dia Heveriko fa tsaroantsika rehetra io fahatsapana io rehefa ny vokatry ny zavatra nandrasana hatry ny ela# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
# [0, 0, 0, 0, 3, 3]
# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
# [4, 4, 1, 0, 0, 6]
def compare(game, guess)
","def compare(game, guess)
  game.zip(guess).map { |score, prediction| (score - prediction).abs }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare
    candidate = method(:compare)
    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))
    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))
    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))
    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))
  end
end
"
HumanEval_153,plt_Latn,rb,"Ohatra: (ny tanjaky ny -1).miverina 'Slices.SErviNGSliCes' satria 'SErviNGSliCes' no fanitarana matanjaka indrindra fanitarana: ['SErviNGSliCes', 'Cheese', 'StuFfed'] dia tokony Ohatra, raha nomena ""Slices"" ho toy ny kilasy sy ny array ny safidio izay voalohany ao amin'ny array.Raha misy roa na mihoatra ny fanitarana mitovy hery, dia tokony endrika: Anaran'ny kilasy. Anaran'ny fanitarana matanjaka indrindra. Tokony ho hitanao ny fanitarana matanjaka indrindra ary avereno ny tadiny ao anatin'io ao amin'ny anaran'ny fanitarana, ny hery dia omena amin'ny ampahany CAP - SM. litera ao amin'ny anaran'ny fanitarana, ary aoka ny SM ho ny isan'ny litera kely Ny tanjaky ny fanitarana dia toy izao manaraka izao: Aoka ny CAP ho ny isa amin'ny litera lehibe Ny fanitarana dia ampiasaina mba hampidiran'ny kilasy fanampiny ho an'ny kilasy.Homena anarana kilasy (tsipika) sy fanitarana maromaro ianao.# >>> Strongest_Extension.call(""my_class"", [""AA"", ""Be"", ""CC""])
# ""my_class.AA""
def Strongest_Extension(class_name, extensions)
","def Strongest_Extension(class_name, extensions)
  strongest_extension = extensions.max_by do |extension|
    cap_count = extension.count('A-Z')
    sm_count = extension.count('a-z')
    cap_count - sm_count
  end
  ""#{class_name}.#{strongest_extension}""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_Strongest_Extension
    candidate = method(:Strongest_Extension)
    assert_equal(""Watashi.eIGHt8OKe"", candidate.call(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]))
    assert_equal(""Boku123.YEs.WeCaNe"", candidate.call(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]))
    assert_equal(""__YESIMHERE.NuLl__"", candidate.call(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]))
    assert_equal(""K.TAR"", candidate.call(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]))
    assert_equal(""__HAHA.123"", candidate.call(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]))
    assert_equal(""YameRore.okIWILL123"", candidate.call(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]))
    assert_equal(""finNNalLLly.WoW"", candidate.call(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]))
    assert_equal(""_.Bb"", candidate.call(""_"", [""Bb"", ""91245""]))
    assert_equal(""Sp.671235"", candidate.call(""Sp"", [""671235"", ""Bb""]))
  end
end
"
HumanEval_154,plt_Latn,rb,"Nomena teny roa ianao. Mila mamerina ny marina ianao raha toa ka ny teny faharoa na ny iray amin'ireo fihodinana dia singa ao amin'ny teny voalohany # >>> cycpattern_check.call(""abcd"", ""abd"")
# false
# >>> cycpattern_check.call(""hello"", ""ell"")
# true
# >>> cycpattern_check.call(""whassup"", ""psus"")
# false
# >>> cycpattern_check.call(""abab"", ""baa"")
# true
# >>> cycpattern_check.call(""efef"", ""eeff"")
# false
# >>> cycpattern_check.call(""himenss"", ""simen"")
# true
def cycpattern_check(a, b)
","def cycpattern_check(a, b)
  (0...b.length).each do |i|
    rotated_b = b[i..-1] + b[0...i]
    return true if a.include?(rotated_b)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_cycpattern_check
    candidate = method(:cycpattern_check)
    assert_equal(false, candidate.call(""xyzw"", ""xyw""))
    assert_equal(true, candidate.call(""yello"", ""ell""))
    assert_equal(false, candidate.call(""whattup"", ""ptut""))
    assert_equal(true, candidate.call(""efef"", ""fee""))
    assert_equal(false, candidate.call(""abab"", ""aabb""))
    assert_equal(true, candidate.call(""winemtt"", ""tinem""))
  end
end
"
HumanEval_155,plt_Latn,rb,"Ohatra: Raha nomena isa iray manontolo. mamerina array izay manana isa isa sy isa isa tsirairay avy. # >>> even_odd_count.call(-12)
# [1, 1]
# >>> even_odd_count.call(123)
# [1, 2]
def even_odd_count(num)
","def even_odd_count(num)
  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_count
    candidate = method(:even_odd_count)
    assert_equal([0, 1], candidate.call(7))
    assert_equal([1, 1], candidate.call(-78))
    assert_equal([2, 2], candidate.call(3452))
    assert_equal([3, 3], candidate.call(346211))
    assert_equal([3, 3], candidate.call(-345821))
    assert_equal([1, 0], candidate.call(-2))
    assert_equal([2, 3], candidate.call(-45347))
    assert_equal([1, 0], candidate.call(0))
  end
end
"
HumanEval_156,plt_Latn,rb,"Ohatra: Ferana: 1 <= isa <= 1000 ary avereno amin'ny litera kely izany. Raha nomena isa iray manontolo miampy, alao ny isa romanina mitovy aminy ho toy ny tady, # >>> int_to_mini_roman.call(19)
# ""xix""
# >>> int_to_mini_roman.call(152)
# ""clii""
# >>> int_to_mini_roman.call(426)
# ""cdxxvi""
def int_to_mini_roman(number)
","def int_to_mini_roman(number)
  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']

  result = ''
  values.each_with_index do |value, index|
    while number >= value
      number -= value
      result += numerals[index]
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_int_to_mini_roman
    candidate = method(:int_to_mini_roman)
    assert_equal(""xix"", candidate.call(19))
    assert_equal(""clii"", candidate.call(152))
    assert_equal(""ccli"", candidate.call(251))
    assert_equal(""cdxxvi"", candidate.call(426))
    assert_equal(""d"", candidate.call(500))
    assert_equal(""i"", candidate.call(1))
    assert_equal(""iv"", candidate.call(4))
    assert_equal(""xliii"", candidate.call(43))
    assert_equal(""xc"", candidate.call(90))
    assert_equal(""xciv"", candidate.call(94))
    assert_equal(""dxxxii"", candidate.call(532))
    assert_equal(""cm"", candidate.call(900))
    assert_equal(""cmxciv"", candidate.call(994))
    assert_equal(""m"", candidate.call(1000))
  end
end
"
HumanEval_157,plt_Latn,rb,"Ohatra: 90 degre. Ny telozoro mahitsy dia telozoro izay ny zoro iray dia mahitsy na Manao telozoro mahitsy ny sisiny, raha tsy izany dia diso.Raha jerena ny halavan'ny lafiny telo amin'ny telozoro iray. avereno marina raha toa ka telo # >>> right_angle_triangle.call(3, 4, 5)
# true
# >>> right_angle_triangle.call(1, 2, 3)
# false
def right_angle_triangle(a, b, c)
","def right_angle_triangle(a, b, c)
  sides = [a, b, c].sort
  sides[0]**2 + sides[1]**2 == sides[2]**2
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_right_angle_triangle
    candidate = method(:right_angle_triangle)
    assert_equal(true, candidate.call(3, 4, 5))
    assert_equal(false, candidate.call(1, 2, 3))
    assert_equal(true, candidate.call(10, 6, 8))
    assert_equal(false, candidate.call(2, 2, 2))
    assert_equal(true, candidate.call(7, 24, 25))
    assert_equal(false, candidate.call(10, 5, 7))
    assert_equal(true, candidate.call(5, 12, 13))
    assert_equal(true, candidate.call(15, 8, 17))
    assert_equal(true, candidate.call(48, 55, 73))
    assert_equal(false, candidate.call(1, 1, 1))
    assert_equal(false, candidate.call(2, 2, 10))
  end
end
"
HumanEval_158,plt_Latn,rb,"ny litera, miverena izay voalohany amin'ny filaharana lexicographique. Raha misy andian-dahatsoratra maromaro dia manana tarehin-tsoratra tokana Ny array dia misy teny samihafa. Avereno ny teny miaraka amin'ny isa ambony indrindra Soraty ny fiasa izay manaiky ny andian-tsipika. # >>> find_max.call([""name"", ""of"", ""string""])
# ""string""
# >>> find_max.call([""name"", ""enam"", ""game""])
# ""enam""
# >>> find_max.call([""aaaaaaa"", ""bb"", ""cc""])
# ""aaaaaaa""
def find_max(words)
","def find_max(words)
  # Helper function to count unique characters
  def unique_char_count(word)
    word.chars.uniq.size
  end

  words.max_by { |word| [unique_char_count(word), -word] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_max
    candidate = method(:find_max)
    assert_equal(""string"", candidate.call([""name"", ""of"", ""string""]))
    assert_equal(""enam"", candidate.call([""name"", ""enam"", ""game""]))
    assert_equal(""aaaaaaa"", candidate.call([""aaaaaaa"", ""bb"", ""cc""]))
    assert_equal(""abc"", candidate.call([""abc"", ""cba""]))
    assert_equal(""footbott"", candidate.call([""play"", ""this"", ""game"", ""of"", ""footbott""]))
    assert_equal(""gonna"", candidate.call([""we"", ""are"", ""gonna"", ""rock""]))
    assert_equal(""nation"", candidate.call([""we"", ""are"", ""a"", ""mad"", ""nation""]))
    assert_equal(""this"", candidate.call([""this"", ""is"", ""a"", ""prrk""]))
    assert_equal(""b"", candidate.call([""b""]))
    assert_equal(""play"", candidate.call([""play"", ""play"", ""play""]))
  end
end
"
HumanEval_159,plt_Latn,rb,"Ohatra: Raha tsy ampy ny karaoty sisa tavela, dia hohaninao daholo ny karaoty sisa tavela, nefa mbola ho noana ihany ianao. ny isan'ny karaoty sisa tavela aorian'ny sakafo ] Tokony hamerina ny [ isa totalin'ny karaoty nohaninao taorian'ny sakafo ianao, Mila mihinana karaoty bebe kokoa anefa ianao izao mba hahavitana ny sakafo isan'andro.Zanak'omby noana ianao, ary efa nihinana karaoty maromaro, # >>> eat.call(5, 6, 10)
# [11, 4]
# >>> eat.call(4, 8, 9)
# [12, 1]
# >>> eat.call(1, 10, 10)
# [11, 0]
# >>> eat.call(2, 11, 5)
# [7, 0]
# Variables:
# @number : integer
# the number of carrots that you have eaten.
# @need : integer
# the number of carrots that you need to eat.
# @remaining : integer
# the number of remaining carrots thet exist in stock
# Constrain:
# * 0 <= number <= 1000
# * 0 <= need <= 1000
# * 0 <= remaining <= 1000
# Have fun :)
def eat(number, need, remaining)
","def eat(number, need, remaining)
  total_eaten = number + [need, remaining].min
  carrots_left = [remaining - need, 0].max
  [total_eaten, carrots_left]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_eat
    candidate = method(:eat)
    assert_equal([11, 4], candidate.call(5, 6, 10))
    assert_equal([12, 1], candidate.call(4, 8, 9))
    assert_equal([11, 0], candidate.call(1, 10, 10))
    assert_equal([7, 0], candidate.call(2, 11, 5))
    assert_equal([9, 2], candidate.call(4, 5, 7))
    assert_equal([5, 0], candidate.call(4, 5, 1))
  end
end
"
HumanEval_160,plt_Latn,rb,"Ny laharan'ny mpandraharaha dia manana mpandraharaha iray farafahakeliny, ary ny laharan'ny operand dia manana operand roa farafahakeliny.Ny operand dia array misy integer tsy miiba.Ny halavan'ny mpandraharaha array dia mitovy amin'ny halavan'ny operand array iray miiba. Fanamarihana: => vokatra = 9 vokatra = 2 + 3 * 4 - 5 array = [2, 3, 4, 5] mpandraharaha['+', '*', '-'] Ohatra: Fampitomboana (**) Fizarana rihana ( //) Fandrefesana ( *) Fihenam-bidy ( - ) Fanampiny ( +) Ny asa algebra fototra: Fanehoana ary miverina ny fanombanana io teny. Ny array faharoa dia array iray misy integer. Ampiasao ireo array roa nomena hananganana ny algebra Raha nomena mpandraharaha roa, sy operand, ny array voalohany dia manana asa algebra fototra, ary def do_algebra(operator, operand)
","def do_algebra(operator, operand)
  expression = operand[0].to_s
  operator.each_with_index do |op, index|
    if op == '//'
      expression += ' / ' + operand[index + 1].to_s
    else
      expression += ' ' + op + ' ' + operand[index + 1].to_s
    end
  end
  eval(expression)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_do_algebra
    candidate = method(:do_algebra)
    assert_equal(37, candidate.call([""**"", ""*"", ""+""], [2, 3, 4, 5]))
    assert_equal(9, candidate.call([""+"", ""*"", ""-""], [2, 3, 4, 5]))
    assert_equal(8, candidate.call([""//"", ""*""], [7, 3, 4]))
  end
end
"
HumanEval_161,plt_Latn,rb,"Ohatra Tokony hamerina ny tadiny ny asa. Raha tsy misy litera ny tadiny, avereno ny tadiny.Raha tsy izany dia tazomy toy izao. raha litera ny s[i], avereno ny endriny avy any ambany mankany ambony na ny mifanohitra amin'izany, Nomena tsipika s ianao. # >>> solve.call(""1234"")
# ""4321""
# >>> solve.call(""ab"")
# ""AB""
# >>> solve.call(""#a@C"")
# ""#A@c""
def solve(s)
","def solve(s)
  if s =~ /[a-zA-Z]/
    s.chars.map { |char| char =~ /[a-zA-Z]/ ? char.swapcase : char }.join
  else
    s.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""aSdF"", candidate.call(""AsDf""))
    assert_equal(""4321"", candidate.call(""1234""))
    assert_equal(""AB"", candidate.call(""ab""))
    assert_equal(""#A@c"", candidate.call(""#a@C""))
    assert_equal(""#aSDFw^45"", candidate.call(""#AsdfW^45""))
    assert_equal(""2@6#"", candidate.call(""#6@2""))
    assert_equal(""#$A^d"", candidate.call(""#$a^D""))
    assert_equal(""#CCC"", candidate.call(""#ccc""))
  end
end
"
HumanEval_162,plt_Latn,rb,"Raha 'text' dia andalana tsy misy dikany, miverina nil. Raha nomena ny 'text' ny tadiny, avereno ny tadiny mitovy amin'ny md5 hash. # >>> string_to_md5.call(""Hello world"")
# ""3e25960a79dbc69b674cd4ec67a72c62""
def string_to_md5(text)
","require 'digest'

def string_to_md5(text)
  return nil if text.empty?
  Digest::MD5.hexdigest(text)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_to_md5
    candidate = method(:string_to_md5)
    assert_equal(""3e25960a79dbc69b674cd4ec67a72c62"", candidate.call(""Hello world""))
    assert_equal(nil, candidate.call(""""))
    assert_equal(""0ef78513b0cb8cef12743f5aeb35f888"", candidate.call(""A B C""))
    assert_equal(""5f4dcc3b5aa765d61d8327deb882cf99"", candidate.call(""password""))
  end
end
"
HumanEval_163,plt_Latn,rb,"Ohatra: ary b, miakatra ny laharana. Raha nomena isa roa a sy b, avereno ny isa roa eo anelanelan'ny a sy b.# >>> generate_integers.call(2, 8)
# [2, 4, 6, 8]
# >>> generate_integers.call(8, 2)
# [2, 4, 6, 8]
# >>> generate_integers.call(10, 14)
# []
def generate_integers(a, b)
","def generate_integers(a, b)
  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_generate_integers
    candidate = method(:generate_integers)
    assert_equal([2, 4, 6, 8], candidate.call(2, 10))
    assert_equal([2, 4, 6, 8], candidate.call(10, 2))
    assert_equal([2, 4, 6, 8], candidate.call(132, 2))
    assert_equal([], candidate.call(17, 89))
  end
end
"
