task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,taq_Tfng,rb,"ⴰⴱⴰⵔⴰⵣ ⵏ ⵓⵙⵙⵉⵔⴰⵔⵣⵣⵓ ⴳ ⵡⴰⵏⵙⴰ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵀⴰⵜ ⵉⵍⵍⴰ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⵉⵏ ⵢⵓⵙⴰⵏ ⵉⵏⴳⵔⵙⵏ ⵓⴳⴳⴰⵔ ⵏ # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)
# false
# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
# true
def has_close_elements(numbers, threshold)
","def has_close_elements(numbers, threshold)
  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_has_close_elements
    candidate = method(:has_close_elements)
    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))
    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))
    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))
    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))
    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))
    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))
    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))
  end
end
"
HumanEval_1,taq_Tfng,rb,"ⵔⵥⵎ ⴽⵔⴰ ⵏ ⵡⴰⵏⵙⴰ ⴳ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ.ⵜⴰⵔⵓⴱⴱⴰ ⵉⴱⴹⴰⵏ ⵜⵜⵓⵙⵎⵙⴰⵙⴰⵏ (ⵢⴰⵜⵜⵓⵢ ⵏ ⴽⵓ ⵜⴰⴱⵔⴰⵜⴰ ⵉⵕⵥⵎⵏ ⵉⵜⵜⵓⵙⵎⵓⵏ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵅⵚⵚⴰⵏ) ⴷ ⵓⵔ ⵜⵜⵓⵙⵎⵓⵏ ⴳ ⵢⴰⵏ ⵔⴱⴹⵓ ⵏ ⵜⵔⴰⴱⴱⵓⵜ ⴰⴷ ⵖⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵥⵍⵉⵏ ⴷ ⵓⵙⵡⴰⵍⴰ ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵉⵏⵏⴰ.ⴷⴰ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵓⵡⵡⵓⵔ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⵉⴼⵔⴽⵜ ⴳ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⵉⵜⵜⵓⵙⵎⵓⵏⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ # >>> separate_paren_groups.call(""( ) (( )) (( )( ))"")
# [""()"", ""(())"", ""(()())""]
def separate_paren_groups(paren_string)
","def separate_paren_groups(paren_string)
  # Remove spaces from the string
  paren_string = paren_string.gsub("" "", """")
  
  result = []
  current_group = """"
  balance = 0

  paren_string.each_char do |char|
    current_group += char
    balance += 1 if char == '('
    balance -= 1 if char == ')'

    if balance == 0 && !current_group.empty?
      result << current_group
      current_group = """"
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_separate_paren_groups
    candidate = method(:separate_paren_groups)
    assert_equal([""(()())"", ""((()))"", ""()"", ""((())()())""], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([""()"", ""(())"", ""((()))"", ""(((())))""], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([""(()(())((())))""], candidate.call(""(()(())((())))""))
    assert_equal([""()"", ""(())"", ""(()())""], candidate.call(""( ) (( )) (( )( ))""))
  end
end
"
HumanEval_2,taq_Tfng,rb,"ⵔⵉⵜⵓⵔ ⵏ ⵓⴳⵣⵣⵓⵎ ⴰⵎⵔⴰⵡ ⵏ ⵡⵓⵟⵟⵓⵏ.(ⴰⵛⵔⵓⵜ ⵏ ⵓⵛⵔⴰⵉ ⴰⵀⴰ ⵉⴳⴰ ⴰⵎⵥⵥⵢⴰⵏ ⵙⴳ 1).ⴷ ⵓⴳⵣⵣⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ (ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ ⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵔⴰⵡⵏ ⵉⵖ ⵏⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ, ⵏⵣⵎⵔ ⴰⴷ ⵏⵙⴱⴹ # >>> truncate_number.call(3.5)
# 0.5
def truncate_number(number)
","def truncate_number(number)
  number - number.to_i
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_truncate_number
    candidate = method(:truncate_number)
    assert_equal(0.5, candidate.call(3.5))
    assert_equal(0.25, candidate.call(1.25))
    assert_equal(0.0, candidate.call(123.0))
  end
end
"
HumanEval_3,taq_Tfng,rb,"ⴳ ⵜⵏⵇⵇⵉⴹⵜ ⴰⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵎⵔⵙⵜ ⵜⵉⴷⵜ. ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵉⴷⵜ.ⴰⵛⴰⵍ ⵓⴰⵏ ⵏⴻⴱⵓⵍⴰⵜⴻ ⵜⴰⵏ ⵓⵉⵏ ⴰⴾⴰⵍ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⴻⵜ ⴰⵂⴰⵏⴰⵜ ⴰⵙⵉⴾⵏⴻ ⵏ ⴰⵙⵉⴾⵏⴻ ⵏ ⴰⴾⴰⵍ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜⴷⴰ ⵜⵜⵓⴼⴽⴰ ⴽⵉⴳⴰⵏ ⵏ ⵜⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵓⵙⵙⴰⵔⵓ ⴷ ⵓⵙⵙⴰⵢ ⴳ ⵓⵙⵙⵉⴹⵏ ⵏ ⵍⴱⴰⵏⴽ ⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ # >>> below_zero.call([1, 2, 3])
# false
# >>> below_zero.call([1, 2, -4, 5])
# true
def below_zero(operations)
","def below_zero(operations)
  balance = 0
  operations.each do |operation|
    balance += operation
    return true if balance < 0
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_zero
    candidate = method(:below_zero)
    assert_equal(false, candidate.call([]))
    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))
    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))
    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))
    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))
    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))
  end
end
"
HumanEval_4,taq_Tfng,rb,"MAD=ⴰⵎⵎⴰⵜⵜⴰⵢ. x - x_ⵎⵉⵏ.ⴰⵛⵔⵓⵜ ⴷ ⵜⵉⵜⴱⴰⵈⴻⵜ ⵜⴰⵏ ⴰⵎⵎⴰⵙ (ⴰⵎⴰⵣⴰⵔⴰⵏ ⴷⴰⵗ ⴰⵍⵓⴰⵈ ⵓⴻⵏ):ⴰⵎⵣⴰⵔⴰⵢ ⵏ ⵓⵖⵣⵓⵔⴰⵏ ⴰⵎⵏⵉⴳ ⵉⴳⴰ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ ⴳⵔ ⴽⵓ ⴰⵂⴰⵏⴷⴰⴶ ⵏ ⴰⵎⵎⴰⵙ ⵏ ⴷⴰⵜⴰ ⵙⵢⵜ ⵓⵢⵏⵉ ⵓⵎⵙⴳⵔⴰⵡ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵙⴽⵛⵛⵓⵎⵏ, ⵙⵙⵓⴷⵙ ⴰⵎⵏⵣⴰⵢ ⴰⵖⴰⵔⴰⵏ # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])
# 1.0
def mean_absolute_deviation(numbers)
","def mean_absolute_deviation(numbers)
  mean = numbers.sum.to_f / numbers.size
  deviations = numbers.map { |num| (num - mean).abs }
  deviations.sum / numbers.size
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_mean_absolute_deviation
    candidate = method(:mean_absolute_deviation)
    assert_equal(0.5, candidate.call([1.0, 2.0]))
    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))
    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
  end
end
"
HumanEval_5,taq_Tfng,rb,"""ⴰⴷ ⵢⴰⵛ ⵓⵟⵟⵓⵏ "" ⴷⵓⵍⵉⵎⵉⵜⵔ "" ⴳⵔ ⴽⵓ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴷⴰⵢⵏ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⵙⴽⵛⵎ "" `numbers"" # >>> intersperse.call([], 4)
# []
# >>> intersperse.call([1, 2, 3], 4)
# [1, 4, 2, 4, 3]
def intersperse(numbers, delimeter)
","def intersperse(numbers, delimeter)
  return numbers if numbers.empty?
  result = []
  numbers.each_with_index do |num, index|
    result << num
    result << delimeter unless index == numbers.size - 1
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersperse
    candidate = method(:intersperse)
    assert_equal([], candidate.call([], 7))
    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))
    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))
  end
end
"
HumanEval_6,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ (() (()) ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⴳ ⵜⵉⵣⵉ ⵏⵏⴰ ⴳ ⵖⵓⵔ ((())) ⴽⵕⴰⴹ. ⵉ ⴽⵓ ⵜⴰⵔⴰⴱⴱⵓⵜ, ⵙⵏⵓⵍⴼⵓ ⴰⵙⵡⵉⵔ ⵏ ⵓⴱⵔⴰⵏⵜⵉⵙ ⵉⴳⴳⵓⵜⵏ.ⴷⴰ ⵉⵜⵜⵓⵙⴽⴰⵔ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵙ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵉ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ ⵉⵜⵜⵓⵙⴱⴹⴰⵏ ⵙ ⵉⵎⵣⴰⵔⴰⵢⵏ.# >>> parse_nested_parens.call(""(()()) ((())) () ((())()())"")
# [2, 3, 1, 3]
def parse_nested_parens(paren_string)
","def parse_nested_parens(paren_string)
  paren_string.split.map do |group|
    max_depth = current_depth = 0
    group.chars.each do |char|
      if char == '('
        current_depth += 1
        max_depth = [max_depth, current_depth].max
      elsif char == ')'
        current_depth -= 1
      end
    end
    max_depth
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_nested_parens
    candidate = method(:parse_nested_parens)
    assert_equal([2, 3, 1, 3], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([1, 2, 3, 4], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([4], candidate.call(""(()(())((())))""))
  end
end
"
HumanEval_7,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⵓⵙⴼⵉⵍⵍ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵜⵉⴼⵉⵏⴰⵖ # >>> filter_by_substring.call([], ""a"")
# []
# >>> filter_by_substring.call([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
# [""abc"", ""bacd"", ""array""]
def filter_by_substring(strings, substring)
","def filter_by_substring(strings, substring)
  strings.select { |string| string.include?(substring) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_substring
    candidate = method(:filter_by_substring)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
    assert_equal([""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""))
    assert_equal([""grunt"", ""prune""], candidate.call([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""))
  end
end
"
HumanEval_8,taq_Tfng,rb,"ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵎⴹⴰⵏ ⵏ ⵓⴽⵙⵓⵎ ⴰⵣⴳⵏ ⴷ ⵓⵎⴹⴰⵏ ⵏ ⵓⴽⵙⵓⵎ ⴰⵣⴳⵏ ⴷ 1.ⵉ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵖⵣⵓⵔ ⴷ ⵓⵙⴼⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⵙⵍ.# >>> sum_product.call([])
# [0, 1]
# >>> sum_product.call([1, 2, 3, 4])
# [10, 24]
def sum_product(numbers)
","def sum_product(numbers)
  sum = numbers.reduce(0, :+)
  product = numbers.reduce(1, :*)
  [sum, product]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_product
    candidate = method(:sum_product)
    assert_equal([0, 1], candidate.call([]))
    assert_equal([3, 1], candidate.call([1, 1, 1]))
    assert_equal([100, 0], candidate.call([100, 0]))
    assert_equal([15, 105], candidate.call([3, 5, 7]))
    assert_equal([10, 10], candidate.call([10]))
  end
end
"
HumanEval_9,taq_Tfng,rb,"ⴳ ⵓⴹⴼⴼⵉⵕ.ⵙⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴰⵎⵙⴳⵏⴰⴼ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵇⵇⵓⵔⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴰⵔ ⵜⵉⵣⵉ ⵏⵏⴰ ⵉⵜⵜⵢⴰⴼⴰⵏ # >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])
# [1, 2, 3, 3, 3, 4, 4]
def rolling_max(numbers)
","def rolling_max(numbers)
  max_so_far = numbers.first
  numbers.map do |num|
    max_so_far = [max_so_far, num].max
  end
end

# Example usage:
# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rolling_max
    candidate = method(:rolling_max)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))
    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))
  end
end
"
HumanEval_10,taq_Tfng,rb,"- ⴰⴷ ⵢⴰⵣⴰⵔ ⵙ ⵜⴳⵉⵔⴰ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵜⵣⵡⴰⵔⵜ ⵏⵏⴰ ⵉⵜⵜⴰⴷⴼⵏ ⴷⴰⵜ ⵏ ⵓⴷⴼⵍ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ.- ⴰⵔⴰⵎ ⴰⴷ ⵏⴰⴼ ⵜⵉⵣⵉ ⵜⴰⵖⵣⵉⴼⵜ ⵏ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ.ⵜⴰⵡⵏⴳⵉⵎⵜ ⵏ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵜⴳⴰ ⵜⴰⴼⵔⴰⵔⵜ: ⴹⴼⵔ ⴰⵎⵣⵔⵓⵢ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵜⵉⴼⵉⵏⴰⵖ.# >>> make_palindrome.call("""")
# """"
# >>> make_palindrome.call(""cat"")
# ""catac""
# >>> make_palindrome.call(""cata"")
# ""catac""
def make_palindrome(string)
","def make_palindrome(string)
  return string if string.empty?

  def is_palindrome?(s)
    s == s.reverse
  end

  (0...string.length).reverse_each do |i|
    if is_palindrome?(string[i..-1])
      return string + string[0...i].reverse
    end
  end

  string
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_palindrome
    candidate = method(:make_palindrome)
    assert_equal("""", candidate.call(""""))
    assert_equal(""x"", candidate.call(""x""))
    assert_equal(""xyzyx"", candidate.call(""xyz""))
    assert_equal(""xyx"", candidate.call(""xyx""))
    assert_equal(""jerryrrej"", candidate.call(""jerry""))
  end
end
"
HumanEval_11,taq_Tfng,rb,"ⴷⴰ ⵏⵙⴽⴰⵔ XOR ⴱⵉⵏⴰⵔⵉ ⵅⴼ ⵉⵙⴽⵛⵛⵓⵎⵏ ⴰⴷ ⴷ ⴷⴰ ⵏⵙⴽⵛⵎ ⵜⴰⵢⴰⴼⵓⵜ ⴰⵡⴷ ⵙ ⵜⴰⵍⵖⴰ.ⴳⴰⵏ ⵉⵏⴽⵛⵛⵓⵎⵏ ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ a ⴷ b ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ 1 ⴷ 0 ⵅⵙ.# >>> string_xor.call(""010"", ""110"")
# ""100""
def string_xor(a, b)
","def string_xor(a, b)
  result = """"
  a.length.times do |i|
    result << (a[i] == b[i] ? ""0"" : ""1"")
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_xor
    candidate = method(:string_xor)
    assert_equal(""010010"", candidate.call(""111000"", ""101010""))
    assert_equal(""0"", candidate.call(""1"", ""1""))
    assert_equal(""0101"", candidate.call(""0101"", ""0000""))
  end
end
"
HumanEval_12,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ nil ⴳ ⵡⴰⴷⴷⴰⴷ ⵏⵏⴰ ⴳ ⵓⵔ ⵉⵍⵍⵉ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⴽⵛⵛⵓⵎ.ⵙⴳ ⵓⵎⵙⴰⵙⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⴽⵔ ⵜⵉⵣⵉ ⵜⴰⵖⴰⵔⴰⵏⵜ. ⵙⴽⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⴽⵉⴳⴰⵏ ⵏ # >>> longest.call([])
# nil
# >>> longest.call([""a"", ""b"", ""c""])
# ""a""
# >>> longest.call([""a"", ""bb"", ""ccc""])
# ""ccc""
def longest(strings)
","def longest(strings)
  return nil if strings.empty?
  strings.max_by(&:length)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_longest
    candidate = method(:longest)
    assert_equal(nil, candidate.call([]))
    assert_equal(""x"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""zzzz"", candidate.call([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]))
  end
end
"
HumanEval_13,taq_Tfng,rb,"ⵔⵉⵜⵓⵔⵏ ⴰⵎⵟⵟⵓ ⴰⵎⵛⵛⵓⵔⴰⵔ ⴰⵎⵇⵔⴰⵏ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b # >>> greatest_common_divisor.call(3, 5)
# 1
# >>> greatest_common_divisor.call(25, 15)
# 5
def greatest_common_divisor(a, b)
","def greatest_common_divisor(a, b)
  while b != 0
    a, b = b, a % b
  end
  a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_greatest_common_divisor
    candidate = method(:greatest_common_divisor)
    assert_equal(1, candidate.call(3, 7))
    assert_equal(5, candidate.call(10, 15))
    assert_equal(7, candidate.call(49, 14))
    assert_equal(12, candidate.call(144, 60))
  end
end
"
HumanEval_14,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵏⴼⴰⵔⵏ ⵙⴳ ⵓⵥⵥⵉⴹⵕ ⴰⵔ ⵓⵣⵣⵓⵣⵔ ⵏ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ # >>> all_prefixes.call(""abc"")
# [""a"", ""ab"", ""abc""]
def all_prefixes(string)
","def all_prefixes(string)
  (1..string.length).map { |i| string[0, i] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_all_prefixes
    candidate = method(:all_prefixes)
    assert_equal([], candidate.call(""""))
    assert_equal([""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""], candidate.call(""asdfgh""))
    assert_equal([""W"", ""WW"", ""WWW""], candidate.call(""WWW""))
  end
end
"
HumanEval_15,taq_Tfng,rb,"ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⴳ ⵓⵎⵣⵡⴰⵔⵓ ⵙⴳ 0 ⴰⵔ n.# >>> string_sequence.call(0)
# ""0""
# >>> string_sequence.call(5)
# ""0 1 2 3 4 5""
def string_sequence(n)
","def string_sequence(n)
  (0..n).to_a.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_sequence
    candidate = method(:string_sequence)
    assert_equal(""0"", candidate.call(0))
    assert_equal(""0 1 2 3"", candidate.call(3))
    assert_equal(""0 1 2 3 4 5 6 7 8 9 10"", candidate.call(10))
  end
end
"
HumanEval_16,taq_Tfng,rb,"ⴹⴰⵗ ⵜⴰⵔⵔⴰⵉⵜ, ⵙⴰⴾⵏⵢⴷ ⵉⵎⵎⵉⴾ ⵓⴰ ⵙ ⵉⵋⵋⴰ # >>> count_distinct_characters.call(""xyzXYZ"")
# 3
# >>> count_distinct_characters.call(""Jerry"")
# 4
def count_distinct_characters(string)
","def count_distinct_characters(string)
  string.downcase.chars.uniq.count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_distinct_characters
    candidate = method(:count_distinct_characters)
    assert_equal(0, candidate.call(""""))
    assert_equal(5, candidate.call(""abcde""))
    assert_equal(5, candidate.call(""abcdecadeCADE""))
    assert_equal(1, candidate.call(""aaaaAAAAaaaa""))
    assert_equal(5, candidate.call(""Jerry jERRY JeRRRY""))
  end
end
"
HumanEval_17,taq_Tfng,rb,"""ⵂⴰⵛⴻ"" - ⴰⴾⴰⵜⴰⴱ ⵏ ⴰⴾⴾⵓⵣ, ⵉⴾⴾⴰ ⵜⴰⴾⴾⴰⵛⵜ""oⴰⵙⵂⴰⴾⵉ"" - ⴰⵛⵂⵔⵓⵜ ⵏ ⵏⵓⵜⵢ, ⵉⴾⴾⴰⵏ ⵙⴰⵏⴰⵜⴰⵜ ⵉⴾⵉⴰⵏ""o"" - ⴰⴾⴰⵜⴰⴱ ⴰⴾⴾⴰⵔⴰⵏ, ⵉⴾⴾⴰⵓⴰⵏ ⴰⴾⴾⵓⵣ ⴾⴰⵍⴰ ⵉⵍⴰⵏ ⴰⵍⴰⵗⵉ:ⵓⴰⵔ ⵢⵈⵢⵍ ⵓⴰ ⵢⵔⴰⵓⴰⵏ.ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴼⵙⵉ ⵜⴰⵡⴰⵍⵜ ⴰⴷ ⴷ ⴰⴷ ⵜⵙⴽⵔ ⴰⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴽⵙⵙⵉ ⵏ ⴽⵓ ⵜⴰⵡⴰⵍⵜ.ⴷⴰ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵓⵏⴰⵎⴽ ⴰⴷ ⵙ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵉ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵓⵥⴰⵡⴰⵏ ⵙ ⵜⵍⵖⴰ ⵉⵥⵍⵉⵏ ⵏ ASCII.# >>> parse_music.call(""o o| .| o| o| .| .| .| .| o o"")
# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
def parse_music(music_string)
","def parse_music(music_string)
  # Split the input string into individual notes.
  notes = music_string.split

  # Map each note to its corresponding number of beats.
  notes.map do |note|
    case note
    when 'o'
      4
    when 'o|'
      2
    when '.|'
      1
    else
      0
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_music
    candidate = method(:parse_music)
    assert_equal([], candidate.call(""""))
    assert_equal([4, 4, 4, 4], candidate.call(""o o o o""))
    assert_equal([1, 1, 1, 1], candidate.call("".| .| .| .|""))
    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(""o| o| .| .| o o o o""))
    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(""o| .| o| .| o o| o o|""))
  end
end
"
HumanEval_18,taq_Tfng,rb,"ⵔⵎⵙⵏ ⵎⵏⵏⴰⵡⵜ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵖⵢ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⴽⴽⵉⵍ ⴰⵎⵏⴹⴰⵡ ⴳ ⵜⴽⵔⵔⴰⵢⵜ ⵜⴰⵢⵍⴰⵏⵜ. ⵔⵎⵙⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵙⴳⴷⴰⵍⵏ.# >>> how_many_times.call("""", ""a"")
# 0
# >>> how_many_times.call(""aaa"", ""a"")
# 3
# >>> how_many_times.call(""aaaa"", ""aa"")
# 3
def how_many_times(string, substring)
","def how_many_times(string, substring)
  return 0 if substring.empty?
  count = 0
  i = 0
  while i <= string.length - substring.length
    if string[i, substring.length] == substring
      count += 1
    end
    i += 1
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_how_many_times
    candidate = method(:how_many_times)
    assert_equal(0, candidate.call("""", ""x""))
    assert_equal(4, candidate.call(""xyxyxyx"", ""x""))
    assert_equal(4, candidate.call(""cacacacac"", ""cac""))
    assert_equal(1, candidate.call(""john doe"", ""john""))
  end
end
"
HumanEval_19,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵜⵉⴼⵔⴽⵜ ⵙ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵡⵉⵏ ⵉⵎⵥⵥⵉⵏ ⴰⵔ ⵡⵉⵏ ⵉⵎⵇⵇⵔⴰⵏ ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ ""ⵥⵕⵓ"", ""ⵢⴰⵏ"", "" ⵙⵉⵏ"", "" ⴽⵕⴰⴹ"", "" ⴽⴽⵓⵥ"", "" ⵙⵎⵎⵓⵙ"", ""ⵚⴹⵉⵚ"", "" ⵙⴰ"", "" ⵜⴰⵎ"" ⴷ "" ⵜⵥⴰ"".""ⵉⴽⴽⵉ ⵏ ⵓⴹⴼⵕ ⵉⴳⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ""ⴰⵎⵢⴰ"" ⴰⵔ ""ⵜⵥⴰ"".# >>> sort_numbers.call(""three one five"")
# ""one three five""
def sort_numbers(numbers)
","def sort_numbers(numbers)
  numeral_map = {
    'zero' => 0,
    'one' => 1,
    'two' => 2,
    'three' => 3,
    'four' => 4,
    'five' => 5,
    'six' => 6,
    'seven' => 7,
    'eight' => 8,
    'nine' => 9
  }

  number_words = numbers.split
  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }
  sorted_numbers.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_numbers
    candidate = method(:sort_numbers)
    assert_equal("""", candidate.call(""""))
    assert_equal(""three"", candidate.call(""three""))
    assert_equal(""three five nine"", candidate.call(""three five nine""))
    assert_equal(""zero four five seven eight nine"", candidate.call(""five zero four seven nine eight""))
    assert_equal(""zero one two three four five six"", candidate.call(""six five four three two one zero""))
  end
end
"
HumanEval_20,taq_Tfng,rb,"ⴹⴰⵔⴰⵜ ⵓⵢⵏ, ⴰⴷⴷⵉⴾⵓⴷ ⵏ ⵉⴾⵉ ⵏ ⴰⵍⴾⴰⴷ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⵓⵢⵏ (ⵉⴾⵉ ⵏ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵎⴰⴷⵔⵓⵉⵏ, ⵉⴾⵉ ⵏ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵎⴰⵈⵈⵓⵔⴰⵏ)ⵙⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ (ⵙ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵓⵔ ⵉⴷⵔⵓⵙ ⵙⵉⵏ) ⵙⵜⴰⵢ ⴷ ⵙⵔⴷⵙⵏ ⵙⵉⵏ ⵡⵉⵏⵏⴰ ⵢⵓⴳⵔⵏ ⴽⵓ ⵢⴰⵏ # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
# [2.0, 2.2]
# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
# [2.0, 2.0]
def find_closest_elements(numbers)
","def find_closest_elements(numbers)
  sorted_numbers = numbers.sort
  closest_pair = [sorted_numbers[0], sorted_numbers[1]]
  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs

  (1...(sorted_numbers.length - 1)).each do |i|
    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs
    if current_difference < min_difference
      min_difference = current_difference
      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]
    end
  end

  closest_pair
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_closest_elements
    candidate = method(:find_closest_elements)
    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))
    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))
    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))
    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))
    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))
  end
end
"
HumanEval_21,taq_Tfng,rb,"ⴰⵢⴰ ⴰⵖⵢⴰⵏ ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ 0 ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ ⵔⴰⴷ ⵉⴳ 1ⴳ ⵓⵙⵔⵙⵉ ⵏ ⵡⵓⵟⵟⵓⵏ (ⵙ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⴷⵖⴰⵔ), ⵙⵙⵎⵔⵙⵏ ⴰⵙⵏⴼⵍ ⴰⵎⵉⵔⵉⵡ ⴳ ⵓⵙⵔⵙⵉ, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])
# [0.0, 0.25, 0.5, 0.75, 1.0]
def rescale_to_unit(numbers)
","def rescale_to_unit(numbers)
  min = numbers.min
  max = numbers.max
  range = max - min
  return numbers.map { |num| (num - min) / range.to_f }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rescale_to_unit
    candidate = method(:rescale_to_unit)
    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))
    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))
    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))
  end
end
"
HumanEval_22,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵎⵙⴳⴷⴰⵍ ⵏ ⴽⵔⴰ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ rbthon ⵖⴰⵙ ⵉ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ # >>> filter_integers.call([""a"", 3.14, 5])
# [5]
# >>> filter_integers.call([1, 2, 3, ""abc"", {}, []])
# [1, 2, 3]
def filter_integers(values)
","def filter_integers(values)
  values.select { |value| value.is_a?(Integer) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_integers
    candidate = method(:filter_integers)
    assert_equal([], candidate.call([]))
    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, ""adasd""]))
    assert_equal([3, 3, 3], candidate.call([3, ""c"", 3, 3, ""a"", ""b""]))
  end
end
"
HumanEval_23,taq_Tfng,rb,"ⵔⵓⵜⵓⵔ ⵍⵓⵏⴳ ⵏ ⵜⵔⵉⵏⴳ # >>> strlen.call("""")
# 0
# >>> strlen.call(""abc"")
# 3
def strlen(string)
","strlen = lambda do |string|
  string.length
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strlen
    candidate = method(:strlen)
    assert_equal(0, candidate.call(""""))
    assert_equal(1, candidate.call(""x""))
    assert_equal(9, candidate.call(""asdasnakj""))
  end
end
"
HumanEval_24,taq_Tfng,rb,"ⵉ ⵓⵎⴹⴰⵏ n, ⴷⴼⵔ ⴰⵎⴹⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵉⵜⵜⴱⴹⵓⵏ n ⵙ ⵜⴰⵖⴹⴼⵜ, ⴷ ⵉⵎⵥⵥⵉⵏ ⵙⴳ n # >>> largest_divisor.call(15)
# 5
def largest_divisor(n)
","def largest_divisor(n)
  (n - 1).downto(1) do |i|
    return i if n % i == 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_divisor
    candidate = method(:largest_divisor)
    assert_equal(1, candidate.call(3))
    assert_equal(1, candidate.call(7))
    assert_equal(5, candidate.call(10))
    assert_equal(50, candidate.call(100))
    assert_equal(7, candidate.call(49))
  end
end
"
HumanEval_25,taq_Tfng,rb,"ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⵙⴽⵛⵎ ⴰⵎⵎ ⵓⵢⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴰⴽⴽⵡ ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵎⴳⴳⵉⵜⵏ ⴰⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏⵏⴰ ⴳ ⴷⴰ ⵢⴰⴷⴼ ⴳ ⵓⵙⴼⵙⵉ.ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⴷⵉ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵙⴳ ⵓⵥⵥⵉⵢⵏ ⴰⵔ ⵓⵅⴰⵜⴰⵔ.# >>> factorize.call(8)
# [2, 2, 2]
# >>> factorize.call(25)
# [5, 5]
# >>> factorize.call(70)
# [2, 5, 7]
def factorize(n)
","def factorize(n)
  factors = []
  divisor = 2
  while n > 1
    while n % divisor == 0
      factors << divisor
      n /= divisor
    end
    divisor += 1
  end
  factors
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_factorize
    candidate = method(:factorize)
    assert_equal([2], candidate.call(2))
    assert_equal([2, 2], candidate.call(4))
    assert_equal([2, 2, 2], candidate.call(8))
    assert_equal([3, 19], candidate.call(57))
    assert_equal([3, 3, 19, 19], candidate.call(3249))
    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))
    assert_equal([3, 19, 19, 19], candidate.call(20577))
    assert_equal([2, 3, 3], candidate.call(18))
  end
end
"
HumanEval_26,taq_Tfng,rb,"ⵃⴹⵓ ⵜⴰⵍⵖⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵙ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⴽⵛⵎ.ⵙⴳ ⵓⵎⵙⴷⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵜⵜⵊⵕⵓⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ.# >>> remove_duplicates.call([1, 2, 3, 2, 4])
# [1, 3, 4]
def remove_duplicates(numbers)
","def remove_duplicates(numbers)
  numbers.select { |num| numbers.count(num) == 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_duplicates
    candidate = method(:remove_duplicates)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))
  end
end
"
HumanEval_27,taq_Tfng,rb," ⵉ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵙⵓⵜⵍ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴷ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ.# >>> flip_case.call(""Hello"")
# ""hELLO""
def flip_case(string)
","def flip_case(string)
  string.swapcase
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_flip_case
    candidate = method(:flip_case)
    assert_equal("""", candidate.call(""""))
    assert_equal(""hELLO!"", candidate.call(""Hello!""))
    assert_equal(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"", candidate.call(""These violent delights have violent ends""))
  end
end
"
HumanEval_28,taq_Tfng,rb,"ⴰⵙⵎⵓⵏ ⵏ ⵜⵓⴳⵜ ⵏ ⵉⵙⵉⴹⵏ ⴳ ⵢⴰⵏ ⵓⵙⵉⴹⵏ # >>> concatenate.call([])
# """"
# >>> concatenate.call([""a"", ""b"", ""c""])
# ""abc""
def concatenate(strings)
","def concatenate(strings)
  strings.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_concatenate
    candidate = method(:concatenate)
    assert_equal("""", candidate.call([]))
    assert_equal(""xyz"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""xyzwk"", candidate.call([""x"", ""y"", ""z"", ""w"", ""k""]))
  end
end
"
HumanEval_29,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ ⵢⴰⵜ ⵜⵣⵍⵖⴰ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ.# >>> filter_by_prefix.call([], ""a"")
# []
# >>> filter_by_prefix.call([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
# [""abc"", ""array""]
def filter_by_prefix(strings, prefix)
","def filter_by_prefix(strings, prefix)
  strings.select { |string| string.start_with?(prefix) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_prefix
    candidate = method(:filter_by_prefix)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
  end
end
"
HumanEval_30,taq_Tfng,rb,"ⴷⴰ ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵖⴰⵙ ⵉⵎⴹⴰⵏ ⵉⴳⴳⵓⴷⵉⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ.# >>> get_positive.call([-1, 2, -4, 5, 6])
# [2, 5, 6]
# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# [5, 3, 2, 3, 9, 123, 1]
def get_positive(l)
","get_positive = lambda do |l|
  l.select { |num| num > 0 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_positive
    candidate = method(:get_positive)
    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))
    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))
    assert_equal([], candidate.call([-1, -2]))
    assert_equal([], candidate.call([]))
  end
end
"
HumanEval_31,taq_Tfng,rb,"ⴰⵔ ⵉⵜⵜⴰⵍⵙ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵜⵉⵔⵡⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ.# >>> is_prime.call(6)
# false
# >>> is_prime.call(101)
# true
# >>> is_prime.call(11)
# true
# >>> is_prime.call(13441)
# true
# >>> is_prime.call(61)
# true
# >>> is_prime.call(4)
# false
# >>> is_prime.call(1)
# false
def is_prime(n)
","is_prime = lambda do |n|
  return false if n <= 1
  return true if n == 2
  return false if n.even?

  max_divisor = Math.sqrt(n).to_i
  (3..max_divisor).step(2).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_prime
    candidate = method(:is_prime)
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(101))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(13441))
    assert_equal(true, candidate.call(61))
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(1))
    assert_equal(true, candidate.call(5))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(17))
    assert_equal(false, candidate.call(85))
    assert_equal(false, candidate.call(77))
    assert_equal(false, candidate.call(255379))
  end
end
"
HumanEval_33,taq_Tfng,rb,"ⵉⵍⴰⵏ ⴰⵜⵉⴳ ⵏ ⵉⵙⴼⴽⴰ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ""ⵍ"", ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.l' ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ l ⴳ ⵉⵙⵏⵎⴰⵍⵏ ⵏⵏⴰ ⵓⵔ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ, ⵎⴰⵛⴰ ⵜⵉⵏⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⵎⴰⵍⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷⴰ ⵜⴽⴽⴰ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ l ⴰⵔ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ l' ⵣⵓⵏⴷ ⵎⴰⵙ # >>> sort_third.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])
# [2, 6, 3, 4, 8, 9, 5]
def sort_third(l)
","def sort_third(l)
  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort
  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_third
    candidate = method(:sort_third)
    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))
    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))
    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))
    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))
  end
end
"
HumanEval_34,taq_Tfng,rb,"ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵥⵍⴰⵢⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ # >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [0, 2, 3, 5, 9, 123]
def unique(l)
","def unique(l)
  l.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique
    candidate = method(:unique)
    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_35,taq_Tfng,rb,"ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵇⵇⵓⵔⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ.# >>> max_element.call([1, 2, 3])
# 3
# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# 123
def max_element(l)
","def max_element(l)
  l.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_element
    candidate = method(:max_element)
    assert_equal(3, candidate.call([1, 2, 3]))
    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))
  end
end
"
HumanEval_36,taq_Tfng,rb,"ⵔⵉⵜⵓⵔ ⵏ ⵓⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵢⴰⴽⵙⵓⵍⵏ ⵙ 11 ⵏⵖⴷ 13. # >>> fizz_buzz.call(50)
# 0
# >>> fizz_buzz.call(78)
# 2
# >>> fizz_buzz.call(79)
# 3
def fizz_buzz(n)
","def fizz_buzz(n)
  count = 0
  (1...n).each do |i|
    if i % 11 == 0 || i % 13 == 0
      count += i.to_s.count('7')
    end
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fizz_buzz
    candidate = method(:fizz_buzz)
    assert_equal(0, candidate.call(50))
    assert_equal(2, candidate.call(78))
    assert_equal(3, candidate.call(79))
    assert_equal(3, candidate.call(100))
    assert_equal(6, candidate.call(200))
    assert_equal(192, candidate.call(4000))
    assert_equal(639, candidate.call(10000))
    assert_equal(8026, candidate.call(100000))
  end
end
"
HumanEval_37,taq_Tfng,rb,"ⵙ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵖⵏⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏ ""ⵍ"", ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.I ⴰⵎⵙⴰⵙⴰ ⴷ I ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵎⴰⵛⴰ ⵜⵉⵜⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳⴰⵏⵜ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷⴰ ⵜⴽⴽⴰ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ l ⴰⵔ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ l' ⵣⵓⵏⴷ ⵎⴰⵙ # >>> sort_even.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_even.call([5, 6, 3, 4])
# [3, 6, 5, 4]
def sort_even(l)
","def sort_even(l)
  even_indices = l.each_index.select { |i| i.even? }
  even_values = even_indices.map { |i| l[i] }.sort
  
  even_index = 0
  l.each_with_index.map do |value, index|
    if index.even?
      even_values[even_index].tap { even_index += 1 }
    else
      value
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_even
    candidate = method(:sort_even)
    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))
    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
  end
end
"
HumanEval_39,taq_Tfng,rb,"prime_fib ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵙ-ⵏⵏⴰ ⵉⴳⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⴷ ⵉⴳⴰ ⴰⵡⴷ ⴰⵎⵣⵡⴰⵔⵓ. # >>> prime_fib.call(1)
# 2
# >>> prime_fib.call(2)
# 3
# >>> prime_fib.call(3)
# 5
# >>> prime_fib.call(4)
# 13
# >>> prime_fib.call(5)
# 89
def prime_fib(n)
","def prime_fib(n)
  require 'prime'
  
  fibs = Enumerator.new do |y|
    a, b = 0, 1
    loop do
      a, b = b, a + b
      y << b
    end
  end
  
  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }
  prime_fibs.first(n).last
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_fib
    candidate = method(:prime_fib)
    assert_equal(2, candidate.call(1))
    assert_equal(3, candidate.call(2))
    assert_equal(5, candidate.call(3))
    assert_equal(13, candidate.call(4))
    assert_equal(89, candidate.call(5))
    assert_equal(233, candidate.call(6))
    assert_equal(1597, candidate.call(7))
    assert_equal(28657, candidate.call(8))
    assert_equal(514229, candidate.call(9))
    assert_equal(433494437, candidate.call(10))
  end
end
"
HumanEval_40,taq_Tfng,rb,"ⴰⵜⵉⴳ ⵏ ⵓⵎⵢⴰ, ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⵏⵙⴰ ⵢⴰⴹⵏ.ⴷⴰ ⵉⵜⵜⴰⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⴰⵙⵉ ⵡⴰⵏⵙⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵣⵓⵏⴷ ⵜⴰⵏⴽⵔⴰ.# >>> triples_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> triples_sum_to_zero.call([1, 3, -2, 1])
# true
# >>> triples_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])
# true
# >>> triples_sum_to_zero.call([1])
# false
def triples_sum_to_zero(l)
","def triples_sum_to_zero(l)
  n = l.length
  (0...n-2).each do |i|
    ((i+1)...n-1).each do |j|
      ((j+1)...n).each do |k|
        return true if l[i] + l[j] + l[k] == 0
      end
    end
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triples_sum_to_zero
    candidate = method(:triples_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, 5, -1]))
    assert_equal(true, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(false, candidate.call([1, 2, 5, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(false, candidate.call([1, 3, 5, -100]))
    assert_equal(false, candidate.call([100, 3, 5, -100]))
  end
end
"
HumanEval_41,taq_Tfng,rb,"ⴷⴰ ⵜⵙⵙⵓⴼⵖ ⵜⵎⵔⵙⵜ ⴰⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵏⵖⵉ ⴰⴷ.ⴷⴰⵗ ⵜⴰⴱⴰⵔⴰⵜ ⵜⴰⵏ ⵏⴰⵙⴰⵏ ⵛⵓⵏⴷ ⵓⴰⵔ ⵉⵋⵋⴰ ⴰⴾⴰⵔⴰⵛⵂⵎⵇⵇⴰⵔ, ⵍⵍⴰⵏ ⵉⵎⵓⴷⴰⵔ ⵉⴷⵓⵙⵏ ⴱⴰⵀⵔⴰ ⴷ ⵉⴷⵓⵙⵏ; ⵙ ⵜⵢⴰⴼⵓⵜ, ⴷⴰ ⵙⵓⵍⵏ ⵙ ⵓⵎⵓⵙⵙⵓ.ⴰⵍⵓⴰⵈ ⵓⴰ ⵉⴷ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵔⵓⵙⵜ ⵜⴰ ⵜⴰⴾⴰⵍ ⵙ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜⵆⴰⵙ ⴰⴾⵓⵣⴰⵏⴰⵏ ⵙ ⵜⴰⵣⴰⵉⵜ ⵉⵉⵉⴰⵜ. ⵙⴰⵏⴰⵜⴰⵜ ⵉⴾⴰⵔⴰⵏⴰⵏ ⴰⵜⵓⴰⵗⵔⴰⴷⴰ ⵜⵜⵓⵙⵙⵓⴷⵓ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵛⵍⵍ. ⵙⵏⴰⵜ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⵓⵍⵍⵉⵜⵉⵏ ⴷⴰ ⵜⵜⴱⴷⵓⵏⵜ ⵙ ⵓⴱⵔⴰⵔ ⵏ ⵣⵉⴽⴽ ⵣⵉ ⵔⴱⴰⵜ.ⴷⴰ ⵙⵙⵓⴷⵙⵏ n ⵏ ⵉⵎⵓⴷⴰⵔ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵖⵔ ⵓⵥⵍⵎⴰⴹ; ⴳ ⵢⴰⵜ ⵜⵉⵣⵉ, ⵜⴰⵔⴰⴱⴱⵓⵜ ⵏ ⵉⵎⵓⴷⴰⵔ ⴰⵜⴰⵍⴰⵗⵉ ⴰⵙ ⴰⴱⴰⵔⴰ ⴻⵈⵈⴰⵍ ⴰⴱⴰⵔⴰ ⵓⴰ ⵓⵗⴰⴷⴰⵏ ⵂⴰⵔⴾⵓⴾ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜdef car_race_collision(n)
","def car_race_collision(n)
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_car_race_collision
    candidate = method(:car_race_collision)
    assert_equal(4, candidate.call(2))
    assert_equal(9, candidate.call(3))
    assert_equal(16, candidate.call(4))
    assert_equal(64, candidate.call(8))
    assert_equal(100, candidate.call(10))
  end
end
"
HumanEval_42,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵣⵣⵉⴳⵣⵏ ⵙ 1.# >>> incr_list.call([1, 2, 3])
# [2, 3, 4]
# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [6, 4, 6, 3, 4, 4, 10, 1, 124]
def incr_list(l)
","def incr_list(l)
  l.map { |x| x + 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_incr_list
    candidate = method(:incr_list)
    assert_equal([], candidate.call([]))
    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))
    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_43,taq_Tfng,rb,"ⴰⵜⵉⴳ ⵏ ⵓⵎⵢⴰ, ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⵏⵙⴰ ⵢⴰⴹⵏ.ⴷⴰ ⵉⵜⵜⴰⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⴰⵙⵉ pairs_sum_to_zero ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ.# >>> pairs_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> pairs_sum_to_zero.call([1, 3, -2, 1])
# false
# >>> pairs_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])
# true
# >>> pairs_sum_to_zero.call([1])
# false
def pairs_sum_to_zero(l)
","def pairs_sum_to_zero(l)
  num_set = l.to_set
  l.each do |num|
    return true if num != 0 && num_set.include?(-num)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pairs_sum_to_zero
    candidate = method(:pairs_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))
  end
end
"
HumanEval_44,taq_Tfng,rb,"ⵉⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⴳⴰⵏ ⵉⵎⵥⵥⵉⵏ ⵙⴳ 10.ⴷⴰ ⵉⵜⵜⴰⵣⴰⵍ ⵓⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵏⴼⵍ.ⵙⵏⴼⵍ ⵜⴰⵙⵉⵍⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ x ⵙ ⵜⴰⵙⵉⵍⴰ.# >>> change_base.call(8, 3)
# ""22""
# >>> change_base.call(8, 2)
# ""1000""
# >>> change_base.call(7, 2)
# ""111""
def change_base(x, base)
","def change_base(x, base)
  return '0' if x == 0
  digits = []
  while x > 0
    digits << (x % base).to_s
    x /= base
  end
  digits.reverse.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_change_base
    candidate = method(:change_base)
    assert_equal(""22"", candidate.call(8, 3))
    assert_equal(""100"", candidate.call(9, 3))
    assert_equal(""11101010"", candidate.call(234, 2))
    assert_equal(""10000"", candidate.call(16, 2))
    assert_equal(""1000"", candidate.call(8, 2))
    assert_equal(""111"", candidate.call(7, 2))
    assert_equal(""2"", candidate.call(2, 3))
    assert_equal(""3"", candidate.call(3, 4))
    assert_equal(""4"", candidate.call(4, 5))
    assert_equal(""5"", candidate.call(5, 6))
    assert_equal(""6"", candidate.call(6, 7))
    assert_equal(""7"", candidate.call(7, 8))
  end
end
"
HumanEval_45,taq_Tfng,rb,"ⴰⵣⵣⵓⵣⵔ ⵏ ⵓⴳⴰⴼⴰ ⴷ ⵢⵉⴳⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎⵇⵔⴰⵏ ⵉ ⵜⵔⵉⴳⵓⵏⵉⵜ.# >>> triangle_area.call(5, 3)
# 7.5
def triangle_area(a, h)
","def triangle_area(a, h)
  (a * h) / 2.0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(7.5, candidate.call(5, 3))
    assert_equal(2.0, candidate.call(2, 2))
    assert_equal(40.0, candidate.call(10, 8))
  end
end
"
HumanEval_46,taq_Tfng,rb,"ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ ⵉⴼⵔⴷⵉⵙ ⵏ ⵡⵉⵙⵙ n ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ fib4. ⵓⵔ ⵜⵙⵙⵎⵔⴰⵙ ⵜⵉⵔⵔⴰ. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 ⵜⴰⵍⵖⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ Fib4 ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ:# >>> fib4.call(5)
# 4
# >>> fib4.call(6)
# 8
# >>> fib4.call(7)
# 14
def fib4(n)
","def fib4(n)
  return 0 if n == 0 || n == 1 || n == 3
  return 2 if n == 2

  fib4_seq = [0, 0, 2, 0]
  (4..n).each do |i|
    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]
  end
  fib4_seq[n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib4
    candidate = method(:fib4)
    assert_equal(4, candidate.call(5))
    assert_equal(28, candidate.call(8))
    assert_equal(104, candidate.call(10))
    assert_equal(386, candidate.call(12))
  end
end
"
HumanEval_47,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⴰⴽⵡⵣ ⵡⴰⵎⵎⴰⵙ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ l. # >>> median.call([3, 1, 2, 4, 5])
# 3
# >>> median.call([-10, 4, 6, 1000, 10, 20])
# 15.0
def median(l)
","def median(l)
  sorted = l.sort
  len = sorted.length
  if len.odd?
    sorted[len / 2]
  else
    (sorted[len / 2 - 1] + sorted[len / 2]) / 2.0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_median
    candidate = method(:median)
    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))
    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))
    assert_equal(5, candidate.call([5]))
    assert_equal(5.5, candidate.call([6, 5]))
    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))
  end
end
"
HumanEval_48,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⴰⴷ ⵉⴳ ⵍⵉⵙⵜⵔⵉⵏ ⴰⴽⴽⵡ ⵉⴳⴰⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ # >>> is_palindrome.call("""")
# true
# >>> is_palindrome.call(""aba"")
# true
# >>> is_palindrome.call(""aaaaa"")
# true
# >>> is_palindrome.call(""zbcd"")
# false
def is_palindrome(text)
","is_palindrome = lambda do |text|
  text == text.reverse
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_palindrome
    candidate = method(:is_palindrome)
    assert_equal(true, candidate.call(""""))
    assert_equal(true, candidate.call(""aba""))
    assert_equal(true, candidate.call(""aaaaa""))
    assert_equal(false, candidate.call(""zbcd""))
    assert_equal(true, candidate.call(""xywyx""))
    assert_equal(false, candidate.call(""xywyz""))
    assert_equal(false, candidate.call(""xywzx""))
  end
end
"
HumanEval_49,taq_Tfng,rb,"ⵔⵉⵜⵓⵔ 2^n ⵎⵓⴷⵓⵍⵓ p (ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⵙ ⵡⵓⵟⵟⵓⵏ).# >>> modp.call(3, 5)
# 3
# >>> modp.call(1101, 101)
# 2
# >>> modp.call(0, 101)
# 1
# >>> modp.call(3, 11)
# 8
# >>> modp.call(100, 101)
# 1
def modp(n, p)
","def modp(n, p)
  return 1 if p == 1
  2.pow(n, p)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_modp
    candidate = method(:modp)
    assert_equal(3, candidate.call(3, 5))
    assert_equal(2, candidate.call(1101, 101))
    assert_equal(1, candidate.call(0, 101))
    assert_equal(8, candidate.call(3, 11))
    assert_equal(1, candidate.call(100, 101))
    assert_equal(4, candidate.call(30, 5))
    assert_equal(3, candidate.call(31, 5))
  end
end
"
HumanEval_51,taq_Tfng,rb,"remove_vowels ⵜⴳⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴱⵍⴰ ⵜⵉⴼⵉⵏⴰⵖ. # >>> remove_vowels.call("""")
# """"
# >>> remove_vowels.call(""abcdef"")
# ""bcdf""
# >>> remove_vowels.call(""aaaaa"")
# """"
# >>> remove_vowels.call(""aaBAA"")
# ""B""
# >>> remove_vowels.call(""zbcd"")
# ""zbcd""
def remove_vowels(text)
","def remove_vowels(text)
  text.delete('aeiouAEIOU')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_vowels
    candidate = method(:remove_vowels)
    assert_equal("""", candidate.call(""""))
    assert_equal(""bcdf
ghjklm"", candidate.call(""abcdef
ghijklm""))
    assert_equal(""fdcb"", candidate.call(""fedcba""))
    assert_equal("""", candidate.call(""eeeee""))
    assert_equal(""cB"", candidate.call(""acBAA""))
    assert_equal(""cB"", candidate.call(""EcBOO""))
    assert_equal(""ybcd"", candidate.call(""ybcd""))
  end
end
"
HumanEval_52,taq_Tfng,rb,"ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⴰⴽⴽⵡ ⴳ ⵓⵎⵙⴳⵏⴰⴼ l ⴷⴷⴰⵡ ⵏ ⵓⴽⵜⵜⴰⵢ t. # >>> below_threshold.call([1, 2, 4, 10], 100)
# true
# >>> below_threshold.call([1, 20, 4, 10], 5)
# false
def below_threshold(l, t)
","def below_threshold(l, t)
  l.all? { |num| num < t }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_threshold
    candidate = method(:below_threshold)
    assert_equal(true, candidate.call([1, 2, 4, 10], 100))
    assert_equal(false, candidate.call([1, 20, 4, 10], 5))
    assert_equal(true, candidate.call([1, 20, 4, 10], 21))
    assert_equal(true, candidate.call([1, 20, 4, 10], 22))
    assert_equal(true, candidate.call([1, 8, 4, 10], 11))
    assert_equal(false, candidate.call([1, 8, 4, 10], 10))
  end
end
"
HumanEval_53,taq_Tfng,rb,"ⵙⵓⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ x ⴷ y # >>> add.call(2, 3)
# 5
# >>> add.call(5, 7)
# 12
def add(x, y)
","add = ->(x, y) { x + y }","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(1, candidate.call(0, 1))
    assert_equal(1, candidate.call(1, 0))
    assert_equal(5, candidate.call(2, 3))
    assert_equal(12, candidate.call(5, 7))
    assert_equal(12, candidate.call(7, 5))
  end
end
"
HumanEval_54,taq_Tfng,rb,"ⵔⴻⵛⴻⵛⴻ ⵎⴻⵗ ⵙⴰⵏⴰⵜⴰⵜ ⵉⵙⵎⴰⵓⴰⵏ ⵉⵍⴰⵏ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⵓⵍⴰⵂⵏⴻⵏ.# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
# true
# >>> same_chars.call(""abcd"", ""dddddddabc"")
# true
# >>> same_chars.call(""dddddddabc"", ""abcd"")
# true
# >>> same_chars.call(""eabcd"", ""dddddddabc"")
# false
# >>> same_chars.call(""abcd"", ""dddddddabce"")
# false
# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
# false
def same_chars(s0, s1)
","def same_chars(s0, s1)
  s0.chars.uniq.all? { |char| s1.include?(char) } &&
  s1.chars.uniq.all? { |char| s0.include?(char) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_same_chars
    candidate = method(:same_chars)
    assert_equal(true, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc""))
    assert_equal(true, candidate.call(""abcd"", ""dddddddabc""))
    assert_equal(true, candidate.call(""dddddddabc"", ""abcd""))
    assert_equal(false, candidate.call(""eabcd"", ""dddddddabc""))
    assert_equal(false, candidate.call(""abcd"", ""dddddddabcf""))
    assert_equal(false, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddddabc""))
    assert_equal(false, candidate.call(""aabb"", ""aaccc""))
  end
end
"
HumanEval_55,taq_Tfng,rb,"ⵔⵉⵜⵓⵔ ⵏ ⵜⵓⵏⴹⵜ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ ⵜⵉⵙ n.# >>> fib.call(10)
# 55
# >>> fib.call(1)
# 1
# >>> fib.call(8)
# 21
def fib(n)
","def fib(n)
  return n if n <= 1
  fib(n - 1) + fib(n - 2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib
    candidate = method(:fib)
    assert_equal(55, candidate.call(10))
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(8))
    assert_equal(89, candidate.call(11))
    assert_equal(144, candidate.call(12))
  end
end
"
HumanEval_56,taq_Tfng,rb,"return true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ. brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ ""<"" ⴷ "">"". # >>> correct_bracketing.call(""<"")
# false
# >>> correct_bracketing.call(""<>"")
# true
# >>> correct_bracketing.call(""<<><>>"")
# true
# >>> correct_bracketing.call(""><<>"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.chars.each do |char|
    if char == '<'
      balance += 1
    elsif char == '>'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""<>""))
    assert_equal(true, candidate.call(""<<><>>""))
    assert_equal(true, candidate.call(""<><><<><>><>""))
    assert_equal(true, candidate.call(""<><><<<><><>><>><<><><<>>>""))
    assert_equal(false, candidate.call(""<<<><>>>>""))
    assert_equal(false, candidate.call(""><<>""))
    assert_equal(false, candidate.call(""<""))
    assert_equal(false, candidate.call(""<<<<""))
    assert_equal(false, candidate.call("">""))
    assert_equal(false, candidate.call(""<<>""))
    assert_equal(false, candidate.call(""<><><<><>><>><<>""))
    assert_equal(false, candidate.call(""<><><<><>><>>><>""))
  end
end
"
HumanEval_57,taq_Tfng,rb,"Return true ⵉⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵙⵏⵙⵍ ⴷⴰ ⵙⵙⵓⴷⵓⵏ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵓⵙⵙⵖⵓⴷⵓ ⵏⵖⴷ ⵓⵙⵙⴷⵔⵓⵙ.# >>> monotonic.call([1, 2, 4, 20])
# true
# >>> monotonic.call([1, 20, 4, 10])
# false
# >>> monotonic.call([4, 1, 0, -10])
# true
def monotonic(l)
","def monotonic(l)
  increasing = true
  decreasing = true

  (0...l.length - 1).each do |i|
    if l[i] < l[i + 1]
      decreasing = false
    elsif l[i] > l[i + 1]
      increasing = false
    end
  end

  increasing || decreasing
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_monotonic
    candidate = method(:monotonic)
    assert_equal(true, candidate.call([1, 2, 4, 10]))
    assert_equal(true, candidate.call([1, 2, 4, 20]))
    assert_equal(false, candidate.call([1, 20, 4, 10]))
    assert_equal(true, candidate.call([4, 1, 0, -10]))
    assert_equal(true, candidate.call([4, 1, 1, 0]))
    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))
    assert_equal(true, candidate.call([9, 9, 9, 9]))
  end
end
"
HumanEval_58,taq_Tfng,rb,"ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⵏⴻⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵉ ⵙⵉⵏ ⵉⵎⵙⴷⴷⵉⵜⵏ.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
# [1, 5, 653]
# >>> common.call([5, 3, 2, 8], [3, 2])
# [2, 3]
def common(l1, l2)
","def common(l1, l2)
  (l1 & l2).uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_common
    candidate = method(:common)
    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))
    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))
    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))
    assert_equal([], candidate.call([4, 3, 2, 8], []))
  end
end
"
HumanEval_59,taq_Tfng,rb,"ⵔⵉⵜⵓⵔ ⵏ ⵓⵎⵙⴽⵉⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵉⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ. # >>> largest_prime_factor.call(13195)
# 29
# >>> largest_prime_factor.call(2048)
# 2
def largest_prime_factor(n)
","def largest_prime_factor(n)
  factor = 2
  while factor * factor <= n
    if n % factor == 0
      n /= factor
    else
      factor += 1
    end
  end
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_prime_factor
    candidate = method(:largest_prime_factor)
    assert_equal(5, candidate.call(15))
    assert_equal(3, candidate.call(27))
    assert_equal(7, candidate.call(63))
    assert_equal(11, candidate.call(330))
    assert_equal(29, candidate.call(13195))
  end
end
"
HumanEval_60,taq_Tfng,rb,"sum_to_n ⵜⴳⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏ ⵉⵎⴹⴰⵏ ⵙⴳ 1 ⴰⵔ n. # >>> sum_to_n.call(30)
# 465
# >>> sum_to_n.call(100)
# 5050
# >>> sum_to_n.call(5)
# 15
# >>> sum_to_n.call(10)
# 55
# >>> sum_to_n.call(1)
# 1
def sum_to_n(n)
","def sum_to_n(n)
  (1..n).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_to_n
    candidate = method(:sum_to_n)
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(6))
    assert_equal(66, candidate.call(11))
    assert_equal(465, candidate.call(30))
    assert_equal(5050, candidate.call(100))
  end
end
"
HumanEval_61,taq_Tfng,rb,"return true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ. brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ ""("" ⴷ "")"".# >>> correct_bracketing.call(""("")
# false
# >>> correct_bracketing.call(""()"")
# true
# >>> correct_bracketing.call(""(()())"")
# true
# >>> correct_bracketing.call("")(()"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.each_char do |char|
    if char == '('
      balance += 1
    elsif char == ')'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""()""))
    assert_equal(true, candidate.call(""(()())""))
    assert_equal(true, candidate.call(""()()(()())()""))
    assert_equal(true, candidate.call(""()()((()()())())(()()(()))""))
    assert_equal(false, candidate.call(""((()())))""))
    assert_equal(false, candidate.call("")(()""))
    assert_equal(false, candidate.call(""(""))
    assert_equal(false, candidate.call(""((((""))
    assert_equal(false, candidate.call("")""))
    assert_equal(false, candidate.call(""(()""))
    assert_equal(false, candidate.call(""()()(()())())(()""))
    assert_equal(false, candidate.call(""()()(()())()))()""))
  end
end
"
HumanEval_62,taq_Tfng,rb,"ⵔⵉⵜⵓⵔⵏ ⴷⵉⵔⵉⴼⵉⴰⵜⵉⴱ ⵏ ⴱⵓⵍⵉⵏⵓⵎⵉⵢⴰ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ. xs[0] + xs[1] * x + xs[2] * x^2 + .... ⴷⴰ ⵉⵙⵎⴷⵢⴰ xs ⵉⵎⴳⴳⵉⵜⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵡⵜⵜⴰ.# >>> derivative.call([3, 1, 2, 4, 5])
# [1, 4, 12, 20]
# >>> derivative.call([1, 2, 3])
# [2, 6]
def derivative(xs)
","def derivative(xs)
  return [] if xs.length < 2
  xs.each_with_index.map { |coef, index| coef * index }[1..-1]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_derivative
    candidate = method(:derivative)
    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))
    assert_equal([2, 6], candidate.call([1, 2, 3]))
    assert_equal([2, 2], candidate.call([3, 2, 1]))
    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))
    assert_equal([], candidate.call([1]))
  end
end
"
HumanEval_63,taq_Tfng,rb,"ⵔⵔⵢⵣ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵉⴹⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵎⴹⴰⵏ ⵏ fibfib ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵉⴼⵓⵍⴽⵉⵏ.fibfib{n} == fibfib{n-1} + fibfib{n-2} + fibfib{n-3}fib fib ((2) == 1 fibfib{1) == 0 fibfib{0} == 0 ⵜⴰⵍⵖⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴼⵉⴱ ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ:# >>> fibfib.call(1)
# 0
# >>> fibfib.call(5)
# 4
# >>> fibfib.call(8)
# 24
def fibfib(n)
","def fibfib(n)
  return 0 if n == 0 || n == 1
  return 1 if n == 2

  a, b, c = 0, 0, 1
  (3..n).each do
    a, b, c = b, c, a + b + c
  end
  c
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fibfib
    candidate = method(:fibfib)
    assert_equal(1, candidate.call(2))
    assert_equal(0, candidate.call(1))
    assert_equal(4, candidate.call(5))
    assert_equal(24, candidate.call(8))
    assert_equal(81, candidate.call(10))
    assert_equal(274, candidate.call(12))
    assert_equal(927, candidate.call(14))
  end
end
"
HumanEval_64,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⴰⵛⵛⵉⵍ, ⵎⴰⵛⴰ ⴷⴰⵢ ⵉⴳ ⵉⵍⵍⴰ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵉⵜⵜⵓⴼⴽⴰⵏ.ⵉⵎⵓⵙⵙⵓⵜⵏ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ ⴳⴰⵏ ""ⴰ"", ""ⵢ"", ""ⵉ"", ""ⵓ"", ""ⵓ"". ⴷⵖⴰ, ""ⵢ"" ⵉⴳⴰ ⴰⵡⴷ ""ⴰ""ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴳⵓⵔⵉ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵣⵍⵉⵜ.ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ vowels_count ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵜⴰⵡⵓⵔⵉ ⵏ # >>> vowels_count.call(""abcde"")
# 2
# >>> vowels_count.call(""ACEDY"")
# 3
def vowels_count(s)
","def vowels_count(s)
  vowels = ['a', 'e', 'i', 'o', 'u']
  count = 0
  
  s.chars.each_with_index do |char, index|
    if vowels.include?(char.downcase)
      count += 1
    elsif char.downcase == 'y' && index == s.length - 1
      count += 1
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_vowels_count
    candidate = method(:vowels_count)
    assert_equal(2, candidate.call(""abcde""))
    assert_equal(3, candidate.call(""Alone""))
    assert_equal(2, candidate.call(""key""))
    assert_equal(1, candidate.call(""bye""))
    assert_equal(2, candidate.call(""keY""))
    assert_equal(1, candidate.call(""bYe""))
    assert_equal(3, candidate.call(""ACEDY""))
  end
end
"
HumanEval_65,taq_Tfng,rb,"ⵎⴽ ⵜⵍⵍⴰ ⵜⵣⵍⵉⵜ > ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵔⴰⴷ ⵙⵔⵙⵏ ⵡⵓⵟⵟⵓⵏ ⵙ ⵓⴱⵔⴷ.ⴷ ⴰⵔ ⵏⴰⴽⴽⴰ ⵜⴰⵢⴰⴼⵓⵜ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ.ⴷⴰ ⵏⵙⵎⵓⵜⵜⵔ ⵉⵎⵉⴹⵏ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ x ⵙ ⵜⵙⵓⵜⵍⵜ, ⵏⵙⵎⵓⵜⵜⵔ ⵉⵎⵉⴹⵏ ⵙ ⵜⵙⴳⴰ ⵏ ⵓⵣⵔⴼ ⵙ ⵓⵎⵙⵓⵜⵍ.# >>> circular_shift.call(12, 1)
# ""21""
# >>> circular_shift.call(12, 2)
# ""12""
def circular_shift(x, shift)
","def circular_shift(x, shift)
  digits = x.to_s.chars
  num_digits = digits.length

  if shift > num_digits
    return digits.reverse.join
  else
    shift = shift % num_digits
    shifted_digits = digits.rotate(-shift)
    return shifted_digits.join
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_circular_shift
    candidate = method(:circular_shift)
    assert_equal(""001"", candidate.call(100, 2))
    assert_equal(""12"", candidate.call(12, 2))
    assert_equal(""79"", candidate.call(97, 8))
    assert_equal(""21"", candidate.call(12, 1))
    assert_equal(""11"", candidate.call(11, 101))
  end
end
"
HumanEval_66,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴾⵓⴷ ⵜⴰⵏ ⵓⵉⵏ ASCIIⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵖⵕⴹⴰ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵓⴼⵍⵍⴰ ⵜⴰⵣⵣⴰⵍⵜ # >>> digitSum.call("""")
# 0
# >>> digitSum.call(""abAB"")
# 131
# >>> digitSum.call(""abcCd"")
# 67
# >>> digitSum.call(""helloE"")
# 69
# >>> digitSum.call(""woArBld"")
# 131
# >>> digitSum.call(""aAaaaXa"")
# 153
def digitSum(s)
","def digitSum(s)
  s.chars.select { |char| char =~ /[A-Z]/ }.map(&:ord).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digitSum
    candidate = method(:digitSum)
    assert_equal(0, candidate.call(""""))
    assert_equal(131, candidate.call(""abAB""))
    assert_equal(67, candidate.call(""abcCd""))
    assert_equal(69, candidate.call(""helloE""))
    assert_equal(131, candidate.call(""woArBld""))
    assert_equal(153, candidate.call(""aAaaaXa""))
    assert_equal(151, candidate.call("" How are yOu?""))
    assert_equal(327, candidate.call(""You arE Very Smart""))
  end
end
"
HumanEval_67,taq_Tfng,rb,"ⵉ ⵓⵛⵛⵉⵍ: ⴳ ⵜⴽⵕⴹⴰ ⵔⵥⵎ ⵓⵟⵟⵓⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ ⵏ ⵍⵎⴰⵏⴳⵓ ⴳ ⵜⴽⵕⴹⴰ. ⵜⵉⴱⵕⴰⵏⵊⵉⵏ ⴷ ⵜⴱⵔⵖⴰ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ ⴹⴰⵔⴰⵜ ⴰⵙⵉⴾⵏⵓ ⵏ ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ,ⴰⵈⵈⴰⵍⴰⵏ ⴰ ⵉⴾⴼⴰⵏ ⴷⴰⵗ ⵜⴰⴱⴰⵔⴰⵜ ⵏ ⵉⴼⵔⴰⵜⴰⵏ ⴰⵂⴰⵏ ⵜⴰⴱⴰⵔⴰⵜ ⵜⵢⵏⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴱⵔⵟⵓⴽⵜ ⴷ ⵜⴱⵔⵟⵓⴽⵜ # >>> fruit_distribution.call(""5 apples and 6 oranges"", 19)
# 8
# >>> fruit_distribution.call(""0 apples and 1 oranges"", 3)
# 2
# >>> fruit_distribution.call(""2 apples and 3 oranges"", 100)
# 95
# >>> fruit_distribution.call(""100 apples and 1 oranges"", 120)
# 19
def fruit_distribution(s, n)
","def fruit_distribution(s, n)
  numbers = s.scan(/\d+/).map(&:to_i)
  apples = numbers[0]
  oranges = numbers[1]
  total_fruits = n
  mangos = total_fruits - (apples + oranges)
  mangos
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fruit_distribution
    candidate = method(:fruit_distribution)
    assert_equal(8, candidate.call(""5 apples and 6 oranges"", 19))
    assert_equal(10, candidate.call(""5 apples and 6 oranges"", 21))
    assert_equal(2, candidate.call(""0 apples and 1 oranges"", 3))
    assert_equal(2, candidate.call(""1 apples and 0 oranges"", 3))
    assert_equal(95, candidate.call(""2 apples and 3 oranges"", 100))
    assert_equal(0, candidate.call(""2 apples and 3 oranges"", 5))
    assert_equal(19, candidate.call(""1 apples and 100 oranges"", 120))
  end
end
"
HumanEval_68,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ 1:ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⵏⵖⴷ ⵉⴳ ⵓⵎⵙⴳⴷⴰⵍ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉⴳⴰ ⵡⴰⴽⵓ, ⵙⵙⴽⵛⵎ [].ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⵏⴼⵍ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⴳ ⵢⴰⵏ ⵓⵎⵙⴳⵏⴰⴼ, [smallest_value, ⴰⵙⵖⵍ ⵏⵏⵙ], ⵎⴽ ⵜⵜⵢⴰⴼⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵓⵎⴹⴰⵏ, ⵙⵙⴽⵛⵎ ⵜⵓⵏⵏⵓⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⴽⵔⵏ ⵜⴰⵡⵜⵎⵉⵢⵜ ⵜⴰⵥⵥⵉⵥⵜ ⴳ ⵡⴰⵜⵉⴳ ⴰⵎⵎ ⵓⵎⵢⴰ.ⵜⴰⵣⴰⵍⵍⵉⵜ ⵏⴰⵙⵙ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵜ ⵙⴳ ⵜⵓⵏⵏⵓⵏⵜ ⴷ ⴰⴷ ⵜⵔⴰⵔ.""ⴰⴽⴽⴰ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵥⵟⵟⴰ ⵏ ⵢⴰⵜ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⵖⵓⵔ ⵍⵍⴰⵏⵜ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵏ # >>> pluck.call([4, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 2:
# >>> pluck.call([1, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 3:
# >>> pluck.call([])
# []
# Example 4:
# >>> pluck.call([5, 0, 3, 0, 4, 2])
# [0, 1]
# Explanation: 0 is the smallest value, but  there are two zeros,
# so we will choose the first zero, which has the smallest index.
# Constraints:
# * 1 <= nodes.length <= 10000
# * 0 <= node.value
def pluck(arr)
","def pluck(arr)
  smallest_even = nil
  smallest_index = nil
  
  arr.each_with_index do |value, index|
    if value.even?
      if smallest_even.nil? || value < smallest_even
        smallest_even = value
        smallest_index = index
      end
    end
  end

  smallest_even.nil? ? [] : [smallest_even, smallest_index]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pluck
    candidate = method(:pluck)
    assert_equal([2, 1], candidate.call([4, 2, 3]))
    assert_equal([2, 1], candidate.call([1, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))
    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))
    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))
    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))
    assert_equal([], candidate.call([7, 9, 7, 1]))
  end
end
"
HumanEval_69,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵜⵉⴳ ⴰⴷ, ⵔⵔⵓⵜⵓⵔ -1.ⵜⴰⴽⴰⵜ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⴼⴽⴰⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ.ⴰⵎⵢⴰ, ⴷ ⵖⵓⵔⵙ ⵜⴰⵔⵖⴰ ⵜⴰⵅⴰⵜⴰⵔⵜ ⵏⵖⴷ ⵉⵎⴽⵉⵏⵏⴰ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⵉⵎⴰⵏ ⵏⵏⵙ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵏⵉⴳ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵏⴰⵏ. ⵔⵔⵓⵜⵓⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵢⵓⴳⵔⵏ # >>> search.call([4, 1, 2, 2, 3, 1])
# 2
# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])
# 3
# >>> search.call([5, 5, 4, 4, 4])
# -1
def search(lst)
","def search(lst)
  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }
  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys
  valid_numbers.empty? ? -1 : valid_numbers.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_search
    candidate = method(:search)
    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))
    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))
    assert_equal(-1, candidate.call([3, 3]))
    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))
    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))
    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))
    assert_equal(2, candidate.call([3, 2, 8, 2]))
    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))
    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))
    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))
    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))
    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))
    assert_equal(1, candidate.call([1]))
    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))
    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))
    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))
    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))
    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))
    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))
    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))
    assert_equal(-1, candidate.call([10]))
    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))
    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))
    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))
    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))
  end
end
"
HumanEval_70,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ, ⵔⴰⴷ ⵢⵉⵍⵉ ⵡⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⵔⴰⴷ ⵢⵉⵍⵉ ⵡⵓⴳⴳⴰⵔ, ⴷ ⴰⵢⴰⴷ.ⴰⵙⵎⵉⵍⵍ ⴰⵎⵣⴳⵓⵏ, ⵉⴳ ⴷⴰ ⵜⵜⴱⴷⵓⴷ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⴰⵙⵔⴷ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵔⴰⴷ ⵏⵔⴰⵔⵓ ⴰⵙⵔⴷ ⵙ ⵓⵍⵖⵓ.# >>> strange_sort_list.call([1, 2, 3, 4])
# [1, 4, 2, 3]
# >>> strange_sort_list.call([5, 5, 5, 5])
# [5, 5, 5, 5]
# >>> strange_sort_list.call([])
# []
def strange_sort_list(lst)
","def strange_sort_list(lst)
  result = []
  lst.sort!
  until lst.empty?
    result << lst.shift
    result << lst.pop unless lst.empty?
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strange_sort_list
    candidate = method(:strange_sort_list)
    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))
    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))
    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))
    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))
    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))
    assert_equal([], candidate.call([]))
    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))
    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))
    assert_equal([111111], candidate.call([111111]))
  end
end
"
HumanEval_71,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴾⴰⵔⴰⴷⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⴷⴰ ⵙⴽⴰⵔⵏ ⵢⴰⵜ ⵜⵔⴰⵢⵓⴳⵍⴰⵏⵜ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⵜⵍⵍⴰ ⵜⵔⵎⵉⵜ ⵏ ⵙⵏⴰⵜ ⵜⴼⵓⵍⵉⵏ ⴽⵔⴰ ⵢⴰⴹⵏ ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⴷⴰ ⵉⵜⵜⵔⴰⵔ -1 ⵜⵔⵉⴰⵏⴳⵉⵍ ⵜⵓⵔⴷⴰ ⵙ 2 ⵏ ⵜⵏⵇⵇⵉⴹⵉⵏ ⵜⵉⵎⵔⴰⵡⵉⵏ ⵎⴽ ⵜⴳⴰ ⴽⵕⴰⴹⵜ ⵜⴼⵓⵍⵉⵏ ⵢⴰⵜ ⵜⵔⵉⴰⵏⴳⵉⵍⵜ ⵜⵓⵏⵖⵉⴷⵜ.ⴷⴰ ⵜⵜⵓⴽⴽⴰⵏ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⴽⵕⴰⴹ ⵓⴷⵖⴰⵔ. ⵔⵎⵙⵏ ⵜⴰⵊⵓⵎⵎⴰ ⵏ # >>> triangle_area.call(3, 4, 5)
# 6.0
# >>> triangle_area.call(1, 2, 10)
# -1
def triangle_area(a, b, c)
","def triangle_area(a, b, c)
  # Check for valid triangle
  if a + b > c && a + c > b && b + c > a
    # Calculate the semi-perimeter
    s = (a + b + c) / 2.0
    # Calculate the area using Heron's formula
    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))
    # Round to 2 decimal points
    return area.round(2)
  else
    return -1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(6.0, candidate.call(3, 4, 5))
    assert_equal(-1, candidate.call(1, 2, 10))
    assert_equal(8.18, candidate.call(4, 8, 5))
    assert_equal(1.73, candidate.call(2, 2, 2))
    assert_equal(-1, candidate.call(1, 2, 3))
    assert_equal(16.25, candidate.call(10, 5, 7))
    assert_equal(-1, candidate.call(2, 6, 3))
    assert_equal(0.43, candidate.call(1, 1, 1))
    assert_equal(-1, candidate.call(2, 2, 10))
  end
end
"
HumanEval_72,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵔⴰⴷ ⵉⵢⵉ ⵜⵓⴷⵔⵜ ⵏ ⵓⴱⵓⵊⵉⴽⵜ q ⵉⴳ ⴷ ⴰⵎⵙⴰⵙⴰ (ⵉⴳⴰ ⵢⴰⵏ ⵓⵎⵙⴰⵙⴰ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ) ⴷ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⵙ ⵡⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵓⴽⵙⴰⵢ ⴰⵅⴰⵜⴰⵔ w.ⵔⵉⵜⵓⵔⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵉⵜⵜⵓⵖⴰⵍ ⵓⴱⵓⵊⵉⴽⵜ q, ⴷ ⵜⵉⴽⵕⴹⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ.# >>> will_it_fly.call([1, 2], 5)
# false
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly.call([3, 2, 3], 1)
# false
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly.call([3, 2, 3], 9)
# true
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly.call([3], 5)
# true
# # 3 is less than the maximum possible weight, and it's balanced.
def will_it_fly(q, w)
","def will_it_fly(q, w)
  is_palindrome = q == q.reverse
  total_weight = q.sum
  is_balanced_and_under_weight = is_palindrome && total_weight <= w
  is_balanced_and_under_weight
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_will_it_fly
    candidate = method(:will_it_fly)
    assert_equal(true, candidate.call([3, 2, 3], 9))
    assert_equal(false, candidate.call([1, 2], 5))
    assert_equal(true, candidate.call([3], 5))
    assert_equal(false, candidate.call([3, 2, 3], 1))
    assert_equal(false, candidate.call([1, 2, 3], 6))
    assert_equal(true, candidate.call([5], 5))
  end
end
"
HumanEval_73,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴷⴰ ⵉⵜⵜⵓⵙⵎⴷ ⵢⴰⵏ ⵓⵎⵏⵉⴷ ⵙ ⵓⵎⵏⵉⴷ ⴷ ⵙ ⵓⵎⵏⵉⴷ. ⴳ ⵢⴰⵏ ⵓⵙⵏⴼⵍ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵏⴼⵍ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵙ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵢⴰⴹⵏ.ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⵍ ⴰⴼⴰⴷ ⴰⴷ ⵜⴳ ⵜⴳ ⵜⵎⵙⴷⴰⵍⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵜ. ⵜⴰⵎⵙⴷⴰⵍⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵜ ⵜⴳⴰ ⵜⴰⵎⵙⴷⴰⵍⵜ ⵏⵏⴰ ⴹⴼⵓⵕ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴹⴼⵓⵕ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])
# 4
# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])
# 1
# >>> smallest_change.call([1, 2, 3, 2, 1])
# 0
def smallest_change(arr)
","def smallest_change(arr)
  changes = 0
  left = 0
  right = arr.length - 1

  while left < right
    if arr[left] != arr[right]
      changes += 1
    end
    left += 1
    right -= 1
  end

  changes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_smallest_change
    candidate = method(:smallest_change)
    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))
    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))
    assert_equal(1, candidate.call([1, 4, 2]))
    assert_equal(1, candidate.call([1, 4, 4, 2]))
    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))
    assert_equal(0, candidate.call([3, 1, 1, 3]))
    assert_equal(0, candidate.call([1]))
    assert_equal(1, candidate.call([0, 1]))
  end
end
"
HumanEval_74,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵎⴽ ⴷⴰⵔ ⵙⵏⴰⵜ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵉⵎⴹⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵙⵙⴽⵛⵎ ⵜⴰⵔⴰⴱⴱⵓⵜ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ.ⴰⵎⴹⴰⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵜⴽⴰⵔ ⴳ ⴽⵓⵍⵍⵓ ⵜⵉⵙⵉⴹⴼⵉⵏ ⵏ ⵓⵎⵙⴰⵙⴰ ⴷⵔⵓⵙⵏ ⴳ ⵓⵎⵙⴰⵙⴰ ⵢⴰⴹⵏ.ⵔⵉⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵙⵏⴰⵜ ⵜⵔⴱⴰⵜⵉⵏ ⵏ ⵉⵙⵉⴹⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⵔⴱⴰⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ # >>> total_match.call([], [])
# []
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""Hi""])
# [""hI"", ""Hi""]
# >>> total_match.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
# [""hi"", ""admin""]
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
# [""hI"", ""hi"", ""hi""]
# >>> total_match.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
# [""4""]
def total_match(lst1, lst2)
","def total_match(lst1, lst2)
  total_chars1 = lst1.map(&:length).sum
  total_chars2 = lst2.map(&:length).sum

  if total_chars1 < total_chars2
    lst1
  elsif total_chars2 < total_chars1
    lst2
  else
    lst1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_total_match
    candidate = method(:total_match)
    assert_equal([], candidate.call([], []))
    assert_equal([""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]))
    assert_equal([""4""], candidate.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]))
    assert_equal([""hI"", ""Hi""], candidate.call([""hi"", ""admin""], [""hI"", ""Hi""]))
    assert_equal([""hI"", ""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]))
    assert_equal([], candidate.call([], [""this""]))
    assert_equal([], candidate.call([""this""], []))
  end
end
"
HumanEval_75,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵃⵎⴰ ⴰⴷ ⵏⵙⵙⵏ ⵉⵙ (ⴰ) ⴷⵔⵓⵙ ⵙⴳ 100.ⴷ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵜⴰⵔⵡⴰ ⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ # >>> is_multiply_prime.call(30)
# true
# 30 = 2 * 3 * 5
def is_multiply_prime(a)
","require 'prime'

def is_multiply_prime(a)
  return false if a >= 100
  prime_factors = a.prime_division
  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_multiply_prime
    candidate = method(:is_multiply_prime)
    assert_equal(false, candidate.call(5))
    assert_equal(true, candidate.call(30))
    assert_equal(true, candidate.call(8))
    assert_equal(false, candidate.call(10))
    assert_equal(true, candidate.call(125))
    assert_equal(true, candidate.call(105))
    assert_equal(false, candidate.call(126))
    assert_equal(false, candidate.call(729))
    assert_equal(false, candidate.call(891))
    assert_equal(true, candidate.call(1001))
  end
end
"
HumanEval_76,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: x ⴷ ⵜⴰⵣⵎⵔⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⵎⴽ n**int=x ⵜⴰⵣⵎⵔⵜ ⵏ n ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ.ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⵔⵔⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ x ⵢⴰⵏ # >>> is_simple_power.call(1, 4)
# true
# >>> is_simple_power.call(2, 2)
# true
# >>> is_simple_power.call(8, 2)
# true
# >>> is_simple_power.call(3, 2)
# false
# >>> is_simple_power.call(3, 1)
# false
# >>> is_simple_power.call(5, 3)
# false
def is_simple_power(x, n)
","def is_simple_power(x, n)
  return false if x <= 0 || n <= 1
  return true if x == 1

  power = n
  while power <= x
    return true if power == x
    power *= n
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_simple_power
    candidate = method(:is_simple_power)
    assert_equal(true, candidate.call(16, 2))
    assert_equal(false, candidate.call(143214, 16))
    assert_equal(true, candidate.call(4, 2))
    assert_equal(true, candidate.call(9, 3))
    assert_equal(true, candidate.call(16, 4))
    assert_equal(false, candidate.call(24, 2))
    assert_equal(false, candidate.call(128, 4))
    assert_equal(false, candidate.call(12, 6))
    assert_equal(true, candidate.call(1, 1))
    assert_equal(true, candidate.call(1, 12))
  end
end
"
HumanEval_77,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵓⵉⵙⵙⴰⵎ: ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⴰⵜⵓⴰⵣⵋⴰⵎ ⴰⵙ ⵉⴾⵉ ⵏ ⴰⴾⴰⵉⴰⴷ ⵓⵍⴰⵗⴰⵏ ⵂⴰⵔⴾⵓⴾⵎⴽ ⵉⴳⴰ ⵡⵉⵏⴳⵉⵊⵔ ⴰⴷ ⴰⵎⴷⵢⴰ ⴰⵎⵖⴰⵔⴰⵏ ⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ a ⴰⵔ ⵉⵜⵜⴰⵊⵊⴰ ⵜⵉⴷⵜ # >>> iscube.call(1)
# true
# >>> iscube.call(2)
# false
# >>> iscube.call(-1)
# true
# >>> iscube.call(64)
# true
# >>> iscube.call(0)
# true
# >>> iscube.call(180)
# false
def iscube(a)
","def iscube(a)
  cube_root = a.abs**(1.0/3)
  cube_root.round**3 == a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_iscube
    candidate = method(:iscube)
    assert_equal(true, candidate.call(1))
    assert_equal(false, candidate.call(2))
    assert_equal(true, candidate.call(-1))
    assert_equal(true, candidate.call(64))
    assert_equal(false, candidate.call(180))
    assert_equal(true, candidate.call(1000))
    assert_equal(true, candidate.call(0))
    assert_equal(false, candidate.call(1729))
  end
end
"
HumanEval_78,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷ ⵉⵙⵎⴰⵡⵏ ⴰ,ⴱ,ⵙ,ⴷ,ⵢ,ⴼ ⴳⴰⵏ ⴰⵀⴰ ⵉⵎⵇⵔⴰⵏⵏ.ⵜⴰⵍⵖⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵉⵙ ⵉⴳⴰ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵀⴰ ⵉⴳⵏ ⴰⵣⵔⴼⴰⵏ ⵏⵖⴷ ⴰⵎⵙⴷⴷⵉ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⴱ (= ⴷⵢⵛⵉⵎⴰⵍ 11), ⴷ (= ⴷⵢⵛⵉⵎⴰⵍ 13).ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ⵡⵓⵟⵟⵓⵏ ⴰⴷ: 2, 3, 5, 7, ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳⴰⵏ 2, 3, 5, 7, 11, 13, 17...ⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵙⵡⴰⵜ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.ⵓⴳⴳⴰⵔ ⵏ 1 ⵓⵔ ⵉⴳⵉ ⴰⵎⵢⴰⴼⵓ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵔⴳⴰⵢⵏ ⵉⵎⵥⵥⵉⵏ).ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ (ⵉⴹ ⴰⵎⵣⵡⴰⵔⵓ, ⵏⵖⴷ ⴰⵎⵣⵡⴰⵔⵓ, ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵓⵟⵟⵓⵏ ⴰⵀⵉⵣⴰⴷⵉⵎⴰⵍ ⴰⵎⵎ ⵜⴰⴹⴰ ⴷ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵓⵟⵟⵓⵏ ⵏ ⵓⵟⵟⵓⵏ ⴰⵀⵉⵣⴰⴷⵉⵎⴰⵍ ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⴰⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ # >>> hex_key.call(""AB"")
# 1
# >>> hex_key.call(""1077E"")
# 2
# >>> hex_key.call(""ABED1A33"")
# 4
# >>> hex_key.call(""123456789ABCDEF0"")
# 6
# >>> hex_key.call(""2020"")
# 2
def hex_key(num)
","def hex_key(num)
  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']
  num.chars.count { |digit| prime_hex_digits.include?(digit) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_hex_key
    candidate = method(:hex_key)
    assert_equal(1, candidate.call(""AB""))
    assert_equal(2, candidate.call(""1077E""))
    assert_equal(4, candidate.call(""ABED1A33""))
    assert_equal(2, candidate.call(""2020""))
    assert_equal(6, candidate.call(""123456789ABCDEF0""))
    assert_equal(12, candidate.call(""112233445566778899AABBCCDDEEFF00""))
  end
end
"
HumanEval_79,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵉⵍⴰⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵓⴳⴳⴰⵔ ⴰⴼⴰⴷ ⴰⴷ ⵜⵜⵓⵙⵎⵔⴰⵙ ⵜⴰⵍⵖⴰ.ⵔⴰⴷ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ""db"" ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ ⵏ ⵜⵣⵍⵉⵜ.ⴽⵓ ⴰⵔⵉⵎ ⴳ ⵜⵣⵍⵉⵜ ⵔⴰⴷ ⵉⴳ ""0"" ⵏⵖ ""1"".ⵜⴰⵍⵖⴰ ⵏ ⵜⴱⵉⵏⴰⵔⵉⵜ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵡⵓⵔⵉ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ, ⴷ ⴽⵓ ⵉⵙⴽⴽⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴱⵉⵏⴰⵔⵉⵜ ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵜⴹⵉⵚⵜ ⴳ ⵜⴰⵍⵖⴰ ⵏ ⵜⴷⵉⵣⵎⵉⵜ ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⵜ ⵙ # >>> decimal_to_binary.call(15)
# ""db1111db""
# >>> decimal_to_binary.call(32)
# ""db100000db""
def decimal_to_binary(decimal)
","def decimal_to_binary(decimal)
  ""db"" + decimal.to_s(2) + ""db""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_decimal_to_binary
    candidate = method(:decimal_to_binary)
    assert_equal(""db0db"", candidate.call(0))
    assert_equal(""db100000db"", candidate.call(32))
    assert_equal(""db1100111db"", candidate.call(103))
    assert_equal(""db1111db"", candidate.call(15))
  end
end
"
HumanEval_80,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ "" haprb "" ⵎⴽ ⵉⴳⴰ ⵓⵖⵣⵉ ⵏⵏⵙ ⴽⵕⴰⴹ ⵓⴳⴳⴰⵔ ⴷ ⴽⵕⴰⴹⵜ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕⵉⵖ ⵉⵖ ⵜⴳⴰ ⵜⵣⵍⵉⵜ ⵜⴰⴷⵙⵍⴰⵏⵜ ⵏⵖ ⵓⵔ ⵜⵍⵍⵉ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ s.# >>> is_happy.call(""a"")
# false
# >>> is_happy.call(""aa"")
# false
# >>> is_happy.call(""abcd"")
# true
# >>> is_happy.call(""aabb"")
# false
# >>> is_happy.call(""adb"")
# true
# >>> is_happy.call(""xyy"")
# false
def is_happy(s)
","def is_happy(s)
  return false if s.length < 3
  
  (0..s.length - 3).each do |i|
    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]
  end
  
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_happy
    candidate = method(:is_happy)
    assert_equal(false, candidate.call(""a""))
    assert_equal(false, candidate.call(""aa""))
    assert_equal(true, candidate.call(""abcd""))
    assert_equal(false, candidate.call(""aabb""))
    assert_equal(true, candidate.call(""adb""))
    assert_equal(false, candidate.call(""xyy""))
    assert_equal(true, candidate.call(""iopaxpoi""))
    assert_equal(false, candidate.call(""iopaxioi""))
  end
end
"
HumanEval_81,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: 0.0 E > 0.0 ⴷ- > 0.7 D > 1.0 ⴷ+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 ⴱ- > 2.7 B > 3.0 ⴱ+ > 3.3 ⴰ- > 3.7 ⴰ 4.0 ⴰ+ GPA. ⴰⵍⴾⴰⴷ ⵏ ⵜⵉⴾⴰⵔⵙⵉⵓⴻⵏⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵥⴹⴰⵕⵏ ⴰⴷ ⵉⴼⴽ ⵜⴰⵡⵍⴰⴼⵜ ⵏ ⵡⴰⵏⴰⵡⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵙ ⵓⵙⵎⵔⵙ ⵏ ⵜⴼⵍⵡⵉⵜ ⴰⴷ: ⵜⴰⴾⴼⴰ-ⵛⴻ ⵉⴻ ⴰⴾⴰⵍ ⵏⴰⵛⴰⵍⴰ ⵜⴰⵏ ⵉⴻ ⵍⴰⴾⴰⴷⴰⵏ ⵉⵉⵉⴰⴷ ⴰⴷ ⵉⴶⵔⴰⵓ ⴰⴷ ⴰⴾⵜⴰⴱⵎⵓⵛⴰⴾⵉⵍ ⵓⴰ ⵉⵉⵉⴰⵏ ⴰⵎⵓⵙ ⴰⵙ ⵜⴰⴾⴼⴰ ⴰⵛⵓⵓⴷ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷⵆⵢⵍ ⴰⵍⵍⴰⵗⴰⵜ ⵓⴰ ⵉⵋⵋⴰⵏ ⴰⵍⵍⵗⵉⵙⴰⵔ ⴰⵍⴶⵂⵓⵔⵉⵜⵎ ⵏⵢⵜ ⵉ ⴰⴾⴾⴰⵉ ⵏ ⴰⵍⴾⴰⴷⴻⵈⴰⵍ ⴻⵎⴰⵉⵏⴰⴶ ⵓⴰ ⴷⴰⵔⴰⵎⴰⵏ ⴰⵏ ⵙⴻⵎⴻⵙⵜⴻⵔ ⴰⴷ ⵎⴰⴶⵔⴰⴷ ⵉⵍⴰ ⴰⴶⴰⵔⴰⵓ ⴰⵏ ⵜⵉⴾⴰⵔⵙⴻⵏ# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])
# [""A+"", ""B"", ""C-"", ""C"", ""A-""]
def numerical_letter_grade(grades)
","def numerical_letter_grade(grades)
  grades.map do |gpa|
    case 
    when gpa == 4.0
      ""A+""
    when gpa > 3.7
      ""A""
    when gpa > 3.3
      ""A-""
    when gpa > 3.0
      ""B+""
    when gpa > 2.7
      ""B""
    when gpa > 2.3
      ""B-""
    when gpa > 2.0
      ""C+""
    when gpa > 1.7
      ""C""
    when gpa > 1.3
      ""C-""
    when gpa > 1.0
      ""D+""
    when gpa > 0.7
      ""D""
    when gpa > 0.0
      ""D-""
    else
      ""E""
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_numerical_letter_grade
    candidate = method(:numerical_letter_grade)
    assert_equal([""A+"", ""B"", ""C-"", ""C"", ""A-""], candidate.call([4.0, 3, 1.7, 2, 3.5]))
    assert_equal([""D+""], candidate.call([1.2]))
    assert_equal([""D-""], candidate.call([0.5]))
    assert_equal([""E""], candidate.call([0.0]))
    assert_equal([""D"", ""D-"", ""C-"", ""B"", ""B+""], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))
    assert_equal([""E"", ""D-""], candidate.call([0.0, 0.7]))
  end
end
"
HumanEval_82,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵜⵉⵖⵣⵉ ⵜⴳⴰ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵖⴷ ⵜⵉⵔⵡⵉ ⵔⵉⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ ⴰⵔ ⵉⵜⵜⴰⵊⵊⴰ ⵜⵉⴷⵜ ⵎⴽ ⵜⴳⴰ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ # >>> prime_length.call(""Hello"")
# true
# >>> prime_length.call(""abcdcba"")
# true
# >>> prime_length.call(""kittens"")
# true
# >>> prime_length.call(""orange"")
# false
def prime_length(string)
","def prime_length(string)
  length = string.length
  return false if length < 2

  (2..Math.sqrt(length)).each do |i|
    return false if length % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_length
    candidate = method(:prime_length)
    assert_equal(true, candidate.call(""Hello""))
    assert_equal(true, candidate.call(""abcdcba""))
    assert_equal(true, candidate.call(""kittens""))
    assert_equal(false, candidate.call(""orange""))
    assert_equal(true, candidate.call(""wow""))
    assert_equal(true, candidate.call(""world""))
    assert_equal(true, candidate.call(""MadaM""))
    assert_equal(true, candidate.call(""Wow""))
    assert_equal(false, candidate.call(""""))
    assert_equal(true, candidate.call(""HI""))
    assert_equal(true, candidate.call(""go""))
    assert_equal(false, candidate.call(""gogo""))
    assert_equal(false, candidate.call(""aaaaaaaaaaaaaaa""))
    assert_equal(true, candidate.call(""Madam""))
    assert_equal(false, candidate.call(""M""))
    assert_equal(false, candidate.call(""0""))
  end
end
"
HumanEval_83,taq_Tfng,rb,"ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ ⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵏⵖⴷ ⵉⵎⵉⵔⴰⵢⵏ ⵙ 1.ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵏⵓⵍⴼⵓ ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ n def starts_one_ends(n)
","def starts_one_ends(n)
  return 0 if n <= 0

  # Count numbers starting with 1
  start_with_1 = 9 ** (n - 1)

  # Count numbers ending with 1
  end_with_1 = 9 ** (n - 1)

  # Adjust for double counting the number that both starts and ends with 1
  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1
  
  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_starts_one_ends
    candidate = method(:starts_one_ends)
    assert_equal(1, candidate.call(1))
    assert_equal(18, candidate.call(2))
    assert_equal(180, candidate.call(3))
    assert_equal(1800, candidate.call(4))
    assert_equal(18000, candidate.call(5))
  end
end
"
HumanEval_84,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ N, ⵙⵙⴽⵛⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⵙ ⵜⴱⵉⵏⴰⵔⵉⵜ. # >>> solve.call(1000)
# ""1""
# >>> solve.call(150)
# ""110""
# >>> solve.call(147)
# ""1100""
# Variables:
# @N integer
# Constraints: 0 ≤ N ≤ 10000.
# Output:
# a string of binary number
def solve(n)
","def solve(n)
  sum_of_digits = n.to_s.chars.map(&:to_i).sum
  sum_of_digits.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""1"", candidate.call(1000))
    assert_equal(""110"", candidate.call(150))
    assert_equal(""1100"", candidate.call(147))
    assert_equal(""1001"", candidate.call(333))
    assert_equal(""10010"", candidate.call(963))
  end
end
"
HumanEval_85,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵓⵙⵔⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⴷⴷⴰⵎⵏ, ⵣⵡⴰⵔ ⴰⴷ ⵏⵔⵏⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ.# >>> add.call([4, 2, 6, 7])
# 2
def add(lst)
","def add(lst)
  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(88, candidate.call([4, 88]))
    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))
    assert_equal(0, candidate.call([4, 0, 6, 7]))
    assert_equal(12, candidate.call([4, 4, 6, 8]))
  end
end
"
HumanEval_86,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴰⵜⵓⵉⵙⵙⴰⵏ: ⵉⵋⵋⴰⵛⵂ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏ ⴰⴾⴰⵔⴰⵛⵂ ⵏ ⵉⵙⵎⴰⵓⴰⵏ ⴷ ⵉⵂⴰⵏⴷⴰⴶⴰⵏ ⵓⵉⵏ ⴰⴱⴰⵔⴰ ⵜⴰⵏ ⴷⴰⵗ ⵜⴰⵗⵢⵍⵉⵜⴾⵢⵍ ⴰⴾⴰⵔⴰⵛⵂ ⵏ ⴰⵍⵈⵉⵎ ⵏ ⴰⵙⵛⵉⵉⴷⴰ ⵜⵜⵓⵙⵏⴼⴰⵍ ⵙ ⵜⴳⵓⵔⵉ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴳ  ⴰⵔ ⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳⵜⴰⵍⵖⴰ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵜⴳⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵍⵍⴰⵏⵜ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ (ⵜⵓⴱⴹⴰ ⵙ ⵓⵙⴰⵢⵔⴰⵔ) ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ.# >>> anti_shuffle.call(""Hi"")
# ""Hi""
# >>> anti_shuffle.call(""hello"")
# ""ehllo""
# >>> anti_shuffle.call(""Hello World!!!"")
# ""Hello !!!Wdlor""
def anti_shuffle(s)
","def anti_shuffle(s)
  s.split(/(\s+)/).map { |word| word.chars.sort.join }.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_anti_shuffle
    candidate = method(:anti_shuffle)
    assert_equal(""Hi"", candidate.call(""Hi""))
    assert_equal(""ehllo"", candidate.call(""hello""))
    assert_equal(""bemnru"", candidate.call(""number""))
    assert_equal(""abcd"", candidate.call(""abcd""))
    assert_equal(""Hello !!!Wdlor"", candidate.call(""Hello World!!!""))
    assert_equal("""", candidate.call(""""))
    assert_equal("".Hi My aemn is Meirst .Rboot How aer ?ouy"", candidate.call(""Hi. My name is Mister Robot. How are you?""))
  end
end
"
HumanEval_87,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵡⴷ, ⵙⵙⵓⴷⵙ ⴰⴽⵓⵓⵔⴷⵉⵏⴰⵜⵏ ⵏ ⵜⴰⴳⴳⴰⵢⵜ ⵙ ⵜⵔⵙⴰⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔ.ⴷⴰ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵙ ⵜⵉⵣⵡⵓⵔⵉ ⵙ ⵜⵉⵙⵉⴹⴼⵉⵏ ⵙ ⵓⵍⵜⵖ.ⴽⵓ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴳⴰ ⴽⵓⵓⵔⴷⵉⵏⴰⵜ - (ⵜⵉⵔⵉⵜ, ⵜⵉⵔⵙⴰⵍ), ⴰⵔⵜⴰⵉ ⵙ 0.ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴰ ⴰⵙⵔⴷⴰⵙ ⵏ ⵉⵙⵔⴷⴰⵙⵏ, [(x1, y1), (x2, y2) ...] ⵣⵓⵏⴷ ⵎⴰⵙ ⴳ ⵜⵉⴽⴽⵉ ⵏ lst, ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ x, ⵃⵜⵉⵜ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ x ⴳ ⵓⵎⵙⴳⵏⴰⴼ,ⴽⵓ ⵜⴰⵔⵙⵍⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⴰⴽⴽⴰ ⴰⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⵉⵣⵍⵉⵏ.ⴰⵢⴰ ⵢⴰⴽⵙⵓⵍ ⴷ ⵎⴰⵜⵔⵉⴽⵙ, ⵎⴰⵛⴰ ⵓⵔ ⵢⴰⴽⵙⵓⵍ ⴷ ⵎⴰⵜⵔⵉⴽⵙ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⵏⵖⵎⵉⵙⵏ ⵏ ⵙⵉⵏ ⵡⵓⴳⴳⵓⴳⵏ, ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵉⵎⵙⴷⴷⵉⵢⵏ ⵉⵎⵎⵔⵓⵔⵉⵏ, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
# >>> get_row.call([], 1)
# []
# >>> get_row.call([[], [1], [1, 2, 3]], 3)
# [[2, 2]]
def get_row(lst, x)
","def get_row(lst, x)
  result = []

  lst.each_with_index do |row, i|
    row.each_with_index do |value, j|
      result << [i, j] if value == x
    end
  end

  result.sort_by { |coord| [coord[0], -coord[1]] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_row
    candidate = method(:get_row)
    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))
    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([], candidate.call([], 1))
    assert_equal([], candidate.call([[1]], 2))
    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))
  end
end
"
HumanEval_88,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:* ⵓⵔ ⴷⴰ ⵏⵙⵙⵏⴼⵍ ⴰⵙⵔⴷⴰⵙ ⵉⵜⵜⵓⴼⴽⴰⵏ. ⴰⵜⵡⵉⵍ: ⵏⵖ ⴰⴷ ⵏⵙⵎⵓⵏ ⴳ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔ ⵉⵖ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵖⴰⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵖⴰⵍ ⴰⵎⴳⴳⴰⵔⵓ.ⵔⴰⴷ ⵜⵙⵏⵙⵉ ⵉⵎⵙⴷⴷⵉ ⵏ ⵓⵎⵙⴳⴷⴰⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵙⵙⵓ ⵉⴳ ⵜⵍⵍⴰ ⵜⴳⵔⵓⵎⵎⴰ ((ⵜⵉⴳⵉ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵉⴹⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵉⴹⵏ ⴰⵎⴳⴳⴰⵔⵓ) ⵓⵔ ⵉⴳⵉⵏ, ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵎⵙⴷⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵕⵥⵥⴰⵏⵏ, # >>> sort_array.call([])
# []
# >>> sort_array.call([5])
# [5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5])
# [0, 1, 2, 3, 4, 5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])
# [6, 5, 4, 3, 2, 1, 0]
def sort_array(array)
","def sort_array(array)
  return array if array.empty? || array.size == 1

  if (array.first + array.last).odd?
    array.sort
  else
    array.sort.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([], candidate.call([]))
    assert_equal([5], candidate.call([5]))
    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))
    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))
    assert_equal([1, 2], candidate.call([2, 1]))
    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))
    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))
  end
end
"
HumanEval_89,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴰⴷⴷⵓⵙ ⵙ ⵙⵉⵏ ⵉⴽⴼⵓⴷⵏ ⵙ ⵙⵏⴰⵜ ⵜⵉⵖⴰⵔⵉⵡⵉⵏ.ⵉⵇⵏⴻⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⴰⵍ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵔⴰⵏⵜ ⵜⴱⵔⵔⴰⵜⵉⵏ ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵜⵜⵓⵃⴹⴰⵏ ⵙ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ.ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵏⴼⵍⵍⵓⵍ ⵏⵏⴰ ⵉⵜⵜⴰⵙⵉⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵎⵎ ⵓⵎⴳⵔⴰⴷ ⴷ # >>> encrypt.call(""hi"")
# ""lm""
# >>> encrypt.call(""asdfghjkl"")
# ""ewhjklnop""
# >>> encrypt.call(""gf"")
# ""kj""
# >>> encrypt.call(""et"")
# ""ix""
def encrypt(s)
","def encrypt(s)
  s.chars.map do |char|
    if char =~ /[a-z]/
      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr
    elsif char =~ /[A-Z]/
      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr
    else
      char
    end
  end.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encrypt
    candidate = method(:encrypt)
    assert_equal(""lm"", candidate.call(""hi""))
    assert_equal(""ewhjklnop"", candidate.call(""asdfghjkl""))
    assert_equal(""kj"", candidate.call(""gf""))
    assert_equal(""ix"", candidate.call(""et""))
    assert_equal(""jeiajeaijeiak"", candidate.call(""faewfawefaewg""))
    assert_equal(""lippsqcjvmirh"", candidate.call(""hellomyfriend""))
    assert_equal(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"", candidate.call(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""))
    assert_equal(""e"", candidate.call(""a""))
  end
end
"
HumanEval_90,taq_Tfng,rb,"ⵔⵉⵜⵓⵔⵏ ⵏⵉⵍ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ.ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ next_smallest (() ⵏⵏⴰ ⵉⵙⴽⵔⵏ ⵜⵉⴽⴽⵍⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⴳ ⵉⵎⵥⵥⵢⴰⵏ ⵏ ⵓⵎⵙⴳⵏⴰⴼ. ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.# >>> next_smallest.call([1, 2, 3, 4, 5])
# 2
# >>> next_smallest.call([5, 1, 4, 3, 2])
# 2
# >>> next_smallest.call([])
# nil
# >>> next_smallest.call([1, 1])
# nil
def next_smallest(lst)
","def next_smallest(lst)
  unique_sorted = lst.uniq.sort
  unique_sorted.length >= 2 ? unique_sorted[1] : nil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_next_smallest
    candidate = method(:next_smallest)
    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))
    assert_equal(nil, candidate.call([]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(-35, candidate.call([-35, 34, 12, -45]))
  end
end
"
HumanEval_91,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵜⵉⴼⵔⴰⵙ ⴰⵜ-ⵓ-ⴰⵗⴱⴰⵍ ⵏⴰⵜ ⵙ """", ""?"" ⵎⵢⵗ ""!""""ⵜⵉⵎⵙⵓⵜⴰ"" ⵜⴰⵈⵈⴰⵍ ⵜⴰⵗⵉⵍⵉⵜ ⵜⵉⵙⵙⵉⵏⵜⴰ ⵙ ⵉⵙⵉⵎ ⵓⴰⵏ ""I""ⴰⴷ ⴰⵜⵓⴰⴾⴰⵙⴰⵏ ⵜⴰⴱⴰⵔⴰⵜ ⴰⵏ ⵎⴰⴶⵔⴰⴷ, ⴰⴷ ⴰⵛⴰⵆⵉⵍ ⴰⵏⴻⵙ ⴰⴷ ⴰⵉⴶⵉ ⴰⵏ ⵎⴰⴶⵔⴰⴷ.# >>> is_bored.call(""Hello world"")
# 0
# >>> is_bored.call(""The sky is blue. The sun is shining. I love this weather"")
# 1
def is_bored(s)
","def is_bored(s)
  sentences = s.split(/(?<=[.?!])/)
  sentences.count { |sentence| sentence.strip.start_with?('I') }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_bored
    candidate = method(:is_bored)
    assert_equal(0, candidate.call(""Hello world""))
    assert_equal(0, candidate.call(""Is the sky blue?""))
    assert_equal(1, candidate.call(""I love It !""))
    assert_equal(0, candidate.call(""bIt""))
    assert_equal(2, candidate.call(""I feel good today. I will be productive. will kill It""))
    assert_equal(0, candidate.call(""You and I are going for a walk""))
  end
end
"
HumanEval_92,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴼⵉⵔⴰⵙ ⵜⵉⵣⴳⴰⵍⵉⵏ ⴳ ⴽⵔⴰ ⵏ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ.ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵢⴰⵏ ⴳ ⵡⵓⵟⵟⵓⵏⵏ ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵢⴰⴹⵏ, ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⴽⴽⵡ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ.# >>> any_int.call(5, 2, 7)
# true
# >>> any_int.call(3, 2, 2)
# false
# >>> any_int.call(3, -2, 1)
# true
# >>> any_int.call(3.6, -2.2, 2)
# false
def any_int(x, y, z)
","def any_int(x, y, z)
  if [x, y, z].all? { |n| n.is_a?(Integer) }
    x == y + z || y == x + z || z == x + y
  else
    false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_any_int
    candidate = method(:any_int)
    assert_equal(true, candidate.call(2, 3, 1))
    assert_equal(false, candidate.call(2.5, 2, 3))
    assert_equal(false, candidate.call(1.5, 5, 3.5))
    assert_equal(false, candidate.call(2, 6, 2))
    assert_equal(true, candidate.call(4, 2, 2))
    assert_equal(false, candidate.call(2.2, 2.2, 2.2))
    assert_equal(true, candidate.call(-4, 6, 2))
    assert_equal(true, candidate.call(2, 1, 1))
    assert_equal(true, candidate.call(3, 4, 7))
    assert_equal(false, candidate.call(3.0, 4, 7))
  end
end
"
HumanEval_93,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⵂⴰ ⴰⴷ ⴰⴾⵜⴰⴱⴰⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏⴰⵛⵛⵉⵍ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵓⴰⵏ ⴰⵏⴶⵍⵉⵣⵜⴰⴱⵔⴰⵜ ⵙ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵜⵜⵉⵍⵉⵏ ⵙⵏⴰⵜ ⵏ ⵡⴰⵏⵙⴰⵢⵏ ⴷⴰⵜ ⵏ ⵜⴱⵔⴰⵜ ⴷⴰ ⵉⵜⵜⵎⵓⵜⵜⴰⵢ ⵡⴰⵏⴰⵡ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⴷⴰ ⵉⵜⵜⵎⵓⵜⵜⴰⵢ ⴽⵓⵍⵍⵓ ⵉⵎⵙⵍⵉ ⴳ ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⴰⵔ ⵉⵜⵜⵓⵣⵎⵎⴻⵎ ⴳ # >>> encode.call(""test"")
# ""TGST""
# >>> encode.call(""This is a message"")
# ""tHKS KS C MGSSCGG""
def encode(message)
","def encode(message)
  vowels = 'aeiou'
  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}
  
  encoded_message = message.chars.map do |char|
    if vowels.include?(char.downcase)
      new_char = swap_vowels[char.downcase]
      char == char.upcase ? new_char.upcase : new_char.downcase
    else
      char == char.upcase ? char.downcase : char.upcase
    end
  end

  encoded_message.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encode
    candidate = method(:encode)
    assert_equal(""tgst"", candidate.call(""TEST""))
    assert_equal(""mWDCSKR"", candidate.call(""Mudasir""))
    assert_equal(""ygs"", candidate.call(""YES""))
    assert_equal(""tHKS KS C MGSSCGG"", candidate.call(""This is a message""))
    assert_equal(""k dQnT kNqW wHcT Tq wRkTg"", candidate.call(""I DoNt KnOw WhAt tO WrItE""))
  end
end
"
HumanEval_94,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⴼ ⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ, ⴷ ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
# 10
# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
# 25
# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
# 13
# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
# 11
# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])
# 3
# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])
# 7
def skjkasdkd(lst)
","def skjkasdkd(lst)
  require 'prime'

  # Find the largest prime number in the array
  largest_prime = lst.select { |num| Prime.prime?(num) }.max
  
  # Return 0 if no prime number is found
  return 0 if largest_prime.nil?

  # Calculate the sum of digits of the largest prime number
  largest_prime.to_s.chars.map(&:to_i).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_skjkasdkd
    candidate = method(:skjkasdkd)
    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))
    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))
    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))
    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))
    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))
    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))
    assert_equal(19, candidate.call([8191]))
    assert_equal(19, candidate.call([8191, 123456, 127, 7]))
    assert_equal(10, candidate.call([127, 97, 8192]))
  end
end
"
HumanEval_95,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵀⴰⵜ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵏ ⵜⵉⵣⴳⵉⵍⵜ ⵉⴳ ⵉⵍⵍⴰ ⵓⵃⴰⵛ ⵉⵜⵜⵓⴼⴽⴰⵏ.ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴽⵓⵍⵍⵓ ⵉⵙⵍⴽⵉⵏ ⵜⵉⵙⴳⵓⵔⵉⵡⵉⵏ ⴳ ⵜⵉⵙⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵅⴰⵜⴰⵔⵉⵏ, ⵔⴰⴷ ⵢⴰⴽⵡⵣ false.ⵉⴳ ⴷⴰⵔⴽ ⵉⵙⵎ ⵏ ⵓⵛⵛⵉ, ⵙⵓⵍ ⵉⴽⴼⵉⴷ ⵜⵉⴷⵜ ⵎⴽ ⴳⴰⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵍⴽⵉⵏ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⴳ ⵍⵉⵙⵜⵔⴰⵔ # >>> check_dict_case.call({""a"" => ""apple"", ""b"" => ""banana""})
# true
# >>> check_dict_case.call({""a"" => ""apple"", ""A"" => ""banana"", ""B"" => ""banana""})
# false
# >>> check_dict_case.call({""a"" => ""apple"", 8 => ""banana"", ""a"" => ""apple""})
# false
# >>> check_dict_case.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""})
# false
# >>> check_dict_case.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""})
# true
def check_dict_case(dict)
","def check_dict_case(dict)
  return false if dict.empty?

  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }
  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }

  lowercase_keys || uppercase_keys
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_dict_case
    candidate = method(:check_dict_case)
    assert_equal(true, candidate.call({""p"" => ""pineapple"", ""b"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""A"" => ""banana"", ""B"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""5"" => ""banana"", ""a"" => ""apple""}))
    assert_equal(false, candidate.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""}))
    assert_equal(true, candidate.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""}))
    assert_equal(true, candidate.call({""fruit"" => ""Orange"", ""taste"" => ""Sweet""}))
    assert_equal(false, candidate.call({}))
  end
end
"
HumanEval_96,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵡⵉⵏ ⵡⴰⵔ n. ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⴳⵉⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵎⵙⴳⴷⴰⵍ ⵏ ⵉⵎⵉⴹⵏ ⵉⵎⵣⵡⵓⵔⴰ n # >>> count_up_to.call(5)
# [2, 3]
# >>> count_up_to.call(11)
# [2, 3, 5, 7]
# >>> count_up_to.call(0)
# []
# >>> count_up_to.call(20)
# [2, 3, 5, 7, 11, 13, 17, 19]
# >>> count_up_to.call(1)
# []
# >>> count_up_to.call(18)
# [2, 3, 5, 7, 11, 13, 17]
def count_up_to(n)
","def count_up_to(n)
  return [] if n <= 2
  primes = []
  (2...n).each do |num|
    is_prime = true
    (2..Math.sqrt(num)).each do |i|
      if num % i == 0
        is_prime = false
        break
      end
    end
    primes << num if is_prime
  end
  primes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_up_to
    candidate = method(:count_up_to)
    assert_equal([2, 3], candidate.call(5))
    assert_equal([2, 3, 5], candidate.call(6))
    assert_equal([2, 3, 5], candidate.call(7))
    assert_equal([2, 3, 5, 7], candidate.call(10))
    assert_equal([], candidate.call(0))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))
    assert_equal([], candidate.call(1))
    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))
  end
end
"
HumanEval_97,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵉⵏⴰⵣⴶⴰⵎ ⴰⵙ ⵉⴾⵉ ⵏⴰⴾⴰⵛⴰⴷ ⴰⵈⴰⵍ ⴰⴶⵓⴷⵉⵉⴰⵏ ⴰⵗⴰⵍ.ⴰⵎⵢⴰⴼⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏⵏⵙⵏ.ⵜⵢⵎⵎⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ # >>> multiply.call(148, 412)
# 16
# >>> multiply.call(19, 28)
# 72
# >>> multiply.call(2020, 1851)
# 0
# >>> multiply.call(14, -15)
# 20
def multiply(a, b)
","def multiply(a, b)
  a_unit_digit = a.abs % 10
  b_unit_digit = b.abs % 10
  a_unit_digit * b_unit_digit
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_multiply
    candidate = method(:multiply)
    assert_equal(16, candidate.call(148, 412))
    assert_equal(72, candidate.call(19, 28))
    assert_equal(0, candidate.call(2020, 1851))
    assert_equal(20, candidate.call(14, -15))
    assert_equal(42, candidate.call(76, 67))
    assert_equal(49, candidate.call(17, 27))
    assert_equal(0, candidate.call(0, 1))
    assert_equal(0, candidate.call(0, 0))
  end
end
"
HumanEval_98,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵙ ⵜⵉⴼⵉⴼⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ s, ⵔⵎⵙⵏ ⴰⵎⴹⴰⵏ ⵏ ⵉⵎⵙⵍⵉⵢⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. # >>> count_upper.call(""aBCdEf"")
# 1
# >>> count_upper.call(""abcdefg"")
# 0
# >>> count_upper.call(""dBBE"")
# 0
def count_upper(s)
","def count_upper(s)
  vowels = ['A', 'E', 'I', 'O', 'U']
  count = 0

  s.chars.each_with_index do |char, index|
    if index.even? && vowels.include?(char)
      count += 1
    end
  end

  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_upper
    candidate = method(:count_upper)
    assert_equal(1, candidate.call(""aBCdEf""))
    assert_equal(0, candidate.call(""abcdefg""))
    assert_equal(0, candidate.call(""dBBE""))
    assert_equal(0, candidate.call(""B""))
    assert_equal(1, candidate.call(""U""))
    assert_equal(0, candidate.call(""""))
    assert_equal(2, candidate.call(""EEEE""))
  end
end
"
HumanEval_99,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵙⴳ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵓⵏ ⵙⴳ ⵓⵎⵢⴰ.ⴰⵔ ⵉⵜⵜⴰⴷⴼ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵉⵔⵉⵡ ⴰⴽⴽⵡ ⵉⵎⵉⵔⵉⵡⵏ. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵉⵔⵉⵡ ⴰⵎⵣⴰⵔⴰⵢ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵡⴰⵜⵉⴳ (ⵜⴰⵙⵉⵔⵜ) ⵉⵙⵎⴷⵢⴰⵏ ⴰⵎⴹⴰⵏ # >>> closest_integer.call(""10"")
# 10
# >>> closest_integer.call(""15.3"")
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer(""14.5"") should
# return 15 and closest_integer(""-14.5"") should return -15.
def closest_integer(value)
","def closest_integer(value)
  number = value.to_f
  if number > 0
    (number + 0.5).floor
  else
    (number - 0.5).ceil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_closest_integer
    candidate = method(:closest_integer)
    assert_equal(10, candidate.call(""10""))
    assert_equal(15, candidate.call(""14.5""))
    assert_equal(-16, candidate.call(""-15.5""))
    assert_equal(15, candidate.call(""15.3""))
    assert_equal(0, candidate.call(""0""))
  end
end
"
HumanEval_100,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:i ⴰⵎⵓⵙ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⵉⵂⵓⴾⴰⵏ ⴷⴰⵗ ⵢⴷⴰⴶ ⵓⴰⵏ (ⵉ+1)ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵓⵟⵟⵓⵏ ⵏ ⵉⵃⵔⵉⵜⵏ ⴳ ⴽⵓ ⴰⵙⵡⵉⵔ ⴳ ⵓⵎⵙⴳⵏⴰⴼ, ⴳ ⵉⵍⵍⴰ ⵓⵏⴰⵎⴽ ⴳ ⵓⵙⵏⵎⵍ - ⴰⵎⴹⴰⵏ ⴰⵎⵎⵓⵟⵟⵓⵏ ⴰⵎⵎⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵉⴳ n ⴰⵎⵎⵓⵟⵟⵓⵏ. - ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⵉⴳ n ⴰⵎⵣⴰⵔⴰⵢ. ⵓⵉ-ⴷ-ⵉⵍⵍⴰⵏ ⴷⴰⵗ ⵜⴰⵂⵔⵉⴾⴻ ⵜⴰⵏ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⴰⵎⵓⵙⴰⵏ:ⴰⵙⵉⵔⵜⴰⵉ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏ ⵉⵍⴰ N ⵉⵂⴰⵏⴷⴰⴶⴰⵏⵎⴽ ⴷ ⵢⴰⴽⴽⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵏ n ⵉⵙⵡⵉⵔⵏ ⵏ ⵉⵅⵅⴰⵏⵏ.# >>> make_a_pile.call(3)
# [3, 5, 7]
def make_a_pile(n)
","def make_a_pile(n)
  result = []
  current_stones = n
  n.times do
    result << current_stones
    current_stones += 2
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_a_pile
    candidate = method(:make_a_pile)
    assert_equal([3, 5, 7], candidate.call(3))
    assert_equal([4, 6, 8, 10], candidate.call(4))
    assert_equal([5, 7, 9, 11, 13], candidate.call(5))
    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))
    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))
  end
end
"
HumanEval_101,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴰⴷ ⵜⴱⴹⵓ ⵜⵉⴼⵉⵏⴰⵖ ⵖⵔ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ.ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵈⵈⵉⵍ ⴾⵢⵍ ⵉⵙⵎⴰⵓⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ ⵉⵋⵋⴰⵏⵢⵏ ⵙ ⵛⵓⵎⴰ ⵜⴰⵏ ⵎⵢⵗ ⵙⴱⵢⵛⵢⵙ ⵜⴰⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ# >>> words_string.call(""Hi, my name is John"")
# [""Hi"", ""my"", ""name"", ""is"", ""John""]
# >>> words_string.call(""One, two, three, four, five, six"")
# [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
def words_string(s)
","def words_string(s)
  s.split(/[\s,]+/)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_string
    candidate = method(:words_string)
    assert_equal([""Hi"", ""my"", ""name"", ""is"", ""John""], candidate.call(""Hi, my name is John""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One, two, three, four, five, six""))
    assert_equal([""Hi"", ""my"", ""name""], candidate.call(""Hi, my name""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One,, two, three, four, five, six,""))
    assert_equal([], candidate.call(""""))
    assert_equal([""ahmed"", ""gamal""], candidate.call(""ahmed     , gamal""))
  end
end
"
HumanEval_102,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵓⵔ ⵉⵍⵍⵉ ⵡⵓⵟⵟⵓⵏ ⴰⴷ, ⵇⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ -1.ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵇⵇⵔⴰⵏ ⴳ ⵓⵎⵣⴰⵔⴰⵢ [x, y] ⴳ ⵜⵓⵎⵣⵉⵏ. ⵎⴽ ⴷⴰ ⵜⴽⴽⴰ ⵜⵎⵔⵙⵜ ⴰⴷ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵃⵍⴰⵏ x ⴷ y ⴰⵔ ⵜⵔⴰⵔ # >>> choose_num.call(12, 15)
# 14
# >>> choose_num.call(13, 12)
# -1
def choose_num(x, y)
","def choose_num(x, y)
  return -1 if x > y
  # Start looking from the largest number
  max_even = y.even? ? y : y - 1
  # Iterate downwards to find the biggest even number
  max_even.downto(x) do |n|
    return n if n.even?
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_choose_num
    candidate = method(:choose_num)
    assert_equal(14, candidate.call(12, 15))
    assert_equal(-1, candidate.call(13, 12))
    assert_equal(12354, candidate.call(33, 12354))
    assert_equal(-1, candidate.call(5234, 5233))
    assert_equal(28, candidate.call(6, 29))
    assert_equal(-1, candidate.call(27, 10))
    assert_equal(-1, candidate.call(7, 7))
    assert_equal(546, candidate.call(546, 546))
  end
end
"
HumanEval_103,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵎⴽ ⵜⴳⴰ n ⴰⵅⴰⵜⴰⵔ ⵙⴳ m, ⵔⵔⵓⵜⵓⵔ -1.ⵔⵓⵏⴷ ⵜⵔⴰⵔⵓⵜ ⵖⵔ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵉⴹⴰⵏ ⴷ ⵜⵙⵏⴼⵍ ⵖⵔ ⴱⵉⵏⴰⵔⵉ.ⴰⵎⵎⴰⵙⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙⴳ n ⴰⵔ m (ⴰⵎⵓⵏ ⴷ n ⴷ m).ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ n ⴷ m, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ # >>> rounded_avg.call(1, 5)
# ""0b11""
# >>> rounded_avg.call(7, 5)
# -1
# >>> rounded_avg.call(10, 20)
# ""0b1111""
# >>> rounded_avg.call(20, 33)
# ""0b11010""
def rounded_avg(n, m)
","def rounded_avg(n, m)
  return -1 if n > m

  sum = (n..m).reduce(:+)
  count = m - n + 1
  average = (sum.to_f / count).round
  ""0b"" + average.to_i.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rounded_avg
    candidate = method(:rounded_avg)
    assert_equal(""0b11"", candidate.call(1, 5))
    assert_equal(""0b1010"", candidate.call(7, 13))
    assert_equal(""0b1111001010"", candidate.call(964, 977))
    assert_equal(""0b1111100100"", candidate.call(996, 997))
    assert_equal(""0b1011000010"", candidate.call(560, 851))
    assert_equal(""0b101101110"", candidate.call(185, 546))
    assert_equal(""0b110101101"", candidate.call(362, 496))
    assert_equal(""0b1001110010"", candidate.call(350, 902))
    assert_equal(""0b11010111"", candidate.call(197, 233))
    assert_equal(-1, candidate.call(7, 5))
    assert_equal(-1, candidate.call(5, 1))
    assert_equal(""0b101"", candidate.call(5, 5))
  end
end
"
HumanEval_104,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵜⴰⵍⵖⴰ: ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵉⵎⵙⴷⴷⵉⵢⵏ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⵓⵢⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ.ⵉⴼⵔⴷⵉⵙⵏ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ.ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵙⵡⴰⵜⵏ x, ⵔⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ # >>> unique_digits.call([15, 33, 1422, 1])
# [1, 15, 33]
# >>> unique_digits.call([152, 323, 1422, 10])
# []
def unique_digits(x)
","def unique_digits(x)
  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique_digits
    candidate = method(:unique_digits)
    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))
    assert_equal([], candidate.call([152, 323, 1422, 10]))
    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))
    assert_equal([31, 135], candidate.call([135, 103, 31]))
  end
end
"
HumanEval_105,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ""ⵢⵉⴰⵏ"", ""ⵉⵏⵏⴰ"", ""ⵜⵕⴰⴹ"", ""ⴽⵓⵥ"", ""ⵎⵎⵓⵙ"", ""ⵙⴹⵉⵙ"", ""ⴰⵙⵙⴰ"", ""ⵜⴰⵎⵔⴰⵡ"". ⵔⵔⵣⵓ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵉⵜⵜⵓⵙⵢⴰⴼⴰⵏ, ⴷ ⴷⴼⴼⵉⵔ ⴰⴷ ⵙⵎⵓⵜⵜⵔ ⴽⵓ ⵓⴽⵕⴹ ⵙ ⵢⵉⵙⵎ ⵏⵏⵙ ⵙⴳ ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵙ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵜⴰⵎⵎ ⵏⵙⵏ, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])
# [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
# If the array is empty, return an empty array:
# >>> by_length.call([])
# []
# If the array has any strange number ignore it:
# >>> by_length.call([1, -1, 55])
# [""One""]
def by_length(arr)
","def by_length(arr)
  number_names = {
    1 => ""One"",
    2 => ""Two"",
    3 => ""Three"",
    4 => ""Four"",
    5 => ""Five"",
    6 => ""Six"",
    7 => ""Seven"",
    8 => ""Eight"",
    9 => ""Nine""
  }

  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse
  filtered_sorted_reversed.map { |num| number_names[num] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_by_length
    candidate = method(:by_length)
    assert_equal([""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([""One""], candidate.call([1, -1, 55]))
    assert_equal([""Three"", ""Two"", ""One""], candidate.call([1, -1, 3, 2]))
    assert_equal([""Nine"", ""Eight"", ""Four""], candidate.call([9, 4, 8]))
  end
end
"
HumanEval_106,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵉⴳⴰ ⵓⴼⴰⴽⵜⵓⵔⵢⴰⵍ ⵏ ""ⵉ"" ⴰⵙⴼⵓⴽⵍⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ ""ⵉ"" (1 * 2 * ... * ""ⵉ"").ⵔⴰⴷ ⵙⵏⵜⵉ ⵙⴳ 1.ⵏⵖⴷ ⵜⴳⵎⵉⴹⵉ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ i. ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ n, ⵣⵓⵏⴷ ⵎⴰⵙⴷ ⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵙⵖⵍ ""ⵉ"" ⵉⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ""ⵉ"" ⵎⴽ ⵜⴳⴰ ""ⵉ"" ⵙⵙⵎⵔⵙ ⵜⴰⵡⵓⵔⵉ f ⵏⵏⴰ ⵢⵓⵎⵥⵏ n ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ, # >>> f.call(5)
# [1, 2, 6, 24, 15]
def f(n)
","def f(n)
  (1..n).map do |i|
    if i.even?
      (1..i).inject(:*) || 1
    else
      (1..i).inject(:+)
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_f
    candidate = method(:f)
    assert_equal([1, 2, 6, 24, 15], candidate.call(5))
    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))
    assert_equal([1], candidate.call(1))
    assert_equal([1, 2, 6], candidate.call(3))
  end
end
"
HumanEval_107,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ 1:ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵜⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵎⵎⴰⵙ ((1, n), ⴳ ⵜⴰⵎⵎⵏⵜ.ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵎⵔⵉⵏⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ # >>> even_odd_palindrome.call(3)
# [1, 2]
# Explanation:
# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome.call(12)
# [4, 6]
# Explanation:
# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
# 1. 1 <= n <= 10^3
# 2. returned array has the number of even and odd integer palindromes respectively.
def even_odd_palindrome(n)
","def even_odd_palindrome(n)
  even_count = 0
  odd_count = 0

  (1..n).each do |num|
    if num.to_s == num.to_s.reverse
      if num.even?
        even_count += 1
      else
        odd_count += 1
      end
    end
  end

  [even_count, odd_count]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_palindrome
    candidate = method(:even_odd_palindrome)
    assert_equal([8, 13], candidate.call(123))
    assert_equal([4, 6], candidate.call(12))
    assert_equal([1, 2], candidate.call(3))
    assert_equal([6, 8], candidate.call(63))
    assert_equal([5, 6], candidate.call(25))
    assert_equal([4, 6], candidate.call(19))
    assert_equal([4, 5], candidate.call(9))
    assert_equal([0, 1], candidate.call(1))
  end
end
"
HumanEval_108,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ -123 ⵉⵍⴰ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ -1, 2, ⴷ 3. ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⴳⵓⵔ, ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⵙ ⴰⵎⴳⵓⵔ:ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ > 0. ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ count_nums ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴰ # >>> count_nums.call([])
# 0
# >>> count_nums.call([-1, 11, -11])
# 1
# >>> count_nums.call([1, 1, 2])
# 3
def count_nums(arr)
","def count_nums(arr)
  arr.count do |num|
    num.to_s.chars.map(&:to_i).sum > 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_nums
    candidate = method(:count_nums)
    assert_equal(0, candidate.call([]))
    assert_equal(0, candidate.call([-1, -2, 0]))
    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))
    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))
    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))
    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))
    assert_equal(1, candidate.call([0, 1]))
    assert_equal(1, candidate.call([1]))
  end
end
"
HumanEval_109,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵜⴰⵍⵖⴰ: ⴷⴰ ⵉⵜⵜⵓⵙⴷⴷⴰ ⵎⴰⵙ ⴷⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵥⵍⴰⵢⵏ.ⵎⴽ ⵜⴳⴰ ⵜⵔⴰⴱⴱⵓⵜ ⵜⴰⵡⴼⵔⴰⵏⵜ ⵜⵍⵍⵓⵍⴷ, ⴹⴰⵕⵜ ⵓⵢⴰ ⵔⴰⴷ ⴷ-ⵜⵓⵖⴰⵍ ⵜⵉⴷⵜ ⵏⵖ ⵔⴰⴷ ⴷ-ⵜⵓⵖⴰⵍ ⵜⵉⴱⵔⵙⴳⴳⵡⴰⴷⵜ.ⵉⵖ ⵜⵣⵎⵔⵎ ⴰⴷ ⵜⴰⵡⵉⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵜⵉⴳⴳⵉⵜ ⵏ ⵜⵎⵙⴽⵔⵜ ⵏⵏⵉⴳ ⵏ ⵓⵢⴰ ⵜⵉⴷⴷⴰⴷⵜ ⵏ ⵓⵙⵙⵏⵜⵉ ⴳ ⵓⵎⵙⴳⵏⴰⴼ, ⵉⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵡⵉⵙⵙ 0.ⵔⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵏⴰⵡ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵜⵉⴳⴳⵉⵜ ⵏ ⵓⵙⵙⴼⵍⴷ ⵙ ⵓⵣⵔⴼ ⵜⵔⵏⴰ ⴰⵙⴼⵍⴷ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵢⴰⵏ.ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵜⵉⴳⴳⵉⵜ ⵏ ⵓⵙⵏⴼⵍ ⵙ ⵓⵣⵔⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ.ⵜⵉⴳⴳⵉⵜ ⴰⴷ ⵅⴼ ⵓⵎⵙⴳⵏⴰⴼ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ: ⵉⵖⵢ ⴰⴷ ⵏⵙⵎⵓⵏ ⵜⴰⵔⵔⴰⵢⵜ ⵙ ⵓⵍⵓⴳ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵔⵔⵓⴽ ⵙ ⵜⴽⴰⵔⴹⴰ ⵏ ⵔⴰⴷ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵜ ⵉⵎⴹⴰⵏ ⴳ ⵓⵎⵙⴰⵙⴰ ⵙ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⴽⵙⵍ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴰⵙ ⵖⵓⵔⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ 'ⴰⵔⵔ' ⵏ N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ arr[1], arr[2], ..., arr[N].# >>> move_one_ball.call([3, 4, 5, 1, 2])
# true
# Explanation: By performin 2 right shift operations, non-decreasing order can
# be achieved for the given array.
# >>> move_one_ball.call([3, 5, 4, 1, 2])
# false
# Explanation:It is not possible to get non-decreasing order for the given
# array by performing any number of right shift operations.
def move_one_ball(arr)
","def move_one_ball(arr)
  return true if arr.empty?

  n = arr.size
  count_rotation_point = 0
  rotation_index = -1

  (0...n).each do |i|
    next_index = (i + 1) % n
    if arr[i] > arr[next_index]
      count_rotation_point += 1
      rotation_index = next_index
    end
  end

  count_rotation_point <= 1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_move_one_ball
    candidate = method(:move_one_ball)
    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))
    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))
    assert_equal(false, candidate.call([4, 3, 1, 2]))
    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))
    assert_equal(true, candidate.call([]))
  end
end
"
HumanEval_110,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ, ⵙⵓⵍ ""ⵓⵀⵓ"".ⵎⴰⵔ ⴰⴷ ⴳⵉⵏ ⴰⴽⴽⵡ ⵉⴼⵔⴷⵉⵙⵏ ⵏ lst1 ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵙⵙⴽⵔ ""YES"".ⵉⵖ ⵜⵣⵎⵔⵎ ⴰⴷ ⵏⵙⵎⵓⵜⵜⵔ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔ lst1 ⴷ lst2 ⵃⵎⴰ ⴰⴷ ⵏⵙⴽⵔ ⵓⵔ ⵉⵍⵍⵉ ⵓⵜⵜⵓ ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴳⵔ lst1 ⴷ lst2.ⵔⴰⵔⵏ ⴰⵙⵏⵙⵍ ⵏ LST1 ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⵡⵉⵏ ⴷ ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⵎⴰⵢⴷ ⵉⵥⴹⴰⵕ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵜⵎⵓⴽⵔⵉⵙⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])
# ""YES""
# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])
# ""NO""
# It is assumed that the input arrays will be non-empty.
def exchange(lst1, lst2)
","def exchange(lst1, lst2)
  # Check if lst1 already consists solely of even numbers
  return ""YES"" if lst1.all?(&:even?)

  # Check if there are at least as many even numbers in lst2
  # as there are odd numbers in lst1
  odd_count_lst1 = lst1.count(&:odd?)
  even_count_lst2 = lst2.count(&:even?)

  odd_count_lst1 <= even_count_lst2 ? ""YES"" : ""NO""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_exchange
    candidate = method(:exchange)
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))
    assert_equal(""NO"", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))
    assert_equal(""YES"", candidate.call([5, 7, 3], [2, 6, 4]))
    assert_equal(""NO"", candidate.call([5, 7, 3], [2, 6, 3]))
    assert_equal(""NO"", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))
    assert_equal(""YES"", candidate.call([100, 200], [200, 200]))
  end
end
"
HumanEval_111,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵎⴽ ⴳⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉ ⵜⵉⴽⴽⵉ ⵢⴰⵜ, ⵔⵎⵙⵏ ⴰⴽⴽⵡ.ⵏ ⵜⴰⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵍⵙⵏ ⴽⵉⴳⴰⵏ ⴷ ⵉⵍⵍⴰ ⴳⵉⵙ ⵓⵟⵟⵓⵏ ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵇⵇⵏⵏ ⴰⴽⴷ ⵜⴱⵔⴰⵜ.ⵎⴽ ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵉⴼⵔⵜ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵜⵉⵎⵥⵥⵢⴰⵏⵉⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⵙ ⵜⵉⴽⵍⵜ, ⵙⵙⴽⵛⵎ ⵀⴰⵛⵉ.# >>> histogram.call(""a b c"")
# {""a"" => 1, ""b"" => 1, ""c"" => 1}
# >>> histogram.call(""a b b a"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""a b c a b"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""b b b b a"")
# {""b"" => 4}
# >>> histogram.call("""")
# {}
def histogram(test)
","def histogram(test)
  return {} if test.empty?

  count = Hash.new(0)

  test.split.each do |char|
    count[char] += 1
  end

  max_count = count.values.max
  count.select { |_, value| value == max_count }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_histogram
    candidate = method(:histogram)
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b b a""))
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b c a b""))
    assert_equal({""a"" => 1, ""b"" => 1, ""c"" => 1, ""d"" => 1, ""g"" => 1}, candidate.call(""a b c d g""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({""b"" => 4}, candidate.call(""b b b b a""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({}, candidate.call(""""))
    assert_equal({""a"" => 1}, candidate.call(""a""))
  end
end
"
HumanEval_112,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍⵉⵇⵇⴰⵏⴷ ⴰⴷ ⴷ-ⵜⵔⴰⵔⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⵏⵙⵍ ⵏ ⵜⵢⴰⴼⵓⵜ ⴷ true/false ⵉ ⵓⵣⵣⵔⴰⵢ.ⴷⴰ ⵜⵜⵉⵏⵉⵏ ⵉ ⵡⵓⵟⵟⵓⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵉⵖ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵢ ⵏⵏⵙ ⴰⵎ ⵡⴰⵏⵏⴰⵢ ⵏⵏⵙ ⵙ ⴷⴰⵜ.ⴹⴰⵕⵜ ⵓⵢⴰ, ⵥⵕⵖ ⵉⵙ ⵜⴳⴰ ⵜⵉⴼⵔⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ.ⴷⴰ ⵏⵜⵜⴰⴽⴽⴰ ⵙⵉⵏ ⵉⵙⵉⵔⵎⵏ s ⴷ c, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ s ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ c.ⵜⴰⵣⵣⴰⵍⵜ # >>> reverse_delete.call(""abcde"", ""ae"")
# [""bcd"", false]
# >>> reverse_delete.call(""abcdef"", ""b"")
# [""acdef"", false]
# >>> reverse_delete.call(""abcdedcba"", ""ab"")
# [""cdedc"", true]
def reverse_delete(s, c)
","def reverse_delete(s, c)
  # Remove all characters in c from s
  filtered_string = s.delete(c)
  
  # Check if the filtered string is a palindrome
  is_palindrome = filtered_string == filtered_string.reverse
  
  # Return the result array
  [filtered_string, is_palindrome]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_reverse_delete
    candidate = method(:reverse_delete)
    assert_equal([""bcd"", false], candidate.call(""abcde"", ""ae""))
    assert_equal([""acdef"", false], candidate.call(""abcdef"", ""b""))
    assert_equal([""cdedc"", true], candidate.call(""abcdedcba"", ""ab""))
    assert_equal([""dik"", false], candidate.call(""dwik"", ""w""))
    assert_equal(["""", true], candidate.call(""a"", ""a""))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", """"))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", ""v""))
    assert_equal([""abba"", true], candidate.call(""vabba"", ""v""))
    assert_equal(["""", true], candidate.call(""mamma"", ""mia""))
  end
end
"
HumanEval_113,taq_Tfng,rb,"ⵏ ⵡⵓⵟⵟⵓⵏ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ ⴳ ⵜⵣⵍⵉⵜ ⵜⵉⵙⵙ i ⵏ ⵓⵙⴽⵛⵎ."" ⴳ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵖⵔⵎⵉⵡⵉⵏ ""ⵉ"" ⵙ ⵓⵟⵟⵓⵏ ⴽⵓ ⵉⴼⵔⴷⵉⵙ i ⵏ ⵜⵢⴰⴼⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ "" ⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⵉⴹⵏ, ⴳ ⴽⵓ ⵉⵙⵉⴹⵏ ⵓⵔ ⵉⴳⵉⵏ ⵡⵉⵏ ⵡⵓⵟⵟⵓⵏ, ⵙⵙⴽⵔ ⴰⵙⵏⵙⵍ.# >>> odd_count.call([""1234567""])
# [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
# >>> odd_count.call([""3"", ""11111111""])
# [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
def odd_count(lst)
","def odd_count(lst)
  lst.map do |num_str|
    count = num_str.count('13579')
    ""the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_odd_count
    candidate = method(:odd_count)
    assert_equal([""the number of odd elements 4n the str4ng 4 of the 4nput.""], candidate.call([""1234567""]))
    assert_equal([""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], candidate.call([""3"", ""11111111""]))
    assert_equal([""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""], candidate.call([""271"", ""137"", ""314""]))
  end
end
"
HumanEval_114,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍⵏ ⵉⵎⴹⴰⵏⵏ.ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⴰⴼⵉ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴰⴷⵔⵓⵙⵜ ⵏ ⴽⵓ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴰⵡⵜⵎⴰⵢⵜ ⵓⵔ ⵉⴳⵉⵏ ⵜⵍⵍⴰⵍⵜ # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])
# 1
# >>> minSubArraySum.call([-1, -2, -3])
# -6
def minSubArraySum(nums)
","def minSubArraySum(nums)
  min_sum = nums[0]
  current_sum = 0
  nums.each do |num|
    if current_sum > 0
      current_sum = num
    else
      current_sum += num
    end
    min_sum = [min_sum, current_sum].min
  end
  min_sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minSubArraySum
    candidate = method(:minSubArraySum)
    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))
    assert_equal(-6, candidate.call([-1, -2, -3]))
    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))
    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))
    assert_equal(0, candidate.call([0, 10, 20, 1000000]))
    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))
    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))
    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))
    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))
    assert_equal(-10, candidate.call([-10]))
    assert_equal(7, candidate.call([7]))
    assert_equal(-1, candidate.call([1, -1]))
  end
end
"
HumanEval_115,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ 1:ⴰⴾⵜⴰⴱ ⵏ ⵉⵎⵎⵉⴾ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⵓⵢⵏ ⴰⴷⴷⵓⴱⴰⵜ ⵏⵢⵜ ⴰⴷ ⵉⴾⴼ-ⴰ ⵉⵂⴰⵔⴰⵏⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⵆⴰⴷⴰⵎ ⵏ ⴱⵓⴾⵢⵜ ⵜⴰⵏ ⵉ ⴰⵙⵉⵓⴰⴷ ⵏ ⵉⵋⵉⵜⴰⵏⴷ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⴼⵓⴾ ⵉⵍⴰⵏⴰⵏ ⵜⴰⵣⵓⵏⵜ ⵉⵉⵉⴰⵜⴾⴻⵍ ⵜⴰⵂⴰⵏⵉⵏⵜ ⵉⵍⴰ ⴱⵓⴾⴻⵜ ⵉⵋⵋⴰⵏ ⵉⵋⵋⵉ ⵏ ⴰⵎⴰⵏ ⴷⴰⵗ ⴻⴷⴰⴶ ⵓⴻⵏⴷ ⴽⵓ 1 ⴳ ⵜⴰⴳⵔⵡⵜ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⵢⵎⵓⵏⵜ ⵏ ⵡⴰⵎⴰⵏ.ⴰⵜⵓⴰⵗⵔⴰⴱⴰⵏ ⵙⴰⴾⴰⵍ ⵏⵓⴾⴰⵉⴰⵏ ⵏⵓⴾⴰⵉⴰⵏ. ⵔⵉⴾⵓⴾ ⵢⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵉⵉⵉⴰⵏ# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
# 6
# Example 2:
# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
# 5
# Example 3:
# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)
# 0
# Constraints:
# * all wells have the same length
# * 1 <= grid.length <= 10^2
# * 1 <= grid[:,1].length <= 10^2
# * grid[i][j] -> 0 | 1
# * 1 <= capacity <= 10
def max_fill(grid, capacity)
","def max_fill(grid, capacity)
  total_water_units = grid.flatten.sum
  (total_water_units.to_f / capacity).ceil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_fill
    candidate = method(:max_fill)
    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))
    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))
    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))
    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))
    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))
  end
end
"
HumanEval_116,taq_Tfng,rb,"ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔ ⵣⵓⵏⴷ ⴰⵢⴰ: ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵢⴰⵖⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙⵙⵓⴷⵙ ⵅⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵔⴰⵡ.ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⵏ ⴳ ⵓⵙⵎⴷⵢⴰ ⵏⵏⵙⵏ ⴰⵎⵉⵏⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵇⵕⴰⵏ.ⴳ ⴽⴰⵜⴰ ⴰⴷ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵏ ⵖⴼ # >>> sort_array.call([1, 5, 2, 3, 4])
# [1, 2, 3, 4, 5]
# >>> sort_array.call([-2, -3, -4, -5, -6])
# [-6, -5, -4, -3, -2]
# >>> sort_array.call([1, 0, 2, 3, 4])
# [0, 1, 2, 3, 4]
def sort_array(arr)
","def sort_array(arr)
  arr.sort_by { |n| [n.to_s(2).count('1'), n] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))
    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))
    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))
    assert_equal([], candidate.call([]))
    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))
    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
  end
end
"
HumanEval_117,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵜⴰⵍⵖⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴽⴷ ⵉⵙ ⴳⴰⵏ ⵉⵣⵔⵉⴳⵏ ⵏ ⵓⵙⴽⵛⵎ ⵖⴰⵙ ⵉⵙⴽⴽⵉⵍⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ.ⵎⴽ ⵜⴳⴰ ⵜⵉⵙⵉⴹⴼⵜ s ⵜⵍⵍⵉⵜ, ⵇⴰⴷ ⵜⵕⵓⵡⵉ ⵜⴰⵡⵓⵔⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵍⵍⵉⵜ.n ⵉⵎⵙⴰⵙⴰⵏ, ⵙ ⵓⵍⵖⴰ ⵏⵏⴰ ⴳ ⵜⵜⵉⵍⵉⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴷ ⴳ ⵜⵣⵍⵉⵜ s. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⴽⴰⵔⵏ ⴰⵙⵖⵍ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ ⵙⴳ ⵜⵉⴼⵉⵏⴰⵖ s ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⴳ ⵜⵉⴽⴽⵉ ⵏ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ s ⴷ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ n, ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⵙⵙⴽⵔ # >>> select_words.call(""Mary had a little lamb"", 4)
# [""little""]
# >>> select_words.call(""Mary had a little lamb"", 3)
# [""Mary"", ""lamb""]
# >>> select_words.call(""simple white space"", 2)
# []
# >>> select_words.call(""Hello world"", 4)
# [""world""]
# >>> select_words.call(""Uncle sam"", 3)
# [""Uncle""]
def select_words(s, n)
","def select_words(s, n)
  vowels = ""aeiouAEIOU""
  words = s.split
  words.select do |word|
    consonant_count = word.chars.count { |char| !vowels.include?(char) }
    consonant_count == n
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_select_words
    candidate = method(:select_words)
    assert_equal([""little""], candidate.call(""Mary had a little lamb"", 4))
    assert_equal([""Mary"", ""lamb""], candidate.call(""Mary had a little lamb"", 3))
    assert_equal([], candidate.call(""simple white space"", 2))
    assert_equal([""world""], candidate.call(""Hello world"", 4))
    assert_equal([""Uncle""], candidate.call(""Uncle sam"", 3))
    assert_equal([], candidate.call("""", 4))
    assert_equal([""b"", ""c"", ""d"", ""f""], candidate.call(""a b c d e f"", 1))
  end
end
"
HumanEval_118,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵎⴰⵙ ⴷ ⵜⴰⴳⵓⵔⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵜⵍⴰ ⵜⴰⴱⵔⵉⴷⵜ ⵜⴰⵏⴳⵍⵉⵣⵜ.ⴹⴼⵔ ⵉ ⴽⵓ ⴰⵖⵔⵉⵎ ⵏⵏⴰ ⵉⵔⵡⴰⵏ ⵙ ⵡⴰⴷⴷⴰⴷ ⵏ ⴰⴼⵍⵍⴰ.ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⵉⴹⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. ⵔⴰⵏⵜⵔ ⵜⴰⵣⵍⵉⵜ ⵜⴰⵅⵍⴰⴼⵜ ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ ⵙⵉⵏ ⵉⵎⵙⴰⵙⴰⵏ ⵙⴳ ⵜⵙⴳⴰ ⵏ ⵡⴰⵡⴰⵍ (ⴰⵙⵙⵏ ⵜⴱⵔⵉⴷⵜ).ⴷⴰ ⵜⵜⵓⴳⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⴼⴷ ⵓⴱⵓⵅⵉⵍ ⵏⵏⴰ ⵢⵓⴳⵔⵏ ⴳⵔ # >>> get_closest_vowel.call(""yogurt"")
# ""u""
# >>> get_closest_vowel.call(""FULL"")
# ""U""
# >>> get_closest_vowel.call(""quick"")
# """"
# >>> get_closest_vowel.call(""ab"")
# """"
def get_closest_vowel(word)
","def get_closest_vowel(word)
  vowels = ""aeiouAEIOU""
  (1...word.length - 1).reverse_each do |i|
    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])
      return word[i]
    end
  end
  return """"
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_closest_vowel
    candidate = method(:get_closest_vowel)
    assert_equal(""u"", candidate.call(""yogurt""))
    assert_equal(""u"", candidate.call(""full""))
    assert_equal("""", candidate.call(""easy""))
    assert_equal("""", candidate.call(""eAsy""))
    assert_equal("""", candidate.call(""ali""))
    assert_equal(""a"", candidate.call(""bad""))
    assert_equal(""o"", candidate.call(""most""))
    assert_equal("""", candidate.call(""ab""))
    assert_equal("""", candidate.call(""ba""))
    assert_equal("""", candidate.call(""quick""))
    assert_equal(""i"", candidate.call(""anime""))
    assert_equal("""", candidate.call(""Asia""))
    assert_equal(""o"", candidate.call(""Above""))
  end
end
"
HumanEval_119,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⵉⵜⵓⵔⵏ ""ⵉⵀ"" ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵉ ⵓⵙⴽⴰⵔ ⵏ ⵢⴰⵏ ⵓⵙⵉⴹⵏ ⵉⵖⵓⴷⴰⵏ, ⴷ ⵔⵉⵜⵓⵔⵏ ""ⵓⵅⴰ"" ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⴷⴷⴰⴷ."" ((()) "" ⵓⵔ ⵉⴳⵉ.ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: ⵜⵉⴼⵉⵏⴰⵖ ""(((() "" ⵜⴳⴰ ⵉⵖⵓⴷⴰⵏ, ⵎⴰⵛⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ S ⵙ ⵉⵙ ⵉⴳⴰ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⴷ ⵖⴰⵙ ⵉⴳ ⵎⴰⵕⵕⴰ ⵉⴽⵕⵕⴰⵥⵏ ⴳ S ⴽⵔⴰ ⵏ ⵓⴽⵓⴷ, ⵎⴰⵙⴷ ⵜⵉⴼⵔⴽⵜ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⵔⴰⴷ ⵜⴳ ⵉⵖⵓⴷⴰⵏ.ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⴷ ⴰⵙ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵉⴾⵉⵉ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⵜⵉⵣⵓⵏⴰⵓⴻⵏ ⴷⴰⵗⴷⴰⵢ ⴷⴰ ⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵉⴹⵕⵉⵚⵏ "" (() "" ⵏⵖⴷ ⵉⴹⵕⵉⵚⵏ ⵏ ⵜⴳⵏⵓⵜ "") "".ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ, ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ ⴷⴰⵔⵙⵏⵜ ⵜⵉⴼⵔⴽⵉⵏ.# >>> match_parens.call([""()("", "")""])
# ""Yes""
# >>> match_parens.call(["")"", "")""])
# ""No""
def match_parens(lst)
","def match_parens(lst)
  a, b = lst

  # Define a helper method to check if a string is balanced
  def balanced?(s)
    count = 0
    s.each_char do |c|
      count += 1 if c == '('
      count -= 1 if c == ')'
      return false if count < 0
    end
    count == 0
  end

  # Check if either concatenation forms a good string
  if balanced?(a + b) || balanced?(b + a)
    ""Yes""
  else
    ""No""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_match_parens
    candidate = method(:match_parens)
    assert_equal(""Yes"", candidate.call([""()("", "")""]))
    assert_equal(""No"", candidate.call(["")"", "")""]))
    assert_equal(""No"", candidate.call([""(()(())"", ""())())""]))
    assert_equal(""Yes"", candidate.call(["")())"", ""(()()(""]))
    assert_equal(""Yes"", candidate.call([""(())))"", ""(()())((""]))
    assert_equal(""No"", candidate.call([""()"", ""())""]))
    assert_equal(""Yes"", candidate.call([""(()("", ""()))()""]))
    assert_equal(""No"", candidate.call([""(((("", ""((())""]))
    assert_equal(""No"", candidate.call(["")(()"", ""(()(""]))
    assert_equal(""No"", candidate.call(["")("", "")(""]))
    assert_equal(""Yes"", candidate.call([""("", "")""]))
    assert_equal(""Yes"", candidate.call(["")"", ""(""]))
  end
end
"
HumanEval_120,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ 1:ⵏ ⵜⵉⵖⵣⵉ k ⴷ ⵡⵓⵟⵟⵓⵏ k ⴳ arr. ⵎⴽ ⴷⴰ ⵏⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ k, ⵏⵙⵙⴽⵍ ⴰⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ # >>> maximum.call([-3, -4, 5], 3)
# [-4, -3, 5]
# Example 2:
# >>> maximum.call([4, -4, 4], 2)
# [4, 4]
# Example 3:
# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)
# [2]
# Note:
# 1. The length of the array will be in the range of [1, 1000].
# 2. The elements in the array will be in the range of [-1000, 1000].
# 3. 0 <= k <= len(arr)
def maximum(arr, k)
","def maximum(arr, k)
  arr.sort.last(k).sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_maximum
    candidate = method(:maximum)
    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))
    assert_equal([4, 4], candidate.call([4, -4, 4], 2))
    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))
    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))
    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))
    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))
    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))
    assert_equal([5], candidate.call([1, 0, 5, -7], 1))
    assert_equal([-4, 4], candidate.call([4, -4], 2))
    assert_equal([-10, 10], candidate.call([-10, 10], 2))
    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))
  end
end
"
HumanEval_121,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵎⴽ ⴷⴰ ⵏⵜⵜⴰⴼ ⵢⴰⵏ ⵓⵙⵔⴷⴰⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⴷⴷⴰⵎⵏ, ⵏⵙⵙⴽⵜⵉ ⵙ ⵓⵖⵣⵓⵔⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⴰⵏⵙⴰ ⵉⵎⵣⴰⵔⴰⵢⵏ. # >>> solution.call([5, 8, 7, 1])
# 12
# >>> solution.call([3, 3, 3, 3, 3])
# 9
# >>> solution.call([30, 13, 24, 321])
# 0
def solution(lst)
","def solution(lst)
  lst.each_with_index.reduce(0) do |sum, (val, idx)|
    (idx.even? && val.odd?) ? sum + val : sum
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solution
    candidate = method(:solution)
    assert_equal(12, candidate.call([5, 8, 7, 1]))
    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))
    assert_equal(0, candidate.call([30, 13, 24, 321]))
    assert_equal(5, candidate.call([5, 9]))
    assert_equal(0, candidate.call([2, 4, 8]))
    assert_equal(23, candidate.call([30, 13, 23, 32]))
    assert_equal(3, candidate.call([3, 13, 2, 9]))
  end
end
"
HumanEval_122,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⴰⵎⵎⴰⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵙⵏⴰⵜ ⵜⴽⵕⴹⵉⵡⵉⵏ ⴳ ⵓⴳⴳⴰⵔ ⵙⴳ ⴽ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ arr.ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵓⵙⵔⵙⵉ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵏⵉⴳ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ arr ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ k,  return# >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
# 24
# Constraints:
# 1. 1 <= len(arr) <= 100
# 2. 1 <= k <= len(arr)
def add_elements(arr, k)
","def add_elements(arr, k)
  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add_elements
    candidate = method(:add_elements)
    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))
    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))
    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))
    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))
    assert_equal(1, candidate.call([1], 1))
  end
end
"
HumanEval_123,taq_Tfng,rb,"get_odd_collatz(5) ⴷⴰ ⵉⵜⵜⵔⴰⵔ [1, 5] # ⵜⴰⵍⵖⴰ ⵏ ⴽⵓⵍⵍⴰⵜⵣ ⵉ 5 ⵜⴳⴰ [5, 16, 8, 4, 2, 1], ⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵅⴰⵙ 1, ⴷ 5. ⵙ ⵓⵎⴷⵢⴰ: 2. ⵜⴰⵔⵔⴰⵢⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ.1. ⴽⵓⵍⵍⴰⵜⵣ ((1) ⵉⴳⴰ [1].ⴰⵜⵡⵉⵍ: ⴷⴰ ⵉⵜⵜⵉⵏⵉ ⵓⵙⵏⵓⵎⵎⵓ ⵎⴰⵙ ⴷ ⵡⴰⵜⵉⴳ ⴰⴽⴽⵡ ⵏ n, ⵔⴰⴷ ⵜⵍⴽⵎ ⵜⵉⴼⵔⴽⵜ ⴰⵀⴰ 1.ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ ⵜⴰⴳⴳⴰⵢⵜ, ⵜⴳⵓⵔⵉ ⵜⴰⴹⴼⴰⵕⵜ ⵔⴰⴷ ⵜⴳ 3 ⵏ ⵜⵉⴽⴽⴰⵍ ⵏ ⵜⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ.ⵜⵉⴼⵔⵉⵜ ⵉⵣⵔⵉⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵉⴳ ⵉⴳⴰ ⵜⵉⴼⵔⵉⵜ ⵉⵣⵔⵉⵏ ⵉⵎⵣⴷⴰⵢⵏ, ⵜⵉⴼⵔⵉⵜ ⵜⴰⴹⴼⴰⵕⵜ ⵜⴳⴰ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵙⵙⵏⵜⵉ ⵙ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ n. ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ, ⴷⴰ ⵜⵜⵓⵢⴰⴽⴽⴰ ⴽⵓ ⵜⴰⵙⴳⵓⵔⵉ ⵙⴳ ⵜⴰⴳⵏⵉⵜ ⵏ ⴽⵓⵍⵍⴰⵣ ⵜⴳⴰ ⵜⴰⴳⵏⵉⵜ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⴽⵛⵎ ⴰⵙⵖⵍ ⵏ ⵓⵙⵎⵙⴰⵙⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵙⵓⵔⵙ ⵏ ⴽⵓⵍⴰⵜⵣ. # >>> get_odd_collatz.call(5)
# [1, 5]
def get_odd_collatz(n)
","def get_odd_collatz(n)
  collatz_sequence = []
  while n != 1
    collatz_sequence << n if n.odd?
    if n.even?
      n = n / 2
    else
      n = 3 * n + 1
    end
  end
  collatz_sequence << 1 if n == 1

  collatz_sequence.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_odd_collatz
    candidate = method(:get_odd_collatz)
    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))
    assert_equal([1, 5], candidate.call(5))
    assert_equal([1, 3, 5], candidate.call(12))
    assert_equal([1], candidate.call(1))
  end
end
"
HumanEval_124,taq_Tfng,rb,"4. ⴷⴰⵜⵢ ⵜ ⵉⵋⵋⴰ ⴷⴰⵗ ⴼⵓⵔⵎⴰⵜⵉ: ⵎⵎ-ⴷⴷ-ⵢⵢⵢⵢⵢⵉ3. ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⴳ ⵡⴰⵢⵢⵓⵔⵏ ⴷⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 12.2. ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 31 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵢⵢⵎ ⵓⴰⵏ 1,3,5,7,8,10,12 ⴷ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 30 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵎ ⵓⴰⵏ 4,6,9,11 ⴷ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 29 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵎ ⵓⴰⵏ 21. ⵜⴰⵣⵓⵏⵜ ⵏ ⵡⴰⵙⵙ ⵓⵔ ⵜⴳⵉ ⵜⵍⵍⴰⵍⵜ.ⴷⴰⵜⴰ ⵜ ⴰⵈⵈⴰⵍ ⴰ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⴰ ⴼⴰⵍ ⵉⵍⴾⴰⵎⴰⵏ ⴼⵓⴾ ⵏⴰⵙⴰⵏ:ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⵣⵔⴼⴰⵏ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵜ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵜⵉⴼⵔⴽⵜ ⵏ ⵡⴰⵙⵙ ⴷ # >>> valid_date.call(""03-11-2000"")
# true
# >>> valid_date.call(""15-01-2012"")
# false
# >>> valid_date.call(""04-0-2040"")
# false
# >>> valid_date.call(""06-04-2020"")
# true
# >>> valid_date.call(""06/04/2020"")
# false
def valid_date(date)
","def valid_date(date)
  return false if date.nil? || date.empty?
  
  # Check if the date format is correct
  match = date.match(/^(\d{2})-(\d{2})-(\d{4})$/)
  return false unless match
  
  month, day, year = match.captures.map(&:to_i)
  
  # Check if month is valid
  return false if month < 1 || month > 12
  
  # Check if day is valid according to the month
  case month
  when 1, 3, 5, 7, 8, 10, 12
    return day >= 1 && day <= 31
  when 4, 6, 9, 11
    return day >= 1 && day <= 30
  when 2
    return day >= 1 && day <= 29
  else
    return false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_valid_date
    candidate = method(:valid_date)
    assert_equal(true, candidate.call(""03-11-2000""))
    assert_equal(false, candidate.call(""15-01-2012""))
    assert_equal(false, candidate.call(""04-0-2040""))
    assert_equal(true, candidate.call(""06-04-2020""))
    assert_equal(true, candidate.call(""01-01-2007""))
    assert_equal(false, candidate.call(""03-32-2011""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""04-31-3000""))
    assert_equal(true, candidate.call(""06-06-2005""))
    assert_equal(false, candidate.call(""21-31-2000""))
    assert_equal(true, candidate.call(""04-12-2003""))
    assert_equal(false, candidate.call(""04122003""))
    assert_equal(false, candidate.call(""20030412""))
    assert_equal(false, candidate.call(""2003-04""))
    assert_equal(false, candidate.call(""2003-04-12""))
    assert_equal(false, candidate.call(""04-2003""))
  end
end
"
HumanEval_125,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⴰⵍⵍⴰⵙ, ord{""a"") = 0, ord{""b"") = 1, ... ord{""z"") = 25 ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⴱⴹⵓ ⵅⴼ ⵜⵉⴼⵉⵏⴰⵖ ',' ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵜⵉⴼⵉⵏⴰⵖ  ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⴰⵔⵉⴹ ⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵢⴰⵏⴰⵡ ⴳ ⵎⴽ ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵉⴼⵔⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵙ ⵜⴱⴹⴰⵢⵜ ⵅⴼ ⵡⴰⵢⴷⴰ, ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵢⴷⴰ ⴳ ⵓⴹⵕⵉⵚ ⵏⵏⴰ ⵜⵔⴰ # >>> split_words.call(""Hello world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""Hello,world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""abcdef"")
# 3
def split_words(txt)
","def split_words(txt)
  if txt.include?(' ')
    return txt.split(' ')
  elsif txt.include?(',')
    return txt.split(',')
  else
    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }
    return odd_count
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_split_words
    candidate = method(:split_words)
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello world!""))
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello,world!""))
    assert_equal([""Hello"", ""world,!""], candidate.call(""Hello world,!""))
    assert_equal([""Hello,Hello,world"", ""!""], candidate.call(""Hello,Hello,world !""))
    assert_equal(3, candidate.call(""abcdef""))
    assert_equal(2, candidate.call(""aaabb""))
    assert_equal(1, candidate.call(""aaaBb""))
    assert_equal(0, candidate.call(""""))
  end
end
"
HumanEval_126,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏnumber, return false. ⵓⵔ ⴷⴰ ⵏⵜⵜⴰⴼⴰ ⵉⵎⴹⴰⵏ ⵉⵔⵉⵏⵉⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⴳ ⵓⵍⵓⴳ ⵏ ⵓⴽⵛⵛⵓⵎ. ⵉⵖ ⴷⴰⵔ ⵓⵎⵙⴳⵏⴰⴼ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵏ ⵓⵎⵙⴽⴰⵔ ⵏ ⵢⴰⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ, ⴰⵔ ⵜⵔⴰⵔⴷ ⵉⵙ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵏⵖ ⵓⵔ ⵜⵜⵓⵙⵎⵉⵍⵏ.# >>> is_sorted.call([5])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5])
# false
# >>> is_sorted.call([1, 2, 3, 4, 5, 6])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])
# false
# >>> is_sorted.call([1, 2, 2, 3, 3, 4])
# true
# >>> is_sorted.call([1, 2, 2, 2, 3, 4])
# false
def is_sorted(lst)
","def is_sorted(lst)
  lst.each_cons(2).with_index do |(a, b), index|
    return false if a > b
    return false if index < lst.length - 2 && a == b && lst[index + 2] == b
  end
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_sorted
    candidate = method(:is_sorted)
    assert_equal(true, candidate.call([5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))
    assert_equal(true, candidate.call([]))
    assert_equal(true, candidate.call([1]))
    assert_equal(false, candidate.call([3, 2, 1]))
    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))
    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 3, 4]))
  end
end
"
HumanEval_127,taq_Tfng,rb,"[ⵉⵏⴱⵓⵜ/ⵓⵓⵜⴱⵓⵜ] ⵙⵜⵓⵎⴱⵍⵙ: ⵎⴽ ⵓⵔ ⴷⴰ ⵜⵜⵎⴳⴰⵍⵏⵜ ⵙⵏⴰⵜ ⵜⵣⵎⵎⴰⵔ, ⵙⵓⵍⵏ ""ⵓⵀⵓ"".ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⵔⵔⵓⵜⵓⵔ ""ⵓⵀⵓ"".ⵎⴽ ⵉⴳⴰ ⵓⵖⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⵙⵙⴽⵛⵎ ""YES"", ⴷ ⴰⵖⵣⵉ ⵏⵏⵙ ⵉⴳⴰⵜ 1, ⴷ ⵓⵔ ⵉⴳⵉ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ.ⴰⵎⴷⵢⴰ, ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⵣⴰⵣⴰⵍ (1, 3), (2, 4) ⵉⴳⴰ (2, 3) ⵉⵙⵎ ⵏ ⵉⵏⴱⵉⵔⴰⵍⵏ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ.ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵜⴰⵢⴷ ⵎⴰⵢⴷ ⵉⴳⴰⵏ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵙⵏⴰⵜ ⵉ ⴽⵓ ⴰⵣⵎⵣ, ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵉⵙ ⵉⴳⴰ ⵍⴱⴷⵓ ⵏⵏⵙ ⵉⵎⵥⵥⵉⵢⵏ ⵏⵖⴷ ⵉⵎⴽⵉⵏⵏⴰ ⴷ ⵜⴳⵉⵔⴰ ⵏⵏⵙ.ⵢⵂⴰⵉ ⵜⵉⵣⴰⵔⴰⵜ ⴷ ⴰⵎⵉⵏⴷⵉⴷⴰ ⵜⵜⵓⵙⵎⵓⵏⴰⵏ ⵡⴰⵏⵙⵉⵡⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ, ⵎⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵡⴰⵏⵙⵉⵡⵏ (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ) ⴳ ⵉⴳⴰⵏ ⴽⵓ ⵓⵣⵎⵣ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙ ⵓⵎⴷⵢⴰ, ⴰⵣⵎⵣ = (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ) = (1, 2).ⴾⵢⵍ ⴰⴾⴰⵍ ⵉⵍⴰⵏ ⵜⵉ ⵉⵙⵙⵉⵏ ⵉⴾⴰⵏⵏⴰⵏ,# >>> intersection.call([1, 2], [2, 3])
# ""NO""
# >>> intersection.call([-1, 1], [0, 4])
# ""NO""
# >>> intersection.call([-3, -1], [-5, 5])
# ""YES""
def intersection(interval1, interval2)
","def intersection(interval1, interval2)
  start1, end1 = interval1
  start2, end2 = interval2

  intersection_start = [start1, start2].max
  intersection_end = [end1, end2].min

  if intersection_start > intersection_end
    return ""NO""
  end

  intersection_length = intersection_end - intersection_start + 1

  return ""YES"" if prime?(intersection_length)

  ""NO""
end

def prime?(n)
  return false if n <= 1
  return true if n == 2 || n == 3

  (2..Math.sqrt(n).to_i).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersection
    candidate = method(:intersection)
    assert_equal(""NO"", candidate.call([1, 2], [2, 3]))
    assert_equal(""NO"", candidate.call([-1, 1], [0, 4]))
    assert_equal(""YES"", candidate.call([-3, -1], [-5, 5]))
    assert_equal(""YES"", candidate.call([-2, 2], [-4, 0]))
    assert_equal(""NO"", candidate.call([-11, 2], [-1, -1]))
    assert_equal(""NO"", candidate.call([1, 2], [3, 5]))
    assert_equal(""NO"", candidate.call([1, 2], [1, 2]))
    assert_equal(""NO"", candidate.call([-2, -2], [-3, -2]))
  end
end
"
HumanEval_128,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: Note: return nil for empty arr.  ⴰⴱⵔⵉⴷ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵡⴰⵏⵙⴰⵏ ⴽⵓ ⵓⵟⵟⵓⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ, ⵉⵜⵜⵓⵙⵎⴷⵢⴰ ⵙ 1, -1 ⵏⵖⴷ 0. ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵉⵙⵎⴽⵜⵉⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵜⵢⴰⴼⵓⵜ ⵏ ⵉⵙⵎⴰⵡⵏ ⴰⴽⴽⵡ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⴰⵔ # >>> prod_signs.call([1, 2, 2, -4])
# 9
# >>> prod_signs.call([0, 1])
# 0
# >>> prod_signs.call([])
# nil
def prod_signs(arr)
","def prod_signs(arr)
  return nil if arr.empty?
  
  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }
  sum_magnitudes = arr.map(&:abs).sum
  
  product_signs * sum_magnitudes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prod_signs
    candidate = method(:prod_signs)
    assert_equal(-9, candidate.call([1, 2, 2, -4]))
    assert_equal(0, candidate.call([0, 1]))
    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))
    assert_equal(nil, candidate.call([]))
    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))
    assert_equal(4, candidate.call([-1, 1, -1, 1]))
    assert_equal(-4, candidate.call([-1, 1, 1, 1]))
    assert_equal(0, candidate.call([-1, 1, 1, 0]))
  end
end
"
HumanEval_129,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵓⴷⵙⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵙ ⵉⵣⵣⵔⵉ ⵓⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ. ⴾⴰⵍⴰ ⵉⵋⵋⴰ ⴰⵓⵢⵏ, ⴰⵍⵓⴰⵣⴰⴱ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏlst_A[j] = lst_B[j] ⵣⵓⵏⴷ lst_A[i] < lst_B[i] ⴷ ⴽⵓ j (1 <= j < i) ⵖⵓⵔⵖ ⵙⴳ lst_B, ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵢⴰⴹⵏ, ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ i (1 <= i <= k) ⵙⴳ (ⴰⴷ ⵏⵙⵎⵎⴰ ⵜⵏ lst_A ⴷ lst_B), lst_A ⴷ ⵡⵉⵏ ⵍⴰⴽⵙⵉⴽⵓⵊⵔⴰⴼⵉ ⴷⴼⴼⵉⵔ ⵎⴰⴷ ⵜⵜⵓⵙⴽⴰⵔⵏⵜ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⵉⴹⴼⴰⵕⵏ ⵉ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵔⴰⴷ ⵙⴽⵔⵏ A ⴷ Bⴷⴰ ⵉⵜⵜⵓⵙⵡⵉⵏⴳⵎ ⵓⴱⵔⵉⴷ A (ⵙ ⵜⵉⵖⵣⵉ k) ⴷⵔⵓⵙⵏ ⵓⴱⵔⵉⴷ B (ⵙ ⵜⵉⵖⵣⵉ k) ⵎⴽ ⵓⴰⵔ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⴰⴾⵉⵛⵉⴷ ⴷⴰⵗ ⴶⵔⵉⴷⴰⵍⴰⵗⵉ ⵏ ⴰⵍⴰⵗⵉⴰⵜⵓⴰⵣⴰⵉ ⴰⵙ ⴰⴱⴰⵔⴰ ⵓⴰⵏ ⵜⵉⵛⵉⵋⵔⵉⵜ ⵏ k ⴰⵎⵓⵙ ⴰⵙⵉⴾⵉ ⵏ ⵛⵢⵍⵍ ⵜⴰⵏ ⵓⵉⵏ k (ⵓⴰⵔ ⵏ ⴰⵈⵈⵢⵍ ⵜⴰⴱⵍⵉⵜ. ⵙ ⵜⴳⵓⵔⵉ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⵉⴷ ⵙ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⴷⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵓⵥⴰⵡⴰⵏ ⵙⴳ ⴽⴰ ⵉⴳⴰⵜ ⵜⴰⵖⵔⴰⵙⵜ, ⴷ ⴳ ⴽⵓ ⵜⴰⵙⵓⵔⵉⴼⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵍⵜ ⵖⵔ ⴽⴰ ⵉⴳⴰⵜ ⵜⴰⵖⵔⴰⵙⵜ ⵜⴰⴷⴷⴰⵔⵜ ⵜⵓⵎⵍⵉⵍⵜ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⴼ ⴰⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵜⵉⵖⵣⵉ k ⴳ ⵜⴽⵔⵔⴰⵢⵜ. ⵉⵖⵢ ⴰⴷ ⵏⴱⴷⵓ ⴷⴰ ⵉⵜⵜⵓⵢⴼⴼⵖ ""inclusive"" ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏ ⵜⵔⴰⴱⴱⵓⵜ.ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴽⴰⵔⴹⴰ ⵜⵍⵍⴰ ⴳ ⵡⴰⵜⵉⴳ. ⴽⵓ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⴼⵍ [1, N * N] ⴳ ⵜⴽⵔⵔⴰⵢⵜ ⵏ N ⵏ ⵜⵉⵙⵉⴹⴼⵉⵏ ⴷ N ⵏ ⵜⵔⵙⴰⵍ (N >= 2) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ k, # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
# [1, 2, 1]
# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
# [1]
def minPath(grid, k)
","def minPath(grid, k)
  n = grid.size
  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  min_path = nil

  n.times do |i|
    n.times do |j|
      queue = [[[i, j], [grid[i][j]]]]
      until queue.empty?
        position, path = queue.shift
        if path.size == k
          min_path = path if min_path.nil? || path < min_path
          next
        end
        directions.each do |dx, dy|
          x, y = position[0] + dx, position[1] + dy
          if x.between?(0, n-1) && y.between?(0, n-1)
            queue.push([[x, y], path + [grid[x][y]]])
          end
        end
      end
    end
  end
  min_path
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minPath
    candidate = method(:minPath)
    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))
    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))
    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))
    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))
    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))
    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))
    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))
  end
end
"
HumanEval_130,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵉⵎⴹⴰⵏ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵛⵉ ⵏ n + 1 ⴰⵎⵣⵡⴰⵔⵓ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⴹ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵏⴳⵓ n, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵔⴰⵢⵜ ⵏ = 2 + 3 + 3= 8 tri(3) = tri(2) + tri(1) + tri(4) tri(4) = 3 tri(2) = 1 + (2 / 2) = 2 ⵙ ⵓⵎⴷⵢⴰ: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ⵉⴳ n ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⴰⵔⴰⵢ. tri{n} = 1 + n / 2, ⵉⴳ ⵉⴳⴰ n ⵉⵎⵣⴰⵔⴰⵢⵏ. tri(1) = 3 ⴷⴰ ⵜⵜⵓⵙⵏⵎⵍ ⵜⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵛⵉ ⵙ ⵓⵙⵏⴼⵍ: ⵎⴰⵛⴰ, ⵓⵔ ⵉⵙⵙⵉⵏ ⵎⵉⴷⴷⵏ ⵙ ⵓⴹⴼⵕ ⵏ ⵟⵔⵉⴱⵓⵏⴰⵛⵛⵉ.ⴷⴰ ⵉⵜⵜⵢⴰⵔⴰ ⴽⵓ ⵢⴰⵏ ⵙ ⵓⵙⵏⵙⵍ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ, ⴰⵔ ⵜⵜⵎⵔⴰⵔⴰⵏ ⵉⵎⵓⵙⵏⴰⵡⵏ ⵏ ⵜⵓⵙⵏⴰⴽⵜ ⴳ # >>> tri.call(3)
# [1, 3, 2, 8]
def tri(n)
","def tri(n)
  sequence = [1, 3]
  
  (2..n).each do |i|
    if i.even?
      sequence[i] = 1 + i / 2
    else
      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0
    end
  end
  
  sequence[0..n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_tri
    candidate = method(:tri)
    assert_equal([1, 3, 2, 8], candidate.call(3))
    assert_equal([1, 3, 2, 8, 3], candidate.call(4))
    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))
    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))
    assert_equal([1], candidate.call(0))
    assert_equal([1, 3], candidate.call(1))
  end
end
"
HumanEval_131,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ 0 ⵎⴽ ⴳⴰⵏ ⴰⴽⴽⵡ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴳⵓⵏⵏ. ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵏⵓⵍⴼⵓ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ. # >>> digits.call(1)
# 1
# >>> digits.call(4)
# 0
# >>> digits.call(235)
# 15
def digits(n)
","def digits(n)
  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }
  return 0 if odd_digits.empty?
  odd_digits.reduce(:*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digits
    candidate = method(:digits)
    assert_equal(5, candidate.call(5))
    assert_equal(5, candidate.call(54))
    assert_equal(1, candidate.call(120))
    assert_equal(5, candidate.call(5014))
    assert_equal(315, candidate.call(98765))
    assert_equal(2625, candidate.call(5576543))
    assert_equal(0, candidate.call(2468))
  end
end
"
HumanEval_132,taq_Tfng,rb,"ⴳ ⵉⵍⵍⴰ ⵓⵙⵎⵓⵏ ⵏ ⴽⵔⴰ ⵏ ⵜⴽⵕⵕⵓⵎⵜ ⴳ ⵜⴹⴼⴼⵓⵕⵜ.ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵏ ⵜⵉⴷⵜ ⵎⴽ ⴷ ⵖⴰⵙ ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵉⵣⵔⴼⴰⵏ ⵏ ⵜⴱⵕⴰⴽⴰⵜⵉⵏ ⵔⵥⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴱⵕⴰⴽⴰⵜⵉⵏ ⵜⵉⴽⵓⴷⴰⵕⵉⵏ.# >>> is_nested.call(""[[]]"")
# true
# >>> is_nested.call(""[]]]]]]][[[[[]"")
# false
# >>> is_nested.call(""[][]"")
# false
# >>> is_nested.call(""[]"")
# false
# >>> is_nested.call(""[[][]]"")
# true
# >>> is_nested.call(""[[]][["")
# true
def is_nested(string)
","def is_nested(string)
  stack = []
  has_nested = false

  string.each_char do |char|
    if char == '['
      stack.push(char)
    elsif char == ']'
      if stack.empty?
        return false
      end
      stack.pop
      has_nested = true if stack.any?
    end
  end

  has_nested
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_nested
    candidate = method(:is_nested)
    assert_equal(true, candidate.call(""[[]]""))
    assert_equal(false, candidate.call(""[]]]]]]][[[[[]""))
    assert_equal(false, candidate.call(""[][]""))
    assert_equal(false, candidate.call(""[]""))
    assert_equal(true, candidate.call(""[[[[]]]]""))
    assert_equal(false, candidate.call(""[]]]]]]]]]]""))
    assert_equal(true, candidate.call(""[][][[]]""))
    assert_equal(false, candidate.call(""[[]""))
    assert_equal(false, candidate.call(""[]]""))
    assert_equal(true, candidate.call(""[[]][[""))
    assert_equal(true, candidate.call(""[[][]]""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""[[[[[[[[""))
    assert_equal(false, candidate.call(""]]]]]]]]""))
  end
end
"
HumanEval_133,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷⴰ ⵉⵜⵜⵉⵔⵉⵡ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵓⴼⵍⵍⴰ ⵏ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵡⴰⵎⵎⴰⵙⵏ ⵣⵡⴰⵔ.ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵓⴱⴰⵕ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵉⵜⵜⵓⴼⴽⴰⵏ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵡⵓⵟⵟⵓⵏ.# >>> lst.call([1.0, 2.0, 3.0])
# 14
# >>> lst.call([1.0, 4.0, 9.0])
# 98
# >>> lst.call([1.0, 3.0, 5.0, 7.0])
# 84
# >>> lst.call([1.4, 4.2, 0.0])
# 29
# >>> lst.call([-2.4, 1.0, 1.0])
# 6
def sum_squares(lst)
","def sum_squares(lst)
  lst.map { |num| (num.ceil)**2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))
    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))
    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))
    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))
    assert_equal(200000000, candidate.call([10000.0, 10000.0]))
    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))
    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))
    assert_equal(0, candidate.call([0.0]))
    assert_equal(1, candidate.call([-1.0]))
    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))
  end
end
"
HumanEval_134,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵓⵉⵣⴶⴰⵔ: ""ⴰⵍⵎⴰⵗⵏⴰ"" ⵢⵈⴰⵍ ⵜⴰⵈⵈⵉⵎⵜ ⴰⵏ ⵎⴰⴶⵔⴰⴷ ⴰⵜⵉⵓⴰⵣⴰⵉⴰⵏ ⵙ ⵢⴷⴰⴶ.ⴰⵛⵔⵓⵜ ⵏ ⴰⵍⵎⴰⵗⵏⴰ ⴷ ⵓⴰⵔ ⵏ ⵓⵍⴰⵗ ⵋⵉⵔ ⴰⵓⵢⵏⵏ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵓⵔ ⵉⴳⵉ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵎⵓⵖ ⴰⵎⴳⴳⴰⵔⵓ # >>> check_if_last_char_is_a_letter.call(""apple pie"")
# false
# >>> check_if_last_char_is_a_letter.call(""apple pi e"")
# true
# >>> check_if_last_char_is_a_letter.call(""apple pi e "")
# false
# >>> check_if_last_char_is_a_letter.call("""")
# false
def check_if_last_char_is_a_letter(txt)
","check_if_last_char_is_a_letter = ->(txt) {
  return false if txt.strip.empty?
  words = txt.strip.split(' ')
  last_word = words.last
  return false if last_word.empty?
  last_char = last_word[-1]

  last_char =~ /[a-zA-Z]/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')
}","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_if_last_char_is_a_letter
    candidate = method(:check_if_last_char_is_a_letter)
    assert_equal(false, candidate.call(""apple""))
    assert_equal(true, candidate.call(""apple pi e""))
    assert_equal(false, candidate.call(""eeeee""))
    assert_equal(true, candidate.call(""A""))
    assert_equal(false, candidate.call(""Pumpkin pie ""))
    assert_equal(false, candidate.call(""Pumpkin pie 1""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""eeeee e ""))
    assert_equal(false, candidate.call(""apple pie""))
    assert_equal(false, candidate.call(""apple pi e ""))
  end
end
"
HumanEval_135,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵉⴳⵏ ⵉⵎⵎⵓⵟⵟⵓⵏⵏ.ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ, ⵔⴰⴷ ⵏⵔⴰⵔ -1ⵓⵔ ⵉⴳⵉ ⴰⵅⴰⵜⴰⵔ ⵏⵖⴷ ⵉⵎⴽⵏ ⵉ ⵓⵏⴰⵡ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⴷⴰⵜ ⵏⵏⵙ. ⵎⴽ ⵔⴰⵏⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵏⵎⴰⵜⴰⵔ ⴰⵅⴰⵜⴰⵔ ⵏ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ # >>> can_arrange.call([1, 2, 4, 3, 5])
# 3
# >>> can_arrange.call([1, 2, 3])
# -1
def can_arrange(arr)
","def can_arrange(arr)
  (1...arr.length).reverse_each do |i|
    return i if arr[i] < arr[i - 1]
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_can_arrange
    candidate = method(:can_arrange)
    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))
    assert_equal(-1, candidate.call([1, 2, 4, 5]))
    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))
    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))
    assert_equal(-1, candidate.call([]))
  end
end
"
HumanEval_136,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵖⴷ ⵉⵎⵏⴳⵉⵏⵏ, ⵙⵙⴽⵛⵎ-ⵜ ⵙ nil. ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ.ⴰⵎⵉⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳⴳⵓⵜⵏ ⴳ ⵓⵎⵏⵣⴰⵢ, ⴷ ""ⴱ"" ⵉⴳⴰ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵙⵔⴷⴰⵙ (ⴰ,ⴱ), ⴳ ⵉⵍⵍⴰ 'ⴰ' # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])
# [nil, 1]
# >>> largest_smallest_integers.call([])
# [nil, nil]
# >>> largest_smallest_integers.call([0])
# [nil, nil]
def largest_smallest_integers(lst)
","def largest_smallest_integers(lst)
  largest_negative = nil
  smallest_positive = nil
  
  lst.each do |num|
    if num < 0
      largest_negative = num if largest_negative.nil? || num > largest_negative
    elsif num > 0
      smallest_positive = num if smallest_positive.nil? || num < smallest_positive
    end
  end
  
  [largest_negative, smallest_positive]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_smallest_integers
    candidate = method(:largest_smallest_integers)
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))
    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))
    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))
    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))
    assert_equal([nil, nil], candidate.call([]))
    assert_equal([nil, nil], candidate.call([0]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))
  end
end
"
HumanEval_137,taq_Tfng,rb,"ⵜⴰⵍⵖⴰ: ⵎⴽ ⵉⵜⵜⵓⵙⵎⴷⵢⴰ ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴷⵜ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵉⵖⵢ ⴰⴷ ⵉⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⴰⵎⵙⵙⵓⴷⵓ . ⵏⵖⴷ , ⴰⵔ ⵉⵜⵜⵔⴰⵔ nil ⵎⴽ ⵜⴳⴰⴷ ⵜⵉⵏⴷⵉⵜⵉⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵉⵎⴹⴰⵏ ⵏ ⵜⵉⴷⵜ, ⴰⵔ ⵉⵙⴽⵔ ⴰⵎⵙⵏⴼⵍⵓⵍ ⴰⵅⴰⵜⴰⵔ ⴳ ⵡⴰⵏⴰⵡ ⵏ ⵓⵎⵙⵏⴼⵍⵓⵍ ⵏⵏⴻⵙ.ⵔⵡⵉ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵏⵖⴷ ⵉⵙⵉⴹⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵏⵖⴷ ⵉⵙⵉⴹⵏ ⵏ ⵡⵓⵟⵟⵓⵏ # >>> compare_one.call(1, 2.5)
# 2.5
# >>> compare_one.call(1, ""2,3"")
# ""2,3""
# >>> compare_one.call(""5,1"", ""6"")
# ""6""
# >>> compare_one.call(""1"", 1)
# nil
def compare_one(a, b)
","def compare_one(a, b)
  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')
  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')

  if a.is_a?(String) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Float)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Float)
    a = a.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Integer)
    b = b.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Float)
    b = b.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(String)
    a = a.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  else
    return nil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare_one
    candidate = method(:compare_one)
    assert_equal(2, candidate.call(1, 2))
    assert_equal(2.5, candidate.call(1, 2.5))
    assert_equal(3, candidate.call(2, 3))
    assert_equal(6, candidate.call(5, 6))
    assert_equal(""2,3"", candidate.call(1, ""2,3""))
    assert_equal(""6"", candidate.call(""5,1"", ""6""))
    assert_equal(""2"", candidate.call(""1"", ""2""))
    assert_equal(nil, candidate.call(""1"", 1))
  end
end
"
HumanEval_138,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍⵔⵣⵓ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⵓⵟⵟⵓⵏ n ⵉⵖⵢ ⴰⴷ ⵉⵜⵜⵢⴰⵔⴰ ⵙ ⵓⵖⵣⵓⵔ ⵏ ⴽⴽⵓⵥ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵃⵍⴰⵏ # >>> is_equal_to_sum_even.call(4)
# false
# >>> is_equal_to_sum_even.call(6)
# false
# >>> is_equal_to_sum_even.call(8)
# true
def is_equal_to_sum_even(n)
","def is_equal_to_sum_even(n)
  return false if n < 8
  n.even?
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_equal_to_sum_even
    candidate = method(:is_equal_to_sum_even)
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(8))
    assert_equal(true, candidate.call(10))
    assert_equal(false, candidate.call(11))
    assert_equal(true, candidate.call(12))
    assert_equal(false, candidate.call(13))
    assert_equal(true, candidate.call(16))
  end
end
"
HumanEval_139,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴳ ⵉⵍⵍⴰ n > 0 brazilian_factorial{n} = n! * (n-1)! * (n-2)! * ... * 1! ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⴼⴰⴽⵜⵓⵔⴰⵍ ⴰⴱⵕⴰⵣⵉⵍⵉ ⵙ: # >>> special_factorial.call(4)
# 288
# The function will receive an integer as input and should return the special
# factorial of this integer.
def special_factorial(n)
","def special_factorial(n)
  return 1 if n <= 1
  (1..n).inject(1) { |product, i| product * factorial(i) }
end

def factorial(num)
  return 1 if num <= 1
  (2..num).inject(1, :*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_special_factorial
    candidate = method(:special_factorial)
    assert_equal(288, candidate.call(4))
    assert_equal(34560, candidate.call(5))
    assert_equal(125411328000, candidate.call(7))
    assert_equal(1, candidate.call(1))
  end
end
"
HumanEval_140,taq_Tfng,rb,"ⴷⴼⴼⵉⵔ ⴰⴷ ⵙⵏⴼⵍ ⵉⵙⴰⵢⵔⴰⵔⵏ ⴰⴽⴽⵡ ⵉⵎⵣⴷⴰⵢⵏ ⵙ - ⴷ ⵎⴽ ⴳⴰⵏ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⵓⴳⴳⴰⵔ ⵏ 2 ⵏ ⵡⴰⵏⵙⴰ ⵉⵎⴹⴼⴰⵕⵏ, ⴹⴰⵗ ⵜⴰⵙⴰⵙⵙⴰⵗⵔⴰⵓⵜ ⵏ ⵉⴾⵉⵜⴱⴰⵏ, ⵙⴰⵎⵎⵓⵜⵜⵉ ⵏ ⵉⵂⴰⵏⴷⴰⴶⴰⵏ ⴼⵓⴾ ⴷⴰⵗ ⵢⴷⵢⵙ ⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏ# >>> fix_spaces.call("" Example"")
# ""Example""
# >>> fix_spaces.call("" Example 1"")
# ""Example_1""
# >>> fix_spaces.call("" Example 2"")
# ""_Example_2""
# >>> fix_spaces.call("" Example 3"")
# ""_Example-3""
def fix_spaces(text)
","def fix_spaces(text)
  text.strip.gsub(/\s{3,}/, '-').gsub(' ', '_')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fix_spaces
    candidate = method(:fix_spaces)
    assert_equal(""Example"", candidate.call(""Example""))
    assert_equal(""Mudasir_Hanif_"", candidate.call(""Mudasir Hanif ""))
    assert_equal(""Yellow_Yellow__Dirty__Fellow"", candidate.call(""Yellow Yellow  Dirty  Fellow""))
    assert_equal(""Exa-mple"", candidate.call(""Exa   mple""))
    assert_equal(""-Exa_1_2_2_mple"", candidate.call(""   Exa 1 2 2 mple""))
  end
end
"
HumanEval_141,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:- ⵉⵇⵏⴻⵏ ⴰⴷ ⵉⴳ ⵓⵙⵏⴼⵍⵓⵍ ⴷⴼⴼⵉⵔ ⵜⴱⵔⵉⴷⵜ ⵢⴰⵏ ⴳ ⵡⴰⵏⵏⴰ ⴷⴷⵖ: ['txt', 'exe', 'dll'] ⴰⵍⴾⴰⴷⴰⵏ ⵓⵉⵏ ⵍⴰⵜⵉⵏ (""ⴰ-ⵣ"" ⴷ ""ⴰ-ⵣ"")- ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵢⵉⵍⵉ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵜⴱⵔⵉⴷⵜ, ⴰⵔ ⵜⴱⴷⴰⴷ ⵙ ⵓⴱⵔⵉⴷ - ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⵉⵍⵍⴰ ⴳⵉⵙ ⵢⴰⵏ ⵓⴱⵔⵉⴽⵜ '.' - ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⴽⵕⴰⴹ ⵏ ⵡⵓⵟⵟⵓⵏ (""0"" - ""9"") ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ. ⵜⵜⵓⵙⵎⵓⵏ: ⵉⵙⵎ ⵏ ⵓⴱⵔⵓⴹⵉⵣ ⴰⵔ ⵉⵜⵜⵓⵙⵡⴰⵏ ⵉⵙ ⵉⴳⴰ ⵡⴰⵍⵍⵉ ⵉⵣⵔⵉⵏ ⵎⴽ ⴷ ⵎⴽ ⴷⴰ ⵇⵇⴰⵔⵏ ⴽⵓⵍⵍⵓ ⵜⵎⵙⴰⵔⵉⵏ ⴷⴷⵖ ""ⴷⴰ"" ⵉⵖ ⵉⴳⴰ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⵣⵔⴼⴰⵏ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ ""ⵓⵀⵓ"" ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵉⵙⵎⴷⵢⴰ ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ # >>> file_name_check.call(""example.txt"")
# ""Yes""
# >>> file_name_check.call(""1example.dll"")
# ""No""
def file_name_check(file_name)
","def file_name_check(file_name)
  # Check if there's exactly one dot in the filename
  return 'No' unless file_name.count('.') == 1
  
  # Split the filename into the name and extension
  name, extension = file_name.split('.')
  
  # Check if the name part starts with a letter
  return 'No' if name.empty? || !name[0].match?(/[a-zA-Z]/)
  
  # Check if the extension is valid
  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)
  
  # Count digits in the file name
  digit_count = file_name.count(""0-9"")
  
  # Check if digits are more than three
  return 'No' if digit_count > 3
  
  'Yes'
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_file_name_check
    candidate = method(:file_name_check)
    assert_equal(""Yes"", candidate.call(""example.txt""))
    assert_equal(""No"", candidate.call(""1example.dll""))
    assert_equal(""No"", candidate.call(""s1sdf3.asd""))
    assert_equal(""Yes"", candidate.call(""K.dll""))
    assert_equal(""Yes"", candidate.call(""MY16FILE3.exe""))
    assert_equal(""No"", candidate.call(""His12FILE94.exe""))
    assert_equal(""No"", candidate.call(""_Y.txt""))
    assert_equal(""No"", candidate.call(""?aREYA.exe""))
    assert_equal(""No"", candidate.call(""/this_is_valid.dll""))
    assert_equal(""No"", candidate.call(""this_is_valid.wow""))
    assert_equal(""Yes"", candidate.call(""this_is_valid.txt""))
    assert_equal(""No"", candidate.call(""this_is_valid.txtexe""))
    assert_equal(""No"", candidate.call(""#this2_i4s_5valid.ten""))
    assert_equal(""No"", candidate.call(""@this1_is6_valid.exe""))
    assert_equal(""No"", candidate.call(""this_is_12valid.6exe4.txt""))
    assert_equal(""No"", candidate.call(""all.exe.txt""))
    assert_equal(""Yes"", candidate.call(""I563_No.exe""))
    assert_equal(""Yes"", candidate.call(""Is3youfault.txt""))
    assert_equal(""Yes"", candidate.call(""no_one#knows.dll""))
    assert_equal(""No"", candidate.call(""1I563_Yes3.exe""))
    assert_equal(""No"", candidate.call(""I563_Yes3.txtt""))
    assert_equal(""No"", candidate.call(""final..txt""))
    assert_equal(""No"", candidate.call(""final132""))
    assert_equal(""No"", candidate.call(""_f4indsartal132.""))
    assert_equal(""No"", candidate.call("".txt""))
    assert_equal(""No"", candidate.call(""s.""))
  end
end
"
HumanEval_142,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⴰⴷ ⵜⵙⵏⴼⵍ ⵜⵎⵙⴽⵜⵉⵜⵉⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵏ 3 ⵏⵖⴷ 4. ⵔⴰⴷ ⵜⵕⵡⵍ ⵜⵡⵓⵔⵉ ⵜⴰⴳⵓⵜ ⵏ ⵜⵎⵙⴽⵜⵉⵜⵉⵏ ⴰⴽⴽⵡ.ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3 ⴷ ⵔⴰⴷ ⵢⴰⴽⵣ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 4 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⵓⵔ ⵔⴰⴷ ⵜⴳⴳ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵕⵥⵎ ⴰⵎⵙⴷⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉ ⴽⵓⵍⵍⵓ ⵜⵉⵎⵙⴽⵜⵉⵜⵉⵏ ⴳ ⵓⵎⵙⴷⵉ, ⵔⴰⴷ ⵜⵕⵥⵎ ⵜⴰⵡⵓⵔⵉ ⴰⵎⵙⴷⵉ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ "" # >>> lst
# [1, 2, 3]
# >>> lst
# []
# >>> lst
# [-1, -5, 2, -1, -5]
def sum_squares(lst)
","def sum_squares(lst)
  lst.map.with_index do |num, index|
    if index % 3 == 0
      num ** 2
    elsif index % 4 == 0
      num ** 3
    else
      num
    end
  end.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(6, candidate.call([1, 2, 3]))
    assert_equal(14, candidate.call([1, 4, 9]))
    assert_equal(0, candidate.call([]))
    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))
    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))
    assert_equal(0, candidate.call([0]))
    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))
    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))
    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))
    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))
    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))
  end
end
"
HumanEval_143,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ 1:ⵍⴰⵀⴰⵏ ⵏ ⵡⴰⵡⴰⵍ ⴳ ⵜⵣⵍⵉⵜ ⵜⴰⵎⴰⵢⵏⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⵎⴽⵉⵏ ⵡⵉⵙⵙ ⵓⵣⵡⴰⵔⵓ.ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵜⴳⴰ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ, ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵉⵜⵓⵔ ⵙⵜⵔⵉⴳ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵢⵎⵎⴰⵜ, ⵜⴰⴳⵓⵔⵉ ⵜⵍⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵢⴼⵔⴰⵔⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴳⵓⵔⵉ, # >>> words_in_sentence.call(""This is a test"")
# ""is""
# Example 2:
# >>> words_in_sentence.call(""lets go for swimming"")
# ""go for""
# Constraints:
# * 1 <= len(sentence) <= 100
# * sentence contains only letters
def words_in_sentence(sentence)
","def words_in_sentence(sentence)
  def is_prime?(num)
    return false if num <= 1
    (2..Math.sqrt(num)).none? { |i| num % i == 0 }
  end
  
  words = sentence.split("" "")
  prime_length_words = words.select { |word| is_prime?(word.length) }
  prime_length_words.join("" "")
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_in_sentence
    candidate = method(:words_in_sentence)
    assert_equal(""is"", candidate.call(""This is a test""))
    assert_equal(""go for"", candidate.call(""lets go for swimming""))
    assert_equal(""there is no place"", candidate.call(""there is no place available here""))
    assert_equal(""Hi am Hussein"", candidate.call(""Hi I am Hussein""))
    assert_equal(""go for it"", candidate.call(""go for it""))
    assert_equal("""", candidate.call(""here""))
    assert_equal(""is"", candidate.call(""here is""))
  end
end
"
HumanEval_144,taq_Tfng,rb,"ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵎⴰⵙ ⴷ x, ⴷ n ⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵖⵓⴷⴰⵏ, ⴷ ⵓⵔ ⴷⴰⵔⵙⵏ ⵓⵎⵢⴰ ⴰⵎⵎ ⵓⵎⵙⵙⴰⵖ.<numerator>/<denominator> ⴳⴰⵏ ⵙⵉⵏ ⵉⵎⵉⴹⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵎⵙⵙⴰⵖⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵎⴽⵍⵍⵉ, ⴳⴰⵏ x ⴷ n, ⴰⵙⵎⴷⵢⴰ ⵏ ⵓⴽⵙⴰⵢ ⵏ ⵜⴳⵣⵣⵓⵎⵜ, ⴷ ⵖⵓⵔⵙⵏ ⵜⴰⵍⵖⴰ ⴷ ⵢⵓⵛⴽⴰⵏ, x * n. ⴷⴰ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⵉⴷⵜ ⵎⴽ ⵜⵙⵙⵎⵔⴰⵙ x * n ⵉ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴷ ⵜⵉⴷⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵉⵙⴱⴷⵉⴷ ⴰⵙⵏⵓⵎⵎⵍ # >>> simplify.call(""1/5"", ""5/1"")
# true
# >>> simplify.call(""1/6"", ""2/1"")
# false
# >>> simplify.call(""7/10"", ""10/2"")
# false
def simplify(x, n)
","def simplify(x, n)
  # Convert x and n to numerators and denominators
  num_x, den_x = x.split('/').map(&:to_i)
  num_n, den_n = n.split('/').map(&:to_i)

  # Multiply fractions: (num_x * num_n) / (den_x * den_n)
  numerator = num_x * num_n
  denominator = den_x * den_n

  # Check if the result is a whole number
  numerator % denominator == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_simplify
    candidate = method(:simplify)
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/6"", ""2/1""))
    assert_equal(true, candidate.call(""5/1"", ""3/1""))
    assert_equal(false, candidate.call(""7/10"", ""10/2""))
    assert_equal(true, candidate.call(""2/10"", ""50/10""))
    assert_equal(true, candidate.call(""7/2"", ""4/2""))
    assert_equal(true, candidate.call(""11/6"", ""6/1""))
    assert_equal(false, candidate.call(""2/3"", ""5/2""))
    assert_equal(false, candidate.call(""5/2"", ""3/5""))
    assert_equal(true, candidate.call(""2/4"", ""8/4""))
    assert_equal(true, candidate.call(""2/4"", ""4/2""))
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/5"", ""1/5""))
  end
end
"
HumanEval_145,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵔⴰⵏⵜ ⵙ ⵓⵙⵓⴷⵙ ⵏⵏⵙⵏ ⵙ ⵓⵙⵉⵔⴰ ⵏⵏⵙⵏ ⴳ ⵓⵙⵏⵙⵍ ⴰⵎⵣⵡⴰⵔⵓ.ⴰⵜⵡⵉⵍ: ⵉⵖ ⵉⵍⵍⴰ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵡⴰⵜⵉⴳ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙ ⵓⵍⵖⵓ ⴰⵎⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ.ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵙⵔⵔⵓⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ # >>> order_by_points.call([1, 11, -1, -11, -12])
# [-1, -11, 1, -12, 11]
# >>> order_by_points.call([])
# []
def order_by_points(nums)
","def order_by_points(nums)
  nums.sort_by.with_index do |num, index|
    [num.to_s.chars.map(&:to_i).sum.abs, index]
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_order_by_points
    candidate = method(:order_by_points)
    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))
    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))
    assert_equal([], candidate.call([]))
    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))
    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))
    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))
  end
end
"
HumanEval_146,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⵉⵏ ⴹⴰⵕⵜ ⵓⴳⴳⴰⵔ ⵏ ⵡⵓⵟⵟⵓⵏ (1, 3, 5, 7, 9).ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⵢⵓⴳⵔⵏ 10 ⴷ ⵙⵏⴰⵜ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵎ ⵉⵏⴽⵛⵓⵎⵏ ⴷ ⵡⵉⵏ ⵜⵏⴰⴼⵓⵜⵉⵏ # >>> specialFilter.call([15, -73, 14, -15])
# 1
# >>> specialFilter.call([33, -2, -3, 45, 21, 109])
# 2
def specialFilter(nums)
","def specialFilter(nums)
  nums.count do |num|
    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_specialFilter
    candidate = method(:specialFilter)
    assert_equal(0, candidate.call([5, -2, 1, -5]))
    assert_equal(1, candidate.call([15, -73, 14, -15]))
    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))
    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))
    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))
    assert_equal(0, candidate.call([1]))
    assert_equal(0, candidate.call([]))
  end
end
"
HumanEval_147,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ:ⴷ a[i] + a[j] + a[k] ⴷ ⴰⵎⵔⴰⵔⵓ ⵏ 3. ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵔⴱⵉⵍⵉⵏ (ⴰ[i], ⴰ[ⵊ], ⴰ[ⴽ]) ⵏ ⴰ ⴳ ⵉⵍⵍⴰ i < ⵊ < ⴽ, ⵉ ⴽⵓ i (1 ≤ i ≤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1. ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⴹ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⴽⵔ ⵢⴰⵏ ⵓⵙⵔⴷ ⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⵏ ⵜⵉⵖⵣⵉ n. # >>> get_max_triples.call(5)
# 1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
def get_max_triples(n)
","def get_max_triples(n)
  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }
  count = 0
  
  (0...n).each do |i|
    (i+1...n).each do |j|
      (j+1...n).each do |k|
        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0
      end
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_max_triples
    candidate = method(:get_max_triples)
    assert_equal(1, candidate.call(5))
    assert_equal(4, candidate.call(6))
    assert_equal(36, candidate.call(10))
    assert_equal(53361, candidate.call(100))
  end
end
"
HumanEval_148,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵓⵔ ⴳⵉⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵉⵜⵔⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ.ⵜⵣⵎⵔ ⵜⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵏ ⵜⴰⴳⵔⵡⴰⵏⵜ ⵜⴰⵅⵅⴰⵔⵜ ⵎⴽ ⵜⴳⴰ planete1 ⵏⵖ planete2 ⵜⴰⵣⵓⵍⵉ ⵏ ⵜⴰⴼⵓⴾⵜⵉⵍⵍⴰⵏ ⵋⵉⵔ ⵜⴰⵗⵉⵙⵙⴰ ⵏ ⴱⵍⴰⵢⵏⵢⵜ1 ⴷ ⵜⴰⵗⵉⵙⵙⴰ ⵏ ⴱⵍⴰⵢⵏⵢⵜ2, ⵉⵋⵋⴰⵏ ⵙ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵡⴰⵍ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⴰⴽⴽⵡ ⵉⵜⵔⴰⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⵜⵉⵖⵔⵓⵎⵎⴰ ⵏⵏⵙ ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵉⵜⵔⴰⵏ ⴰⵎⵎ ⵜⵉⵙⵉⴹⴼⵕⵉⵏ planet1 ⴷ planet2.ⵓⵓⵔⴰⵏⵓⵙ, ⵏⴻⴱⵜⵓⵏⴻ.ⵉⴳⴰ ⵎⵉⵔⴽⵓⵔⵉ, ⵡⴰⵏⵏⴰ ⴷ ⵉⴷⴷⴰⵏ ⵉⴳⴰ ⵡⵉⵏⵓⵙ, ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ ⵉⴳⴰ ⵡⴰⴽⴰⵍ, ⵎⴰⵕⵙ, ⵊⵓⴱⵉⵜⵔ, ⵙⴰⵜⵓⵔⵏ, ⵍⵍⴰⵏⵜ 8 ⵏ ⵜⵣⵡⵉⵏⵏⵉⵜⵉⵏ ⴳ ⵓⵏⴳⵔⴰⵡ ⵏ ⵜⴰⴼⵓⴽⵜ ⵏⵏⵖ: ⵜⵉⴷⵙⵜ ⵜⴰⴷⵙⵜⵔⴰⵔⵜ ⵏ ⵜⴰⴼⵓⴽⵜ.# >>> bf.call(""Jupiter"", ""Neptune"")
# [""Saturn"", ""Uranus""]
# >>> bf.call(""Earth"", ""Mercury"")
# ""Venus""
# >>> bf.call(""Mercury"", ""Uranus"")
# [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
def bf(planet1, planet2)
","def bf(planet1, planet2)
  planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
  
  idx1 = planets.index(planet1)
  idx2 = planets.index(planet2)
  
  return [] if idx1.nil? || idx2.nil?

  start_idx, end_idx = [idx1, idx2].sort
  
  planets[(start_idx + 1)...end_idx]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_bf
    candidate = method(:bf)
    assert_equal([""Saturn"", ""Uranus""], candidate.call(""Jupiter"", ""Neptune""))
    assert_equal([""Venus""], candidate.call(""Earth"", ""Mercury""))
    assert_equal([""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""], candidate.call(""Mercury"", ""Uranus""))
    assert_equal([""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""], candidate.call(""Neptune"", ""Venus""))
    assert_equal([], candidate.call(""Earth"", ""Earth""))
    assert_equal([], candidate.call(""Mars"", ""Earth""))
    assert_equal([], candidate.call(""Jupiter"", ""Makemake""))
  end
end
"
HumanEval_149,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵙ ⵇⴰⴷ ⵢⵉⵍⵉ ⵓⵖⵣⵉ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ.ⵍⴰⵇⵏ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵓⵏⵎⴰⵍⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.ⵎⴽ ⴷⴰⵔ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵖⵣⵉ ⵜⴰⵣⴳⵣⴰⵡⵜ, ⵙⵙⵓⴷⵙ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵙ ⵓⴽⵙⴰⵢ.ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⵉ ⴰⵙⵔⴷⴰⵙ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⴷⴷⴰⴷ ⴰⴷ.ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⴰⵍⵖⴰ ⵏ ⵓⵙⵏⵙⵍ ⵙ ⵓⵙⵙⴼⵍⴷ ⵙ ⵜⵉⵖⵣⵉ ⵏ ⴽⵓ ⵜⴳⵓⵔⵉ, ⴷ ⵇⴰⴷ ⵜⵙⵙⴽⵔⴷ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵂⴰ ⵉⴾⵉⵜⴱⴰⵏⵉⴳⴰ ⵓⵎⵙⴳⵏⴰⴼ ⴰⵀⴰ ⴰⵎⵙⴳⵏⴰⴼ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵓⵔ ⴷ ⴰⵎⵙⴳⵏⴰⴼ ⵏ ⵉⵎⴹⴰⵏ, ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵙⵢⴰⴼⴰⵏ ⵙ ⵢⴰⵏ ⵓⴽⵓⴷ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ, ⴷⴰ ⵉⵜⵜⵓⵙⴽⵙⵉ ⵜⵉⴼⵔⴽⵉⵏ ⵏⵏⴰ ⵖⵓⵔ ⵍⵍⴰⵏ ⵜⵉⵖⵣⵉⵡⵉⵏ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ, ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⵉⴹⵏⵏ ⴰⵎⵎ ⵓⴱⴰⵔⴰⵎⴰⵜⵔ,# >>> list_sort.call([""aa"", ""a"", ""aaa""])
# [""aa""]
# >>> list_sort.call([""ab"", ""a"", ""aaa"", ""cd""])
# [""ab"", ""cd""]
def sorted_list_sum(lst)
","def list_sort(arr)
  arr.select { |s| s.length.even? }
     .sort_by { |s| [s.length, s] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sorted_list_sum
    candidate = method(:sorted_list_sum)
    assert_equal([""aa""], candidate.call([""aa"", ""a"", ""aaa""]))
    assert_equal([""AI"", ""asdf"", ""school""], candidate.call([""school"", ""AI"", ""asdf"", ""b""]))
    assert_equal([], candidate.call([""d"", ""b"", ""c"", ""a""]))
    assert_equal([""abcd"", ""dcba""], candidate.call([""d"", ""dcba"", ""abcd"", ""a""]))
    assert_equal([""AI"", ""ai"", ""au""], candidate.call([""AI"", ""ai"", ""au""]))
    assert_equal([], candidate.call([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]))
    assert_equal([""cc"", ""dd"", ""aaaa"", ""bbbb""], candidate.call([""aaaa"", ""bbbb"", ""dd"", ""cc""]))
  end
end
"
HumanEval_150,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⴰⴷ ⵢⴰⴽⴽⴰ ⵡⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵡⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ.ⴰⵖⴰⵡⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵉⴳⴰ n # >>> x_or_y.call(7, 34, 12)
# 34
# >>> x_or_y.call(15, 8, 5)
# 5
def x_or_y(n, x, y)
","def x_or_y(n, x, y)
  require 'prime'
  n.prime? ? x : y
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_x_or_y
    candidate = method(:x_or_y)
    assert_equal(34, candidate.call(7, 34, 12))
    assert_equal(5, candidate.call(15, 8, 5))
    assert_equal(33, candidate.call(3, 33, 5212))
    assert_equal(3, candidate.call(1259, 3, 52))
    assert_equal(-1, candidate.call(7919, -1, 12))
    assert_equal(583, candidate.call(3609, 1245, 583))
    assert_equal(129, candidate.call(91, 56, 129))
    assert_equal(1234, candidate.call(6, 34, 1234))
    assert_equal(0, candidate.call(1, 2, 0))
    assert_equal(2, candidate.call(2, 2, 0))
  end
end
"
HumanEval_151,taq_Tfng,rb,"ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⵓⵔ ⵉⵎⴽⵍⵉ.  ⵓⵔ ⴷⴰ ⵏⵙⵙⴽⵜⵉ ⵉⵎⴹⴰⵏ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵔⴰⵏⵜⵓ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ # >>> double_the_difference.call([1, 3, 2, 0])
# 10
# >>> double_the_difference.call([-1, -2, 0])
# 0
# >>> double_the_difference.call([9, -2])
# 81
# >>> double_the_difference.call([0])
# 0
# If the input array is empty, return 0.
def double_the_difference(lst)
","def double_the_difference(lst)
  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }
     .map { |n| n ** 2 }
     .sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_double_the_difference
    candidate = method(:double_the_difference)
    assert_equal(0, candidate.call([]))
    assert_equal(25, candidate.call([5.0, 4.0]))
    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))
    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))
    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))
    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))
    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))
  end
end
"
HumanEval_152,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ:ⴰⵍⵈⵉⵎ ⵢⵈⵈⴰⵍ 0, ⵎⵢⵗ ⴰ ⴼⴰⵍ ⵓⴰⵔ ⵢⵈⵈⵢⵍ, ⴰⵍⵈⵉⵎ ⵢⵈⵈⴰⵍ ⴰⵏⵎⵉⵣⵍⴰⵉ ⵓⵍⴰⵗⴰⵏ ⵋⵉⵔ ⵜⴰ-ⵉⵜⵢ ⴷ ⵜⵢⵗⴰⵔⵢⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵜⵉⵖⵣⵉ ⵏⵏⴰ ⵉⵎⴽⵉⵏⵏⴰ ⵉⵙⵏⵎⴰⵍⴰ ⵎⴰⵢⴷ ⵉⴳⴰⵏ ⴰⴱⴰⵔⴰⵣ ⵏ ⴽⵓ ⴰⵙⵏⵖⵍ. ⵎⴽ ⵜⵔⵏⴰ ⴰⵙⵏⵖⵍ ⵙ ⵜⴷⵓⵙⵉ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵏ ⵜⵏⴰⴼⵓⵜⵉⵏ ⴷ ⵉⵙⵡⵉⵏⴳⵉⵎⵏ ⵏ ⵜⵉⵖⵣⵉ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⴳ ⴷⴰ ⵉⵙⵙⴼⵔⴰⵢ ⴽⵓ ⵉⵎⵉⴹ ⵢⴰⵜ ⵜⵎⵙⴰⵙⴰ.ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⴷ ⴰⵙ ⴰⵓⴰⴷⵉⵎ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷ ⵙ ⵜⵉⴷⵉⵜⵜ ⴼⴰⵍ ⵜⵉⵏⴼⴰ ⵏ ⵉⵛⵂ-ⵉⴾⵉⵍⴰⵏⴰⵍⴰⵗⵉ ⵏⴰⵜ ⴰⵙ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷ ⴷ ⴰⵙⵉⴾⵉ ⵏⵢⵜⴰⴾⴰⵉⴰⴷ ⵓⴰ ⵉⴾⵏⴰⵏ ⵜⴰ-ⵉⵜⵢ ⵏ-ⴰⴾⴰⵉⴰⴷ ⵓⴰ ⵉⴾⵏⴰⵏ ⴰⵍⵓⴰⵈ ⵓⵢⵏⴰⵂⴰⵏⴰⵉ ⴰⵏ ⵏⴰⴾⴰⵍ ⴰⵜⵉⵓⴰⵏⵏⴰ ⴰⵏ ⵜⴰ-ⵉⵜⵢ ⴰⵏ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
# [0, 0, 0, 0, 3, 3]
# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
# [4, 4, 1, 0, 0, 6]
def compare(game, guess)
","def compare(game, guess)
  game.zip(guess).map { |score, prediction| (score - prediction).abs }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare
    candidate = method(:compare)
    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))
    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))
    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))
    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))
  end
end
"
HumanEval_153,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: (ⵜⵓⵙⴷⵉⴷⵜ ⵏⵏⵙ ⵜⴳⴰ -1).return ""Slices.SErviNGSliCes"" ⴰⵛⴽⵓ ""SErviNGSliCes"" ⵉⴳⴰ ⵓⵙⵙⵖⵣⵏ ⵉⴷⵓⵙⵏ ⵉⵙⵎ ⵏ ⵓⵙⵙⴰⵔⵓ: ['ⵙⵉⵔⴼⵉⵏⴳⵙⵍⵉⵛⵙ', 'ⵛⵉⵣ', 'ⵙⵜⵓⴼⴼⵉⴷ'], ⵇⴰⴷ ⵜⵙⵙⵏⴷⵙ ⵓⵎⴷⵢⴰ, ⵎⴽ ⵜⵜⵓⴼⴽⴰ ""ⵙⵍⴰⵢⵛⵙ"" ⴰⵎⵎ ⵜⵣⵔⴰⵡⵜ ⴷ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⴷⴰ ⵉⵜⵜⵓⵙⵜⴰ ⵡⴰⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵏⵏⴰⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ.ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵏ ⵉⵙⵖⵣⵣⵉⴼⵏ ⵏⵖ ⵓⴳⴳⴰⵔ ⵙ ⵢⴰⵜ ⵜⵉⴷⵜ, ⵇⴰⴷ ⵜⵙⵙⴽⵛⵎ format: ClassName.StrongestExtensionName. ⵇⴰⴷ ⵜⵙⵙⵉⴼⴹ ⵜⴰⴳⵣⵉⵔⵜ ⵜⴰⴷⵓⵙⵜ ⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵉⵍⴰ ⴳ ⵓⵢⴰ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵣⵎⵔⵜ ⵙ ⵜⴽⵕⴹⵉ CAP - SM. ⵜⵉⴼⵔⵉⵙⵉⵏ ⴳ ⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷ ⴰⴷ ⵜⴳ SM ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵜⵉⵎⵥⵥⵢⴰⵏⵉⵏ ⵜⴰⵣⵓⵏⵜ ⵏ ⵓⵙⵙⵖⵣⵣⵉⴼ ⵜⴳⴰ ⵣⵓⵏⴷ ⴰⵢⴰ: ⴰⴷ ⵜⴳ CAP ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵔⵔⴰ ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵜⵔⵏⵓⵜⵉⵏ ⵃⵎⴰ ⴰⴷ ⵜⵜⵓⵙⴽⵛⵎⵏ ⵉⵙⵍⵎⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ ⴳ ⵓⵙⵍⵎⴷ.ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⵉⵙⵎ ⵏ ⵜⵔⴳⴰ (ⵜⴰⵏⴳⵉ) ⴷ ⵢⴰⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵉⵙⵖⵣⵏ.# >>> Strongest_Extension.call(""my_class"", [""AA"", ""Be"", ""CC""])
# ""my_class.AA""
def Strongest_Extension(class_name, extensions)
","def Strongest_Extension(class_name, extensions)
  strongest_extension = extensions.max_by do |extension|
    cap_count = extension.count('A-Z')
    sm_count = extension.count('a-z')
    cap_count - sm_count
  end
  ""#{class_name}.#{strongest_extension}""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_Strongest_Extension
    candidate = method(:Strongest_Extension)
    assert_equal(""Watashi.eIGHt8OKe"", candidate.call(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]))
    assert_equal(""Boku123.YEs.WeCaNe"", candidate.call(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]))
    assert_equal(""__YESIMHERE.NuLl__"", candidate.call(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]))
    assert_equal(""K.TAR"", candidate.call(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]))
    assert_equal(""__HAHA.123"", candidate.call(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]))
    assert_equal(""YameRore.okIWILL123"", candidate.call(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]))
    assert_equal(""finNNalLLly.WoW"", candidate.call(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]))
    assert_equal(""_.Bb"", candidate.call(""_"", [""Bb"", ""91245""]))
    assert_equal(""Sp.671235"", candidate.call(""Sp"", [""671235"", ""Bb""]))
  end
end
"
HumanEval_154,taq_Tfng,rb,"ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵇⴰⴷ ⵜⵔⴰⵔⴷ true ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵏⵖ ⴽⵔⴰ ⵏ ⵜⵙⵓⵜⵍⵉⵏ ⵏⵏⵙ ⵜⴰⴳⵓⵔⵉ ⵜⴰⴷⵙⵍⴰⵏⵜ ⴳ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ.# >>> cycpattern_check.call(""abcd"", ""abd"")
# false
# >>> cycpattern_check.call(""hello"", ""ell"")
# true
# >>> cycpattern_check.call(""whassup"", ""psus"")
# false
# >>> cycpattern_check.call(""abab"", ""baa"")
# true
# >>> cycpattern_check.call(""efef"", ""eeff"")
# false
# >>> cycpattern_check.call(""himenss"", ""simen"")
# true
def cycpattern_check(a, b)
","def cycpattern_check(a, b)
  (0...b.length).each do |i|
    rotated_b = b[i..-1] + b[0...i]
    return true if a.include?(rotated_b)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_cycpattern_check
    candidate = method(:cycpattern_check)
    assert_equal(false, candidate.call(""xyzw"", ""xyw""))
    assert_equal(true, candidate.call(""yello"", ""ell""))
    assert_equal(false, candidate.call(""whattup"", ""ptut""))
    assert_equal(true, candidate.call(""efef"", ""fee""))
    assert_equal(false, candidate.call(""abab"", ""aabb""))
    assert_equal(true, candidate.call(""winemtt"", ""tinem""))
  end
end
"
HumanEval_155,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵉⴳ ⵏⵙⴽⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ, ⵏⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵉⴷⵏ ⴷ ⵉⵎⵎⵉⴷⵏ ⵙ ⵓⵎⵣⴰⵔⴰⵢ.# >>> even_odd_count.call(-12)
# [1, 1]
# >>> even_odd_count.call(123)
# [1, 2]
def even_odd_count(num)
","def even_odd_count(num)
  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_count
    candidate = method(:even_odd_count)
    assert_equal([0, 1], candidate.call(7))
    assert_equal([1, 1], candidate.call(-78))
    assert_equal([2, 2], candidate.call(3452))
    assert_equal([3, 3], candidate.call(346211))
    assert_equal([3, 3], candidate.call(-345821))
    assert_equal([1, 0], candidate.call(-2))
    assert_equal([2, 3], candidate.call(-45347))
    assert_equal([1, 0], candidate.call(0))
  end
end
"
HumanEval_156,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵜⵉⵎⵥⴰⴳⵉⵏ: 1 <= num <= 1000 ⴷ ⵙ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵓⴽⵙⴰⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ, ⵙⵙⵓⵜⵔ ⴰⵎⵙⴽⴰⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵕⵓⵎⵉⵢⵏ ⵏⵏⵙ ⴰⵎⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ, # >>> int_to_mini_roman.call(19)
# ""xix""
# >>> int_to_mini_roman.call(152)
# ""clii""
# >>> int_to_mini_roman.call(426)
# ""cdxxvi""
def int_to_mini_roman(number)
","def int_to_mini_roman(number)
  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']

  result = ''
  values.each_with_index do |value, index|
    while number >= value
      number -= value
      result += numerals[index]
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_int_to_mini_roman
    candidate = method(:int_to_mini_roman)
    assert_equal(""xix"", candidate.call(19))
    assert_equal(""clii"", candidate.call(152))
    assert_equal(""ccli"", candidate.call(251))
    assert_equal(""cdxxvi"", candidate.call(426))
    assert_equal(""d"", candidate.call(500))
    assert_equal(""i"", candidate.call(1))
    assert_equal(""iv"", candidate.call(4))
    assert_equal(""xliii"", candidate.call(43))
    assert_equal(""xc"", candidate.call(90))
    assert_equal(""xciv"", candidate.call(94))
    assert_equal(""dxxxii"", candidate.call(532))
    assert_equal(""cm"", candidate.call(900))
    assert_equal(""cmxciv"", candidate.call(994))
    assert_equal(""m"", candidate.call(1000))
  end
end
"
HumanEval_157,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: 90 ⴷⴻⴶⵔⴻⴻⴻ.ⵜⴰⴾⴾⵓⵣⵜ ⵜⴰ ⵜⴰⵂⴰⵜ ⵜⴰⵂⵔⵉⴾⴻ ⵜⴰ ⵜⴰⵈⵈⴰⵍ ⵜⴰⴾⴾⵓⵣⵜ ⴷⴰⵗ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴾⵓⵣ ⵉⵉⵉⴰⵏ ⴰⴾⴾⵓⵣ ⵎⴻⵗⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⵉⵖⵎⵔⵉⵏ ⵜⵉⴷⵙⵍⴰⵏⵉⵏ, ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵙⵜ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⵉⵙⴳⵡⵉⵏ. ⵔⴰⴷ ⵏⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵔⴰⴷ ⴽⵕⴰⴹ # >>> right_angle_triangle.call(3, 4, 5)
# true
# >>> right_angle_triangle.call(1, 2, 3)
# false
def right_angle_triangle(a, b, c)
","def right_angle_triangle(a, b, c)
  sides = [a, b, c].sort
  sides[0]**2 + sides[1]**2 == sides[2]**2
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_right_angle_triangle
    candidate = method(:right_angle_triangle)
    assert_equal(true, candidate.call(3, 4, 5))
    assert_equal(false, candidate.call(1, 2, 3))
    assert_equal(true, candidate.call(10, 6, 8))
    assert_equal(false, candidate.call(2, 2, 2))
    assert_equal(true, candidate.call(7, 24, 25))
    assert_equal(false, candidate.call(10, 5, 7))
    assert_equal(true, candidate.call(5, 12, 13))
    assert_equal(true, candidate.call(15, 8, 17))
    assert_equal(true, candidate.call(48, 55, 73))
    assert_equal(false, candidate.call(1, 1, 1))
    assert_equal(false, candidate.call(2, 2, 10))
  end
end
"
HumanEval_158,taq_Tfng,rb,"ⵔⴻⵜⵔⵓⵏ ⵆⴰⵔⴻⵛⵜⴻⵔⵙ , ⴰⴷⴷoⴱⴰⵜ ⵓⴰ ⴰⵣⵣⴰⵔⴰⵏ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵏ ⴰⵍⵎⴰⵗⵏⴰ ⵏ ⵉⵙⵎⴰⵓⴰⵏⵎⴽ ⴳⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴽⵉⴳⴰⵏ, ⴷⴰ ⵉⵜⵜⴰⵎⵥ ⵓⵎⵙⴳⵏⴰⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵔⴰⵏⵜⵔ ⵜⴳⵓⵔⵉ ⵙ ⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⵉⴹⵏⵏ.# >>> find_max.call([""name"", ""of"", ""string""])
# ""string""
# >>> find_max.call([""name"", ""enam"", ""game""])
# ""enam""
# >>> find_max.call([""aaaaaaa"", ""bb"", ""cc""])
# ""aaaaaaa""
def find_max(words)
","def find_max(words)
  # Helper function to count unique characters
  def unique_char_count(word)
    word.chars.uniq.size
  end

  words.max_by { |word| [unique_char_count(word), -word] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_max
    candidate = method(:find_max)
    assert_equal(""string"", candidate.call([""name"", ""of"", ""string""]))
    assert_equal(""enam"", candidate.call([""name"", ""enam"", ""game""]))
    assert_equal(""aaaaaaa"", candidate.call([""aaaaaaa"", ""bb"", ""cc""]))
    assert_equal(""abc"", candidate.call([""abc"", ""cba""]))
    assert_equal(""footbott"", candidate.call([""play"", ""this"", ""game"", ""of"", ""footbott""]))
    assert_equal(""gonna"", candidate.call([""we"", ""are"", ""gonna"", ""rock""]))
    assert_equal(""nation"", candidate.call([""we"", ""are"", ""a"", ""mad"", ""nation""]))
    assert_equal(""this"", candidate.call([""this"", ""is"", ""a"", ""prrk""]))
    assert_equal(""b"", candidate.call([""b""]))
    assert_equal(""play"", candidate.call([""play"", ""play"", ""play""]))
  end
end
"
HumanEval_159,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ: ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵉⵔⵖⵉⵢⵏ ⵉⵇⵇⵉⵎⵏ, ⵔⴰⴷ ⵜⵙⵙⵓⵜⵎ ⴰⴽⴽⵡ ⵉⵔⵖⵉⵢⵏ ⵉⵇⵇⵉⵎⵏ, ⵎⴰⴽⴰ ⵔⴰⴷ ⵜⵇⵇⵉⵎ ⵜⵔⵖⵉ.ⴰⴹⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵏⵏⴰ ⴷ ⵉⵇⵇⵉⵎⵏ ⴷⴼⴼⵉⵔ ⵏ ⵡⵓⵜⵛⵉ ⵏⵏⴽ ] ⵉⵇⵏⴻⵏ ⴰⴷ ⵜⴰⵔⴻⴷ ⴰⵎⵙⴳⵏⴰⴼ ⵏ [ⴰⵎⴹⴰⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵏⵏⴰ ⵜⵙⵙⵓⵜⵔⴷ ⴷⴼⴼⵉⵔ ⵏ ⵜⴰⵢⵢⵔⵉ, ⵎⴰⵛⴰ ⴷⵖⴰ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵜⵜⵓⵢⴷ ⴽⵉⴳⴰⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵎⵓⵔⵎ ⵜⴰⵢⵢⵉⵔⴰ ⵏ ⵡⴰⵙⵙ.ⴻⵈⴰⵍⴻ ⵜⴰⵛⵉⵛⴻⵜ ⵜⴰ ⵜⴰⴶⴰⵏⴻⵏ ⴰⵛⴻⵛ, ⴰⴷ ⴾⴰⵍⴰ ⵉⴶⵔⴰⵓⴻⵜ ⴰⴶⵓⴷⴰⵏ ⴰⵏ ⵜⴰⵛⵉⵛⴻⵜ ⴰⵏ ⴾⴰⵔⵓⵜⴻⵏ,# >>> eat.call(5, 6, 10)
# [11, 4]
# >>> eat.call(4, 8, 9)
# [12, 1]
# >>> eat.call(1, 10, 10)
# [11, 0]
# >>> eat.call(2, 11, 5)
# [7, 0]
# Variables:
# @number : integer
# the number of carrots that you have eaten.
# @need : integer
# the number of carrots that you need to eat.
# @remaining : integer
# the number of remaining carrots thet exist in stock
# Constrain:
# * 0 <= number <= 1000
# * 0 <= need <= 1000
# * 0 <= remaining <= 1000
# Have fun :)
def eat(number, need, remaining)
","def eat(number, need, remaining)
  total_eaten = number + [need, remaining].min
  carrots_left = [remaining - need, 0].max
  [total_eaten, carrots_left]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_eat
    candidate = method(:eat)
    assert_equal([11, 4], candidate.call(5, 6, 10))
    assert_equal([12, 1], candidate.call(4, 8, 9))
    assert_equal([11, 0], candidate.call(1, 10, 10))
    assert_equal([7, 0], candidate.call(2, 11, 5))
    assert_equal([9, 2], candidate.call(4, 5, 7))
    assert_equal([5, 0], candidate.call(4, 5, 1))
  end
end
"
HumanEval_160,taq_Tfng,rb,"ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⴳ ⵓⵙⵔⵔⵓⵙ ⵏ ⵓⵎⵙⴽⴰⵔ ⵢⴰⵏ ⵓⵎⵙⴽⴰⵔ, ⴷ ⵓⵙⵔⵔⵓⵙ ⵏ ⵓⵎⵙⴽⴰⵔ ⵏ ⵓⵎⵙⴽⴰⵔ ⵙ ⵙⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ.ⵉⴳⴰ ⵓⴱⵢⵔⴰⵏⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵢⵏ.ⵜⵉⵖⵣⵉ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⵎⵙⵡⵓⵔⵉ ⵜⴳⴰ ⵜⵜ ⵜⵉⵖⵣⵉ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⵎⵙⵡⵓⵔⵉ ⵎⵉⵏⵓⵙ ⵢⴰⵏ.ⴰⵜⵡⵉⵍ: => ⵜⴰⵢⴰⴼⵓⵜ = 9 ⵜⴰⵢⴰⴼⵓⵜ = 2 + 3 * 4 - 5 ⴰⵙⵔⵔⵓⵙ = [2, 3, 4, 5] ⴰⵎⵙⵙⵎⵔⵙⴰⵍ['+', '*', '-'] ⴰⵍⵎⵉⵜⴰⵍ: ⴰⵙⵎⵓⵜⵜⴳ (**) ⴰⴱⵟⵟⵓ ⵏ ⵜⵣⴰⵍⵖⵉⵡⵉⵏ ( //) ⴰⵙⴼⵓⴷⴷⵓ (*) ⵜⵓⴽⴽⵙⴰ ( - ) ⴰⵙⵎⵓⵏ ( +) ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵏ ⵓⵙⵉⵙⵙⵏ: ⵉⵙⵎ ⵏ ⵓⵙⵏⵓⵎⵎⵍ ⴷ ⵓⵙⵡⴰⵍⴰ ⵏ ⵓⵙⵎⵉⵍ ⴰⴷ. ⵜⴰⴳⵔⵡⴰⵏⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵜⴳⴰ ⵜⴰⴳⵔⵡⴰⵏⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵎⵔⵙⵏⵜ ⵙⵏⴰⵜ ⵏ ⵜⴳⵔⵡⴰⵏⵜ ⵉⵜⵜⵓⴼⴽⴰⵏ  ⵃⵎⴰ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔⵏⵜ ⵜⴱⵔⵉⴷⵉⵏ ⵏ ⵍⵊⵉⴱⵔ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵏ ⵉⵎⵙⴷⴷⵉⵜⵏ, ⴷ ⵓⵎⵙⴽⴰⵔ. ⴰⵎⵙⴷⴷⵉⵜ ⴰⵎⵣⵡⴰⵔⵓ ⵖⵓⵔⵙ ⵜⵉⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ, ⴷ def do_algebra(operator, operand)
","def do_algebra(operator, operand)
  expression = operand[0].to_s
  operator.each_with_index do |op, index|
    if op == '//'
      expression += ' / ' + operand[index + 1].to_s
    else
      expression += ' ' + op + ' ' + operand[index + 1].to_s
    end
  end
  eval(expression)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_do_algebra
    candidate = method(:do_algebra)
    assert_equal(37, candidate.call([""**"", ""*"", ""+""], [2, 3, 4, 5]))
    assert_equal(9, candidate.call([""+"", ""*"", ""-""], [2, 3, 4, 5]))
    assert_equal(8, candidate.call([""//"", ""*""], [7, 3, 4]))
  end
end
"
HumanEval_161,taq_Tfng,rb,"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵍⴰⵇⴱⴰⵍ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⴹⵓ ⵜⵉⴼⵔⴽⵜ ⵏ ⵜⵢⴰⴼⵓⵜ.ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴳ ⵜⵉⴼⵔⵜ ⴽⵔⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⵙⵙⵓⵜⵍ ⵜⵉⴼⵔⵜ.ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴰⵢⴰ ⵃⴹⵓ ⵖⵉⴽⵍⵍⵉ ⵉⴳⴰ.ⵎⴽ ⵜⴳⴰ s[i] ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⵙⵙⵓⵜⵔ ⵜⴰⵡⴰⵍⵜ ⵏⵏⵙ ⵙⴳ ⴷⴷⴰⵡ ⴰⵔ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⵎⵣⴰⵔⴰⵢ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ s.# >>> solve.call(""1234"")
# ""4321""
# >>> solve.call(""ab"")
# ""AB""
# >>> solve.call(""#a@C"")
# ""#A@c""
def solve(s)
","def solve(s)
  if s =~ /[a-zA-Z]/
    s.chars.map { |char| char =~ /[a-zA-Z]/ ? char.swapcase : char }.join
  else
    s.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""aSdF"", candidate.call(""AsDf""))
    assert_equal(""4321"", candidate.call(""1234""))
    assert_equal(""AB"", candidate.call(""ab""))
    assert_equal(""#A@c"", candidate.call(""#a@C""))
    assert_equal(""#aSDFw^45"", candidate.call(""#AsdfW^45""))
    assert_equal(""2@6#"", candidate.call(""#6@2""))
    assert_equal(""#$A^d"", candidate.call(""#$a^D""))
    assert_equal(""#CCC"", candidate.call(""#ccc""))
  end
end
"
HumanEval_162,taq_Tfng,rb,"ⵎⴽ ⵉⴳⴰ 'text' ⵢⴰⵏ ⵓⴹⵕⵉⵚ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ, ⵔⵉⵜⵓⵔⵏ nil.ⵙ ⵜⵉⴽⴽⵉ ⵏ ""ⵜⵉⴽⵙⵜ"" ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵓⵍⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏ ""ⵀⴰⵛⵉ"" ⵏ md5 ⵏⵏⵙ. # >>> string_to_md5.call(""Hello world"")
# ""3e25960a79dbc69b674cd4ec67a72c62""
def string_to_md5(text)
","require 'digest'

def string_to_md5(text)
  return nil if text.empty?
  Digest::MD5.hexdigest(text)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_to_md5
    candidate = method(:string_to_md5)
    assert_equal(""3e25960a79dbc69b674cd4ec67a72c62"", candidate.call(""Hello world""))
    assert_equal(nil, candidate.call(""""))
    assert_equal(""0ef78513b0cb8cef12743f5aeb35f888"", candidate.call(""A B C""))
    assert_equal(""5f4dcc3b5aa765d61d8327deb882cf99"", candidate.call(""password""))
  end
end
"
HumanEval_163,taq_Tfng,rb,"ⵙ ⵓⵎⴷⵢⴰ: ⴷ ⴱ, ⵙ ⵓⵍⵍⵙ ⵏ ⵓⵙⵙⴰⵔⵓ.ⴳ ⵜⵉⴽⴽⵉ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ a ⴷ b, ⵙⵙⴽⵛⵎ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⵡⵉⵏ ⴳⵔ a # >>> generate_integers.call(2, 8)
# [2, 4, 6, 8]
# >>> generate_integers.call(8, 2)
# [2, 4, 6, 8]
# >>> generate_integers.call(10, 14)
# []
def generate_integers(a, b)
","def generate_integers(a, b)
  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_generate_integers
    candidate = method(:generate_integers)
    assert_equal([2, 4, 6, 8], candidate.call(2, 10))
    assert_equal([2, 4, 6, 8], candidate.call(10, 2))
    assert_equal([2, 4, 6, 8], candidate.call(132, 2))
    assert_equal([], candidate.call(17, 89))
  end
end
"
