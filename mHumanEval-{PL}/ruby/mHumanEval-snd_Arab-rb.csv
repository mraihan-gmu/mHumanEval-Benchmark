task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,snd_Arab,rb," جي حد تائينچيڪ ڪريو ته ڏنل نمبرن جي صف ۾، ڪي ٻه نمبر هڪ ٻئي کان ويجها آهن # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)
# false
# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
# true
def has_close_elements(numbers, threshold)
","def has_close_elements(numbers, threshold)
  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_has_close_elements
    candidate = method(:has_close_elements)
    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))
    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))
    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))
    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))
    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))
    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))
    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))
  end
end
"
HumanEval_1,snd_Arab,rb,"انپٽ اسٽرنگ ۾ موجود اسپيسز کي نظرانداز ڪريو.ڌار ڌار گروپ متوازن آهن (هر کليل بيس مناسب طور تي بند ٿيل آهي) ۽ هڪ ٻئي جي اندر نه آهن.انهن گروپن کي الڳ الڳ اسٽرنگز ۾ ڌار ڪري ۽ انهن جي صف واپس ڪري.هن فنڪشن ۾ انپٽ هڪ اسٽرنگ آهي جنهن ۾ گھڻن گروپن جي جڙيل قوسين جو مشتمل آهي. توهان جو مقصد آهي # >>> separate_paren_groups.call(""( ) (( )) (( )( ))"")
# [""()"", ""(())"", ""(()())""]
def separate_paren_groups(paren_string)
","def separate_paren_groups(paren_string)
  # Remove spaces from the string
  paren_string = paren_string.gsub("" "", """")
  
  result = []
  current_group = """"
  balance = 0

  paren_string.each_char do |char|
    current_group += char
    balance += 1 if char == '('
    balance -= 1 if char == ')'

    if balance == 0 && !current_group.empty?
      result << current_group
      current_group = """"
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_separate_paren_groups
    candidate = method(:separate_paren_groups)
    assert_equal([""(()())"", ""((()))"", ""()"", ""((())()())""], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([""()"", ""(())"", ""((()))"", ""(((())))""], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([""(()(())((())))""], candidate.call(""(()(())((())))""))
    assert_equal([""()"", ""(())"", ""(()())""], candidate.call(""( ) (( )) (( )( ))""))
  end
end
"
HumanEval_2,snd_Arab,rb,"نمبر جي اعشاري حصي کي موٽايو.(باقي حصو هميشه 1 کان ننڍو هوندو آهي).۽ انٽيگر حصو (وڏي کان وڏو انٽيگر ڏنل نمبر کان نن smallerو) ۽ ڊيسمل مثبت فلوٽنگ پوائنٽ نمبر ڏنو ويو، ان کي  ۾ ٽوڙي سگهجي ٿو.# >>> truncate_number.call(3.5)
# 0.5
def truncate_number(number)
","def truncate_number(number)
  number - number.to_i
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_truncate_number
    candidate = method(:truncate_number)
    assert_equal(0.5, candidate.call(3.5))
    assert_equal(0.25, candidate.call(1.25))
    assert_equal(0.0, candidate.call(123.0))
  end
end
"
HumanEval_3,snd_Arab,rb,"ان وقت فنڪشن کي صحيح موٽڻ گهرجي. ٻي صورت ۾ اهو غلط موٽڻ گهرجي.صفر بيلنس. توهان جو ڪم اهو معلوم ڪرڻ آهي ته ڪنهن به نقطي تي اڪائونٽ بيلنس صفر کان هيٺ اچي وڃي ٿو ، ۽ توهان کي هڪ بينڪ اڪائونٽ تي جمع ۽ واپسي جي عملن جي هڪ صف ڏني وئي آهي جيڪا شروع ٿئي ٿي# >>> below_zero.call([1, 2, 3])
# false
# >>> below_zero.call([1, 2, -4, 5])
# true
def below_zero(operations)
","def below_zero(operations)
  balance = 0
  operations.each do |operation|
    balance += operation
    return true if balance < 0
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_zero
    candidate = method(:below_zero)
    assert_equal(false, candidate.call([]))
    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))
    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))
    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))
    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))
    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))
  end
end
"
HumanEval_4,snd_Arab,rb,"MAD = اوسط. x - x_mean. عنصر ۽ هڪ مرڪزي نقطو (هن صورت ۾ مطلب): اوسط مطلق انحراف هر هڪ جي وچ ۾ اوسط مطلق فرق آهي.هن ڊيٽا سيٽ جي وچ ۾.انپٽ نمبرن جي ڏنل صف لاءِ ، اوسط مطلق انحراف جو حساب ڪريو # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])
# 1.0
def mean_absolute_deviation(numbers)
","def mean_absolute_deviation(numbers)
  mean = numbers.sum.to_f / numbers.size
  deviations = numbers.map { |num| (num - mean).abs }
  deviations.sum / numbers.size
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_mean_absolute_deviation
    candidate = method(:mean_absolute_deviation)
    assert_equal(0.5, candidate.call([1.0, 2.0]))
    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))
    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
  end
end
"
HumanEval_5,snd_Arab,rb,"داخل ٿيل صف جي هر ٻن لڳاتار عناصر جي وچ ۾ هڪ نمبر ""ڊيلميٽر"" داخل ڪريو ∀numbers"" # >>> intersperse.call([], 4)
# []
# >>> intersperse.call([1, 2, 3], 4)
# [1, 4, 2, 4, 3]
def intersperse(numbers, delimeter)
","def intersperse(numbers, delimeter)
  return numbers if numbers.empty?
  result = []
  numbers.each_with_index do |num, index|
    result << num
    result << delimeter unless index == numbers.size - 1
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersperse
    candidate = method(:intersperse)
    assert_equal([], candidate.call([], 7))
    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))
    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))
  end
end
"
HumanEval_6,snd_Arab,rb,"مثال طور (() (()) ۾ وڌ ۾ وڌ ٻه سطحون آهن جڏهن ته ((())) ۾ ٽي آهن. هر گروپ لاءِ ، قوسين جي گهيري جي سڀ کان وڏي سطح کي ٻاھر ڪ ڻ.هن فنڪشن جو ان پٽ هڪ اسٽرنگ آهي جيڪا گھڻن گروپن جي نمائندگي ڪري ٿي جڙيل قوسين لاءِ جيڪي خلا سان ڌار ٿيل آهن.# >>> parse_nested_parens.call(""(()()) ((())) () ((())()())"")
# [2, 3, 1, 3]
def parse_nested_parens(paren_string)
","def parse_nested_parens(paren_string)
  paren_string.split.map do |group|
    max_depth = current_depth = 0
    group.chars.each do |char|
      if char == '('
        current_depth += 1
        max_depth = [max_depth, current_depth].max
      elsif char == ')'
        current_depth -= 1
      end
    end
    max_depth
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_nested_parens
    candidate = method(:parse_nested_parens)
    assert_equal([2, 3, 1, 3], candidate.call(""(()()) ((())) () ((())()())""))
    assert_equal([1, 2, 3, 4], candidate.call(""() (()) ((())) (((())))""))
    assert_equal([4], candidate.call(""(()(())((())))""))
  end
end
"
HumanEval_7,snd_Arab,rb,"صرف انهن لاءِ داخل ٿيل اسٽرنگز جي صف کي فلٽر ڪريو جيڪي ڏنل سبسٽنگ تي مشتمل آهن# >>> filter_by_substring.call([], ""a"")
# []
# >>> filter_by_substring.call([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
# [""abc"", ""bacd"", ""array""]
def filter_by_substring(strings, substring)
","def filter_by_substring(strings, substring)
  strings.select { |string| string.include?(substring) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_substring
    candidate = method(:filter_by_substring)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
    assert_equal([""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""))
    assert_equal([""grunt"", ""prune""], candidate.call([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""))
  end
end
"
HumanEval_8,snd_Arab,rb,"خالي جمع 0 ۽ خالي پيداوار 1 جي برابر هجڻ گهرجي.انٽيگرز جي ڏنل صف لاءِ ، هڪ صف واپس ڪريو جنهن ۾ هڪ صف ۾ سڀني انٽيگرز جو مجموعو ۽ هڪ پيداوار شامل آهي.# >>> sum_product.call([])
# [0, 1]
# >>> sum_product.call([1, 2, 3, 4])
# [10, 24]
def sum_product(numbers)
","def sum_product(numbers)
  sum = numbers.reduce(0, :+)
  product = numbers.reduce(1, :*)
  [sum, product]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_product
    candidate = method(:sum_product)
    assert_equal([0, 1], candidate.call([]))
    assert_equal([3, 1], candidate.call([1, 1, 1]))
    assert_equal([100, 0], candidate.call([100, 0]))
    assert_equal([15, 105], candidate.call([3, 5, 7]))
    assert_equal([10, 10], candidate.call([10]))
  end
end
"
HumanEval_9,snd_Arab,rb,"جي تسلسل ۾.ڏنل عدد جي صف مان، ڏنل وقت تائين مليل وڌ ۾ وڌ عنصر جي صف ٺاهي.# >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])
# [1, 2, 3, 3, 3, 4, 4]
def rolling_max(numbers)
","def rolling_max(numbers)
  max_so_far = numbers.first
  numbers.map do |num|
    max_so_far = [max_so_far, num].max
  end
end

# Example usage:
# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rolling_max
    candidate = method(:rolling_max)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))
    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))
  end
end
"
HumanEval_10,snd_Arab,rb,"- اسٽرنگ جي آخر ۾ هڪ اسٽرنگ پريفڪس جو ريورس شامل ڪريو جيڪو پيلنڊرومڪ ضمير کان اڳ اچي ٿو.- ڏنل اسٽرنگ جو سڀ کان ڊگهو پوسٽ فڪس ڳوليو جيڪو هڪ پيلنڊروم آهي. الگورٿم جو خيال سادو آهي: مختصر ترين پيلنڊروم ڳوليو جيڪو ڏنل اسٽرنگ سان شروع ٿئي ٿو.# >>> make_palindrome.call("""")
# """"
# >>> make_palindrome.call(""cat"")
# ""catac""
# >>> make_palindrome.call(""cata"")
# ""catac""
def make_palindrome(string)
","def make_palindrome(string)
  return string if string.empty?

  def is_palindrome?(s)
    s == s.reverse
  end

  (0...string.length).reverse_each do |i|
    if is_palindrome?(string[i..-1])
      return string + string[0...i].reverse
    end
  end

  string
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_palindrome
    candidate = method(:make_palindrome)
    assert_equal("""", candidate.call(""""))
    assert_equal(""x"", candidate.call(""x""))
    assert_equal(""xyzyx"", candidate.call(""xyz""))
    assert_equal(""xyx"", candidate.call(""xyx""))
    assert_equal(""jerryrrej"", candidate.call(""jerry""))
  end
end
"
HumanEval_11,snd_Arab,rb,"انهن انپٽس تي بائنري XOR انجام ڏيو ۽ نتيجو پڻ هڪ اسٽرنگ جي طور تي موٽايو.انپٽ ٻه اسٽرنگس آهن a ۽ b جن ۾ صرف 1 ۽ 0 آهن.# >>> string_xor.call(""010"", ""110"")
# ""100""
def string_xor(a, b)
","def string_xor(a, b)
  result = """"
  a.length.times do |i|
    result << (a[i] == b[i] ? ""0"" : ""1"")
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_xor
    candidate = method(:string_xor)
    assert_equal(""010010"", candidate.call(""111000"", ""101010""))
    assert_equal(""0"", candidate.call(""1"", ""1""))
    assert_equal(""0101"", candidate.call(""0101"", ""0000""))
  end
end
"
HumanEval_12,snd_Arab,rb,"ساڳي ڊيگهه جي تارن کي واپس آڻڻ جي صورت ۾ انٽري صف خالي آهي.string جي صف مان، سڀ کان ڊگھي string کي موٽايو.# >>> longest.call([])
# nil
# >>> longest.call([""a"", ""b"", ""c""])
# ""a""
# >>> longest.call([""a"", ""bb"", ""ccc""])
# ""ccc""
def longest(strings)
","def longest(strings)
  return nil if strings.empty?
  strings.max_by(&:length)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_longest
    candidate = method(:longest)
    assert_equal(nil, candidate.call([]))
    assert_equal(""x"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""zzzz"", candidate.call([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]))
  end
end
"
HumanEval_13,snd_Arab,rb,"ٻه integers a ۽ b جي وڏي ۾ وڏي عام divisor موٽي # >>> greatest_common_divisor.call(3, 5)
# 1
# >>> greatest_common_divisor.call(25, 15)
# 5
def greatest_common_divisor(a, b)
","def greatest_common_divisor(a, b)
  while b != 0
    a, b = b, a % b
  end
  a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_greatest_common_divisor
    candidate = method(:greatest_common_divisor)
    assert_equal(1, candidate.call(3, 7))
    assert_equal(5, candidate.call(10, 15))
    assert_equal(7, candidate.call(49, 14))
    assert_equal(12, candidate.call(144, 60))
  end
end
"
HumanEval_14,snd_Arab,rb,"سڀني اڳياڻن جي صف موٽائي ٿو انپٽ اسٽرنگ جي مختصر کان ڊگهي تائين # >>> all_prefixes.call(""abc"")
# [""a"", ""ab"", ""abc""]
def all_prefixes(string)
","def all_prefixes(string)
  (1..string.length).map { |i| string[0, i] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_all_prefixes
    candidate = method(:all_prefixes)
    assert_equal([], candidate.call(""""))
    assert_equal([""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""], candidate.call(""asdfgh""))
    assert_equal([""W"", ""WW"", ""WWW""], candidate.call(""WWW""))
  end
end
"
HumanEval_15,snd_Arab,rb,"0 کان وٺي n تائين شامل ڪيل نمبرن تي مشتمل هڪ تار واپس ڪريو. # >>> string_sequence.call(0)
# ""0""
# >>> string_sequence.call(5)
# ""0 1 2 3 4 5""
def string_sequence(n)
","def string_sequence(n)
  (0..n).to_a.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_sequence
    candidate = method(:string_sequence)
    assert_equal(""0"", candidate.call(0))
    assert_equal(""0 1 2 3"", candidate.call(3))
    assert_equal(""0 1 2 3 4 5 6 7 8 9 10"", candidate.call(10))
  end
end
"
HumanEval_16,snd_Arab,rb,"هڪ اسٽرنگ ڏني وئي، معلوم ڪريو ته ڪيترا مختلف اکر (ڪيس جي قطع نظر) ان ۾ شامل آهن# >>> count_distinct_characters.call(""xyzXYZ"")
# 3
# >>> count_distinct_characters.call(""Jerry"")
# 4
def count_distinct_characters(string)
","def count_distinct_characters(string)
  string.downcase.chars.uniq.count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_distinct_characters
    candidate = method(:count_distinct_characters)
    assert_equal(0, candidate.call(""""))
    assert_equal(5, candidate.call(""abcde""))
    assert_equal(5, candidate.call(""abcdecadeCADE""))
    assert_equal(1, candidate.call(""aaaaAAAAaaaa""))
    assert_equal(5, candidate.call(""Jerry jERRY JeRRRY""))
  end
end
"
HumanEval_17,snd_Arab,rb,"'ڪهڙو' - چوٿون نوٽ، هڪ ڌڪ لڳندو آهي.'او ڊيڪس' - اڌ نوٽ، ٻن ڌڪن تائين هلندو آهي.'او' - پوري نوٽ، چار بيٽس تائين هلندي آهي.هتي هڪ ڏند ڪٿا آهي:نه آخري.توهان جو ڪم هن تار کي پارس ڪرڻ ۽ انٽيگرز جي صف کي موٽائڻ آهي جيڪي هر هڪ کي ڪيترا بيٽ ڪندو آهي.هن فنڪشن جو ان پٽ هڪ خاص ASCII فارميٽ ۾ موسيقي نوٽس جي نمائندگي ڪندڙ هڪ تار آهي.# >>> parse_music.call(""o o| .| o| o| .| .| .| .| o o"")
# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
def parse_music(music_string)
","def parse_music(music_string)
  # Split the input string into individual notes.
  notes = music_string.split

  # Map each note to its corresponding number of beats.
  notes.map do |note|
    case note
    when 'o'
      4
    when 'o|'
      2
    when '.|'
      1
    else
      0
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_parse_music
    candidate = method(:parse_music)
    assert_equal([], candidate.call(""""))
    assert_equal([4, 4, 4, 4], candidate.call(""o o o o""))
    assert_equal([1, 1, 1, 1], candidate.call("".| .| .| .|""))
    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(""o| o| .| .| o o o o""))
    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(""o| .| o| .| o o| o o|""))
  end
end
"
HumanEval_18,snd_Arab,rb,"ڳولي وٺو ته هڪ ڏنل ذيلي تار اصل تار ۾ ڪيترا ڀيرا ملي سگهي ٿو. اوورلوپنگ ڪيسن کي ڳڻيو. # >>> how_many_times.call("""", ""a"")
# 0
# >>> how_many_times.call(""aaa"", ""a"")
# 3
# >>> how_many_times.call(""aaaa"", ""aa"")
# 3
def how_many_times(string, substring)
","def how_many_times(string, substring)
  return 0 if substring.empty?
  count = 0
  i = 0
  while i <= string.length - substring.length
    if string[i, substring.length] == substring
      count += 1
    end
    i += 1
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_how_many_times
    candidate = method(:how_many_times)
    assert_equal(0, candidate.call("""", ""x""))
    assert_equal(4, candidate.call(""xyxyxyx"", ""x""))
    assert_equal(4, candidate.call(""cacacacac"", ""cac""))
    assert_equal(1, candidate.call(""john doe"", ""john""))
  end
end
"
HumanEval_19,snd_Arab,rb,"نمبرن سان گڏ string کي ننڍي کان وڏي تائين ترتيب ڏيوصحيح انتخاب ""صفر""، ""هڪ""، ""ٻه""، ""ٽي""، ""چار""، ""پنج""، ""ڇهه""، ""سٿ""، ""اٺ"" ۽ ""نو"" آهن.انپٽ ""صفر"" کان ""نو"" تائين عددن جي هڪ جڳهه سان محدود تار آهي.# >>> sort_numbers.call(""three one five"")
# ""one three five""
def sort_numbers(numbers)
","def sort_numbers(numbers)
  numeral_map = {
    'zero' => 0,
    'one' => 1,
    'two' => 2,
    'three' => 3,
    'four' => 4,
    'five' => 5,
    'six' => 6,
    'seven' => 7,
    'eight' => 8,
    'nine' => 9
  }

  number_words = numbers.split
  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }
  sorted_numbers.join(' ')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_numbers
    candidate = method(:sort_numbers)
    assert_equal("""", candidate.call(""""))
    assert_equal(""three"", candidate.call(""three""))
    assert_equal(""three five nine"", candidate.call(""three five nine""))
    assert_equal(""zero four five seven eight nine"", candidate.call(""five zero four seven nine eight""))
    assert_equal(""zero one two three four five six"", candidate.call(""six five four three two one zero""))
  end
end
"
HumanEval_20,snd_Arab,rb,"ٻين ۽ انهن کي ترتيب سان واپس ڪريو (ننڍو نمبر، وڏو نمبر).نمبرن جي ڏنل صف مان (گهٽ ۾ گهٽ ٻه نمبر) ٻه نمبر چونڊيو ۽ موٽايو جيڪي هر هڪ جي ويجهو آهن # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
# [2.0, 2.2]
# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
# [2.0, 2.0]
def find_closest_elements(numbers)
","def find_closest_elements(numbers)
  sorted_numbers = numbers.sort
  closest_pair = [sorted_numbers[0], sorted_numbers[1]]
  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs

  (1...(sorted_numbers.length - 1)).each do |i|
    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs
    if current_difference < min_difference
      min_difference = current_difference
      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]
    end
  end

  closest_pair
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_closest_elements
    candidate = method(:find_closest_elements)
    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))
    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))
    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))
    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))
    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))
  end
end
"
HumanEval_21,snd_Arab,rb,"اھڙي طرح جو سڀ کان ننڍو نمبر 0 ٿيندو ۽ سڀ کان وڏو 1 ٿيندو.انگن جي ڏنل صف (گهٽ ۾ گهٽ ٻن عنصرن جي) ، ان صف کي هڪ لائينار ٽرانسفارم لاڳو ڪريو، # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])
# [0.0, 0.25, 0.5, 0.75, 1.0]
def rescale_to_unit(numbers)
","def rescale_to_unit(numbers)
  min = numbers.min
  max = numbers.max
  range = max - min
  return numbers.map { |num| (num - min) / range.to_f }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rescale_to_unit
    candidate = method(:rescale_to_unit)
    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))
    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))
    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))
    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))
  end
end
"
HumanEval_22,snd_Arab,rb,"صرف انٽيگرز لاءِ ڪنهن به rbthon قدر جي ڏنل صف کي فلٽر ڪريو # >>> filter_integers.call([""a"", 3.14, 5])
# [5]
# >>> filter_integers.call([1, 2, 3, ""abc"", {}, []])
# [1, 2, 3]
def filter_integers(values)
","def filter_integers(values)
  values.select { |value| value.is_a?(Integer) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_integers
    candidate = method(:filter_integers)
    assert_equal([], candidate.call([]))
    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, ""adasd""]))
    assert_equal([3, 3, 3], candidate.call([3, ""c"", 3, 3, ""a"", ""b""]))
  end
end
"
HumanEval_23,snd_Arab,rb,"ڏنل اسٽرنگ جي واپسي جي ڊيگهه # >>> strlen.call("""")
# 0
# >>> strlen.call(""abc"")
# 3
def strlen(string)
","strlen = lambda do |string|
  string.length
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strlen
    candidate = method(:strlen)
    assert_equal(0, candidate.call(""""))
    assert_equal(1, candidate.call(""x""))
    assert_equal(9, candidate.call(""asdasnakj""))
  end
end
"
HumanEval_24,snd_Arab,rb,"هڪ ڏنل نمبر n لاءِ، سڀ کان وڏو نمبر ڳوليو جيڪو n کي برابر طور تي ورهائي ٿو، جيڪو n کان ننڍو آهي.# >>> largest_divisor.call(15)
# 5
def largest_divisor(n)
","def largest_divisor(n)
  (n - 1).downto(1) do |i|
    return i if n % i == 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_divisor
    candidate = method(:largest_divisor)
    assert_equal(1, candidate.call(3))
    assert_equal(1, candidate.call(7))
    assert_equal(5, candidate.call(10))
    assert_equal(50, candidate.call(100))
    assert_equal(7, candidate.call(49))
  end
end
"
HumanEval_25,snd_Arab,rb,"انپٽ نمبر سڀني عنصرن جي پيداوار جي برابر هجڻ گهرجي.هر هڪ عنصر کي ان جي فڪر ۾ ظاهر ٿيڻ جي تعداد جي برابر وقت جي ترتيب سان ترتيب ڏيڻ گهرجي.ڏنل عدد جي پرائم فئڪٽرن جي صف کي ننڍي کان وڏي تائين ترتيب ۾ موٽائي ٿو.# >>> factorize.call(8)
# [2, 2, 2]
# >>> factorize.call(25)
# [5, 5]
# >>> factorize.call(70)
# [2, 5, 7]
def factorize(n)
","def factorize(n)
  factors = []
  divisor = 2
  while n > 1
    while n % divisor == 0
      factors << divisor
      n /= divisor
    end
    divisor += 1
  end
  factors
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_factorize
    candidate = method(:factorize)
    assert_equal([2], candidate.call(2))
    assert_equal([2, 2], candidate.call(4))
    assert_equal([2, 2, 2], candidate.call(8))
    assert_equal([3, 19], candidate.call(57))
    assert_equal([3, 3, 19, 19], candidate.call(3249))
    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))
    assert_equal([3, 19, 19, 19], candidate.call(20577))
    assert_equal([2, 3, 3], candidate.call(18))
  end
end
"
HumanEval_26,snd_Arab,rb,"عناصر جي حڪم جي طور تي ان پٽ ۾ ساڳي ڇڏي رکو.عدد جي صف مان، اهي سڀ عنصر هٽايو جيڪي هڪ کان وڌيڪ دفعا اچن ٿا.# >>> remove_duplicates.call([1, 2, 3, 2, 4])
# [1, 3, 4]
def remove_duplicates(numbers)
","def remove_duplicates(numbers)
  numbers.select { |num| numbers.count(num) == 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_duplicates
    candidate = method(:remove_duplicates)
    assert_equal([], candidate.call([]))
    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))
    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))
  end
end
"
HumanEval_27,snd_Arab,rb,"هڪ ڏنل اسٽرنگ لاءِ ، ننcaseن اکرن کي وڏي اکرن ۽ وڏي اکرن کي ننcaseي اکرن ۾ تبديل ڪريو. # >>> flip_case.call(""Hello"")
# ""hELLO""
def flip_case(string)
","def flip_case(string)
  string.swapcase
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_flip_case
    candidate = method(:flip_case)
    assert_equal("""", candidate.call(""""))
    assert_equal(""hELLO!"", candidate.call(""Hello!""))
    assert_equal(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"", candidate.call(""These violent delights have violent ends""))
  end
end
"
HumanEval_28,snd_Arab,rb,"سٽرنگن جي صف کي ھڪ سٽرنگ ۾ ملائي # >>> concatenate.call([])
# """"
# >>> concatenate.call([""a"", ""b"", ""c""])
# ""abc""
def concatenate(strings)
","def concatenate(strings)
  strings.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_concatenate
    candidate = method(:concatenate)
    assert_equal("""", candidate.call([]))
    assert_equal(""xyz"", candidate.call([""x"", ""y"", ""z""]))
    assert_equal(""xyzwk"", candidate.call([""x"", ""y"", ""z"", ""w"", ""k""]))
  end
end
"
HumanEval_29,snd_Arab,rb,"صرف انهن لاءِ داخل ٿيل تارن جي صف کي فلٽر ڪريو جيڪي ڏنل اڳياڙي سان شروع ٿين ٿيون.# >>> filter_by_prefix.call([], ""a"")
# []
# >>> filter_by_prefix.call([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
# [""abc"", ""array""]
def filter_by_prefix(strings, prefix)
","def filter_by_prefix(strings, prefix)
  strings.select { |string| string.start_with?(prefix) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_filter_by_prefix
    candidate = method(:filter_by_prefix)
    assert_equal([], candidate.call([], ""john""))
    assert_equal([""xxx"", ""xxxAAA"", ""xxx""], candidate.call([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""))
  end
end
"
HumanEval_30,snd_Arab,rb,"صف ۾ صرف مثبت نمبر واپس آڻيندو آهي.# >>> get_positive.call([-1, 2, -4, 5, 6])
# [2, 5, 6]
# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# [5, 3, 2, 3, 9, 123, 1]
def get_positive(l)
","get_positive = lambda do |l|
  l.select { |num| num > 0 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_positive
    candidate = method(:get_positive)
    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))
    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))
    assert_equal([], candidate.call([-1, -2]))
    assert_equal([], candidate.call([]))
  end
end
"
HumanEval_31,snd_Arab,rb,"جيڪڏهن ڏنل نمبر پرائم آهي ته صحيح موٽائي، ۽ ٻي صورت ۾ غلط.# >>> is_prime.call(6)
# false
# >>> is_prime.call(101)
# true
# >>> is_prime.call(11)
# true
# >>> is_prime.call(13441)
# true
# >>> is_prime.call(61)
# true
# >>> is_prime.call(4)
# false
# >>> is_prime.call(1)
# false
def is_prime(n)
","is_prime = lambda do |n|
  return false if n <= 1
  return true if n == 2
  return false if n.even?

  max_divisor = Math.sqrt(n).to_i
  (3..max_divisor).step(2).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_prime
    candidate = method(:is_prime)
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(101))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(13441))
    assert_equal(true, candidate.call(61))
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(1))
    assert_equal(true, candidate.call(5))
    assert_equal(true, candidate.call(11))
    assert_equal(true, candidate.call(17))
    assert_equal(false, candidate.call(85))
    assert_equal(false, candidate.call(77))
    assert_equal(false, candidate.call(255379))
  end
end
"
HumanEval_33,snd_Arab,rb,"جي لاڳاپيل indexes جي اهميت کي، پر ترتيب.l' انڊيڪس ۾ l سان ملندڙ آهي جيڪي ٽن ۾ ورهايل نه آهن ، جڏهن ته ان جي قدر انڊيڪس ۾ جيڪي ٽن ۾ ورهايل آهن برابر آهن هي فنڪشن هڪ صف l وٺندو آهي ۽ هڪ صف l موٽائيندو آهي جيئن ته # >>> sort_third.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])
# [2, 6, 3, 4, 8, 9, 5]
def sort_third(l)
","def sort_third(l)
  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort
  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_third
    candidate = method(:sort_third)
    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))
    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))
    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))
    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))
  end
end
"
HumanEval_34,snd_Arab,rb,"صف ۾ ترتيب ڏنل منفرد عنصر واپس ڪري ٿو# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [0, 2, 3, 5, 9, 123]
def unique(l)
","def unique(l)
  l.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique
    candidate = method(:unique)
    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_35,snd_Arab,rb,"صف ۾ وڌ کان وڌ عنصر موٽائي ٿو.# >>> max_element.call([1, 2, 3])
# 3
# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
# 123
def max_element(l)
","def max_element(l)
  l.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_element
    candidate = method(:max_element)
    assert_equal(3, candidate.call([1, 2, 3]))
    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))
  end
end
"
HumanEval_36,snd_Arab,rb,"عدد 7 جو تعداد واپس ڪريو عدد 7 کان گھٽ عدد ۾ ظاهر ٿئي ٿو جيڪي 11 يا 13 سان ورهائجي سگھن ٿا.# >>> fizz_buzz.call(50)
# 0
# >>> fizz_buzz.call(78)
# 2
# >>> fizz_buzz.call(79)
# 3
def fizz_buzz(n)
","def fizz_buzz(n)
  count = 0
  (1...n).each do |i|
    if i % 11 == 0 || i % 13 == 0
      count += i.to_s.count('7')
    end
  end
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fizz_buzz
    candidate = method(:fizz_buzz)
    assert_equal(0, candidate.call(50))
    assert_equal(2, candidate.call(78))
    assert_equal(3, candidate.call(79))
    assert_equal(3, candidate.call(100))
    assert_equal(6, candidate.call(200))
    assert_equal(192, candidate.call(4000))
    assert_equal(639, candidate.call(10000))
    assert_equal(8026, candidate.call(100000))
  end
end
"
HumanEval_37,snd_Arab,rb,"l جي انڊيڪس جي قدرن کي به ترتيب ڏنو ويو آهي.l' انڊين انڊيڪسز ۾ l سان برابر آهي ، جڏهن ته ان جي قدرن ۾ برابر انڊيڪسز برابر آهن هي فنڪشن هڪ صف l وٺندو آهي ۽ هڪ صف l موٽائيندو آهي جيئن ته # >>> sort_even.call([1, 2, 3])
# [1, 2, 3]
# >>> sort_even.call([5, 6, 3, 4])
# [3, 6, 5, 4]
def sort_even(l)
","def sort_even(l)
  even_indices = l.each_index.select { |i| i.even? }
  even_values = even_indices.map { |i| l[i] }.sort
  
  even_index = 0
  l.each_with_index.map do |value, index|
    if index.even?
      even_values[even_index].tap { even_index += 1 }
    else
      value
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_even
    candidate = method(:sort_even)
    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))
    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
  end
end
"
HumanEval_39,snd_Arab,rb,"prime_fib n-th نمبر واپس ڪري ٿو جيڪو هڪ فبوناچي نمبر آهي ۽ اهو پڻ پرائم آهي. # >>> prime_fib.call(1)
# 2
# >>> prime_fib.call(2)
# 3
# >>> prime_fib.call(3)
# 5
# >>> prime_fib.call(4)
# 13
# >>> prime_fib.call(5)
# 89
def prime_fib(n)
","def prime_fib(n)
  require 'prime'
  
  fibs = Enumerator.new do |y|
    a, b = 0, 1
    loop do
      a, b = b, a + b
      y << b
    end
  end
  
  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }
  prime_fibs.first(n).last
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_fib
    candidate = method(:prime_fib)
    assert_equal(2, candidate.call(1))
    assert_equal(3, candidate.call(2))
    assert_equal(5, candidate.call(3))
    assert_equal(13, candidate.call(4))
    assert_equal(89, candidate.call(5))
    assert_equal(233, candidate.call(6))
    assert_equal(1597, candidate.call(7))
    assert_equal(28657, candidate.call(8))
    assert_equal(514229, candidate.call(9))
    assert_equal(433494437, candidate.call(10))
  end
end
"
HumanEval_40,snd_Arab,rb,"صفر تائين گڏ، ۽ ٻي صورت ۾ غلط.اهو سچ موٽندو آهي جيڪڏهن صف ۾ ٽي الڳ الڳ عنصر آهن جيڪي triples_sum_to_zero انٽيگرز جي هڪ صف کي ان پٽ جي طور تي وٺي ٿو.# >>> triples_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> triples_sum_to_zero.call([1, 3, -2, 1])
# true
# >>> triples_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])
# true
# >>> triples_sum_to_zero.call([1])
# false
def triples_sum_to_zero(l)
","def triples_sum_to_zero(l)
  n = l.length
  (0...n-2).each do |i|
    ((i+1)...n-1).each do |j|
      ((j+1)...n).each do |k|
        return true if l[i] + l[j] + l[k] == 0
      end
    end
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triples_sum_to_zero
    candidate = method(:triples_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, 5, -1]))
    assert_equal(true, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(false, candidate.call([1, 2, 5, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(false, candidate.call([1, 3, 5, -100]))
    assert_equal(false, candidate.call([100, 3, 5, -100]))
  end
end
"
HumanEval_41,snd_Arab,rb,"هي فنڪشن اهڙن ٽڪرن جو تعداد ٻاھر ڪڍي ٿو.ڄڻ ته انهن ۾ ڪو ٽڪراءُ نه ٿيو هجي.پر، اهي گاڏيون بي حد مضبوط ۽ مضبوط آهن؛ نتيجي طور، اهي هلندي رهيون آهن.جڏهن هڪ ڪار جيڪا کاٻي کان ساڄي طرف وڃي رهي آهي هڪ ڪار کي ٽوڙي ٿي جيڪا ساڄي کان کاٻي طرف وڃي رهي آهي.سڀ گاڏيون هڪ ئي رفتار سان هلن ٿيون. ٻن گاڏين کي چيو ويندو آهي ته ٽڪرائجي وڃن.گاڏين جا ٻه سيٽ شروع ٿين ٿا ته انهن کان تمام گهڻو پري آهن.n گاڏيون کاٻي کان ساڄي طرف ڊوڙنديون آهن؛ هڪ ئي وقت، n گاڏين جو هڪ مختلف سيٽ تصور ڪريو ته هڪ روڊ جيڪو هڪ مڪمل سڌي لڪير آهي لامحدود ڊگهي لڪير.def car_race_collision(n)
","def car_race_collision(n)
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_car_race_collision
    candidate = method(:car_race_collision)
    assert_equal(4, candidate.call(2))
    assert_equal(9, candidate.call(3))
    assert_equal(16, candidate.call(4))
    assert_equal(64, candidate.call(8))
    assert_equal(100, candidate.call(10))
  end
end
"
HumanEval_42,snd_Arab,rb,"1 جي اضافو سان عنصرن سان گڏ صف واپس ڪريو.# >>> incr_list.call([1, 2, 3])
# [2, 3, 4]
# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])
# [6, 4, 6, 3, 4, 4, 10, 1, 124]
def incr_list(l)
","def incr_list(l)
  l.map { |x| x + 1 }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_incr_list
    candidate = method(:incr_list)
    assert_equal([], candidate.call([]))
    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))
    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))
  end
end
"
HumanEval_43,snd_Arab,rb,"صفر تائين گڏ، ۽ ٻي صورت ۾ غلط.اهو سچ موٽندو آهي جيڪڏهن صف ۾ ٻه الڳ عنصر آهن جيڪي pairs_sum_to_zero انٽيگرز جي هڪ صف کي ان پٽ جي طور تي وٺي ٿو.# >>> pairs_sum_to_zero.call([1, 3, 5, 0])
# false
# >>> pairs_sum_to_zero.call([1, 3, -2, 1])
# false
# >>> pairs_sum_to_zero.call([1, 2, 3, 7])
# false
# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])
# true
# >>> pairs_sum_to_zero.call([1])
# false
def pairs_sum_to_zero(l)
","def pairs_sum_to_zero(l)
  num_set = l.to_set
  l.each do |num|
    return true if num != 0 && num_set.include?(-num)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pairs_sum_to_zero
    candidate = method(:pairs_sum_to_zero)
    assert_equal(false, candidate.call([1, 3, 5, 0]))
    assert_equal(false, candidate.call([1, 3, -2, 1]))
    assert_equal(false, candidate.call([1, 2, 3, 7]))
    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))
    assert_equal(false, candidate.call([1]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))
    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))
    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))
  end
end
"
HumanEval_44,snd_Arab,rb,"بنيادي نمبر 10 کان گهٽ آهن.واپسي واري اسٽرنگ جي نمائندگي تبديل ٿيڻ کان پوءِ.انپٽ نمبر x جي عددي بنياد کي بنياد ۾ تبديل ڪريو.# >>> change_base.call(8, 3)
# ""22""
# >>> change_base.call(8, 2)
# ""1000""
# >>> change_base.call(7, 2)
# ""111""
def change_base(x, base)
","def change_base(x, base)
  return '0' if x == 0
  digits = []
  while x > 0
    digits << (x % base).to_s
    x /= base
  end
  digits.reverse.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_change_base
    candidate = method(:change_base)
    assert_equal(""22"", candidate.call(8, 3))
    assert_equal(""100"", candidate.call(9, 3))
    assert_equal(""11101010"", candidate.call(234, 2))
    assert_equal(""10000"", candidate.call(16, 2))
    assert_equal(""1000"", candidate.call(8, 2))
    assert_equal(""111"", candidate.call(7, 2))
    assert_equal(""2"", candidate.call(2, 3))
    assert_equal(""3"", candidate.call(3, 4))
    assert_equal(""4"", candidate.call(4, 5))
    assert_equal(""5"", candidate.call(5, 6))
    assert_equal(""6"", candidate.call(6, 7))
    assert_equal(""7"", candidate.call(7, 8))
  end
end
"
HumanEval_45,snd_Arab,rb,"هڪ مثلث لاء هڪ پاسي ۽ اعلي موٽڻ علائقي جي ڊيگهه ڏنو.# >>> triangle_area.call(5, 3)
# 7.5
def triangle_area(a, h)
","def triangle_area(a, h)
  (a * h) / 2.0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(7.5, candidate.call(5, 3))
    assert_equal(2.0, candidate.call(2, 2))
    assert_equal(40.0, candidate.call(10, 8))
  end
end
"
HumanEval_46,snd_Arab,rb,"مهرباني ڪري هڪ فنڪشن لکو ته جيئن fib4 نمبر سيڪشن جي n-th عنصر کي موثر طريقي سان ڳڻپ ڪري سگهجي. ريڪارشن استعمال نه ڪريو.fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). <br /> <br /> <br /> <br /> <br /> <br /> <br /><br /> <br /> <br /> <br /> <br /> <br /> <br />fib4(1) -> 0 fib4(0) -> 0 Fib4 نمبر سيڪينس هڪ سيڪينس آهي جيڪا فبوناچي سيڪينس وانگر آهي جنهن جي تعريف هن ريت آهي:# >>> fib4.call(5)
# 4
# >>> fib4.call(6)
# 8
# >>> fib4.call(7)
# 14
def fib4(n)
","def fib4(n)
  return 0 if n == 0 || n == 1 || n == 3
  return 2 if n == 2

  fib4_seq = [0, 0, 2, 0]
  (4..n).each do |i|
    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]
  end
  fib4_seq[n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib4
    candidate = method(:fib4)
    assert_equal(4, candidate.call(5))
    assert_equal(28, candidate.call(8))
    assert_equal(104, candidate.call(10))
    assert_equal(386, candidate.call(12))
  end
end
"
HumanEval_47,snd_Arab,rb,"صف ۾ عنصرن جي وچولي موٽڻ l. # >>> median.call([3, 1, 2, 4, 5])
# 3
# >>> median.call([-10, 4, 6, 1000, 10, 20])
# 15.0
def median(l)
","def median(l)
  sorted = l.sort
  len = sorted.length
  if len.odd?
    sorted[len / 2]
  else
    (sorted[len / 2 - 1] + sorted[len / 2]) / 2.0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_median
    candidate = method(:median)
    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))
    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))
    assert_equal(5, candidate.call([5]))
    assert_equal(5.5, candidate.call([6, 5]))
    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))
  end
end
"
HumanEval_48,snd_Arab,rb,"چيڪ ڪري ٿو ته ڏنل اسٽرنگ هڪ پيلنڊروم آهي# >>> is_palindrome.call("""")
# true
# >>> is_palindrome.call(""aba"")
# true
# >>> is_palindrome.call(""aaaaa"")
# true
# >>> is_palindrome.call(""zbcd"")
# false
def is_palindrome(text)
","is_palindrome = lambda do |text|
  text == text.reverse
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_palindrome
    candidate = method(:is_palindrome)
    assert_equal(true, candidate.call(""""))
    assert_equal(true, candidate.call(""aba""))
    assert_equal(true, candidate.call(""aaaaa""))
    assert_equal(false, candidate.call(""zbcd""))
    assert_equal(true, candidate.call(""xywyx""))
    assert_equal(false, candidate.call(""xywyz""))
    assert_equal(false, candidate.call(""xywzx""))
  end
end
"
HumanEval_49,snd_Arab,rb,"موٽايو 2^n ماڊولو پي (ان جي عددن کان واقف ٿيو).# >>> modp.call(3, 5)
# 3
# >>> modp.call(1101, 101)
# 2
# >>> modp.call(0, 101)
# 1
# >>> modp.call(3, 11)
# 8
# >>> modp.call(100, 101)
# 1
def modp(n, p)
","def modp(n, p)
  return 1 if p == 1
  2.pow(n, p)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_modp
    candidate = method(:modp)
    assert_equal(3, candidate.call(3, 5))
    assert_equal(2, candidate.call(1101, 101))
    assert_equal(1, candidate.call(0, 101))
    assert_equal(8, candidate.call(3, 11))
    assert_equal(1, candidate.call(100, 101))
    assert_equal(4, candidate.call(30, 5))
    assert_equal(3, candidate.call(31, 5))
  end
end
"
HumanEval_51,snd_Arab,rb,"remove_vowels هڪ فنڪشن آهي جيڪو سٽرنگ وٺي ٿو ۽ بغير آوازن جي سٽرنگ موٽائي ٿو. # >>> remove_vowels.call("""")
# """"
# >>> remove_vowels.call(""abcdef"")
# ""bcdf""
# >>> remove_vowels.call(""aaaaa"")
# """"
# >>> remove_vowels.call(""aaBAA"")
# ""B""
# >>> remove_vowels.call(""zbcd"")
# ""zbcd""
def remove_vowels(text)
","def remove_vowels(text)
  text.delete('aeiouAEIOU')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_remove_vowels
    candidate = method(:remove_vowels)
    assert_equal("""", candidate.call(""""))
    assert_equal(""bcdf
ghjklm"", candidate.call(""abcdef
ghijklm""))
    assert_equal(""fdcb"", candidate.call(""fedcba""))
    assert_equal("""", candidate.call(""eeeee""))
    assert_equal(""cB"", candidate.call(""acBAA""))
    assert_equal(""cB"", candidate.call(""EcBOO""))
    assert_equal(""ybcd"", candidate.call(""ybcd""))
  end
end
"
HumanEval_52,snd_Arab,rb,"جيڪڏهن صف ۾ سڀئي نمبر حد کان هيٺ آهن ته سچ موٽايو.# >>> below_threshold.call([1, 2, 4, 10], 100)
# true
# >>> below_threshold.call([1, 20, 4, 10], 5)
# false
def below_threshold(l, t)
","def below_threshold(l, t)
  l.all? { |num| num < t }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_below_threshold
    candidate = method(:below_threshold)
    assert_equal(true, candidate.call([1, 2, 4, 10], 100))
    assert_equal(false, candidate.call([1, 20, 4, 10], 5))
    assert_equal(true, candidate.call([1, 20, 4, 10], 21))
    assert_equal(true, candidate.call([1, 20, 4, 10], 22))
    assert_equal(true, candidate.call([1, 8, 4, 10], 11))
    assert_equal(false, candidate.call([1, 8, 4, 10], 10))
  end
end
"
HumanEval_53,snd_Arab,rb,"ٻن نمبرن کي گڏ ڪريو x ۽ y # >>> add.call(2, 3)
# 5
# >>> add.call(5, 7)
# 12
def add(x, y)
","add = ->(x, y) { x + y }","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(1, candidate.call(0, 1))
    assert_equal(1, candidate.call(1, 0))
    assert_equal(5, candidate.call(2, 3))
    assert_equal(12, candidate.call(5, 7))
    assert_equal(12, candidate.call(7, 5))
  end
end
"
HumanEval_54,snd_Arab,rb,"چيڪ ڪريو ته ڇا ٻن لفظن ۾ هڪجهڙا اکر آهن.# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
# true
# >>> same_chars.call(""abcd"", ""dddddddabc"")
# true
# >>> same_chars.call(""dddddddabc"", ""abcd"")
# true
# >>> same_chars.call(""eabcd"", ""dddddddabc"")
# false
# >>> same_chars.call(""abcd"", ""dddddddabce"")
# false
# >>> same_chars.call(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
# false
def same_chars(s0, s1)
","def same_chars(s0, s1)
  s0.chars.uniq.all? { |char| s1.include?(char) } &&
  s1.chars.uniq.all? { |char| s0.include?(char) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_same_chars
    candidate = method(:same_chars)
    assert_equal(true, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddeddabc""))
    assert_equal(true, candidate.call(""abcd"", ""dddddddabc""))
    assert_equal(true, candidate.call(""dddddddabc"", ""abcd""))
    assert_equal(false, candidate.call(""eabcd"", ""dddddddabc""))
    assert_equal(false, candidate.call(""abcd"", ""dddddddabcf""))
    assert_equal(false, candidate.call(""eabcdzzzz"", ""dddzzzzzzzddddabc""))
    assert_equal(false, candidate.call(""aabb"", ""aaccc""))
  end
end
"
HumanEval_55,snd_Arab,rb,"n-th فبوناچي نمبر واپس ڪريو. # >>> fib.call(10)
# 55
# >>> fib.call(1)
# 1
# >>> fib.call(8)
# 21
def fib(n)
","def fib(n)
  return n if n <= 1
  fib(n - 1) + fib(n - 2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fib
    candidate = method(:fib)
    assert_equal(55, candidate.call(10))
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(8))
    assert_equal(89, candidate.call(11))
    assert_equal(144, candidate.call(12))
  end
end
"
HumanEval_56,snd_Arab,rb,"جيڪڏهن هر اوپننگ براڪ ۾ هڪ برابر بند ڪرڻ وارو براڪ آهي ته صحيح موٽايو.brackets ""<"" ۽ "">"" جي هڪ سلسلي آهي.# >>> correct_bracketing.call(""<"")
# false
# >>> correct_bracketing.call(""<>"")
# true
# >>> correct_bracketing.call(""<<><>>"")
# true
# >>> correct_bracketing.call(""><<>"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.chars.each do |char|
    if char == '<'
      balance += 1
    elsif char == '>'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""<>""))
    assert_equal(true, candidate.call(""<<><>>""))
    assert_equal(true, candidate.call(""<><><<><>><>""))
    assert_equal(true, candidate.call(""<><><<<><><>><>><<><><<>>>""))
    assert_equal(false, candidate.call(""<<<><>>>>""))
    assert_equal(false, candidate.call(""><<>""))
    assert_equal(false, candidate.call(""<""))
    assert_equal(false, candidate.call(""<<<<""))
    assert_equal(false, candidate.call("">""))
    assert_equal(false, candidate.call(""<<>""))
    assert_equal(false, candidate.call(""<><><<><>><>><<>""))
    assert_equal(false, candidate.call(""<><><<><>><>>><>""))
  end
end
"
HumanEval_57,snd_Arab,rb,"موٽڻ صحيح آهي صف عناصر monotonically وڌندا يا گهٽتائي آهن.# >>> monotonic.call([1, 2, 4, 20])
# true
# >>> monotonic.call([1, 20, 4, 10])
# false
# >>> monotonic.call([4, 1, 0, -10])
# true
def monotonic(l)
","def monotonic(l)
  increasing = true
  decreasing = true

  (0...l.length - 1).each do |i|
    if l[i] < l[i + 1]
      decreasing = false
    elsif l[i] > l[i + 1]
      increasing = false
    end
  end

  increasing || decreasing
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_monotonic
    candidate = method(:monotonic)
    assert_equal(true, candidate.call([1, 2, 4, 10]))
    assert_equal(true, candidate.call([1, 2, 4, 20]))
    assert_equal(false, candidate.call([1, 20, 4, 10]))
    assert_equal(true, candidate.call([4, 1, 0, -10]))
    assert_equal(true, candidate.call([4, 1, 1, 0]))
    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))
    assert_equal(true, candidate.call([9, 9, 9, 9]))
  end
end
"
HumanEval_58,snd_Arab,rb,"ٻن صفن لاءِ ترتيب ڏنل منفرد عام عنصر واپس آڻڻ.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
# [1, 5, 653]
# >>> common.call([5, 3, 2, 8], [3, 2])
# [2, 3]
def common(l1, l2)
","def common(l1, l2)
  (l1 & l2).uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_common
    candidate = method(:common)
    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))
    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))
    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))
    assert_equal([], candidate.call([4, 3, 2, 8], []))
  end
end
"
HumanEval_59,snd_Arab,rb,"n جو سڀ کان وڏو پرائم فيڪٽر موٽايو. فرض ڪريو n > 1 ۽ پرائم نه آهي. # >>> largest_prime_factor.call(13195)
# 29
# >>> largest_prime_factor.call(2048)
# 2
def largest_prime_factor(n)
","def largest_prime_factor(n)
  factor = 2
  while factor * factor <= n
    if n % factor == 0
      n /= factor
    else
      factor += 1
    end
  end
  n
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_prime_factor
    candidate = method(:largest_prime_factor)
    assert_equal(5, candidate.call(15))
    assert_equal(3, candidate.call(27))
    assert_equal(7, candidate.call(63))
    assert_equal(11, candidate.call(330))
    assert_equal(29, candidate.call(13195))
  end
end
"
HumanEval_60,snd_Arab,rb,"sum_to_n هڪ فنڪشن آهي جيڪو 1 کان n تائين نمبرن جو مجموعو آهي.# >>> sum_to_n.call(30)
# 465
# >>> sum_to_n.call(100)
# 5050
# >>> sum_to_n.call(5)
# 15
# >>> sum_to_n.call(10)
# 55
# >>> sum_to_n.call(1)
# 1
def sum_to_n(n)
","def sum_to_n(n)
  (1..n).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_to_n
    candidate = method(:sum_to_n)
    assert_equal(1, candidate.call(1))
    assert_equal(21, candidate.call(6))
    assert_equal(66, candidate.call(11))
    assert_equal(465, candidate.call(30))
    assert_equal(5050, candidate.call(100))
  end
end
"
HumanEval_61,snd_Arab,rb,"جيڪڏهن هر اوپننگ براڪ ۾ هڪ برابر بند ڪرڻ وارو براڪ آهي ته صحيح موٽايو.brackets ""("" ۽ """") جي هڪ سلسلي آهي.# >>> correct_bracketing.call(""("")
# false
# >>> correct_bracketing.call(""()"")
# true
# >>> correct_bracketing.call(""(()())"")
# true
# >>> correct_bracketing.call("")(()"")
# false
def correct_bracketing(brackets)
","def correct_bracketing(brackets)
  balance = 0
  brackets.each_char do |char|
    if char == '('
      balance += 1
    elsif char == ')'
      balance -= 1
    end
    return false if balance < 0
  end
  balance == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_correct_bracketing
    candidate = method(:correct_bracketing)
    assert_equal(true, candidate.call(""()""))
    assert_equal(true, candidate.call(""(()())""))
    assert_equal(true, candidate.call(""()()(()())()""))
    assert_equal(true, candidate.call(""()()((()()())())(()()(()))""))
    assert_equal(false, candidate.call(""((()())))""))
    assert_equal(false, candidate.call("")(()""))
    assert_equal(false, candidate.call(""(""))
    assert_equal(false, candidate.call(""((((""))
    assert_equal(false, candidate.call("")""))
    assert_equal(false, candidate.call(""(()""))
    assert_equal(false, candidate.call(""()()(()())())(()""))
    assert_equal(false, candidate.call(""()()(()())()))()""))
  end
end
"
HumanEval_62,snd_Arab,rb,"هن polynomial جي derivative موٽڻ جي ساڳي صورت ۾. xs[0] + xs[1] * x + xs[2] * x^2 + .... xs هڪ پولينوميل جي کوفيفٽيننٽ جي نمائندگي ڪن ٿا.# >>> derivative.call([3, 1, 2, 4, 5])
# [1, 4, 12, 20]
# >>> derivative.call([1, 2, 3])
# [2, 6]
def derivative(xs)
","def derivative(xs)
  return [] if xs.length < 2
  xs.each_with_index.map { |coef, index| coef * index }[1..-1]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_derivative
    candidate = method(:derivative)
    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))
    assert_equal([2, 6], candidate.call([1, 2, 3]))
    assert_equal([2, 2], candidate.call([3, 2, 1]))
    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))
    assert_equal([], candidate.call([1]))
  end
end
"
HumanEval_63,snd_Arab,rb,"مهرباني ڪري هڪ فنڪشن لکو ته جيئن فائفف نمبر سيڪشن جي n-th عنصر کي موثر طريقي سان ڳڻپ ڪري سگهجي.fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). فففففففففففففففففففففففففففففففففففففف< < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <ففففففففففففففففففففففففففففففففففففFibFib نمبر سيڪينس هڪ سيڪينس آهي جيڪا فبوناچي سيڪينس وانگر آهي جنهن جي تعريف هن ريت آهي: # >>> fibfib.call(1)
# 0
# >>> fibfib.call(5)
# 4
# >>> fibfib.call(8)
# 24
def fibfib(n)
","def fibfib(n)
  return 0 if n == 0 || n == 1
  return 1 if n == 2

  a, b, c = 0, 0, 1
  (3..n).each do
    a, b, c = b, c, a + b + c
  end
  c
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fibfib
    candidate = method(:fibfib)
    assert_equal(1, candidate.call(2))
    assert_equal(0, candidate.call(1))
    assert_equal(4, candidate.call(5))
    assert_equal(24, candidate.call(8))
    assert_equal(81, candidate.call(10))
    assert_equal(274, candidate.call(12))
    assert_equal(927, candidate.call(14))
  end
end
"
HumanEval_64,snd_Arab,rb,"مثال: پر صرف ان صورت ۾ جڏهن اهو ڏنل لفظ جي آخر ۾ هجي.هن صورت ۾ آواز ""اي"" آهن، ""اي"" آهن، ""اي"" آهن، ""او"" آهن، ""يو"" آهن، ""يو"" به آهي.لفظ داخل ڪري ٿو ۽ سٽرنگ ۾ موجود وولن جو تعداد واپس ڪري ٿو.هڪ فنڪشن لکو vowels_count جيڪو هڪ اسٽرنگ جي نمائندگي ڪري ٿو# >>> vowels_count.call(""abcde"")
# 2
# >>> vowels_count.call(""ACEDY"")
# 3
def vowels_count(s)
","def vowels_count(s)
  vowels = ['a', 'e', 'i', 'o', 'u']
  count = 0
  
  s.chars.each_with_index do |char, index|
    if vowels.include?(char.downcase)
      count += 1
    elsif char.downcase == 'y' && index == s.length - 1
      count += 1
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_vowels_count
    candidate = method(:vowels_count)
    assert_equal(2, candidate.call(""abcde""))
    assert_equal(3, candidate.call(""Alone""))
    assert_equal(2, candidate.call(""key""))
    assert_equal(1, candidate.call(""bye""))
    assert_equal(2, candidate.call(""keY""))
    assert_equal(1, candidate.call(""bYe""))
    assert_equal(3, candidate.call(""ACEDY""))
  end
end
"
HumanEval_65,snd_Arab,rb,"جيڪڏهن شفٽ > انگن جو تعداد ، واپسي جا انگ ان جي برعڪس.۽ نتيجو هڪ اسٽرنگ جي طور تي موٽايو.دائري جي طرف x جي عدد کي منتقل ڪريو، عددن کي ساڄي طرف منتقل ڪريو # >>> circular_shift.call(12, 1)
# ""21""
# >>> circular_shift.call(12, 2)
# ""12""
def circular_shift(x, shift)
","def circular_shift(x, shift)
  digits = x.to_s.chars
  num_digits = digits.length

  if shift > num_digits
    return digits.reverse.join
  else
    shift = shift % num_digits
    shifted_digits = digits.rotate(-shift)
    return shifted_digits.join
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_circular_shift
    candidate = method(:circular_shift)
    assert_equal(""001"", candidate.call(100, 2))
    assert_equal(""12"", candidate.call(12, 2))
    assert_equal(""79"", candidate.call(97, 8))
    assert_equal(""21"", candidate.call(12, 1))
    assert_equal(""11"", candidate.call(11, 101))
  end
end
"
HumanEval_66,snd_Arab,rb,"مثال: ASCII ڪوڊ.هڪ فنڪشن لکو جيڪو هڪ اسٽرنگ کي انپٽ طور وٺي ۽ صرف مٿين اکرن جو مجموعو موٽائي ٿو' ڪم # >>> digitSum.call("""")
# 0
# >>> digitSum.call(""abAB"")
# 131
# >>> digitSum.call(""abcCd"")
# 67
# >>> digitSum.call(""helloE"")
# 69
# >>> digitSum.call(""woArBld"")
# 131
# >>> digitSum.call(""aAaaaXa"")
# 153
def digitSum(s)
","def digitSum(s)
  s.chars.select { |char| char =~ /[A-Z]/ }.map(&:ord).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digitSum
    candidate = method(:digitSum)
    assert_equal(0, candidate.call(""""))
    assert_equal(131, candidate.call(""abAB""))
    assert_equal(67, candidate.call(""abcCd""))
    assert_equal(69, candidate.call(""helloE""))
    assert_equal(131, candidate.call(""woArBld""))
    assert_equal(153, candidate.call(""aAaaaXa""))
    assert_equal(151, candidate.call("" How are yOu?""))
    assert_equal(327, candidate.call(""You arE Very Smart""))
  end
end
"
HumanEval_67,snd_Arab,rb,"examble لاءِ: ٽوڪري ۾ مانگو ميون جو تعداد ٽوڪري ۾ واپس آڻيو. نارنگي ۽ ايپل ۽ هڪ انٽيگر جيڪو ميون جي مجموعي تعداد جي نمائندگي ڪري ٿو ايپل، نارنگي ۽ منگو ميون جي هڪ تار ڏني وئي آهي جيڪا  جي مجموعي تعداد جي نمائندگي ڪري ٿيجيڪي ميون جي هڪ ٽوڪري ۾ ورهايل آهن هن ٽوڪري ۾ ميون شامل آهيهن ڪم ۾، توهان کي هڪ تار ڏني ويندي جيڪا ايپل ۽ نارنگي جي هڪ نمبر جي نمائندگي ڪري ٿي # >>> fruit_distribution.call(""5 apples and 6 oranges"", 19)
# 8
# >>> fruit_distribution.call(""0 apples and 1 oranges"", 3)
# 2
# >>> fruit_distribution.call(""2 apples and 3 oranges"", 100)
# 95
# >>> fruit_distribution.call(""100 apples and 1 oranges"", 120)
# 19
def fruit_distribution(s, n)
","def fruit_distribution(s, n)
  numbers = s.scan(/\d+/).map(&:to_i)
  apples = numbers[0]
  oranges = numbers[1]
  total_fruits = n
  mangos = total_fruits - (apples + oranges)
  mangos
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fruit_distribution
    candidate = method(:fruit_distribution)
    assert_equal(8, candidate.call(""5 apples and 6 oranges"", 19))
    assert_equal(10, candidate.call(""5 apples and 6 oranges"", 21))
    assert_equal(2, candidate.call(""0 apples and 1 oranges"", 3))
    assert_equal(2, candidate.call(""1 apples and 0 oranges"", 3))
    assert_equal(95, candidate.call(""2 apples and 3 oranges"", 100))
    assert_equal(0, candidate.call(""2 apples and 3 oranges"", 5))
    assert_equal(19, candidate.call(""1 apples and 100 oranges"", 120))
  end
end
"
HumanEval_68,snd_Arab,rb,"مثال 1: جيڪڏهن ڪوبه قدر نه هجي يا ڏنل صف خالي هجي ، واپس [].هن plucked node هڪ صف ۾ موٽڻ گهرجي، [smallest_value، ان جي انديڪس ]، جيڪڏهن ڪيترائي نوڊس هڪ ئي نن smallestي نن evenي قيمت سان مليا آهن ته نوڊ واپس ڪريو جنهن ۾ نن smallestي انڊيڪس آهي. ڇڪيل نوڊ اهو نوڊ هجڻ گهرجي جنهن جي تمام نن evenي قدر هجي.توھان جو ڪم آھي ھڪڙي نوڊ کي ڪ andڻ ۽ ان کي واپس ڪرڻ.""هڪ صف ڏني وئي آهي جيڪا هڪ وڻ جي شاخ جي نمائندگي ڪري ٿي جنهن ۾ غير منفي انٽيگر نوڊس آهن # >>> pluck.call([4, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 2:
# >>> pluck.call([1, 2, 3])
# [2, 1]
# Explanation: 2 has the smallest even value, and 2 has the smallest index.
# Example 3:
# >>> pluck.call([])
# []
# Example 4:
# >>> pluck.call([5, 0, 3, 0, 4, 2])
# [0, 1]
# Explanation: 0 is the smallest value, but  there are two zeros,
# so we will choose the first zero, which has the smallest index.
# Constraints:
# * 1 <= nodes.length <= 10000
# * 0 <= node.value
def pluck(arr)
","def pluck(arr)
  smallest_even = nil
  smallest_index = nil
  
  arr.each_with_index do |value, index|
    if value.even?
      if smallest_even.nil? || value < smallest_even
        smallest_even = value
        smallest_index = index
      end
    end
  end

  smallest_even.nil? ? [] : [smallest_even, smallest_index]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_pluck
    candidate = method(:pluck)
    assert_equal([2, 1], candidate.call([4, 2, 3]))
    assert_equal([2, 1], candidate.call([1, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))
    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))
    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))
    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))
    assert_equal([], candidate.call([7, 9, 7, 1]))
  end
end
"
HumanEval_69,snd_Arab,rb,"مثال: جيڪڏهن اهڙي ڪا قدر موجود نه آهي، موٽڻ -1.هڪ عدد جي فریکوئنسي ان جي صف ۾ ظاهر ٿيڻ جو تعداد آهي.صفر، ۽ ان جي تعدد انٽيگر جي قدر کان وڌيڪ يا برابر آهي.توهان کي مثبت انٽيگرز جي هڪ غير خالي صف ڏني وئي آهي. وڏي کان وڏو انٽيگر واپس ڪريو جيڪو  کان وڏو آهي# >>> search.call([4, 1, 2, 2, 3, 1])
# 2
# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])
# 3
# >>> search.call([5, 5, 4, 4, 4])
# -1
def search(lst)
","def search(lst)
  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }
  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys
  valid_numbers.empty? ? -1 : valid_numbers.max
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_search
    candidate = method(:search)
    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))
    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))
    assert_equal(-1, candidate.call([3, 3]))
    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))
    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))
    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))
    assert_equal(2, candidate.call([3, 2, 8, 2]))
    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))
    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))
    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))
    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))
    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))
    assert_equal(1, candidate.call([1]))
    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))
    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))
    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))
    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))
    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))
    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))
    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))
    assert_equal(-1, candidate.call([10]))
    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))
    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))
    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))
    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))
  end
end
"
HumanEval_70,snd_Arab,rb,"مثال: پوءِ باقي انٽيگرز جو وڌ کان وڌ، پوءِ گهٽ کان گهٽ ۽ ائين ئي.عجيب ترتيب ڏيڻ، جڏهن توهان گهٽ ۾ گهٽ قدر سان شروع، انٽيگرز جي ڏنل صف، اجنبي ترتيب ۾ صف موٽائي.# >>> strange_sort_list.call([1, 2, 3, 4])
# [1, 4, 2, 3]
# >>> strange_sort_list.call([5, 5, 5, 5])
# [5, 5, 5, 5]
# >>> strange_sort_list.call([])
# []
def strange_sort_list(lst)
","def strange_sort_list(lst)
  result = []
  lst.sort!
  until lst.empty?
    result << lst.shift
    result << lst.pop unless lst.empty?
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_strange_sort_list
    candidate = method(:strange_sort_list)
    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))
    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))
    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))
    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))
    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))
    assert_equal([], candidate.call([]))
    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))
    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))
    assert_equal([111111], candidate.call([111111]))
  end
end
"
HumanEval_71,snd_Arab,rb,"مثال: ٽئين پاسي کان.ٽن طرفن جو مجموعو هڪ صحيح مثلث آهي جڏهن ته ڪنهن به ٻن طرفن جو مجموعو وڏو آهي.ٻي صورت ۾ واپسي -1 ٽڪنڊي کي 2 ڊيسمل پوائنٽن تائين گول ڪيو ويندو آهي جيڪڏهن ٽن پاسن هڪ صحيح ٽڪنڊي ٺاهي.هڪ مثلث جي ٽن پاسن جي ڊيگهه ڏني وئي آهي. جي ايراضي موٽائي # >>> triangle_area.call(3, 4, 5)
# 6.0
# >>> triangle_area.call(1, 2, 10)
# -1
def triangle_area(a, b, c)
","def triangle_area(a, b, c)
  # Check for valid triangle
  if a + b > c && a + c > b && b + c > a
    # Calculate the semi-perimeter
    s = (a + b + c) / 2.0
    # Calculate the area using Heron's formula
    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))
    # Round to 2 decimal points
    return area.round(2)
  else
    return -1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_triangle_area
    candidate = method(:triangle_area)
    assert_equal(6.0, candidate.call(3, 4, 5))
    assert_equal(-1, candidate.call(1, 2, 10))
    assert_equal(8.18, candidate.call(4, 8, 5))
    assert_equal(1.73, candidate.call(2, 2, 2))
    assert_equal(-1, candidate.call(1, 2, 3))
    assert_equal(16.25, candidate.call(10, 5, 7))
    assert_equal(-1, candidate.call(2, 6, 3))
    assert_equal(0.43, candidate.call(1, 1, 1))
    assert_equal(-1, candidate.call(2, 2, 10))
  end
end
"
HumanEval_72,snd_Arab,rb,"مثال: جيڪڏهن اهو متوازن آهي ته اهو جهاز اڏامي ويندو (اهو هڪ پيلنڊرومڪ آرري آهي) ۽ ان جي عنصرن جو مجموعو وڌ کان وڌ ممڪن وزن کان گهٽ يا برابر آهي.هڪ فنڪشن لکو جيڪو سچو موٽندو آهي جيڪڏهن اعتراض q اڏامي ويندو، ۽ ٻي صورت ۾ غلط. # >>> will_it_fly.call([1, 2], 5)
# false
# # 1+2 is less than the maximum possible weight, but it's unbalanced.
# >>> will_it_fly.call([3, 2, 3], 1)
# false
# # it's balanced, but 3+2+3 is more than the maximum possible weight.
# >>> will_it_fly.call([3, 2, 3], 9)
# true
# # 3+2+3 is less than the maximum possible weight, and it's balanced.
# >>> will_it_fly.call([3], 5)
# true
# # 3 is less than the maximum possible weight, and it's balanced.
def will_it_fly(q, w)
","def will_it_fly(q, w)
  is_palindrome = q == q.reverse
  total_weight = q.sum
  is_balanced_and_under_weight = is_palindrome && total_weight <= w
  is_balanced_and_under_weight
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_will_it_fly
    candidate = method(:will_it_fly)
    assert_equal(true, candidate.call([3, 2, 3], 9))
    assert_equal(false, candidate.call([1, 2], 5))
    assert_equal(true, candidate.call([3], 5))
    assert_equal(false, candidate.call([3, 2, 3], 1))
    assert_equal(false, candidate.call([1, 2, 3], 6))
    assert_equal(true, candidate.call([5], 5))
  end
end
"
HumanEval_73,snd_Arab,rb,"مثال طور: هڪ ئي تبديلي ۾، توهان هڪ عنصر کي ڪنهن ٻئي عنصر ۾ تبديل ڪري سگهو ٿا.ان کي تبديل ڪرڻ جي ضرورت آهي ته جيئن صف کي پيلنڊرومڪ بڻائي سگھجي. هڪ پيلنڊرومڪ صف هڪ صف آهي جيڪا هڪ صف ار ار جي ڏنل عدد، عنصرن جو گهٽ ۾ گهٽ تعداد ڳوليو جيڪو # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])
# 4
# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])
# 1
# >>> smallest_change.call([1, 2, 3, 2, 1])
# 0
def smallest_change(arr)
","def smallest_change(arr)
  changes = 0
  left = 0
  right = arr.length - 1

  while left < right
    if arr[left] != arr[right]
      changes += 1
    end
    left += 1
    right -= 1
  end

  changes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_smallest_change
    candidate = method(:smallest_change)
    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))
    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))
    assert_equal(1, candidate.call([1, 4, 2]))
    assert_equal(1, candidate.call([1, 4, 4, 2]))
    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))
    assert_equal(0, candidate.call([3, 1, 1, 3]))
    assert_equal(0, candidate.call([1]))
    assert_equal(1, candidate.call([0, 1]))
  end
end
"
HumanEval_74,snd_Arab,rb,"مثال جيڪڏهن ٻنهي صفن ۾ ڪارن جو هڪ ئي تعداد آهي، پهرين صف واپس ڪريو.صف جي سڀني تارن ۾ ڪارس جو مجموعي تعداد ٻين صفن کان گهٽ آهي.هڪ فنڪشن لکو جيڪو ٻن اسٽرنگس جي صفن کي قبول ڪري ۽ ان صف کي موٽائي جنهن ۾ # >>> total_match.call([], [])
# []
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""Hi""])
# [""hI"", ""Hi""]
# >>> total_match.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
# [""hi"", ""admin""]
# >>> total_match.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
# [""hI"", ""hi"", ""hi""]
# >>> total_match.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
# [""4""]
def total_match(lst1, lst2)
","def total_match(lst1, lst2)
  total_chars1 = lst1.map(&:length).sum
  total_chars2 = lst2.map(&:length).sum

  if total_chars1 < total_chars2
    lst1
  elsif total_chars2 < total_chars1
    lst2
  else
    lst1
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_total_match
    candidate = method(:total_match)
    assert_equal([], candidate.call([], []))
    assert_equal([""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]))
    assert_equal([""4""], candidate.call([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]))
    assert_equal([""hI"", ""Hi""], candidate.call([""hi"", ""admin""], [""hI"", ""Hi""]))
    assert_equal([""hI"", ""hi"", ""hi""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]))
    assert_equal([""hi"", ""admin""], candidate.call([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]))
    assert_equal([], candidate.call([], [""this""]))
    assert_equal([], candidate.call([""this""], []))
  end
end
"
HumanEval_75,snd_Arab,rb,"مثال: ڄاڻڻ ته (a) 100 کان گهٽ آهي.۽ ٻي صورت ۾ غلط آهي.هڪ فنڪشن لکو جيڪو سچو موٽائي ٿو جيڪڏهن ڏنل نمبر 3 پرائم نمبرن جو ضرب آهي# >>> is_multiply_prime.call(30)
# true
# 30 = 2 * 3 * 5
def is_multiply_prime(a)
","require 'prime'

def is_multiply_prime(a)
  return false if a >= 100
  prime_factors = a.prime_division
  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_multiply_prime
    candidate = method(:is_multiply_prime)
    assert_equal(false, candidate.call(5))
    assert_equal(true, candidate.call(30))
    assert_equal(true, candidate.call(8))
    assert_equal(false, candidate.call(10))
    assert_equal(true, candidate.call(125))
    assert_equal(true, candidate.call(105))
    assert_equal(false, candidate.call(126))
    assert_equal(false, candidate.call(729))
    assert_equal(false, candidate.call(891))
    assert_equal(true, candidate.call(1001))
  end
end
"
HumanEval_76,snd_Arab,rb,"مثال طور: x n جي هڪ سادي طاقت آهي جيڪڏهن n**int=x n جي طاقت ۽ غلط ٻين ڪيسن ۾.توهان جو ڪم هڪ فنڪشن لکڻ آهي جيڪو صحيح موٽندو آهي جيڪڏهن هڪ نمبر x هڪ سادي آهي# >>> is_simple_power.call(1, 4)
# true
# >>> is_simple_power.call(2, 2)
# true
# >>> is_simple_power.call(8, 2)
# true
# >>> is_simple_power.call(3, 2)
# false
# >>> is_simple_power.call(3, 1)
# false
# >>> is_simple_power.call(5, 3)
# false
def is_simple_power(x, n)
","def is_simple_power(x, n)
  return false if x <= 0 || n <= 1
  return true if x == 1

  power = n
  while power <= x
    return true if power == x
    power *= n
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_simple_power
    candidate = method(:is_simple_power)
    assert_equal(true, candidate.call(16, 2))
    assert_equal(false, candidate.call(143214, 16))
    assert_equal(true, candidate.call(4, 2))
    assert_equal(true, candidate.call(9, 3))
    assert_equal(true, candidate.call(16, 4))
    assert_equal(false, candidate.call(24, 2))
    assert_equal(false, candidate.call(128, 4))
    assert_equal(false, candidate.call(12, 6))
    assert_equal(true, candidate.call(1, 1))
    assert_equal(true, candidate.call(1, 12))
  end
end
"
HumanEval_77,snd_Arab,rb,"مثال: نوٽ: توهان فرض ڪري سگھو ٿا ته ان پٽ هميشه صحيح آهي.جيڪڏهن هي انگ هڪ عدد عدد جو مکعب آهي.هڪ فنڪشن لکو جيڪو هڪ عدد a وٺي ۽ true موٽائي # >>> iscube.call(1)
# true
# >>> iscube.call(2)
# false
# >>> iscube.call(-1)
# true
# >>> iscube.call(64)
# true
# >>> iscube.call(0)
# true
# >>> iscube.call(180)
# false
def iscube(a)
","def iscube(a)
  cube_root = a.abs**(1.0/3)
  cube_root.round**3 == a
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_iscube
    candidate = method(:iscube)
    assert_equal(true, candidate.call(1))
    assert_equal(false, candidate.call(2))
    assert_equal(true, candidate.call(-1))
    assert_equal(true, candidate.call(64))
    assert_equal(false, candidate.call(180))
    assert_equal(true, candidate.call(1000))
    assert_equal(true, candidate.call(0))
    assert_equal(false, candidate.call(1729))
  end
end
"
HumanEval_78,snd_Arab,rb,"مثال: ۽ نشان A،B،C،D،E،F هميشه وڏا اکر آهن.نوٽ: توهان فرض ڪري سگھو ٿا ته ان پٽ هميشه صحيح يا خالي اسٽرنگ آهي، بي (= ڏهين 11) ، ڊي (= ڏهين 13) پوءِ توهان کي هيٺين انگن مان هڪ نمبر معلوم ڪرڻو پوندو: 2، 3، 5، 7، پرائم نمبر آهن 2، 3، 5، 7، 11، 13، 17، . . .هيڪساديسيمل انگن اکرن ۾ 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، اي، بي، سي، ڊي، اي، ايف آهن.1 کان وڏو آهي جيڪو ٻن ننڍن قدرتي انگن جو هڪ پيداوار نه آهي).عدد جيڪي پرائم آهن (پرائم نمبر، يا پرائم، هڪ قدرتي نمبر آهي)هڪ hexadecimal انگ هڪ جملو ۽ hexadecimal جي تعداد ۾ ڳڻيندو آھي توھان کي ھڪ فنڪشن لکڻ جو ڪم ڏنو ويو آھي جيڪو وصول ڪري ٿو# >>> hex_key.call(""AB"")
# 1
# >>> hex_key.call(""1077E"")
# 2
# >>> hex_key.call(""ABED1A33"")
# 4
# >>> hex_key.call(""123456789ABCDEF0"")
# 6
# >>> hex_key.call(""2020"")
# 2
def hex_key(num)
","def hex_key(num)
  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']
  num.chars.count { |digit| prime_hex_digits.include?(digit) }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_hex_key
    candidate = method(:hex_key)
    assert_equal(1, candidate.call(""AB""))
    assert_equal(2, candidate.call(""1077E""))
    assert_equal(4, candidate.call(""ABED1A33""))
    assert_equal(2, candidate.call(""2020""))
    assert_equal(6, candidate.call(""123456789ABCDEF0""))
    assert_equal(12, candidate.call(""112233445566778899AABBCCDDEEFF00""))
  end
end
"
HumanEval_79,snd_Arab,rb,"مثال: اضافي اکرن جي فارميٽ سان مدد لاء آهن.string جي شروعات ۽ آخر ۾ هڪ اضافي اکر 'db' هوندا.هر اکر ۾ '0' يا '1' هوندو.بائنري فارميٽ. فنڪشن کي هڪ اسٽرنگ موٽڻ گهرجي، هر ڪردار هڪ بائنري  جي نمائندگي ڪندي.توهان کي ڏهين شڪل ۾ هڪ نمبر ڏنو ويندو ۽ توهان جو ڪم ان کي تبديل ڪرڻ آهي# >>> decimal_to_binary.call(15)
# ""db1111db""
# >>> decimal_to_binary.call(32)
# ""db100000db""
def decimal_to_binary(decimal)
","def decimal_to_binary(decimal)
  ""db"" + decimal.to_s(2) + ""db""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_decimal_to_binary
    candidate = method(:decimal_to_binary)
    assert_equal(""db0db"", candidate.call(0))
    assert_equal(""db100000db"", candidate.call(32))
    assert_equal(""db1100111db"", candidate.call(103))
    assert_equal(""db1111db"", candidate.call(15))
  end
end
"
HumanEval_80,snd_Arab,rb,"مثال طور: هڪ تار haprb آهي جيڪڏهن ان جي ڊيگهه گهٽ ۾ گهٽ 3 آهي ۽ هر 3 لڳاتار اکر الڳ الڳ آهن توهان جو ڪم اهو چڪاس ڪرڻ آهي ته ڇا اهو سلسلو صحيح آهي يا نه.توھان کي ھڪ string s ڏنو ويو آھي.# >>> is_happy.call(""a"")
# false
# >>> is_happy.call(""aa"")
# false
# >>> is_happy.call(""abcd"")
# true
# >>> is_happy.call(""aabb"")
# false
# >>> is_happy.call(""adb"")
# true
# >>> is_happy.call(""xyy"")
# false
def is_happy(s)
","def is_happy(s)
  return false if s.length < 3
  
  (0..s.length - 3).each do |i|
    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]
  end
  
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_happy
    candidate = method(:is_happy)
    assert_equal(false, candidate.call(""a""))
    assert_equal(false, candidate.call(""aa""))
    assert_equal(true, candidate.call(""abcd""))
    assert_equal(false, candidate.call(""aabb""))
    assert_equal(true, candidate.call(""adb""))
    assert_equal(false, candidate.call(""xyy""))
    assert_equal(true, candidate.call(""iopaxpoi""))
    assert_equal(false, candidate.call(""iopaxioi""))
  end
end
"
HumanEval_81,snd_Arab,rb,"مثال: 0.0 اي > 0.0 ڊي- > 0.7 ڊي > 1.0 ڊي + > 1.3 سي- > 1.7 سي > 2.0 سي + > 2.3 بي- > 2.7 بي > 3.0 بي + > 3.3 A- > 3.7 A 4.0 اي + GPA. خط جو گريڊ.هڪ فنڪشن جيڪو هيٺ ڏنل ٽيبل استعمال ڪندي خط جي درجي جي صف کي ٻاھر ڪ canي سگھي ٿو: هن توکي ڪجهه شاگردن جي لاءِ GPA جو هڪ سلسلو ڏنو آهي ۽ توکي لکڻ گهرجي .بس مسئلو اهو آهي ته هن کي ڪوڊ ياد نه آهي جنهن سان هو گريڊنگ ڪندو هو.استاد پنهنجي گريڊنگ لاءِ الگورتھم ٺاهي رهيو آهي.هي سيمسٽر جو آخري هفتو آهي ۽ استاد کي گريڊ ڏيڻا آهن.# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])
# [""A+"", ""B"", ""C-"", ""C"", ""A-""]
def numerical_letter_grade(grades)
","def numerical_letter_grade(grades)
  grades.map do |gpa|
    case 
    when gpa == 4.0
      ""A+""
    when gpa > 3.7
      ""A""
    when gpa > 3.3
      ""A-""
    when gpa > 3.0
      ""B+""
    when gpa > 2.7
      ""B""
    when gpa > 2.3
      ""B-""
    when gpa > 2.0
      ""C+""
    when gpa > 1.7
      ""C""
    when gpa > 1.3
      ""C-""
    when gpa > 1.0
      ""D+""
    when gpa > 0.7
      ""D""
    when gpa > 0.0
      ""D-""
    else
      ""E""
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_numerical_letter_grade
    candidate = method(:numerical_letter_grade)
    assert_equal([""A+"", ""B"", ""C-"", ""C"", ""A-""], candidate.call([4.0, 3, 1.7, 2, 3.5]))
    assert_equal([""D+""], candidate.call([1.2]))
    assert_equal([""D-""], candidate.call([0.5]))
    assert_equal([""E""], candidate.call([0.0]))
    assert_equal([""D"", ""D-"", ""C-"", ""B"", ""B+""], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))
    assert_equal([""E"", ""D-""], candidate.call([0.0, 0.7]))
  end
end
"
HumanEval_82,snd_Arab,rb,"مثال length هڪ پرائم نمبر آهي يا ٻي صورت ۾ غلط آهي هڪ فنڪشن لکو جيڪو هڪ اسٽرنگ وٺي ۽ سچو موٽائي جيڪڏهن اسٽرنگ # >>> prime_length.call(""Hello"")
# true
# >>> prime_length.call(""abcdcba"")
# true
# >>> prime_length.call(""kittens"")
# true
# >>> prime_length.call(""orange"")
# false
def prime_length(string)
","def prime_length(string)
  length = string.length
  return false if length < 2

  (2..Math.sqrt(length)).each do |i|
    return false if length % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prime_length
    candidate = method(:prime_length)
    assert_equal(true, candidate.call(""Hello""))
    assert_equal(true, candidate.call(""abcdcba""))
    assert_equal(true, candidate.call(""kittens""))
    assert_equal(false, candidate.call(""orange""))
    assert_equal(true, candidate.call(""wow""))
    assert_equal(true, candidate.call(""world""))
    assert_equal(true, candidate.call(""MadaM""))
    assert_equal(true, candidate.call(""Wow""))
    assert_equal(false, candidate.call(""""))
    assert_equal(true, candidate.call(""HI""))
    assert_equal(true, candidate.call(""go""))
    assert_equal(false, candidate.call(""gogo""))
    assert_equal(false, candidate.call(""aaaaaaaaaaaaaaa""))
    assert_equal(true, candidate.call(""Madam""))
    assert_equal(false, candidate.call(""M""))
    assert_equal(false, candidate.call(""0""))
  end
end
"
HumanEval_83,snd_Arab,rb,"مثبت عدد جيڪي 1 سان شروع يا ختم ٿين ٿا.مثبت عدد n ڏنو ويو، n-عدد جي انگن جي ڳڻپ موٽائي def starts_one_ends(n)
","def starts_one_ends(n)
  return 0 if n <= 0

  # Count numbers starting with 1
  start_with_1 = 9 ** (n - 1)

  # Count numbers ending with 1
  end_with_1 = 9 ** (n - 1)

  # Adjust for double counting the number that both starts and ends with 1
  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1
  
  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_starts_one_ends
    candidate = method(:starts_one_ends)
    assert_equal(1, candidate.call(1))
    assert_equal(18, candidate.call(2))
    assert_equal(180, candidate.call(3))
    assert_equal(1800, candidate.call(4))
    assert_equal(18000, candidate.call(5))
  end
end
"
HumanEval_84,snd_Arab,rb,"مثال هڪ مثبت انٽيگر N ڏنو ويو آهي، ان جي انگن جو مجموعو بائنري ۾ موٽايو. # >>> solve.call(1000)
# ""1""
# >>> solve.call(150)
# ""110""
# >>> solve.call(147)
# ""1100""
# Variables:
# @N integer
# Constraints: 0 ≤ N ≤ 10000.
# Output:
# a string of binary number
def solve(n)
","def solve(n)
  sum_of_digits = n.to_s.chars.map(&:to_i).sum
  sum_of_digits.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""1"", candidate.call(1000))
    assert_equal(""110"", candidate.call(150))
    assert_equal(""1100"", candidate.call(147))
    assert_equal(""1001"", candidate.call(333))
    assert_equal(""10010"", candidate.call(963))
  end
end
"
HumanEval_85,snd_Arab,rb,"مثال: lst. جي هڪ غير خالي صف ڏنو integers جي شامل به عنصرن ته اڻڄاتل indexes تي آهن. .# >>> add.call([4, 2, 6, 7])
# 2
def add(lst)
","def add(lst)
  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add
    candidate = method(:add)
    assert_equal(88, candidate.call([4, 88]))
    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))
    assert_equal(0, candidate.call([4, 0, 6, 7]))
    assert_equal(12, candidate.call([4, 4, 6, 8]))
  end
end
"
HumanEval_86,snd_Arab,rb,"مثال طور: نوٽ: توهان کي جملي ۾ لفظن ۽ خالي جڳهن جي ترتيب کي برقرار رکڻ گهرجي.ascending حڪم جي بنياد تي ascii قدر. هڪ نئين لفظ جي جاء تي آهن جتي سڀني جي ڪردارن ۾ ترتيب string جو آرڊر ٿيل نسخو، هڪ اسٽرنگ آهي جتي سڀئي لفظ (اسپيس سان جدا ٿيل) هڪ فنڪشن لکو جيڪو هڪ اسٽرنگ وٺي ۽ ان جو هڪ آرڊر ٿيل نسخو موٽائي.# >>> anti_shuffle.call(""Hi"")
# ""Hi""
# >>> anti_shuffle.call(""hello"")
# ""ehllo""
# >>> anti_shuffle.call(""Hello World!!!"")
# ""Hello !!!Wdlor""
def anti_shuffle(s)
","def anti_shuffle(s)
  s.split(/(\s+)/).map { |word| word.chars.sort.join }.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_anti_shuffle
    candidate = method(:anti_shuffle)
    assert_equal(""Hi"", candidate.call(""Hi""))
    assert_equal(""ehllo"", candidate.call(""hello""))
    assert_equal(""bemnru"", candidate.call(""number""))
    assert_equal(""abcd"", candidate.call(""abcd""))
    assert_equal(""Hello !!!Wdlor"", candidate.call(""Hello World!!!""))
    assert_equal("""", candidate.call(""""))
    assert_equal("".Hi My aemn is Meirst .Rboot How aer ?ouy"", candidate.call(""Hi. My name is Mister Robot. How are you?""))
  end
end
"
HumanEval_87,snd_Arab,rb,"مثال: ان کان علاوه، قطار جي ڪالمن جي ترتيب ترتيب سان ترتيب ڏيو.شروعاتي ترتيب ۾ قطار ۾ ترتيب ڏيو.هر صف هڪ همراهه آهي - (صف، ڪالمن) ، 0 سان شروع ٿي.۽ arrays جي arrays، [(x1، y1، (x2، y2) ] اهڙي ته موٽڻ lst ڏنو، ۽ انٽيگر x، صف ۾ انٽيگرز x ڳوليو، هر قطار ۾ مختلف نمبر جا ڪالمن شامل ٿي سگهن ٿا.جيڪو ميٽرڪس سان ملندڙ جلندڙ آهي، پر ميٽرڪس جي برعڪس،توهان کي هڪ 2 dimensional ڊيٽا ڏنو ويو آهي، هڪ nested arrays جي طور تي، # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
# >>> get_row.call([], 1)
# []
# >>> get_row.call([[], [1], [1, 2, 3]], 3)
# [[2, 2]]
def get_row(lst, x)
","def get_row(lst, x)
  result = []

  lst.each_with_index do |row, i|
    row.each_with_index do |value, j|
      result << [i, j] if value == x
    end
  end

  result.sort_by { |coord| [coord[0], -coord[1]] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_row
    candidate = method(:get_row)
    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))
    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))
    assert_equal([], candidate.call([], 1))
    assert_equal([], candidate.call([[1]], 2))
    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))
  end
end
"
HumanEval_88,snd_Arab,rb,"مثال: * ڏنل صف کي تبديل نه ڪريو. نوٽ:يا ان کي هيٺ لھڻ واري ترتيب ۾ ترتيب ڏيو جيڪڏھن رقم ((پهريون انڊيڪس قدر ، آخري انڊيڪس قدر) به آھي.توهان جي ڏنل صف ۾ ascending حڪم ۾ ترتيب ڏيندو ته جي رقم ((پهرين انڊيڪس قدر، آخري انڊيڪس قدر) اڻڄاڻ آهي، غير منفي عدد جي صف ڏني وئي، ترتيب ڏيڻ کان پوءِ ڏنل صف جو هڪ ڪور واپس آڻيو،# >>> sort_array.call([])
# []
# >>> sort_array.call([5])
# [5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5])
# [0, 1, 2, 3, 4, 5]
# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])
# [6, 5, 4, 3, 2, 1, 0]
def sort_array(array)
","def sort_array(array)
  return array if array.empty? || array.size == 1

  if (array.first + array.last).odd?
    array.sort
  else
    array.sort.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([], candidate.call([]))
    assert_equal([5], candidate.call([5]))
    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))
    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))
    assert_equal([1, 2], candidate.call([2, 1]))
    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))
    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))
  end
end
"
HumanEval_89,snd_Arab,rb,"مثال طور: ٻه دفعا ٻه جڳهن تي منتقل ڪريو.الفابيٽ کي اهڙي طرح گھمايو وڃي ته اکر هڪ اسٽرنگ موٽائي ٿو جنهن کي الفابيٽ جي گردش سان انڪوڊ ڪيو ويو آهي.هڪ فنڪشن ٺاهيو جيڪو هڪ اسٽرنگ کي دليل طور وٺي ۽ # >>> encrypt.call(""hi"")
# ""lm""
# >>> encrypt.call(""asdfghjkl"")
# ""ewhjklnop""
# >>> encrypt.call(""gf"")
# ""kj""
# >>> encrypt.call(""et"")
# ""ix""
def encrypt(s)
","def encrypt(s)
  s.chars.map do |char|
    if char =~ /[a-z]/
      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr
    elsif char =~ /[A-Z]/
      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr
    else
      char
    end
  end.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encrypt
    candidate = method(:encrypt)
    assert_equal(""lm"", candidate.call(""hi""))
    assert_equal(""ewhjklnop"", candidate.call(""asdfghjkl""))
    assert_equal(""kj"", candidate.call(""gf""))
    assert_equal(""ix"", candidate.call(""et""))
    assert_equal(""jeiajeaijeiak"", candidate.call(""faewfawefaewg""))
    assert_equal(""lippsqcjvmirh"", candidate.call(""hellomyfriend""))
    assert_equal(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"", candidate.call(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""))
    assert_equal(""e"", candidate.call(""a""))
  end
end
"
HumanEval_90,snd_Arab,rb,"جيڪڏهن ڪو اهڙو عنصر نه هجي ته null موٽايو.هڪ فنڪشن لکو next_smallest (_) جيڪو صف جو ٻيو نن smallestو عنصر واپس ڪري ٿو. توهان کي انٽيگرز جي هڪ صف ڏني وئي آهي.# >>> next_smallest.call([1, 2, 3, 4, 5])
# 2
# >>> next_smallest.call([5, 1, 4, 3, 2])
# 2
# >>> next_smallest.call([])
# nil
# >>> next_smallest.call([1, 1])
# nil
def next_smallest(lst)
","def next_smallest(lst)
  unique_sorted = lst.uniq.sort
  unique_sorted.length >= 2 ? unique_sorted[1] : nil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_next_smallest
    candidate = method(:next_smallest)
    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))
    assert_equal(nil, candidate.call([]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))
    assert_equal(nil, candidate.call([1, 1]))
    assert_equal(-35, candidate.call([-35, 34, 12, -45]))
  end
end
"
HumanEval_91,snd_Arab,rb,"مثال طور: جملن جي وچ ۾ """"، ""؟"" يا ""! "" نشان لڳل آهن.بوريت جو لفظ آهي. بوريت هڪ جملو آهي جيڪو لفظ ""I"" سان شروع ٿئي ٿو.توھان کي لفظن جو سلسلو ڏنو ويندو، ۽ توھان جو ڪم اھو آھي ته ان جو تعداد ڳڻيو وڃي.# >>> is_bored.call(""Hello world"")
# 0
# >>> is_bored.call(""The sky is blue. The sun is shining. I love this weather"")
# 1
def is_bored(s)
","def is_bored(s)
  sentences = s.split(/(?<=[.?!])/)
  sentences.count { |sentence| sentence.strip.start_with?('I') }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_bored
    candidate = method(:is_bored)
    assert_equal(0, candidate.call(""Hello world""))
    assert_equal(0, candidate.call(""Is the sky blue?""))
    assert_equal(1, candidate.call(""I love It !""))
    assert_equal(0, candidate.call(""bIt""))
    assert_equal(2, candidate.call(""I feel good today. I will be productive. will kill It""))
    assert_equal(0, candidate.call(""You and I are going for a walk""))
  end
end
"
HumanEval_92,snd_Arab,rb,"مثال ٻين ڪيسن ۾ غلط موٽائي ٿو.جيڪڏهن هڪ نمبر ٻين ٻن جي مجموعي جي برابر آهي ۽ سڀ نمبر انٽيجر آهن ته پوءِ صحيح موٽائي ٿو.هڪ فنڪشن ٺاهيو جيڪو 3 نمبر وٺندو آهي.# >>> any_int.call(5, 2, 7)
# true
# >>> any_int.call(3, 2, 2)
# false
# >>> any_int.call(3, -2, 1)
# true
# >>> any_int.call(3.6, -2.2, 2)
# false
def any_int(x, y, z)
","def any_int(x, y, z)
  if [x, y, z].all? { |n| n.is_a?(Integer) }
    x == y + z || y == x + z || z == x + y
  else
    false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_any_int
    candidate = method(:any_int)
    assert_equal(true, candidate.call(2, 3, 1))
    assert_equal(false, candidate.call(2.5, 2, 3))
    assert_equal(false, candidate.call(1.5, 5, 3.5))
    assert_equal(false, candidate.call(2, 6, 2))
    assert_equal(true, candidate.call(4, 2, 2))
    assert_equal(false, candidate.call(2.2, 2.2, 2.2))
    assert_equal(true, candidate.call(-4, 6, 2))
    assert_equal(true, candidate.call(2, 1, 1))
    assert_equal(true, candidate.call(3, 4, 7))
    assert_equal(false, candidate.call(3.0, 4, 7))
  end
end
"
HumanEval_93,snd_Arab,rb,"مثال: صرف اکرن کي فرض ڪريو.انگريزي الفابيٽ ۾ هڪ حرف.پيغام جنهن جو خط ان کان 2 جڳهه اڳيان ظاهر ٿئي ٿو ان ڪري اهو سڀني اکرن جي صورت بدلائي ٿو، سڀني حرفن جي جاءِ تي هڪ فنڪشن لکو جيڪو هڪ پيغام وٺي ٿو، ۽ ان ۾ ڪوڊ ڪري ٿو# >>> encode.call(""test"")
# ""TGST""
# >>> encode.call(""This is a message"")
# ""tHKS KS C MGSSCGG""
def encode(message)
","def encode(message)
  vowels = 'aeiou'
  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}
  
  encoded_message = message.chars.map do |char|
    if vowels.include?(char.downcase)
      new_char = swap_vowels[char.downcase]
      char == char.upcase ? new_char.upcase : new_char.downcase
    else
      char == char.upcase ? char.downcase : char.upcase
    end
  end

  encoded_message.join
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_encode
    candidate = method(:encode)
    assert_equal(""tgst"", candidate.call(""TEST""))
    assert_equal(""mWDCSKR"", candidate.call(""Mudasir""))
    assert_equal(""ygs"", candidate.call(""YES""))
    assert_equal(""tHKS KS C MGSSCGG"", candidate.call(""This is a message""))
    assert_equal(""k dQnT kNqW wHcT Tq wRkTg"", candidate.call(""I DoNt KnOw WhAt tO WrItE""))
  end
end
"
HumanEval_94,snd_Arab,rb,"مثال: توهان جي وڏي ۾ وڏي پرائم قدر ڳولڻ ۽ ان جي انگن جي رقم موٽي ڪرڻ جي ضرورت آهي.توهان کي انٽيگرز جي هڪ صف ڏني وئي آهي.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
# 10
# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
# 25
# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
# 13
# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
# 11
# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])
# 3
# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])
# 7
def skjkasdkd(lst)
","def skjkasdkd(lst)
  require 'prime'

  # Find the largest prime number in the array
  largest_prime = lst.select { |num| Prime.prime?(num) }.max
  
  # Return 0 if no prime number is found
  return 0 if largest_prime.nil?

  # Calculate the sum of digits of the largest prime number
  largest_prime.to_s.chars.map(&:to_i).sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_skjkasdkd
    candidate = method(:skjkasdkd)
    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))
    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))
    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))
    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))
    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))
    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))
    assert_equal(19, candidate.call([8191]))
    assert_equal(19, candidate.call([8191, 123456, 127, 7]))
    assert_equal(10, candidate.call([127, 97, 8192]))
  end
end
"
HumanEval_95,snd_Arab,rb,"مثال: فنڪشن کي غلط موٽڻ گهرجي جيڪڏهن ڏنل هش خالي آهي. case يا سڀئي ڪيچ وڏن اکرن ۾ آهن، ٻي صورت ۾ false موٽايو.هڪ hash ڏنو، سچ موٽڻ جيڪڏھن سڀ ڪنجيون ۾ strings آهن هيٺين # >>> check_dict_case.call({""a"" => ""apple"", ""b"" => ""banana""})
# true
# >>> check_dict_case.call({""a"" => ""apple"", ""A"" => ""banana"", ""B"" => ""banana""})
# false
# >>> check_dict_case.call({""a"" => ""apple"", 8 => ""banana"", ""a"" => ""apple""})
# false
# >>> check_dict_case.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""})
# false
# >>> check_dict_case.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""})
# true
def check_dict_case(dict)
","def check_dict_case(dict)
  return false if dict.empty?

  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }
  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }

  lowercase_keys || uppercase_keys
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_dict_case
    candidate = method(:check_dict_case)
    assert_equal(true, candidate.call({""p"" => ""pineapple"", ""b"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""A"" => ""banana"", ""B"" => ""banana""}))
    assert_equal(false, candidate.call({""p"" => ""pineapple"", ""5"" => ""banana"", ""a"" => ""apple""}))
    assert_equal(false, candidate.call({""Name"" => ""John"", ""Age"" => ""36"", ""City"" => ""Houston""}))
    assert_equal(true, candidate.call({""STATE"" => ""NC"", ""ZIP"" => ""12345""}))
    assert_equal(true, candidate.call({""fruit"" => ""Orange"", ""taste"" => ""Sweet""}))
    assert_equal(false, candidate.call({}))
  end
end
"
HumanEval_96,snd_Arab,rb,"مثال طور: عدد جيڪي پرائم نمبر آهن ۽ n کان گهٽ آهن.هڪ فنڪشن لاڳو ڪريو جيڪو هڪ غير منفي انٽيگر وٺي ٿو ۽ پهرين n جي صف واپس ڪري ٿو# >>> count_up_to.call(5)
# [2, 3]
# >>> count_up_to.call(11)
# [2, 3, 5, 7]
# >>> count_up_to.call(0)
# []
# >>> count_up_to.call(20)
# [2, 3, 5, 7, 11, 13, 17, 19]
# >>> count_up_to.call(1)
# []
# >>> count_up_to.call(18)
# [2, 3, 5, 7, 11, 13, 17]
def count_up_to(n)
","def count_up_to(n)
  return [] if n <= 2
  primes = []
  (2...n).each do |num|
    is_prime = true
    (2..Math.sqrt(num)).each do |i|
      if num % i == 0
        is_prime = false
        break
      end
    end
    primes << num if is_prime
  end
  primes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_up_to
    candidate = method(:count_up_to)
    assert_equal([2, 3], candidate.call(5))
    assert_equal([2, 3, 5], candidate.call(6))
    assert_equal([2, 3, 5], candidate.call(7))
    assert_equal([2, 3, 5, 7], candidate.call(10))
    assert_equal([], candidate.call(0))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))
    assert_equal([], candidate.call(1))
    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))
    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))
  end
end
"
HumanEval_97,snd_Arab,rb,"مثال: فرض ڪريو ته ان پٽ هميشه صحيح آهي.انهن جي يونٽ انگن جي پيداوار. فنڪشن کي مڪمل ڪريو جيڪو ٻه انٽيگرز وٺندو آهي ۽ موٽندو آهي # >>> multiply.call(148, 412)
# 16
# >>> multiply.call(19, 28)
# 72
# >>> multiply.call(2020, 1851)
# 0
# >>> multiply.call(14, -15)
# 20
def multiply(a, b)
","def multiply(a, b)
  a_unit_digit = a.abs % 10
  b_unit_digit = b.abs % 10
  a_unit_digit * b_unit_digit
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_multiply
    candidate = method(:multiply)
    assert_equal(16, candidate.call(148, 412))
    assert_equal(72, candidate.call(19, 28))
    assert_equal(0, candidate.call(2020, 1851))
    assert_equal(20, candidate.call(14, -15))
    assert_equal(42, candidate.call(76, 67))
    assert_equal(49, candidate.call(17, 27))
    assert_equal(0, candidate.call(0, 1))
    assert_equal(0, candidate.call(0, 0))
  end
end
"
HumanEval_98,snd_Arab,rb,"مثال طور: هڪ اسٽرنگ s ڏنو ويو آهي ، وڏي اکرن جي تعداد کي ڳڻپ ڪريو.# >>> count_upper.call(""aBCdEf"")
# 1
# >>> count_upper.call(""abcdefg"")
# 0
# >>> count_upper.call(""dBBE"")
# 0
def count_upper(s)
","def count_upper(s)
  vowels = ['A', 'E', 'I', 'O', 'U']
  count = 0

  s.chars.each_with_index do |char, index|
    if index.even? && vowels.include?(char)
      count += 1
    end
  end

  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_upper
    candidate = method(:count_upper)
    assert_equal(1, candidate.call(""aBCdEf""))
    assert_equal(0, candidate.call(""abcdefg""))
    assert_equal(0, candidate.call(""dBBE""))
    assert_equal(0, candidate.call(""B""))
    assert_equal(1, candidate.call(""U""))
    assert_equal(0, candidate.call(""""))
    assert_equal(2, candidate.call(""EEEE""))
  end
end
"
HumanEval_99,snd_Arab,rb,"مثال ٻن عددن کان، ان کي صفر کان پري ڪرائي.۽ ان جي ويجھو انٽيگر موٽائي ٿو. جيڪڏهن نمبر equidistant آهي هڪ فنڪشن ٺاهيو جيڪو هڪ نمبر جي نمائندگي ڪندڙ قدر (سٽرنگ) وٺي ٿو # >>> closest_integer.call(""10"")
# 10
# >>> closest_integer.call(""15.3"")
# 15
# Note:
# Rounding away from zero means that if the given number is equidistant
# from two integers, the one you should return is the one that is the
# farthest from zero. For example closest_integer(""14.5"") should
# return 15 and closest_integer(""-14.5"") should return -15.
def closest_integer(value)
","def closest_integer(value)
  number = value.to_f
  if number > 0
    (number + 0.5).floor
  else
    (number - 0.5).ceil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_closest_integer
    candidate = method(:closest_integer)
    assert_equal(10, candidate.call(""10""))
    assert_equal(15, candidate.call(""14.5""))
    assert_equal(-16, candidate.call(""-15.5""))
    assert_equal(15, candidate.call(""15.3""))
    assert_equal(0, candidate.call(""0""))
  end
end
"
HumanEval_100,snd_Arab,rb,"مثال: i سطح ۾ پٿرن جو تعداد ظاهر ڪري ٿو (i+1).هڪ صف ۾ هر سطح ۾ پٿر جو تعداد موٽائي ٿو، جتي عنصر انڊيڪس - ايندڙ برابر نمبر جيڪڏهن n برابر آهي.- ايندڙ نمبر جيڪڏهن n جو نمبر انڊو آهي.ايندڙ سطح ۾ پٿرن جو تعداد آهي: پهرين سطح تي ن پٿر آهن.هڪ مثبت عدد n ڏنو وڃي، توهان کي پٿرن جي n سطحن جو هڪ پٿر ٺاهڻو آهي.# >>> make_a_pile.call(3)
# [3, 5, 7]
def make_a_pile(n)
","def make_a_pile(n)
  result = []
  current_stones = n
  n.times do
    result << current_stones
    current_stones += 2
  end
  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_make_a_pile
    candidate = method(:make_a_pile)
    assert_equal([3, 5, 7], candidate.call(3))
    assert_equal([4, 6, 8, 10], candidate.call(4))
    assert_equal([5, 7, 9, 11, 13], candidate.call(5))
    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))
    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))
  end
end
"
HumanEval_101,snd_Arab,rb,"مثال طور: لفظن ۾ اسٽرنگ کي ورهائڻ ۽ لفظن جي صف واپس ڪرڻ لاءِ.توهان کي ڪامن يا اسپيسز کان ڌار لفظن جو هڪ سلسلو ڏنو ويندو. توهان جو ڪم آهي # >>> words_string.call(""Hi, my name is John"")
# [""Hi"", ""my"", ""name"", ""is"", ""John""]
# >>> words_string.call(""One, two, three, four, five, six"")
# [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
def words_string(s)
","def words_string(s)
  s.split(/[\s,]+/)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_string
    candidate = method(:words_string)
    assert_equal([""Hi"", ""my"", ""name"", ""is"", ""John""], candidate.call(""Hi, my name is John""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One, two, three, four, five, six""))
    assert_equal([""Hi"", ""my"", ""name""], candidate.call(""Hi, my name""))
    assert_equal([""One"", ""two"", ""three"", ""four"", ""five"", ""six""], candidate.call(""One,, two, three, four, five, six,""))
    assert_equal([], candidate.call(""""))
    assert_equal([""ahmed"", ""gamal""], candidate.call(""ahmed     , gamal""))
  end
end
"
HumanEval_102,snd_Arab,rb,"مثال طور: اھڙو ڪو نمبر نه آھي، ته فنڪشن موٽڻ گھرجي -1.سڀ کان وڏو برابر عدد جيڪو [x، y] جي حد ۾ آهي.هي فنڪشن ٻه مثبت نمبر x ۽ y وٺندو آهي ۽ موٽندو آهي # >>> choose_num.call(12, 15)
# 14
# >>> choose_num.call(13, 12)
# -1
def choose_num(x, y)
","def choose_num(x, y)
  return -1 if x > y
  # Start looking from the largest number
  max_even = y.even? ? y : y - 1
  # Iterate downwards to find the biggest even number
  max_even.downto(x) do |n|
    return n if n.even?
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_choose_num
    candidate = method(:choose_num)
    assert_equal(14, candidate.call(12, 15))
    assert_equal(-1, candidate.call(13, 12))
    assert_equal(12354, candidate.call(33, 12354))
    assert_equal(-1, candidate.call(5234, 5233))
    assert_equal(28, candidate.call(6, 29))
    assert_equal(-1, candidate.call(27, 10))
    assert_equal(-1, candidate.call(7, 7))
    assert_equal(546, candidate.call(546, 546))
  end
end
"
HumanEval_103,snd_Arab,rb,"مثال: جيڪڏهن n m کان وڏو آهي، موٽايو -1.جواب کي ويجهي انٽيگر تائين گول ڪريو ۽ ان کي بائنري ۾ تبديل ڪريو.n کان وٺي m تائين (n ۽ m سميت) سڌن جو اوسط.توهان کي ٻه مثبت عدد n ۽ m ڏنا ويا آهن، ۽ توهان جو ڪم آهي ته  جي حساب ڪريو# >>> rounded_avg.call(1, 5)
# ""0b11""
# >>> rounded_avg.call(7, 5)
# -1
# >>> rounded_avg.call(10, 20)
# ""0b1111""
# >>> rounded_avg.call(20, 33)
# ""0b11010""
def rounded_avg(n, m)
","def rounded_avg(n, m)
  return -1 if n > m

  sum = (n..m).reduce(:+)
  count = m - n + 1
  average = (sum.to_f / count).round
  ""0b"" + average.to_i.to_s(2)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_rounded_avg
    candidate = method(:rounded_avg)
    assert_equal(""0b11"", candidate.call(1, 5))
    assert_equal(""0b1010"", candidate.call(7, 13))
    assert_equal(""0b1111001010"", candidate.call(964, 977))
    assert_equal(""0b1111100100"", candidate.call(996, 997))
    assert_equal(""0b1011000010"", candidate.call(560, 851))
    assert_equal(""0b101101110"", candidate.call(185, 546))
    assert_equal(""0b110101101"", candidate.call(362, 496))
    assert_equal(""0b1001110010"", candidate.call(350, 902))
    assert_equal(""0b11010111"", candidate.call(197, 233))
    assert_equal(-1, candidate.call(7, 5))
    assert_equal(-1, candidate.call(5, 1))
    assert_equal(""0b101"", candidate.call(5, 5))
  end
end
"
HumanEval_104,snd_Arab,rb,"مثال طور: نوٽ: واپس ٿيل صف کي وڌندڙ ترتيب ۾ ترتيب ڏيڻ گهرجي.عنصرن جو ڪو به انگ نه آهي.مثبت انٽيگرز جي هڪ صف ڏني وئي x. سڀني جي ترتيب واري صف واپس ڪريو # >>> unique_digits.call([15, 33, 1422, 1])
# [1, 15, 33]
# >>> unique_digits.call([152, 323, 1422, 10])
# []
def unique_digits(x)
","def unique_digits(x)
  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_unique_digits
    candidate = method(:unique_digits)
    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))
    assert_equal([], candidate.call([152, 323, 1422, 10]))
    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))
    assert_equal([31, 135], candidate.call([135, 103, 31]))
  end
end
"
HumanEval_105,snd_Arab,rb,"مثال طور: هڪ، ٻه، ٽي، چار، پنج، ڇهه، ست، اٺ، نو.نتيجي ۾ ترتيب کي ريورس ڪريو، ۽ پوءِ هر عدد کي ان جي نالي سان تبديل ڪريو عدد جي هڪ صف ڏني، 1 ۽ 9 جي وچ ۾ integers ترتيب، # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])
# [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
# If the array is empty, return an empty array:
# >>> by_length.call([])
# []
# If the array has any strange number ignore it:
# >>> by_length.call([1, -1, 55])
# [""One""]
def by_length(arr)
","def by_length(arr)
  number_names = {
    1 => ""One"",
    2 => ""Two"",
    3 => ""Three"",
    4 => ""Four"",
    5 => ""Five"",
    6 => ""Six"",
    7 => ""Seven"",
    8 => ""Eight"",
    9 => ""Nine""
  }

  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse
  filtered_sorted_reversed.map { |num| number_names[num] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_by_length
    candidate = method(:by_length)
    assert_equal([""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))
    assert_equal([], candidate.call([]))
    assert_equal([""One""], candidate.call([1, -1, 55]))
    assert_equal([""Three"", ""Two"", ""One""], candidate.call([1, -1, 3, 2]))
    assert_equal([""Nine"", ""Eight"", ""Four""], candidate.call([9, 4, 8]))
  end
end
"
HumanEval_106,snd_Arab,rb,"مثال: i جو فئڪٽريئل 1 کان i تائين نمبرن جو ضرب آهي (1 * 2 * . . . * i).مان 1 کان شروع ڪريان ٿو.يا 1 کان i تائين نمبرن جو مجموعو. ۽ سائيز n جي صف موٽائي ٿو، اهڙي طرح ته انڊيڪس i تي عنصر جي قيمت i جي فئڪٽريئر آهي جيڪڏهن i به آهي فنڪشن کي لاڳو ڪريو جيڪو n کي پيرا ميٽر طور وٺي ٿو، # >>> f.call(5)
# [1, 2, 6, 24, 15]
def f(n)
","def f(n)
  (1..n).map do |i|
    if i.even?
      (1..i).inject(:*) || 1
    else
      (1..i).inject(:+)
    end
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_f
    candidate = method(:f)
    assert_equal([1, 2, 6, 24, 15], candidate.call(5))
    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))
    assert_equal([1], candidate.call(1))
    assert_equal([1, 2, 6], candidate.call(3))
  end
end
"
HumanEval_107,snd_Arab,rb,"مثال 1: انٽيگر پيلنڊروم جيڪي حد جي اندر اچن ٿا ((1، ن) ، شامل آهن.هڪ مثبت انٽيگر n ڏنو، هڪ صف موٽائي جنهن ۾ به ۽ ڌار جو تعداد آهي # >>> even_odd_palindrome.call(3)
# [1, 2]
# Explanation:
# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
# Example 2:
# >>> even_odd_palindrome.call(12)
# [4, 6]
# Explanation:
# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
# Note:
# 1. 1 <= n <= 10^3
# 2. returned array has the number of even and odd integer palindromes respectively.
def even_odd_palindrome(n)
","def even_odd_palindrome(n)
  even_count = 0
  odd_count = 0

  (1..n).each do |num|
    if num.to_s == num.to_s.reverse
      if num.even?
        even_count += 1
      else
        odd_count += 1
      end
    end
  end

  [even_count, odd_count]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_palindrome
    candidate = method(:even_odd_palindrome)
    assert_equal([8, 13], candidate.call(123))
    assert_equal([4, 6], candidate.call(12))
    assert_equal([1, 2], candidate.call(3))
    assert_equal([6, 8], candidate.call(63))
    assert_equal([5, 6], candidate.call(25))
    assert_equal([4, 6], candidate.call(19))
    assert_equal([4, 5], candidate.call(9))
    assert_equal([0, 1], candidate.call(1))
  end
end
"
HumanEval_108,snd_Arab,rb,"مثال طور -123 ۾ نشاني وارا عدد -1, 2 ۽ 3 آهن.جيڪڏهن هڪ عدد منفي آهي ته پوءِ ان جو پهريون نشاني وارو عدد منفي هوندو:عنصرن جو تعداد جنهن جي انگن جو مجموعو آهي > 0هڪ فنڪشن count_nums لکو جيڪو انٽيگرز جي هڪ صف وٺي ٿو ۽ موٽائي ٿو # >>> count_nums.call([])
# 0
# >>> count_nums.call([-1, 11, -11])
# 1
# >>> count_nums.call([1, 1, 2])
# 3
def count_nums(arr)
","def count_nums(arr)
  arr.count do |num|
    num.to_s.chars.map(&:to_i).sum > 0
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_count_nums
    candidate = method(:count_nums)
    assert_equal(0, candidate.call([]))
    assert_equal(0, candidate.call([-1, -2, 0]))
    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))
    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))
    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))
    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))
    assert_equal(1, candidate.call([0, 1]))
    assert_equal(1, candidate.call([1]))
  end
end
"
HumanEval_109,snd_Arab,rb,"مثال طور: نوٽ: ڏنل صف ۾ منفرد عنصر هجڻ جي ضمانت آهي.جيڪڏهن ڏنل صف خالي آهي ته پوءِ true موٽايو.پوءِ واپس صحيح يا غلط موٽيو.جيڪڏهن اهو ممڪن آهي ته مٿي ڏنل آپريشن ڪندي ترتيب ڏنل صف حاصل ڪرڻ لاءِ صف ۾ شروعاتي پوزيشن يعني 0th انڊيڪس.صف جو آخري عنصر منتقل ڪيو ويندو هڪ صحيح طرف منتقل ڪرڻ جو مطلب آهي ته صف جي سڀني عنصرن کي هڪ طرف منتقل ڪرڻ.توهان کي صحيح شفٽ آپريشن ڪرڻ جي اجازت آهي ڪنهن به تعداد ۾.ڏنل صف تي ھيٺ ڏنل آپريشن: اهو ممڪن آهي ته هڪ صف کي غير گهٽجڻ واري ترتيب ۾ ترتيب ڏيڻ لاءِ صف ۾ نمبر بي ترتيب ترتيب سان ترتيب ڏنا ويندا. توهان جو ڪم اهو طئي ڪرڻ آهي ته اسان وٽ N انٽيگرز جي صف 'آر آر' آهي arr[1], arr[2]، ..., arr[N].# >>> move_one_ball.call([3, 4, 5, 1, 2])
# true
# Explanation: By performin 2 right shift operations, non-decreasing order can
# be achieved for the given array.
# >>> move_one_ball.call([3, 5, 4, 1, 2])
# false
# Explanation:It is not possible to get non-decreasing order for the given
# array by performing any number of right shift operations.
def move_one_ball(arr)
","def move_one_ball(arr)
  return true if arr.empty?

  n = arr.size
  count_rotation_point = 0
  rotation_index = -1

  (0...n).each do |i|
    next_index = (i + 1) % n
    if arr[i] > arr[next_index]
      count_rotation_point += 1
      rotation_index = next_index
    end
  end

  count_rotation_point <= 1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_move_one_ball
    candidate = method(:move_one_ball)
    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))
    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))
    assert_equal(false, candidate.call([4, 3, 1, 2]))
    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))
    assert_equal(true, candidate.call([]))
  end
end
"
HumanEval_110,snd_Arab,rb,"مثال طور: ٻي صورت ۾، ""نه"" موٽايو.lst1 جي سڀني عنصرن کي به برابر ڪرڻ لاءِ ، ""YES"" موٽايو.جيڪڏهن اهو ممڪن آهي ته lst1 ۽ lst2 جي وچ ۾ عناصر کي تبديل ڪرڻ لاءِlst1 ۽ lst2 جي وچ ۾ تبديل ٿيل عنصرن جي تعداد تي ڪا حد ناهي.انهن جي وچ ۾ صرف برابر نمبرن جي هڪ صف ٺاهڻ لاءِ.۽ اهو طئي ڪري ٿو ته ڇا عنصرن جي مٽاسٽا ڪرڻ ممڪن آهي هن مسئلي ۾، توهان هڪ فنڪشن ته انگن جي ٻن arrays لڳن ٿا لاڳو ٿيندو، # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])
# ""YES""
# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])
# ""NO""
# It is assumed that the input arrays will be non-empty.
def exchange(lst1, lst2)
","def exchange(lst1, lst2)
  # Check if lst1 already consists solely of even numbers
  return ""YES"" if lst1.all?(&:even?)

  # Check if there are at least as many even numbers in lst2
  # as there are odd numbers in lst1
  odd_count_lst1 = lst1.count(&:odd?)
  even_count_lst2 = lst2.count(&:even?)

  odd_count_lst1 <= even_count_lst2 ? ""YES"" : ""NO""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_exchange
    candidate = method(:exchange)
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))
    assert_equal(""NO"", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))
    assert_equal(""YES"", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))
    assert_equal(""YES"", candidate.call([5, 7, 3], [2, 6, 4]))
    assert_equal(""NO"", candidate.call([5, 7, 3], [2, 6, 3]))
    assert_equal(""NO"", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))
    assert_equal(""YES"", candidate.call([100, 200], [200, 200]))
  end
end
"
HumanEval_111,snd_Arab,rb,"مثال: جيڪڏهن ڪيترائي اکر هڪ ئي واقعو آهن، انهن سڀني کي واپس آڻيو.سڀ کان وڌيڪ ورجائي خط جو ۽ ان جي برابر شمار تي مشتمل آهي. هڪ اسٽرنگ ڏني وئي آهي جيڪا هڪ اسپيس الڳ ٿيل ننڍن اکرن جي نمائندگي ڪري ٿي، هڪ هش موٽايو # >>> histogram.call(""a b c"")
# {""a"" => 1, ""b"" => 1, ""c"" => 1}
# >>> histogram.call(""a b b a"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""a b c a b"")
# {""a"" => 2, ""b"" => 2}
# >>> histogram.call(""b b b b a"")
# {""b"" => 4}
# >>> histogram.call("""")
# {}
def histogram(test)
","def histogram(test)
  return {} if test.empty?

  count = Hash.new(0)

  test.split.each do |char|
    count[char] += 1
  end

  max_count = count.values.max
  count.select { |_, value| value == max_count }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_histogram
    candidate = method(:histogram)
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b b a""))
    assert_equal({""a"" => 2, ""b"" => 2}, candidate.call(""a b c a b""))
    assert_equal({""a"" => 1, ""b"" => 1, ""c"" => 1, ""d"" => 1, ""g"" => 1}, candidate.call(""a b c d g""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({""b"" => 4}, candidate.call(""b b b b a""))
    assert_equal({""r"" => 1, ""t"" => 1, ""g"" => 1}, candidate.call(""r t g""))
    assert_equal({}, candidate.call(""""))
    assert_equal({""a"" => 1}, candidate.call(""a""))
  end
end
"
HumanEval_112,snd_Arab,rb,"مثال توھان کي ھڪڙي صف موٽائڻي آھي جنھن ۾ نتيجو وارو سلسلو ۽ سچ / غلط آھي چيڪ لاءِ.هڪ تار کي پيلنڊروم سڏيو ويندو آهي جيڪڏهن اهو پوئتي ۽ اڳتي هڪجهڙو پڙهيو وڃي.پوءِ چڪاس ڪريو ته نتيجو وارو اسٽرنگ پيلنڊروم آهي.اسان کي ٻه اسٽرنگس s ۽ c ڏنا ويا آهن، توهان کي s ۾ موجود سڀ اکر ختم ڪرڻا پوندا جيڪي c ۾ موجود ڪنهن به اکر جي برابر آهنڪم # >>> reverse_delete.call(""abcde"", ""ae"")
# [""bcd"", false]
# >>> reverse_delete.call(""abcdef"", ""b"")
# [""acdef"", false]
# >>> reverse_delete.call(""abcdedcba"", ""ab"")
# [""cdedc"", true]
def reverse_delete(s, c)
","def reverse_delete(s, c)
  # Remove all characters in c from s
  filtered_string = s.delete(c)
  
  # Check if the filtered string is a palindrome
  is_palindrome = filtered_string == filtered_string.reverse
  
  # Return the result array
  [filtered_string, is_palindrome]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_reverse_delete
    candidate = method(:reverse_delete)
    assert_equal([""bcd"", false], candidate.call(""abcde"", ""ae""))
    assert_equal([""acdef"", false], candidate.call(""abcdef"", ""b""))
    assert_equal([""cdedc"", true], candidate.call(""abcdedcba"", ""ab""))
    assert_equal([""dik"", false], candidate.call(""dwik"", ""w""))
    assert_equal(["""", true], candidate.call(""a"", ""a""))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", """"))
    assert_equal([""abcdedcba"", true], candidate.call(""abcdedcba"", ""v""))
    assert_equal([""abba"", true], candidate.call(""vabba"", ""v""))
    assert_equal(["""", true], candidate.call(""mamma"", ""mia""))
  end
end
"
HumanEval_113,snd_Arab,rb,"ان پٽ جي i'th سلسلي ۾ اڻت جي انگن جي. ان پٽ جي string i. "" جتي سڀئي i کي نمبر سان تبديل ڪيو وڃي.هر عنصر آئوٽ جي آئوٽ جي نمبر تي هجڻ گهرجي.string جي هڪ صف ڏني وئي آهي، جتي هر string صرف انگن اکرن تي مشتمل آهي، هڪ array موٽائي ٿو.# >>> odd_count.call([""1234567""])
# [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
# >>> odd_count.call([""3"", ""11111111""])
# [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
def odd_count(lst)
","def odd_count(lst)
  lst.map do |num_str|
    count = num_str.count('13579')
    ""the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_odd_count
    candidate = method(:odd_count)
    assert_equal([""the number of odd elements 4n the str4ng 4 of the 4nput.""], candidate.call([""1234567""]))
    assert_equal([""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], candidate.call([""3"", ""11111111""]))
    assert_equal([""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""], candidate.call([""271"", ""137"", ""314""]))
  end
end
"
HumanEval_114,snd_Arab,rb,"مثال جي nums.عدد جي صف کي ڏنو وڃي ته انٽيگرز نمبرز جي صف ۾، ڪنهن به غير خالي ذيلي صف جو گھٽ ۾ گھٽ مجموعو ڳوليو # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])
# 1
# >>> minSubArraySum.call([-1, -2, -3])
# -6
def minSubArraySum(nums)
","def minSubArraySum(nums)
  min_sum = nums[0]
  current_sum = 0
  nums.each do |num|
    if current_sum > 0
      current_sum = num
    else
      current_sum += num
    end
    min_sum = [min_sum, current_sum].min
  end
  min_sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minSubArraySum
    candidate = method(:minSubArraySum)
    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))
    assert_equal(-6, candidate.call([-1, -2, -3]))
    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))
    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))
    assert_equal(0, candidate.call([0, 10, 20, 1000000]))
    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))
    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))
    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))
    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))
    assert_equal(-10, candidate.call([-10]))
    assert_equal(7, candidate.call([7]))
    assert_equal(-1, candidate.call([1, -1]))
  end
end
"
HumanEval_115,snd_Arab,rb,"مثال 1: جي ڀيرا توهان جي buckets لاٿو ڪرڻ جي ضرورت جو تعداد ٻاھر.توھان جو ڪم آھي ته برتن کي خالي ڪرڻ لاءِ بالٽيون استعمال ڪريو.۽ سڀني بڪين جي گنجائش برابر آهي.هر کوهه ۾ هڪ جهڙي دٻي آهي جنهن مان پاڻي ڪڍي سگهجي ٿو، ۽ هر هڪ قطار ۾ 1 پاڻي جي هڪ واحد يونٽ جي نمائندگي ڪري ٿو.توهان کي ويلز جو هڪ مستطيل گرڊ ڏنو ويو آهي. هر قطار هڪ واحد ويل جي نمائندگي ڪري ٿي، # >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
# 6
# Example 2:
# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
# 5
# Example 3:
# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)
# 0
# Constraints:
# * all wells have the same length
# * 1 <= grid.length <= 10^2
# * 1 <= grid[:,1].length <= 10^2
# * grid[i][j] -> 0 | 1
# * 1 <= capacity <= 10
def max_fill(grid, capacity)
","def max_fill(grid, capacity)
  total_water_units = grid.flatten.sum
  (total_water_units.to_f / capacity).ceil
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_max_fill
    candidate = method(:max_fill)
    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))
    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))
    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))
    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))
    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))
  end
end
"
HumanEval_116,snd_Arab,rb,"ان کي هن طرح لاڳو ڪرڻ گهرجي: هڪ جيتري تعداد لاءِ، ڊيزيمل ويليو جي بنياد تي ترتيب ڏيو.انهن جي بائنري نمائندگي ۾ هڪ جي تعداد ۾ وڌندڙ ترتيب ۾.هن kata ۾، توهان کي غير منفي integers جي هڪ صف ترتيب ڪرڻ آهي مطابق # >>> sort_array.call([1, 5, 2, 3, 4])
# [1, 2, 3, 4, 5]
# >>> sort_array.call([-2, -3, -4, -5, -6])
# [-6, -5, -4, -3, -2]
# >>> sort_array.call([1, 0, 2, 3, 4])
# [0, 1, 2, 3, 4]
def sort_array(arr)
","def sort_array(arr)
  arr.sort_by { |n| [n.to_s(2).count('1'), n] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sort_array
    candidate = method(:sort_array)
    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))
    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))
    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))
    assert_equal([], candidate.call([]))
    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))
    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))
  end
end
"
HumanEval_117,snd_Arab,rb,"مثال: نوٽ: توهان فرض ڪري سگھو ٿا ته ان پٽ اسٽرنگ ۾ صرف اکر ۽ اسپيس آهن.جيڪڏهن string s خالي آهي ته پوءِ فنڪشن کي خالي صف موٽائڻي پوندي.n ڪنسنٽ، ان ڪري اهي لفظ string s ۾ ظاهر ٿين ٿا.هڪ فنڪشن جيڪو string s مان سڀني لفظن جي هڪ صف واپس ڪري ٿو جنهن ۾ بلڪل هڪ string s ۽ هڪ قدرتي نمبر n ڏنو، اوھان کي لاڳو ڪرڻ لاء tasked ڪيو ويو آهي # >>> select_words.call(""Mary had a little lamb"", 4)
# [""little""]
# >>> select_words.call(""Mary had a little lamb"", 3)
# [""Mary"", ""lamb""]
# >>> select_words.call(""simple white space"", 2)
# []
# >>> select_words.call(""Hello world"", 4)
# [""world""]
# >>> select_words.call(""Uncle sam"", 3)
# [""Uncle""]
def select_words(s, n)
","def select_words(s, n)
  vowels = ""aeiouAEIOU""
  words = s.split
  words.select do |word|
    consonant_count = word.chars.count { |char| !vowels.include?(char) }
    consonant_count == n
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_select_words
    candidate = method(:select_words)
    assert_equal([""little""], candidate.call(""Mary had a little lamb"", 4))
    assert_equal([""Mary"", ""lamb""], candidate.call(""Mary had a little lamb"", 3))
    assert_equal([], candidate.call(""simple white space"", 2))
    assert_equal([""world""], candidate.call(""Hello world"", 4))
    assert_equal([""Uncle""], candidate.call(""Uncle sam"", 3))
    assert_equal([], candidate.call("""", 4))
    assert_equal([""b"", ""c"", ""d"", ""f""], candidate.call(""a b c d e f"", 1))
  end
end
"
HumanEval_118,snd_Arab,rb,"مثال: توهان فرض ڪري سگھو ٿا ته ڏنل اسٽرنگ ۾ صرف انگريزي اکر شامل آهن.ڪنهن به آواز کي ڳولهيو جيڪو مٿي ڏنل شرط تي پورو لهي.شروع ۽ آخر ۾ وولن جي ڳڻپ نه ڪئي ويندي آهي جيڪڏهن نه ته خالي تار واپس ڪريولفظ جي ساڄي پاسي کان ٻه ڪنسنٽ (ڪيس حساس).توھان کي ھڪ لفظ ڏنو ويو آھي توھان جو ڪم آھي ته ويجھي ويجھي آواز کي ڳولھيو جيڪو وچ ۾ بيٺو آھي# >>> get_closest_vowel.call(""yogurt"")
# ""u""
# >>> get_closest_vowel.call(""FULL"")
# ""U""
# >>> get_closest_vowel.call(""quick"")
# """"
# >>> get_closest_vowel.call(""ab"")
# """"
def get_closest_vowel(word)
","def get_closest_vowel(word)
  vowels = ""aeiouAEIOU""
  (1...word.length - 1).reverse_each do |i|
    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])
      return word[i]
    end
  end
  return """"
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_closest_vowel
    candidate = method(:get_closest_vowel)
    assert_equal(""u"", candidate.call(""yogurt""))
    assert_equal(""u"", candidate.call(""full""))
    assert_equal("""", candidate.call(""easy""))
    assert_equal("""", candidate.call(""eAsy""))
    assert_equal("""", candidate.call(""ali""))
    assert_equal(""a"", candidate.call(""bad""))
    assert_equal(""o"", candidate.call(""most""))
    assert_equal("""", candidate.call(""ab""))
    assert_equal("""", candidate.call(""ba""))
    assert_equal("""", candidate.call(""quick""))
    assert_equal(""i"", candidate.call(""anime""))
    assert_equal("""", candidate.call(""Asia""))
    assert_equal(""o"", candidate.call(""Above""))
  end
end
"
HumanEval_119,snd_Arab,rb,"مثال: جيڪڏهن ڪو سٺو اسٽرنگ ٺاهڻ جو طريقو آهي ته 'ها' موٽايو، ۽ ٻي صورت ۾ 'نه' موٽايو."" (()) "" نه آهي.مثال طور: اسٽرنگ '(()))) سٺي آهي، جڏهن ته اسٽرنگ هڪ اسٽرنگ S کي سٺو سمجهيو ويندو آهي جيڪڏهن ۽ صرف جيڪڏهن S ۾ سڀئي قوسين ڪجهه حڪم، ته نتيجي ۾ جملو سٺو ٿيندو.توهان جو ڪم اهو چيڪ ڪرڻ آهي ته ڇا اهو ممڪن آهي ته ٻن تارن کي گڏ ڪرڻ لاءِصرف قوسين ۾ "" (("") يا بند قوسين ۾ "") ""توهان کي ٻه اسٽرنگس جا آرري ڏنا ويا آهن، ٻئي اسٽرنگس اوپن تي مشتمل آهن.# >>> match_parens.call([""()("", "")""])
# ""Yes""
# >>> match_parens.call(["")"", "")""])
# ""No""
def match_parens(lst)
","def match_parens(lst)
  a, b = lst

  # Define a helper method to check if a string is balanced
  def balanced?(s)
    count = 0
    s.each_char do |c|
      count += 1 if c == '('
      count -= 1 if c == ')'
      return false if count < 0
    end
    count == 0
  end

  # Check if either concatenation forms a good string
  if balanced?(a + b) || balanced?(b + a)
    ""Yes""
  else
    ""No""
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_match_parens
    candidate = method(:match_parens)
    assert_equal(""Yes"", candidate.call([""()("", "")""]))
    assert_equal(""No"", candidate.call(["")"", "")""]))
    assert_equal(""No"", candidate.call([""(()(())"", ""())())""]))
    assert_equal(""Yes"", candidate.call(["")())"", ""(()()(""]))
    assert_equal(""Yes"", candidate.call([""(())))"", ""(()())((""]))
    assert_equal(""No"", candidate.call([""()"", ""())""]))
    assert_equal(""Yes"", candidate.call([""(()("", ""()))()""]))
    assert_equal(""No"", candidate.call([""(((("", ""((())""]))
    assert_equal(""No"", candidate.call(["")(()"", ""(()(""]))
    assert_equal(""No"", candidate.call(["")("", "")(""]))
    assert_equal(""Yes"", candidate.call([""("", "")""]))
    assert_equal(""Yes"", candidate.call(["")"", ""(""]))
  end
end
"
HumanEval_120,snd_Arab,rb,"مثال 1: ڊيگهه k جي وڌ ۾ وڌ k نمبرن سان آر آر ۾.هڪ صف arr ڏنل آهي انٽيگرز ۽ هڪ مثبت انٽيگر k، هڪ ترتيب ڏنل صف موٽايو # >>> maximum.call([-3, -4, 5], 3)
# [-4, -3, 5]
# Example 2:
# >>> maximum.call([4, -4, 4], 2)
# [4, 4]
# Example 3:
# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)
# [2]
# Note:
# 1. The length of the array will be in the range of [1, 1000].
# 2. The elements in the array will be in the range of [-1000, 1000].
# 3. 0 <= k <= len(arr)
def maximum(arr, k)
","def maximum(arr, k)
  arr.sort.last(k).sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_maximum
    candidate = method(:maximum)
    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))
    assert_equal([4, 4], candidate.call([4, -4, 4], 2))
    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))
    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))
    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))
    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))
    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))
    assert_equal([5], candidate.call([1, 0, 5, -7], 1))
    assert_equal([-4, 4], candidate.call([4, -4], 2))
    assert_equal([-10, 10], candidate.call([-10, 10], 2))
    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))
  end
end
"
HumanEval_121,snd_Arab,rb,"مثال عدد جي هڪ غير خالي صف ڏني، سڀني جي جوڙ جو مجموعو ته به موقف ۾ آهن موٽي. # >>> solution.call([5, 8, 7, 1])
# 12
# >>> solution.call([3, 3, 3, 3, 3])
# 9
# >>> solution.call([30, 13, 24, 321])
# 0
def solution(lst)
","def solution(lst)
  lst.each_with_index.reduce(0) do |sum, (val, idx)|
    (idx.even? && val.odd?) ? sum + val : sum
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solution
    candidate = method(:solution)
    assert_equal(12, candidate.call([5, 8, 7, 1]))
    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))
    assert_equal(0, candidate.call([30, 13, 24, 321]))
    assert_equal(5, candidate.call([5, 9]))
    assert_equal(0, candidate.call([2, 4, 8]))
    assert_equal(23, candidate.call([30, 13, 23, 32]))
    assert_equal(3, candidate.call([3, 13, 2, 9]))
  end
end
"
HumanEval_122,snd_Arab,rb,"مثال: arr جي پهرين k عنصرن کان وڌ ۾ وڌ ٻن انگن سان عنصرن جو مجموعو. آر آر جي هڪ غير خالي صف ۽ هڪ انٽيگر k ڏنو ويو آهي ، واپسي # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
# 24
# Constraints:
# 1. 1 <= len(arr) <= 100
# 2. 1 <= k <= len(arr)
def add_elements(arr, k)
","def add_elements(arr, k)
  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_add_elements
    candidate = method(:add_elements)
    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))
    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))
    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))
    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))
    assert_equal(1, candidate.call([1], 1))
  end
end
"
HumanEval_123,snd_Arab,rb,"get_odd_collatz(5) موٽائي ٿو [1, 5] # 5 لاءِ ڪولٽز تسلسل [5, 16, 8, 4, 2, 1] آهي، تنهنڪري انڊو نمبر صرف 1 ۽ 5 آهن. مثال طور: 2. موٽيل صف وڌندڙ ترتيب ۾ ترتيب ڏنل.1. ڪولٽز ((1) [1] آهي.نوٽ:اصطلاح جمع 1. اندازو آهي ته n جي ڪهڙي به قدر هجي، اهو تسلسل هميشه 1 تائين پهچندو.جيڪڏهن پوئين اصطلاح ڌار آهي، ته ايندڙ اصطلاح پوئين اصطلاح جي 3 ڀيرا آهي.پوئين اصطلاح جي طور تي: جيڪڏهن پوئين اصطلاح برابر آهي، ايندڙ اصطلاح  جو اڌ آهي.جيئن هيٺ ڏنل آهي: ڪنهن به مثبت انٽيگر n سان شروع ڪريو. پوءِ هر اصطلاح حاصل ڪيو ويندو آهي ڪولٽز جو گمان رياضي ۾ هڪ گمان آهي جيڪو هڪ تعريف ڪيل تسلسل سان تعلق رکي ٿو مثبت انٽيگر n ڏنو ويو، هڪ ترتيب ڏنل صف واپس ڪريو جنهن ۾ ڪولٽز تسلسل ۾ بي جوڙ نمبر آهن. # >>> get_odd_collatz.call(5)
# [1, 5]
def get_odd_collatz(n)
","def get_odd_collatz(n)
  collatz_sequence = []
  while n != 1
    collatz_sequence << n if n.odd?
    if n.even?
      n = n / 2
    else
      n = 3 * n + 1
    end
  end
  collatz_sequence << 1 if n == 1

  collatz_sequence.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_odd_collatz
    candidate = method(:get_odd_collatz)
    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))
    assert_equal([1, 5], candidate.call(5))
    assert_equal([1, 3, 5], candidate.call(12))
    assert_equal([1], candidate.call(1))
  end
end
"
HumanEval_124,snd_Arab,rb,"4. تاريخ جي فارميٽ ۾ هجڻ گهرجي: ايم ايم ڊي اي اي اي اي.3. مهينن جو تعداد 1 کان گهٽ ۽ 12 کان وڌيڪ نه هجڻ گهرجي.2. ڏينهن جو تعداد مهينن 1,3,5,7,8,10,12 لاء 1 کان گهٽ يا 31 ڏينهن کان وڌيڪ نه آهي. ۽ ڏينهن جو تعداد مهينن 4,6,9,11 لاء 1 کان گهٽ يا 30 ڏينهن کان وڌيڪ نه آهي. ۽، ڏينهن جو تعداد مهيني 2 لاء 1 کان گهٽ يا 29 کان وڌيڪ نه آهي.1. تاريخ جي تار خالي نه آهي.تاريخ صحيح آهي جيڪڏهن هيٺين سڀني قاعدن کي پورو ڪيو وڃي: جيڪڏهن تاريخ صحيح آهي ته پوءِ صحيح موٽائي ٻي صورت ۾ غلط.توهان هڪ فعل جنهن هڪ ڏنو تاريخ سلسلو validates لکڻ آهي ۽ # >>> valid_date.call(""03-11-2000"")
# true
# >>> valid_date.call(""15-01-2012"")
# false
# >>> valid_date.call(""04-0-2040"")
# false
# >>> valid_date.call(""06-04-2020"")
# true
# >>> valid_date.call(""06/04/2020"")
# false
def valid_date(date)
","def valid_date(date)
  return false if date.nil? || date.empty?
  
  # Check if the date format is correct
  match = date.match(/^(\d{2})-(\d{2})-(\d{4})$/)
  return false unless match
  
  month, day, year = match.captures.map(&:to_i)
  
  # Check if month is valid
  return false if month < 1 || month > 12
  
  # Check if day is valid according to the month
  case month
  when 1, 3, 5, 7, 8, 10, 12
    return day >= 1 && day <= 31
  when 4, 6, 9, 11
    return day >= 1 && day <= 30
  when 2
    return day >= 1 && day <= 29
  else
    return false
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_valid_date
    candidate = method(:valid_date)
    assert_equal(true, candidate.call(""03-11-2000""))
    assert_equal(false, candidate.call(""15-01-2012""))
    assert_equal(false, candidate.call(""04-0-2040""))
    assert_equal(true, candidate.call(""06-04-2020""))
    assert_equal(true, candidate.call(""01-01-2007""))
    assert_equal(false, candidate.call(""03-32-2011""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""04-31-3000""))
    assert_equal(true, candidate.call(""06-06-2005""))
    assert_equal(false, candidate.call(""21-31-2000""))
    assert_equal(true, candidate.call(""04-12-2003""))
    assert_equal(false, candidate.call(""04122003""))
    assert_equal(false, candidate.call(""20030412""))
    assert_equal(false, candidate.call(""2003-04""))
    assert_equal(false, candidate.call(""2003-04-12""))
    assert_equal(false, candidate.call(""04-2003""))
  end
end
"
HumanEval_125,snd_Arab,rb,"مثال الفابيٽ ، آرڊ (a) = 0 ، آرڊ (b) = 1 ، . . . آرڊ (z) = 25 commas تي ورهايو وڃي ',' جيڪڏهن ڪو commas موجود نه آهي توهان کي  ۾ اڻ وڻندڙ حڪم سان ننڍي اکرن جو تعداد موٽڻ گهرجيلفظن جي هڪ سلسلي ڏني، لفظن جي هڪ صف واپس وائيٽ اسپيس تي ورهايو، جيڪڏهن ڪو وائيٽ اسپيس موجود نه آهي ته توهان جي متن ۾ # >>> split_words.call(""Hello world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""Hello,world!"")
# [""Hello"", ""world!""]
# >>> split_words.call(""abcdef"")
# 3
def split_words(txt)
","def split_words(txt)
  if txt.include?(' ')
    return txt.split(' ')
  elsif txt.include?(',')
    return txt.split(',')
  else
    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }
    return odd_count
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_split_words
    candidate = method(:split_words)
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello world!""))
    assert_equal([""Hello"", ""world!""], candidate.call(""Hello,world!""))
    assert_equal([""Hello"", ""world,!""], candidate.call(""Hello world,!""))
    assert_equal([""Hello,Hello,world"", ""!""], candidate.call(""Hello,Hello,world !""))
    assert_equal(3, candidate.call(""abcdef""))
    assert_equal(2, candidate.call(""aaabb""))
    assert_equal(1, candidate.call(""aaaBb""))
    assert_equal(0, candidate.call(""""))
  end
end
"
HumanEval_126,snd_Arab,rb,"مثال نمبر، غلط موٽايو. ڪو منفي نمبر ۽ صرف انٽيگرز فرض ڪريو.جيڪڏهن صف ۾ هڪ کان وڌيڪ ڊپليڪٽ آهن ته ساڳي ئي ترتيب ۾.نمبرن جي صف ڏني وئي، واپس ڪريو ته اهي ترتيب ڏنل آهن يا نه.# >>> is_sorted.call([5])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5])
# false
# >>> is_sorted.call([1, 2, 3, 4, 5, 6])
# true
# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])
# true
# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])
# false
# >>> is_sorted.call([1, 2, 2, 3, 3, 4])
# true
# >>> is_sorted.call([1, 2, 2, 2, 3, 4])
# false
def is_sorted(lst)
","def is_sorted(lst)
  lst.each_cons(2).with_index do |(a, b), index|
    return false if a > b
    return false if index < lst.length - 2 && a == b && lst[index + 2] == b
  end
  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_sorted
    candidate = method(:is_sorted)
    assert_equal(true, candidate.call([5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))
    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))
    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))
    assert_equal(true, candidate.call([]))
    assert_equal(true, candidate.call([1]))
    assert_equal(false, candidate.call([3, 2, 1]))
    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))
    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))
    assert_equal(true, candidate.call([1, 2, 3, 4]))
  end
end
"
HumanEval_127,snd_Arab,rb,"[انپٽ / آئوٽ] نموني: جيڪڏهن ٻه وقفو نه ٿا ڪن، ""نه"" موٽايو.ٻي صورت ۾ ""نه"" موٽايو.جيڪڏهن انٽرسائيٽ جي ڊيگهه هڪ پرائم نمبر آهي، موٽ ""YES""جنهن جي ڊيگهه 1 آهي، جيڪو ڪو پرائم نمبر نه آهي.مثال طور، وقتي جي وچ ۾ (1, 3), (2, 4) (2, 3) آهي.وقتي هڪ پرائم نمبر آهي.توهان جو ڪم اهو طئي ڪرڻ آهي ته انهن ٻن جي وچ واري ڊيگهه هر هڪ مقرر ڪيل وقفي لاءِ اهو فرض ڪيو ويندو آهي ته ان جي شروعات ان جي آخر کان گهٽ يا برابر آهي.شروع ۽ ختم ٻئي شامل آهن.ڏنل وقفو بند ٿيل آهي جنهن جو مطلب آهي ته وقفو (شروع ، ختم) جتي هر وقفو عدد جو هڪ جوڙو آهي. مثال طور، وقفو = (شروع، آخر) = (1, 2).اوهان کي ٻه وقت ڏنا ويا آهن،# >>> intersection.call([1, 2], [2, 3])
# ""NO""
# >>> intersection.call([-1, 1], [0, 4])
# ""NO""
# >>> intersection.call([-3, -1], [-5, 5])
# ""YES""
def intersection(interval1, interval2)
","def intersection(interval1, interval2)
  start1, end1 = interval1
  start2, end2 = interval2

  intersection_start = [start1, start2].max
  intersection_end = [end1, end2].min

  if intersection_start > intersection_end
    return ""NO""
  end

  intersection_length = intersection_end - intersection_start + 1

  return ""YES"" if prime?(intersection_length)

  ""NO""
end

def prime?(n)
  return false if n <= 1
  return true if n == 2 || n == 3

  (2..Math.sqrt(n).to_i).each do |i|
    return false if n % i == 0
  end

  true
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_intersection
    candidate = method(:intersection)
    assert_equal(""NO"", candidate.call([1, 2], [2, 3]))
    assert_equal(""NO"", candidate.call([-1, 1], [0, 4]))
    assert_equal(""YES"", candidate.call([-3, -1], [-5, 5]))
    assert_equal(""YES"", candidate.call([-2, 2], [-4, 0]))
    assert_equal(""NO"", candidate.call([-11, 2], [-1, -1]))
    assert_equal(""NO"", candidate.call([1, 2], [3, 5]))
    assert_equal(""NO"", candidate.call([1, 2], [1, 2]))
    assert_equal(""NO"", candidate.call([-2, -2], [-3, -2]))
  end
end
"
HumanEval_128,snd_Arab,rb,"مثال: نوٽ: خالي آر آر لاءِ نيل موٽايو.صف ۾ هر نمبر جي نمائندگي 1، -1 يا 0 سان ڪئي وئي آهي.انٽيگرز جي مقدار جو مجموعو سڀني نشانين جي پيداوار سان ضرب ڪيو ويو آهي توهان کي انٽيگرز جي هڪ صف ڏني وئي آهي ۽ توهان کي واپس اچڻ جي ضرورت آهي# >>> prod_signs.call([1, 2, 2, -4])
# 9
# >>> prod_signs.call([0, 1])
# 0
# >>> prod_signs.call([])
# nil
def prod_signs(arr)
","def prod_signs(arr)
  return nil if arr.empty?
  
  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }
  sum_magnitudes = arr.map(&:abs).sum
  
  product_signs * sum_magnitudes
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_prod_signs
    candidate = method(:prod_signs)
    assert_equal(-9, candidate.call([1, 2, 2, -4]))
    assert_equal(0, candidate.call([0, 1]))
    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))
    assert_equal(nil, candidate.call([]))
    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))
    assert_equal(4, candidate.call([-1, 1, -1, 1]))
    assert_equal(-4, candidate.call([-1, 1, 1, 1]))
    assert_equal(0, candidate.call([-1, 1, 1, 0]))
  end
end
"
HumanEval_129,snd_Arab,rb,"مثال: جي خاني جي قدرن جي هڪ ترتيب واري صف واپس ڪري ٿو جنهن جي ذريعي گهٽ ۾ گهٽ رستو گذري ٿو.ان جو جواب يقيني طور تي منفرد آهي.lst_A[j] = lst_B[j] جيئن ته lst_A[i] < lst_B[i] ۽ ڪنهن به j (1 <= j <i) لاءِ اسان وٽ آهي lst_B کان ، ٻين لفظن ۾ ، هڪ انٽيگر انڊيڪس موجود آهي i (1 <= i <= k) جي ذريعي (اسان انهن کي lst_A ۽ lst_B سڏينداسين) ، lst_A lexicographically گهٽ آهي جي ordered arrays ٺاهڻ کان پوء جي خاني تي قدر آهي ته هڪ ۽ ب وڃڻ هڪ رستو A (ڊيگهه k) هڪ رستو B (ڊيگهه k) کان ننڍو سمجهيو ويندو آهي جيڪڏهن توهان گرڊ کان ٻاهر نه ٿا ڪري سگهو.ضروري طور تي ڌار ڌار).مهرباني ڪري نوٽ ڪريو ته ڊيگهه k جي رستي جو مطلب آهي ته بلڪل k خاني جو دورو ڪيو وڃي (نه موبائل فونٻين لفظن ۾، توهان خانا جنهن کي توهان جي موجوده سان هڪ برتري حصيداري ڏانهن رخ ڪري سگهن ٿا ڪنهن به سيل کان، ۽ هر قدم ۾ توهان کي پاڙيسري خاني جي ڪنهن به کي منتقل ڪري سگهو ٿا، توهان کي گهٽ ۾ گهٽ رستو ڳولڻو آهي ڊيگهه k گرڊ ۾. توهان شروع ڪري سگهو ٿا شامل ٿيل گرڊ جي خاني تي بلڪل هڪ ڀيرو ظاهر ٿئي ٿو. گرڊ جي هر خاني ۾ هڪ قدر آهي. [1، N * N] جي حد ۾ هر انٽيگر.N قطار ۽ N ڪالمن سان هڪ گرڊ ڏنو ويو آهي (N >= 2) ۽ هڪ مثبت انٽيگر k ، # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
# [1, 2, 1]
# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
# [1]
def minPath(grid, k)
","def minPath(grid, k)
  n = grid.size
  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  min_path = nil

  n.times do |i|
    n.times do |j|
      queue = [[[i, j], [grid[i][j]]]]
      until queue.empty?
        position, path = queue.shift
        if path.size == k
          min_path = path if min_path.nil? || path < min_path
          next
        end
        directions.each do |dx, dy|
          x, y = position[0] + dx, position[1] + dy
          if x.between?(0, n-1) && y.between?(0, n-1)
            queue.push([[x, y], path + [grid[x][y]]])
          end
        end
      end
    end
  end
  min_path
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_minPath
    candidate = method(:minPath)
    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))
    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))
    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))
    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))
    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))
    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))
    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))
    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))
    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))
  end
end
"
HumanEval_130,snd_Arab,rb,"مثال: ٽربونڪي تسلسل جي پهرين n + 1 نمبرن. توهان کي هڪ غير منفي عدد نمبر n ڏنو ويو آهي، توهان کي هڪ صف موٽائڻي آهي= 2 + 3 + 3 = 8 ٽريٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽيٽري ((4) = 3 ٽري ((2) = 1 + (2 / 2) = 2 مثال طور: ٽري (ن) = ٽري (ن - 1) + ٽري (ن - 2) + ٽري (ن + 1) ، جيڪڏهن ن ڌار آهي.tri (n) = 1 + n / 2، جيڪڏهن n جوڙو آهي.ٽري ((1) = 3 ٽربونڪي تسلسل جي تعريف ڪئي وئي آهي: پر، جيڪي ماڻهو نٿا ڄاڻن، اهي ٽربونڪي تسلسل آهن.هرڪو فبوناچي تسلسل کي knowsاڻي ٿو ، اهو گهيري ۾ رياضي دانن پاران مطالعو ڪيو ويو هو# >>> tri.call(3)
# [1, 3, 2, 8]
def tri(n)
","def tri(n)
  sequence = [1, 3]
  
  (2..n).each do |i|
    if i.even?
      sequence[i] = 1 + i / 2
    else
      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0
    end
  end
  
  sequence[0..n]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_tri
    candidate = method(:tri)
    assert_equal([1, 3, 2, 8], candidate.call(3))
    assert_equal([1, 3, 2, 8, 3], candidate.call(4))
    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))
    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))
    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))
    assert_equal([1], candidate.call(0))
    assert_equal([1, 3], candidate.call(1))
  end
end
"
HumanEval_131,snd_Arab,rb,"مثال طور: 0 واپس ڪريو جيڪڏهن سڀئي عدد برابر آهن. مثبت عدد n ڏنو وڃي، انڊيڪس جي غير متوازن انگن جي پيداوار واپس ڪريو.# >>> digits.call(1)
# 1
# >>> digits.call(4)
# 0
# >>> digits.call(235)
# 15
def digits(n)
","def digits(n)
  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }
  return 0 if odd_digits.empty?
  odd_digits.reduce(:*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_digits
    candidate = method(:digits)
    assert_equal(5, candidate.call(5))
    assert_equal(5, candidate.call(54))
    assert_equal(1, candidate.call(120))
    assert_equal(5, candidate.call(5014))
    assert_equal(315, candidate.call(98765))
    assert_equal(2625, candidate.call(5576543))
    assert_equal(0, candidate.call(2468))
  end
end
"
HumanEval_132,snd_Arab,rb,"جتي گهٽ ۾ گهٽ هڪ bracket جي subsequence ۾ nested آهي. فنڪشن کي موٽڻ گهرجي سچ جيڪڏهن ۽ صرف جيڪڏهن قوسين جو هڪ صحيح ذيلي تسلسل آهي هڪ فنڪشن ٺاهيو جيڪو ان پٽ جي طور تي هڪ اسٽرنگ وٺي ٿو جنهن ۾ صرف چورس قوسين شامل آهن.# >>> is_nested.call(""[[]]"")
# true
# >>> is_nested.call(""[]]]]]]][[[[[]"")
# false
# >>> is_nested.call(""[][]"")
# false
# >>> is_nested.call(""[]"")
# false
# >>> is_nested.call(""[[][]]"")
# true
# >>> is_nested.call(""[[]][["")
# true
def is_nested(string)
","def is_nested(string)
  stack = []
  has_nested = false

  string.each_char do |char|
    if char == '['
      stack.push(char)
    elsif char == ']'
      if stack.empty?
        return false
      end
      stack.pop
      has_nested = true if stack.any?
    end
  end

  has_nested
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_nested
    candidate = method(:is_nested)
    assert_equal(true, candidate.call(""[[]]""))
    assert_equal(false, candidate.call(""[]]]]]]][[[[[]""))
    assert_equal(false, candidate.call(""[][]""))
    assert_equal(false, candidate.call(""[]""))
    assert_equal(true, candidate.call(""[[[[]]]]""))
    assert_equal(false, candidate.call(""[]]]]]]]]]]""))
    assert_equal(true, candidate.call(""[][][[]]""))
    assert_equal(false, candidate.call(""[[]""))
    assert_equal(false, candidate.call(""[]]""))
    assert_equal(true, candidate.call(""[[]][[""))
    assert_equal(true, candidate.call(""[[][]]""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""[[[[[[[[""))
    assert_equal(false, candidate.call(""]]]]]]]]""))
  end
end
"
HumanEval_133,snd_Arab,rb,"مثال: هر عنصر کي صف ۾ چوٿين نمبر تي چڪاس ڪريو.توهان کي ڏنل صف ۾ نمبرز جي چوڪ جو مجموعو موٽائڻ جي ضرورت آهي، توھان کي نمبرن جو هڪ سلسلو ڏنو ويو آھي.# >>> lst.call([1.0, 2.0, 3.0])
# 14
# >>> lst.call([1.0, 4.0, 9.0])
# 98
# >>> lst.call([1.0, 3.0, 5.0, 7.0])
# 84
# >>> lst.call([1.4, 4.2, 0.0])
# 29
# >>> lst.call([-2.4, 1.0, 1.0])
# 6
def sum_squares(lst)
","def sum_squares(lst)
  lst.map { |num| (num.ceil)**2 }.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))
    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))
    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))
    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))
    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))
    assert_equal(200000000, candidate.call([10000.0, 10000.0]))
    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))
    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))
    assert_equal(0, candidate.call([0.0]))
    assert_equal(1, candidate.call([-1.0]))
    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))
  end
end
"
HumanEval_134,snd_Arab,rb,"مثال: نوٽ: ""لفظ"" اکرن جو هڪ گروپ آهي جيڪو خلا سان ڌار ٿيل آهي.لفظن جو حصو آهي ۽ ٻي صورت ۾ غلط آهي.هڪ ڏنل اسٽرنگ جو الفابيٽ وارو ڪردار آهي ۽ نه آهيهڪ فنڪشن ٺاهيو جيڪو سچو موٽائي ٿو جيڪڏهن آخري ڪردار # >>> check_if_last_char_is_a_letter.call(""apple pie"")
# false
# >>> check_if_last_char_is_a_letter.call(""apple pi e"")
# true
# >>> check_if_last_char_is_a_letter.call(""apple pi e "")
# false
# >>> check_if_last_char_is_a_letter.call("""")
# false
def check_if_last_char_is_a_letter(txt)
","check_if_last_char_is_a_letter = ->(txt) {
  return false if txt.strip.empty?
  words = txt.strip.split(' ')
  last_word = words.last
  return false if last_word.empty?
  last_char = last_word[-1]

  last_char =~ /[a-zA-Z]/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')
}","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_check_if_last_char_is_a_letter
    candidate = method(:check_if_last_char_is_a_letter)
    assert_equal(false, candidate.call(""apple""))
    assert_equal(true, candidate.call(""apple pi e""))
    assert_equal(false, candidate.call(""eeeee""))
    assert_equal(true, candidate.call(""A""))
    assert_equal(false, candidate.call(""Pumpkin pie ""))
    assert_equal(false, candidate.call(""Pumpkin pie 1""))
    assert_equal(false, candidate.call(""""))
    assert_equal(false, candidate.call(""eeeee e ""))
    assert_equal(false, candidate.call(""apple pie""))
    assert_equal(false, candidate.call(""apple pi e ""))
  end
end
"
HumanEval_135,snd_Arab,rb,"مثال: ٻيڻو قدر.اھڙو ڪوبه عنصر موجود نه آھي ته پوءِ واپسي -1. ڏنل صف ۾ شامل نه ٿيندو کان وڏو يا برابر نه آهي ته ان کي فوري طور تي ان کان اڳ عنصر آهي. جيڪڏهن هڪ فنڪشن ٺاهيو جيڪو هڪ عنصر جو سڀ کان وڏو انڊيڪس موٽائي ٿو جيڪو # >>> can_arrange.call([1, 2, 4, 3, 5])
# 3
# >>> can_arrange.call([1, 2, 3])
# -1
def can_arrange(arr)
","def can_arrange(arr)
  (1...arr.length).reverse_each do |i|
    return i if arr[i] < arr[i - 1]
  end
  -1
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_can_arrange
    candidate = method(:can_arrange)
    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))
    assert_equal(-1, candidate.call([1, 2, 4, 5]))
    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))
    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))
    assert_equal(-1, candidate.call([]))
  end
end
"
HumanEval_136,snd_Arab,rb,"مثال: جيڪڏهن ڪو منفي يا مثبت عدد نه آهي ته انهن کي نيل طور موٽايو.هڪ صف ۾ مثبت انٽيگرز جي. سڀ کان وڏو منفي عدد آهي، ۽ ""ب"" سڀ کان ننڍو آهي.هڪ فنڪشن ٺاهيو جيڪو هڪ صف (a، b) موٽائي ٿو، جتي 'a' آهي# >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])
# [nil, 1]
# >>> largest_smallest_integers.call([])
# [nil, nil]
# >>> largest_smallest_integers.call([0])
# [nil, nil]
def largest_smallest_integers(lst)
","def largest_smallest_integers(lst)
  largest_negative = nil
  smallest_positive = nil
  
  lst.each do |num|
    if num < 0
      largest_negative = num if largest_negative.nil? || num > largest_negative
    elsif num > 0
      smallest_positive = num if smallest_positive.nil? || num < smallest_positive
    end
  end
  
  [largest_negative, smallest_positive]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_largest_smallest_integers
    candidate = method(:largest_smallest_integers)
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))
    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))
    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))
    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))
    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))
    assert_equal([nil, nil], candidate.call([]))
    assert_equal([nil, nil], candidate.call([0]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))
    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))
    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))
  end
end
"
HumanEval_137,snd_Arab,rb,"نوٽ: جيڪڏهن هڪ حقيقي نمبر هڪ تار جي طور تي نمائندگي ڪيو ويندو آهي، سچل نقطو ٿي سگهي ٿو . يا ، جيڪڏهن قدر برابر آهن ته نيل موٽايو. حقيقي انگن، ۽ ان جي ڏنو variable قسم ۾ وڏي variable موٽي. هڪ فنڪشن ٺاهيو جيڪو انٽيگرز، فلوٽس، يا اسٽرنگز کي نمائندگي ڪري ٿو# >>> compare_one.call(1, 2.5)
# 2.5
# >>> compare_one.call(1, ""2,3"")
# ""2,3""
# >>> compare_one.call(""5,1"", ""6"")
# ""6""
# >>> compare_one.call(""1"", 1)
# nil
def compare_one(a, b)
","def compare_one(a, b)
  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')
  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')

  if a.is_a?(String) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Float)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(Float)
    a = a.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(Integer)
    b = b.to_f
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Float)
    b = b.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Float) && b.is_a?(String)
    a = a.to_s # Only supporting variable type comparison, retain original types
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(String) && b.is_a?(Integer)
    return nil if a == b
    return a > b ? a : b
  elsif a.is_a?(Integer) && b.is_a?(String)
    return nil if a == b
    return a > b ? a : b
  else
    return nil
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare_one
    candidate = method(:compare_one)
    assert_equal(2, candidate.call(1, 2))
    assert_equal(2.5, candidate.call(1, 2.5))
    assert_equal(3, candidate.call(2, 3))
    assert_equal(6, candidate.call(5, 6))
    assert_equal(""2,3"", candidate.call(1, ""2,3""))
    assert_equal(""6"", candidate.call(""5,1"", ""6""))
    assert_equal(""2"", candidate.call(""1"", ""2""))
    assert_equal(nil, candidate.call(""1"", 1))
  end
end
"
HumanEval_138,snd_Arab,rb,"مثال اندازو لڳايو ته ڇا ڏنل نمبر n کي صحيح طور تي 4 مثبت نمبرن جي مجموعي طور لکي سگهجي ٿو # >>> is_equal_to_sum_even.call(4)
# false
# >>> is_equal_to_sum_even.call(6)
# false
# >>> is_equal_to_sum_even.call(8)
# true
def is_equal_to_sum_even(n)
","def is_equal_to_sum_even(n)
  return false if n < 8
  n.even?
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_is_equal_to_sum_even
    candidate = method(:is_equal_to_sum_even)
    assert_equal(false, candidate.call(4))
    assert_equal(false, candidate.call(6))
    assert_equal(true, candidate.call(8))
    assert_equal(true, candidate.call(10))
    assert_equal(false, candidate.call(11))
    assert_equal(true, candidate.call(12))
    assert_equal(false, candidate.call(13))
    assert_equal(true, candidate.call(16))
  end
end
"
HumanEval_139,snd_Arab,rb,"مثال طور: جتي n > 0 برازيلي_فيڪٽوريل ((ن) = ن! * (ن - 1)! * (ن - 2))! * . . . * 1! برازيل جي فئڪٽريئر جي تعريف ڪئي وئي آهي: # >>> special_factorial.call(4)
# 288
# The function will receive an integer as input and should return the special
# factorial of this integer.
def special_factorial(n)
","def special_factorial(n)
  return 1 if n <= 1
  (1..n).inject(1) { |product, i| product * factorial(i) }
end

def factorial(num)
  return 1 if num <= 1
  (2..num).inject(1, :*)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_special_factorial
    candidate = method(:special_factorial)
    assert_equal(288, candidate.call(4))
    assert_equal(34560, candidate.call(5))
    assert_equal(125411328000, candidate.call(7))
    assert_equal(1, candidate.call(1))
  end
end
"
HumanEval_140,snd_Arab,rb,"پوءِ سڀني لڳاتار جڳهن کي -  سان تبديل ڪريو.۽ جيڪڏهن هڪ تار کان وڌيڪ 2 لڳاتار خال ڪئي آهي، هڪ متن جي تار ڏني، ان ۾ سڀني خال underscores سان مٽائي، # >>> fix_spaces.call("" Example"")
# ""Example""
# >>> fix_spaces.call("" Example 1"")
# ""Example_1""
# >>> fix_spaces.call("" Example 2"")
# ""_Example_2""
# >>> fix_spaces.call("" Example 3"")
# ""_Example-3""
def fix_spaces(text)
","def fix_spaces(text)
  text.strip.gsub(/\s{3,}/, '-').gsub(' ', '_')
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_fix_spaces
    candidate = method(:fix_spaces)
    assert_equal(""Example"", candidate.call(""Example""))
    assert_equal(""Mudasir_Hanif_"", candidate.call(""Mudasir Hanif ""))
    assert_equal(""Yellow_Yellow__Dirty__Fellow"", candidate.call(""Yellow Yellow  Dirty  Fellow""))
    assert_equal(""Exa-mple"", candidate.call(""Exa   mple""))
    assert_equal(""-Exa_1_2_2_mple"", candidate.call(""   Exa 1 2 2 mple""))
  end
end
"
HumanEval_141,snd_Arab,rb,"مثال: - هن نقطي کان پوء جي substring انهن مان هڪ ٿي وڃي: ['txt'، 'exe'، 'dll'] لاطيني الفابيٽ ('a'-'z' ۽ 'A'-'Z').- هن نقطي کان اڳ جي substring خالي نه هجڻ گهرجي، ۽ ان کي هڪ اکر کان شروع ٿئي ٿو - فائل جو نالو بلڪل هڪ نقطو '.' تي مشتمل آهي.- فائل جي نالي ۾ ٽن کان وڌيڪ انگ اکر نه هجڻ گهرجن ('0'-'9')ملن ٿا: هڪ فائل جو نالو صحيح سمجهيو ويندو آهي جيڪڏهن ۽ صرف جيڪڏهن هيٺ ڏنل سڀني شرطن تي پورا لهن 'ها' جيڪڏهن فائل جو نالو صحيح آهي، ۽ ٻي صورت ۾ 'نه' موٽائي ٿو.هڪ فنڪشن ٺاهيو جيڪو هڪ فائل جو نالو ظاهر ڪري ٿو ۽ واپسي # >>> file_name_check.call(""example.txt"")
# ""Yes""
# >>> file_name_check.call(""1example.dll"")
# ""No""
def file_name_check(file_name)
","def file_name_check(file_name)
  # Check if there's exactly one dot in the filename
  return 'No' unless file_name.count('.') == 1
  
  # Split the filename into the name and extension
  name, extension = file_name.split('.')
  
  # Check if the name part starts with a letter
  return 'No' if name.empty? || !name[0].match?(/[a-zA-Z]/)
  
  # Check if the extension is valid
  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)
  
  # Count digits in the file name
  digit_count = file_name.count(""0-9"")
  
  # Check if digits are more than three
  return 'No' if digit_count > 3
  
  'Yes'
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_file_name_check
    candidate = method(:file_name_check)
    assert_equal(""Yes"", candidate.call(""example.txt""))
    assert_equal(""No"", candidate.call(""1example.dll""))
    assert_equal(""No"", candidate.call(""s1sdf3.asd""))
    assert_equal(""Yes"", candidate.call(""K.dll""))
    assert_equal(""Yes"", candidate.call(""MY16FILE3.exe""))
    assert_equal(""No"", candidate.call(""His12FILE94.exe""))
    assert_equal(""No"", candidate.call(""_Y.txt""))
    assert_equal(""No"", candidate.call(""?aREYA.exe""))
    assert_equal(""No"", candidate.call(""/this_is_valid.dll""))
    assert_equal(""No"", candidate.call(""this_is_valid.wow""))
    assert_equal(""Yes"", candidate.call(""this_is_valid.txt""))
    assert_equal(""No"", candidate.call(""this_is_valid.txtexe""))
    assert_equal(""No"", candidate.call(""#this2_i4s_5valid.ten""))
    assert_equal(""No"", candidate.call(""@this1_is6_valid.exe""))
    assert_equal(""No"", candidate.call(""this_is_12valid.6exe4.txt""))
    assert_equal(""No"", candidate.call(""all.exe.txt""))
    assert_equal(""Yes"", candidate.call(""I563_No.exe""))
    assert_equal(""Yes"", candidate.call(""Is3youfault.txt""))
    assert_equal(""Yes"", candidate.call(""no_one#knows.dll""))
    assert_equal(""No"", candidate.call(""1I563_Yes3.exe""))
    assert_equal(""No"", candidate.call(""I563_Yes3.txtt""))
    assert_equal(""No"", candidate.call(""final..txt""))
    assert_equal(""No"", candidate.call(""final132""))
    assert_equal(""No"", candidate.call(""_f4indsartal132.""))
    assert_equal(""No"", candidate.call("".txt""))
    assert_equal(""No"", candidate.call(""s.""))
  end
end
"
HumanEval_142,snd_Arab,rb,"مثال: آرري ۾ انٽري تبديل ڪريو جن جا انڊيڪس 3 يا 4 جا ضرب نه آهن. فنڪشن وري سڀني انٽري جو مجموعو موٽائيندو.3 جو گھڻو ۽ انٽيگر انٽري کي ڪوب ڪندو جيڪڏهن ان جو انڊيڪس 4 جو گھڻو ۽ 3 جو گھڻو نه هجي. فنڪشن نه ڪندو هي فنڪشن انٽيگرز جي هڪ صف وٺي ويندي. صف ۾ سڀني داخلائن لاءِ ، فنڪشن انٽيگر داخلا کي چوڪيندو جيڪڏهن ان جو انڊيڪس هڪ آهي."" # >>> lst
# [1, 2, 3]
# >>> lst
# []
# >>> lst
# [-1, -5, 2, -1, -5]
def sum_squares(lst)
","def sum_squares(lst)
  lst.map.with_index do |num, index|
    if index % 3 == 0
      num ** 2
    elsif index % 4 == 0
      num ** 3
    else
      num
    end
  end.sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sum_squares
    candidate = method(:sum_squares)
    assert_equal(6, candidate.call([1, 2, 3]))
    assert_equal(14, candidate.call([1, 4, 9]))
    assert_equal(0, candidate.call([]))
    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))
    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))
    assert_equal(0, candidate.call([0]))
    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))
    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))
    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))
    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))
    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))
  end
end
"
HumanEval_143,snd_Arab,rb,"مثال 1: لفظن جي ترتيب نئين اسٽرنگ ۾ اصل وانگر ساڳي هجڻ گهرجي.جن جي ڊيگهه پرائم نمبر آهن، ۽ توهان کي هڪ تار واپس ڪرڻو آهي جنهن ۾ اصل جملي جا لفظ شامل آهن، جملي ۾ ڪجھ لفظ آھن جيڪي ھڪ جڳھ سان جدا ٿيل آھن، توھان کي ھڪ جملو ظاھر ڪندڙ تار ڏنو ويو آھي،# >>> words_in_sentence.call(""This is a test"")
# ""is""
# Example 2:
# >>> words_in_sentence.call(""lets go for swimming"")
# ""go for""
# Constraints:
# * 1 <= len(sentence) <= 100
# * sentence contains only letters
def words_in_sentence(sentence)
","def words_in_sentence(sentence)
  def is_prime?(num)
    return false if num <= 1
    (2..Math.sqrt(num)).none? { |i| num % i == 0 }
  end
  
  words = sentence.split("" "")
  prime_length_words = words.select { |word| is_prime?(word.length) }
  prime_length_words.join("" "")
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_words_in_sentence
    candidate = method(:words_in_sentence)
    assert_equal(""is"", candidate.call(""This is a test""))
    assert_equal(""go for"", candidate.call(""lets go for swimming""))
    assert_equal(""there is no place"", candidate.call(""there is no place available here""))
    assert_equal(""Hi am Hussein"", candidate.call(""Hi I am Hussein""))
    assert_equal(""go for it"", candidate.call(""go for it""))
    assert_equal("""", candidate.call(""here""))
    assert_equal(""is"", candidate.call(""here is""))
  end
end
"
HumanEval_144,snd_Arab,rb,"توهان فرض ڪري سگھو ٿا ته x، ۽ n صحيح ڀاڱا آهن، ۽ انهن جو denominator صفر ناهي.<نومريٽر>/<ڊينومينٽر> جتي نيمريٽر ۽ ڊينومينٽر ٻئي مثبت عدد آهن.ٻي صورت ۾، x ۽ n، هڪ ڀاڱي جي اسٽرنگ نمائندگي آهي، ۽ هيٺين شڪل آهي،x * n. فنڪشن موٽائي ٿو سچو جيڪڏهن x * n هڪ پوري نمبر ۽ غلط جو جائزو وٺندو آهي توھان جو ڪم آھي ھڪڙي فنڪشن کي لاڳو ڪرڻ جيڪو اظهار کي آسان بڻائي ٿو # >>> simplify.call(""1/5"", ""5/1"")
# true
# >>> simplify.call(""1/6"", ""2/1"")
# false
# >>> simplify.call(""7/10"", ""10/2"")
# false
def simplify(x, n)
","def simplify(x, n)
  # Convert x and n to numerators and denominators
  num_x, den_x = x.split('/').map(&:to_i)
  num_n, den_n = n.split('/').map(&:to_i)

  # Multiply fractions: (num_x * num_n) / (den_x * den_n)
  numerator = num_x * num_n
  denominator = den_x * den_n

  # Check if the result is a whole number
  numerator % denominator == 0
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_simplify
    candidate = method(:simplify)
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/6"", ""2/1""))
    assert_equal(true, candidate.call(""5/1"", ""3/1""))
    assert_equal(false, candidate.call(""7/10"", ""10/2""))
    assert_equal(true, candidate.call(""2/10"", ""50/10""))
    assert_equal(true, candidate.call(""7/2"", ""4/2""))
    assert_equal(true, candidate.call(""11/6"", ""6/1""))
    assert_equal(false, candidate.call(""2/3"", ""5/2""))
    assert_equal(false, candidate.call(""5/2"", ""3/5""))
    assert_equal(true, candidate.call(""2/4"", ""8/4""))
    assert_equal(true, candidate.call(""2/4"", ""4/2""))
    assert_equal(true, candidate.call(""1/5"", ""5/1""))
    assert_equal(false, candidate.call(""1/5"", ""1/5""))
  end
end
"
HumanEval_145,snd_Arab,rb,"مثال طور: انهن کي اصل صف ۾ انڊيڪس جي بنياد تي ترتيب ڏيو.نوٽ: جيڪڏهن ڪيئي شيون آهن جن جي انگن جو مجموعو ساڳيو آهي، انهن جي انگن جي مجموعي مطابق عروج جي ترتيب ۾.هڪ فنڪشن لکو جيڪو ڏنل انٽيگرز جي صف کي ترتيب ڏئي ٿو# >>> order_by_points.call([1, 11, -1, -11, -12])
# [-1, -11, 1, -12, 11]
# >>> order_by_points.call([])
# []
def order_by_points(nums)
","def order_by_points(nums)
  nums.sort_by.with_index do |num, index|
    [num.to_s.chars.map(&:to_i).sum.abs, index]
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_order_by_points
    candidate = method(:order_by_points)
    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))
    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))
    assert_equal([], candidate.call([]))
    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))
    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))
    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))
  end
end
"
HumanEval_146,snd_Arab,rb,"مثال طور: هڪ نمبر جو پهريون ۽ آخري عدد اڻ ڳڻيو آهي (1, 3, 5, 7, 9).صف ۾ عنصرن جو تعداد جيڪي 10 کان وڌيڪ آهن ۽ ٻئي هڪ فنڪشن لکو جيڪو انگن جي صف کي ان پٽ ۽ واپسي جي طور تي وٺي ٿو# >>> specialFilter.call([15, -73, 14, -15])
# 1
# >>> specialFilter.call([33, -2, -3, 45, 21, 109])
# 2
def specialFilter(nums)
","def specialFilter(nums)
  nums.count do |num|
    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_specialFilter
    candidate = method(:specialFilter)
    assert_equal(0, candidate.call([5, -2, 1, -5]))
    assert_equal(1, candidate.call([15, -73, 14, -15]))
    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))
    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))
    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))
    assert_equal(0, candidate.call([1]))
    assert_equal(0, candidate.call([]))
  end
end
"
HumanEval_147,snd_Arab,rb,"مثال طور:۽ a[i] + a[j] + a[k] 3 جو ضرب آهي.a جي ٽرپل جي تعداد کي واپس ڪريو (a[i] ، a[j] ، a[k]) جتي i < j < k ، هر i (1 ≤ i ≤ n) لاءِ ، a[i] = i * i - i + 1 جي قيمت.توهان کي هڪ مثبت انٽيگر ڏنو ويو آهي n. توهان کي هڪ انٽيگر صف ٺاهي آهي ڊيگهه n جي.# >>> get_max_triples.call(5)
# 1
# Explanation: 
# a = [1, 3, 7, 13, 21]
# The only valid triple is (1, 7, 13).
def get_max_triples(n)
","def get_max_triples(n)
  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }
  count = 0
  
  (0...n).each do |i|
    (i+1...n).each do |j|
      (j+1...n).each do |k|
        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0
      end
    end
  end
  
  count
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_get_max_triples
    candidate = method(:get_max_triples)
    assert_equal(1, candidate.call(5))
    assert_equal(4, candidate.call(6))
    assert_equal(36, candidate.call(10))
    assert_equal(53361, candidate.call(100))
  end
end
"
HumanEval_148,snd_Arab,rb,"مثال سيارن جا صحيح نالا نه آهن.فعل کي هڪ خالي صف موٽڻ گهرجي جيڪڏهن planet1 يا planet2 سج جي ويجهو.Planet1 جي مدار ۽ Planet2 جي مدار جي وچ ۾ واقع آهي، ترتيب ڏنل آهيفنڪشن کي هڪ صف موٽائڻي آهي جنهن ۾ سڀ سيارو شامل آهن جن جي مدار آهن هڪ فنڪشن لکو جيڪو ٻه سيارو نالا وٺندو آهي جيئن ته تار planet1 ۽ planet2. يورينس، نيپچون.هي عطارد آهي، هيءُ زهره آهي، پوءِ زمين، مريخ، جپٽيئر، زحل،اسان جي شمسي نظام ۾ اٺ سيارو آهن: سج جي ويجهو سڀ کان ويجها .# >>> bf.call(""Jupiter"", ""Neptune"")
# [""Saturn"", ""Uranus""]
# >>> bf.call(""Earth"", ""Mercury"")
# ""Venus""
# >>> bf.call(""Mercury"", ""Uranus"")
# [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
def bf(planet1, planet2)
","def bf(planet1, planet2)
  planets = [""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""]
  
  idx1 = planets.index(planet1)
  idx2 = planets.index(planet2)
  
  return [] if idx1.nil? || idx2.nil?

  start_idx, end_idx = [idx1, idx2].sort
  
  planets[(start_idx + 1)...end_idx]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_bf
    candidate = method(:bf)
    assert_equal([""Saturn"", ""Uranus""], candidate.call(""Jupiter"", ""Neptune""))
    assert_equal([""Venus""], candidate.call(""Earth"", ""Mercury""))
    assert_equal([""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""], candidate.call(""Mercury"", ""Uranus""))
    assert_equal([""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""], candidate.call(""Neptune"", ""Venus""))
    assert_equal([], candidate.call(""Earth"", ""Earth""))
    assert_equal([], candidate.call(""Mars"", ""Earth""))
    assert_equal([], candidate.call(""Jupiter"", ""Makemake""))
  end
end
"
HumanEval_149,snd_Arab,rb,"مثال طور: توهان اهو سمجهي سگهو ٿا ته سڀئي لفظ هڪ ئي ڊيگهه وارا هوندا.فنڪشن کي ترتيب ڏنل ترتيب ۾ تارن جي صف موٽائڻ گهرجي.جيڪڏهن ٻن لفظن جي ڊيگهه هڪجهڙي آهي، صف کي الفابيٽ جي ترتيب سان ترتيب ڏيو.ان قاعدي جي ترتيب سان ترتيب ڏنل صف واپس ڪرڻ گهرجي.آرٽيڪل جي ترتيب هر لفظ جي ڊيگهه سان وڌي وڃي ٿي، ۽ توهان کي ۽ ان ۾ ٻيڙيون به ٿي سگهن ٿيون.صف هميشه تارن جي صف آهي ۽ ڪڏهن به انگن جي صف ناهي،۽ ترتيب ڏنل ترتيب سان نتيجو واري صف واپس ڪري ٿو، strings ته ان کان ڌار lengths آهن حذف، هڪ فنڪشن لکو جيڪو هڪ اسٽرنگ جي صف کي پيرا ميٽر طور قبول ڪري،# >>> list_sort.call([""aa"", ""a"", ""aaa""])
# [""aa""]
# >>> list_sort.call([""ab"", ""a"", ""aaa"", ""cd""])
# [""ab"", ""cd""]
def sorted_list_sum(lst)
","def list_sort(arr)
  arr.select { |s| s.length.even? }
     .sort_by { |s| [s.length, s] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_sorted_list_sum
    candidate = method(:sorted_list_sum)
    assert_equal([""aa""], candidate.call([""aa"", ""a"", ""aaa""]))
    assert_equal([""AI"", ""asdf"", ""school""], candidate.call([""school"", ""AI"", ""asdf"", ""b""]))
    assert_equal([], candidate.call([""d"", ""b"", ""c"", ""a""]))
    assert_equal([""abcd"", ""dcba""], candidate.call([""d"", ""dcba"", ""abcd"", ""a""]))
    assert_equal([""AI"", ""ai"", ""au""], candidate.call([""AI"", ""ai"", ""au""]))
    assert_equal([], candidate.call([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]))
    assert_equal([""cc"", ""dd"", ""aaaa"", ""bbbb""], candidate.call([""aaaa"", ""bbbb"", ""dd"", ""cc""]))
  end
end
"
HumanEval_150,snd_Arab,rb,"مثال: هڪ پرائم نمبر ۽ ٻي صورت ۾ y جي قيمت موٽڻ گهرجي. هڪ سادي پروگرام جنهن کي x جي قدر واپس ڪرڻ گهرجي جيڪڏهن n  آهي# >>> x_or_y.call(7, 34, 12)
# 34
# >>> x_or_y.call(15, 8, 5)
# 5
def x_or_y(n, x, y)
","def x_or_y(n, x, y)
  require 'prime'
  n.prime? ? x : y
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_x_or_y
    candidate = method(:x_or_y)
    assert_equal(34, candidate.call(7, 34, 12))
    assert_equal(5, candidate.call(15, 8, 5))
    assert_equal(33, candidate.call(3, 33, 5212))
    assert_equal(3, candidate.call(1259, 3, 52))
    assert_equal(-1, candidate.call(7919, -1, 12))
    assert_equal(583, candidate.call(3609, 1245, 583))
    assert_equal(129, candidate.call(91, 56, 129))
    assert_equal(1234, candidate.call(6, 34, 1234))
    assert_equal(0, candidate.call(1, 2, 0))
    assert_equal(2, candidate.call(2, 2, 0))
  end
end
"
HumanEval_151,snd_Arab,rb,"صف ۾ جيڪي ڌار آهن. نمبرن کي نظرانداز ڪريو جيڪي منفي آهن يا انٽيجر نه آهن.انگن جي هڪ صف ڏني، انگن جي squares جو مجموعو موٽي # >>> double_the_difference.call([1, 3, 2, 0])
# 10
# >>> double_the_difference.call([-1, -2, 0])
# 0
# >>> double_the_difference.call([9, -2])
# 81
# >>> double_the_difference.call([0])
# 0
# If the input array is empty, return 0.
def double_the_difference(lst)
","def double_the_difference(lst)
  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }
     .map { |n| n ** 2 }
     .sum
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_double_the_difference
    candidate = method(:double_the_difference)
    assert_equal(0, candidate.call([]))
    assert_equal(25, candidate.call([5.0, 4.0]))
    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))
    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))
    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))
    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))
    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))
  end
end
"
HumanEval_152,snd_Arab,rb,"مثال طور: قيمت 0 آهي ۽ جيڪڏهن نه ، قيمت اندازي ۽ اسڪور جي وچ ۾ مطلق فرق آهي.هڪ ئي ڊيگهه جي صف واپس ڪريو ته هر اندازي جي ڪيتري حد تائين هئي. جيڪڏهن انهن صحيح اندازو لڳايو آهي، توهان کي ٻه نمبر ۽ اندازن جا ٻه صف ڏنا ويا آهن ، جتي هر انڊيڪس هڪ ميچ ڏيکاري ٿو.توهان جو ڪم اهو طئي ڪرڻ آهي ته جيڪڏهن هڪ شخص ڪيترن ئي ميچن جي نتيجن کي صحيح اندازو لڳايو آهي.يقيناً نوٽ ڪرڻ ۽ موازنہ ڪرڻ جي قابل آهي.واقعي جي آخر ۾ معلوم ٿي وئي آهي. توهان جي احساسن ۽ سوچن کي هن وقت آهيمان سمجهان ٿو ته اسان سڀني کي اهو احساس ياد آهي جڏهن ڪجهه ڊگهي انتظار جو نتيجو# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
# [0, 0, 0, 0, 3, 3]
# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
# [4, 4, 1, 0, 0, 6]
def compare(game, guess)
","def compare(game, guess)
  game.zip(guess).map { |score, prediction| (score - prediction).abs }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_compare
    candidate = method(:compare)
    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))
    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))
    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))
    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))
  end
end
"
HumanEval_153,snd_Arab,rb,"مثال: (ان جي طاقت -1) آهي.واپس ڪريو ""Slices.SERVINGSliCes"" ڇاڪاڻ ته ""SERVINGSliCes"" مضبوط واڌ آهي extensions: ['SErviNGSliCes'، 'Cheese'، 'StuFfed'] پوءِ توهان کي گهرجي مثال طور، جيڪڏهن توهان کي ""سلائس"" ڏنو ويو آهي ته جيئن ڪلاس ۽ هڪ صف جيجيڪو صف ۾ پهريون اچي ٿو اهو چونڊيو.جيڪڏهن ٻه يا وڌيڪ واڌايون هڪ ئي طاقت سان آهن، توهان کي گهرجيفارميٽ: ڪلاس نالو. مضبوط ترين ايڪسٽينشن نالو. توھان کي مضبوط ترين واڌارو ڳولڻ گھرجي ۽ ان ۾ ھڪڙو تار واپس ڪرڻ گھرجيواڌ جي نالي ۾ ، طاقت کي سي اي پي - ايس ايم جي ڀا byي سان ڏنو ويو آهي. ايڪسٽينشن جي نالي ۾ اکرن، ۽ SM کي ننڍن اکرن جو تعداد ڏيو.واڌ جي طاقت هيٺ ڏنل آهي: CAP کي وڏي اکر جو نمبر ڏيو ايڪسٽينشنز کي استعمال ڪيو ويندو آهي اضافي ڪلاسز کي لوڊ ڪرڻ لاءِ.توهان کي هڪ ڪلاس جو نالو (هڪ اسٽرنگ) ۽ ايڪسٽينشن جو هڪ صف ڏنو ويندو.# >>> Strongest_Extension.call(""my_class"", [""AA"", ""Be"", ""CC""])
# ""my_class.AA""
def Strongest_Extension(class_name, extensions)
","def Strongest_Extension(class_name, extensions)
  strongest_extension = extensions.max_by do |extension|
    cap_count = extension.count('A-Z')
    sm_count = extension.count('a-z')
    cap_count - sm_count
  end
  ""#{class_name}.#{strongest_extension}""
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_Strongest_Extension
    candidate = method(:Strongest_Extension)
    assert_equal(""Watashi.eIGHt8OKe"", candidate.call(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]))
    assert_equal(""Boku123.YEs.WeCaNe"", candidate.call(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]))
    assert_equal(""__YESIMHERE.NuLl__"", candidate.call(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]))
    assert_equal(""K.TAR"", candidate.call(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]))
    assert_equal(""__HAHA.123"", candidate.call(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]))
    assert_equal(""YameRore.okIWILL123"", candidate.call(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]))
    assert_equal(""finNNalLLly.WoW"", candidate.call(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]))
    assert_equal(""_.Bb"", candidate.call(""_"", [""Bb"", ""91245""]))
    assert_equal(""Sp.671235"", candidate.call(""Sp"", [""671235"", ""Bb""]))
  end
end
"
HumanEval_154,snd_Arab,rb,"توهان کي 2 لفظ ڏنا ويا آهن. توهان کي سچ موٽڻ جي ضرورت آهي جيڪڏهن ٻيو لفظ يا ان جي ڪنهن به گردش پهرين لفظ ۾ هڪ ذيلي تار آهي # >>> cycpattern_check.call(""abcd"", ""abd"")
# false
# >>> cycpattern_check.call(""hello"", ""ell"")
# true
# >>> cycpattern_check.call(""whassup"", ""psus"")
# false
# >>> cycpattern_check.call(""abab"", ""baa"")
# true
# >>> cycpattern_check.call(""efef"", ""eeff"")
# false
# >>> cycpattern_check.call(""himenss"", ""simen"")
# true
def cycpattern_check(a, b)
","def cycpattern_check(a, b)
  (0...b.length).each do |i|
    rotated_b = b[i..-1] + b[0...i]
    return true if a.include?(rotated_b)
  end
  false
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_cycpattern_check
    candidate = method(:cycpattern_check)
    assert_equal(false, candidate.call(""xyzw"", ""xyw""))
    assert_equal(true, candidate.call(""yello"", ""ell""))
    assert_equal(false, candidate.call(""whattup"", ""ptut""))
    assert_equal(true, candidate.call(""efef"", ""fee""))
    assert_equal(false, candidate.call(""abab"", ""aabb""))
    assert_equal(true, candidate.call(""winemtt"", ""tinem""))
  end
end
"
HumanEval_155,snd_Arab,rb,"مثال: هڪ عدد ڏنو ويو آهي. هڪ صف موٽائي ٿو جنهن ۾ ترتيب سان برابر ۽ اڻ برابر انگن جو تعداد آهي.# >>> even_odd_count.call(-12)
# [1, 1]
# >>> even_odd_count.call(123)
# [1, 2]
def even_odd_count(num)
","def even_odd_count(num)
  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_even_odd_count
    candidate = method(:even_odd_count)
    assert_equal([0, 1], candidate.call(7))
    assert_equal([1, 1], candidate.call(-78))
    assert_equal([2, 2], candidate.call(3452))
    assert_equal([3, 3], candidate.call(346211))
    assert_equal([3, 3], candidate.call(-345821))
    assert_equal([1, 0], candidate.call(-2))
    assert_equal([2, 3], candidate.call(-45347))
    assert_equal([1, 0], candidate.call(0))
  end
end
"
HumanEval_156,snd_Arab,rb,"مثال: پابنديون: 1 <= نمبر <= 1000 ۽ ان کي ننڍي اکرن ۾ موٽايو.هڪ مثبت انٽيگر ڏنو، ان جي رومن عددي برابر کي هڪ اسٽرنگ طور حاصل ڪريو، # >>> int_to_mini_roman.call(19)
# ""xix""
# >>> int_to_mini_roman.call(152)
# ""clii""
# >>> int_to_mini_roman.call(426)
# ""cdxxvi""
def int_to_mini_roman(number)
","def int_to_mini_roman(number)
  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']

  result = ''
  values.each_with_index do |value, index|
    while number >= value
      number -= value
      result += numerals[index]
    end
  end

  result
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_int_to_mini_roman
    candidate = method(:int_to_mini_roman)
    assert_equal(""xix"", candidate.call(19))
    assert_equal(""clii"", candidate.call(152))
    assert_equal(""ccli"", candidate.call(251))
    assert_equal(""cdxxvi"", candidate.call(426))
    assert_equal(""d"", candidate.call(500))
    assert_equal(""i"", candidate.call(1))
    assert_equal(""iv"", candidate.call(4))
    assert_equal(""xliii"", candidate.call(43))
    assert_equal(""xc"", candidate.call(90))
    assert_equal(""xciv"", candidate.call(94))
    assert_equal(""dxxxii"", candidate.call(532))
    assert_equal(""cm"", candidate.call(900))
    assert_equal(""cmxciv"", candidate.call(994))
    assert_equal(""m"", candidate.call(1000))
  end
end
"
HumanEval_157,snd_Arab,rb,"مثال: 90 درجا. هڪ مستطيل مثلث هڪ مثلث آهي جنهن ۾ هڪ زاويه صحيح زاويه آهي يا طرف هڪ صحيح زاويه ٽڪنڊي ٺاهيندا آهن، ٻي صورت ۾ غلط.هڪ مثلث جي ٽن پاسن جي ڊيگهه ڏنو. سچ واپس جيڪڏھن ٽي # >>> right_angle_triangle.call(3, 4, 5)
# true
# >>> right_angle_triangle.call(1, 2, 3)
# false
def right_angle_triangle(a, b, c)
","def right_angle_triangle(a, b, c)
  sides = [a, b, c].sort
  sides[0]**2 + sides[1]**2 == sides[2]**2
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_right_angle_triangle
    candidate = method(:right_angle_triangle)
    assert_equal(true, candidate.call(3, 4, 5))
    assert_equal(false, candidate.call(1, 2, 3))
    assert_equal(true, candidate.call(10, 6, 8))
    assert_equal(false, candidate.call(2, 2, 2))
    assert_equal(true, candidate.call(7, 24, 25))
    assert_equal(false, candidate.call(10, 5, 7))
    assert_equal(true, candidate.call(5, 12, 13))
    assert_equal(true, candidate.call(15, 8, 17))
    assert_equal(true, candidate.call(48, 55, 73))
    assert_equal(false, candidate.call(1, 1, 1))
    assert_equal(false, candidate.call(2, 2, 10))
  end
end
"
HumanEval_158,snd_Arab,rb,"اکرن جي ترتيب سان ، اهو واپس ڪريو جيڪو لڪسيگرافڪ ترتيب ۾ پهرين اچي ٿو. جيڪڏهن گهڻن اسٽرنگن ۾ منفرد اکرن جو وڌ ۾ وڌ تعداد آهيصف ۾ مختلف لفظ آهن. لفظ موٽايو وڌ کان وڌ تعداد سان هڪ فنڪشن لکو جيڪو اسٽرنگز جي صف کي قبول ڪري.# >>> find_max.call([""name"", ""of"", ""string""])
# ""string""
# >>> find_max.call([""name"", ""enam"", ""game""])
# ""enam""
# >>> find_max.call([""aaaaaaa"", ""bb"", ""cc""])
# ""aaaaaaa""
def find_max(words)
","def find_max(words)
  # Helper function to count unique characters
  def unique_char_count(word)
    word.chars.uniq.size
  end

  words.max_by { |word| [unique_char_count(word), -word] }
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_find_max
    candidate = method(:find_max)
    assert_equal(""string"", candidate.call([""name"", ""of"", ""string""]))
    assert_equal(""enam"", candidate.call([""name"", ""enam"", ""game""]))
    assert_equal(""aaaaaaa"", candidate.call([""aaaaaaa"", ""bb"", ""cc""]))
    assert_equal(""abc"", candidate.call([""abc"", ""cba""]))
    assert_equal(""footbott"", candidate.call([""play"", ""this"", ""game"", ""of"", ""footbott""]))
    assert_equal(""gonna"", candidate.call([""we"", ""are"", ""gonna"", ""rock""]))
    assert_equal(""nation"", candidate.call([""we"", ""are"", ""a"", ""mad"", ""nation""]))
    assert_equal(""this"", candidate.call([""this"", ""is"", ""a"", ""prrk""]))
    assert_equal(""b"", candidate.call([""b""]))
    assert_equal(""play"", candidate.call([""play"", ""play"", ""play""]))
  end
end
"
HumanEval_159,snd_Arab,rb,"مثال: جيڪڏهن ڪافي گاجر نه بچيا آهن، توهان سڀئي باقي گاجر کائيندا، پر اڃا تائين بکيو رهندو.کائڻ کانپوءِ رهجي ويل گاجر جو تعداد ] توھان کي موٽڻ گھرجي ھڪڙي صف جي [ کائڻ کانپوءِ کائڻ واري گاجر جي ڪل تعداد ، پر هاڻي توکي وڌيڪ گاجر کائڻ جي ضرورت آهي ته جيئن ڏينهن جو کاڌو پورو ڪري سگهين.تون هڪ بکايل خرگوش آهين، ۽ تون اڳ ۾ ئي ڪجهه گاجر کائي چڪو آهين،# >>> eat.call(5, 6, 10)
# [11, 4]
# >>> eat.call(4, 8, 9)
# [12, 1]
# >>> eat.call(1, 10, 10)
# [11, 0]
# >>> eat.call(2, 11, 5)
# [7, 0]
# Variables:
# @number : integer
# the number of carrots that you have eaten.
# @need : integer
# the number of carrots that you need to eat.
# @remaining : integer
# the number of remaining carrots thet exist in stock
# Constrain:
# * 0 <= number <= 1000
# * 0 <= need <= 1000
# * 0 <= remaining <= 1000
# Have fun :)
def eat(number, need, remaining)
","def eat(number, need, remaining)
  total_eaten = number + [need, remaining].min
  carrots_left = [remaining - need, 0].max
  [total_eaten, carrots_left]
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_eat
    candidate = method(:eat)
    assert_equal([11, 4], candidate.call(5, 6, 10))
    assert_equal([12, 1], candidate.call(4, 8, 9))
    assert_equal([11, 0], candidate.call(1, 10, 10))
    assert_equal([7, 0], candidate.call(2, 11, 5))
    assert_equal([9, 2], candidate.call(4, 5, 7))
    assert_equal([5, 0], candidate.call(4, 5, 1))
  end
end
"
HumanEval_160,snd_Arab,rb,"آپريٽر صف ۾ گهٽ ۾ گهٽ هڪ آپريٽر هوندو آهي، ۽ آپريڊ صف ۾ گهٽ ۾ گهٽ ٻه آپريڊ هوندا آهن.آپريڊ غير منفي عدد جو هڪ صف آهي.آپريٽر جي صف جي ڊيگهه آپريڊ جي صف جي ڊيگهه منفي هڪ جي برابر آهي.نوٽ:=> نتيجو = 9 نتيجو = 2 + 3 * 4 - 5 صف = [2, 3, 4, 5] آپريٽر['+'، '*'، '-'] مثال: نمائش (**) فرش جي تقسيم ( //) ضرب (*) گھٽائڻ ( - ) جمع ڪرڻ (+) بنيادي جبر جا آپريشن:اظهار ۽ هن اظهار جي تشخيص موٽڻ. ٻيو صف عدد جي صف آهي. ٻه ڏنل صفون استعمال ڪريو ته جبر جي تعمير لاءِ ٻن صفن جو آپريٽر ۽ آپريڊ ڏنو ويو آهي. پهرين صف ۾ بنيادي الجبرا آپريشن آهن، ۽ def do_algebra(operator, operand)
","def do_algebra(operator, operand)
  expression = operand[0].to_s
  operator.each_with_index do |op, index|
    if op == '//'
      expression += ' / ' + operand[index + 1].to_s
    else
      expression += ' ' + op + ' ' + operand[index + 1].to_s
    end
  end
  eval(expression)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_do_algebra
    candidate = method(:do_algebra)
    assert_equal(37, candidate.call([""**"", ""*"", ""+""], [2, 3, 4, 5]))
    assert_equal(9, candidate.call([""+"", ""*"", ""-""], [2, 3, 4, 5]))
    assert_equal(8, candidate.call([""//"", ""*""], [7, 3, 4]))
  end
end
"
HumanEval_161,snd_Arab,rb,"مثال فنڪشن کي نتيجي ۾ ڏنل اسٽرنگ موٽائڻ گهرجي.جيڪڏهن اسٽرنگ ۾ ڪي اکر نه هجن ته ان کي ان جي ابتڙ ڪريو.ٻي صورت ۾ ان کي جيئن آهي تيئن ئي رکو.جيڪڏهن s[i] هڪ خط آهي، ان جي صورت کي هيٺئين کان مٿئين طرف يا ان جي برعڪس، توھان کي ھڪ string s ڏنو ويو آھي.# >>> solve.call(""1234"")
# ""4321""
# >>> solve.call(""ab"")
# ""AB""
# >>> solve.call(""#a@C"")
# ""#A@c""
def solve(s)
","def solve(s)
  if s =~ /[a-zA-Z]/
    s.chars.map { |char| char =~ /[a-zA-Z]/ ? char.swapcase : char }.join
  else
    s.reverse
  end
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_solve
    candidate = method(:solve)
    assert_equal(""aSdF"", candidate.call(""AsDf""))
    assert_equal(""4321"", candidate.call(""1234""))
    assert_equal(""AB"", candidate.call(""ab""))
    assert_equal(""#A@c"", candidate.call(""#a@C""))
    assert_equal(""#aSDFw^45"", candidate.call(""#AsdfW^45""))
    assert_equal(""2@6#"", candidate.call(""#6@2""))
    assert_equal(""#$A^d"", candidate.call(""#$a^D""))
    assert_equal(""#CCC"", candidate.call(""#ccc""))
  end
end
"
HumanEval_162,snd_Arab,rb,"جيڪڏهن 'متن' خالي تار آهي، واپس نيل. هڪ اسٽرنگ 'متن' ڏني، ان جي md5 hash برابر اسٽرنگ موٽائي. # >>> string_to_md5.call(""Hello world"")
# ""3e25960a79dbc69b674cd4ec67a72c62""
def string_to_md5(text)
","require 'digest'

def string_to_md5(text)
  return nil if text.empty?
  Digest::MD5.hexdigest(text)
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_string_to_md5
    candidate = method(:string_to_md5)
    assert_equal(""3e25960a79dbc69b674cd4ec67a72c62"", candidate.call(""Hello world""))
    assert_equal(nil, candidate.call(""""))
    assert_equal(""0ef78513b0cb8cef12743f5aeb35f888"", candidate.call(""A B C""))
    assert_equal(""5f4dcc3b5aa765d61d8327deb882cf99"", candidate.call(""password""))
  end
end
"
HumanEval_163,snd_Arab,rb,"مثال طور: ۽ ب، اڀرندڙ ترتيب ۾.ٻه مثبت انٽيگرز a ۽ b ڏنا، a  جي وچ ۾ به انگن اکرن کي موٽايو# >>> generate_integers.call(2, 8)
# [2, 4, 6, 8]
# >>> generate_integers.call(8, 2)
# [2, 4, 6, 8]
# >>> generate_integers.call(10, 14)
# []
def generate_integers(a, b)
","def generate_integers(a, b)
  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort
end","require 'test/unit'
class TestHumanEval < Test::Unit::TestCase
  def test_generate_integers
    candidate = method(:generate_integers)
    assert_equal([2, 4, 6, 8], candidate.call(2, 10))
    assert_equal([2, 4, 6, 8], candidate.call(10, 2))
    assert_equal([2, 4, 6, 8], candidate.call(132, 2))
    assert_equal([], candidate.call(17, 89))
  end
end
"
