[{"task_id":"HumanEval_0","nl":"tgk_Cyrl","pl":"rb","prompt":" дар як сатҳи додашуда.Санҷед, ки оё дар массиви додашудаи рақамҳо, ягон ду рақам ба якдигар наздиктар аз # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# true\ndef has_close_elements(numbers, threshold)\n","canonical_solution":"def has_close_elements(numbers, threshold)\n  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n  end\nend\n"},{"task_id":"HumanEval_1","nl":"tgk_Cyrl","pl":"rb","prompt":"Ҳар гуна фосилаҳоро дар сатри вуруд нодида гиред.Гурӯҳҳои ҷудогона мувозинат доранд (ҳар як дастгоҳи кушода дуруст баста шудааст) ва дар дохили якдигар ҷойгир нестанд.ин гурӯҳро ба сатрҳои алоҳида ҷудо кунед ва массиви онҳоро баргардонед.Воридоти ин функсия сатр аст, ки дорои гурӯҳҳои зиёди скобҳои даргирифта мебошад.# >>> separate_paren_groups.call(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\ndef separate_paren_groups(paren_string)\n","canonical_solution":"def separate_paren_groups(paren_string)\n  # Remove spaces from the string\n  paren_string = paren_string.gsub(\" \", \"\")\n  \n  result = []\n  current_group = \"\"\n  balance = 0\n\n  paren_string.each_char do |char|\n    current_group += char\n    balance += 1 if char == '('\n    balance -= 1 if char == ')'\n\n    if balance == 0 && !current_group.empty?\n      result << current_group\n      current_group = \"\"\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_separate_paren_groups\n    candidate = method(:separate_paren_groups)\n    assert_equal([\"(()())\", \"((()))\", \"()\", \"((())()())\"], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([\"()\", \"(())\", \"((()))\", \"(((())))\"], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([\"(()(())((())))\"], candidate.call(\"(()(())((())))\"))\n    assert_equal([\"()\", \"(())\", \"(()())\"], candidate.call(\"( ) (( )) (( )( ))\"))\n  end\nend\n"},{"task_id":"HumanEval_2","nl":"tgk_Cyrl","pl":"rb","prompt":"Қисми даҳуми рақамро баргардонед. (қисми боқимонда ҳамеша хурдтар аз 1) аст.ва қисми адади куллӣ (бузургтарин адади куллӣ аз адади додашуда хурдтар) ва даҳҳоӣ Бо назардошти рақами мусбати нуқтаи тағйирёбанда, онро ба  ҷудо кардан мумкин аст.# >>> truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n","canonical_solution":"def truncate_number(number)\n  number - number.to_i\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n  end\nend\n"},{"task_id":"HumanEval_3","nl":"tgk_Cyrl","pl":"rb","prompt":"дар ин нуқта функсия бояд true баргардонад. Дар акси ҳол он бояд false баргардонад. вазифаи шумо аст, ки ба ошкор агар дар ягон нуқтаи тавозуни ҳисоб falls below zero, ва Шумо як қатор амалиётҳои амонатгузорӣ ва бозпас гирифтани маблағро дар суратҳисоби бонкӣ мегиред, ки бо  сар мешавад.# >>> below_zero.call([1, 2, 3])\n# false\n# >>> below_zero.call([1, 2, -4, 5])\n# true\ndef below_zero(operations)\n","canonical_solution":"def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_zero\n    candidate = method(:below_zero)\n    assert_equal(false, candidate.call([]))\n    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))\n    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))\n    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))\n    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))\n    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))\n  end\nend\n"},{"task_id":"HumanEval_4","nl":"tgk_Cyrl","pl":"rb","prompt":"MAD = миёна. x - x_миёна. унсур ва нуқтаи марказӣ (дар ин ҳолат миёна): Ѓаффоли мутлаќи миёна фарќи миёнаи мутлаќи њама астҳои ин маҷмӯи маълумот.Барои массиви додашудаи рақамҳои вуруд, Тахрифи мутлақи миёнаро ҳисоб кунед # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n# 1.0\ndef mean_absolute_deviation(numbers)\n","canonical_solution":"def mean_absolute_deviation(numbers)\n  mean = numbers.sum.to_f \/ numbers.size\n  deviations = numbers.map { |num| (num - mean).abs }\n  deviations.sum \/ numbers.size\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0, 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"},{"task_id":"HumanEval_5","nl":"tgk_Cyrl","pl":"rb","prompt":"Миёни ҳар ду унсури пайдарпайи массиви вуруд рақами \"делиметр\" ворид кунед `рақамҳо\" # >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n","canonical_solution":"def intersperse(numbers, delimeter)\n  return numbers if numbers.empty?\n  result = []\n  numbers.each_with_index do |num, index|\n    result << num\n    result << delimeter unless index == numbers.size - 1\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"},{"task_id":"HumanEval_6","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан, (() (()) ҳадди аксар ду сатҳи гунбазкунӣ дорад, дар ҳоле ки ((())) се аст. Барои ҳар як гурӯҳи, баровардани сатҳи чуқури nesting аз омехтаи. Воридоти ин функсия сатри намояндагии гурӯҳҳои сершумор барои скобҳои дар байни худ ҷойгиршуда мебошад, ки бо фосилаҳо ҷудо карда шудаанд. # >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n","canonical_solution":"def parse_nested_parens(paren_string)\n  paren_string.split.map do |group|\n    max_depth = current_depth = 0\n    group.chars.each do |char|\n      if char == '('\n        current_depth += 1\n        max_depth = [max_depth, current_depth].max\n      elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"))\n  end\nend\n"},{"task_id":"HumanEval_7","nl":"tgk_Cyrl","pl":"rb","prompt":"Массиви вуруди сатрҳоро танҳо барои онҳое, ки дорои зерсатри додашуда мебошанд, филтр кунед # >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\ndef filter_by_substring(strings, substring)\n","canonical_solution":"def filter_by_substring(strings, substring)\n  strings.select { |string| string.include?(substring) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"))\n  end\nend\n"},{"task_id":"HumanEval_8","nl":"tgk_Cyrl","pl":"rb","prompt":"Ҷамъи холӣ бояд ба 0 баробар бошад ва маҳсули холӣ бояд ба 1 баробар бошад. Барои массиви додашудаи ададҳои бутун, массиви иборат аз ҷамъ ва ҳосили ҳамаи ададҳои бутунро дар массив баргардонед. # >>> sum_product.call([])\n# [0, 1]\n# >>> sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n","canonical_solution":"def sum_product(numbers)\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0], candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"},{"task_id":"HumanEval_9","nl":"tgk_Cyrl","pl":"rb","prompt":"дар пайдарпайи.Аз массиви додашудаи ададҳои бутун массиви унсури максимуми доимии то лаҳзаи додашударо пайдо кунед.# >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n","canonical_solution":"def rolling_max(numbers)\n  max_so_far = numbers.first\n  numbers.map do |num|\n    max_so_far = [max_so_far, num].max\n  end\nend\n\n# Example usage:\n# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"},{"task_id":"HumanEval_10","nl":"tgk_Cyrl","pl":"rb","prompt":"- Ба охири сатри баръакси префикси сатр илова кунед, ки пеш аз суфикси палиндромӣ меояд.- Дарозтарин пас аз пайвастшавии сатри додашударо, ки палиндром аст, ёбед. Андешаи алгоритм оддӣ аст: Кӯтоҳтарин палиндромеро ёбед, ки бо сатри додашуда оғоз меёбад. # >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n","canonical_solution":"def make_palindrome(string)\n  return string if string.empty?\n\n  def is_palindrome?(s)\n    s == s.reverse\n  end\n\n  (0...string.length).reverse_each do |i|\n    if is_palindrome?(string[i..-1])\n      return string + string[0...i].reverse\n    end\n  end\n\n  string\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\", candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"},{"task_id":"HumanEval_11","nl":"tgk_Cyrl","pl":"rb","prompt":"XOR-и дуӣ дар ин вурудҳо иҷро карда, натиҷаро ҳамчун сатр бармегардонад. Вуруди ду сатри a ва b, ки танҳо аз 1 ва 0 иборат аст.# >>> string_xor.call(\"010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n","canonical_solution":"def string_xor(a, b)\n  result = \"\"\n  a.length.times do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"},{"task_id":"HumanEval_12","nl":"tgk_Cyrl","pl":"rb","prompt":"сатрҳои дарозии якхела. Агар массиви вуруд холӣ бошад, nil -ро баргардонед. Аз массиви сатрҳо, дарозтаринро баргардонед. Дар сурати ҳои зиёд, аввалинро баргардонед.# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n","canonical_solution":"def longest(strings)\n  return nil if strings.empty?\n  strings.max_by(&:length)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n    assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n  end\nend\n"},{"task_id":"HumanEval_13","nl":"tgk_Cyrl","pl":"rb","prompt":"Бузургтарин тақсимкунандаи умумии ду адади a ва b-ро баргардонед # >>> greatest_common_divisor.call(3, 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a, b)\n","canonical_solution":"def greatest_common_divisor(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3, 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49, 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"},{"task_id":"HumanEval_14","nl":"tgk_Cyrl","pl":"rb","prompt":"Массиви ҳамаи префиксҳоро аз кӯтоҳтарин то дарозтарин сатри вуруд  баргардонад# >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n","canonical_solution":"def all_prefixes(string)\n  (1..string.length).map { |i| string[0, i] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"], candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"WWW\"))\n  end\nend\n"},{"task_id":"HumanEval_15","nl":"tgk_Cyrl","pl":"rb","prompt":"Сатри дорои рақамҳои дорои ҳудуди фазоро аз 0 то n дохил мекунад. # >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n# \"0 1 2 3 4 5\"\ndef string_sequence(n)\n","canonical_solution":"def string_sequence(n)\n  (0..n).to_a.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_16","nl":"tgk_Cyrl","pl":"rb","prompt":"Дар бораи сатр, бифаҳмед, ки аз чанд аломати алоҳида (беэътибор аз калима) иборат аст.# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n","canonical_solution":"def count_distinct_characters(string)\n  string.downcase.chars.uniq.count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5, candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"},{"task_id":"HumanEval_17","nl":"tgk_Cyrl","pl":"rb","prompt":"\"Оиша\" - нотаҳои чорякӣ, як зарбаро давом медиҳад.\"О\" - ним нота, ду зарбаро мегирад.\"О\" - тамоми нота, чор зарбаро давом медиҳад.Ин аст ривояте:на охирин.Вазифаи шумо ин аст, ки ин сатрро таҳлил кунед ва массиви ададҳои пурраро баргардонед, ки ба чанд зарба ҳар як Воридоти ин функсия як сатр аст, ки нотҳои мусиқиро дар формати махсуси ASCII ифода мекунад.# >>> parse_music.call(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n","canonical_solution":"def parse_music(music_string)\n  # Split the input string into individual notes.\n  notes = music_string.split\n\n  # Map each note to its corresponding number of beats.\n  notes.map do |note|\n    case note\n    when 'o'\n      4\n    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1, 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"},{"task_id":"HumanEval_18","nl":"tgk_Cyrl","pl":"rb","prompt":"Бифаҳмед, ки чанд маротиба як сатри додашударо дар сатри аслӣ пайдо кардан мумкин аст. Ҳолатҳои барҳамдиҳиро ҳисоб кунед. # >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring)\n","canonical_solution":"def how_many_times(string, substring)\n  return 0 if substring.empty?\n  count = 0\n  i = 0\n  while i <= string.length - substring.length\n    if string[i, substring.length] == substring\n      count += 1\n    end\n    i += 1\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\", \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4, candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"john doe\", \"john\"))\n  end\nend\n"},{"task_id":"HumanEval_19","nl":"tgk_Cyrl","pl":"rb","prompt":"Рақамҳои аз хурдтарин то калонтарин тартибдодашударо баргардонад Интихоби дуруст \"сифр\", \"як\", \"ду\", \"се\", \"чор\", \"панҷ\", \"шаш\", \"ҳафт\", \"ҳашт\" ва \"наҳор\" аст. Вуруди як сатри рақами аз \"сифр\" то \"наҳор\" аст.# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef sort_numbers(numbers)\n","canonical_solution":"def sort_numbers(numbers)\n  numeral_map = {\n    'zero' => 0,\n    'one' => 1,\n    'two' => 2,\n    'three' => 3,\n    'four' => 4,\n    'five' => 5,\n    'six' => 6,\n    'seven' => 7,\n    'eight' => 8,\n    'nine' => 9\n  }\n\n  number_words = numbers.split\n  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }\n  sorted_numbers.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six five four three two one zero\"))\n  end\nend\n"},{"task_id":"HumanEval_20","nl":"tgk_Cyrl","pl":"rb","prompt":"дигар ва онҳоро бо тартиб баргардонед (шумораи камтар, шумораи бештар).Аз массиви додашудаи рақамҳо (дарозии ҳадди аққал ду) ду рақами ба ҳар кадоме аз онҳо наздиктаринро интихоб ва баргардонед # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n","canonical_solution":"def find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs\n\n  (1...(sorted_numbers.length - 1)).each do |i|\n    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs\n    if current_difference < min_difference\n      min_difference = current_difference\n      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    end\n  end\n\n  closest_pair\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n"},{"task_id":"HumanEval_21","nl":"tgk_Cyrl","pl":"rb","prompt":"Ҳамин тавр, ки шумораи хурдтарин 0 ва шумораи калонтарин 1 мешавад.Дар массиви додашудаи рақамҳо (на камтар аз ду унсур), ба он массив табдилдиҳии хаттӣ татбиқ кунед, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n","canonical_solution":"def rescale_to_unit(numbers)\n  min = numbers.min\n  max = numbers.max\n  range = max - min\n  return numbers.map { |num| (num - min) \/ range.to_f }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\nend\n"},{"task_id":"HumanEval_22","nl":"tgk_Cyrl","pl":"rb","prompt":"Филтри массиви додашуда аз арзишҳои rbthon танҳо барои ададҳои бутун # >>> filter_integers.call([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\ndef filter_integers(values)\n","canonical_solution":"def filter_integers(values)\n  values.select { |value| value.is_a?(Integer) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n    assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\nend\n"},{"task_id":"HumanEval_23","nl":"tgk_Cyrl","pl":"rb","prompt":"Дарозии баргардонидани сатри додашуда # >>> strlen.call(\"\")\n# 0\n# >>> strlen.call(\"abc\")\n# 3\ndef strlen(string)\n","canonical_solution":"strlen = lambda do |string|\n  string.length\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"asdasnakj\"))\n  end\nend\n"},{"task_id":"HumanEval_24","nl":"tgk_Cyrl","pl":"rb","prompt":"Барои адади додашуда n, бузургтарин ададро, ки n-ро баробар тақсим мекунад, ёбем, ки аз n хурдтар аст # >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n","canonical_solution":"def largest_divisor(n)\n  (n - 1).downto(1) do |i|\n    return i if n % i == 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n  end\nend\n"},{"task_id":"HumanEval_25","nl":"tgk_Cyrl","pl":"rb","prompt":"Шумораи вуруд бояд ба ҳосили ҳамаи омилҳо баробар бошад.Ҳар як омил бояд ба шумораи маротибаҳо мувофиқ бошад, ки ба чанд маротиба дар омилҳо пайдо мешавад.Массиви омилҳои аввалини адади муайянро аз хурдтарин то калонтарин бармегардонад. # >>> factorize.call(8)\n# [2, 2, 2]\n# >>> factorize.call(25)\n# [5, 5]\n# >>> factorize.call(70)\n# [2, 5, 7]\ndef factorize(n)\n","canonical_solution":"def factorize(n)\n  factors = []\n  divisor = 2\n  while n > 1\n    while n % divisor == 0\n      factors << divisor\n      n \/= divisor\n    end\n    divisor += 1\n  end\n  factors\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_factorize\n    candidate = method(:factorize)\n    assert_equal([2], candidate.call(2))\n    assert_equal([2, 2], candidate.call(4))\n    assert_equal([2, 2, 2], candidate.call(8))\n    assert_equal([3, 19], candidate.call(57))\n    assert_equal([3, 3, 19, 19], candidate.call(3249))\n    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))\n    assert_equal([3, 19, 19, 19], candidate.call(20577))\n    assert_equal([2, 3, 3], candidate.call(18))\n  end\nend\n"},{"task_id":"HumanEval_26","nl":"tgk_Cyrl","pl":"rb","prompt":"Тартиби унсурҳои боқӣ ҳамон тавре ки дар вуруд нигоҳ дошта мешавад.Аз массиви ададҳои бутун ҳамаи унсурҳои зиёда аз як маротиба пайдошударо хориҷ кунед. # >>> remove_duplicates.call([1, 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n","canonical_solution":"def remove_duplicates(numbers)\n  numbers.select { |num| numbers.count(num) == 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"},{"task_id":"HumanEval_27","nl":"tgk_Cyrl","pl":"rb","prompt":"Барои сатри додашуда, аломатҳои хурд ба калон ва калон ба хурд иваз кунед. # >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n","canonical_solution":"def flip_case(string)\n  string.swapcase\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights have violent ends\"))\n  end\nend\n"},{"task_id":"HumanEval_28","nl":"tgk_Cyrl","pl":"rb","prompt":"Массиви сатрҳоро ба сатри ягона пайваст кунед # >>> concatenate.call([])\n# \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n","canonical_solution":"def concatenate(strings)\n  strings.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"},{"task_id":"HumanEval_29","nl":"tgk_Cyrl","pl":"rb","prompt":"Массиви вуруди сатрҳоро танҳо барои онҳое, ки бо префикси додашуда сар мешаванд, филтр кунед. # >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings, prefix)\n","canonical_solution":"def filter_by_prefix(strings, prefix)\n  strings.select { |string| string.start_with?(prefix) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\nend\n"},{"task_id":"HumanEval_30","nl":"tgk_Cyrl","pl":"rb","prompt":"Танҳо рақамҳои мусбатро дар массив бармегардонад. # >>> get_positive.call([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n","canonical_solution":"get_positive = lambda do |l|\n  l.select { |num| num > 0 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1, -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_31","nl":"tgk_Cyrl","pl":"rb","prompt":"Агар рақами додашуда рақами якум бошад, рост ва дар акси ҳол дурӯғро баргардонед. # >>> is_prime.call(6)\n# false\n# >>> is_prime.call(101)\n# true\n# >>> is_prime.call(11)\n# true\n# >>> is_prime.call(13441)\n# true\n# >>> is_prime.call(61)\n# true\n# >>> is_prime.call(4)\n# false\n# >>> is_prime.call(1)\n# false\ndef is_prime(n)\n","canonical_solution":"is_prime = lambda do |n|\n  return false if n <= 1\n  return true if n == 2\n  return false if n.even?\n\n  max_divisor = Math.sqrt(n).to_i\n  (3..max_divisor).step(2).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_prime\n    candidate = method(:is_prime)\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(101))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(13441))\n    assert_equal(true, candidate.call(61))\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(1))\n    assert_equal(true, candidate.call(5))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(17))\n    assert_equal(false, candidate.call(85))\n    assert_equal(false, candidate.call(77))\n    assert_equal(false, candidate.call(255379))\n  end\nend\n"},{"task_id":"HumanEval_33","nl":"tgk_Cyrl","pl":"rb","prompt":"ба арзишҳои нишондиҳандаҳои мувофиқи l, аммо ҷудо карда шудааст. l' бо l дар нишондиҳандаҳое, ки бо се тақсим намешаванд, якхела аст, дар ҳоле ки арзишҳои он дар нишондиҳандаҳое, ки бо се тақсим мешаванд, баробаранд Ин функсия массиви l-ро мегирад ва массиви l-ро чунин бармегардонад, ки # >>> sort_third.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n","canonical_solution":"def sort_third(l)\n  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort\n  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"},{"task_id":"HumanEval_34","nl":"tgk_Cyrl","pl":"rb","prompt":"Элементҳои ягонаи тартибдодашударо дар массив бармегардонад # >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n","canonical_solution":"def unique(l)\n  l.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_35","nl":"tgk_Cyrl","pl":"rb","prompt":"Элементи ҳадди аксарро дар массив бармегардонад. # >>> max_element.call([1, 2, 3])\n# 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n","canonical_solution":"def max_element(l)\n  l.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2, 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))\n  end\nend\n"},{"task_id":"HumanEval_36","nl":"tgk_Cyrl","pl":"rb","prompt":"Шумораи маротибаҳои пайдо шудани рақами 7 дар ададҳои бутун камтар аз n-ро, ки бо 11 ё 13 тақсимшаванда мебошанд, баргардонед. # >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n# 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n","canonical_solution":"def fizz_buzz(n)\n  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 || i % 13 == 0\n      count += i.to_s.count('7')\n    end\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n    assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n    assert_equal(8026, candidate.call(100000))\n  end\nend\n"},{"task_id":"HumanEval_37","nl":"tgk_Cyrl","pl":"rb","prompt":"ба арзишҳои индексҳои ҳатто аз l, вале тартиб дода шудааст. l' бо l дар индексҳои ҷуфт якхела аст, дар ҳоле ки арзишҳои он дар индексҳои ҷуфт баробаранд Ин функсия массиви l-ро мегирад ва массиви l-ро чунин бармегардонад, ки # >>> sort_even.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n","canonical_solution":"def sort_even(l)\n  even_indices = l.each_index.select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  \n  even_index = 0\n  l.each_with_index.map do |value, index|\n    if index.even?\n      even_values[even_index].tap { even_index += 1 }\n    else\n      value\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\nend\n"},{"task_id":"HumanEval_39","nl":"tgk_Cyrl","pl":"rb","prompt":"prime_fib шумораи n-умро бармегардонад, ки шумораи Фибоначчи аст ва он ҳам якум аст. # >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n# 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n","canonical_solution":"def prime_fib(n)\n  require 'prime'\n  \n  fibs = Enumerator.new do |y|\n    a, b = 0, 1\n    loop do\n      a, b = b, a + b\n      y << b\n    end\n  end\n  \n  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }\n  prime_fibs.first(n).last\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n    assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n    assert_equal(433494437, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_40","nl":"tgk_Cyrl","pl":"rb","prompt":"љамъбасти ба сифр ва дар акси ҳол дурӯғ аст.он true-ро бармегардонад, агар дар массив се унсури алоҳида мавҷуд бошад, ки triples_sum_to_zero массиви ададҳои куллро ҳамчун вуруд мегирад. # >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n# >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n","canonical_solution":"def triples_sum_to_zero(l)\n  n = l.length\n  (0...n-2).each do |i|\n    ((i+1)...n-1).each do |j|\n      ((j+1)...n).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false, candidate.call([100, 3, 5, -100]))\n  end\nend\n"},{"task_id":"HumanEval_41","nl":"tgk_Cyrl","pl":"rb","prompt":"Ин функсия шумораи чунин бархӯрдҳоро ба даст меорад. Ба монанди он ки ба ҳам барнахӯрданд.Аммо, мошинҳо беохир устувор ва қавӣ мебошанд; дар натиҷа, онҳо ҳаракат мекунанд.ва мошини аз чап ба рост ҳаракаткунанда ба мошини аз рост ба чап ҳаракаткунанда бархӯрдааст.хама мошинхо бо хамон суръат ҳаракат мекунанд.ду ҷуфт мошин аз дурии хеле дур сар мекунанд.n мошин аз чап ба рост ҳаракат мекунанд; ҳамзамон, як қатор мошинҳои n гуногун Тасаввур кунед, ки як роҳе, ки комилан рост аст, хатти беохир дароз аст.def car_race_collision(n)\n","canonical_solution":"def car_race_collision(n)\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_42","nl":"tgk_Cyrl","pl":"rb","prompt":"Массиви бо унсурҳои бо 1 афзоишёфтаро бармегардонад.# >>> incr_list.call([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n","canonical_solution":"def incr_list(l)\n  l.map { |x| x + 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_43","nl":"tgk_Cyrl","pl":"rb","prompt":"љамъбасти ба сифр ва дар акси ҳол дурӯғ аст.он true-ро бармегардонад, агар дар массив ду унсури алоҳида мавҷуд бошанд, ки pairs_sum_to_zero массиви ададҳои куллро ҳамчун вуруд мегирад. # >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1, 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n# false\ndef pairs_sum_to_zero(l)\n","canonical_solution":"def pairs_sum_to_zero(l)\n  num_set = l.to_set\n  l.each do |num|\n    return true if num != 0 && num_set.include?(-num)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"},{"task_id":"HumanEval_44","nl":"tgk_Cyrl","pl":"rb","prompt":"рақамҳои асос камтар аз 10 мебошанд.намоиши сатри баргардонидан пас аз табдилдиҳӣ. Тағйири асоси рақамии рақами вуруди x ба асос. # >>> change_base.call(8, 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7, 2)\n# \"111\"\ndef change_base(x, base)\n","canonical_solution":"def change_base(x, base)\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits << (x % base).to_s\n    x \/= base\n  end\n  digits.reverse.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8, 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\", candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7, 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3, 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5, 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7, 8))\n  end\nend\n"},{"task_id":"HumanEval_45","nl":"tgk_Cyrl","pl":"rb","prompt":"Дарозии канори додашуда ва майдони баланд баргаштан барои сегона.# >>> triangle_area.call(5, 3)\n# 7.5\ndef triangle_area(a, h)\n","canonical_solution":"def triangle_area(a, h)\n  (a * h) \/ 2.0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(7.5, candidate.call(5, 3))\n    assert_equal(2.0, candidate.call(2, 2))\n    assert_equal(40.0, candidate.call(10, 8))\n  end\nend\n"},{"task_id":"HumanEval_46","nl":"tgk_Cyrl","pl":"rb","prompt":"Лутфан функсияеро нависед, ки унсури n-уми пайдарпайи рақами fib4-ро самаранок ҳисоб кунад. Рекурсияро истифода набаред. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 Пайдарҳами рақами Fib4 пайдарҳами монанд ба пайдарҳами Фибоначчи аст, ки чунин муайян карда мешавад: # >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>> fib4.call(7)\n# 14\ndef fib4(n)\n","canonical_solution":"def fib4(n)\n  return 0 if n == 0 || n == 1 || n == 3\n  return 2 if n == 2\n\n  fib4_seq = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n  end\n  fib4_seq[n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28, candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_47","nl":"tgk_Cyrl","pl":"rb","prompt":"Миёнашавии унсурҳои массиви l-ро баргардонед. # >>> median.call([3, 1, 2, 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n","canonical_solution":"def median(l)\n  sorted = l.sort\n  len = sorted.length\n  if len.odd?\n    sorted[len \/ 2]\n  else\n    (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2.0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5, candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"},{"task_id":"HumanEval_48","nl":"tgk_Cyrl","pl":"rb","prompt":"Санҷида мешавад, ки оё сатри додашуда палиндром аст # >>> is_palindrome.call(\"\")\n# true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\")\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n","canonical_solution":"is_palindrome = lambda do |text|\n  text == text.reverse\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true, candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"},{"task_id":"HumanEval_49","nl":"tgk_Cyrl","pl":"rb","prompt":"2^n модули p-ро баргардонед (ба рақамҳо таваҷҷӯҳ кунед).# >>> modp.call(3, 5)\n# 3\n# >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3, 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n","canonical_solution":"def modp(n, p)\n  return 1 if p == 1\n  2.pow(n, p)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"},{"task_id":"HumanEval_51","nl":"tgk_Cyrl","pl":"rb","prompt":"remove_vowels функсияест, ки сатрро мегирад ва сатрро бе овозҳо бармегардонад. # >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n","canonical_solution":"def remove_vowels(text)\n  text.delete('aeiouAEIOU')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\", candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\", candidate.call(\"ybcd\"))\n  end\nend\n"},{"task_id":"HumanEval_52","nl":"tgk_Cyrl","pl":"rb","prompt":"Агар ҳамаи рақамҳои массиви l аз ҳадди t камтар бошанд, ростро баргардонад. # >>> below_threshold.call([1, 2, 4, 10], 100)\n# true\n# >>> below_threshold.call([1, 20, 4, 10], 5)\n# false\ndef below_threshold(l, t)\n","canonical_solution":"def below_threshold(l, t)\n  l.all? { |num| num < t }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_threshold\n    candidate = method(:below_threshold)\n    assert_equal(true, candidate.call([1, 2, 4, 10], 100))\n    assert_equal(false, candidate.call([1, 20, 4, 10], 5))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 21))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 22))\n    assert_equal(true, candidate.call([1, 8, 4, 10], 11))\n    assert_equal(false, candidate.call([1, 8, 4, 10], 10))\n  end\nend\n"},{"task_id":"HumanEval_53","nl":"tgk_Cyrl","pl":"rb","prompt":"Ду адад x ва y-ро илова кунед.# >>> add.call(2, 3)\n# 5\n# >>> add.call(5, 7)\n# 12\ndef add(x, y)\n","canonical_solution":"add = ->(x, y) { x + y }","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(1, candidate.call(0, 1))\n    assert_equal(1, candidate.call(1, 0))\n    assert_equal(5, candidate.call(2, 3))\n    assert_equal(12, candidate.call(5, 7))\n    assert_equal(12, candidate.call(7, 5))\n  end\nend\n"},{"task_id":"HumanEval_54","nl":"tgk_Cyrl","pl":"rb","prompt":"Санҷед, ки оё ду калима аломатҳои якхела доранд. # >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n# >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# false\ndef same_chars(s0, s1)\n","canonical_solution":"def same_chars(s0, s1)\n  s0.chars.uniq.all? { |char| s1.include?(char) } &&\n  s1.chars.uniq.all? { |char| s0.include?(char) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false, candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"))\n  end\nend\n"},{"task_id":"HumanEval_55","nl":"tgk_Cyrl","pl":"rb","prompt":"Шумораи n-уми Фибоначчиро баргардонед. # >>> fib.call(10)\n# 55\n# >>> fib.call(1)\n# 1\n# >>> fib.call(8)\n# 21\ndef fib(n)\n","canonical_solution":"def fib(n)\n  return n if n <= 1\n  fib(n - 1) + fib(n - 2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89, candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_56","nl":"tgk_Cyrl","pl":"rb","prompt":"баргардонидани ҳақиқӣ агар ҳар як камарбанди кушодашуда камарбанди пӯшида дошта бошад.  ин сатри \"<\" ва \">\" аст.# >>> correct_bracketing.call(\"<\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"<<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.chars.each do |char|\n    if char == '<'\n      balance += 1\n    elsif char == '>'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"<>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true, candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false, candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n    assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\">\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>>><>\"))\n  end\nend\n"},{"task_id":"HumanEval_57","nl":"tgk_Cyrl","pl":"rb","prompt":"Бозгашти ҳақиқӣ ин аст, ки унсурҳои массив якранг афзоиш ё коҳиш меёбанд. # >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n# false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n","canonical_solution":"def monotonic(l)\n  increasing = true\n  decreasing = true\n\n  (0...l.length - 1).each do |i|\n    if l[i] < l[i + 1]\n      decreasing = false\n    elsif l[i] > l[i + 1]\n      increasing = false\n    end\n  end\n\n  increasing || decreasing\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2, 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false, candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1, 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\nend\n"},{"task_id":"HumanEval_58","nl":"tgk_Cyrl","pl":"rb","prompt":"Элементҳои ягонаи умумии ду массивро бармегардонад. # >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n","canonical_solution":"def common(l1, l2)\n  (l1 & l2).uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"},{"task_id":"HumanEval_59","nl":"tgk_Cyrl","pl":"rb","prompt":"Бузургтарин омили аввалияи n-ро баргардонед. Фарз кунед, ки n > 1 аст ва омили аввалия нест. # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n# 2\ndef largest_prime_factor(n)\n","canonical_solution":"def largest_prime_factor(n)\n  factor = 2\n  while factor * factor <= n\n    if n % factor == 0\n      n \/= factor\n    else\n      factor += 1\n    end\n  end\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n  end\nend\n"},{"task_id":"HumanEval_60","nl":"tgk_Cyrl","pl":"rb","prompt":"sum_to_n функсияест, ки ададҳои аз 1 то n-ро ҷамъ мекунад. # >>> sum_to_n.call(30)\n# 465\n# >>> sum_to_n.call(100)\n# 5050\n# >>> sum_to_n.call(5)\n# 15\n# >>> sum_to_n.call(10)\n# 55\n# >>> sum_to_n.call(1)\n# 1\ndef sum_to_n(n)\n","canonical_solution":"def sum_to_n(n)\n  (1..n).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_61","nl":"tgk_Cyrl","pl":"rb","prompt":"баргардонидани ҳақиқӣ агар ҳар як камарбанди кушодашуда камарбанди пӯшида дошта бошад.                    # >>> correct_bracketing.call(\"(\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"(()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.each_char do |char|\n    if char == '('\n      balance += 1\n    elsif char == ')'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true, candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false, candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n    assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\")\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false, candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"()()(()())()))()\"))\n  end\nend\n"},{"task_id":"HumanEval_62","nl":"tgk_Cyrl","pl":"rb","prompt":"Пайдоиши ин бисёрномро дар ҳамон шакл баргардонед.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs коэффитсиентҳои бисёрномро ифода мекунад.# >>> derivative.call([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative.call([1, 2, 3])\n# [2, 6]\ndef derivative(xs)\n","canonical_solution":"def derivative(xs)\n  return [] if xs.length < 2\n  xs.each_with_index.map { |coef, index| coef * index }[1..-1]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2, 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_63","nl":"tgk_Cyrl","pl":"rb","prompt":"Лутфан функсияеро нависед, ки унсури n-уми пайдарпайи рақами fibfib-ро самаранок ҳисоб кунад. fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). fib fib ((2) == 1 fib fib ((1) == 0 fib fib ((0) == 0 Пайдарпаии рақами FibFib пайдарпаии монанд ба пайдарпаии Фибоначчи мебошад, ки чунин муайян карда мешавад: # >>> fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef fibfib(n)\n","canonical_solution":"def fibfib(n)\n  return 0 if n == 0 || n == 1\n  return 1 if n == 2\n\n  a, b, c = 0, 0, 1\n  (3..n).each do\n    a, b, c = b, c, a + b + c\n  end\n  c\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0, candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24, candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274, candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"},{"task_id":"HumanEval_64","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: овоз, аммо танҳо дар охири калима.Дар ин ҳолат овозҳо \"а\", \"е\", \"i\", \"o\", \"u\" мебошанд. Дар ин ҷо \"y\" низ а аст.як калимаро ҳамчун вуруд ва шумораи овозҳоро дар сатр бармегардонад. Функсияи vowels_count нависед, ки сатрро ифода мекунад # >>> vowels_count.call(\"abcde\")\n# 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n","canonical_solution":"def vowels_count(s)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  \n  s.chars.each_with_index do |char, index|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif char.downcase == 'y' && index == s.length - 1\n      count += 1\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"ACEDY\"))\n  end\nend\n"},{"task_id":"HumanEval_65","nl":"tgk_Cyrl","pl":"rb","prompt":"Агар shift > шумораи рақамҳо бошад, рақамҳои баргашта баръакс карда мешаванд. ва натиҷаро ҳамчун сатр баргардонад. Рақамҳои нуқтаи x-ро ба таври даврӣ гузаронед, рақамҳоро ба тарафи рост гузаронед.# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12, 2)\n# \"12\"\ndef circular_shift(x, shift)\n","canonical_solution":"def circular_shift(x, shift)\n  digits = x.to_s.chars\n  num_digits = digits.length\n\n  if shift > num_digits\n    return digits.reverse.join\n  else\n    shift = shift % num_digits\n    shifted_digits = digits.rotate(-shift)\n    return shifted_digits.join\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100, 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\", candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"11\", candidate.call(11, 101))\n  end\nend\n"},{"task_id":"HumanEval_66","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Рамзҳои ASCII. Функсияе нависед, ки сатрро ҳамчун вуруд қабул кунад ва танҳо ҷамъбасти аломатҳои болоӣ баргардонад' Вазифа # >>> digitSum.call(\"\")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n# 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n# 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n","canonical_solution":"def digitSum(s)\n  s.chars.select { |char| char =~ \/[A-Z]\/ }.map(&:ord).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131, candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327, candidate.call(\"You arE Very Smart\"))\n  end\nend\n"},{"task_id":"HumanEval_67","nl":"tgk_Cyrl","pl":"rb","prompt":"барои эксамбл: дар сабад шумораи меваҳои мангро дар сабад баргардонед. зардолу ва себ ва адади пурра, ки шумораи умумии меваҳоро ифода мекунад себ, зардолу ва мевахои манго.ки дар сабади меваи дар ин сабад мавҷудбуда тақсим карда мешаванд Дар ин вазифа, ба шумо як сатр дода мешавад, ки як қатор себ ва зардолуро ифода мекунад.# >>> fruit_distribution.call(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution.call(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution.call(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution.call(\"100 apples and 1 oranges\", 120)\n# 19\ndef fruit_distribution(s, n)\n","canonical_solution":"def fruit_distribution(s, n)\n  numbers = s.scan(\/\\d+\/).map(&:to_i)\n  apples = numbers[0]\n  oranges = numbers[1]\n  total_fruits = n\n  mangos = total_fruits - (apples + oranges)\n  mangos\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fruit_distribution\n    candidate = method(:fruit_distribution)\n    assert_equal(8, candidate.call(\"5 apples and 6 oranges\", 19))\n    assert_equal(10, candidate.call(\"5 apples and 6 oranges\", 21))\n    assert_equal(2, candidate.call(\"0 apples and 1 oranges\", 3))\n    assert_equal(2, candidate.call(\"1 apples and 0 oranges\", 3))\n    assert_equal(95, candidate.call(\"2 apples and 3 oranges\", 100))\n    assert_equal(0, candidate.call(\"2 apples and 3 oranges\", 5))\n    assert_equal(19, candidate.call(\"1 apples and 100 oranges\", 120))\n  end\nend\n"},{"task_id":"HumanEval_68","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисоли 1: Агар арзишҳои ҷуфт набошанд ё массиви додашуда холӣ бошад, баргардонед []. Дар гиреҳи plucked бояд дар массиви баргардонида шавад, [smallest_value, индекси он ], Агар якчанд гиреҳ бо ҳамон арзиши хурдтарини ҷуфт пайдо шавад, гиреҳро, ки индекси хурдтарин дорад, баргардонед. Дар гиреҳи plucked бояд гиреҳи бо хурдтарин арзиши ҳатто бошад. Вазифаи шумо ин аст, ки яке аз гиреҳҳоро бигиред ва онро баргардонед.\"Барои массиви намояндаи шохаи дарахте, ки дорои гиреҳҳои адади ҳои мутлақ ҳои ѓайриманфӣ мебошад # >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>> pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n","canonical_solution":"def pluck(arr)\n  smallest_even = nil\n  smallest_index = nil\n  \n  arr.each_with_index do |value, index|\n    if value.even?\n      if smallest_even.nil? || value < smallest_even\n        smallest_even = value\n        smallest_index = index\n      end\n    end\n  end\n\n  smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"},{"task_id":"HumanEval_69","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Агар чунин арзиш вуҷуд надошта бошад, -1-ро баргардонед.Басомади адади бутун ин шумораи маротибаҳоест, ки он дар массив пайдо мешавад.сифр ва дорои басомади калонтар аз ё баробар ба арзиши худи адади куллӣ мебошад. Шумо массиви холӣ-нашудаи ададҳои мусбатро доред. Бузургтарин адади мусбатеро баргардонед, ки аз  калонтар аст.# >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n","canonical_solution":"def search(lst)\n  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys\n  valid_numbers.empty? ? -1 : valid_numbers.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1, candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1, candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"},{"task_id":"HumanEval_70","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: пас аз он ки шумораи зиёди ададҳои пурраи боқимонда, пас аз он ки шумораи камтарин ва ғайра.Ҷамъбасти аҷиб, ин аст, ки шумо бо арзиши ҳадди ақал оғоз мекунед, Массиви ададҳои пурра дода шуда, массиви мухталифро бо тартиби номутаносиб бармегардонад.# >>> strange_sort_list.call([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n","canonical_solution":"def strange_sort_list(lst)\n  result = []\n  lst.sort!\n  until lst.empty?\n    result << lst.shift\n    result << lst.pop unless lst.empty?\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\nend\n"},{"task_id":"HumanEval_71","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Аз тарафи сеюм.Се канори сегона вақте ки суммаи ҳар ду канори он калонтар аст, секунҷаи дуруст аст.Дар акси ҳол баргардонида мешавад -1 секунҷа ба 2 нуқтаи даҳум мудаввар карда мешавад, агар се тараф секунҷаи дуруст ташкил кунанд. Бо назардошти дарозии се тарафи секунҷа, масоҳати  -ро баргардонед.# >>> triangle_area.call(3, 4, 5)\n# 6.0\n# >>> triangle_area.call(1, 2, 10)\n# -1\ndef triangle_area(a, b, c)\n","canonical_solution":"def triangle_area(a, b, c)\n  # Check for valid triangle\n  if a + b > c && a + c > b && b + c > a\n    # Calculate the semi-perimeter\n    s = (a + b + c) \/ 2.0\n    # Calculate the area using Heron's formula\n    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Round to 2 decimal points\n    return area.round(2)\n  else\n    return -1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(6.0, candidate.call(3, 4, 5))\n    assert_equal(-1, candidate.call(1, 2, 10))\n    assert_equal(8.18, candidate.call(4, 8, 5))\n    assert_equal(1.73, candidate.call(2, 2, 2))\n    assert_equal(-1, candidate.call(1, 2, 3))\n    assert_equal(16.25, candidate.call(10, 5, 7))\n    assert_equal(-1, candidate.call(2, 6, 3))\n    assert_equal(0.43, candidate.call(1, 1, 1))\n    assert_equal(-1, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_72","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Объекти q парвоз мекунад агар он мувозинат дошта бошад (ин массиви палиндромӣ аст) ва ҷамъи унсурҳои он аз вазни максималии имконпазир камтар ё баробар бошад w.Функсияе нависед, ки агар объект q парвоз кунад, дуруст ва дар акси ҳол дурӯғро баргардонад. # >>> will_it_fly.call([1, 2], 5)\n# false\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly.call([3, 2, 3], 1)\n# false\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly.call([3, 2, 3], 9)\n# true\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly.call([3], 5)\n# true\n# # 3 is less than the maximum possible weight, and it's balanced.\ndef will_it_fly(q, w)\n","canonical_solution":"def will_it_fly(q, w)\n  is_palindrome = q == q.reverse\n  total_weight = q.sum\n  is_balanced_and_under_weight = is_palindrome && total_weight <= w\n  is_balanced_and_under_weight\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_will_it_fly\n    candidate = method(:will_it_fly)\n    assert_equal(true, candidate.call([3, 2, 3], 9))\n    assert_equal(false, candidate.call([1, 2], 5))\n    assert_equal(true, candidate.call([3], 5))\n    assert_equal(false, candidate.call([3, 2, 3], 1))\n    assert_equal(false, candidate.call([1, 2, 3], 6))\n    assert_equal(true, candidate.call([5], 5))\n  end\nend\n"},{"task_id":"HumanEval_73","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Дар як тағирот, шумо метавонед як унсурро ба ягон унсури дигар иваз кунед. бояд тағир дода шавад, то массив палиндромӣ гардад. Массиви палиндромӣ массивест, ки Бо назардошти массиви arr ададҳои бутун, шумораи камтарини унсурҳоро ёбед, ки # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change.call([1, 2, 3, 2, 1])\n# 0\ndef smallest_change(arr)\n","canonical_solution":"def smallest_change(arr)\n  changes = 0\n  left = 0\n  right = arr.length - 1\n\n  while left < right\n    if arr[left] != arr[right]\n      changes += 1\n    end\n    left += 1\n    right -= 1\n  end\n\n  changes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_smallest_change\n    candidate = method(:smallest_change)\n    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))\n    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))\n    assert_equal(1, candidate.call([1, 4, 2]))\n    assert_equal(1, candidate.call([1, 4, 4, 2]))\n    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))\n    assert_equal(0, candidate.call([3, 1, 1, 3]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(1, candidate.call([0, 1]))\n  end\nend\n"},{"task_id":"HumanEval_74","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо агар ду массив шумораи аломатҳои якхела дошта бошанд, массиви аввалро баргардонед.шумораи умумии аломатҳо дар ҳамаи сатрҳои массив аз массиви дигар камтар аст.Функсияе нависед, ки ду массиви сатрҳоро қабул кунад ва массиви дорои # >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n","canonical_solution":"def total_match(lst1, lst2)\n  total_chars1 = lst1.map(&:length).sum\n  total_chars2 = lst2.map(&:length).sum\n\n  if total_chars1 < total_chars2\n    lst1\n  elsif total_chars2 < total_chars1\n    lst2\n  else\n    lst1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\", \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n    assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"},{"task_id":"HumanEval_75","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Донистани он ки а камтар аз 100 аст.ва бо ин ҳол дурӯғ аст.Функсияе нависед, ки агар рақами додашуда зарбаи 3 адади якум бошад, дуруст баргардонад.# >>> is_multiply_prime.call(30)\n# true\n# 30 = 2 * 3 * 5\ndef is_multiply_prime(a)\n","canonical_solution":"require 'prime'\n\ndef is_multiply_prime(a)\n  return false if a >= 100\n  prime_factors = a.prime_division\n  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_multiply_prime\n    candidate = method(:is_multiply_prime)\n    assert_equal(false, candidate.call(5))\n    assert_equal(true, candidate.call(30))\n    assert_equal(true, candidate.call(8))\n    assert_equal(false, candidate.call(10))\n    assert_equal(true, candidate.call(125))\n    assert_equal(true, candidate.call(105))\n    assert_equal(false, candidate.call(126))\n    assert_equal(false, candidate.call(729))\n    assert_equal(false, candidate.call(891))\n    assert_equal(true, candidate.call(1001))\n  end\nend\n"},{"task_id":"HumanEval_76","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: x қувваи оддии n аст, агар n**int=x қувваи n ва дар дигар ҳолатҳо дурӯғ аст. Вазифаи шумо ин аст, ки функсияеро нависед, ки агар адади x як адади оддӣ бошад, пас он true-ро баргардонад.# >>> is_simple_power.call(1, 4)\n# true\n# >>> is_simple_power.call(2, 2)\n# true\n# >>> is_simple_power.call(8, 2)\n# true\n# >>> is_simple_power.call(3, 2)\n# false\n# >>> is_simple_power.call(3, 1)\n# false\n# >>> is_simple_power.call(5, 3)\n# false\ndef is_simple_power(x, n)\n","canonical_solution":"def is_simple_power(x, n)\n  return false if x <= 0 || n <= 1\n  return true if x == 1\n\n  power = n\n  while power <= x\n    return true if power == x\n    power *= n\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_simple_power\n    candidate = method(:is_simple_power)\n    assert_equal(true, candidate.call(16, 2))\n    assert_equal(false, candidate.call(143214, 16))\n    assert_equal(true, candidate.call(4, 2))\n    assert_equal(true, candidate.call(9, 3))\n    assert_equal(true, candidate.call(16, 4))\n    assert_equal(false, candidate.call(24, 2))\n    assert_equal(false, candidate.call(128, 4))\n    assert_equal(false, candidate.call(12, 6))\n    assert_equal(true, candidate.call(1, 1))\n    assert_equal(true, candidate.call(1, 12))\n  end\nend\n"},{"task_id":"HumanEval_77","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Эзоҳ: шумо метавонед воридотро ҳамеша дуруст ҳисоб кунед. Агар ин ингерер куби ягон адади кулл бошад.Функсияе нависед, ки адади амудро мегирад ва true-ро бармегардонад.# >>> iscube.call(1)\n# true\n# >>> iscube.call(2)\n# false\n# >>> iscube.call(-1)\n# true\n# >>> iscube.call(64)\n# true\n# >>> iscube.call(0)\n# true\n# >>> iscube.call(180)\n# false\ndef iscube(a)\n","canonical_solution":"def iscube(a)\n  cube_root = a.abs**(1.0\/3)\n  cube_root.round**3 == a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_iscube\n    candidate = method(:iscube)\n    assert_equal(true, candidate.call(1))\n    assert_equal(false, candidate.call(2))\n    assert_equal(true, candidate.call(-1))\n    assert_equal(true, candidate.call(64))\n    assert_equal(false, candidate.call(180))\n    assert_equal(true, candidate.call(1000))\n    assert_equal(true, candidate.call(0))\n    assert_equal(false, candidate.call(1729))\n  end\nend\n"},{"task_id":"HumanEval_78","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: ва рамзҳои A,B,C,D,E,F ҳамеша калон мебошанд. Эзоҳ: шумо метавонед воридоти ҳамеша дуруст ё сатри холӣ аст, B (= даҳяк 11), D (= даҳяк 13). Пас шумо бояд як адад аз рақамҳои зеринро муайян кунед: 2, 3, 5, 7, Рақамҳои якум 2, 3, 5, 7, 11, 13, 17... мебошанд.Рақамҳои ҳаждаҳгонаи 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F мебошанд. калонтар аз 1 ки маҳсули ду адади табиии хурдтар нест).рақамҳои аввалия (рақами аввалия, ё рақами аввалия, рақами табиӣ аст рақами шашдаҳякӣ ҳамчун сатр ва шумораи рақамҳои шашдаҳякӣ Шумо вазифадор карда шудаед, ки функсияи қабулкунандаро нависед.# >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n# >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n","canonical_solution":"def hex_key(num)\n  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n  num.chars.count { |digit| prime_hex_digits.include?(digit) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6, candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"},{"task_id":"HumanEval_79","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Аксҳои иловагӣ барои тарҳрезӣ кӯмак мекунанд.Дар ибтидо ва охири сатр як ҷуфти аломатҳои иловагии \"db\" пайдо мешавад.Ҳар як аломат дар сатр \"0\" ё \"1\" хоҳад буд.формати дуӣ. Функсия бояд сатрро баргардонад, ки ҳар як аломат дуӣ Шумо ба шумо рақами даҳӣ дода мешавад ва вазифаи шумо ин аст, ки онро ба  табдил диҳед.# >>> decimal_to_binary.call(15)\n# \"db1111db\"\n# >>> decimal_to_binary.call(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal)\n","canonical_solution":"def decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"db\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_decimal_to_binary\n    candidate = method(:decimal_to_binary)\n    assert_equal(\"db0db\", candidate.call(0))\n    assert_equal(\"db100000db\", candidate.call(32))\n    assert_equal(\"db1100111db\", candidate.call(103))\n    assert_equal(\"db1111db\", candidate.call(15))\n  end\nend\n"},{"task_id":"HumanEval_80","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Сатр агар дарозии он на камтар аз 3 бошад ва ҳар 3 ҳарфи пайдарпай алоҳида бошанд, haprb аст.Вазифаи шумо ин аст, ки санҷед, ки оё сатр дуруст аст ё не.Ба шумо сатри s дода мешавад. # >>> is_happy.call(\"a\")\n# false\n# >>> is_happy.call(\"aa\")\n# false\n# >>> is_happy.call(\"abcd\")\n# true\n# >>> is_happy.call(\"aabb\")\n# false\n# >>> is_happy.call(\"adb\")\n# true\n# >>> is_happy.call(\"xyy\")\n# false\ndef is_happy(s)\n","canonical_solution":"def is_happy(s)\n  return false if s.length < 3\n  \n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  \n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true, candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n    assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"iopaxioi\"))\n  end\nend\n"},{"task_id":"HumanEval_81","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: 0.0 E > 0,0 D- > 0,7 D > 1,0 D+ > 1.3 C- > 1,7 С > 2.0 C+ > 2.3 Б- > 2,7 Б > 3.0 Б+ > 3.3 А- > 3.7 А 4.0 А+ Миёнаи баҳои баҳои хаттӣфунксияе, ки метавонад массиви синфҳои ҳарфро бо истифода аз ҷадвали зерин барорад: Ӯ ба шумо як қатор баҳои ба баъзе донишҷӯён дода ва шумо бояд нависед.Ягона мушкил ин аст, ки вай рамзи барои баҳогузорӣ истифодашударо гум кардааст.муаллим алгоритми худро барои баҳогузорӣ сохтааст.Ин ҳафтаи охирини семестр аст ва муаллим бояд баҳоҳо диҳад.# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\ndef numerical_letter_grade(grades)\n","canonical_solution":"def numerical_letter_grade(grades)\n  grades.map do |gpa|\n    case \n    when gpa == 4.0\n      \"A+\"\n    when gpa > 3.7\n      \"A\"\n    when gpa > 3.3\n      \"A-\"\n    when gpa > 3.0\n      \"B+\"\n    when gpa > 2.7\n      \"B\"\n    when gpa > 2.3\n      \"B-\"\n    when gpa > 2.0\n      \"C+\"\n    when gpa > 1.7\n      \"C\"\n    when gpa > 1.3\n      \"C-\"\n    when gpa > 1.0\n      \"D+\"\n    when gpa > 0.7\n      \"D\"\n    when gpa > 0.0\n      \"D-\"\n    else\n      \"E\"\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_numerical_letter_grade\n    candidate = method(:numerical_letter_grade)\n    assert_equal([\"A+\", \"B\", \"C-\", \"C\", \"A-\"], candidate.call([4.0, 3, 1.7, 2, 3.5]))\n    assert_equal([\"D+\"], candidate.call([1.2]))\n    assert_equal([\"D-\"], candidate.call([0.5]))\n    assert_equal([\"E\"], candidate.call([0.0]))\n    assert_equal([\"D\", \"D-\", \"C-\", \"B\", \"B+\"], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))\n    assert_equal([\"E\", \"D-\"], candidate.call([0.0, 0.7]))\n  end\nend\n"},{"task_id":"HumanEval_82","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо дарозии рақами якум аст ё дар акси ҳол Функсияе нависед, ки сатрро мегирад ва true-ро бармегардонад, агар сатр # >>> prime_length.call(\"Hello\")\n# true\n# >>> prime_length.call(\"abcdcba\")\n# true\n# >>> prime_length.call(\"kittens\")\n# true\n# >>> prime_length.call(\"orange\")\n# false\ndef prime_length(string)\n","canonical_solution":"def prime_length(string)\n  length = string.length\n  return false if length < 2\n\n  (2..Math.sqrt(length)).each do |i|\n    return false if length % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_length\n    candidate = method(:prime_length)\n    assert_equal(true, candidate.call(\"Hello\"))\n    assert_equal(true, candidate.call(\"abcdcba\"))\n    assert_equal(true, candidate.call(\"kittens\"))\n    assert_equal(false, candidate.call(\"orange\"))\n    assert_equal(true, candidate.call(\"wow\"))\n    assert_equal(true, candidate.call(\"world\"))\n    assert_equal(true, candidate.call(\"MadaM\"))\n    assert_equal(true, candidate.call(\"Wow\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"HI\"))\n    assert_equal(true, candidate.call(\"go\"))\n    assert_equal(false, candidate.call(\"gogo\"))\n    assert_equal(false, candidate.call(\"aaaaaaaaaaaaaaa\"))\n    assert_equal(true, candidate.call(\"Madam\"))\n    assert_equal(false, candidate.call(\"M\"))\n    assert_equal(false, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_83","nl":"tgk_Cyrl","pl":"rb","prompt":"ададҳои мусбате, ки бо 1 сар мешаванд ё ба 1 хотима меёбанд.Бо назардошти як адади мусбати n, шумораи рақамҳои n-рақамро баргардонед def starts_one_ends(n)\n","canonical_solution":"def starts_one_ends(n)\n  return 0 if n <= 0\n\n  # Count numbers starting with 1\n  start_with_1 = 9 ** (n - 1)\n\n  # Count numbers ending with 1\n  end_with_1 = 9 ** (n - 1)\n\n  # Adjust for double counting the number that both starts and ends with 1\n  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1\n  \n  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n  end\nend\n"},{"task_id":"HumanEval_84","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол Бо назардошти як адади мусбати N, ҷамъбасти умумии рақамҳои онро дар дуӣ баргардонед. # >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n# >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n","canonical_solution":"def solve(n)\n  sum_of_digits = n.to_s.chars.map(&:to_i).sum\n  sum_of_digits.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n  end\nend\n"},{"task_id":"HumanEval_85","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Бо назардошти массиви пурраи ададҳои бутун, аввал элементҳои ҷуфтро, ки дар индексҳои нобаробар ҳастанд, илова кунед.# >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n","canonical_solution":"def add(lst)\n  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0, candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n  end\nend\n"},{"task_id":"HumanEval_86","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Эзоҳ: Шумо бояд тартиби калимаҳо ва ҷойҳои холиро дар ҷумла нигоҳ доред. тартиби болоравии асос ёфта аз арзиши ASCII. бо калимаи нав иваз карда мешаванд, ки дар он ҳамаи аломатҳо дар Версияи тартибдодаи сатр, сатрест, ки дар он ҳамаи калимаҳо (бо фосила ҷудо карда шудаанд) Функсияе нависед, ки сатрро мегирад ва версияи тартибдодаи онро бармегардонад. # >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n","canonical_solution":"def anti_shuffle(s)\n  s.split(\/(\\s+)\/).map { |word| word.chars.sort.join }.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot. How are you?\"))\n  end\nend\n"},{"task_id":"HumanEval_87","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Ҳамчунин, координатаҳои сатрро аз рӯи сутунҳо бо тартиби афзоянда тартиб диҳед.Дар аввал координатаҳоро аз рӯи сатрҳо бо тартиби болоравӣ тартиб диҳед.ҳар массив координатаи - (сатр, сутун), ки бо 0 сар мешавад. ва массиви массивҳоро баргардонед, [(x1, y1), (x2, y2) ...] чунин ки Бо назардошти lst, ва адади бутун x, ададҳои бутун x дар массивро ёбед, ҳар сатр метавонад шумораи гуногуни сутунҳоро дар бар гирад. ки ба матритса монанд аст, аммо, ба фарқ аз матритсаҳо, Ба шумо маълумоти ду андоза дода мешавад, ҳамчун массивҳои даргирифта, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([], 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst, x)\n","canonical_solution":"def get_row(lst, x)\n  result = []\n\n  lst.each_with_index do |row, i|\n    row.each_with_index do |value, j|\n      result << [i, j] if value == x\n    end\n  end\n\n  result.sort_by { |coord| [coord[0], -coord[1]] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"},{"task_id":"HumanEval_88","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: * массиви додашударо иваз накунед. Эзоҳ: ё онро бо тартиби афзоянда тартиб диҳед, агар сумма ((баҳои индекси аввал, арзиши индекси охирин) ҷуфт бошад. шумо массиви додашударо бо тартиби болоравӣ тартиб медиҳед, агар сумма ((баҳои индекси аввал, арзиши индекси охирин) нобарор бошад, Бо назардошти массиви ададҳои мукаммали ғайри манфӣ, пас аз танзимкунӣ, як корби массиви додашударо баргардонед, # >>> sort_array.call([])\n# []\n# >>> sort_array.call([5])\n# [5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n","canonical_solution":"def sort_array(array)\n  return array if array.empty? || array.size == 1\n\n  if (array.first + array.last).odd?\n    array.sort\n  else\n    array.sort.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"},{"task_id":"HumanEval_89","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: ба ду баробар зиёд карда ба ду ҷой гузаред.Алифбо бояд ба тавре иваз карда шавад, ки ҳарфҳо сатри рамзшударо бо гардиши алифбо бармегардонад. Функсияи рамзкушоиро эҷод кунед, ки сатрро ҳамчун аргумент қабул кунад ва # >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"et\")\n# \"ix\"\ndef encrypt(s)\n","canonical_solution":"def encrypt(s)\n  s.chars.map do |char|\n    if char =~ \/[a-z]\/\n      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr\n    elsif char =~ \/[A-Z]\/\n      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr\n    else\n      char\n    end\n  end.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"e\", candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_90","nl":"tgk_Cyrl","pl":"rb","prompt":"Агар чунин унсур вуҷуд надошта бошад, nil -ро баргардонед. Функсияи next_smallest нависед, ки унсури 2-и хурдтарини массивро бармегардонад. Шумо массиви ададҳои пурра мегиред.# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1, 1])\n# nil\ndef next_smallest(lst)\n","canonical_solution":"def next_smallest(lst)\n  unique_sorted = lst.uniq.sort\n  unique_sorted.length >= 2 ? unique_sorted[1] : nil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"},{"task_id":"HumanEval_91","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Ҷумлаҳо бо '.', '?' ё '!' маҳдуд карда мешаванд. Дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷо, дар ин ҷоШумо ба шумо як силсила калимаҳо дода мешавад, ва вазифаи шумо шумораи онҳоро ҳисоб кардан аст.# >>> is_bored.call(\"Hello world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\ndef is_bored(s)\n","canonical_solution":"def is_bored(s)\n  sentences = s.split(\/(?<=[.?!])\/)\n  sentences.count { |sentence| sentence.strip.start_with?('I') }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1, candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"))\n  end\nend\n"},{"task_id":"HumanEval_92","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо Дар ҳама ҳолатҳои дигар false -ро бармегардонад. Агар яке аз рақамҳо ба ҷамъи ду рақами дигар баробар бошад ва ҳамаи рақамҳо ададҳои пурра бошанд, дуруст бармегардонад.Функсияе эҷод кунед, ки 3 ададро мегирад.# >>> any_int.call(5, 2, 7)\n# true\n# >>> any_int.call(3, 2, 2)\n# false\n# >>> any_int.call(3, -2, 1)\n# true\n# >>> any_int.call(3.6, -2.2, 2)\n# false\ndef any_int(x, y, z)\n","canonical_solution":"def any_int(x, y, z)\n  if [x, y, z].all? { |n| n.is_a?(Integer) }\n    x == y + z || y == x + z || z == x + y\n  else\n    false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_any_int\n    candidate = method(:any_int)\n    assert_equal(true, candidate.call(2, 3, 1))\n    assert_equal(false, candidate.call(2.5, 2, 3))\n    assert_equal(false, candidate.call(1.5, 5, 3.5))\n    assert_equal(false, candidate.call(2, 6, 2))\n    assert_equal(true, candidate.call(4, 2, 2))\n    assert_equal(false, candidate.call(2.2, 2.2, 2.2))\n    assert_equal(true, candidate.call(-4, 6, 2))\n    assert_equal(true, candidate.call(2, 1, 1))\n    assert_equal(true, candidate.call(3, 4, 7))\n    assert_equal(false, candidate.call(3.0, 4, 7))\n  end\nend\n"},{"task_id":"HumanEval_93","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Танҳо ҳарфҳоро қабул кунед. њамсадо дар алифбои англисӣ.паём бо ҳарфе, ки 2 ҷой пеш аз он пайдо мешавад ба таврие, ки он ҳамаи ҳарфҳоро иваз мекунад, ҳамаи овозҳоро дар  иваз мекунад.Функсияе нависед, ки паёмеро мегирад ва дар чунин # >>> encode.call(\"test\")\n# \"TGST\"\n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n","canonical_solution":"def encode(message)\n  vowels = 'aeiou'\n  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}\n  \n  encoded_message = message.chars.map do |char|\n    if vowels.include?(char.downcase)\n      new_char = swap_vowels[char.downcase]\n      char == char.upcase ? new_char.upcase : new_char.downcase\n    else\n      char == char.upcase ? char.downcase : char.upcase\n    end\n  end\n\n  encoded_message.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"},{"task_id":"HumanEval_94","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Шумо бояд бузургтарин арзиши аввалияро ёбед ва маблағи рақамҳои онро баргардонед.Шумо массиви ададҳои пурра мегиред.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])\n# 7\ndef skjkasdkd(lst)\n","canonical_solution":"def skjkasdkd(lst)\n  require 'prime'\n\n  # Find the largest prime number in the array\n  largest_prime = lst.select { |num| Prime.prime?(num) }.max\n  \n  # Return 0 if no prime number is found\n  return 0 if largest_prime.nil?\n\n  # Calculate the sum of digits of the largest prime number\n  largest_prime.to_s.chars.map(&:to_i).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_skjkasdkd\n    candidate = method(:skjkasdkd)\n    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))\n    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))\n    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))\n    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))\n    assert_equal(19, candidate.call([8191]))\n    assert_equal(19, candidate.call([8191, 123456, 127, 7]))\n    assert_equal(10, candidate.call([127, 97, 8192]))\n  end\nend\n"},{"task_id":"HumanEval_95","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Функсия бояд false баргардонад, агар ҳаши додашуда холӣ бошад. case ё ҳамаи калидҳо сатрҳо дар ҳарфи калон мебошанд, вагарна false бармегардонад. Агар hash дода шавад, баргардонидани true агар ҳамаи тугмаҳо сатрҳои дар  поёнӣ # >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n","canonical_solution":"def check_dict_case(dict)\n  return false if dict.empty?\n\n  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }\n  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }\n\n  lowercase_keys || uppercase_keys\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n"},{"task_id":"HumanEval_96","nl":"tgk_Cyrl","pl":"rb","prompt":"барои мисол: ададҳои бутун, ки ададҳои аввалия ва камтар аз n мебошанд. Функсияеро амалӣ кунед, ки адади мукаммали ғайриманфиро мегирад ва массиви n-и аввалро бармегардонад .# >>> count_up_to.call(5)\n# [2, 3]\n# >>> count_up_to.call(11)\n# [2, 3, 5, 7]\n# >>> count_up_to.call(0)\n# []\n# >>> count_up_to.call(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to.call(1)\n# []\n# >>> count_up_to.call(18)\n# [2, 3, 5, 7, 11, 13, 17]\ndef count_up_to(n)\n","canonical_solution":"def count_up_to(n)\n  return [] if n <= 2\n  primes = []\n  (2...n).each do |num|\n    is_prime = true\n    (2..Math.sqrt(num)).each do |i|\n      if num % i == 0\n        is_prime = false\n        break\n      end\n    end\n    primes << num if is_prime\n  end\n  primes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([], candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"},{"task_id":"HumanEval_97","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Фарз кунед, ки вуруд ҳамеша дуруст аст.ҳосили рақамҳои воҳиди онҳо. Функсияро пур кунед, ки ду адади куллро мегирад ва # >>> multiply.call(148, 412)\n# 16\n# >>> multiply.call(19, 28)\n# 72\n# >>> multiply.call(2020, 1851)\n# 0\n# >>> multiply.call(14, -15)\n# 20\ndef multiply(a, b)\n","canonical_solution":"def multiply(a, b)\n  a_unit_digit = a.abs % 10\n  b_unit_digit = b.abs % 10\n  a_unit_digit * b_unit_digit\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_multiply\n    candidate = method(:multiply)\n    assert_equal(16, candidate.call(148, 412))\n    assert_equal(72, candidate.call(19, 28))\n    assert_equal(0, candidate.call(2020, 1851))\n    assert_equal(20, candidate.call(14, -15))\n    assert_equal(42, candidate.call(76, 67))\n    assert_equal(49, candidate.call(17, 27))\n    assert_equal(0, candidate.call(0, 1))\n    assert_equal(0, candidate.call(0, 0))\n  end\nend\n"},{"task_id":"HumanEval_98","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Бо назардошти сатри s, шумораи овозҳои калонро дар индексҳои ҷуфт ҳисоб кунед. # >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n","canonical_solution":"def count_upper(s)\n  vowels = ['A', 'E', 'I', 'O', 'U']\n  count = 0\n\n  s.chars.each_with_index do |char, index|\n    if index.even? && vowels.include?(char)\n      count += 1\n    end\n  end\n\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"EEEE\"))\n  end\nend\n"},{"task_id":"HumanEval_99","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо аз ду адади кулл, онро аз сифр дур кунед.ва ба он наздиктарин адади мукаммалро бармегардонад. Агар адад баробар дур бошад Функсияе эҷод кунед, ки арзиши (санҷ) -и рақамиро қабул кунад # >>> closest_integer.call(\"10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\ndef closest_integer(value)\n","canonical_solution":"def closest_integer(value)\n  number = value.to_f\n  if number > 0\n    (number + 0.5).floor\n  else\n    (number - 0.5).ceil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_100","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: i шумораи сангҳои сатҳи (i+1) -ро ифода мекунад.Шумораи сангҳои ҳар як сатҳро дар массив баргардонад, ки дар он элемент дар индекс - шумораи ҷуфт, агар n ҷуфт бошад. - шумораи нобаробари оянда агар n нобаробар бошад. Шумораи сангҳо дар сатҳи навбатӣ: Дар сатҳи аввал n санг мавҷуд аст.Бо назардошти як адади мусбати n, шумо бояд як қатор сангҳои n сатҳро созед.# >>> make_a_pile.call(3)\n# [3, 5, 7]\ndef make_a_pile(n)\n","canonical_solution":"def make_a_pile(n)\n  result = []\n  current_stones = n\n  n.times do\n    result << current_stones\n    current_stones += 2\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9, 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"},{"task_id":"HumanEval_101","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: барои тақсим кардани сатр ба калимаҳо ва баргардонидани массиви калимаҳо. Ба шумо як силсила калимаҳо бо аломатҳои аломатӣ ё фосилаҳо ҷудо карда мешавад. Вазифаи шумо ин аст:# >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n","canonical_solution":"def words_string(s)\n  s.split(\/[\\s,]+\/)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\", \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two, three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"ahmed     , gamal\"))\n  end\nend\n"},{"task_id":"HumanEval_102","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Агар чунин рақам вуҷуд надошта бошад, пас функсия бояд -1-ро баргардонад.бузургтарин адади мутлақи ҷуфт, ки дар доираи [x, y] дохил карда мешавад.Ин функсия ду адади мусбатро x ва y мегирад ва  -ро бармегардонад.# >>> choose_num.call(12, 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n","canonical_solution":"def choose_num(x, y)\n  return -1 if x > y\n  # Start looking from the largest number\n  max_even = y.even? ? y : y - 1\n  # Iterate downwards to find the biggest even number\n  max_even.downto(x) do |n|\n    return n if n.even?\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33, 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28, candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1, candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\nend\n"},{"task_id":"HumanEval_103","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Агар n аз m калонтар бошад, баргардонидани -1. Ҷавобро ба адади пурраи наздиктарин мудаввар кунед ва онро ба дуӣ табдил диҳед.миёнаи ададҳои кулл аз n то m (аз ҷумла n ва m).Ба шумо ду адади мусбати n ва m дода мешавад, ва вазифаи шумо ин аст, ки  -ро ҳисоб кунед.# >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>> rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n# >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n","canonical_solution":"def rounded_avg(n, m)\n  return -1 if n > m\n\n  sum = (n..m).reduce(:+)\n  count = m - n + 1\n  average = (sum.to_f \/ count).round\n  \"0b\" + average.to_i.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1, 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996, 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362, 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7, 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5, 5))\n  end\nend\n"},{"task_id":"HumanEval_104","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Эзоҳ: Массиви баргардонидашуда бояд бо тартиби афзоянда тартиб дода шавад.унсурҳое, ки рақами ҷуфт надоранд.Бо назардошти массиви ададҳои мусбати бутун x. массиви тартибдодашудаи ҳамаи # >>> unique_digits.call([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n","canonical_solution":"def unique_digits(x)\n  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31, 135], candidate.call([135, 103, 31]))\n  end\nend\n"},{"task_id":"HumanEval_105","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: \"Як\", \"ду\", \"се\", \"чор\", \"панҷ\", \"шаш\", \"ҳафт\", \"ҳашт\", \"наҳор\". массиви ҳосилшударо баръакс кунед ва пас ҳар як рақамро бо номи мувофиқи он аз  иваз кунед.Бо назардошти массиви ададҳои бутун, ададҳои бутунро, ки аз 1 то 9 дохил мешаванд, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length.call([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n","canonical_solution":"def by_length(arr)\n  number_names = {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\"\n  }\n\n  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse\n  filtered_sorted_reversed.map { |num| number_names[num] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"], candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"], candidate.call([9, 4, 8]))\n  end\nend\n"},{"task_id":"HumanEval_106","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: омили i зарбаи ададҳои аз 1 то i (1 * 2 * ... * i) мебошад.i аз 1 сар мешавад.ё ҷамъбасти рақамҳои аз 1 то i. ва массиви андозаи n-ро бармегардонад, ки арзиши унсур дар индекси i омили i бошад, агар i ҷуфт бошад Функсияи f-ро, ки n-ро ҳамчун параметр мегирад, амалӣ кунед, # >>> f.call(5)\n# [1, 2, 6, 24, 15]\ndef f(n)\n","canonical_solution":"def f(n)\n  (1..n).map do |i|\n    if i.even?\n      (1..i).inject(:*) || 1\n    else\n      (1..i).inject(:+)\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([1, 2, 6, 24, 15], candidate.call(5))\n    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))\n    assert_equal([1], candidate.call(1))\n    assert_equal([1, 2, 6], candidate.call(3))\n  end\nend\n"},{"task_id":"HumanEval_107","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисоли 1: palindromes адади пурра, ки дар доираи ((1, n), ба он дохил мешаванд. Бо назардошти як адади мусбати n, массиверо баргардонед, ки шумораи ададҳои ҷуфт ва нобаробарро дорад.# >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\ndef even_odd_palindrome(n)\n","canonical_solution":"def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n\n  [even_count, odd_count]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_108","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан, -123 рақамҳои -1, 2 ва 3 дорад.Агар адад манфӣ бошад, пас рақами аввалини он манфӣ хоҳад буд: шумораи унсурҳое, ки ҷамъи рақамҳои онҳо > 0 аст. Функсияи count_nums нависед, ки массиви ададҳои пурраро мегирад ва бармегардонад # >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n# 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n","canonical_solution":"def count_nums(arr)\n  arr.count do |num|\n    num.to_s.chars.map(&:to_i).sum > 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0, 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_109","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Эзоҳ: Массиви додашуда элементҳои ягона дорад. Агар массиви додашуда холӣ бошад, пас true -ро баргардонед. пас рост баргардонед ё дурӯғ баргардонед. Агар имконпазир бошад, ки массиви тартибдодашударо бо иҷрои амали болоӣ ба даст орем мавқеи ибтидоӣ дар массив, яъне индекси 0. ба                  Як амалиёти ҳаракати рост маънои ҳаракати ҳамаи унсурҳои массивро бо як Шумо иҷозат додаед, ки ҳар чанд маротиба амалиёти ҳаракати ростро иҷро кунед.амалиёти зеринро дар массиви додашуда иҷро кунед: массивро бо тартиби камнашаванда бо иҷрои рақамҳо дар массив ба таври тасодуфӣ тартиб дода мешаванд. Вазифаи шумо муайян кардани он аст, ки оё Мо массиви 'arr' аз N ададҳои бутун arr[1], arr[2], ..., arr[N] дорем. # >>> move_one_ball.call([3, 4, 5, 1, 2])\n# true\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball.call([3, 5, 4, 1, 2])\n# false\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\ndef move_one_ball(arr)\n","canonical_solution":"def move_one_ball(arr)\n  return true if arr.empty?\n\n  n = arr.size\n  count_rotation_point = 0\n  rotation_index = -1\n\n  (0...n).each do |i|\n    next_index = (i + 1) % n\n    if arr[i] > arr[next_index]\n      count_rotation_point += 1\n      rotation_index = next_index\n    end\n  end\n\n  count_rotation_point <= 1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_move_one_ball\n    candidate = method(:move_one_ball)\n    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))\n    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))\n    assert_equal(false, candidate.call([4, 3, 1, 2]))\n    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))\n    assert_equal(true, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_110","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Дар акси ҳол, \"НЕ\" -ро баргардонед.ҳамаи унсурҳои lst1 баробар бошанд, \"YES\" -ро баргардонед. Агар имкон бошад, ки байни элементҳои lst1 ва lst2 иваз карда шавад, то Дар бораи шумораи унсурҳои табодули байни lst1 ва lst2 маҳдудият вуҷуд надорад. байни онҳо барои сохтани массиви lst1 танҳо аз рақамҳои ҷуфт.ва муайян мекунад , ки оё иваз кардани унсурҳо имконпазир аст Дар ин масъала, шумо функсияеро амалӣ мекунед, ки ду массиви рақамҳоро мегирад, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\ndef exchange(lst1, lst2)\n","canonical_solution":"def exchange(lst1, lst2)\n  # Check if lst1 already consists solely of even numbers\n  return \"YES\" if lst1.all?(&:even?)\n\n  # Check if there are at least as many even numbers in lst2\n  # as there are odd numbers in lst1\n  odd_count_lst1 = lst1.count(&:odd?)\n  even_count_lst2 = lst2.count(&:even?)\n\n  odd_count_lst1 <= even_count_lst2 ? \"YES\" : \"NO\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_exchange\n    candidate = method(:exchange)\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))\n    assert_equal(\"NO\", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))\n    assert_equal(\"YES\", candidate.call([5, 7, 3], [2, 6, 4]))\n    assert_equal(\"NO\", candidate.call([5, 7, 3], [2, 6, 3]))\n    assert_equal(\"NO\", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\n    assert_equal(\"YES\", candidate.call([100, 200], [200, 200]))\n  end\nend\n"},{"task_id":"HumanEval_111","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Агар якчанд ҳарфҳо якхела бошанд, ҳамаи онҳоро баргардонед. аз ҳарф бо такрори бештар ва дорои шумораи мувофиқ. Бо назардошти сатр, ки ҳарфҳои хурди алоҳида аз аломатҳои алоҳидаро ифода мекунад, як hash баргардонед # >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n","canonical_solution":"def histogram(test)\n  return {} if test.empty?\n\n  count = Hash.new(0)\n\n  test.split.each do |char|\n    count[char] += 1\n  end\n\n  max_count = count.values.max\n  count.select { |_, value| value == max_count }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4}, candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_112","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол Шумо бояд массиви дорои сатри натиҷа ва true\/false барои санҷиш баргардонед. Силсилаи сатрро палиндром меноманд, агар он ба қафо ва пеш баробар хонда шавад. пас санҷед, ки оё сатри натиҷа палиндром аст. Мо ду сатри s ва c дорем, шумо бояд хамаи аломатхои s-ро, ки ба хар як аломати c баробар аст, хорич кунед.Вазифа # >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n# >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s, c)\n","canonical_solution":"def reverse_delete(s, c)\n  # Remove all characters in c from s\n  filtered_string = s.delete(c)\n  \n  # Check if the filtered string is a palindrome\n  is_palindrome = filtered_string == filtered_string.reverse\n  \n  # Return the result array\n  [filtered_string, is_palindrome]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\", \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n    assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true], candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"mamma\", \"mia\"))\n  end\nend\n"},{"task_id":"HumanEval_113","nl":"tgk_Cyrl","pl":"rb","prompt":"аз рақамҳои нобаробар дар сатри i'th вуруди. сатри i вуруди. \" ки дар он ҳамаи i бояд бо рақам иваз карда шаванд Ҳар як унсури i баробари шумораи унсурҳои нобаробар дар Бо назардошти массиви сатрҳо, ки ҳар як сатр танҳо аз рақамҳо иборат аст, массивро баргардонед. # >>> odd_count.call([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n","canonical_solution":"def odd_count(lst)\n  lst.map do |num_str|\n    count = num_str.count('13579')\n    \"the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\", \"314\"]))\n  end\nend\n"},{"task_id":"HumanEval_114","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол аз nums. Бо назардошти массиви ададҳои бутун, миқдори ҳадди ақали ҳар як зермассиви холӣ # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n","canonical_solution":"def minSubArraySum(nums)\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    if current_sum > 0\n      current_sum = num\n    else\n      current_sum += num\n    end\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10, candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1, candidate.call([1, -1]))\n  end\nend\n"},{"task_id":"HumanEval_115","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисоли 1: Шумораи маротибае, ки ба шумо лозим аст, ки бухорҳоро поён кунед.Вазифаи шумо ин аст, ки бо истифода аз буғҳо чоҳҳоро холӣ кунед.ва ҳамаи зарфҳо дорои ҳамон иқтидор мебошанд.Ҳар як чоҳ як косаи мувофиқ дорад, ки онро барои гирифтани об истифода бурдан мумкин аст, ва ҳар як 1 дар сатр як воҳиди обро ифода мекунад. Ба шумо як шабакаи росткунҷаи чоҳҳо дода мешавад. Ҳар як сатр як чоҳро ифода мекунад, # >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n","canonical_solution":"def max_fill(grid, capacity)\n  total_water_units = grid.flatten.sum\n  (total_water_units.to_f \/ capacity).ceil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))\n  end\nend\n"},{"task_id":"HumanEval_116","nl":"tgk_Cyrl","pl":"rb","prompt":"Он бояд чунин амалӣ карда шавад: Барои шумораи монанд аз якҳо, дар асоси арзиши даҳӣ тартиб диҳед. шумораи якҳо дар намоиши дуӣ дар тартиби болоравӣ. Дар ин ката шумо бояд массиви ададҳои ѓайриманфӣ мувофиқи # >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\ndef sort_array(arr)\n","canonical_solution":"def sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"},{"task_id":"HumanEval_117","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Эзоҳ: шумо метавонед тахмин кунед, ки сатри вуруд танҳо ҳарфҳо ва фосилаҳоро дар бар мегирад. Агар сатр s холӣ бошад, пас функсия бояд массиви холӣ баргардонад. n ҳамсадоҳо, ба тартиби ин калимаҳо дар сатри s пайдо мешаванд. функсияе, ки массиви ҳамаи калимаҳоро аз сатрҳои s, ки дақиқан  доранд, бармегардонад.Бо назардошти сатри s ва адади табиии n, ба шумо супориш дода шудааст, ки амалӣ кунед # >>> select_words.call(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words.call(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words.call(\"simple white space\", 2)\n# []\n# >>> select_words.call(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words.call(\"Uncle sam\", 3)\n# [\"Uncle\"]\ndef select_words(s, n)\n","canonical_solution":"def select_words(s, n)\n  vowels = \"aeiouAEIOU\"\n  words = s.split\n  words.select do |word|\n    consonant_count = word.chars.count { |char| !vowels.include?(char) }\n    consonant_count == n\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([], candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"a b c d e f\", 1))\n  end\nend\n"},{"task_id":"HumanEval_118","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Шумо метавонед гумон кунед, ки сатри додашуда танҳо ҳарфи англисиро дар бар мегирад. ҳар як овозро, ки ба шартҳои болоӣ мувофиқат мекунад, ёбед.Хушторҳо дар ибтидо ва охири ҳисоб карда намешаванд. Агар шумо онро надошта бошед, сатри холӣ баргардонед.ду ҳамсадо аз тарафи рости калима (дар мавридҳои асосӣ). Ба шумо як калима дода мешавад. Вазифаи шумо дарёфти ҳарфи наздиктарин аст, ки дар байни он # >>> get_closest_vowel.call(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n","canonical_solution":"def get_closest_vowel(word)\n  vowels = \"aeiouAEIOU\"\n  (1...word.length - 1).reverse_each do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n      return word[i]\n    end\n  end\n  return \"\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\", candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"Above\"))\n  end\nend\n"},{"task_id":"HumanEval_119","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Агар роҳи сохтани сатри хуб бошад, \"Бале\" баргардонед ва дар акси ҳол \"Не\" баргардонед.\" (()) \" чунин нест. Масалан: сатри '(())))) хуб аст, дар ҳоле ки сатри Сатри S хуб ҳисобида мешавад, агар ва танҳо агар ҳамаи қафасҳо дар S баъзе тартиб, ки сатри натиҷа хуб хоҳад буд.Вазифаи шумо санҷидани он аст, ки оё имкон дорад, ки ду сатрро дар танҳо дар байни ду дубанд \" ((\" ё дубандҳои наздик \") \".Ба шумо массиви ду сатр дода мешавад, ки ҳарду сатр аз кушода иборат аст.# >>> match_parens.call([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n","canonical_solution":"def match_parens(lst)\n  a, b = lst\n\n  # Define a helper method to check if a string is balanced\n  def balanced?(s)\n    count = 0\n    s.each_char do |c|\n      count += 1 if c == '('\n      count -= 1 if c == ')'\n      return false if count < 0\n    end\n    count == 0\n  end\n\n  # Check if either concatenation forms a good string\n  if balanced?(a + b) || balanced?(b + a)\n    \"Yes\"\n  else\n    \"No\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\")())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"(()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n    assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\")(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"},{"task_id":"HumanEval_120","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисоли 1: дарозии k бо шумораи k дар arr. Бо назардошти массиви arr аз ададҳои бутун ва адади мусбати k, массиви тартибдодашударо баргардонед # >>> maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n","canonical_solution":"def maximum(arr, k)\n  arr.sort.last(k).sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n    assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10], candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))\n  end\nend\n"},{"task_id":"HumanEval_121","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо Бо назардошти массиви ададҳои пурраи холӣ, ҷамъбасти ҳамаи унсурҳои нобаробарро, ки дар мавқеи ҷуфт ҳастанд, баргардонед. # >>> solution.call([5, 8, 7, 1])\n# 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24, 321])\n# 0\ndef solution(lst)\n","canonical_solution":"def solution(lst)\n  lst.each_with_index.reduce(0) do |sum, (val, idx)|\n    (idx.even? && val.odd?) ? sum + val : sum\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7, 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0, candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30, 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"},{"task_id":"HumanEval_122","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: ҷамъи унсурҳое, ки на бештар аз ду рақами аввалин k унсурҳои arr доранд. Бо назардошти массиви ғайри холӣ аз ададҳои бутун arr ва адади бутун k, баргардонед # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k)\n","canonical_solution":"def add_elements(arr, k)\n  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"},{"task_id":"HumanEval_123","nl":"tgk_Cyrl","pl":"rb","prompt":"get_odd_collatz(5) баргардонад [1, 5] # Ҷадвали collatz барои 5 [5, 16, 8, 4, 2, 1], аз ин рӯ рақамҳои нобаробар танҳо 1 ва 5 мебошанд. Масалан: 2. массиви баргардонидашуда бо тартиби афзоянда. 1. Collatz ((1) аст [1]. Эзоҳ: термини плюс 1. Тахмин ин аст, ки новобаста аз он ки арзиши n кадом аст, пайдарпай ҳамеша ба 1 мерасад.Агар ки кимиёи пешин нобарор бошад, кимиёи навбатӣ 3 маротиба кимиёи пешин аст.ки агар кимиёи қаблӣ ҷуфт бошад, кимиёи навбатӣ нисфи ба таври зерин: бо ҳар адади мусбати n оғоз кунед. Сипас ҳар як мӯҳлат аз  гирифта мешавад.Фарзияи Коллатс - фарзияи математикӣ аст, ки ба пайдарпайии муайяншуда дахл дорад.Бо назардошти як адади мусбати n, массиви тартибдодашударо баргардонед, ки дар он рақамҳои нобаробар дар пайдарпаии collatz мавҷуданд. # >>> get_odd_collatz.call(5)\n# [1, 5]\ndef get_odd_collatz(n)\n","canonical_solution":"def get_odd_collatz(n)\n  collatz_sequence = []\n  while n != 1\n    collatz_sequence << n if n.odd?\n    if n.even?\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n  end\n  collatz_sequence << 1 if n == 1\n\n  collatz_sequence.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_odd_collatz\n    candidate = method(:get_odd_collatz)\n    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))\n    assert_equal([1, 5], candidate.call(5))\n    assert_equal([1, 3, 5], candidate.call(12))\n    assert_equal([1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_124","nl":"tgk_Cyrl","pl":"rb","prompt":"4. Сана бояд дар формати: mm-dd-yyyy бошад.3. Мӯҳлат набояд аз 1 камтар ё аз 12 зиёд бошад.2. Шумораи рӯзҳои на камтар аз 1 ё зиёдтар аз 31 рӯз барои моҳҳои 1,3,5,7,8,10,12. Ва шумораи рӯзҳои на камтар аз 1 ё зиёдтар аз 30 рӯз барои моҳҳои 4,6,9,11. Ва, шумораи рӯзҳои на камтар аз 1 ё зиёдтар аз 29 барои моҳ 2. 1. Силсилаи сана холӣ нест.Санаи эътибор дорад, агар ҳамаи қоидаҳои зерин риоя карда шаванд: Агар сана дуруст бошад, рост баргардонад, дар акси ҳол дурӯғ аст. Шумо бояд функсияеро нависед, ки сатри санаи додашударо тасдиқ мекунад ва # >>> valid_date.call(\"03-11-2000\")\n# true\n# >>> valid_date.call(\"15-01-2012\")\n# false\n# >>> valid_date.call(\"04-0-2040\")\n# false\n# >>> valid_date.call(\"06-04-2020\")\n# true\n# >>> valid_date.call(\"06\/04\/2020\")\n# false\ndef valid_date(date)\n","canonical_solution":"def valid_date(date)\n  return false if date.nil? || date.empty?\n  \n  # Check if the date format is correct\n  match = date.match(\/^(\\d{2})-(\\d{2})-(\\d{4})$\/)\n  return false unless match\n  \n  month, day, year = match.captures.map(&:to_i)\n  \n  # Check if month is valid\n  return false if month < 1 || month > 12\n  \n  # Check if day is valid according to the month\n  case month\n  when 1, 3, 5, 7, 8, 10, 12\n    return day >= 1 && day <= 31\n  when 4, 6, 9, 11\n    return day >= 1 && day <= 30\n  when 2\n    return day >= 1 && day <= 29\n  else\n    return false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_valid_date\n    candidate = method(:valid_date)\n    assert_equal(true, candidate.call(\"03-11-2000\"))\n    assert_equal(false, candidate.call(\"15-01-2012\"))\n    assert_equal(false, candidate.call(\"04-0-2040\"))\n    assert_equal(true, candidate.call(\"06-04-2020\"))\n    assert_equal(true, candidate.call(\"01-01-2007\"))\n    assert_equal(false, candidate.call(\"03-32-2011\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"04-31-3000\"))\n    assert_equal(true, candidate.call(\"06-06-2005\"))\n    assert_equal(false, candidate.call(\"21-31-2000\"))\n    assert_equal(true, candidate.call(\"04-12-2003\"))\n    assert_equal(false, candidate.call(\"04122003\"))\n    assert_equal(false, candidate.call(\"20030412\"))\n    assert_equal(false, candidate.call(\"2003-04\"))\n    assert_equal(false, candidate.call(\"2003-04-12\"))\n    assert_equal(false, candidate.call(\"04-2003\"))\n  end\nend\n"},{"task_id":"HumanEval_125","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо алифбо, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 бояд дар хотимаҳои ',' ҷудо карда шавад, агар хотимаҳо мавҷуд набошанд, шумо бояд шумораи ҳарфҳои хурд бо тартиби нобаробарро дар  баргардонедБо назардошти сатри калимаҳо, массиви калимаҳоро бо фазои сафед ҷудо кунед, агар дар матни шумо фазои сафед вуҷуд надошта бошад.# >>> split_words.call(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n","canonical_solution":"def split_words(txt)\n  if txt.include?(' ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }\n    return odd_count\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2, candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n    assert_equal(0, candidate.call(\"\"))\n  end\nend\n"},{"task_id":"HumanEval_126","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо шумора, баргардонидани дурӯғ аст. Ҳеҷ рақами манфӣ ва танҳо ададҳои мукаммалро қабул накунед.дар тартиби болоравӣ. Агар массив зиёда аз 1 дубликати ҳамонро дошта бошад Бо назардошти массиви рақамҳо, баргардонед, ки онҳо тартиб дода шудаанд ё не.# >>> is_sorted.call([5])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>> is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n","canonical_solution":"def is_sorted(lst)\n  lst.each_cons(2).with_index do |(a, b), index|\n    return false if a > b\n    return false if index < lst.length - 2 && a == b && lst[index + 2] == b\n  end\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true, candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false, candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_127","nl":"tgk_Cyrl","pl":"rb","prompt":"[оғоз\/оғоз] намунаҳо: Агар ин ду фосила бо ҳам мувофиқ набошанд, \"НЕ\" -ро баргардонед.дар акси ҳол, \"НЕ\" -ро баргардонед.Агар дарозии буриши рақами якум бошад, \"ҲА\", ки дарозии он 1 аст, ки адади аввалия нест.Мисол, буриши фосилаҳои (1, 3), (2, 4) (2, 3) фосилаи рақами якум аст.Вазифаи шумо ин аст, ки муайян кунед, ки оё дарозии буриши ин ду Барои ҳар як интервали додашуда, тахмин мезанем, ки оғози он аз охири он камтар ё баробар аст. ҳам ибтидо ва ҳам хотимаро дар бар мегирад. Интервалҳои додашуда бастаанд, ки маънои онро дорад, ки интервал (оғоз, хотима) ки ҳар як фосила як ҷуфти ададҳои мукаммал аст. Масалан, фосила = (оғоз, хотима) = (1, 2).Ба шумо ду фосила дода мешавад.# >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\ndef intersection(interval1, interval2)\n","canonical_solution":"def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n\n  if intersection_start > intersection_end\n    return \"NO\"\n  end\n\n  intersection_length = intersection_end - intersection_start + 1\n\n  return \"YES\" if prime?(intersection_length)\n\n  \"NO\"\nend\n\ndef prime?(n)\n  return false if n <= 1\n  return true if n == 2 || n == 3\n\n  (2..Math.sqrt(n).to_i).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1, 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2, 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\", candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2, -2], [-3, -2]))\n  end\nend\n"},{"task_id":"HumanEval_128","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Эзоҳ: барои arr холӣ nil-ро баргардонед. аз ҳар як рақами массив, ки бо 1, -1 ё 0 ифода карда мешавад.љамъи бузургињои ададњои њамагирої, ки бо мањсули њамаи аломатњо Шумо массиви arr ададҳои бутунро доред ва шумо бояд баргардонед.# >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n# >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n","canonical_solution":"def prod_signs(arr)\n  return nil if arr.empty?\n  \n  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }\n  sum_magnitudes = arr.map(&:abs).sum\n  \n  product_signs * sum_magnitudes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"},{"task_id":"HumanEval_129","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Массиви тартибдодаи арзишҳои ҳуҷайраҳоро, ки роҳи ҳадди ақал аз он мегузарад, баргардонад. Ин кафолат медиҳад, ки ҷавоб беназир аст. lst_A[j] = lst_B[j]. Чунон ки lst_A[i] < lst_B[i] ва барои ҳар як j (1 <= j < i) мо аз lst_B, ба ибораи дигар, индекси адади i (1 <= i <= k)  вуҷуд дорадба воситаи (биёед онҳоро lst_A ва lst_B ном барем), lst_A аз ҷиҳати луғавӣ камтар аст баъди сохтани массивҳои тартибдодашудаи арзишҳо дар ҳуҷайраҳое, ки A ва B Роҳи A (дарозии k) аз роҳи B (дарозии k) камтар ҳисобида мешавад, агар Шумо НЕ КУНЕД, ки аз шабакаи интернетӣ дур шавед.ҳатман фарқ мекунанд).Лутфан қайд кунед, ки роҳи дарозии k маънои ба маҳз k ҳуҷайраҳо рафтанро дорад (на  мобилӣба ибораи дигар, шумо метавонед ба ҳуҷайраҳое, ки бо шумо  ҷорӣ аз ҳар як ҳуҷайра, ва дар ҳар як қадам шумо метавонед ба ҳар як ҳуҷайраҳои ҳамсоя ҳаракат, Шумо бояд роҳи ҳадди ақали дарозии k-ро дар шабака пайдо кунед. Шумо метавонед оғоз кунед.inclusive дар ҳуҷайраҳои шабака як маротиба пайдо мешавад. ҳар як ҳуҷайраи шабака арзише дорад. Ҳар як адади мукаммал дар доираи [1, N * N] Бо назардошти шабака бо N сатр ва N сутун (N >= 2) ва адади мусбати k, # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid, k)\n","canonical_solution":"def minPath(grid, k)\n  n = grid.size\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  min_path = nil\n\n  n.times do |i|\n    n.times do |j|\n      queue = [[[i, j], [grid[i][j]]]]\n      until queue.empty?\n        position, path = queue.shift\n        if path.size == k\n          min_path = path if min_path.nil? || path < min_path\n          next\n        end\n        directions.each do |dx, dy|\n          x, y = position[0] + dx, position[1] + dy\n          if x.between?(0, n-1) && y.between?(0, n-1)\n            queue.push([[x, y], path + [grid[x][y]]])\n          end\n        end\n      end\n    end\n  end\n  min_path\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"},{"task_id":"HumanEval_130","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: аввалин n + 1 ададҳои пайдарпайи Трибоначчи. Шумо як адади пурраи ғайри манфӣ n мегиред, шумо бояд массиви  -ро баргардонед.= 2 + 3 + 3 = 8 tri(3) = tri(2) + tri(1) + tri(4) tri(4) = 3 tri(2) = 1 + (2 \/ 2) = 2 Масалан: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), агар n нодир бошад. tri ((n) = 1 + n \/ 2, агар n ҷуфт бошад. tri(1) = 3 Ҷадвали Трибоначчи бо такрори: Аммо, он чизе ки мардум намедонанд, ин пайдарпайии Трибоначчи аст.Ҳама пайдарпайии Фибоначчиро медонанд, онро математикҳо дар соли # >>> tri.call(3)\n# [1, 3, 2, 8]\ndef tri(n)\n","canonical_solution":"def tri(n)\n  sequence = [1, 3]\n  \n  (2..n).each do |i|\n    if i.even?\n      sequence[i] = 1 + i \/ 2\n    else\n      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0\n    end\n  end\n  \n  sequence[0..n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n    assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_131","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Агар ҳамаи рақамҳо ҷуфт бошанд, 0-ро баргардонед. Бо назардошти як адади мусбати n, ҳосили рақамҳои нобаробарро баргардонед. # >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n# 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n","canonical_solution":"def digits(n)\n  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }\n  return 0 if odd_digits.empty?\n  odd_digits.reduce(:*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5, candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5, candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625, candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"},{"task_id":"HumanEval_132","nl":"tgk_Cyrl","pl":"rb","prompt":"ки дар он ҳадди аққал як қафас дар зерқатор ҷойгир аст. Функсия бояд true баргардонад, агар ва танҳо агар як навбати дурусти камарбандҳо вуҷуд дошта бошад.Функсияе эҷод кунед, ки ҳамчун вуруди сатр мегирад, ки танҳо камарбандҳои мураббаъро дар бар мегирад. # >>> is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n# false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n# false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\")\n# true\ndef is_nested(string)\n","canonical_solution":"def is_nested(string)\n  stack = []\n  has_nested = false\n\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n    elsif char == ']'\n      if stack.empty?\n        return false\n      end\n      stack.pop\n      has_nested = true if stack.any?\n    end\n  end\n\n  has_nested\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false, candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n    assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false, candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n    assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"[[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"))\n  end\nend\n"},{"task_id":"HumanEval_133","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: ҳар як унсури массивро аввал ба int ((Ceiling)) болоӣ давр занед.Шумо бояд суммаи ададҳои квадратиро дар массиви додашуда баргардонед, Шумо массиви рақамҳоро мегиред.# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0, 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4, 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map { |num| (num.ceil)**2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0, 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))\n  end\nend\n"},{"task_id":"HumanEval_134","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Эзоҳ: \"калима\" гурӯҳи аломатҳоест, ки бо фосила ҷудо карда шудаанд. қисми калима ва дар акси ҳол дурӯғ аст.аз сатри додашуда аломати алифбоӣ аст ва  нестФунксияе эҷод кунед , ки агар охирин аломат  бошад, true -ро баргардонад# >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n","canonical_solution":"check_if_last_char_is_a_letter = ->(txt) {\n  return false if txt.strip.empty?\n  words = txt.strip.split(' ')\n  last_word = words.last\n  return false if last_word.empty?\n  last_char = last_word[-1]\n\n  last_char =~ \/[a-zA-Z]\/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')\n}","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false, candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false, candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false, candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple pi e \"))\n  end\nend\n"},{"task_id":"HumanEval_135","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: арзишҳои дубора. чунин унсур вуҷуд надорад, пас баргардонида мешавад -1. Массиви додашуда ро дар бар намегирадаз унсури бевосита пешинааш калонтар ё баробар нест. Агар Функсияе эҷод кунед, ки бузургтарин индекси унсуреро, ки # >>> can_arrange.call([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange.call([1, 2, 3])\n# -1\ndef can_arrange(arr)\n","canonical_solution":"def can_arrange(arr)\n  (1...arr.length).reverse_each do |i|\n    return i if arr[i] < arr[i - 1]\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_can_arrange\n    candidate = method(:can_arrange)\n    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))\n    assert_equal(-1, candidate.call([1, 2, 4, 5]))\n    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))\n    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))\n    assert_equal(-1, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_136","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Агар ададҳои мусбат ё манфӣ набошанд, онҳоро ҳамчун nil баргардонед.аз ададҳои мусбати пурра дар массив. калонтарин адади мутлақ, ва \"b\" хурдтарин аст Функсияе эҷод кунед, ки массиви (a, b) -ро баргардонад, ки дар он 'a'  аст.# >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n# [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n","canonical_solution":"def largest_smallest_integers(lst)\n  largest_negative = nil\n  smallest_positive = nil\n  \n  lst.each do |num|\n    if num < 0\n      largest_negative = num if largest_negative.nil? || num > largest_negative\n    elsif num > 0\n      smallest_positive = num if smallest_positive.nil? || num < smallest_positive\n    end\n  end\n  \n  [largest_negative, smallest_positive]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil, nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))\n  end\nend\n"},{"task_id":"HumanEval_137","nl":"tgk_Cyrl","pl":"rb","prompt":"Эзоҳ: Агар адади воқеӣ ҳамчун сатр тасвир карда шавад, нуқтаи сайёр метавонад . ё ,  бошад.Агар арзишҳо баробар бошанд, nil -ро баргардонед. ададҳои воқеӣ ва тағйирёбандаи калонтарро дар навъи тағйирёбандаи додашуда бармегардонад. Функсияе эҷод кунед, ки ададҳои пурра, парвозкунанда ё сатрҳои намояндагиро қабул кунад.# >>> compare_one.call(1, 2.5)\n# 2.5\n# >>> compare_one.call(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one.call(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one.call(\"1\", 1)\n# nil\ndef compare_one(a, b)\n","canonical_solution":"def compare_one(a, b)\n  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')\n  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')\n\n  if a.is_a?(String) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Float)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Float)\n    a = a.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Integer)\n    b = b.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Float)\n    b = b.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(String)\n    a = a.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  else\n    return nil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare_one\n    candidate = method(:compare_one)\n    assert_equal(2, candidate.call(1, 2))\n    assert_equal(2.5, candidate.call(1, 2.5))\n    assert_equal(3, candidate.call(2, 3))\n    assert_equal(6, candidate.call(5, 6))\n    assert_equal(\"2,3\", candidate.call(1, \"2,3\"))\n    assert_equal(\"6\", candidate.call(\"5,1\", \"6\"))\n    assert_equal(\"2\", candidate.call(\"1\", \"2\"))\n    assert_equal(nil, candidate.call(\"1\", 1))\n  end\nend\n"},{"task_id":"HumanEval_138","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол Арзёбӣ кунед, ки оё адади додашуда n метавонад ҳамчун ҷамъи дақиқан 4 адади мусбати ҷуфт навишта шавад.# >>> is_equal_to_sum_even.call(4)\n# false\n# >>> is_equal_to_sum_even.call(6)\n# false\n# >>> is_equal_to_sum_even.call(8)\n# true\ndef is_equal_to_sum_even(n)\n","canonical_solution":"def is_equal_to_sum_even(n)\n  return false if n < 8\n  n.even?\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_equal_to_sum_even\n    candidate = method(:is_equal_to_sum_even)\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(8))\n    assert_equal(true, candidate.call(10))\n    assert_equal(false, candidate.call(11))\n    assert_equal(true, candidate.call(12))\n    assert_equal(false, candidate.call(13))\n    assert_equal(true, candidate.call(16))\n  end\nend\n"},{"task_id":"HumanEval_139","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: дар он n > 0 бразилияи_факториалӣ (n) = n! * (n-1)! * (n-2)! * ... * 1! Факториали Бразилия чунин муайян карда мешавад: # >>> special_factorial.call(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\ndef special_factorial(n)\n","canonical_solution":"def special_factorial(n)\n  return 1 if n <= 1\n  (1..n).inject(1) { |product, i| product * factorial(i) }\nend\n\ndef factorial(num)\n  return 1 if num <= 1\n  (2..num).inject(1, :*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n    assert_equal(1, candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_140","nl":"tgk_Cyrl","pl":"rb","prompt":"пас ҳамаи фосилаҳои пайдарҳамро бо -  иваз кунедва агар сатр зиёда аз 2 фосилаи пайдарҳам дошта бошад, Дар сурати гирифтани сатри матн, ҳамаи ҷойҳои онро бо аломатҳои зерин иваз кунед, # >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n","canonical_solution":"def fix_spaces(text)\n  text.strip.gsub(\/\\s{3,}\/, '-').gsub(' ', '_')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2 2 mple\"))\n  end\nend\n"},{"task_id":"HumanEval_141","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: - Силсилаи зер пас аз нуқта бояд яке аз инҳо бошад: ['txt', 'exe', 'dll'] алифбои лотинӣ (\"a\"-\"z\" ва \"A\"-\"Z\"). - Силсилаи зербаъд аз нуқта набояд холӣ бошад ва он бо ҳарфи  сар мешавад.- Номи файл маҳз як нуқтаро дар бар мегирад.- Дар номи парванда набояд зиёда аз се рақам (\"0\" - \"9\") бошад. риоя карда мешаванд: Номи файл танҳо дар сурате эътибор дорад, ки ҳамаи шартҳои зерин \"Бале\" агар номи файл дуруст бошад ва дар акси ҳол \"Не\" бармегардонад. Функсияе эҷод кунед, ки сатри намояндаи номи файлро мегирад ва  -ро бармегардонад.# >>> file_name_check.call(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check.call(\"1example.dll\")\n# \"No\"\ndef file_name_check(file_name)\n","canonical_solution":"def file_name_check(file_name)\n  # Check if there's exactly one dot in the filename\n  return 'No' unless file_name.count('.') == 1\n  \n  # Split the filename into the name and extension\n  name, extension = file_name.split('.')\n  \n  # Check if the name part starts with a letter\n  return 'No' if name.empty? || !name[0].match?(\/[a-zA-Z]\/)\n  \n  # Check if the extension is valid\n  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)\n  \n  # Count digits in the file name\n  digit_count = file_name.count(\"0-9\")\n  \n  # Check if digits are more than three\n  return 'No' if digit_count > 3\n  \n  'Yes'\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_file_name_check\n    candidate = method(:file_name_check)\n    assert_equal(\"Yes\", candidate.call(\"example.txt\"))\n    assert_equal(\"No\", candidate.call(\"1example.dll\"))\n    assert_equal(\"No\", candidate.call(\"s1sdf3.asd\"))\n    assert_equal(\"Yes\", candidate.call(\"K.dll\"))\n    assert_equal(\"Yes\", candidate.call(\"MY16FILE3.exe\"))\n    assert_equal(\"No\", candidate.call(\"His12FILE94.exe\"))\n    assert_equal(\"No\", candidate.call(\"_Y.txt\"))\n    assert_equal(\"No\", candidate.call(\"?aREYA.exe\"))\n    assert_equal(\"No\", candidate.call(\"\/this_is_valid.dll\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.wow\"))\n    assert_equal(\"Yes\", candidate.call(\"this_is_valid.txt\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.txtexe\"))\n    assert_equal(\"No\", candidate.call(\"#this2_i4s_5valid.ten\"))\n    assert_equal(\"No\", candidate.call(\"@this1_is6_valid.exe\"))\n    assert_equal(\"No\", candidate.call(\"this_is_12valid.6exe4.txt\"))\n    assert_equal(\"No\", candidate.call(\"all.exe.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"I563_No.exe\"))\n    assert_equal(\"Yes\", candidate.call(\"Is3youfault.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"no_one#knows.dll\"))\n    assert_equal(\"No\", candidate.call(\"1I563_Yes3.exe\"))\n    assert_equal(\"No\", candidate.call(\"I563_Yes3.txtt\"))\n    assert_equal(\"No\", candidate.call(\"final..txt\"))\n    assert_equal(\"No\", candidate.call(\"final132\"))\n    assert_equal(\"No\", candidate.call(\"_f4indsartal132.\"))\n    assert_equal(\"No\", candidate.call(\".txt\"))\n    assert_equal(\"No\", candidate.call(\"s.\"))\n  end\nend\n"},{"task_id":"HumanEval_142","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: воридотҳои массивро тағир диҳед, ки индексҳои онҳо якчанд 3 ё 4 нестанд. Функсия пас маҷмӯи ҳамаи воридотҳоро бармегардонад. функсияи  бо рақами  ба  баробар аст ва агар индекси он якчанд 4 бошад,  ба  баробар аст.Ин функсия массиви ададҳои пурраро мегирад. Барои ҳамаи воридҳо дар массив, функсия воридшавии адади пурраро квадрати мекунад, агар индекси он  бошад.\" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map.with_index do |num, index|\n    if index % 3 == 0\n      num ** 2\n    elsif index % 4 == 0\n      num ** 3\n    else\n      num\n    end\n  end.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(6, candidate.call([1, 2, 3]))\n    assert_equal(14, candidate.call([1, 4, 9]))\n    assert_equal(0, candidate.call([]))\n    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n    assert_equal(0, candidate.call([0]))\n    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))\n    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))\n    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))\n    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))\n    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))\n  end\nend\n"},{"task_id":"HumanEval_143","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисоли 1: тартиби калимаҳо дар сатри нав бояд ҳамон тартиби аслии он бошад. ки дарозии он рақамҳои якум аст, ва шумо бояд сатри дорои калимаҳои ҷумлаи аслӣро баргардонед, ҷумла дорои калимаҳоест, ки бо фосила ҷудо карда шудаанд, Ба шумо сатр дода мешавад, ки як ҷумларо ифода мекунад, # >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n","canonical_solution":"def words_in_sentence(sentence)\n  def is_prime?(num)\n    return false if num <= 1\n    (2..Math.sqrt(num)).none? { |i| num % i == 0 }\n  end\n  \n  words = sentence.split(\" \")\n  prime_length_words = words.select { |word| is_prime?(word.length) }\n  prime_length_words.join(\" \")\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"))\n  end\nend\n"},{"task_id":"HumanEval_144","nl":"tgk_Cyrl","pl":"rb","prompt":"Шумо метавонед гумон кунед, ки x ва n харобахои дуруст хастанд, ва онхо ба унвони номинар сифр надоранд.<шумори>\/<шумори>, ки дар он ҳам шумора ва ҳам номгӯй ададҳои мусбати мусбат мебошанд. ҳам x ва ҳам n, намояндагии сатрии харобкунӣ мебошанд ва формати зерин доранд, x * n. Функсия true-ро бармегардонад, агар x * n ба адади куллӣ ва false  баробар бошад.Вазифаи шумо ин аст, ки функсияеро амалӣ кунед, ки ифодаро содда мекунад.# >>> simplify.call(\"1\/5\", \"5\/1\")\n# true\n# >>> simplify.call(\"1\/6\", \"2\/1\")\n# false\n# >>> simplify.call(\"7\/10\", \"10\/2\")\n# false\ndef simplify(x, n)\n","canonical_solution":"def simplify(x, n)\n  # Convert x and n to numerators and denominators\n  num_x, den_x = x.split('\/').map(&:to_i)\n  num_n, den_n = n.split('\/').map(&:to_i)\n\n  # Multiply fractions: (num_x * num_n) \/ (den_x * den_n)\n  numerator = num_x * num_n\n  denominator = den_x * den_n\n\n  # Check if the result is a whole number\n  numerator % denominator == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_simplify\n    candidate = method(:simplify)\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/6\", \"2\/1\"))\n    assert_equal(true, candidate.call(\"5\/1\", \"3\/1\"))\n    assert_equal(false, candidate.call(\"7\/10\", \"10\/2\"))\n    assert_equal(true, candidate.call(\"2\/10\", \"50\/10\"))\n    assert_equal(true, candidate.call(\"7\/2\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"11\/6\", \"6\/1\"))\n    assert_equal(false, candidate.call(\"2\/3\", \"5\/2\"))\n    assert_equal(false, candidate.call(\"5\/2\", \"3\/5\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"8\/4\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/5\", \"1\/5\"))\n  end\nend\n"},{"task_id":"HumanEval_145","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: онҳоро дар асоси индекси худ дар массиви аслӣ тартиб диҳед.Эзоҳ: агар якчанд ашё бо суммаи рақамҳои худ монанд бошанд, дар тартиби болоравӣ мувофиқи ҷамъбасти рақамҳои онҳо. Функсияеро нависед, ки массиви додашудаи ададҳои куллро тартиб диҳад # >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n","canonical_solution":"def order_by_points(nums)\n  nums.sort_by.with_index do |num, index|\n    [num.to_s.chars.map(&:to_i).sum.abs, index]\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"},{"task_id":"HumanEval_146","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: рақамҳои аввал ва охирини рақам нодир мебошанд (1, 3, 5, 7, 9).шумораи унсурҳои массив, ки аз 10 калонтаранд ва ҳарду Функсияе нависед, ки массиви ададҳоро ҳамчун вуруд ва бозгардонад # >>> specialFilter.call([15, -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\ndef specialFilter(nums)\n","canonical_solution":"def specialFilter(nums)\n  nums.count do |num|\n    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5, -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_147","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: ва a[i] + a[j] + a[k] як боркунии 3 аст.Шумораи секаратаи (a[i], a[j], a[k]) -и a-ро баргардонед, ки i < j < k, Барои ҳар як i (1 ≤ i ≤ n), арзиши a[i] = i * i - i + 1. Шумо ба шумо як адади мусбати n дода мешавад. Шумо бояд массиви ададҳои a-ро бо дарозии n эҷод кунед. # >>> get_max_triples.call(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\ndef get_max_triples(n)\n","canonical_solution":"def get_max_triples(n)\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  count = 0\n  \n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      (j+1...n).each do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n    assert_equal(53361, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_148","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо номҳои дурусти сайёраҳо нестанд.Функсия бояд массиви холиро баргардонад, агар planet1 ё planet2 наздикӣ ба офтоб.байни мадори сайёраи 1 ва мадори сайёраи 2 ҷойгир аст, ки аз рӯи Функсия бояд массиви дорои ҳамаи сайёраҳоеро, ки Функсияе нависед, ки ду номи сайёраро ҳамчун сатрҳои planet1 ва planet2 мегирад. Уран, Нептун.аст Меркурий, навбатии он Венус, сипас Замин, Марс, Юпитер, Сатурн, Дар системаи офтобии мо ҳашт сайёра мавҷуданд: наздиктарин ба Офтоб.# >>> bf.call(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf.call(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf.call(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\ndef bf(planet1, planet2)\n","canonical_solution":"def bf(planet1, planet2)\n  planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \n  idx1 = planets.index(planet1)\n  idx2 = planets.index(planet2)\n  \n  return [] if idx1.nil? || idx2.nil?\n\n  start_idx, end_idx = [idx1, idx2].sort\n  \n  planets[(start_idx + 1)...end_idx]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_bf\n    candidate = method(:bf)\n    assert_equal([\"Saturn\", \"Uranus\"], candidate.call(\"Jupiter\", \"Neptune\"))\n    assert_equal([\"Venus\"], candidate.call(\"Earth\", \"Mercury\"))\n    assert_equal([\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], candidate.call(\"Mercury\", \"Uranus\"))\n    assert_equal([\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], candidate.call(\"Neptune\", \"Venus\"))\n    assert_equal([], candidate.call(\"Earth\", \"Earth\"))\n    assert_equal([], candidate.call(\"Mars\", \"Earth\"))\n    assert_equal([], candidate.call(\"Jupiter\", \"Makemake\"))\n  end\nend\n"},{"task_id":"HumanEval_149","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: Шумо метавонед гумон кунед, ки ҳамаи калимаҳо дарозии якхела доранд.Функсия бояд массиви сатрҳоро бо тартиби тартиб дода баргардонад. Агар ду калима дарозии якхела дошта бошанд, массивро аз рӯи алифбо тартиб диҳед.бояд массиви аз рӯи ин қоида тартибдодашударо баргардонад. Тартиби массив бояд аз рӯи дарозии ҳар як калима боло равад, ва шумо ва он метавонад дубора бошад.Массив ҳамеша массиви сатрҳост ва ҳеҷ гоҳ массиви рақамҳо нест, ва массиви натиҷаи бо тартиби тартибдодашударо бармегардонад, сатрхои дарозии нобаробарро аз он хорич мекунад, Функсияе нависед, ки массиви сатрҳоро ҳамчун параметр қабул кунад, # >>> list_sort.call([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n","canonical_solution":"def list_sort(arr)\n  arr.select { |s| s.length.even? }\n     .sort_by { |s| [s.length, s] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\", \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"], candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"},{"task_id":"HumanEval_150","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: адади аввалия ва бояд арзиши y-ро баргардонад.Барномаи оддӣ, ки бояд арзиши x-ро баргардонад, агар n  бошад.# >>> x_or_y.call(7, 34, 12)\n# 34\n# >>> x_or_y.call(15, 8, 5)\n# 5\ndef x_or_y(n, x, y)\n","canonical_solution":"def x_or_y(n, x, y)\n  require 'prime'\n  n.prime? ? x : y\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_x_or_y\n    candidate = method(:x_or_y)\n    assert_equal(34, candidate.call(7, 34, 12))\n    assert_equal(5, candidate.call(15, 8, 5))\n    assert_equal(33, candidate.call(3, 33, 5212))\n    assert_equal(3, candidate.call(1259, 3, 52))\n    assert_equal(-1, candidate.call(7919, -1, 12))\n    assert_equal(583, candidate.call(3609, 1245, 583))\n    assert_equal(129, candidate.call(91, 56, 129))\n    assert_equal(1234, candidate.call(6, 34, 1234))\n    assert_equal(0, candidate.call(1, 2, 0))\n    assert_equal(2, candidate.call(2, 2, 0))\n  end\nend\n"},{"task_id":"HumanEval_151","nl":"tgk_Cyrl","pl":"rb","prompt":"Дар массив, ки нобаробар аст. рақамҳои манфӣ ё њамагироро нодида гиред.Бо назардошти массиви рақамҳо, ҷамъбасти квадрати рақамҳоро баргардонед # >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1, -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n# 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n","canonical_solution":"def double_the_difference(lst)\n  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }\n     .map { |n| n ** 2 }\n     .sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"},{"task_id":"HumanEval_152","nl":"tgk_Cyrl","pl":"rb","prompt":"мисол: арзиши 0 аст ва агар не, арзиши фарқи мутлақи байни тахмин ва хол аст. Массиви дарозии якхеларо баргардонед, ки нишон медиҳад, ки ҳар як тахмин то чӣ андоза дур аст. Агар онҳо дуруст тахмин зада бошанд, Ба шумо ду массиви холҳо ва тахминҳои дарозии баробар дода мешавад, ки ҳар як индекс мувофиқаро нишон медиҳад. Вазифаи шумо муайян кардани он аст, ки оё шахс натиҷаҳои як қатор бозиҳоро дуруст тахмин кардааст.бешубҳа ба қайд гирифтани ва муқоиса кардан арзанда аст. Дар ин лаҳза эҳсосоту фикрҳои шумо Ман фикр мекунам, ки ҳамаи мо он эҳсосотро дар хотир дорем, вақте ки натиҷаи баъзе аз интизориҳои тӯлонӣ# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\ndef compare(game, guess)\n","canonical_solution":"def compare(game, guess)\n  game.zip(guess).map { |score, prediction| (score - prediction).abs }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_153","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: (қувваи он -1) аст.return \"Slices.SErviNGSliCes\" чунки \"SErviNGSliCes\" пурзӯртарин васеъкунӣ аст васеъкунӣ: ['SErviNGSliCes', 'Cheese', 'StuFfed'] пас шумо бояд Масалан, агар ба шумо \"Slices\" ҳамчун синф ва массиви  дода шавад.Онро интихоб кунед, ки дар массив аввал пайдо мешавад.Агар ду ё зиёда васеъкунӣ бо ҳамон қувват бошад, шумо бояд формат: ClassName.StrongestExtensionName. Шумо бояд пайвастагии пурқувватро ёбед ва дар ин  string -ро баргардонед.дар номи васеъшавӣ, қувваи он бо фраксияи CAP - SM дода мешавад. ҳарфҳои номи васеъкунӣ ва SM бошад, ки шумораи ҳарфҳои хурд бошад қувваи васеъкунӣ чунин аст: Бигзор CAP рақами ҳарфи калон бошад Тавсеаҳо барои бор кардани синфҳои иловагӣ ба синф истифода мешаванд.Ба шумо номи синф (санҷ) ва массиви васеъшавӣ дода мешавад.# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n","canonical_solution":"def Strongest_Extension(class_name, extensions)\n  strongest_extension = extensions.max_by do |extension|\n    cap_count = extension.count('A-Z')\n    sm_count = extension.count('a-z')\n    cap_count - sm_count\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\", candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\", candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"_\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\", [\"671235\", \"Bb\"]))\n  end\nend\n"},{"task_id":"HumanEval_154","nl":"tgk_Cyrl","pl":"rb","prompt":"Ба шумо 2 калима дода мешавад. Шумо бояд true-ро баргардонед агар калимаи дуюм ё ягон гардиши он дар калимаи аввал субстринг бошад.# >>> cycpattern_check.call(\"abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n# >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n# >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a, b)\n","canonical_solution":"def cycpattern_check(a, b)\n  (0...b.length).each do |i|\n    rotated_b = b[i..-1] + b[0...i]\n    return true if a.include?(rotated_b)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true, candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"))\n  end\nend\n"},{"task_id":"HumanEval_155","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: Бо назардошти як адади мукаммал. массивро баргардонед, ки шумораи рақамҳои ҷуфт ва нобаробарро дорад. # >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n# [1, 2]\ndef even_odd_count(num)\n","canonical_solution":"def even_odd_count(num)\n  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"},{"task_id":"HumanEval_156","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо: Маҳдудиятҳо: 1 <= num <= 1000 ва онро бо ҳарфи хурд баргардонед.Бо додани адади мусбати мутлақ, муодили адади римӣ ҳамчун сатрро ба даст оред, # >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n# \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n","canonical_solution":"def int_to_mini_roman(number)\n  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n  result = ''\n  values.each_with_index do |value, index|\n    while number >= value\n      number -= value\n      result += numerals[index]\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"},{"task_id":"HumanEval_157","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: 90 дараҷа.Секунҷаи росткунҷа секунҷаест, ки дар он як кунҷ кунҷи рост аст ё тарафи секунҷаи росткунҷаро ташкил медиҳад, дар акси ҳол нодуруст аст.Бо назардошти дарозии се тарафи секунҷа. баргардонидани ҳақиқӣ агар се # >>> right_angle_triangle.call(3, 4, 5)\n# true\n# >>> right_angle_triangle.call(1, 2, 3)\n# false\ndef right_angle_triangle(a, b, c)\n","canonical_solution":"def right_angle_triangle(a, b, c)\n  sides = [a, b, c].sort\n  sides[0]**2 + sides[1]**2 == sides[2]**2\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_right_angle_triangle\n    candidate = method(:right_angle_triangle)\n    assert_equal(true, candidate.call(3, 4, 5))\n    assert_equal(false, candidate.call(1, 2, 3))\n    assert_equal(true, candidate.call(10, 6, 8))\n    assert_equal(false, candidate.call(2, 2, 2))\n    assert_equal(true, candidate.call(7, 24, 25))\n    assert_equal(false, candidate.call(10, 5, 7))\n    assert_equal(true, candidate.call(5, 12, 13))\n    assert_equal(true, candidate.call(15, 8, 17))\n    assert_equal(true, candidate.call(48, 55, 73))\n    assert_equal(false, candidate.call(1, 1, 1))\n    assert_equal(false, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_158","nl":"tgk_Cyrl","pl":"rb","prompt":"аломатҳо, он чизеро, ки дар тартиби лексикографӣ аввал меояд, баргардонед. аз аломатҳои ягона. Агар сатрҳои сершумор шумораи ҳадди аксар аломатҳои ягона дошта бошанд Массив дорои калимаҳои гуногун аст. Калимаро бо шумораи Функсияе нависед, ки массиви сатрҳоро қабул кунад. # >>> find_max.call([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n","canonical_solution":"def find_max(words)\n  # Helper function to count unique characters\n  def unique_char_count(word)\n    word.chars.uniq.size\n  end\n\n  words.max_by { |word| [unique_char_count(word), -word] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n  end\nend\n"},{"task_id":"HumanEval_159","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисол: агар шумо ба қадри кофӣ моркро нахӯред, шумо тамоми моркро мехӯред, аммо ҳанӯз гурусна хоҳед монд.шумораи морчаҳои баъди хӯрокхӯрӣ боқӣ мондашуда] шумо бояд як қатор [шумораи умумии моркро пас аз хӯрокхӯрӣ, Аммо акнун барои пурра хӯрдани хӯроки ҳаррӯза шумо бояд бештар моркро бихӯред.Ту як харгӯши гурусна ҳастӣ ва шумо аллакай як миқдори муайяни моркро хӯрдед,# >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1, 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number, need, remaining)\n","canonical_solution":"def eat(number, need, remaining)\n  total_eaten = number + [need, remaining].min\n  carrots_left = [remaining - need, 0].max\n  [total_eaten, carrots_left]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1, 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9, 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n  end\nend\n"},{"task_id":"HumanEval_160","nl":"tgk_Cyrl","pl":"rb","prompt":"Массиви оператор ҳадди аққал як оператор ва массиви операнд ҳадди аққал ду операнд дорад. Операнд массиви ададҳои мукаммали ғайри манфӣ мебошад.Дарозии массиви оператор ба дарозии массиви операнд минус як баробар аст.Эзоҳ: => натиҷа = 9 натиҷа = 2 + 3 * 4 - 5 массив = [2, 3, 4, 5] оператор['+', '*', '-'] Мисол: Экспонентатсия (**) Бахши ошёна ( \/\/ ) Баландшавӣ (*) Тахфиф ( - ) Иловакунӣ (+) Амалиёти асосии алгебра: ифода ва баҳодиҳии ин ифодаро баргардонед. массиви дуюм массиви ададҳои бутун аст. Барои сохтани алгебраи Бо назардошти ду оператори массив ва операнда. Массиви аввал амалиёти асосии алгебра дорад, ва def do_algebra(operator, operand)\n","canonical_solution":"def do_algebra(operator, operand)\n  expression = operand[0].to_s\n  operator.each_with_index do |op, index|\n    if op == '\/\/'\n      expression += ' \/ ' + operand[index + 1].to_s\n    else\n      expression += ' ' + op + ' ' + operand[index + 1].to_s\n    end\n  end\n  eval(expression)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\", \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\", \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"\/\/\", \"*\"], [7, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_161","nl":"tgk_Cyrl","pl":"rb","prompt":"Мисолҳо Функсия бояд сатри натиҷаро баргардонад. Агар сатр ҳарфҳо надошта бошад, сатрро баръакс кунед.вагарна онро ҳамон тавре, ки ҳаст, нигоҳ доред.агар s[i] ҳарф бошад, пас аз поён ба боло ё баръакс, Ба шумо сатри s дода мешавад. # >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n","canonical_solution":"def solve(s)\n  if s =~ \/[a-zA-Z]\/\n    s.chars.map { |char| char =~ \/[a-zA-Z]\/ ? char.swapcase : char }.join\n  else\n    s.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\", candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"#$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"},{"task_id":"HumanEval_162","nl":"tgk_Cyrl","pl":"rb","prompt":"Агар 'text' сатри холӣ бошад, nil-ро баргардонед. Дар сурати гирифтани сатри 'text', сатри муодили хеш md5-и онро баргардонед. # >>> string_to_md5.call(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n","canonical_solution":"require 'digest'\n\ndef string_to_md5(text)\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\", candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"))\n  end\nend\n"},{"task_id":"HumanEval_163","nl":"tgk_Cyrl","pl":"rb","prompt":"Масалан: ва б, дар тартиби болоравӣ. Бо назардошти ду адади мусбати а ва b, рақамҳои ҷуфтро байни a  баргардонед.# >>> generate_integers.call(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10, 14)\n# []\ndef generate_integers(a, b)\n","canonical_solution":"def generate_integers(a, b)\n  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2, 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2, 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n  end\nend\n"}]